// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "ash/accelerators/accelerator_dispatcher.h"

#include "ash/accelerators/accelerator_controller.h"
#include "ash/shell.h"
#include "ui/aura/window_event_dispatcher.h"
#include "ui/base/accelerators/accelerator.h"
#include "ui/events/event.h"
#include "ui/events/event_constants.h"
#include "ui/events/event_utils.h"
#include "ui/views/controls/menu/menu_controller.h"

namespace ash {
namespace {

bool IsPossibleAcceleratorNotForMenu(const ui::KeyEvent& key_event) {
  // For shortcuts generated by Ctrl or Alt plus a letter, number or
  // the tab key, we want to exit the context menu first and then
  // repost the event. That allows for the shortcut execution after
  // the context menu has exited.
  if (key_event.type() == ui::ET_KEY_PRESSED &&
      (key_event.flags() & (ui::EF_CONTROL_DOWN | ui::EF_ALT_DOWN))) {
    const ui::KeyboardCode key_code = key_event.key_code();
    if ((key_code >= ui::VKEY_A && key_code <= ui::VKEY_Z) ||
        (key_code >= ui::VKEY_0 && key_code <= ui::VKEY_9) ||
        (key_code == ui::VKEY_TAB)) {
      return true;
    }
  }
  return false;
}

}  // namespace

bool AcceleratorDispatcher::MenuClosedForPossibleAccelerator(
    const ui::KeyEvent& key_event) {
  if (!IsPossibleAcceleratorNotForMenu(key_event))
    return false;

  if (views::MenuController* menu_controller =
          views::MenuController::GetActiveInstance()) {
    menu_controller->CancelAll();
    return true;
  }
  return false;
}

bool AcceleratorDispatcher::AcceleratorProcessedForKeyEvent(
    const ui::KeyEvent& key_event) {
  ash::AcceleratorController* accelerator_controller =
      ash::Shell::GetInstance()->accelerator_controller();
  if (!accelerator_controller)
    return false;
  const int kModifierMask =
      (ui::EF_SHIFT_DOWN | ui::EF_CONTROL_DOWN | ui::EF_ALT_DOWN);
  ui::Accelerator accelerator(key_event.key_code(),
                              key_event.flags() & kModifierMask);
  if (key_event.type() == ui::ET_KEY_RELEASED)
    accelerator.set_type(ui::ET_KEY_RELEASED);
  // Fill out context object so AcceleratorController will know what
  // was the previous accelerator or if the current accelerator is repeated.
  Shell::GetInstance()->accelerator_controller()->context()->UpdateContext(
      accelerator);
  return accelerator_controller->Process(accelerator);
}

}  // namespace ash
