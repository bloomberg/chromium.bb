// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module ash.mojom;

import "ash/public/interfaces/user_info.mojom";
import "components/signin/public/interfaces/account_id.mojom";
import "mojo/common/time.mojom";

// Matches session_manager::SessionState.
enum SessionState {
  // Default value, when session state hasn't been initialized yet.
  UNKNOWN,

  // Running out of box UI.
  OOBE,

  // Running login UI (primary user) but user sign in hasn't completed yet.
  LOGIN_PRIMARY,

  // Running login UI (primary or secondary user), user sign in has been
  // completed but login UI hasn't been hidden yet. This means that either
  // some session initialization is happening or user has to go through some
  // UI flow on the same login UI like select avatar, agree to terms of
  // service etc.
  LOGGED_IN_NOT_ACTIVE,

  // A user(s) has logged in *and* login UI is hidden i.e. user session is
  // not blocked.
  ACTIVE,

  // The session screen is locked.
  LOCKED,

  // Same as SESSION_STATE_LOGIN_PRIMARY but for multi-profiles sign in i.e.
  // when there's at least one user already active in the session.
  LOGIN_SECONDARY,
};

// Matches ash::CycleUserDirection.
enum CycleUserDirection {
  NEXT,  // Cycle to the next user.
  PREVIOUS,  // Cycle to the previous user.
};

// Info about a user session in ash. May be sent repeatedly for a single user
// because individual fields may change (e.g. the avatar image or custodians).
struct UserSession {
  // A user session id for the user session. It is generated by session manager
  // (chrome) when a user session starts and never changes during the lifetime
  // of the session manager. The number starts at 1 for the first user session
  // and incremented by one for each subsequent user session.
  uint32 session_id;

  // Contains general user information state, like the account id, display name,
  // and avatar.
  UserInfo user_info;

  // For supervised users only, the email address of the custodian account.
  // Empty for non-supervised users. Available after profile is loaded.
  string custodian_email;

  // For supervised users only, the email address of the second custodian
  // account, if any. Available after profile is loaded.
  string second_custodian_email;

  // Whether the settings icon should be enabled in the system tray menu.
  // Usually true after login, but can be false for specialized user sessions
  // (e.g. adding supervised users).
  bool should_enable_settings;

  // Similar to |should_show_settings| but for the notification tray.
  bool should_show_notification_tray;
};

// Matches ash::AddUserSessionPolicy.
enum AddUserSessionPolicy {
  // Adding a user session is allowed.
  ALLOWED,

  // Disallowed due to primary user's policy.
  ERROR_NOT_ALLOWED_PRIMARY_USER,

  // Disallowed due to no eligible users.
  ERROR_NO_ELIGIBLE_USERS,

  // Disallowed due to reaching maximum supported user.
  ERROR_MAXIMUM_USERS_REACHED,
};

// Info about an ash session.
struct SessionInfo {
  // Whether the screen can be locked.
  bool can_lock_screen;

  // Whether the screen should be locked automatically before suspending.
  bool should_lock_screen_automatically;

  // Whether the session is in app mode, which includes a kiosk-like mode for
  // fullscreen web content or running a single [forced] Chrome or ARC app.
  bool is_running_in_app_mode;

  // Sets whether adding a user session to ash is allowed.
  AddUserSessionPolicy add_user_session_policy;

  // Current state of the ash session.
  SessionState state;
};

// Interface for ash client (e.g. Chrome) to set session info for ash.
interface SessionController {
  // Sets the client interface.
  SetClient(SessionControllerClient client);

  // Sets the ash session info.
  SetSessionInfo(SessionInfo info);

  // Updates a user session. This is called when a user session is added or
  // its meta data (e.g. name, avatar) is changed. There is no method to remove
  // a user session because ash/chrome does not support that. All users are
  // logged out at the same time.
  UpdateUserSession(UserSession user_session);

  // Sets the order of user sessions. The order is keyed by the session id.
  // Currently, session manager set a LRU order with the first one being the
  // active user session.
  SetUserSessionOrder(array<uint32> user_session_ids);

  // Prepares ash for lock screen. Currently this ensures the current active
  // window could not be used to mimic the lock screen. Lock screen is created
  // after this call returns.
  PrepareForLock() => ();

  // Runs the pre-lock animation to start locking ash. When the call returns,
  // |locked| == true means that the ash post-lock animation is finished and ash
  // is fully locked. Otherwise |locked| is false, which means something is
  // wrong for the lock and ash is not locked. When the call returns with a true
  // |locked|, screen locker runs the post lock jobs such as a11y announcement
  // etc. Invoked by the screen locker during initialization.
  StartLock() => (bool locked);

  // Notifies ash that chrome lock animations are finished. This is the last
  // event for locking. SessionController forwards it to PowerEventObserver.
  NotifyChromeLockAnimationsComplete();

  // Runs the pre-unlock animation. Invoked by the screen locker before
  // dismissing. When the mojo call returns, screen locker takes that as a
  // signal of finished unlock animation and dismisses itself.
  RunUnlockAnimation() => ();

  // Notifies that chrome is terminating.
  NotifyChromeTerminating();

  // Adds a countdown timer to the system tray menu and creates or updates a
  // notification saying the session length is limited (e.g. a public session in
  // a library). Setting |length_limit| to zero removes the notification.
  // NOTE: Chrome enforces the limit, not ash. Ash could enforce it if local
  // state prefs and user activity monitoring were available under mustash.
  // http://crbug.com/729808
  SetSessionLengthLimit(mojo.common.mojom.TimeDelta length_limit,
                        mojo.common.mojom.TimeTicks start_time);

  // Returns whether it's ok to switch the active multiprofile user. May affect
  // or be affected by system state such as window overview mode and screen
  // casting.
  CanSwitchActiveUser() => (bool can_switch);

  // Shows a dialog to explain the implications of signing in multiple users.
  // If |on_accept| is false, |permanently_accept| is ignored.
  ShowMultiprofilesIntroDialog() => (bool on_accept, bool permanently_accept);

  // Shows a dialog to confirm that the user wants to teleport a window to
  // another desktop. If |on_accept| is false, |permanently_accept| is ignored.
  ShowTeleportWarningDialog() => (bool on_accept, bool permanently_accept);

  // Shows a dialog that explains that the given user is no longer allowed in
  // the session due to a policy change, and aborts the session.
  ShowMultiprofilesSessionAbortedDialog(string user_email);
};

// Interface for ash to request session service from its client (e.g. Chrome).
interface SessionControllerClient {
  // Requests to lock screen.
  RequestLockScreen();

  // Requests signing out all users, ending the current session.
  RequestSignOut();

  // Switch to the active user with |account_id| (if the user has already signed
  // in).
  SwitchActiveUser(signin.mojom.AccountId account_id);

  // Switch the active user to the next or previous user.
  CycleActiveUser(CycleUserDirection direction);

  // Show the multi-profile login UI to add another user to this session.
  ShowMultiProfileLogin();
};
