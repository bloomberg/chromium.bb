
KEYWORDS:

Wayland is a nano display server, relying on drm modesetting, gem
batchbuffer submission and hw initialization generally in the kernel.
Wayland puts the compositing manager and display server in the same
process.  Window management is largely pushed to the clients, they
draw their own decorations and move and resize themselves, typically
implemented in a toolkit library.  More of the core desktop could be
pushed into wayland, for example, stock desktop components such as the
panel or the desktop background.

The actual compositor will define a fair bit of desktop policy and it
is expected that different use cases (desktop environments, devices,
appliances) will provide their own custom compositor.

It is still designed with a windowed type of desktop in mind, as
opposed to fullscreen-all-the-time type of interface, but should be
useful wherever several processes contribute content to be composited.

Current trends goes towards less and less rendering in X server, more
hardware setup and management in kernel and shared libraries allow
code sharing without putting it all in a server.  freetype,
fontconfig, cairo all point in this direction, as does direct
rendering mesa.

Client allocates DRM buffers, draws decorations, and full window
contents and posts entire thing to server along with dimensions.

Everything is direct rendered and composited.  No cliprects, no
drawing api/protocl between server and client.  No
pixmaps/windows/drawables, only surfaces (essentially pixmaps).  No
gcs/fonts, no nested windows.  OpenGL is already direct rendered,
pixman may be direct rendered which adds the cairo API, or cairo
may gain a GL backend.

Could be a "shell" for launching gdm X server, user session servers,
safe mode xservers, graphics text console.  From gdm, we could also
launch a rdp session, solid ice sessions.  

All surface commands (copy, attach, map=set quads) are buffered until
the client sends a commit command, which executes everything
atomically.  The commit command includes a cookie, which will be
returned in an event generated by the server once the commit has been
executed.  This allows clients to throttle themselves against the
server and implement smooth animations.


ISSUES:

Include panel and desktop background in wayland?

How does clients move their surfaces? set a full tri-mesh every time?

How does the server apply transformations to a surface behind the
clients back? (wobbly, minimize, zoom)  Maybe wobble is client side?

How do apps share the glyph cache?

Input handling - keyboard focus, multiple input devices, multiple
pointers, multi touch.

Drawing cursors, moving them, cursor themes, attaching surfaces to
cursors.  How do you change cursors when you mouse over a text
field if you don't have subwindows?

synaptics, 3-button emulation, xkb, scim

changing screen resolution, adding monitors.

What to do when protocol out buffer fills up?  Just block on write
would work I guess.  Clients are supposed to throttle using the bread
crumb events, so we shouldn't get into this situation.

When a surface is the size of the screen and on top, we can set the
scanout buffer to that surface directly.  Like compiz unredirect
top-level window feature.  Except it won't have any protocol state
side-effects and the client that owns the surface won't know.  We lose
control of updates.  Should work well for X server root window under
wayland.

Throttling/scheduling - there is currently no mechanism for scheduling
clients to prevent greedy clients from spamming the server and
starving other clients.  On the other hand, now that recompositing is
done in the idle handler (and eventually at vertical retrace time),
there's nothing a client can do to hog the server.  Unless we include
a copyregion type request, to let a client update it's surface
contents by asking the server to atomically copy a region from some
other buffer to the surface buffer.

Atomicity - we have the map and the attach requests which sometimes
will have to be executed atomically.  Moving the window is done using
the map request and will not involve an attach requet.  Updating the
window contents will use an attach request but no map.  Resizing,
however, will use both and in that case must be executed atomically.
One way to do this is to have the server always batch up requests and
then introduce a kind of "commit" request, which will push the batched
changes into effect.  This is easier than it sounds, since we only
have to remember the most recent map and most recent attach.  The
commit request will generate an corresponding commit event once the
committed changes become visible on screen.  The client can provide a
bread-crumb id in the commit request, which will be sent back in the
commit event.

 - is batching+commit per client or per surface?  Much more convenient
   if per-client, since a client can batch up a bunch of stuff and get
   atomic updates to multiple windows.  Also nice to only get one
   commit event for changes to a bunch of windows.  Is a little more
   tricky server-side, since we now have to keep a list of windows
   with pending changes in the wl_client struct.

 - batching+commit also lets a client reuse parts of the surface
   buffer without allocating a new full-size back buffer.  For
   scrolling, for example, the client can render just the newly
   exposed part of the page to a smaller temporary buffer, then issue
   a copy request to copy the preserved part of the page up, and the
   new part of the page into the exposed area.

 - This does let a client batch up an uncontrolled amount of copy
   requests that the server has to execute when it gets the commit
   request.  This could potentially lock up the server for a while,
   leading to lost frames.  Should never cause tearing though, we're
   changing the surface contents, not the server back buffer which is
   what is scheduled for blitting at vsync time.


RMI

The wayland protocol is a async object oriented protocol.  All
requests are method invocations on some object.  The request include
an object id that uniquely identifies an object on the server.  Each
object implements an interface and the requests include an opcode that
identifies which method in the interface to invoke.

The server sends back events to the client, each event is emitted from
an object.  Events can be error conditions.  The event includes the
object id and the event opcode, from which the client can determine
the type of event.  Events are generated both in repsonse to a request
(in which case the request and the event constitutes a round trip) or
spontanously when the server state changes.

the get_interface method is called on an object to get an object
handle that implements the specified interface.


EMBEDDING OTHER WINDOWS

X11 lets clients embed windows from other clients other copy pixmap
contents rendered by another client into their window.  This is often
used for applets in a panel, browser plugins and similar.  Wayland
doesn't directly allow this, but clients can communicate GEM buffer
names out-of-band, for example, using d-bus or as command line
arguments when the panel launches the applet.  Another option is to
use a nested wayland instance.  For this, the wayland server will have
to be a library that the host application links to.  The host
application will then pass the wayland server socket name to the
embedded application, and will need to implement the wayland
compositor interface.  The host application composites the client
surfaces as part of it's window, that is, in the web page or in the
panel.  The benefit of nesting the wayland server is that it provides
the requests the embedded client needs to inform the host about buffer
updates and a mechanism for forwarding input events from the host
application.
