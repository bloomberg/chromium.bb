// This file is generated

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef HEADLESS_PUBLIC_DOMAINS_{{domain.domain | camelcase_to_hacker_style | upper}}_H_
#define HEADLESS_PUBLIC_DOMAINS_{{domain.domain | camelcase_to_hacker_style | upper}}_H_

#include "base/callback.h"
#include "base/observer_list.h"
#include "base/values.h"
#include "headless/public/domains/types.h"
#include "headless/public/headless_export.h"
#include "headless/public/internal/message_dispatcher.h"

namespace headless {
namespace {{domain.domain | camelcase_to_hacker_style}} {
{% if "events" in domain %}
class Observer {
 public:
  virtual ~Observer() {}
  {% for event in domain.events %}
  virtual void On{{event.name | to_title_case}}(const {{event.name | to_title_case}}Params& params) {}
  {% endfor %}
};
{% endif %}

{% if domain.description %}
// {{domain.description}}
{% endif %}
class HEADLESS_EXPORT Domain {
 public:
  Domain(internal::MessageDispatcher* dispatcher);
  ~Domain();

  {% if "events" in domain %}
  // Add or remove an observer. |observer| must be removed before being
  // destroyed.
  void AddObserver(Observer* observer);
  void RemoveObserver(Observer* observer);
  {% endif %}

  {# Generate methods for each command. #}
  {% for command in domain.commands %}
    {# Skip redirected commands. #}
    {% if "redirect" in command %}{% continue %}{% endif %}
    {% set method_name = command.name | to_title_case %}
    {% if command.description %}
  // {{ command.description }}
    {% endif %}
    {% if "parameters" in command and "returns" in command %}
  void {{method_name}}(std::unique_ptr<{{method_name}}Params> params, base::Callback<void(std::unique_ptr<{{method_name}}Result>)> callback = base::Callback<void(std::unique_ptr<{{method_name}}Result>)>());
    {% elif "parameters" in command %}
  void {{method_name}}(std::unique_ptr<{{method_name}}Params> params, base::Callback<void()> callback = base::Callback<void()>());
    {% elif "returns" in command %}
  void {{method_name}}(base::Callback<void(std::unique_ptr<{{method_name}}Result>)> callback = base::Callback<void(std::unique_ptr<{{method_name}}Result>)>());
    {% else %}
  void {{method_name}}(base::Callback<void()> callback = base::Callback<void()>());
    {% endif %}
    {# Generate convenience methods that take the required parameters directly. #}
    {% if not "parameters" in command %}{% continue %}{% endif %}
  void {{method_name}}({##}
  {% for parameter in command.parameters -%}
      {% if parameter.get("optional", False) -%}
        {% break %}
      {% endif %}
      {% if not loop.first %}, {% endif %}
{{resolve_type(parameter).pass_type}} {{parameter.name | camelcase_to_hacker_style -}}
    {% endfor %}
    {% if "parameters" in command and not command.parameters[0].get("optional", False) %}, {% endif %}{# -#}
    {% if "returns" in command -%}
      base::Callback<void(std::unique_ptr<{{method_name}}Result>)> callback = base::Callback<void(std::unique_ptr<{{method_name}}Result>)>(){##}
    {% else -%}
      base::Callback<void()> callback = base::Callback<void()>(){##}
    {% endif %});
  {% endfor %}
 private:
  {# Generate response handlers for commands that need them. #}
  {% for command in domain.commands %}
    {% if not "returns" in command %}{% continue %}{% endif %}
    {% set method_name = command.name | to_title_case %}
  static void Handle{{method_name}}Response(base::Callback<void(std::unique_ptr<{{method_name}}Result>)> callback, const base::Value& response);
  {% endfor %}

  {# Generate event dispatchers. #}
  {% for event in domain.events %}
  void Dispatch{{event.name | to_title_case}}Event(const base::Value& params);
  {% endfor %}

  internal::MessageDispatcher* dispatcher_;  // Not owned.
  {% if "events" in domain %}
  base::ObserverList<Observer> observers_;
  {% endif %}

  DISALLOW_COPY_AND_ASSIGN(Domain);
};

}  // namespace {{domain.domain | camelcase_to_hacker_style}}
}  // namespace headless

#endif  // HEADLESS_PUBLIC_DOMAINS_{{domain.domain | camelcase_to_hacker_style | upper}}_H_
