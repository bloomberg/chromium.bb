{%- import "struct_macros.tmpl" as struct_macros %}
{%- set data_view = struct|get_qualified_name_for_kind ~ "DataView" %}
{%- set data_type = struct|get_qualified_name_for_kind(internal=True) %}

namespace internal {

template <typename MaybeConstUserType>
struct Serializer<{{data_view}}, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<{{data_view}}, UserType>;

  static void PrepareToSerialize(MaybeConstUserType& input,
                                 SerializationContext* context) {
{# NOTE: Only types which may (recursively) contain handles or interface types
   need to do any preparation for serialization. We don't bother in other cases,
   and nullability testing and context setup can instead be done directly in
   Serialize below. #}
{%- if struct|contains_handles_or_interfaces %}
    const bool is_null = CallIsNullIfExists<Traits>(input);
    context->PushNextNullState(is_null);
    if (is_null)
      return;

    void* custom_context = CustomContextHelper<Traits>::SetUpAndPush(input,
                                                                     context);
    ALLOW_UNUSED_LOCAL(custom_context);

    {{struct_macros.prepare_to_serialize(
          struct, "CallWithContext(Traits::%s, input, custom_context)",
          "context", True)|indent(2)}}
{%- endif %}
  }

  static void Serialize(MaybeConstUserType& input,
                        Buffer* buffer,
                        {{data_type}}::BufferWriter* output,
                        SerializationContext* context) {
{%- if struct|contains_handles_or_interfaces %}
    if (context->IsNextFieldNull())
      return;
    void* custom_context = CustomContextHelper<Traits>::GetNext(context);
{%- else %}
    if (CallIsNullIfExists<Traits>(input))
      return;
    void* custom_context = CustomContextHelper<Traits>::SetUp(input, context);
{%- endif %}
    {{struct_macros.serialize(
          struct, struct.name ~ " struct",
          "CallWithContext(Traits::%s, input, custom_context)", "(*output)",
          "buffer", "context", True)|indent(2)}}

    CustomContextHelper<Traits>::TearDown(input, custom_context);
  }

  static bool Deserialize({{data_type}}* input,
                          UserType* output,
                          SerializationContext* context) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    {{data_view}} data_view(input, context);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal
