// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module ui.mojom;

import "mojo/public/mojom/base/time.mojom";
import "ui/events/mojo/event_constants.mojom";
import "ui/events/mojo/keyboard_codes.mojom";
import "ui/gfx/geometry/mojo/geometry.mojom";
import "ui/latency/mojo/latency_info.mojom";

struct KeyData {
  // The chromium event key code; these values are from the ui/ KeyCode enum,
  // which has the fun property of being neither consistently the Windows key
  // code, nor the X11 keycodes. (This value is consistent across platforms
  // for basic ASCII characters; it will differ for modifiers. We don't define
  // this as a mojo enum because mojom doesn't appear to have a platform
  // dependent preprocessor yet.)
  //
  // TODO(erg): Remove this, and declare Win32 keycodes correct by fiat. We can
  // not do this until we remove ui::Event usage from within mojo.
  int32 key_code;

  // Whether this is a character event, and the character value if it is. Note
  // that this is different than |text|, which holds a value even when there
  // isn't actually a character to insert. (For example, |text| will be set and
  // have a value on backspace, and |character| won't.)
  bool is_char;
  uint16 character;

  // The Win32 key code. Because of the web, this is the closest thing that we
  // have to a cross platform key state.
  KeyboardCode windows_key_code;

  // The platform specific key code.
  //
  // TODO(erg): This exists only for NPAPI support, pepper USB keyboard support
  // and IME on android support. Theoretically, we should be able to remove this
  // in the medium to long term.
  int32 native_key_code;

  // The text generated by this keystroke. Corresponds to
  // blink::WebKeyboardEvent::text.
  uint16 text;

  // Like |text|, but unmodified by concurrently held modifier keys (except
  // shift). Corresponds to blink::WebKeyboardEvent::unmodifiedText.
  uint16 unmodified_text;
};

struct LocationData {
  // |relative_location| is in the coordinate system of the target and in DIPs.
  gfx.mojom.PointF relative_location;
  // |root_location| is relative to the client's root and in dips.
  gfx.mojom.PointF root_location;
};

// Data to support gesture events.
// TODO(crbug.com/767087): Expand GestureEvent and GestureEventDetails support.
struct GestureData {
  LocationData location;
};

// Data to support scroll events.
struct ScrollData {
  LocationData location;

  // Potential accelerated offsets.
  float x_offset;
  float y_offset;
  // Unaccelerated offsets.
  float x_offset_ordinal;
  float y_offset_ordinal;
  // Number of fingers on the pad.
  int32 finger_count;

  // For non-fling events, provides momentum information (e.g. for the case
  // where the device provides continuous event updates during a fling).
  EventMomentumPhase momentum_phase;

  // Provides phase information if device can provide.
  ScrollEventPhase scroll_event_phase;
};

// This mirrors the C++ class of the same name, see it for details.
struct PointerDetails {
  PointerKind pointer_type;
  float radius_x;
  float radius_y;
  float force;
  float tilt_x;
  float tilt_y;
  float tangential_pressure;
  float twist;
  int32 id;
  int32 offset_x;
  int32 offset_y;
};

struct MouseData {
  int32 changed_button_flags;
  LocationData location;
  PointerDetails pointer_details;
  // Only used for mouse wheel.
  gfx.mojom.Vector2d wheel_offset;
};

// This is used for TouchEvents.
struct TouchData {
  bool may_cause_scrolling;
  bool hovering;
  LocationData location;
  PointerDetails pointer_details;
};

struct Event {
  // TODO(sky): rename to type.
  EventType action;
  // A bitfield of kEventFlag* and kMouseEventFlag* values in
  // input_event_constants.mojom.
  int32 flags;
  // This value accurately orders events w.r.t. to each other but does not
  // position them at an absolute time since the TimeTicks origin is only
  // guaranteed to be fixed during one instance of the application.
  mojo_base.mojom.TimeTicks time_stamp;
  LatencyInfo latency;
  KeyData? key_data;
  GestureData? gesture_data;
  ScrollData? scroll_data;
  TouchData? touch_data;
  MouseData? mouse_data;
  map<string, array<uint8>>? properties;
};
