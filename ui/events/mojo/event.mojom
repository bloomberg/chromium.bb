// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module ui.mojom;

import "mojo/public/mojom/base/time.mojom";
import "ui/events/mojo/event_constants.mojom";
import "ui/events/mojo/keyboard_codes.mojom";
import "ui/latency/mojo/latency_info.mojom";

struct KeyData {
  // The chromium event key code; these values are from the ui/ KeyCode enum,
  // which has the fun property of being neither consistently the Windows key
  // code, nor the X11 keycodes. (This value is consistent across platforms
  // for basic ASCII characters; it will differ for modifiers. We don't define
  // this as a mojo enum because mojom doesn't appear to have a platform
  // dependent preprocessor yet.)
  //
  // TODO(erg): Remove this, and declare Win32 keycodes correct by fiat. We can
  // not do this until we remove ui::Event usage from within mojo.
  int32 key_code;

  // Whether this is a character event, and the character value if it is. Note
  // that this is different than |text|, which holds a value even when there
  // isn't actually a character to insert. (For example, |text| will be set and
  // have a value on backspace, and |character| won't.)
  bool is_char;
  uint16 character;

  // The Win32 key code. Because of the web, this is the closest thing that we
  // have to a cross platform key state.
  KeyboardCode windows_key_code;

  // The platform specific key code.
  //
  // TODO(erg): This exists only for NPAPI support, pepper USB keyboard support
  // and IME on android support. Theoretically, we should be able to remove this
  // in the medium to long term.
  int32 native_key_code;

  // The text generated by this keystroke. Corresponds to
  // blink::WebKeyboardEvent::text.
  uint16 text;

  // Like |text|, but unmodified by concurrently held modifier keys (except
  // shift). Corresponds to blink::WebKeyboardEvent::unmodifiedText.
  uint16 unmodified_text;

  // Mirrors KeyEvent::properties_.
  map<string, array<uint8>>? properties;
};

struct LocationData {
  // |x| and |y| are in the coordinate system of the View.
  // Typically, this will be an integer-valued translation w.r.t.
  // the screen and in this case, |x| and |y| are in units of physical
  // pixels. However, some View embedders may apply arbitrary transformations
  // of a view w.r.t. the screen.
  float x;
  float y;
  // |screen_x| and |screen_y| are in screen coordinates in units of
  // physical pixels.
  float screen_x;
  float screen_y;
};

// TODO(rjkroege,sadrul): Add gesture representation.
struct PointerData {
  int32 pointer_id;
  int32 changed_button_flags;
  PointerKind kind;
  LocationData location;
  // Some devices (e.g. pen, finger) can extend across multiple pixels
  // at once. |brush_data| provides additional data for this case and
  // is available when |kind| is PEN or TOUCH.
  BrushData? brush_data;
  // Only set for |WHEEL| events.
  WheelData? wheel_data;
};

// Information payload to support
// https://developer.mozilla.org/en-US/docs/Web/Events/wheel.
// TODO(rjkroege): Handle MacOS momentum scrolling.
struct WheelData {
  WheelMode mode;
  // |delta_x|, |delta_y|, |delta_z| can be in units of pixels, lines, pages
  // or control scaling as controlled by |mode|. Pixel scroll is physical
  // pixels in the coordinate system of the target View.
  float delta_x;
  float delta_y;
  float delta_z;
};

// Supplementary data to support pointers where the pointer can
// cover multiple pixels per http://www.w3.org/TR/pointerevents/
struct BrushData {
  // |width| and |height| are in CSS pixels in the coordinate system of
  // the target View.
  float width;
  float height;
  // |pressure| range is [0,1]. For devices like mice buttons where the
  // pressure is not available, it will be set to 0.5 if the button is down.
  float pressure;
  // |tilt_x| and |tilt_y| are in degrees. See comments in ui::PointerDetails
  // for more information.
  float tilt_x;
  float tilt_y;
  // The normalized tangential pressure (or barrel pressure), typically set by
  // an additional control of the stylus, which has a range of [-1,1], where 0
  // is the neutral position of the control. Always 0 if the device does not
  // support it.
  float tangential_pressure;
  // The clockwise rotation of a pen stylus around its own major axis, in
  // degrees in the range [0,359]. Always 0 if the device does not support it.
  int32 twist;
};

// Data to support gesture events.
// TODO(crbug.com/767087): Expand GestureEvent and GestureEventDetails support.
struct GestureData {
  LocationData location;
};

// Data to support scroll events.
struct ScrollData {
  LocationData location;

  // Potential accelerated offsets.
  float x_offset;
  float y_offset;
  // Unaccelerated offsets.
  float x_offset_ordinal;
  float y_offset_ordinal;
  // Number of fingers on the pad.
  int32 finger_count;

  // For non-fling events, provides momentum information (e.g. for the case
  // where the device provides continuous event updates during a fling).
  EventMomentumPhase momentum_phase;

  // Provides phase information if device can provide.
  ScrollEventPhase scroll_event_phase;
};

struct Event {
  // TODO(sky): rename to type.
  EventType action;
  // A bitfield of kEventFlag* and kMouseEventFlag* values in
  // input_event_constants.mojom.
  //
  // TODO(sky): parts of this should move to PointerData.
  int32 flags;
  // This value accurately orders events w.r.t. to each other but does not
  // position them at an absolute time since the TimeTicks origin is only
  // guaranteed to be fixed during one instance of the application.
  mojo_base.mojom.TimeTicks time_stamp;
  LatencyInfo latency;
  KeyData? key_data;
  PointerData? pointer_data;
  GestureData? gesture_data;
  ScrollData? scroll_data;
};
