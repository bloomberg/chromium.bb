// Copyright 2018 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "ui/events/blink/prediction/least_squares_predictor.h"
#include "testing/gtest/include/gtest/gtest.h"

namespace {

constexpr double kEpsilon = 0.01;

}  // namespace

namespace ui {

class LSQPredictorTest : public testing::Test {
 public:
  LSQPredictorTest() {}

  void SetUp() override {
    predictor_ = std::make_unique<ui::LeastSquaresPredictor>();
  }

  static base::TimeTicks FromMilliseconds(int64_t ms) {
    return base::TimeTicks() + base::TimeDelta::FromMilliseconds(ms);
  }

  void ValidateLeastSquaresPredictor(const std::vector<double>& x,
                                     const std::vector<double>& y,
                                     const std::vector<double>& timestamp_ms) {
    predictor_->Reset();
    ui::InputPredictor::InputData result;

    for (size_t i = 0; i < timestamp_ms.size(); i++) {
      if (i >= LeastSquaresPredictor::kSize) {
        EXPECT_TRUE(predictor_->GeneratePrediction(
            FromMilliseconds(timestamp_ms[i]), &result));
        EXPECT_NEAR(result.pos.x(), x[i], kEpsilon);
        EXPECT_NEAR(result.pos.y(), y[i], kEpsilon);
      }
      InputPredictor::InputData data = {gfx::PointF(x[i], y[i]),
                                        FromMilliseconds(timestamp_ms[i])};
      predictor_->Update(data);
    }
  }

 protected:
  std::unique_ptr<LeastSquaresPredictor> predictor_;

  DISALLOW_COPY_AND_ASSIGN(LSQPredictorTest);
};

TEST_F(LSQPredictorTest, ShouldHasPrediction) {
  LeastSquaresPredictor predictor;
  for (size_t i = 0; i < LeastSquaresPredictor::kSize; i++) {
    // First |kSize| point do not have prediction available.
    EXPECT_FALSE(predictor.HasPrediction());
    InputPredictor::InputData data = {gfx::PointF(1, 1),
                                      FromMilliseconds(8 * i)};
    predictor.Update(data);
  }
  EXPECT_TRUE(predictor.HasPrediction());
}

// Tests the lest squares filter behavior.
// The data set is generated by a "known to work" quadratic fit.
TEST_F(LSQPredictorTest, PredictedValue) {
  std::vector<double> x = {22, 58, 102, 108.094};
  std::vector<double> y = {100, 100, 100, 100};
  std::vector<double> t = {13, 21, 37, 42};
  ValidateLeastSquaresPredictor(x, y, t);

  x = {100, 100, 101, 104.126};
  y = {120, 280, 600, 1364.93};
  t = {101, 126, 148, 180};
  ValidateLeastSquaresPredictor(x, y, t);
}

// Tests the LSQ predictor predict linear value correctly.
TEST_F(LSQPredictorTest, PredictLinearValue) {
  std::vector<double> x = {8, 16, 24, 32, 40};
  std::vector<double> y = {300, 410, 520, 630, 740};
  std::vector<double> t = {8, 16, 24, 32, 40};
  ValidateLeastSquaresPredictor(x, y, t);
}

// Tests the LSQ predictor predict quadratic value correctly.
TEST_F(LSQPredictorTest, PredictQuadraticValue) {
  std::vector<double> x = {2, 8, 18, 32, 50};
  std::vector<double> y = {100, 400, 900, 1600, 2500};
  std::vector<double> t = {8, 16, 24, 32, 40};
  ValidateLeastSquaresPredictor(x, y, t);
}

// Tests that lsq predictor will not crash when given constant time stamp.
TEST_F(LSQPredictorTest, ConstantTimeStampNotCrash) {
  std::vector<double> x = {100, 101, 102};
  std::vector<double> y = {101, 102, 103};
  std::vector<double> t = {0, 0, 0};
  for (size_t i = 0; i < t.size(); i++) {
    InputPredictor::InputData data = {gfx::PointF(x[i], y[i]),
                                      FromMilliseconds(t[i])};
    predictor_->Update(data);
  }
  ui::InputPredictor::InputData result;
  EXPECT_FALSE(predictor_->GeneratePrediction(FromMilliseconds(42), &result));

  x = {100, 100, 100};
  y = {100, 100, 100};
  t = {100, 100, 100};
  for (size_t i = 0; i < t.size(); i++) {
    InputPredictor::InputData data = {gfx::PointF(x[i], y[i]),
                                      FromMilliseconds(t[i])};
    predictor_->Update(data);
  }
  EXPECT_FALSE(predictor_->GeneratePrediction(FromMilliseconds(42), &result));
}

}  // namespace ui
