// Copyright 2018 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "ui/events/blink/prediction/least_squares_predictor.h"
#include "testing/gtest/include/gtest/gtest.h"

namespace ui {

// The epsilon of predicted result.
const double kEpsilon = 0.01;

base::TimeTicks FromMilliseconds(int64_t ms) {
  return base::TimeTicks() + base::TimeDelta::FromMilliseconds(ms);
}

TEST(LSQPredictorTest, ShouldHasPrediction) {
  LeastSquaresPredictor predictor;
  for (size_t i = 0; i < LeastSquaresPredictor::kSize; i++) {
    EXPECT_FALSE(predictor.HasPrediction());
    InputPredictor::InputData data = {1 /* x */, 1 /* y */,
                                      FromMilliseconds(8 * i)};
    predictor.Update(data);
  }
  EXPECT_TRUE(predictor.HasPrediction());
}

// Test the lest squares filter behavior.
// The data set is generated by a "known to work" quadratic fit.
TEST(LSQPredictorTest, PredictedValue) {
  LeastSquaresPredictor predictor;

  std::vector<double> x = {22, 58, 102};
  std::vector<double> y = {100, 100, 100};
  std::vector<base::TimeTicks> t = {FromMilliseconds(13), FromMilliseconds(21),
                                    FromMilliseconds(37)};

  for (int i = 0; i < 3; i++) {
    InputPredictor::InputData data = {x[i], y[i], t[i]};
    predictor.Update(data);
  }

  ui::InputPredictor::InputData result;

  EXPECT_TRUE(predictor.GeneratePrediction(FromMilliseconds(42), &result));
  EXPECT_NEAR(result.pos_x, 108.094, kEpsilon);
  EXPECT_NEAR(result.pos_y, 100, kEpsilon);

  x = {100, 100, 101};
  y = {120, 280, 600};
  t = {FromMilliseconds(101), FromMilliseconds(126), FromMilliseconds(148)};
  for (int i = 0; i < 3; i++) {
    InputPredictor::InputData data = {x[i], y[i], t[i]};
    predictor.Update(data);
  }

  EXPECT_TRUE(predictor.GeneratePrediction(FromMilliseconds(180), &result));
  EXPECT_NEAR(result.pos_x, 104.126, kEpsilon);
  EXPECT_NEAR(result.pos_y, 1364.93, kEpsilon);
}

// Test that lsq predictor will not crash when given constant time stamp.
TEST(LSQPredictorTest, ConstantTimeStampNotCrash) {
  LeastSquaresPredictor predictor;

  InputPredictor::InputData data = {100 /* x */, 101 /* y */,
                                    FromMilliseconds(0)};
  predictor.Update(data);
  data = {101 /* x */, 102 /* y */, FromMilliseconds(0)};
  predictor.Update(data);
  data = {102 /* x */, 103 /* y */, FromMilliseconds(0)};
  predictor.Update(data);
  EXPECT_FALSE(predictor.GeneratePrediction(FromMilliseconds(42), &data));

  data = {100 /* x */, 100 /* y */, FromMilliseconds(100)};
  predictor.Update(data);
  data = {100 /* x */, 100 /* y */, FromMilliseconds(100)};
  predictor.Update(data);
  EXPECT_FALSE(predictor.GeneratePrediction(FromMilliseconds(42), &data));
}

}  // namespace ui
