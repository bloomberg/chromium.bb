<!DOCTYPE html>
<!--
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/math/range.html">
<link rel="import" href="/tracing/base/unit.html">
<link rel="import" href="/tracing/extras/chrome/event_finder_utils.html">
<link rel="import" href="/tracing/extras/v8/runtime_stats_entry.html">
<link rel="import" href="/tracing/metrics/metric_registry.html">
<link rel="import" href="/tracing/metrics/v8/utils.html">
<link rel="import" href="/tracing/value/histogram.html">

<script>
'use strict';

tr.exportTo('tr.metrics.v8', function() {
  const COUNT_CUSTOM_BOUNDARIES = tr.v.HistogramBinBoundaries
      .createExponential(1, 1000000, 50);
  const DURATION_CUSTOM_BOUNDARIES = tr.v.HistogramBinBoundaries
      .createExponential(0.1, 10000, 50);
  const SUMMARY_OPTIONS = {
    std: false,
    count: false,
    sum: false,
    min: false,
    max: false,
  };

  function convertMicroToMilli_(time) {
    return tr.b.convertUnit(time,
        tr.b.UnitPrefixScale.METRIC.MICRO, tr.b.UnitPrefixScale.METRIC.MILLI);
  }

  function addDurationHistogram(histogramName, time, histograms) {
    const value = convertMicroToMilli_(time);
    histograms.createHistogram(
        `${histogramName}:duration`,
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter,
        {value},
        { binBoundaries: DURATION_CUSTOM_BOUNDARIES,
          summaryOptions: SUMMARY_OPTIONS
        });
  }

  function addCountHistogram(histogramName, value, histograms) {
    histograms.createHistogram(
        `${histogramName}:count`,
        tr.b.Unit.byName.count_smallerIsBetter,
        {value},
        { binBoundaries: COUNT_CUSTOM_BOUNDARIES,
          summaryOptions: SUMMARY_OPTIONS
        });
  }

  function filterV8ThreadSlices(event) {
    return event instanceof tr.e.v8.V8ThreadSlice;
  }

  function runtimeStatsTotalMetric(histograms, model) {
    const v8Slices = tr.metrics.v8.utils.filterEvents(
        model,
        filterV8ThreadSlices);
    const runtimeGroupCollection = new tr.e.v8.RuntimeStatsGroupCollection();
    runtimeGroupCollection.addSlices(v8Slices);

    let overallV8Time = runtimeGroupCollection.totalTime;
    let overallV8Count = runtimeGroupCollection.totalCount;
    let v8ForegroundTime = runtimeGroupCollection.totalTime;
    let v8ForegroundCount = runtimeGroupCollection.totalCount;
    for (const runtimeGroup of runtimeGroupCollection.runtimeGroups) {
      addDurationHistogram(runtimeGroup.name, runtimeGroup.time, histograms);
      addCountHistogram(runtimeGroup.name, runtimeGroup.count, histograms);

      if (runtimeGroup.isBlink) {
        overallV8Count -= runtimeGroup.count;
        overallV8Time -= runtimeGroup.time;
      }

      if (runtimeGroup.isBackground || runtimeGroup.isBlink) {
        v8ForegroundTime -= runtimeGroup.time;
        v8ForegroundCount -= runtimeGroup.count;
      }
    }

    if (runtimeGroupCollection.blinkRCSGroupCollection.totalTime > 0) {
      const blinkRCSGroupCollection =
        runtimeGroupCollection.blinkRCSGroupCollection;
      for (const group of blinkRCSGroupCollection.runtimeGroups) {
        addDurationHistogram(group.name, group.time, histograms);
        addCountHistogram(group.name, group.count, histograms);
      }
    }

    // Add V8 only time that is Total - Blink C++ duration.
    addDurationHistogram('V8-Only', overallV8Time, histograms);
    addCountHistogram('V8-Only', overallV8Count, histograms);

    // Add V8 only time that is spent in foreground.
    addDurationHistogram('V8-Only-Foreground', v8ForegroundTime, histograms);
    addCountHistogram('V8-Only-Foreground', v8ForegroundCount, histograms);
  }

  tr.metrics.MetricRegistry.register(runtimeStatsTotalMetric);

  return {
    runtimeStatsTotalMetric,
  };
});
</script>
