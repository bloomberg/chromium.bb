// Copyright 2018 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module media_session.mojom;

import "services/media_session/public/mojom/media_session.mojom";

// These are the different types of audio focus that can be requested.
enum AudioFocusType {
  // Request permanent audio focus when you plan to play audio for the
  // foreseeable future (for example, when playing music) and you expect the
  // previous holder of audio focus to stop playing.
  kGain,

  // Request transient focus with ducking to indicate that you expect to play
  // audio for only a short time and that it's OK for the previous focus owner
  // to keep playing if it "ducks" (lowers) its audio output.
  kGainTransientMayDuck,

  // Request transient focus when you expect to play audio for only a short
  // time and you expect the previous holder to pause playing.
  kGainTransient,
};

// Contains information about |MediaSessions| that have requested audio focus
// and their current requested type.
struct AudioFocusRequestState {
  MediaSessionInfo session_info;
  AudioFocusType audio_focus_type;
  uint64 request_id;
};

// The observer for audio focus events.
interface AudioFocusObserver {
  // The given |session| gained audio focus with the specified |type|.
  OnFocusGained(MediaSessionInfo session, AudioFocusType type);

  // The given |session| lost audio focus.
  OnFocusLost(MediaSessionInfo session);
};

// Controls audio focus for an associated request.
interface AudioFocusRequestClient {
  // Requests updated audio focus for this request. If the request was granted
  // then the callback will resolve.
  RequestAudioFocus(MediaSessionInfo session_info, AudioFocusType type) => ();

  // Abandons audio focus for this request.
  AbandonAudioFocus();

  // Notifies the audio focus backend when the associated session info changes.
  MediaSessionInfoChanged(MediaSessionInfo session_info);

  // Retrieve a unique ID for this request.
  GetRequestId() => (uint64 request_id);
};

// Controls audio focus across the entire system.
interface AudioFocusManager {
  // Requests audio focus with |type| for the |media_session| with
  // |session_info|. Media sessions should provide a |request| that will
  // provide an AudioFocusRequestClient that can be used to control this
  // request. The callback will resolve when audio focus has been granted.
  RequestAudioFocus(AudioFocusRequestClient& client,
                    MediaSession media_session,
                    MediaSessionInfo session_info,
                    AudioFocusType type) => ();

  // Gets all the information about all |MediaSessions| that have requested
  // audio focus and their current requested type.
  GetFocusRequests() => (array<AudioFocusRequestState> requests);

  // Adds observers that receive audio focus events.
  AddObserver(AudioFocusObserver observer);
};

// Provides debug information about audio focus requests.
interface AudioFocusManagerDebug {
  // Gets debugging information for a |MediaSession| with |request_id|.
  GetDebugInfoForRequest(uint64 request_id)
      => (MediaSessionDebugInfo debug_info);
};
