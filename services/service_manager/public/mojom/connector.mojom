// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module service_manager.mojom;

import "mojo/public/mojom/base/token.mojom";
import "services/service_manager/public/mojom/constants.mojom";
import "services/service_manager/public/mojom/interface_provider.mojom";

// TODO(beng): Evaluate the utility of this enum. There are some inconsistencies
//             in its use with BindInterface/StartService.
enum ConnectResult {
  // The operation was completed successfully.
  SUCCEEDED,

  // The given service name specified by |name| does not match a known service.
  INVALID_ARGUMENT,

  // Policy prevented the successful completion of this operation. Either
  // requests to bind to |name| are forbidden from the calling service by its
  // manifest, or the service attempted to connect to an instance in an instance
  // group with which it's not allowed to communicate.
  ACCESS_DENIED
};

// A collection of metadata that disambiguates instances in the service manager.
struct Identity {
  // A name identifying a service.
  string name;

  // Identifies the instance group to which a service instance belongs. Most
  // running service instances can only reach (via Connector) other service
  // instances running in the same instance group. This facilitates a mode of
  // isolation which is useful for modeling, e.g., different users in a multi-
  // user system.
  //
  // If this is null in an Identity passed to |Connector.BindInterface()|, it is
  // implied that the connecting service wants to connect to an instance in its
  // own instance group.
  //
  // Only services with appropriate permissions (declared in manifest options
  // via |can_connect_to_instances_in_any_group|) may explicitly choose other
  // instance groups when making outgoing service interface requests.
  //
  // When a new service instance is initialized and the Service Manager provides
  // its Identity via |Service.OnStart()|, that Identity always includes a valid
  // instance group ID.
  mojo_base.mojom.Token? instance_group;

  // When making outgoing connections to a service, the |instance_id| field may
  // be used to select one of multiple instances within the instance group. This
  // is only meaningful if the target service is not designated as a singleton
  // service in its manifest.
  //
  // May be (and is typically) null, indicating an instance with the default
  // instance ID.
  mojo_base.mojom.Token? instance_id;

  // A Token which globally and uniquely identifies a service instance across
  // space and time.
  //
  // This value is generated and assigned by the Service Manager when starting
  // a new instance and is given in the Identity passed to the instance via
  // |Service.OnStart()|.
  //
  // This may also be used to reliably correlate events on a
  // ServiceManagerListener interface with a specific service instance, given
  // that other metadata (like |instance_id| above, or service process PID) may
  // be reused over short periods of time and can thus lead to ambiguity in the
  // relationship among multiple such events.
  //
  // NOTE: If a specific |globally_unique_id| is provided in an Identity passed
  // to |Connector.BindInterface()|, the Service Manager will only establish a
  // connection to the target service if all other provided fields above match a
  // running instance AND that instance has the provided |globally_unique_id|.
  // The Service Manager will never start a new instance on behalf of such a
  // request. That is to say, clients cannot elicit new instance creation with
  // a specific |globally_unique_id|.
  mojo_base.mojom.Token? globally_unique_id;
};

// Implemented by an object in the service manager associated with a specific
// instance. Tells the service manager the PID for a process launched by the
// client.
interface PIDReceiver {
  SetPID(uint32 pid);
};

// An interface that allows the holder to start other services & bind to
// interfaces exposed by them.
interface Connector {
  // Asks the service manager to route a request to bind an implementation of
  // the interface to a named service instance.
  //
  // A service's ability to bind interfaces exposed by another is controlled by
  // policy set out in each service's manifest. See
  // //services/service_manager/README.md for more information on manifests.
  // If policy prevents the requesting service from binding the specified
  // interface, the request pipe will be closed.
  //
  // Parameters:
  //
  //  target
  //    The identity of the service instance to route the request to. If no
  //    instance exists, the service will be started.
  //
  //  interface_name
  //    The name of the interface to be bound. If the target service does not
  //    expose an interface of this name, the request pipe will be closed.
  //
  //  interface_pipe
  //    A message pipe endpoint encapsulating a request for an interface named
  //    |interface_name|.
  //
  // Response parameters:
  //
  //  result
  //    Indicates the result of the BindInterface() operation.
  //
  //  identity
  //    The fully resolved identity of the instance in the service manager,
  //    including instance group and globally unique ID. Typically the client
  //    passes null for the instance group in |target|, defaulting to the
  //    caller's own instance group.
  //
  BindInterface(Identity target,
                string interface_name,
                handle<message_pipe> interface_pipe) =>
      (ConnectResult result, Identity identity);

  // Asks the service manager whether it knows how to manage a given service,
  // and how the service is to be sandboxed per the mainifest. No processes are
  // started as a result. QueryService() is typically used before a call to
  // StartProcessWithService() so the client can determine how to launch a
  // process.
  //
  // Parameters:
  //
  //  target
  //    The identity of the service to query.
  //
  // Response parameters:
  //
  //  result
  //    Indicates the result of the QueryService() operation.
  //
  //  sandbox_type
  //    A string describing the kind of sandboxing the service has declared
  //    for itself in the manifest.
  //
  QueryService(Identity target) => (ConnectResult result, string sandbox_type);

  // Asks the service manager to create an instance for a service. No action is
  // taken if an instance is already present. If the service is not yet running,
  // it will be initialized and its OnStart() method will be called. A process
  // may be allocated.
  //
  // Parameters:
  //
  //  target
  //    The identity of the service to start.
  //
  // Response parameters:
  //
  //  result
  //    Indicates the result of the StartService() operation.
  //
  //  identity
  //    The fully resolved identity of the instance in the service manager,
  //    including instance group and globally unique ID. Typically the client
  //    passes null for the instance group in |target|, defaulting to the
  //    caller's own instance group.
  //
  StartService(Identity target) => (ConnectResult result, Identity identity);

  // Typically, the service manager will start a process for a service the first
  // time it receives a bind interface request for it, or when StartService() is
  // called. This struct allows a client to start the process itself and provide
  // the service manager the pipes it needs to communicate with it. When this
  // function is called, the client owns the lifetime of the child process it
  // started, not the service manager. The service manager binds the |service|
  // pipe, and when it closes destroys the associated instance but the process
  // stays alive.
  //
  // Parameters:
  //
  //  target
  //    The identity of the service to create the instance for.
  //
  //  service
  //    A pipe to an implementation of Service that the service manager can use
  //    to communicate with the service.
  //
  //  pid_receiver_request
  //   Allows the client process launcher to tell the service manager the PID of
  //   the process it created (the pid isn't supplied directly here as the
  //   process may not have been launched by the time BindInterface() is
  //   called.)
  //
  StartServiceWithProcess(Identity target,
                          handle<message_pipe> service,
                          PIDReceiver& pid_receiver_request) =>
      (ConnectResult result, Identity identity);

  // Clones this Connector so it can be passed to another thread.
  Clone(Connector& request);

  // Filter interface requests received from |source| according to the policy
  // specified in this service's manifest in an InterfaceProviderSpec named
  // |spec|.
  //
  // The flow is basically - remote service wishes to (generically) request
  // interfaces from this service, and so sends us an InterfaceProvider request
  // (|source_request|) which it would like us to bind. We forward this request
  // to the Service Manager, passing our actual InterfaceProvider implementation
  // in |target|. The Service Manager will only forward interface requests that
  // were permitted by intersecting |source|'s manifest requirements with the
  // contents of |spec|.
  FilterInterfaces(string spec,
                   Identity source,
                   InterfaceProvider& source_request,
                   InterfaceProvider target);
};
