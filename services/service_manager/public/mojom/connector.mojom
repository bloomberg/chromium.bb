// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module service_manager.mojom;

import "mojo/public/mojom/base/token.mojom";
import "services/service_manager/public/mojom/constants.mojom";
import "services/service_manager/public/mojom/interface_provider.mojom";
import "services/service_manager/public/mojom/service_filter.mojom";

// TODO(beng): Evaluate the utility of this enum. There are some inconsistencies
//             in its use with BindInterface/StartService.
enum ConnectResult {
  // The operation was completed successfully.
  SUCCEEDED,

  // The given service name specified by |name| does not match a known service.
  INVALID_ARGUMENT,

  // Policy prevented the successful completion of this operation. Either
  // requests to bind to |name| are forbidden from the calling service by its
  // manifest, or the service attempted to connect to an instance in an instance
  // group with which it's not allowed to communicate.
  ACCESS_DENIED
};

// A collection of metadata that disambiguates instances in the service manager.
struct Identity {
  // A name identifying a service.
  string name;

  // Identifies the instance group to which a service instance belongs. Most
  // running service instances can only reach (via Connector) other service
  // instances running in the same instance group. This facilitates a mode of
  // isolation which is useful for modeling, e.g., different users in a multi-
  // user system.
  //
  // If this is null in an Identity passed to |Connector.BindInterface()|, it is
  // implied that the connecting service wants to connect to an instance in its
  // own instance group.
  //
  // Only services with appropriate permissions (declared in manifest options
  // via |can_connect_to_instances_in_any_group|) may explicitly choose other
  // instance groups when making outgoing service interface requests.
  //
  // When a new service instance is initialized and the Service Manager provides
  // its Identity via |Service.OnStart()|, that Identity always includes a valid
  // instance group ID.
  mojo_base.mojom.Token? instance_group;

  // When making outgoing connections to a service, the |instance_id| field may
  // be used to select one of multiple instances within the instance group. This
  // is only meaningful if the target service is not designated as a singleton
  // service in its manifest.
  //
  // May be (and is typically) null, indicating an instance with the default
  // instance ID.
  mojo_base.mojom.Token? instance_id;

  // A Token which globally and uniquely identifies a service instance across
  // space and time.
  //
  // This value is generated and assigned by the Service Manager when starting
  // a new instance and is given in the Identity passed to the instance via
  // |Service.OnStart()|.
  //
  // This may also be used to reliably correlate events on a
  // ServiceManagerListener interface with a specific service instance, given
  // that other metadata (like |instance_id| above, or service process PID) may
  // be reused over short periods of time and can thus lead to ambiguity in the
  // relationship among multiple such events.
  //
  // NOTE: If a specific |globally_unique_id| is provided in an Identity passed
  // to |Connector.BindInterface()|, the Service Manager will only establish a
  // connection to the target service if all other provided fields above match a
  // running instance AND that instance has the provided |globally_unique_id|.
  // The Service Manager will never start a new instance on behalf of such a
  // request. That is to say, clients cannot elicit new instance creation with
  // a specific |globally_unique_id|.
  mojo_base.mojom.Token? globally_unique_id;
};

// Implemented by an object in the service manager associated with a specific
// instance. Tells the service manager the PID for a process launched by the
// client.
interface PIDReceiver {
  SetPID(uint32 pid);
};

// An interface that allows the holder to start other services & bind to
// interfaces exposed by them.
interface Connector {
  // Asks the Service Manager to route an interface request to another service
  // instance. The target instance is selected by |filter|, subject to various
  // constraints. With some exceptions and limitations, if no existing service
  // instance is found matching the given |filter|, a new instance is started
  // which meets the constraints of the filter.
  //
  // Upon success, |result| will be |SUCCEEDED| and |identity| will contain the
  // full identity of the service instance to which the request was successfully
  // routed. Upon failure |result| will take on a different value and |identity|
  // will be null.
  //
  // If |filter| filters only by service name, the Service Manager may select
  // any running service instance with that service name. If the named service
  // is not a singleton or otherwise shared across all instance groups, the
  // selection space is limited to the caller's own instance group.
  //
  // If |filter| includes an instance group ID, either that group ID must match
  // the caller's own, or the caller must have set the
  // |can_connect_to_instances_in_any_group| option in its own manifest.
  //
  // If |filter| includes an instance ID, the caller must have set the
  // |can_connect_to_other_services_with_any_instance_name| option in its own
  // manifest.
  //
  // If |filter| includes a globally unique ID, it must include a group ID and
  // instance ID as well. Requests like this will only ever match a specific
  // service instance that is already running. Unlike in other cases, the
  // Service Manager will NEVER create a new service instance to fulfill this
  // request.
  BindInterface(ServiceFilter filter,
                string interface_name,
                handle<message_pipe> interface_pipe)
      => (ConnectResult result, Identity? identity);

  // Asks the service manager whether it knows how to manage a given service,
  // and how the service is to be sandboxed per the mainifest. No processes are
  // started as a result. QueryService() is typically used before a call to
  // StartProcessWithService() so the client can determine how to launch a
  // process.
  //
  // |filter| is interpreted similarly to |BindInterface()| above.
  //
  // Response parameters:
  //
  //  result
  //    Indicates the result of the QueryService() operation.
  //
  //  sandbox_type
  //    A string describing the kind of sandboxing the service has declared
  //    for itself in the manifest.
  //
  QueryService(ServiceFilter filter)
      => (ConnectResult result, string sandbox_type);

  // Asks the Service Manager to create a service instance which would match
  // |filter|. This is essentially equivalent to |BindInterface()| above but
  // no interface request given to bind. This may be used to elicit service
  // launching if no matching service instance is already running. See comments
  // on |BindInterface()| above for details on filtering constraints, instance
  // creation, and response values.
  StartService(ServiceFilter filter)
      => (ConnectResult result, Identity? identity);

  // Typically, the service manager will start a process for a service the first
  // time it receives a bind interface request for it, or when StartService() is
  // called. This struct allows a client to start the process itself and provide
  // the service manager the pipes it needs to communicate with it. When this
  // function is called, the client owns the lifetime of the child process it
  // started, not the service manager. The service manager binds the |service|
  // pipe, and when it closes destroys the associated instance but the process
  // stays alive.
  //
  // Parameters:
  //
  //  target
  //    The identity of the service to create the instance for.
  //
  //  service
  //    A pipe to an implementation of Service that the service manager can use
  //    to communicate with the service.
  //
  //  pid_receiver_request
  //   Allows the client process launcher to tell the service manager the PID of
  //   the process it created (the pid isn't supplied directly here as the
  //   process may not have been launched by the time BindInterface() is
  //   called.)
  //
  StartServiceWithProcess(Identity target,
                          handle<message_pipe> service,
                          PIDReceiver& pid_receiver_request) =>
      (ConnectResult result, Identity? identity);

  // Clones this Connector so it can be passed to another thread.
  Clone(Connector& request);

  // Filter interface requests received from |source| according to the policy
  // specified in this service's manifest in an InterfaceProviderSpec named
  // |spec|.
  //
  // The flow is basically - remote service wishes to (generically) request
  // interfaces from this service, and so sends us an InterfaceProvider request
  // (|source_request|) which it would like us to bind. We forward this request
  // to the Service Manager, passing our actual InterfaceProvider implementation
  // in |target|. The Service Manager will only forward interface requests that
  // were permitted by intersecting |source|'s manifest requirements with the
  // contents of |spec|.
  FilterInterfaces(string spec,
                   Identity source,
                   InterfaceProvider& source_request,
                   InterfaceProvider target);
};
