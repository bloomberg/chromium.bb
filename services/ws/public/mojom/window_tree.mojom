// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module ws.mojom;

import "mojo/public/mojom/base/unguessable_token.mojom";
import "services/viz/public/interfaces/compositing/compositor_frame_sink.mojom";
import "services/viz/public/interfaces/compositing/frame_sink_id.mojom";
import "services/viz/public/interfaces/compositing/local_surface_id_allocation.mojom";
import "services/viz/public/interfaces/compositing/surface_info.mojom";
import "services/ws/public/mojom/window_manager.mojom";
import "services/ws/public/mojom/screen_provider_observer.mojom";
import "services/ws/public/mojom/window_tree_constants.mojom";
import "ui/base/mojo/cursor.mojom";
import "ui/base/mojo/ui_base_types.mojom";
import "ui/events/mojo/event.mojom";
import "ui/events/mojo/event_constants.mojom";
import "ui/gfx/geometry/mojo/geometry.mojom";
import "ui/gfx/image/mojo/image.mojom";
import "ui/gfx/mojo/transform.mojom";
import "ui/platform_window/mojo/text_input_state.mojom";

// Windows are identified by a uint64. The upper 32 bits are the id assigned to
// the client by the Window Service, and the lower 32 an id assigned by the
// client. Windows created by the client supply a client id of 0, which the
// Window Service maps appropriately. For clients that see Windows created by
// another client, the upper 32 bits are set to identify the other client.
//
// The root window is identified with a connection id of 0, and value of 1.
//
// Most functions to the WindowTree take a change_id parameter. When
// WindowTree completes processing of a function WindowTree calls
// WindowTreeClient::OnChangeCompleted() with the change_id supplied by the
// client and the result of the function. This allows the client to track
// whether the call succeeded or not. Calls are done via the client interface
// rather than a callback to ensure ordering. The server does not interpret the
// change id in anyway, it is up to the client to assign a value and use it.
// Generally the change id is an ever increasing integer.
//
// Event processing happens in the following order:
// . The event is sent to the accelerator registered for the PRE_TARGET. If
//   the client consumes the event, matching event observers are notified and
//   processing stops. If the client does not consume the event processing
//   continues.
// . Target window (lookup of the target window depends upon the event type) and
//   matching event observers are notified at the same time. The target is only
//   notified once, even if it has a matching event observer registered. If the
//   target consumes the event, processing stops.
// . Accelerator registered for POST_TARGET. No response is expected from the
//   client for the POST_TARGET and processing of the next continues
//   immediately.
interface WindowTree {
  // Creates a new window with the specified id. It is up to the client to
  // ensure the id is unique to the connection (the id need not be globally
  // unique). Additionally the connection id (embedded in |window_id|) must
  // match that of the connection.
  // Errors:
  //   ERROR_CODE_VALUE_IN_USE: a window already exists with the specified id.
  //   ERROR_CODE_ILLEGAL_ARGUMENT: The connection part of |window_id| does not
  //     match the connection id of the client.
  NewWindow(uint32 change_id,
            uint64 window_id,
            map<string, array<uint8>>? properties);

  // Requests the WindowManager to create a new top level window. On success
  // OnTopLevelCreated() is called with the WindowData for the new window. On
  // failure OnChangeCompleted() is called.
  NewTopLevelWindow(uint32 change_id,
                    uint64 window_id,
                    map<string, array<uint8>> properties);

  // Deletes a window. This does not recurse. No hierarchy change notifications
  // are sent as a result of this. Only the connection that created the window
  // can delete it. DeleteWindow() may also be used to remove a window as an
  // embed root from the client. When DeleteWindow() is used to remove an embed
  // root, the client no longer has access to the embed root. The embedder of
  // the root is notified of the change via OnEmbeddedAppDisconnected().
  DeleteWindow(uint32 change_id, uint64 window_id);

  // Requests input event capture for the given |window_id|. Capture is only
  // allowed if the window is processing an event. When a window gains capture,
  // current input events are canceled. The given window will receive all
  // subsequent input until an alternate window is set via SetCapture, or
  // ReleaseCapture is called for |window_id|. OnCaptureChanged() is called to
  // notify of capture changing (as long as the client did not initiate the
  // change).
  SetCapture(uint32 change_id, uint64 window_id);

  // Releases input event capture for the given |window_id|. This does nothing
  // if |window_id| does not currently have capture.
  ReleaseCapture(uint32 change_id, uint64 window_id);

  // Start observing global events matching the supplied |types|, even if they
  // are not targeted at the requesting client. Events that would normally be
  // sent to the requesting client (ie. the event target is this window tree)
  // are sent to OnWindowInputEvent() with |matches_event_observer| set to true.
  //
  // Clients should limit the requested types and the duration of observation,
  // as there is a system-wide perf/battery penalty, especially for mouse moves.
  //
  // See class description for details on event delivery.
  ObserveEventTypes(array<ui.mojom.EventType> types);

  // Sets the specified bounds of the specified window. The window will paint
  // the frame in the provided |local_frame_id|, if any.
  // |local_surface_id_allocation| need only be supplied for roots.
  // For top-levels, clients may supply a null LocalSurfaceIdAllocation, before
  // OnTopLevelCreated() is called (clients receive the initial
  // LocalSurfaceIdAllocation in OnTopLevelCreated()). While clients may supply
  // a LocalSurfaceIdAllocation for top-levels, they are only allowed to
  // change the child-sequence number portion of the id. Supplying a different
  // embed token results in failure, and changes to the parent sequence number
  // are ignored.
  // |bounds| are in DIPs.
  SetWindowBounds(
      uint32 change_id,
      uint64 window_id,
      gfx.mojom.Rect bounds,
      viz.mojom.LocalSurfaceIdAllocation? local_surface_id_allocation);

  // Updates the LocalSurfaceIdAllocation for a window from the child. Does
  // nothing if |window_id| does not identify a top-level. See comment in
  // SetWindowBounds() for allowable values of |local_surface_id_allocation|.
  UpdateLocalSurfaceIdFromChild(
      uint64 window_id,
      viz.mojom.LocalSurfaceIdAllocation local_surface_id_allocation);

  // Asks the server to generate a new LocalSurfaceId for a window. The server
  // responds with the new LocalSurfaceId by way of OnWindowBoundsChanged().
  // This is only useful for top-levels.
  AllocateLocalSurfaceId(uint64 window_id);

  SetWindowTransform(uint32 change_id,
                     uint64 window_id,
                     gfx.mojom.Transform transform);

  // Sets the client area of the specified window. The client area is specified
  // by way of insets. Everything outside of the insets, and not in
  // |additional_client_areas| is considered non-client area.
  // TODO(sky): convert additional_client_areas to a path.
  SetClientArea(uint64 window_id,
                gfx.mojom.Insets insets,
                array<gfx.mojom.Rect>? additional_client_areas);

  // Insets the hit test of a window by the specified values. The insets must be
  // positive (or zero). |mouse| applies to events originating from the mouse,
  // and |touch| from a non-mouse pointer device (such as tap).
  SetHitTestInsets(uint64 window_id,
                   gfx.mojom.Insets mouse,
                   gfx.mojom.Insets touch);

  // Specifies the shape of the window. The region outside of the shape becomes
  // transparent and should be considered to be outside of the widget, so
  // underlying window will be targeted. Each element of |shape| is relative to
  // the window's coordinate. Empty means to reset the settings, so the normal
  // rectangular region will be used.
  SetShape(uint64 window_id, array<gfx.mojom.Rect> shape);

  // Called by clients that want to accept drag and drops. Windows default to
  // this being disabled; a window must actively opt-in to receiving OnDrag*()
  // calls.
  SetCanAcceptDrops(uint64 window_id, bool accepts_drops);

  // Sets the visibility of the specified window to |visible|. Connections are
  // allowed to change the visibility of any window they have created, as well
  // as any of their roots.
  SetWindowVisibility(uint32 change_id, uint64 window_id, bool visible);

  // Sets an individual named property. Setting an individual property to null
  // deletes the property.
  SetWindowProperty(uint32 change_id,
                    uint64 window_id,
                    string name,
                    array<uint8>? value);

  // Sets the opacity of the specified window to |opacity|.
  SetWindowOpacity(uint32 change_id, uint64 window_id, float opacity);

  // Attaches a CompositorFrameSink to a particular window.
  AttachCompositorFrameSink(
      uint64 window_id,
      viz.mojom.CompositorFrameSink& compositor_frame_sink,
      viz.mojom.CompositorFrameSinkClient client);

  // Reparents a window.
  // This fails for any of the following reasons:
  // . |parent| or |child| does not identify a valid window.
  // . |child| is an ancestor of |parent|.
  // . |child| is already a child of |parent|.
  //
  // This may result in a connection getting OnWindowDeleted(). See
  // RemoveWindowFromParent for details.
  AddWindow(uint32 change_id, uint64 parent, uint64 child);

  // Removes a window from its current parent. This fails if the window is not
  // valid or the window already has no parent.
  //
  // Removing a window from a parent may result in OnWindowDeleted() being sent
  // to other connections. For example, connection A has windows 1 and 2, with 2
  // a child of 1. Connection B has a root 1. If 2 is removed from 1 then B gets
  // OnWindowDeleted(). This is done as window 2 is effectively no longer
  // visible to connection B.
  RemoveWindowFromParent(uint32 change_id, uint64 window_id);

  // Ties the lifetime of |transient_window_id| to the lifetime of |window_id|.
  // This also places |transient_window_id| on top of |window_id|.
  // This fails for any of the following reasons:
  // . |window_id| or |transient_window_id| does not identify a valid window.
  // . |transient_window_id| is an ancestor of |window_id|.
  // . |transient_window_id| is modal to system.
  AddTransientWindow(uint32 change_id,
                     uint64 window_id,
                     uint64 transient_window_id);

  // Decouples the lifetime of |transient_window_id| from its transient parent.
  // This does not change transient window's position in the window hierarchy.
  RemoveTransientWindowFromParent(uint32 change_id, uint64 transient_window_id);

  // Changes modality type of |window_id|. This releases capture if necessary.
  // This fails for any of the following reasons:
  // . |window_id| does not identify a valid window.
  // . Client does not have a valid user id (i.e., it is an embedded app).
  SetModalType(uint32 change_id, uint64 window_id, ui.mojom.ModalType type);

  // Reorders a window in its parent, relative to |relative_window_id| according
  // to |direction|. Only the connection that created the window's parent can
  // reorder its children.
  ReorderWindow(uint32 change_id,
                uint64 window_id,
                uint64 relative_window_id,
                OrderDirection direction);

  // Returns the windows comprising the tree starting at |window_id|.
  // |window_id| is the first result in the return value, unless |window_id| is
  // invalid, in which case an empty vector is returned. The windows are visited
  // using a depth first search (pre-order).
  GetWindowTree(uint64 window_id) => (array<WindowData> windows);

  // A connection may grant access to another connection by way of Embed().
  // Embed() results in the supplied WindowTreeClient being configured with a
  // root window of |window_id|. The supplied WindowTreeClient may create child
  // windows and do other various tree operations (including Embed()), but does
  // not see nor have access to any of the windows above the embed point.
  //
  // The caller must have created |window_id|. If not the request fails and the
  // response is false.
  //
  // The embedder can dictate the behaviour of the embedded client by setting
  // the appropriate embed flags (e.g. kEmbedFlagEmbedderInterceptsEvents).
  //
  // When a connection embeds a WindowTreeClient the originating connection no
  // longer has privileges to access or see any of the children of the window.
  // If the window had existing children the children are removed. The
  // WindowManager gets to see the whole tree.
  //
  // A window may only have one embedding in it at a time. Subsequent calls to
  // Embed() for the same window result in the currently embedded
  // WindowTreeClient being removed. The embedded app is told this by way of
  // OnUnembed(), which is followed by OnWindowDeleted() (as the connection no
  // longer has access to the window).
  //
  // The embedder can detect when the embedded app disconnects by way of
  // OnEmbeddedAppDisconnected().
  //
  // The callback returns whether the embedding was successful.
  Embed(uint64 window_id, WindowTreeClient client, uint32 embed_flags)
      => (bool success);

  // Schedules a future call to Embed() using the returned token. This is used
  // when two clients need to work together to complete an embedding without
  // passing the WindowTreeClient between the two. This ensures a client isn't
  // able to spoof another client (say by directly passing events to the
  // client).
  //
  // For example, client A embeds client B in a window. Client A wants client B
  // to embed a WindowTreeClient in a window created by client B. This can be
  // accomplished by client A calling ScheduleEmbed() and then passing the
  // token returned from ScheduleEmbed() to client B (using a separate pipe) so
  // that client B may call EmbedUsingToken().
  ScheduleEmbed(WindowTreeClient client)
      => (mojo_base.mojom.UnguessableToken token);

  // Creates an UnguessableToken for use in a future call, by another client, to
  // EmbedUsingToken().
  //
  // The following example shows how to use this api. Client A wants client B
  // to embed it in a window created by client B.
  // 1. Client A calls ScheduleEmbedForExistingClient() to get a token.
  // 2. Client A passes the token to client B. This communication is done using
  //    an additional channel, outside of WindowTree/WindowTreeClient.
  // 3. Client B calls EmbedUsingToken().
  // 4. Client A receives OnEmbedFromToken() with the token from step 1.
  //
  // |window_id| is the id used for the window once EmbedUsingToken() is called.
  // More specifically, when OnEmbedFromToken() is called |window_id| is the id
  // of the window identified in the WindowData.
  ScheduleEmbedForExistingClient(uint32 window_id) => (
      mojo_base.mojom.UnguessableToken token);

  // Pair with ScheduleEmbed() or ScheduleEmbedForExistingClient() to complete
  // an embedding, see them for details.
  EmbedUsingToken(uint64 window_id,
                  mojo_base.mojom.UnguessableToken token,
                  uint32 embed_flags)
      => (bool success);

  // Attaches/unattaches a FrameSinkId to this window. A window can only have
  // a single frame-sink-id attached to it.
  AttachFrameSinkId(uint64 window_id,
                    viz.mojom.FrameSinkId frame_sink_id);
  UnattachFrameSinkId(uint64 window_id);

  // Sets focus to the specified window, use 0 to clear focus. For a window to
  // get focus the following has to happen: the window is drawn, the window has
  // been marked as focusable (see SetCanFocus()) and the window is in a
  // container the WindowManager has identified as allowing activation
  // (see WindowManagerClient::AddActivationParent()).
  SetFocus(uint32 change_id, uint64 window_id);

  // Marks the specified window as being able to receive focus.
  SetCanFocus(uint64 window_id, bool can_focus);

  // Sets the cursor when the pointer is inside |window_id|.
  SetCursor(uint32 change_id, uint64 window_id, ui.mojom.Cursor cursor);

  // Set text input state for the given window.
  SetWindowTextInputState(uint64 window_id, ui.mojom.TextInputState state);

  // Set the input method editor UI (software keyboard, etc) visibility.
  // If state is non-null, the specified window's text input state is updated.
  // Otherwise the existing state is used.
  SetImeVisibility(uint64 window_id,
                   bool visible,
                   ui.mojom.TextInputState? state);

  // Sets the EventTargetingPolicy. See EventTargetingPolicy for details.
  SetEventTargetingPolicy(uint64 window_id, EventTargetingPolicy policy);

  // See documentation for WindowTreeClient::OnWindowInputEvent().
  OnWindowInputEventAck(uint32 event_id, EventResult result);

  // If the current focus is (or is a child of) |window_id|, requests that the
  // window manager change the focus to the next activatable window.
  DeactivateWindow(uint64 window_id);

  // Stacks the window |above_id| above |below_id|. These two windows must
  // share the same parent. This function is intended for use with top-levels
  // only. For non-top-levels, use ReorderWindow().
  // TODO(sky): unify this and ReorderWindow(). https://crbug.com/850133.
  StackAbove(uint32 change_id, uint64 above_id, uint64 below_id);

  // Stacks the window above all sibling windows.
  StackAtTop(uint32 change_id, uint64 window_id);

  // Requests a window manager specific interface. |name| is the name of the
  // interface. This function is typed to WindowManager, but that's purely
  // by necessity. This function is used to request *any* interface known to
  // the environment hosting the window service. If |name| is not the name of
  // an interface known to the environment hosting the window service,
  // |window_manager| is closed.
  BindWindowManagerInterface(string name,
                             associated WindowManager& window_manager);

  // Returns a shared memory segment that contains two 16-bit ints packed into a
  // single Atomic32, which represent the current location of the mouse cursor
  // where the location is (x << 16) | y.
  GetCursorLocationMemory() => (handle<shared_buffer> cursor_buffer);

  // Tells the window manager to start moving or resizing the window.
  // OnChangeCompleted is called on whether the move was canceled. Because
  // there's a delay between when a client sends this message and when the
  // window manager starts acting on it, pass the cursor location at the start
  // of the move. |hit_test| specifies the type of the session; kCaption for
  // moving.
  PerformWindowMove(uint32 change_id, uint64 window_id, MoveLoopSource source,
                    gfx.mojom.Point cursor, ui.mojom.HitTest hit_test);

  // Tells the window manager to cancel any in progress window move started with
  // StartWindowMove() and to revert the window bounds to how they were.
  CancelWindowMove(uint64 window_id);

  // Called by the client to start a drag operation. |source_window_id| is the
  // source window, |screen_location| is what the source thinks their location
  // of the pointer which started the drag is, |drag_data| is the entire set of
  // mime to raw data mapping. |drag_image| and |drag_image_offset| describe
  // an image to hold behind the cursor which represents the data on the
  // clipboard. We send this during the start of the drag because most views
  // clients will try to read all this data on first entry.
  PerformDragDrop(uint32 change_id,
                  uint64 source_window_id,
                  gfx.mojom.Point screen_location,
                  map<string, array<uint8>> drag_data,
                  gfx.mojom.ImageSkia? drag_image,
                  gfx.mojom.Vector2d drag_image_offset,
                  uint32 drag_operation,
                  ui.mojom.PointerKind source);

  // Called by the client to cancel any in progress drag drop operation. This
  // will result in a change completed for the underlying change.
  CancelDragDrop(uint64 window_id);

  // Called by the client to start a session of observing the topmost window
  // under the cursor or touch point. Once called, OnTopmostWindowChanged() is
  // called on the client whenever the topmost window changes. |source|
  // specifies what type of located events should be observed (mouse or touch),
  // and |window_id| specifies the initial target of the located event.
  ObserveTopmostWindow(MoveLoopSource source, uint64 window_id);

  // Called by the client to request stopping the ongoing session of observing
  // the topmost window under the cursor.
  StopObservingTopmostWindow();

  // Sets the resize shadow for |hit_test| to the specified window. It hides
  // the shadow when kNowhere is set.
  SetWindowResizeShadow(uint64 window_id, ui.mojom.HitTest hit_test);

  // Called by the client to cancel active touch events. not_cancelled_window_id
  // is a window ID, and that window is excluded from cancelling. When
  // not_cancelled_window_id is invalid, active touch events should be cancelled
  // on all windows.
  CancelActiveTouchesExcept(uint64 not_cancelled_window_id);

  // Called by the client to cancel active touches on |window_id|.
  CancelActiveTouches(uint64 window_id);

  // Called by the client to transfer the gesture stream from the window of
  // |current_id| to the window of |new_id|. If |should_cancel| is set, then
  // cancel events are also dispatched to |current_id|. Both |current_id| and
  // |new_id| need to be valid window ID created by the client. This operation
  // is not allowed for embedded clients.
  TransferGestureEventsTo(uint64 current_id, uint64 new_id, bool should_cancel);

  // Called by the client to start occlusion tracking for a window.
  TrackOcclusionState(uint64 window_id);

  // Called by the client to pause occlusion states computation when there are
  // massive window changes (such as a hierarchy change, or multiple window
  // visibility change) to avoid unnecessary occlusion state updates. Server
  // will re-compute the occlusion state after a balancing
  // UnpauseWindowOcclusionTracking call.
  PauseWindowOcclusionTracking();

  // Called by the client the resume occlusion states computation. When
  // all outstanding pause requests are cleared, server will re-compute
  // occlusion states for the tracked windows and send back updates.
  UnpauseWindowOcclusionTracking();
};

// Changes to windows are not sent to the connection that originated the
// change. For example, if connection 1 changes the bounds of a window by
// calling SetWindowBounds(), connection 1 does not receive
// OnWindowBoundsChanged().
interface WindowTreeClient {
  // Sent when clients establishes a connection to the WindowService.
  // |client_id| gives the unique id for the client. This value is generally
  // only useful for debugging.
  OnClientId(uint32 client_id);

  // Invoked when the client application has been embedded at |root|.
  // See Embed() on WindowTree for more details. |tree| will be a handle back to
  // the window manager service, unless the connection is to the root connection
  // in which case it will be null. |parent_drawn| is true if roots parent is
  // drawn, see OnParentDrawnStateChanged() for details. |display_id| identifies
  // the display this root window is on. If the embedded window has a size,
  // |local_surface_id| identifies the ID to use to submit CompositorFrames.
  OnEmbed(WindowData root,
          WindowTree? tree,
          int64 display_id,
          uint64 focused_window,
          bool parent_drawn,
          viz.mojom.LocalSurfaceIdAllocation? local_surface_id_allocation);

  // See description in ScheduleEmbedForExistingClient() for details on this.
  // Supplied arguments match that of OnEmbed().
  OnEmbedFromToken(
      mojo_base.mojom.UnguessableToken token,
      WindowData root,
      int64 display_id,
      viz.mojom.LocalSurfaceIdAllocation? local_surface_id_allocation);

  // Invoked when the application embedded at |window| is disconnected. In other
  // words the embedded app closes the connection to the server. This is called
  // on the connection that created |window| as well as any ancestors that have
  // the embed root policy.
  OnEmbeddedAppDisconnected(uint64 window);

  // Sent when another connection is embedded in the Window this connection was
  // previously embedded in. See Embed() for more information.
  OnUnembed(uint64 window);

  // Sent when capture changes. This is not sent if the client initiated the
  // change.
  OnCaptureChanged(uint64 new_capture, uint64 old_capture);

  // This is called on the client that initiated a call to Embed(), and informs
  // the owner (embedder) of the new FrameSinkId of the window (embedding
  // results in changing the FrameSinkId).
  OnFrameSinkIdAllocated(uint64 window, viz.mojom.FrameSinkId frame_sink_id);

  // Called in response to NewTopLevelWindow() successfully completing.
  // |parent_drawn| is true if the parent of the window is drawn, see
  // OnDrawnStateChanged() for details. |display_id| identifies the display this
  // window is on.
  OnTopLevelCreated(
      uint32 change_id,
      WindowData data,
      int64 display_id,
      bool parent_drawn,
      viz.mojom.LocalSurfaceIdAllocation local_surface_id_allocation);

  // Invoked when a window's bounds have changed. |local_surface_id_allocation|
  // is only supplied for roots.
  OnWindowBoundsChanged(
      uint64 window,
      gfx.mojom.Rect new_bounds,
      viz.mojom.LocalSurfaceIdAllocation? local_surface_id_allocation);

  OnWindowTransformChanged(uint64 window,
                           gfx.mojom.Transform new_transform);

  OnTransientWindowAdded(uint64 window_id,
                         uint64 transient_window_id);

  OnTransientWindowRemoved(uint64 window_id,
                           uint64 transient_window_id);

  // Invoked when a change is done to the hierarchy. A value of 0 is used to
  // identify a null window. For example, if the old_parent is NULL, 0 is
  // supplied.
  // If |window| was not visible to this client, but is visible now because
  // |new_parent| is visible to this client, then |windows| contains details
  // about |window|, and all its descendants. |windows| includes any windows
  // the client may already know about, but did not know the parent because
  // the parent was previously not visible to this client.
  // This is not sent for hierarchy changes of windows not known to this client
  // or not attached to the tree.
  OnWindowHierarchyChanged(uint64 window,
                           uint64 old_parent,
                           uint64 new_parent,
                           array<WindowData> windows);

  // Invoked when the order of windows within a parent changes.
  OnWindowReordered(uint64 window_id,
                    uint64 relative_window_id,
                    OrderDirection direction);

  // Invoked when a window is deleted.
  OnWindowDeleted(uint64 window);

  // Invoked when the visibility of the specified window changes.
  OnWindowVisibilityChanged(uint64 window, bool visible);

  // Invoked when the opacity of the specified window has changed.
  OnWindowOpacityChanged(uint64 window, float new_opacity);

  // Invoked when the window moves to a new display. This is only called on
  // a top-level window or an embedded root.
  OnWindowDisplayChanged(uint64 window, int64 display_id);

  // Invoked when the drawn state of |window|'s parent changes. The drawn state
  // is determined by the visibility of a Window and the Windows ancestors. A
  // Window is drawn if all ancestors are visible, not drawn if any ancestor is
  // hidden.
  //
  // The initial drawn state is communicated by way of OnTopLevelCreated() or
  // OnEmbed().
  //
  // This function is only called for root Windows as the drawn state of all
  // other windows can be determined from their parent.
  OnWindowParentDrawnStateChanged(uint64 window, bool drawn);

  // Invoked when a window property is changed. If this change is a removal,
  // |new_data| is null.
  OnWindowSharedPropertyChanged(uint64 window,
                                string name,
                                array<uint8>? new_data);

  // Invoked when an event is targeted at the specified window. The client must
  // call WindowTree::OnWindowInputEventAck() with the same |event_id| to ack
  // that the event has been processed, and with an EventResult value to notify
  // if the event was consumed. |matches_event_observer| is true if the event
  // also matches the requested types passed via ObserveEventTypes(). The client
  // must respond to ack these events, regardless of |matches_event_observer|.
  OnWindowInputEvent(uint32 event_id,
                     uint64 window,
                     int64 display_id,
                     ui.mojom.Event event,
                     bool matches_event_observer);

  // Called when an event not targeted at this client is observed, matching the
  // event types passed to ObserveEventTypes(); see that function for details.
  // Located events are always passed with the locations in screen coordinates.
  // The client should not respond to ack these events.
  OnObservedInputEvent(ui.mojom.Event event);

  // Called in two distinct cases: when a window known to the connection gains
  // focus, or when focus moves from a window known to the connection to a
  // window not known to the connection. In the later case |focused_window_id|
  // is 0. As with other functions this is only called if the client did not
  // initiate the change.
  OnWindowFocused(uint64 focused_window_id);

  OnWindowCursorChanged(uint64 window_id, ui.mojom.Cursor cursor);

  // Called when the mouse cursor enters a window on this connection for the
  // first time, providing a list of available mime types. We want to send this
  // set of data only one time, so this isn't part of OnDragEnter(), which
  // occurs every time the mouse enters a window.
  OnDragDropStart(map<string, array<uint8>> drag_data);

  // Called when the mouse cursor enters a window that has opted into accepting
  // drags through SetAcceptsDrags(), providing a list of available mime types.
  // |location_in_root| is the location relative to the embed root of |window|.
  // |location| is the location relative to |window|.
  // If |window| is a top-level or embed root, then |location_in_root| is the
  // same as |location|. Callback is supplied the supported operations.
  OnDragEnter(uint64 window,
              uint32 key_state,
              gfx.mojom.PointF location_in_root,
              gfx.mojom.PointF location,
              uint32 effect_bitmask) => (uint32 supported_op_bitmask);

  // Called when the pointer moves over the window after the initial DragEnter.
  // Returns a bitmask of the supported operations at this location. See
  // OnDragEnter() for details on coordinates.
  OnDragOver(uint64 window,
             uint32 key_state,
             gfx.mojom.PointF location_in_root,
             gfx.mojom.PointF location,
             uint32 effect_bitmask) => (uint32 supported_op_bitmask);

  // Called when the pointer leaves a window or if the drop is canceled.
  OnDragLeave(uint64 window);

  // Called when the drop occurs on a window. Returns the action taken. See
  // OnDragEnter() for details on coordinates.
  OnCompleteDrop(uint64 window,
                 uint32 key_state,
                 gfx.mojom.PointF location_in_root,
                 gfx.mojom.PointF location,
                 uint32 effect_bitmask) => (uint32 action_taken);

  // Called on the client that requested PerformDragDrop() to return which drag
  // action was completed. This is called instead of OnChangeCompleted().
  OnPerformDragDropCompleted(uint32 change_id,
                             bool success,
                             uint32 action_taken);

  // Called after OnCompleteDrop completes for every connection which received
  // an OnDragDropStart() message. This signals that a client can forget the
  // |drag_data| passed in via the first message.
  OnDragDropDone();

  // Called when the topmost window under the cursor/touch changes. The client
  // receives at most two IDs for the topmost windows. The first one is for the
  // topmost window. The second one is optionally for the second topmost window
  // if the first one happens to be the current event target. The second one
  // will be used by the client when they want to ignore the event target.
  // Each ID can be 0 when the window is not hosted by the client.
  OnTopmostWindowChanged(array<uint64> topmost_ids);

  // A change initiated from the client has completed. See description of
  // change ids for details.
  OnChangeCompleted(uint32 change_id, bool success);

  // The WindowManager is requesting the specified window to close. If the
  // client allows the change it should delete the window.
  RequestClose(uint64 window_id);

  // Requests the ScreenProviderObserver from the client. See
  // ScreenProviderObserver for details.
  GetScreenProviderObserver(associated ScreenProviderObserver& observer);

  // Called to send occlusion changes to client. |occlusion_changes| contains
  // the changed info, with window id as its key and new occlusion state as its
  // data. See also TrackOcclusionState on WindowTree.
  OnOcclusionStatesChanged(map<uint64, OcclusionState> occlusion_changes);

  // Cancels the ongoing touch gesture recognitions and clears related gesture
  // recognition state of the window of |window_id| in the client.
  CleanupGestureState(uint64 window_id);

  // Called when the window manager may start resizing a window by a user
  // gesture. For example, if the user clicks on a window-resize handle this may
  // be called. This is followed by OnWindowResizeLoopEnded() when the loop is
  // done. This function is only called for top-levels.
  // OnWindowResizeLoopEnded() may not be called if the window is destroyed
  // during the loop.
  OnWindowResizeLoopStarted(uint64 window_id);
  OnWindowResizeLoopEnded(uint64 window_id);
};

// Mus provides this interface as a way for clients to connect and obtain a
// WindowTree handle with a supplied WindowTreeClient handle. The
// WindowTreeClient has no roots, use NewTopLevelWindow() to create one.
interface WindowTreeFactory {
  CreateWindowTree(WindowTree& tree_request, WindowTreeClient client);
};
