<!DOCTYPE html>
<script src="../resources/testharness.js"></script>
<script src="../resources/testharnessreport.js"></script>
<script>
promise_test(async t => {

  const adapter = await navigator.gpu.requestAdapter();
  const device = await adapter.requestDevice();
  const queue = device.getQueue();

  // Check expected length and zero-initialization.
  function checkMapWriteResult(arrayBuffer, expectedSize) {
    assert_equals(arrayBuffer.byteLength, expectedSize);
    const view = new Uint8Array(arrayBuffer);
    for (let i = 0; i < view.length; ++i) {
      assert_equals(view[i], 0);
    }
  }

  // Copy and MapRead data to check buffer contents
  async function expectContents(buffer, expected) {
    const size = expected.byteLength;

    const readback = device.createBuffer({
      size,
      usage: GPUBufferUsage.TRANSFER_DST | GPUBufferUsage.MAP_READ,
    });

    const commandEncoder = device.createCommandEncoder({});
    commandEncoder.copyBufferToBuffer(buffer, 0, readback, 0, size);
    queue.submit([commandEncoder.finish()]);

    const actual = new Uint8Array(await readback.mapReadAsync());
    assert_equals(actual.byteLength, size);

    // Cast the expected contents as a byte array.
    const expectedView = new Uint8Array(expected.buffer, expected.byteOffset, expected.byteLength);

    for (let i = 0; i < size; ++i) {
      assert_equals(actual[i], expectedView[i]);
    }
  }

  {
    // Test simple MapWrite.
    const buffer = device.createBuffer({
      size: 12,
      usage: GPUBufferUsage.TRANSFER_SRC | GPUBufferUsage.MAP_WRITE,
    });

    const arrayBuffer = await buffer.mapWriteAsync();
    checkMapWriteResult(arrayBuffer, 12);

    const view = new Uint32Array(arrayBuffer);
    view[1] = 7;
    buffer.unmap();

    // Array buffer should be detached.
    assert_equals(arrayBuffer.byteLength, 0);
    assert_equals(view.byteLength, 0);

    await expectContents(buffer, new Uint32Array([0, 7, 0]));
  }

  {
    // Test large MapWrite
    const size = 512 * 1024;

    const buffer = device.createBuffer({
      size,
      usage: GPUBufferUsage.TRANSFER_SRC | GPUBufferUsage.MAP_WRITE,
    });

    const arrayBuffer = await buffer.mapWriteAsync();
    checkMapWriteResult(arrayBuffer, size);

    const view = new Uint32Array(arrayBuffer);
    assert_equals(view.byteLength, size);
    for (let i = 0; i < view.length; ++i) {
      view[i] = i;
    }
    const expected = view.slice();
    buffer.unmap();

    // Array buffer should be detached.
    assert_equals(arrayBuffer.byteLength, 0);
    assert_equals(view.byteLength, 0);

    await expectContents(buffer, expected);
  }

  {
    // Test simple MapRead
    const buffer = device.createBuffer({
      size: 12,
      usage: GPUBufferUsage.TRANSFER_DST | GPUBufferUsage.MAP_READ,
    });

    buffer.setSubData(8, new Uint32Array([3]));

    // TODO(enga): This should check the other values are zero, but we don't have
    // lazy zero-initialization yet.
    const actual = new Uint32Array(await buffer.mapReadAsync());
    assert_equals(actual[2], 3);
  }

  {
    // Test large MapRead
    const size = 512 * 1024;

    const buffer = device.createBuffer({
      size,
      usage: GPUBufferUsage.TRANSFER_DST | GPUBufferUsage.MAP_READ,
    });

    const data = new Uint32Array(new ArrayBuffer(size));
    for (let i = 0; i < data.length; ++i) {
      data[i] = i;
    }
    buffer.setSubData(0, data);

    const actual = new Uint32Array(await buffer.mapReadAsync());
    assert_equals(data.length, actual.length);
    for (let i = 0; i < data.length; ++i) {
      assert_equals(data[i], actual[i]);
    }

  }

}, "Test WebGPU buffer mapping");
</script>
