<!DOCTYPE html>
<title>Credential Manager: End-to-end tests for get() with a virtual authenticator.</title>
<script src="../resources/testharness.js"></script>
<script src="../resources/testharnessreport.js"></script>
<script src="/gen/layout_test_data/mojo/public/js/mojo_bindings_lite.js"></script>
<script src="/gen/mojo/public/mojom/base/time.mojom-lite.js"></script>
<script src="/gen/url/mojom/url.mojom-lite.js"></script>
<script src="/gen/third_party/blink/public/mojom/webauthn/authenticator.mojom-lite.js"></script>
<script src="/gen/third_party/blink/public/mojom/webauthn/virtual_authenticator.mojom-lite.js"></script>
<script src="resources/test-inputs.js"></script>
<script src="resources/virtual-navigator-credentials.js"></script>
<body>
<script>

if (document.location.host != "subdomain.example.test:8443") {
  document.location = "https://subdomain.example.test:8443/credentialmanager/credentialscontainer-get-with-virtual-authenticator.html";
  promise_test(_ => new Promise(_ => {}), "Stall tests on the wrong host.");
}

promise_test(async _ => {
  let authenticators = await navigator.credentials.test.authenticators();
  assert_equals(authenticators.length, 0);
  let testAuthenticator = await navigator.credentials.test.createAuthenticator();
  assert_true(await testAuthenticator.generateAndRegisterKey(ACCEPTABLE_CREDENTIAL_ID, "subdomain.example.test"));
}, "Set up the testing environment.");

promise_test(async t => {
  let testAuthenticator = await navigator.credentials.test.createAuthenticator();
  t.add_cleanup(async () => {
    let id = await testAuthenticator.id();
    return navigator.credentials.test.removeAuthenticator(id);
  });
  assert_true(await testAuthenticator.generateAndRegisterKey(ACCEPTABLE_CREDENTIAL_ID, "subdomain.example.test"));
  let keys = await testAuthenticator.registeredKeys();
  assert_equals(keys.length, 1);
  var customGetAssertionOptions = deepCopy(GET_CREDENTIAL_OPTIONS);
  var someOtherCredential = deepCopy(ACCEPTABLE_CREDENTIAL);
  someOtherCredential.id = new TextEncoder().encode("someOtherCredential");
  customGetAssertionOptions.allowCredentials = [someOtherCredential];

  return promise_rejects(t, "NotAllowedError",
    navigator.credentials.get({ publicKey : customGetAssertionOptions}));
}, "navigator.credentials.get() for unregistered device returns NotAllowedError");

promise_test(async t => {
  // Injecting resident credentials through the mojo virtual authenticator is
  // not supported.
  var customMakeCredOptions = deepCopy(MAKE_CREDENTIAL_OPTIONS);
  customMakeCredOptions.authenticatorSelection.requireResidentKey = true;
  var residentCredential =
    await navigator.credentials.create({ publicKey : customMakeCredOptions });

  var customGetAssertionOptions = deepCopy(GET_CREDENTIAL_OPTIONS);
  delete customGetAssertionOptions.allowCredentials;
  customGetAssertionOptions.user = PUBLIC_KEY_USER;
  return navigator.credentials.get({ publicKey : customGetAssertionOptions })
    .then(credential => assert_equals(credential.id, residentCredential.id));
}, "navigator.credentials.get() with empty allowCredentials returns a resident credential");

promise_test(t => {
  var customGetCredentialOptions = deepCopy(GET_CREDENTIAL_OPTIONS);
  customGetCredentialOptions.allowCredentials.transports = [];
  return navigator.credentials.get({publicKey: customGetCredentialOptions}).then();
}, "navigator.credentials.get() with missing transports in allowCredentials.");

promise_test(async t => {
  authAbortController = new AbortController();
  authAbortSignal = authAbortController.signal;
  return navigator.credentials.get({ publicKey : GET_CREDENTIAL_OPTIONS, signal : authAbortSignal});
}, "navigator.credentials.get() with abort signal flag not set");

promise_test(async t => {
  authAbortController = new AbortController();
  authAbortSignal = authAbortController.signal;
  authAbortController.abort();
  var promise = navigator.credentials.get({ publicKey : GET_CREDENTIAL_OPTIONS, signal : authAbortSignal});
  return promise_rejects(t, "AbortError", promise);
}, "navigator.credentials.get() with abort signal flag set before sending request");

promise_test(async t => {
  authAbortController = new AbortController();
  authAbortSignal = authAbortController.signal;
  var promise = navigator.credentials.get({ publicKey : GET_CREDENTIAL_OPTIONS, signal : authAbortSignal});
  authAbortController.abort();
  return promise_rejects(t, "AbortError", promise);
}, "navigator.credentials.get() with abort signal flag set after sending request");

promise_test(async t => {
  authAbortController = new AbortController();
  authAbortSignal = authAbortController.signal;
  let promise = await navigator.credentials.get({ publicKey : GET_CREDENTIAL_OPTIONS, signal : authAbortSignal});
  authAbortController.abort();
  return promise;
}, "navigator.credentials.get() with abort signal flag set after promise resolved");

promise_test(async t => {
  let bleTestAuthenticator = await navigator.credentials.test.createAuthenticator({
    transport: blink.mojom.AuthenticatorTransport.BLE,
  });
  t.add_cleanup(async () => {
    let id = await bleTestAuthenticator.id();
    return navigator.credentials.test.removeAuthenticator(id);
  });
  let bleCredential = deepCopy(ACCEPTABLE_CREDENTIAL);
  bleCredential.id = new TextEncoder().encode("bleCredential");
  bleCredential.transports = ["ble"]
  assert_true(await bleTestAuthenticator.generateAndRegisterKey(bleCredential.id, "subdomain.example.test"));
  let keys = await bleTestAuthenticator.registeredKeys();
  assert_equals(keys.length, 1);

  let customGetAssertionOptions = deepCopy(GET_CREDENTIAL_OPTIONS);
  customGetAssertionOptions.allowCredentials = [bleCredential];
  return navigator.credentials.get({ publicKey : customGetAssertionOptions });
}, "navigator.credentials.get() with authenticators supporting different transports");

promise_test(t => {
  return navigator.credentials.test.clearAuthenticators();
}, "Clean up testing environment.");

</script>
