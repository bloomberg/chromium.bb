// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_RENDERER_CORE_LAYOUT_NG_INLINE_NG_FRAGMENT_ITEM_H_
#define THIRD_PARTY_BLINK_RENDERER_CORE_LAYOUT_NG_INLINE_NG_FRAGMENT_ITEM_H_

#include "third_party/blink/renderer/core/core_export.h"
#include "third_party/blink/renderer/core/layout/geometry/logical_offset.h"
#include "third_party/blink/renderer/core/layout/ng/inline/ng_line_box_fragment_builder.h"
#include "third_party/blink/renderer/core/layout/ng/inline/ng_line_height_metrics.h"
#include "third_party/blink/renderer/platform/graphics/paint/display_item_client.h"

namespace blink {

class NGInlineBreakToken;

// This class represents a text run or a box in an inline formatting context.
//
// This class consumes less memory than a full fragment, and can be stored in a
// flat list (NGFragmentItems) for easier and faster traversal.
class CORE_EXPORT NGFragmentItem : public DisplayItemClient {
 public:
  // Represents regular text that exists in the DOM.
  struct Text {
    scoped_refptr<const ShapeResultView> shape_result;
    // TODO(kojii): |start_offset| and |end_offset| should match to the offset
    // in |shape_result|. Consider if we should remove them, or if keeping them
    // is easier.
    const unsigned start_offset;
    const unsigned end_offset;
  };
  // Represents text generated by the layout engine, e.g., hyphen or ellipsis.
  struct GeneratedText {
    scoped_refptr<const ShapeResultView> shape_result;
    String text;
  };
  // A start marker of a line box.
  struct Line {
    NGLineHeightMetrics metrics;
    scoped_refptr<NGInlineBreakToken> inline_break_token;
    wtf_size_t children_count;
  };
  // Represents a box fragment appeared in a line. This includes inline boxes
  // (e.g., <span>text</span>) and atomic inlines.
  struct Box {
    // If this item is an inline box, its children are stored as following
    // items. |children_count_| has the number of such items.
    //
    // If this item is a root of another IFC/BFC, children are stored normally,
    // as children of |box_fragment|.
    scoped_refptr<const NGPhysicalBoxFragment> box_fragment;
    wtf_size_t children_count;
  };

  enum ItemType { kText, kGeneratedText, kLine, kBox };

  // TODO(kojii): Should be able to create without once creating fragments.
  NGFragmentItem(const NGPhysicalTextFragment& text);
  NGFragmentItem(const NGPhysicalBoxFragment& box, wtf_size_t item_count);
  NGFragmentItem(const NGPhysicalLineBoxFragment& line, wtf_size_t item_count);

  ~NGFragmentItem() final;

  ItemType Type() const { return static_cast<ItemType>(type_); }

  NGStyleVariant StyleVariant() const {
    return static_cast<NGStyleVariant>(style_variant_);
  }
  const LayoutObject* GetLayoutObject() const { return layout_object_; }

  const PhysicalSize Size() { return size_; }
  const PhysicalOffset& Offset() const { return offset_; }
  void SetOffset(const PhysicalOffset& offset) { offset_ = offset; }

  // Count of following items that are descendants of this item in the box tree,
  // including this item. 1 means this is a box (box or line box) without
  // children. 0 if this item type cannot have children.
  wtf_size_t ChildrenCount() const {
    if (Type() == kBox)
      return box_.children_count;
    if (Type() == kLine)
      return line_.children_count;
    return 0;
  }

  // DisplayItemClient overrides
  String DebugName() const override;
  IntRect VisualRect() const override;

  // Painters can use const methods only, except for these explicitly declared
  // methods.
  class MutableForPainting {
    STACK_ALLOCATED();

   public:
    // TODO(kojii): Add painter functions.

   private:
    friend class NGFragmentItem;
    MutableForPainting(const NGFragmentItem& item) {}
  };
  MutableForPainting GetMutableForPainting() const {
    return MutableForPainting(*this);
  }

 private:
  const LayoutObject* layout_object_;

  // TODO(kojii): We can make them sub-classes if we need to make the vector of
  // pointers. Sub-classing from DisplayItemClient prohibits copying and that we
  // cannot create a vector of this class.
  union {
    Text text_;
    GeneratedText generated_text_;
    Line line_;
    Box box_;
  };

  PhysicalOffset offset_;
  PhysicalSize size_;

  struct NGInkOverflowModel {
    USING_FAST_MALLOC(NGInkOverflowModel);

   public:
    NGInkOverflowModel(const PhysicalRect& self_ink_overflow,
                       const PhysicalRect& contents_ink_overflow);

    PhysicalRect self_ink_overflow;
    // TODO(kojii): Some types (e.g., kText) never have |contents_ink_overflow|.
    // Can/should we optimize the memory usage for those cases?
    PhysicalRect contents_ink_overflow;
  };
  mutable std::unique_ptr<NGInkOverflowModel> ink_overflow_;
  // TOOD(kojii): mutable because this is lazily computed, but it may not be
  // needed if we use |MutableForPainting|. TBD.

  // Item index delta to the next item for the same |LayoutObject|.
  // wtf_size_t delta_to_next_for_same_layout_object_ = 0;

  unsigned type_ : 2;           // ItemType
  unsigned style_variant_ : 2;  // NGStyleVariant
};

}  // namespace blink

#endif  // THIRD_PARTY_BLINK_RENDERER_CORE_LAYOUT_NG_INLINE_NG_FRAGMENT_ITEM_H_
