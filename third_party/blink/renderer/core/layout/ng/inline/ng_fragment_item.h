// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_RENDERER_CORE_LAYOUT_NG_INLINE_NG_FRAGMENT_ITEM_H_
#define THIRD_PARTY_BLINK_RENDERER_CORE_LAYOUT_NG_INLINE_NG_FRAGMENT_ITEM_H_

#include "third_party/blink/renderer/core/core_export.h"
#include "third_party/blink/renderer/core/layout/geometry/logical_offset.h"
#include "third_party/blink/renderer/core/layout/layout_object.h"
#include "third_party/blink/renderer/core/layout/ng/inline/ng_line_box_fragment_builder.h"
#include "third_party/blink/renderer/core/layout/ng/inline/ng_line_height_metrics.h"
#include "third_party/blink/renderer/core/layout/ng/inline/ng_physical_text_fragment.h"
#include "third_party/blink/renderer/core/layout/ng/ng_ink_overflow.h"
#include "third_party/blink/renderer/platform/graphics/paint/display_item_client.h"

namespace blink {

class NGFragmentItems;
class NGInlineBreakToken;
struct NGTextFragmentPaintInfo;

// This class represents a text run or a box in an inline formatting context.
//
// This class consumes less memory than a full fragment, and can be stored in a
// flat list (NGFragmentItems) for easier and faster traversal.
class CORE_EXPORT NGFragmentItem : public DisplayItemClient {
 public:
  // Represents regular text that exists in the DOM.
  struct TextItem {
    scoped_refptr<const ShapeResultView> shape_result;
    // TODO(kojii): |start_offset| and |end_offset| should match to the offset
    // in |shape_result|. Consider if we should remove them, or if keeping them
    // is easier.
    const unsigned start_offset;
    const unsigned end_offset;
  };
  // Represents text generated by the layout engine, e.g., hyphen or ellipsis.
  struct GeneratedTextItem {
    scoped_refptr<const ShapeResultView> shape_result;
    String text;
  };
  // A start marker of a line box.
  struct LineItem {
    scoped_refptr<const NGPhysicalLineBoxFragment> line_box_fragment;
    wtf_size_t descendants_count;
  };
  // Represents a box fragment appeared in a line. This includes inline boxes
  // (e.g., <span>text</span>) and atomic inlines.
  struct BoxItem {
    // If this item is an inline box, its children are stored as following
    // items. |descendants_count_| has the number of such items.
    //
    // If this item is a root of another IFC/BFC, children are stored normally,
    // as children of |box_fragment|.
    //
    // Note:|box_fragment| can be null for <span>.
    scoped_refptr<const NGPhysicalBoxFragment> box_fragment;
    wtf_size_t descendants_count;
  };

  enum ItemType { kText, kGeneratedText, kLine, kBox };

  // TODO(kojii): Should be able to create without once creating fragments.
  NGFragmentItem(const NGPhysicalTextFragment& text);
  NGFragmentItem(const NGPhysicalBoxFragment& box,
                 wtf_size_t item_count,
                 TextDirection resolved_direction);
  NGFragmentItem(const NGPhysicalLineBoxFragment& line, wtf_size_t item_count);

  ~NGFragmentItem() final;

  ItemType Type() const { return static_cast<ItemType>(type_); }

  bool IsText() const { return Type() == kText || Type() == kGeneratedText; }
  bool IsContainer() const { return Type() == kBox || Type() == kLine; }
  bool IsAtomicInline() const;
  bool IsEmptyLineBox() const;
  bool IsHiddenForPaint() const { return is_hidden_for_paint_; }
  bool IsListMarker() const;

  NGStyleVariant StyleVariant() const {
    return static_cast<NGStyleVariant>(style_variant_);
  }
  bool UsesFirstLineStyle() const {
    return StyleVariant() == NGStyleVariant::kFirstLine;
  }
  // Returns the style for this fragment.
  //
  // For a line box, this returns the style of the containing block. This mostly
  // represents the style for the line box, except 1) |style.Direction()| maybe
  // incorrect, use |BaseDirection()| instead, and 2) margin/border/padding,
  // background etc. do not apply to the line box.
  const ComputedStyle& Style() const {
    return layout_object_->EffectiveStyle(StyleVariant());
  }
  const LayoutObject* GetLayoutObject() const { return layout_object_; }
  LayoutObject* GetMutableLayoutObject() const {
    return const_cast<LayoutObject*>(layout_object_);
  }
  Node* GetNode() const { return layout_object_->GetNode(); }
  Node* NodeForHitTest() const { return layout_object_->NodeForHitTest(); }
  bool HasSameParent(const NGFragmentItem& other) const;

  wtf_size_t DeltaToNextForSameLayoutObject() const {
    return delta_to_next_for_same_layout_object_;
  }
  void SetDeltaToNextForSameLayoutObject(wtf_size_t delta);

  const PhysicalRect& Rect() const { return rect_; }
  const PhysicalOffset& Offset() const { return rect_.offset; }
  const PhysicalSize& Size() const { return rect_.size; }
  PhysicalRect LocalRect() const { return {PhysicalOffset(), Size()}; }
  void SetOffset(const PhysicalOffset& offset) { rect_.offset = offset; }

  PhysicalRect InkOverflow() const;
  PhysicalRect SelfInkOverflow() const;

  // Count of following items that are descendants of this item in the box tree,
  // including this item. 1 means this is a box (box or line box) without
  // descendants. 0 if this item type cannot have children.
  wtf_size_t DescendantsCount() const {
    if (Type() == kBox)
      return box_.descendants_count;
    if (Type() == kLine)
      return line_.descendants_count;
    DCHECK(!IsContainer());
    return 0;
  }
  bool HasChildren() const { return DescendantsCount() > 1; }

  // Returns |NGPhysicalBoxFragment| if one is associated with this item.
  const NGPhysicalBoxFragment* BoxFragment() const {
    if (Type() == kBox)
      return box_.box_fragment.get();
    return nullptr;
  }

  bool HasOverflowClip() const;
  bool HasSelfPaintingLayer() const;

  // TODO(kojii): Avoid using this function in outside of this class as much as
  // possible, because |NGPhysicalLineBoxFragment| is likely to be removed. Add
  // functions to access data in |NGPhysicalLineBoxFragment| rather than using
  // this function. See |InlineBreakToken()| for example.
  const NGPhysicalLineBoxFragment* LineBoxFragment() const {
    if (Type() == kLine)
      return line_.line_box_fragment.get();
    return nullptr;
  }

  // Returns |NGInlineBreakToken| associated with this line, for line items.
  // Calling this function for other types is not valid.
  const NGInlineBreakToken* InlineBreakToken() const {
    if (const NGPhysicalLineBoxFragment* line_box = LineBoxFragment())
      return To<NGInlineBreakToken>(line_box->BreakToken());
    NOTREACHED();
    return nullptr;
  }

  NGTextFragmentPaintInfo TextPaintInfo(const NGFragmentItems& items) const;

  // DisplayItemClient overrides
  String DebugName() const override;
  IntRect VisualRect() const override;

  // Find |NGFragmentItem|s that are associated with a |LayoutObject|.
  class CORE_EXPORT ItemsForLayoutObject {
    STACK_ALLOCATED();

   public:
    ItemsForLayoutObject() = default;
    ItemsForLayoutObject(const Vector<std::unique_ptr<NGFragmentItem>>& items,
                         unsigned first_index,
                         const NGFragmentItem* first_item)
        : items_(&items), first_item_(first_item), first_index_(first_index) {}

    bool IsEmpty() const { return !items_; }

    class CORE_EXPORT Iterator {
     public:
      Iterator(const Vector<std::unique_ptr<NGFragmentItem>>* items,
               unsigned index,
               const NGFragmentItem* item)
          : current_(item), items_(items), index_(index) {}
      const NGFragmentItem& operator*() const { return *current_; }
      const NGFragmentItem& operator->() const { return *current_; }
      Iterator& operator++();
      bool operator==(const Iterator& other) const {
        return current_ == other.current_;
      }
      bool operator!=(const Iterator& other) const {
        return current_ != other.current_;
      }

     private:
      const NGFragmentItem* current_;
      const Vector<std::unique_ptr<NGFragmentItem>>* items_;
      unsigned index_;
    };
    using iterator = Iterator;
    iterator begin() const {
      return Iterator(items_, first_index_, first_item_);
    }
    iterator end() const { return Iterator(nullptr, 0, nullptr); }

   private:
    const Vector<std::unique_ptr<NGFragmentItem>>* items_;
    const NGFragmentItem* first_item_;
    unsigned first_index_;
  };
  static ItemsForLayoutObject ItemsFor(const LayoutObject& layout_object);
  static PhysicalRect LocalVisualRectFor(const LayoutObject& layout_object);

  // Re-compute the ink overflow for the |cursor| until its end.
  static PhysicalRect RecalcInkOverflowForCursor(NGInlineCursor* cursor);

  // Re-compute the ink overflow for this item. |cursor| should be at |this|,
  // and is advanced to the next item on return.
  void RecalcInkOverflow(NGInlineCursor* cursor,
                         PhysicalRect* self_and_contents_rect_out);

  // Painters can use const methods only, except for these explicitly declared
  // methods.
  class MutableForPainting {
    STACK_ALLOCATED();

   public:
    void RecalcInkOverflow(NGInlineCursor* cursor,
                           PhysicalRect* self_and_contents_rect_out) {
      return item_.RecalcInkOverflow(cursor, self_and_contents_rect_out);
    }

   private:
    friend class NGFragmentItem;
    MutableForPainting(const NGFragmentItem& item)
        : item_(const_cast<NGFragmentItem&>(item)) {}

    NGFragmentItem& item_;
  };
  MutableForPainting GetMutableForPainting() const {
    return MutableForPainting(*this);
  }

  bool IsHorizontal() const {
    return IsHorizontalWritingMode(GetWritingMode());
  }

  WritingMode GetWritingMode() const {
    return Style().GetWritingMode();
  }

  // Functions for |TextItem| and |GeneratedTextItem|
  using NGTextType = NGPhysicalTextFragment::NGTextType;
  NGTextType TextType() const {
    if (Type() == kText)
      return static_cast<NGTextType>(sub_type_);
    if (Type() == kGeneratedText)
      return NGTextType::kGeneratedText;
    NOTREACHED() << this;
    return NGTextType::kNormalText;
  }

  // True if this is a forced line break.
  bool IsLineBreak() const {
    return TextType() == NGTextType::kForcedLineBreak;
  }

  // True if this is not for painting; i.e., a forced line break, a tabulation,
  // or a soft-wrap opportunity.
  bool IsFlowControl() const {
    return IsLineBreak() || TextType() == NGTextType::kFlowControl;
  }

  // True if this is an ellpisis generated by `text-overflow: ellipsis`.
  bool IsEllipsis() const {
    return StyleVariant() == NGStyleVariant::kEllipsis;
  }

  // Returns true if the text is generated (from, e.g., list marker,
  // pseudo-element, ...) instead of from a DOM text node.
  //  * CSS content         kText
  //  * ellipsis            kGeneratedText
  //  * first-letter-part   kText
  //  * list marker         kGeneratedText
  //  * soft hyphen         kGeneratedText
  // TODO(yosin): When we implement |kGeneratedText|, we rename this function
  // to avoid confliction with |kGeneratedText|.
  bool IsGeneratedText() const;

  bool IsSymbolMarker() const {
    return TextType() == NGTextType::kSymbolMarker;
  }

  const ShapeResultView* TextShapeResult() const;

  unsigned StartOffset() const;
  unsigned EndOffset() const;
  unsigned TextLength() const { return EndOffset() - StartOffset(); }
  StringView Text(const NGFragmentItems& items) const;
  String GeneratedText() const {
    DCHECK_EQ(Type(), kGeneratedText);
    return generated_text_.text;
  }

  // Compute the inline position from text offset, in logical coordinate
  // relative to this fragment.
  LayoutUnit InlinePositionForOffset(StringView text,
                                     unsigned offset,
                                     LayoutUnit (*round_function)(float),
                                     AdjustMidCluster) const;

  LayoutUnit InlinePositionForOffset(StringView text, unsigned offset) const;

  // Compute line-relative coordinates for given offsets, this is not
  // flow-relative:
  // https://drafts.csswg.org/css-writing-modes-3/#line-directions
  std::pair<LayoutUnit, LayoutUnit> LineLeftAndRightForOffsets(
      StringView text,
      unsigned start_offset,
      unsigned end_offset) const;

  // The layout box of text in (start, end) range in local coordinate.
  // Start and end offsets must be between StartOffset() and EndOffset().
  PhysicalRect LocalRect(StringView text,
                         unsigned start_offset,
                         unsigned end_offset) const;

  // The base direction of line. Also known as the paragraph direction. This may
  // be different from the direction of the container box when first-line style
  // is used, or when 'unicode-bidi: plaintext' is used.
  // Note: This is valid only for |LineItem|.
  TextDirection BaseDirection() const;

  // Direction of this item valid for |TextItem| and |IsAtomicInline()|.
  // Note: <span> doesn't have text direction.
  TextDirection ResolvedDirection() const;

  // Converts the given point, relative to the fragment itself, into a position
  // in DOM tree.
  PositionWithAffinity PositionForPoint(const PhysicalOffset&) const;
  PositionWithAffinity PositionForPointInText(
      const PhysicalOffset& point,
      const NGInlineCursor& cursor) const;
  unsigned TextOffsetForPoint(const PhysicalOffset& point,
                              const NGFragmentItems& items) const;

 private:
  const LayoutBox* InkOverflowOwnerBox() const;
  LayoutBox* MutableInkOverflowOwnerBox();

  const LayoutObject* layout_object_;

  // TODO(kojii): We can make them sub-classes if we need to make the vector of
  // pointers. Sub-classing from DisplayItemClient prohibits copying and that we
  // cannot create a vector of this class.
  union {
    TextItem text_;
    GeneratedTextItem generated_text_;
    LineItem line_;
    BoxItem box_;
  };

  PhysicalRect rect_;

  std::unique_ptr<NGInkOverflow> ink_overflow_;

  // Item index delta to the next item for the same |LayoutObject|.
  wtf_size_t delta_to_next_for_same_layout_object_ = 0;

  // Note: We should not add |bidi_level_| because it is used only for layout.
  unsigned type_ : 2;           // ItemType
  unsigned sub_type_ : 3;       // NGTextType
  unsigned style_variant_ : 2;  // NGStyleVariant
  // TODO(yosin): We'll remove |is_generated_text_| field when we construct
  // |NGFragmentItem| without |NGPhysicalTextFragment| because usage of this
  // varaible, IsGeneratedText(), is not hot.
  unsigned is_generated_text_ : 1;  // NGPhysicalTextFragment::IsGenerated()
  unsigned is_hidden_for_paint_ : 1;
  // Note: For |TextItem| and |GeneratedTextItem|, |text_direction_| equals to
  // |ShapeResult::Direction()|.
  unsigned text_direction_ : 1;  // TextDirection.

  // Used only when |IsText()| to avoid re-computing ink overflow.
  unsigned ink_overflow_computed_ : 1;
};

}  // namespace blink

#endif  // THIRD_PARTY_BLINK_RENDERER_CORE_LAYOUT_NG_INLINE_NG_FRAGMENT_ITEM_H_
