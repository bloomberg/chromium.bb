// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "third_party/blink/renderer/core/layout/ng/ng_out_of_flow_layout_part.h"

#include "third_party/blink/renderer/core/layout/layout_block.h"
#include "third_party/blink/renderer/core/layout/layout_box.h"
#include "third_party/blink/renderer/core/layout/layout_flexible_box.h"
#include "third_party/blink/renderer/core/layout/layout_inline.h"
#include "third_party/blink/renderer/core/layout/layout_object.h"
#include "third_party/blink/renderer/core/layout/ng/inline/ng_physical_line_box_fragment.h"
#include "third_party/blink/renderer/core/layout/ng/layout_box_utils.h"
#include "third_party/blink/renderer/core/layout/ng/ng_absolute_utils.h"
#include "third_party/blink/renderer/core/layout/ng/ng_block_node.h"
#include "third_party/blink/renderer/core/layout/ng/ng_box_fragment_builder.h"
#include "third_party/blink/renderer/core/layout/ng/ng_constraint_space_builder.h"
#include "third_party/blink/renderer/core/layout/ng/ng_fragment.h"
#include "third_party/blink/renderer/core/layout/ng/ng_layout_result.h"
#include "third_party/blink/renderer/core/layout/ng/ng_length_utils.h"
#include "third_party/blink/renderer/core/layout/ng/ng_out_of_flow_positioned_descendant.h"
#include "third_party/blink/renderer/core/layout/ng/ng_physical_fragment.h"
#include "third_party/blink/renderer/core/paint/paint_layer_scrollable_area.h"
#include "third_party/blink/renderer/core/style/computed_style.h"

namespace blink {

namespace {

bool IsAnonymousContainer(const LayoutObject* layout_object) {
  return layout_object->IsAnonymousBlock() &&
         layout_object->CanContainAbsolutePositionObjects();
}

// When the containing block is a split inline, Legacy and NG use different
// containers to place the OOF descendant:
//  - Legacy uses the anonymous block generated by inline.
//  - NG uses the anonymous' parent block, that contains all the anonymous
//    continuations.
// This function finds the correct anonymous parent block.
const LayoutInline* GetOOFContainingBlockFromAnonymous(
    const LayoutObject* anonymous_block,
    EPosition child_position) {
  DCHECK(IsAnonymousContainer(anonymous_block));
  DCHECK(anonymous_block->IsBox());

  // Comments and code copied from
  // LayoutBox::ContainingBlockLogicalWidthForPositioned.
  // Ensure we compute our width based on the width of our rel-pos inline
  // container rather than any anonymous block created to manage a block-flow
  // ancestor of ours in the rel-pos inline's inline flow.
  LayoutBoxModelObject* absolute_containing_block =
      ToLayoutBox(anonymous_block)->Continuation();
  // There may be nested parallel inline continuations. We have now found the
  // innermost inline (which may not be relatively positioned). Locate the
  // inline that serves as the containing block of this box.
  while (!absolute_containing_block->CanContainOutOfFlowPositionedElement(
      child_position)) {
    absolute_containing_block =
        ToLayoutBoxModelObject(absolute_containing_block->Container());
  }
  DCHECK(absolute_containing_block->IsLayoutInline());
  // Make absolute_containing_block continuation root.
  return ToLayoutInline(absolute_containing_block->ContinuationRoot());
}

}  // namespace

NGOutOfFlowLayoutPart::NGOutOfFlowLayoutPart(
    const NGBlockNode& container_node,
    const NGConstraintSpace& container_space,
    const NGBoxStrut& border_scrollbar,
    NGBoxFragmentBuilder* container_builder)
    : NGOutOfFlowLayoutPart(container_node.IsAbsoluteContainer(),
                            container_node.IsFixedContainer(),
                            container_node.Style(),
                            container_space,
                            border_scrollbar,
                            container_builder) {}

NGOutOfFlowLayoutPart::NGOutOfFlowLayoutPart(
    bool contains_absolute,
    bool contains_fixed,
    const ComputedStyle& container_style,
    const NGConstraintSpace& container_space,
    const NGBoxStrut& border_scrollbar,
    NGBoxFragmentBuilder* container_builder,
    base::Optional<LogicalSize> initial_containing_block_fixed_size)
    : container_builder_(container_builder),
      contains_absolute_(contains_absolute),
      contains_fixed_(contains_fixed) {
  if (!container_builder->HasOutOfFlowDescendantCandidates() &&
      !To<LayoutBlock>(container_builder_->GetLayoutObject())
           ->HasPositionedObjects())
    return;

  default_containing_block_.style = &container_style;
  default_containing_block_.content_size_for_absolute =
      ShrinkAvailableSize(container_builder_->Size(), border_scrollbar);
  default_containing_block_.content_size_for_fixed =
      initial_containing_block_fixed_size
          ? *initial_containing_block_fixed_size
          : default_containing_block_.content_size_for_absolute;

  default_containing_block_.container_offset = LogicalOffset(
      border_scrollbar.inline_start, border_scrollbar.block_start);

  NGPhysicalBoxStrut physical_border_scrollbar =
      border_scrollbar.ConvertToPhysical(container_style.GetWritingMode(),
                                         container_style.Direction());
  default_containing_block_.physical_container_offset = PhysicalOffset(
      physical_border_scrollbar.left, physical_border_scrollbar.top);
}

void NGOutOfFlowLayoutPart::Run(const LayoutBox* only_layout) {
  Vector<NGOutOfFlowPositionedDescendant> descendant_candidates;
  const LayoutObject* current_container = container_builder_->GetLayoutObject();

  container_builder_->GetAndClearOutOfFlowDescendantCandidates(
      &descendant_candidates, current_container);

  if (descendant_candidates.IsEmpty() &&
      !To<LayoutBlock>(current_container)->HasPositionedObjects())
    return;

  // Special case: containing block is a split inline.
  // If current container was generated by a split inline, do not position
  // descendants inside this container. Let its non-anonymous parent handle it.
  // Only parent has geometry information needed to compute containing block
  // geometry.
  // See "Special case: oof css container" comment for detailed description.
  if (descendant_candidates.size() > 0 && current_container && !only_layout &&
      IsAnonymousContainer(current_container)) {
    const LayoutInline* absolute_containing_block =
        contains_absolute_ ? GetOOFContainingBlockFromAnonymous(
                                 current_container, EPosition::kAbsolute)
                           : nullptr;
    const LayoutInline* fixed_containing_block =
        contains_fixed_ ? GetOOFContainingBlockFromAnonymous(current_container,
                                                             EPosition::kFixed)
                        : nullptr;
    for (auto& candidate : descendant_candidates) {
      if (absolute_containing_block &&
          absolute_containing_block->CanContainOutOfFlowPositionedElement(
              candidate.node.Style().GetPosition())) {
        candidate.inline_container = absolute_containing_block;
      } else if (fixed_containing_block &&
                 fixed_containing_block->CanContainOutOfFlowPositionedElement(
                     candidate.node.Style().GetPosition())) {
        candidate.inline_container = fixed_containing_block;
      }
      container_builder_->AddOutOfFlowDescendant(candidate);
    }
    return;
  }

  HashSet<const LayoutObject*> placed_objects;
  LayoutDescendantCandidates(&descendant_candidates, only_layout,
                             &placed_objects);

  if (only_layout)
    return;


  wtf_size_t prev_placed_objects_size = placed_objects.size();
  while (SweepLegacyDescendants(&placed_objects)) {
    container_builder_->GetAndClearOutOfFlowDescendantCandidates(
        &descendant_candidates, current_container);

    // We must have at least one new candidate, otherwise we shouldn't have
    // entered this branch.
    DCHECK_GT(descendant_candidates.size(), 0u);

    LayoutDescendantCandidates(&descendant_candidates, only_layout,
                               &placed_objects);

    // Legacy currently has a bug where an OOF-positioned node is present
    // within the current node's |LayoutBlock::PositionedObjects|, however it
    // is not the containing-block for this node.
    //
    // This results in |LayoutDescendantCandidates| never performing layout on
    // any additional objects.
    wtf_size_t placed_objects_size = placed_objects.size();
    if (prev_placed_objects_size == placed_objects_size) {
      NOTREACHED();
      break;
    }
    prev_placed_objects_size = placed_objects_size;
  }
}

// Gather candidates that weren't present in the OOF candidates list.
// This occurs when a candidate is separated from container by a legacy node.
// E.g.
// <div style="position: relative;">
//   <div style="display: flex;">
//     <div style="position: absolute;"></div>
//   </div>
// </div>
// Returns false if no new candidates were found.
bool NGOutOfFlowLayoutPart::SweepLegacyDescendants(
    HashSet<const LayoutObject*>* placed_objects) {
  const auto* container_block =
      DynamicTo<LayoutBlock>(container_builder_->GetLayoutObject());
  if (!container_block)
    return false;
  TrackedLayoutBoxListHashSet* legacy_objects =
      container_block->PositionedObjects();
  if (!legacy_objects || legacy_objects->size() == placed_objects->size())
    return false;
  for (LayoutObject* legacy_object : *legacy_objects) {
    if (placed_objects->Contains(legacy_object))
      continue;

    // Flex OOF children may have center alignment or similar, and in order
    // to determine their static position correctly need to have a valid
    // size first.
    // We perform a pre-layout to correctly determine the static position.
    // Copied from LayoutBlock::LayoutPositionedObject
    LayoutBox* layout_box = ToLayoutBox(legacy_object);
    // TODO(dgrogan): The NG flexbox implementation doesn't have an
    // analogous method yet, so abspos children of NG flexboxes that have a
    // legacy containing block will not be positioned correctly.
    if (layout_box->Parent()->IsFlexibleBox()) {
      LayoutFlexibleBox* parent = ToLayoutFlexibleBox(layout_box->Parent());
      if (parent->SetStaticPositionForPositionedLayout(*layout_box)) {
        NGOutOfFlowPositionedDescendant descendant((NGBlockNode(layout_box)),
                                                   NGStaticPosition());
        LayoutDescendant(descendant, /* only_layout */ nullptr);
        parent->SetStaticPositionForPositionedLayout(*layout_box);
      }
    }

    NGStaticPosition static_position =
        LayoutBoxUtils::ComputeStaticPositionFromLegacy(*layout_box,
                                                        container_builder_);

    const LayoutObject* css_container = layout_box->Container();
    if (IsAnonymousContainer(css_container)) {
      css_container = GetOOFContainingBlockFromAnonymous(
          css_container, layout_box->Style()->GetPosition());
    }
    container_builder_->AddOutOfFlowLegacyCandidate(
        NGBlockNode(layout_box), static_position,
        ToLayoutInlineOrNull(css_container));
  }
  return true;
}

const NGOutOfFlowLayoutPart::ContainingBlockInfo&
NGOutOfFlowLayoutPart::GetContainingBlockInfo(
    const NGOutOfFlowPositionedDescendant& descendant) const {
  if (descendant.inline_container) {
    const auto it = containing_blocks_map_.find(descendant.inline_container);
    DCHECK(it != containing_blocks_map_.end());
    return it->value;
  }
  return default_containing_block_;
}

void NGOutOfFlowLayoutPart::ComputeInlineContainingBlocks(
    const Vector<NGOutOfFlowPositionedDescendant>& descendants) {
  NGBoxFragmentBuilder::InlineContainingBlockMap inline_container_fragments;

  for (auto& descendant : descendants) {
    if (descendant.inline_container &&
        !inline_container_fragments.Contains(descendant.inline_container)) {
      NGBoxFragmentBuilder::InlineContainingBlockGeometry inline_geometry = {};
      inline_container_fragments.insert(descendant.inline_container,
                                        inline_geometry);
    }
  }
  // Fetch start/end fragment info.
  container_builder_->ComputeInlineContainerFragments(
      &inline_container_fragments);
  LogicalSize container_builder_size = container_builder_->Size();
  PhysicalSize container_builder_physical_size =
      ToPhysicalSize(container_builder_size,
                     default_containing_block_.style->GetWritingMode());
  // Translate start/end fragments into ContainingBlockInfo.
  for (auto& block_info : inline_container_fragments) {
    // Variables needed to describe ContainingBlockInfo
    const ComputedStyle* inline_cb_style = block_info.key->Style();
    LogicalSize inline_cb_size;
    LogicalOffset container_offset;
    PhysicalOffset physical_container_offset;

    DCHECK(block_info.value.has_value());
    DCHECK(inline_cb_style);
    NGBoxStrut inline_cb_borders = ComputeBordersForInline(*inline_cb_style);

    // The calculation below determines the size of the inline containing block
    // rect.
    //
    // To perform this calculation we:
    // 1. Determine the start_offset "^", this is at the logical-start (wrt.
    //    default containing block), of the start fragment rect.
    // 2. Determine the end_offset "$", this is at the logical-end (wrt.
    //    default containing block), of the end  fragment rect.
    // 3. Determine the logical rectangle defined by these two offsets.
    //
    // Case 1a: Same direction, overlapping fragments.
    //      +---------------
    // ---> |^*****-------->
    //      +*----*---------
    //       *    *
    // ------*----*+
    // ----> *****$| --->
    // ------------+
    //
    // Case 1b: Different direction, overlapping fragments.
    //      +---------------
    // ---> ^******* <-----|
    //      *------*--------
    //      *      *
    // -----*------*
    // |<-- *******$ --->
    // ------------+
    //
    // Case 2a: Same direction, non-overlapping fragments.
    //             +--------
    // --------->  |^ ----->
    //             +*-------
    //              *
    // --------+    *
    // ------->|    $ --->
    // --------+
    //
    // Case 2b: Same direction, non-overlapping fragments.
    //             +--------
    // --------->  ^ <-----|
    //             *--------
    //             *
    // --------+   *
    // | <------   $  --->
    // --------+
    //
    // Note in cases [1a, 2a] we need to account for the inline borders of the
    // rectangles, where-as in [1b, 2b] we do not. This is handled by the
    // is_same_direction check(s).
    //
    // Note in cases [2a, 2b] we don't allow a "negative" containing block size,
    // we clamp negative sizes to zero.
    WritingMode container_writing_mode =
        default_containing_block_.style->GetWritingMode();
    TextDirection container_direction =
        default_containing_block_.style->Direction();

    bool is_same_direction =
        container_direction == inline_cb_style->Direction();

    // Step 1 - determine the start_offset.
    const PhysicalRect& start_rect =
        block_info.value->start_fragment_union_rect;
    LogicalOffset start_offset = start_rect.offset.ConvertToLogical(
        container_writing_mode, container_direction,
        container_builder_physical_size, start_rect.size);

    // Make sure we add the inline borders, we don't need to do this in the
    // inline direction if the blocks are in opposite directions.
    start_offset.block_offset += inline_cb_borders.block_start;
    if (is_same_direction)
      start_offset.inline_offset += inline_cb_borders.inline_start;

    // Step 2 - determine the end_offset.
    const PhysicalRect& end_rect = block_info.value->end_fragment_union_rect;
    LogicalOffset end_offset = end_rect.offset.ConvertToLogical(
        container_writing_mode, container_direction,
        container_builder_physical_size, end_rect.size);

    // Add in the size of the fragment to get the logical end of the fragment.
    end_offset += end_rect.size.ConvertToLogical(container_writing_mode);

    // Make sure we subtract the inline borders, we don't need to do this in the
    // inline direction if the blocks are in opposite directions.
    end_offset.block_offset -= inline_cb_borders.block_end;
    if (is_same_direction)
      end_offset.inline_offset -= inline_cb_borders.inline_end;

    // Make sure we don't end up with a rectangle with "negative" size.
    end_offset.inline_offset =
        std::max(end_offset.inline_offset, start_offset.inline_offset);

    // Step 3 - determine the logical rectangle.

    // Determine the logical size of the containing block.
    inline_cb_size = {end_offset.inline_offset - start_offset.inline_offset,
                      end_offset.block_offset - start_offset.block_offset};
    DCHECK_GE(inline_cb_size.inline_size, LayoutUnit());
    DCHECK_GE(inline_cb_size.block_size, LayoutUnit());

    // Determine the container offsets.
    container_offset = start_offset;
    physical_container_offset = container_offset.ConvertToPhysical(
        container_writing_mode, container_direction,
        container_builder_physical_size,
        ToPhysicalSize(inline_cb_size, container_writing_mode));
    containing_blocks_map_.insert(
        block_info.key,
        ContainingBlockInfo{inline_cb_style, inline_cb_size, inline_cb_size,
                            container_offset, physical_container_offset});
  }
}

void NGOutOfFlowLayoutPart::LayoutDescendantCandidates(
    Vector<NGOutOfFlowPositionedDescendant>* descendant_candidates,
    const LayoutBox* only_layout,
    HashSet<const LayoutObject*>* placed_objects) {
  while (descendant_candidates->size() > 0) {
    ComputeInlineContainingBlocks(*descendant_candidates);
    for (auto& candidate : *descendant_candidates) {
      if (IsContainingBlockForDescendant(candidate) &&
          (!only_layout || candidate.node.GetLayoutBox() == only_layout)) {
        scoped_refptr<const NGLayoutResult> result =
            LayoutDescendant(candidate, only_layout);
        container_builder_->AddChild(result->PhysicalFragment(),
                                     result->OutOfFlowPositionedOffset(),
                                     candidate.inline_container);
        placed_objects->insert(candidate.node.GetLayoutBox());
        if (candidate.node.GetLayoutBox() != only_layout)
          candidate.node.UseLegacyOutOfFlowPositioning();
      } else {
        container_builder_->AddOutOfFlowDescendant(candidate);
      }
    }
    // Sweep any descendants that might have been added.
    // This happens when an absolute container has a fixed child.
    descendant_candidates->Shrink(0);
    container_builder_->GetAndClearOutOfFlowDescendantCandidates(
        descendant_candidates, container_builder_->GetLayoutObject());
  }
}

scoped_refptr<const NGLayoutResult> NGOutOfFlowLayoutPart::LayoutDescendant(
    const NGOutOfFlowPositionedDescendant& descendant,
    const LayoutBox* only_layout) {
  NGBlockNode node = descendant.node;

  // "NGOutOfFlowLayoutPart container is ContainingBlock" invariant cannot
  // be enforced for tables. Tables are special, in that the ContainingBlock is
  // TABLE, but constraint space is generated by TBODY/TR/. This happens
  // because TBODY/TR are not LayoutBlocks, but LayoutBoxModelObjects.
  DCHECK((container_builder_->GetLayoutObject() ==
          node.GetLayoutBox()->ContainingBlock()) ||
         node.GetLayoutBox()->ContainingBlock()->IsTable());

  const ContainingBlockInfo& container_info =
      GetContainingBlockInfo(descendant);
  const ComputedStyle& container_style = *container_info.style;
  const ComputedStyle& descendant_style = node.Style();

  WritingMode container_writing_mode = container_style.GetWritingMode();
  WritingMode descendant_writing_mode = descendant_style.GetWritingMode();

  LogicalSize container_content_size =
      container_info.ContentSize(descendant_style.GetPosition());
  LogicalSize container_content_size_in_child_writing_mode =
      ToPhysicalSize(container_content_size, container_writing_mode)
          .ConvertToLogical(descendant_writing_mode);

  // Determine if we need to actually run the full OOF-positioned sizing, and
  // positioning algorithm.
  //
  // When this candidate has an inline container, the container may move without
  // setting |NeedsLayout()| to the candidate and that there are cases where the
  // cache validity cannot be determined.
  if (!descendant.inline_container) {
    if (scoped_refptr<const NGLayoutResult> cached_result =
            node.CachedLayoutResultForOutOfFlowPositioned(
                container_content_size_in_child_writing_mode))
      return cached_result;
  }

  // Adjust the |static_position| (which is currently relative to the default
  // container's border-box). ng_absolute_utils expects the static position to
  // be relative to the container's padding-box.
  NGStaticPosition static_position(descendant.static_position);
  static_position.offset -= container_info.physical_container_offset;

  NGConstraintSpace descendant_constraint_space =
      NGConstraintSpaceBuilder(container_writing_mode, descendant_writing_mode,
                               /* is_new_fc */ true)
          .SetTextDirection(descendant_style.Direction())
          .SetAvailableSize(container_content_size)
          .SetPercentageResolutionSize(container_content_size)
          .ToConstraintSpace();

  base::Optional<PaintLayerScrollableArea::FreezeScrollbarsScope>
      freeze_scrollbars;
  do {
    scoped_refptr<const NGLayoutResult> layout_result =
        Layout(node, descendant_constraint_space, static_position,
               container_content_size, container_info, only_layout);

    if (!freeze_scrollbars.has_value()) {
      // Since out-of-flow positioning sets up a constraint space with fixed
      // inline-size, the regular layout code (|NGBlockNode::Layout()|) cannot
      // re-layout if it discovers that a scrollbar was added or removed. Handle
      // that situation here. The assumption is that if preferred logical widths
      // are dirty after layout, AND its inline-size depends on preferred
      // logical widths, it means that scrollbars appeared or disappeared. We
      // have the same logic in legacy layout in
      // |LayoutBlockFlow::UpdateBlockLayout()|.
      if (node.GetLayoutBox()->PreferredLogicalWidthsDirty() &&
          AbsoluteNeedsChildInlineSize(descendant_style)) {
        // Freeze the scrollbars for this layout pass. We don't want them to
        // change *again*.
        freeze_scrollbars.emplace();
        continue;
      }
    }

    return layout_result;
  } while (true);
}

scoped_refptr<const NGLayoutResult> NGOutOfFlowLayoutPart::Layout(
    NGBlockNode node,
    const NGConstraintSpace& descendant_constraint_space,
    const NGStaticPosition& static_position,
    LogicalSize container_content_size,
    const ContainingBlockInfo& container_info,
    const LayoutBox* only_layout) {
  const ComputedStyle& container_style = *container_info.style;
  const ComputedStyle& descendant_style = node.Style();
  WritingMode container_writing_mode = container_style.GetWritingMode();
  WritingMode descendant_writing_mode = descendant_style.GetWritingMode();

  LogicalSize container_content_size_in_child_writing_mode =
      ToPhysicalSize(container_content_size, container_writing_mode)
          .ConvertToLogical(descendant_writing_mode);
  NGBoxStrut border_padding =
      ComputeBorders(descendant_constraint_space, node) +
      ComputePadding(descendant_constraint_space, descendant_style);

  // The |block_estimate| is wrt. the descendant's writing mode.
  base::Optional<LayoutUnit> block_estimate;
  base::Optional<MinMaxSize> min_max_size;
  scoped_refptr<const NGLayoutResult> layout_result = nullptr;

  bool is_replaced = node.IsReplaced();
  bool should_be_considered_as_replaced = node.ShouldBeConsideredAsReplaced();

  if (AbsoluteNeedsChildInlineSize(descendant_style) ||
      NeedMinMaxSize(descendant_style) || should_be_considered_as_replaced) {
    // This is a new formatting context, so whatever happened on the outside
    // doesn't concern us.
    MinMaxSizeInput input(container_content_size.block_size);
    min_max_size = ComputeMinAndMaxContentSizeForOutOfFlow(
        descendant_constraint_space, node, border_padding, input);
  }

  base::Optional<LogicalSize> replaced_size;
  if (is_replaced) {
    replaced_size =
        ComputeReplacedSize(node, descendant_constraint_space, min_max_size);
  } else if (should_be_considered_as_replaced) {
    replaced_size = LogicalSize{
        min_max_size->ShrinkToFit(
            descendant_constraint_space.AvailableSize().inline_size),
        kIndefiniteSize};
  }
  NGAbsolutePhysicalPosition node_position =
      ComputePartialAbsoluteWithChildInlineSize(
          descendant_constraint_space, descendant_style, border_padding,
          static_position, min_max_size, replaced_size, container_writing_mode,
          container_style.Direction());

  // |should_be_considered_as_replaced| sets the inline-size.
  // It does not set the block-size. This is a compatibility quirk.
  if (!is_replaced && should_be_considered_as_replaced)
    replaced_size.reset();

  if (AbsoluteNeedsChildBlockSize(descendant_style)) {
    layout_result =
        GenerateFragment(node, container_content_size_in_child_writing_mode,
                         block_estimate, node_position);

    NGFragment fragment(descendant_writing_mode,
                        layout_result->PhysicalFragment());

    block_estimate = fragment.BlockSize();
  }

  ComputeFullAbsoluteWithChildBlockSize(
      descendant_constraint_space, descendant_style, border_padding,
      static_position, block_estimate, replaced_size, container_writing_mode,
      container_style.Direction(), &node_position);

  // Skip this step if we produced a fragment when estimating the block-size.
  if (!layout_result) {
    block_estimate =
        node_position.size.ConvertToLogical(descendant_writing_mode).block_size;
    layout_result =
        GenerateFragment(node, container_content_size_in_child_writing_mode,
                         block_estimate, node_position);
  }

  // TODO(mstensho): Move the rest of this method back into LayoutCandidate().

  if (node.GetLayoutBox()->IsLayoutNGObject()) {
    To<LayoutBlock>(node.GetLayoutBox())
        ->SetIsLegacyInitiatedOutOfFlowLayout(false);
  }
  // Legacy grid and flexbox handle OOF-positioned margins on their own, and
  // break if we set them here.
  if (!container_builder_->GetLayoutObject()
           ->Style()
           ->IsDisplayFlexibleOrGridBox())
    node.GetLayoutBox()->SetMargin(node_position.margins);

  NGBoxStrut inset = node_position.inset.ConvertToLogical(
      container_writing_mode, default_containing_block_.style->Direction());

  // |inset| is relative to the container's padding-box. Convert this to being
  // relative to the default container's border-box.
  LogicalOffset offset = container_info.container_offset;
  offset.inline_offset += inset.inline_start;
  offset.block_offset += inset.block_start;

  base::Optional<LayoutUnit> y = ComputeAbsoluteDialogYPosition(
      *node.GetLayoutBox(), layout_result->PhysicalFragment().Size().height);
  if (y.has_value()) {
    if (IsHorizontalWritingMode(container_writing_mode))
      offset.block_offset = *y;
    else
      offset.inline_offset = *y;
  }

  if (only_layout) {
    layout_result->GetMutableForOutOfFlow().SetOutOfFlowPositionedOffset(
        offset);
    return layout_result;
  }

  // Special case: oof css container is a split inline.
  // When css container spans multiple anonymous blocks, its dimensions
  // can only be computed by a block that is an ancestor of all fragments
  // generated by css container. That block is parent of anonymous containing
  // block.
  // That is why instead of OOF being placed by its anonymous container,
  // they get placed by anonymous container's parent.
  // This is different from all other OOF blocks, and requires special
  // handling in several places in the OOF code.
  // There is an exception to special case: if anonymous block is Legacy,
  // we cannot do the fancy multiple anonymous block traversal, and we handle
  // it like regular blocks.
  //
  // Detailed example:
  //
  // If Layout tree looks like this:
  // LayoutNGBlockFlow#container
  //   LayoutNGBlockFlow (anonymous#1)
  //     LayoutInline#1 (relative)
  //   LayoutNGBlockFlow (anonymous#2 relative)
  //     LayoutNGBlockFlow#oof (positioned)
  //   LayoutNGBlockFlow (anonymous#3)
  //     LayoutInline#3 (continuation)
  //
  // The containing block geometry is defined by split inlines,
  // LayoutInline#1, LayoutInline#3.
  // Css container anonymous#2 does not have information needed
  // to compute containing block geometry.
  // Therefore, #oof cannot be placed by anonymous#2. NG handles this case
  // by placing #oof in parent of anonymous (#container).
  //
  // But, PaintPropertyTreeBuilder expects #oof.Location() to be wrt
  // css container, #anonymous2. This is why the code below adjusts
  // the legacy offset from being wrt #container to being wrt #anonymous2.
  const LayoutObject* container = node.GetLayoutBox()->Container();
  if (container->IsAnonymousBlock()) {
    LogicalOffset container_offset =
        container_builder_->GetChildOffset(container);
    offset -= container_offset;
  } else if (container->IsLayoutInline() &&
             container->ContainingBlock()->IsAnonymousBlock()) {
    // Location of OOF with inline container, and anonymous containing block
    // is wrt container.
    LogicalOffset container_offset =
        container_builder_->GetChildOffset(container->ContainingBlock());
    offset -= container_offset;
  }

  layout_result->GetMutableForOutOfFlow().SetOutOfFlowPositionedOffset(offset);
  return layout_result;
}

bool NGOutOfFlowLayoutPart::IsContainingBlockForDescendant(
    const NGOutOfFlowPositionedDescendant& descendant) {
  EPosition position = descendant.node.Style().GetPosition();

  // Descendants whose containing block is inline are always positioned
  // inside closest parent block flow.
  if (descendant.inline_container) {
    DCHECK(
        descendant.node.Style().GetPosition() == EPosition::kAbsolute &&
            descendant.inline_container->CanContainAbsolutePositionObjects() ||
        (descendant.node.Style().GetPosition() == EPosition::kFixed &&
         descendant.inline_container->CanContainFixedPositionObjects()));
    return container_builder_->GetLayoutObject() ==
           descendant.node.GetLayoutBox()->ContainingBlock();
  }
  return (contains_absolute_ && position == EPosition::kAbsolute) ||
         (contains_fixed_ && position == EPosition::kFixed);
}

// The fragment is generated in one of these two scenarios:
// 1. To estimate descendant's block size, in this case block_size is
//    container's available size.
// 2. To compute final fragment, when block size is known from the absolute
//    position calculation.
scoped_refptr<const NGLayoutResult> NGOutOfFlowLayoutPart::GenerateFragment(
    NGBlockNode descendant,
    const LogicalSize& container_content_size_in_child_writing_mode,
    const base::Optional<LayoutUnit>& block_estimate,
    const NGAbsolutePhysicalPosition& node_position) {
  // As the |block_estimate| is always in the descendant's writing mode, we
  // build the constraint space in the descendant's writing mode.
  WritingMode writing_mode = descendant.Style().GetWritingMode();

  LayoutUnit inline_size =
      node_position.size.ConvertToLogical(writing_mode).inline_size;
  LayoutUnit block_size =
      block_estimate ? *block_estimate
                     : container_content_size_in_child_writing_mode.block_size;

  LogicalSize available_size(inline_size, block_size);

  // TODO(atotic) will need to be adjusted for scrollbars.
  NGConstraintSpaceBuilder builder(writing_mode, writing_mode,
                                   /* is_new_fc */ true);
  builder.SetAvailableSize(available_size)
      .SetTextDirection(descendant.Style().Direction())
      .SetPercentageResolutionSize(container_content_size_in_child_writing_mode)
      .SetIsFixedSizeInline(true);
  if (block_estimate)
    builder.SetIsFixedSizeBlock(true);
  NGConstraintSpace space = builder.ToConstraintSpace();

  return descendant.Layout(space);
}

}  // namespace blink
