diff --git a/third_party/harfbuzz/contrib/harfbuzz-unicode.c b/third_party/harfbuzz/contrib/harfbuzz-unicode.c
index 9b3c43e..51dd4ea 100644
--- a/third_party/harfbuzz/contrib/harfbuzz-unicode.c
+++ b/third_party/harfbuzz/contrib/harfbuzz-unicode.c
@@ -6,8 +6,9 @@
 #include <harfbuzz-shaper.h>
 #include "harfbuzz-unicode.h"
 
-#include "tables/script-properties.h"
 #include "tables/grapheme-break-properties.h"
+#include "tables/mirroring-properties.h"
+#include "tables/script-properties.h"
 
 uint32_t
 utf16_to_code_point(const uint16_t *chars, size_t len, ssize_t *iter) {
@@ -234,10 +235,30 @@ HB_GetGraphemeAndLineBreakClass(HB_UChar32 ch, HB_GraphemeClass *gclass, HB_Line
   *breakclass = HB_GetLineBreakClass(ch);
 }
 
+static int
+mirroring_property_cmp(const void *vkey, const void *vcandidate) {
+  const uint32_t key = (uint32_t) (intptr_t) vkey;
+  const struct mirroring_property *candidate = vcandidate;
+
+  if (key < candidate->a) {
+    return -1;
+  } else if (key > candidate->a) {
+    return 1;
+  } else {
+    return 0;
+  }
+}
+
 HB_UChar16
 HB_GetMirroredChar(HB_UChar16 ch) {
-  abort();
-  return 0;
+  const void *mprop = bsearch((void *) (intptr_t) ch, mirroring_properties,
+                              mirroring_properties_count,
+                              sizeof(struct mirroring_property),
+                              mirroring_property_cmp);
+  if (!mprop)
+    return ch;
+
+  return ((const struct mirroring_property *) mprop)->b;
 }
 
 void *
diff --git a/third_party/harfbuzz/src/harfbuzz-shaper.cpp b/third_party/harfbuzz/src/harfbuzz-shaper.cpp
index 36b9282..3628c88 100644
--- a/third_party/harfbuzz/src/harfbuzz-shaper.cpp
+++ b/third_party/harfbuzz/src/harfbuzz-shaper.cpp
@@ -433,7 +433,7 @@ void HB_HeuristicSetGlyphAttributes(HB_ShaperItem *item)
 
     // ### zeroWidth and justification are missing here!!!!!
 
-    assert(item->num_glyphs <= length);
+    assert(length <= item->num_glyphs);
 
 //     qDebug("QScriptEngine::heuristicSetGlyphAttributes, num_glyphs=%d", item->num_glyphs);
     HB_GlyphAttributes *attributes = item->attributes;
@@ -451,7 +451,6 @@ void HB_HeuristicSetGlyphAttributes(HB_ShaperItem *item)
         }
         ++glyph_pos;
     }
-    assert(glyph_pos == item->num_glyphs);
 
     // first char in a run is never (treated as) a mark
     int cStart = 0;
diff --git a/third_party/harfbuzz/src/harfbuzz-hebrew.c b/third_party/harfbuzz/src/harfbuzz-hebrew.c
index 533a063..2bda386 100644
--- a/third_party/harfbuzz/src/harfbuzz-hebrew.c
+++ b/third_party/harfbuzz/src/harfbuzz-hebrew.c
@@ -56,6 +56,8 @@ HB_Bool HB_HebrewShape(HB_ShaperItem *shaper_item)
 
     assert(shaper_item->item.script == HB_Script_Hebrew);
 
+    HB_HeuristicSetGlyphAttributes(shaper_item);
+
 #ifndef NO_OPENTYPE
     if (HB_SelectScript(shaper_item, hebrew_features)) {
 
@@ -64,7 +66,6 @@ HB_Bool HB_HebrewShape(HB_ShaperItem *shaper_item)
             return FALSE;
 
 
-        HB_HeuristicSetGlyphAttributes(shaper_item);
         HB_OpenTypeShape(shaper_item, /*properties*/0);
         return HB_OpenTypePosition(shaper_item, availableGlyphs, /*doLogClusters*/TRUE);
     }
