<!DOCTYPE html>
<script src="../resources/testharness.js"></script>
<script src="../resources/testharnessreport.js"></script>
<script src="../resources/mojo-helpers.js"></script>
<script src="resources/mock-imagecapture.js"></script>
<body>
<canvas id='canvas' width=10 height=10/>
</body>
<script>

const focusModeNames = ["unavailable", "manual", "single-shot", "continuous"];

// This test verifies that ImageCapture can call setOptions()s, with a mock Mojo
// interface implementation.
async_test(function(t) {
  var canvas = document.getElementById('canvas');
  var context = canvas.getContext("2d");
  context.fillStyle = "red";
  context.fillRect(0, 0, 10, 10);
  var stream = canvas.captureStream();

  var theMock = null;
  const optionsDict = { zoom : 7,
                        imageWidth : 1080,
                        imageHeight : 100,
                        focusMode : "single-shot",
                        pointsOfInterest : [{x : 0.1, y : 0.2},
                                            {x : 0.3, y : 0.4}],
                        exposureCompensation : 133,
                      };
  mockImageCaptureReady
    .then(mock => {
      theMock = mock;
      return new ImageCapture(stream.getVideoTracks()[0]);
    })
    .catch(error => {
      assert_unreached("Error creating MockImageCapture: " + error);
    })
    .then(capturer => {
      return capturer.setOptions(optionsDict);
    })
    .then(function() {
      assert_true(theMock.options().has_zoom, 'has_zoom must be true');
      assert_equals(optionsDict.zoom, theMock.options().zoom, 'zoom value');
      assert_equals(true, theMock.options().has_width, 'has_width must be true');
      assert_equals(optionsDict.imageWidth, theMock.options().width, 'width value');
      assert_equals(true, theMock.options().has_height, 'has_height must be true');
      assert_equals(optionsDict.imageHeight, theMock.options().height, 'height value');
      assert_equals(true, theMock.options().has_focus_mode, 'has_focus_mode must be true');
      assert_equals(optionsDict.focusMode,
                    focusModeNames[theMock.options().focus_mode],
                    'focusMode value');
      assert_equals(optionsDict.pointsOfInterest.length,
                    theMock.options().points_of_interest.length,
                    'amount of points of interest');
      for (i = 0; i < optionsDict.pointsOfInterest.length; i++) {
          assert_approx_equals(optionsDict.pointsOfInterest[i].x,
                              theMock.options().points_of_interest[i].x,
                              0.001,
                              'pointsOfInterest\'s x');
          assert_approx_equals(optionsDict.pointsOfInterest[i].y,
                               theMock.options().points_of_interest[i].y,
                               0.001,
                               'pointsOfInterest\' y');
      }
      assert_equals(true, theMock.options().has_exposure_compensation,
                    'has_exposure_compensation must be true');
      assert_equals(optionsDict.exposureCompensation,
                    theMock.options().exposure_compensation,
                    'exposure_compensation value');

      t.done();
    })
    .catch(error => {
      assert_unreached("Error during setOptions(): " + error);
    });
}, 'exercises the ImageCapture API setOptions()');

</script>
