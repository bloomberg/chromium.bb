<!DOCTYPE html>
<script src="../resources/testharness.js"></script>
<script src="../resources/testharness-helpers.js"></script>
<script src="../resources/testharnessreport.js"></script>
<script src="resources/bluetooth-helpers.js"></script>
<script>
'use strict';

test(function(t) { assert_true(window.testRunner instanceof Object); t.done(); },
     'window.testRunner is required for the following tests.');

sequential_promise_test(() => {
  testRunner.setBluetoothMockDataSet('EmptyAdapter');
  return assert_promise_rejects(requestDeviceWithKeyDown(),
                                new TypeError());
}, 'Requires an argument.');

sequential_promise_test(() => {
  testRunner.setBluetoothMockDataSet('EmptyAdapter');
  return assert_promise_rejects(requestDeviceWithKeyDown({}),
                                new TypeError());
}, 'RequestDeviceOptions requires a |filters| member.');

sequential_promise_test(() => {
  testRunner.setBluetoothMockDataSet('FailStartDiscoveryAdapter');
  return assert_promise_rejects_with_message(
    requestDeviceWithKeyDown({filters: [{services: ['generic_access']}]}),
    {name: 'NotFoundError', message: 'Couldn\'t start discovery session.'},
    'The adapter failed to start a discovery session.');
}, 'Discovery session fails to start.');

sequential_promise_test(() => {
  testRunner.setBluetoothMockDataSet('EmptyAdapter');
  return assert_promise_rejects_with_message(
    requestDeviceWithKeyDown({filters: [{services: ['generic_access']}]}),
    {name: 'NotFoundError', message: 'No Bluetooth devices in range.'},
    'No Bluetooth devices in range.');
}, 'Reject with NotFoundError if there are no devices around.');

sequential_promise_test(() => {
  testRunner.setBluetoothMockDataSet('GenericAccessAdapter');
  return Promise.all([
    requestDeviceWithKeyDown({filters: [{services: [generic_access.alias]}]}),
    requestDeviceWithKeyDown({filters: [{services: [generic_access.name]}]}),
    requestDeviceWithKeyDown({filters: [{services: [generic_access.uuid]}]})
  ]).then(devices => {
    devices.forEach(device => {
      assert_equals(device.constructor.name, 'BluetoothDevice');
    });
  });
}, 'Mock will resolve.');

sequential_promise_test(() => {
  testRunner.setBluetoothMockDataSet('GenericAccessAdapter');
  return assert_promise_rejects(
    navigator.bluetooth.requestDevice({filters: [{services: ['generic_access']}]}),
    'SecurityError');
}, 'Requires a user gesture.');

sequential_promise_test(() => {
  testRunner.setBluetoothMockDataSet('GenericAccessAdapter');
  return callWithKeyDown(() => {
    var first = navigator.bluetooth.requestDevice({filters: [{services: ['generic_access']}]});
    var second = navigator.bluetooth.requestDevice({filters: [{services: ['generic_access']}]});
    return Promise.all([
      first.then(device => assert_equals(device.constructor.name, 'BluetoothDevice')),
      assert_promise_rejects(second, 'SecurityError'),
    ]);
  });
}, 'Consumes a user gesture.');

sequential_promise_test(() => {
  testRunner.setBluetoothMockDataSet('GenericAccessAdapter');
  return Promise.all([
    requestDeviceWithKeyDown({filters: [{services: [generic_access.alias]}]}),
    requestDeviceWithKeyDown({filters: [{services: [generic_access.name]}]}),
    requestDeviceWithKeyDown({filters: [{services: [generic_access.uuid]}]})
  ]).then(devices => {
    // requestDevice should return the same object if it was created
    // earlier. https://crbug.com/495270
    // TODO(ortuno): Change to assert_equals.
    assert_not_equals(devices[0], devices[1]);
    assert_not_equals(devices[1], devices[2]);
  });
}, 'Returned device should always be the same.');

sequential_promise_test(() => {
  testRunner.setBluetoothMockDataSet('ScanFilterCheckingAdapter');
  // The work of this test is done in the ScanFilterCheckingAdapter. It asserts
  // that this requestDevice() call tells the platform to scan for only devices
  // that include the Battery, Glucose, or Heart Rate services.
  return requestDeviceWithKeyDown({
    filters: [
      {services: ['battery_service']},
      {services: ['glucose', 'heart_rate']}
    ],
    // The optionalServices shouldn't affect the platform's scan.
    optionalServices: [generic_access.name]
  });
}, 'Filters restrict the platform\'s Bluetooth scan.');

sequential_promise_test(() => {
  testRunner.setBluetoothMockDataSet('GlucoseHeartRateAdapter');
  return requestDeviceWithKeyDown({filters: [{services: ['glucose']}]})
    .then(device => assert_equals(device.name, 'Glucose Device'));
}, 'Simple filter selects matching device.');

sequential_promise_test(() => {
  testRunner.setBluetoothMockDataSet('GlucoseHeartRateAdapter');
  return requestDeviceWithKeyDown({
    filters: [{services: ['generic_access', 'heart_rate']}]
  }).then(device => assert_equals(device.name, 'Heart Rate Device'));
}, 'Filter with 2 services returns a matching device.');

sequential_promise_test(() => {
  testRunner.setBluetoothMockDataSet('GlucoseHeartRateAdapter');
  return requestDeviceWithKeyDown({
    filters: [{services: ['battery_service']},
              {services: ['heart_rate']}]
  }).then(device => assert_equals(device.name, 'Heart Rate Device'));
}, 'An extra filter doesn\'t prevent matching.');

sequential_promise_test(() => {
  testRunner.setBluetoothMockDataSet('GlucoseHeartRateAdapter');
  // Both devices support the Generic Access service, but things need to
  // support both services to pass the filter, and neither has a Battery
  // service.
  return assert_promise_rejects(requestDeviceWithKeyDown({
    filters: [{services: ['generic_access', 'battery_service']}]
  }), 'NotFoundError');
}, 'Too-strict filters do prevent matching.');
</script>
