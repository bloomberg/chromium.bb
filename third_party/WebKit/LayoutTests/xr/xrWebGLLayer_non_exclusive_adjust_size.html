<!DOCTYPE html>
<script src="../resources/testharness.js"></script>
<script src="../resources/testharnessreport.js"></script>
<script src="file:///gen/layout_test_data/mojo/public/js/mojo_bindings.js"></script>
<script src="file:///gen/device/vr/public/mojom/vr_service.mojom.js"></script>
<script src="../xr/resources/xr-device-mocking.js"></script>
<script src="../xr/resources/xr-test-utils.js"></script>
<script src="../xr/resources/test-constants.js"></script>
<canvas id="webgl-canvas"></canvas>

<script>
let fakeDevices = fakeXRDevices();
let outputContext = getOutputContext();
let outputCanvas = outputContext.canvas;

// Make an unreasonably large magic window canvas.
outputCanvas.width = 18000; // 16k ought to be a large enough max for anyone.
outputCanvas.height = 20000;

let outputCanvasRatio = outputCanvas.width / outputCanvas.height;

xr_session_promise_test( (session, t) => new Promise((resolve, reject) => {
  let webglLayer = new XRWebGLLayer(session, gl);
  session.baseLayer = webglLayer;

  t.step(() => {
    // The layer's framebuffer should be smaller than the requested size.
    assert_true(webglLayer.framebufferWidth < outputCanvas.width);
    assert_true(webglLayer.framebufferHeight < outputCanvas.height);

    // The layer's dimensions should keep the same ratio as the canvas.
    let framebufferRatio = webglLayer.framebufferWidth / webglLayer.framebufferHeight;
    assert_approx_equals(framebufferRatio, outputCanvasRatio, 0.0001);
  });

  // Resize the canvas to something more reasonable.
  outputCanvas.width = 256;
  outputCanvas.height = 128;

  // Give the UA a chance to respond to the resize.
  setTimeout(() => {
    // Check to ensure the framebuffer resized to match the new canvas dimensions.
    t.step(() => {
      assert_equals(webglLayer.framebufferWidth, outputCanvas.width);
      assert_equals(webglLayer.framebufferHeight, outputCanvas.height);
    });

    resolve();
  }, 100);
}), fakeDevices["FakeGooglePixelPhone"], [{ outputContext: outputContext }],
"Ensure a WebGL layer's framebuffer size is adjusted appropriately when a large canvas is requested");

</script>
