<!doctype html>
<meta charset=utf-8>
<title>RTCPeerConnection.prototype.getStats</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="RTCPeerConnection-helper.js"></script>
<script>
  'use strict';

  // The following helper functions are called from RTCPeerConnection-helper.js:
  //   getUserMediaTracksAndStreams

  async_test(t => {
    const pc = new RTCPeerConnection();
    let track;
    return getUserMediaTracksAndStreams(1)
    .then(t.step_func(([tracks, streams]) => {
      track = tracks[0];
      pc.addTrack(track);
      return pc.getStats();
    }))
    .then(t.step_func(report => {
      let trackStats = findStatsByTypeAndId(report, 'track', track.id);
      assert_true(trackStats != null, 'Has stats for track');
      t.done();
    }))
    .catch(t.step_func(reason => {
      assert_unreached(reason);
    }));
  }, 'addTrack() without setLocalDescription() yields track stats');

  async_test(t => {
    const pc = new RTCPeerConnection();
    let stream;
    return getUserMediaTracksAndStreams(1)
    .then(t.step_func(([tracks, streams]) => {
      let track = tracks[0];
      stream = streams[0];
      pc.addTrack(track, stream);
      return pc.getStats();
    }))
    .then(t.step_func(report => {
      let streamStats = findStatsByTypeAndId(report, 'stream', stream.id);
      assert_true(streamStats != null, 'Has stats for stream');
      t.done();
    }))
    .catch(t.step_func(reason => {
      assert_unreached(reason);
    }));
  }, 'addTrack() without setLocalDescription() yields media stream stats');

  async_test(t => {
    const pc = new RTCPeerConnection();
    let track;
    return getUserMediaTracksAndStreams(1)
    .then(t.step_func(([tracks, streams]) => {
      track = tracks[0];
      pc.addTrack(track);
      return pc.createOffer();
    }))
    .then(t.step_func(offer => {
      return pc.setLocalDescription(offer);
    }))
    .then(t.step_func(() => {
      return pc.getStats();
    }))
    .then(t.step_func(report => {
      let trackStats = findStatsByTypeAndId(report, 'track', track.id);
      assert_true(trackStats != null, 'Has stats for track');
      t.done();
    }))
    .catch(t.step_func(reason => {
      assert_unreached(reason);
    }));
  }, 'addTrack() with setLocalDescription() yields track stats');

  async_test(t => {
    const pc = new RTCPeerConnection();
    let stream;
    return getUserMediaTracksAndStreams(1)
    .then(t.step_func(([tracks, streams]) => {
      let track = tracks[0];
      stream = streams[0];
      pc.addTrack(track, stream);
      return pc.createOffer();
    }))
    .then(t.step_func(offer => {
      return pc.setLocalDescription(offer);
    }))
    .then(t.step_func(() => {
      return pc.getStats();
    }))
    .then(t.step_func(report => {
      let streamStats = findStatsByTypeAndId(report, 'stream', stream.id);
      assert_true(streamStats != null, 'Has stats for stream');
      t.done();
    }))
    .catch(t.step_func(reason => {
      assert_unreached(reason);
    }));
  }, 'addTrack() with setLocalDescription() yields media stream stats');

  async_test(t => {
    const pc = new RTCPeerConnection();
    let track;
    let stream;
    return getUserMediaTracksAndStreams(1)
    .then(t.step_func(([tracks, streams]) => {
      track = tracks[0];
      stream = streams[0];
      pc.addTrack(track, stream);
      return pc.createOffer();
    }))
    .then(t.step_func(offer => {
      return pc.setLocalDescription(offer);
    }))
    .then(t.step_func(() => {
      return pc.getStats();
    }))
    .then(t.step_func(report => {
      let trackStats = findStatsByTypeAndId(report, 'track', track.id);
      let streamStats = findStatsByTypeAndId(report, 'stream', stream.id);
      assert_true(trackStats != null && streamStats != null,
                  'Has stats for track and stream');
      assert_array_equals(streamStats.trackIds, [ trackStats.id ],
                          'streamStats.trackIds == [ trackStats.id ]');
      t.done();
    }))
    .catch(t.step_func(reason => {
      assert_unreached(reason);
    }));
  }, 'addTrack(): Media stream stats references track stats');

  // TODO(hbos): addStream() is legacy API not in the spec. Based on discussion
  // whether to standardize in legacy section, consider removing this test or
  // keeping it until addTrack() has wide support.
  // https://github.com/w3c/webrtc-pc/issues/1705
  // https://github.com/w3c/webrtc-pc/issues/1125
  async_test(t => {
    const pc = new RTCPeerConnection();
    let track;
    let stream;
    return getUserMediaTracksAndStreams(1)
    .then(t.step_func(([tracks, streams]) => {
      track = tracks[0];
      stream = streams[0];
      stream.addTrack(track);
      pc.addStream(stream);
      return pc.createOffer();
    }))
    .then(t.step_func(offer => {
      return pc.setLocalDescription(offer);
    }))
    .then(t.step_func(() => {
      return pc.getStats();
    }))
    .then(t.step_func(report => {
      let trackStats = findStatsByTypeAndId(report, 'track', track.id);
      let streamStats = findStatsByTypeAndId(report, 'stream', stream.id);
      assert_true(trackStats != null && streamStats != null,
                  'Has stats for track and stream');
      assert_array_equals(streamStats.trackIds, [ trackStats.id ],
                          'streamStats.trackIds == [ trackStats.id ]');
      t.done();
    }))
    .catch(t.step_func(reason => {
      assert_unreached(reason);
    }));
  }, 'Legacy addStream(): Media stream stats references track stats');

  async_test(t => {
    const caller = new RTCPeerConnection();
    const callee = new RTCPeerConnection();
    let sendingTrack;
    return getUserMediaTracksAndStreams(1)
    .then(t.step_func(([tracks, streams]) => {
      sendingTrack = tracks[0];
      caller.addTrack(sendingTrack);
      return caller.createOffer();
    }))
    .then(t.step_func(offer => {
      return Promise.all([ caller.setLocalDescription(offer),
                           callee.setRemoteDescription(offer) ]);
    }))
    .then(t.step_func(() => {
      return callee.createAnswer();
    }))
    .then(t.step_func(answer => {
      return Promise.all([ callee.setLocalDescription(answer),
                           caller.setRemoteDescription(answer) ]);
    }))
    .then(t.step_func(() => {
      return caller.getStats();
    }))
    .then(t.step_func(report => {
      let trackStats = findStatsByTypeAndId(report, 'track', sendingTrack.id);
      assert_true(trackStats != null, 'Has stats for sending track');
      let outboundStats = findStatsByTypeAndMember(report, 'outbound-rtp',
                                                   'trackId', trackStats.id);
      assert_true(outboundStats != null, 'Has stats for outbound RTP stream');
      t.done();
    }))
    .catch(t.step_func(reason => {
      assert_unreached(reason);
    }));
  }, 'O/A exchange yields outbound RTP stream stats for sending track');

  async_test(t => {
    const caller = new RTCPeerConnection();
    const callee = new RTCPeerConnection();
    let receivingTrack;
    callee.ontrack = trackEvent => {
      assert_true(receivingTrack == undefined, 'ontrack has not fired before');
      receivingTrack = trackEvent.track;
    };
    return getUserMediaTracksAndStreams(1)
    .then(t.step_func(([tracks, streams]) => {
      caller.addTrack(tracks[0]);
      return caller.createOffer();
    }))
    .then(t.step_func(offer => {
      return Promise.all([ caller.setLocalDescription(offer),
                           callee.setRemoteDescription(offer) ]);
    }))
    .then(t.step_func(() => {
      return callee.createAnswer();
    }))
    .then(t.step_func(answer => {
      return Promise.all([ callee.setLocalDescription(answer),
                           caller.setRemoteDescription(answer) ]);
    }))
    .then(t.step_func(() => {
      return callee.getStats();
    }))
    .then(t.step_func(report => {
      assert_true(receivingTrack != null, 'Has a receiving track');
      let trackStats = findStatsByTypeAndId(report, 'track', receivingTrack.id);
      assert_true(trackStats != null, 'Has stats for receiving track');
      let inboundStats = findStatsByTypeAndMember(report, 'inbound-rtp',
                                                  'trackId', trackStats.id);
      assert_true(inboundStats != null, 'Has stats for outbound RTP stream');
      t.done();
    }))
    .catch(t.step_func(reason => {
      assert_unreached(reason);
    }));
  }, 'O/A exchange yields inbound RTP stream stats for receiving track');

  // Helpers.

  function findStatsByTypeAndId(report, type, identifier) {
    return findStats(report, stats => {
      return stats.type == type && stats[type + 'Identifier'] == identifier;
    });
  }

  function findStatsByTypeAndMember(report, type, member, value) {
    return findStats(report, stats => {
      return stats.type == type && stats[member] == value;
    });
  }

  function findStats(report, findFunc) {
    for (let it = report.values(), n = it.next(); !n.done; n = it.next()) {
      if (findFunc(n.value))
        return n.value;
    }
    return null;
  }

</script>
