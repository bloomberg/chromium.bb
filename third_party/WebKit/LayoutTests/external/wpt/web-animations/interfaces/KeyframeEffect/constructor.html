<!DOCTYPE html>
<meta charset=utf-8>
<title>KeyframeEffect and KeyframeEffectReadOnly constructor</title>
<link rel="help"
      href="https://w3c.github.io/web-animations/#dom-keyframeeffect-keyframeeffect">
<link rel="help"
      href="https://w3c.github.io/web-animations/#dom-keyframeeffectreadonly-keyframeeffectreadonly">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../../testcommon.js"></script>
<script src="../../resources/easing-tests.js"></script>
<script src="../../resources/keyframe-utils.js"></script>
<script src="../../resources/keyframe-tests.js"></script>
<body>
<div id="log"></div>
<div id="target"></div>
<script>
'use strict';

const target = document.getElementById('target');

test(function(t) {
  gEmptyKeyframeListTests.forEach(function(frames) {
    assert_equals(new KeyframeEffectReadOnly(target, frames)
                        .getKeyframes().length,
                  0, 'number of frames for ' + JSON.stringify(frames));
  });
}, 'A KeyframeEffectReadOnly can be constructed with no frames');

test(function(t) {
  gEasingParsingTests.forEach(function(subtest) {
    const easing = subtest[0];
    const expected = subtest[1];
    const effect = new KeyframeEffectReadOnly(target, {
      left: ['10px', '20px']
    }, { easing: easing });
    assert_equals(effect.timing.easing, expected,
                  `resulting easing for '${easing}'`);
  });
}, 'easing values are parsed correctly when passed to the ' +
   'KeyframeEffectReadOnly constructor in KeyframeEffectOptions');

test(function(t) {
  gInvalidEasings.forEach(invalidEasing => {
    assert_throws(new TypeError, () => {
      new KeyframeEffectReadOnly(target, null, { easing: invalidEasing });
    }, `TypeError is thrown for easing '${invalidEasing}'`);
  });
}, 'Invalid easing values are correctly rejected when passed to the ' +
   'KeyframeEffectReadOnly constructor in KeyframeEffectOptions');

test(function(t) {
  const getKeyframe = function(composite) {
    return { left: [ '10px', '20px' ], composite: composite };
  };
  gGoodKeyframeCompositeValueTests.forEach(function(composite) {
    const effect = new KeyframeEffectReadOnly(target, getKeyframe(composite));
    assert_equals(effect.getKeyframes()[0].composite, composite,
                  `resulting composite for '${composite}'`);
  });
  gBadCompositeValueTests.forEach(function(composite) {
    assert_throws(new TypeError, function() {
      new KeyframeEffectReadOnly(target, getKeyframe(composite));
    });
  });
}, 'composite values are parsed correctly when passed to the ' +
   'KeyframeEffectReadOnly constructor in property-indexed keyframes');

test(function(t) {
  const getKeyframes = function(composite) {
    return [
      { offset: 0, left: '10px', composite: composite },
      { offset: 1, left: '20px' }
    ];
  };
  gGoodKeyframeCompositeValueTests.forEach(function(composite) {
    const effect = new KeyframeEffectReadOnly(target, getKeyframes(composite));
    assert_equals(effect.getKeyframes()[0].composite, composite,
                  `resulting composite for '${composite}'`);
  });
  gBadCompositeValueTests.forEach(function(composite) {
    assert_throws(new TypeError, function() {
      new KeyframeEffectReadOnly(target, getKeyframes(composite));
    });
  });
}, 'composite values are parsed correctly when passed to the ' +
   'KeyframeEffectReadOnly constructor in regular keyframes');

test(function(t) {
  gGoodOptionsCompositeValueTests.forEach(function(composite) {
    const effect = new KeyframeEffectReadOnly(target, {
      left: ['10px', '20px']
    }, { composite: composite });
    assert_equals(effect.getKeyframes()[0].composite, undefined,
                  `resulting composite for '${composite}'`);
  });
  gBadCompositeValueTests.forEach(function(composite) {
    assert_throws(new TypeError, function() {
      new KeyframeEffectReadOnly(target, {
        left: ['10px', '20px']
      }, { composite: composite });
    });
  });
}, 'composite value is absent if the composite operation specified on the ' +
   'keyframe effect is being used');

gKeyframesTests.forEach(function(subtest) {
  test(function(t) {
    const effect = new KeyframeEffectReadOnly(target, subtest.input);
    assert_frame_lists_equal(effect.getKeyframes(), subtest.output);
  }, `A KeyframeEffectReadOnly can be constructed with ${subtest.desc}`);

  test(function(t) {
    const effect = new KeyframeEffectReadOnly(target, subtest.input);
    const secondEffect =
      new KeyframeEffectReadOnly(target, effect.getKeyframes());
    assert_frame_lists_equal(secondEffect.getKeyframes(),
                             effect.getKeyframes());
  }, `A KeyframeEffectReadOnly constructed with ${subtest.desc} roundtrips`);
});

gInvalidKeyframesTests.forEach(function(subtest) {
  test(function(t) {
    assert_throws(new TypeError, function() {
      new KeyframeEffectReadOnly(target, subtest.input);
    });
  }, `KeyframeEffectReadOnly constructor throws with ${subtest.desc}`);
});

test(function(t) {
  const effect = new KeyframeEffectReadOnly(target,
                                            { left: ['10px', '20px'] });

  const timing = effect.timing;
  assert_equals(timing.delay, 0, 'default delay');
  assert_equals(timing.endDelay, 0, 'default endDelay');
  assert_equals(timing.fill, 'auto', 'default fill');
  assert_equals(timing.iterations, 1.0, 'default iterations');
  assert_equals(timing.iterationStart, 0.0, 'default iterationStart');
  assert_equals(timing.duration, 'auto', 'default duration');
  assert_equals(timing.direction, 'normal', 'default direction');
  assert_equals(timing.easing, 'linear', 'default easing');

  assert_equals(effect.composite, 'replace', 'default composite');
  assert_equals(effect.iterationComposite, 'replace',
                'default iterationComposite');
}, 'A KeyframeEffectReadOnly constructed without any ' +
   'KeyframeEffectOptions object');

gKeyframeEffectOptionTests.forEach(function(subtest) {
  test(function(t) {
    const effect = new KeyframeEffectReadOnly(target,
                                              { left: ['10px', '20px'] },
                                              subtest.input);

    // Helper function to provide default expected values when the test does
    // not supply them.
    const expected = (field, defaultValue) => {
      return field in subtest.expected ? subtest.expected[field] : defaultValue;
    };

    const timing = effect.timing;
    assert_equals(timing.delay, expected('delay', 0),
                  'timing delay');
    assert_equals(timing.fill, expected('fill', 'auto'),
                  'timing fill');
    assert_equals(timing.iterations, expected('iterations', 1),
                  'timing iterations');
    assert_equals(timing.duration, expected('duration', 'auto'),
                  'timing duration');
    assert_equals(timing.direction, expected('direction', 'normal'),
                  'timing direction');

  }, `A KeyframeEffectReadOnly constructed by ${subtest.desc}`);
});

gInvalidKeyframeEffectOptionTests.forEach(function(subtest) {
  test(function(t) {
    assert_throws(new TypeError, function() {
      new KeyframeEffectReadOnly(target,
                                 { left: ['10px', '20px'] },
                                 subtest.input);
    });
  }, `Invalid KeyframeEffectReadOnly option by ${subtest.desc}`);
});

test(function(t) {
  const effect = new KeyframeEffectReadOnly(null,
                                            { left: ['10px', '20px'] },
                                            { duration: 100 * MS_PER_SEC,
                                              fill: 'forwards' });
  assert_equals(effect.target, null,
                'Effect created with null target has correct target');
}, 'A KeyframeEffectReadOnly constructed with null target');

test(function(t) {
  const test_error = { name: 'test' };

  assert_throws(test_error, function() {
    new KeyframeEffect(target, { get left() { throw test_error }})
  });
}, 'KeyframeEffect constructor propagates exceptions generated by accessing'
   + ' the options object');
</script>
</body>
