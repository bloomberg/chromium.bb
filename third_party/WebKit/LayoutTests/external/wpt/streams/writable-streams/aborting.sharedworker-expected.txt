This is a testharness.js-based test.
Harness Error. harness_status.status = 1 , harness_status.message = error1
Found 54 tests; 26 PASS, 28 FAIL, 0 TIMEOUT, 0 NOTRUN.
FAIL Aborting a WritableStream before it starts should cause the writer's unsettled ready promise to reject assert_throws: the ready promise should reject with error1 function "function() { throw e }" threw object "TypeError: The stream is in the process of being aborted" ("TypeError") expected object "error1: error1" ("error1")
FAIL Aborting a WritableStream should cause the writer's fulfilled ready promise to reset to a rejected one assert_throws: the ready promise should reject with error1 function "function() { throw e }" threw object "TypeError: The stream is in the process of being aborted" ("TypeError") expected object "error1: error1" ("error1")
PASS abort() on a released writer rejects
FAIL Aborting a WritableStream immediately prevents future writes assert_throws: write(1) must reject with error1 function "function() { throw e }" threw object "TypeError: The stream is in the process of being aborted" ("TypeError") expected object "error1: error1" ("error1")
FAIL Aborting a WritableStream prevents further writes after any that are in progress assert_throws: write(2) must reject with error1 function "function() { throw e }" threw object "TypeError: The stream is in the process of being aborted" ("TypeError") expected object "error1: error1" ("error1")
PASS Fulfillment value of ws.abort() call must be undefined even if the underlying sink returns a non-undefined value
PASS WritableStream if sink's abort throws, the promise returned by writer.abort() rejects
FAIL WritableStream if sink's abort throws, the promise returned by multiple writer.abort()s is the same and rejects assert_equals: the promises must be the same expected object "[object Promise]" but got object "[object Promise]"
PASS WritableStream if sink's abort throws, the promise returned by ws.abort() rejects
PASS WritableStream if sink's abort throws, for an abort performed during a write, the promise returned by ws.abort() rejects
PASS Aborting a WritableStream passes through the given reason
FAIL Aborting a WritableStream puts it in an errored state with the error passed to abort() assert_throws: writing should reject with error1 function "function() { throw e }" threw object "TypeError: The stream is in the process of being aborted" ("TypeError") expected object "error1: error1" ("error1")
FAIL Aborting a WritableStream causes any outstanding write() promises to be rejected with the reason supplied assert_throws: writing should reject with error1 function "function() { throw e }" threw object "TypeError: The stream is in the process of being aborted" ("TypeError") expected object "error1: error1" ("error1")
FAIL Closing but then immediately aborting a WritableStream causes the stream to error assert_throws: close() should reject with error1 function "function() { throw e }" threw object "TypeError: The stream is in the process of being aborted" ("TypeError") expected object "error1: error1" ("error1")
PASS Closing a WritableStream and aborting it while it closes causes the stream to ignore the abort attempt
PASS Aborting a WritableStream after it is closed is a no-op
FAIL WritableStream should NOT call underlying sink's close if no abort is supplied (historical) assert_throws: closed should reject with error1 function "function() { throw e }" threw object "TypeError: The stream is in the process of being aborted" ("TypeError") expected object "error1: error1" ("error1")
PASS returning a thenable from abort() should work
FAIL .closed should not resolve before fulfilled write() assert_throws: .closed should reject function "function() { throw e }" threw object "TypeError: The stream is in the process of being aborted" ("TypeError") expected object "error1: error1" ("error1")
FAIL .closed should not resolve before rejected write(); write() error should not overwrite abort() error assert_throws: .closed should reject function "function() { throw e }" threw object "TypeError: The stream is in the process of being aborted" ("TypeError") expected object "error2: error2" ("error2")
FAIL writes should be satisfied in order when aborting assert_throws: first queued write should be rejected function "function() { throw e }" threw object "TypeError: The stream is in the process of being aborted" ("TypeError") expected object "error1: error1" ("error1")
FAIL writes should be satisfied in order after rejected write when aborting assert_throws: first queued write should be rejected function "function() { throw e }" threw object "TypeError: The stream is in the process of being aborted" ("TypeError") expected object "error2: error2" ("error2")
FAIL close() should reject with abort reason why abort() is first error assert_throws: writer.close() should reject with error from underlying write() function "function() { throw e }" threw object "TypeError: The stream is in the process of being aborted" ("TypeError") expected object "error2: error2" ("error2")
PASS underlying abort() should not be called until underlying write() completes
PASS underlying abort() should not be called if underlying close() has started
PASS if underlying close() has started and then rejects, the abort() and close() promises should reject with the underlying close rejection reason
FAIL an abort() that happens during a write() should trigger the underlying abort() even with a close() queued assert_throws: promise returned by close() should be rejected function "function() { throw e }" threw object "TypeError: The stream is in the process of being aborted" ("TypeError") expected object "error1: error1" ("error1")
FAIL if a writer is created for a stream with a pending abort, its ready should be rejected with the abort error assert_throws: ready of the second writer should be rejected with error1 function "function() { throw e }" threw object "TypeError: The stream is in the process of being aborted" ("TypeError") expected object "error1: error1" ("error1")
PASS writer close() promise should resolve before abort() promise
PASS writer.ready should reject on controller error without waiting for underlying write
FAIL writer.abort() while there is an in-flight write, and then finish the write with rejection assert_throws: writePromise2 must reject with the error from abort function "function() { throw e }" threw object "TypeError: The stream is in the process of being aborted" ("TypeError") expected object "error1: error1" ("error1")
FAIL writer.abort(), controller.error() while there is an in-flight write, and then finish the write assert_throws: writePromise2 must reject with the error from abort function "function() { throw e }" threw object "TypeError: The stream is in the process of being aborted" ("TypeError") expected object "error1: error1" ("error1")
FAIL writer.abort(), controller.error() while there is an in-flight close, and then finish the close assert_throws: writer.ready must reject with the error from abort function "function() { throw e }" threw object "TypeError: The stream is in the process of being aborted" ("TypeError") expected object "error1: error1" ("error1")
PASS controller.error(), writer.abort() while there is an in-flight write, and then finish the write
PASS controller.error(), writer.abort() while there is an in-flight close, and then finish the close
PASS releaseLock() while aborting should reject the original closed promise
PASS releaseLock() during delayed async abort() should reject the writer.closed promise
PASS sink abort() should not be called until sink start() is done
PASS if start attempts to error the controller after abort() has been called, then it should lose
PASS stream abort() promise should still resolve if sink start() rejects
FAIL writer abort() during sink start() should replace the writer.ready promise synchronously assert_throws: writerReady2 should reject function "function() { throw e }" threw object "TypeError: The stream is in the process of being aborted" ("TypeError") expected object "error1: error1" ("error1")
FAIL promises returned from other writer methods should be rejected when writer abort() happens during sink start() assert_throws: second write() should reject function "function() { throw e }" threw object "TypeError: The stream is in the process of being aborted" ("TypeError") expected object "error1: error1" ("error1")
PASS abort() should succeed despite rejection from write
PASS abort() should be rejected with the rejection returned from close()
FAIL a rejecting sink.write() should not prevent sink.abort() from being called assert_throws: closed should reject with error2 function "function() { throw e }" threw object "TypeError: The stream is in the process of being aborted" ("TypeError") expected object "error2: error2" ("error2")
PASS when start errors after stream abort(), underlying sink abort() should be called anyway
FAIL when calling abort() twice on the same stream, both should give the same promise that fulfills with undefined assert_equals: the promises must be the same expected object "[object Promise]" but got object "[object Promise]"
FAIL when calling abort() twice on the same stream, but sequentially so so there's no pending abort the second time, both should fulfill with undefined promise_test: Unhandled rejection with value: object "TypeError: The stream is in the process of being aborted"
FAIL calling abort() on an errored stream should fulfill with undefined promise_test: Unhandled rejection with value: object "error1: error1"
PASS sink abort() should not be called if stream was erroring due to controller.error() before abort() was called
PASS sink abort() should not be called if stream was erroring due to bad strategy before abort() was called
FAIL abort with no arguments should set the stored error to undefined assert_equals: e should be undefined expected (undefined) undefined but got (object) object "TypeError: The stream is in the process of being aborted"
FAIL abort with an undefined argument should set the stored error to undefined assert_equals: e should be undefined expected (undefined) undefined but got (object) object "TypeError: The stream is in the process of being aborted"
FAIL abort with a string argument should set the stored error to that argument assert_equals: e should be 'string argument' expected (string) "string argument" but got (object) object "TypeError: The stream is in the process of being aborted"
Harness: the test ran to completion.

