This is a testharness.js-based test.
PASS fulfillment value of ws.close() call must be undefined even if the underlying sink returns a non-undefined value
PASS when sink calls error asynchronously while sink close is in-flight, the stream should not become errored
PASS when sink calls error synchronously while closing, the stream should not become errored
PASS when the sink throws during close, and the close is requested while a write is still in-flight, the stream should become errored during the close
PASS releaseLock on a stream with a pending write in which the stream has been errored
PASS releaseLock on a stream with a pending close in which controller.error() was called
PASS when close is called on a WritableStream in writable state, ready should return a fulfilled promise
PASS when close is called on a WritableStream in waiting state, ready promise should be fulfilled
PASS when close is called on a WritableStream in waiting state, ready should be fulfilled immediately even if close takes a long time
PASS returning a thenable from close() should work
PASS releaseLock() should not change the result of sync close()
PASS releaseLock() should not change the result of async close()
PASS close() should set state to CLOSED even if writer has detached
PASS the promise returned by async abort during close should resolve
PASS promises must fulfill/reject in the expected order on closure
PASS promises must fulfill/reject in the expected order on aborted closure
FAIL promises must fulfill/reject in the expected order on aborted and errored closure assert_throws: writer.closed must reject with error2 function "function() { throw e }" threw object "TypeError: The stream is in the process of being aborted" ("TypeError") expected object "error2: error2" ("error2")
PASS close() should not reject until no sink methods are in flight
Harness: the test ran to completion.

