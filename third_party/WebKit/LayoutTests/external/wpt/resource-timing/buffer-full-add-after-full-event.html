<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<link rel="help" href="https://w3c.github.io/resource-timing/#dom-performance-setresourcetimingbuffersize">
<title>This test validates that setResourceTimingBufferFull behaves appropriately when set to the current buffer level.</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
</head>
<body>
<script>
let eventFired = false;
function loadRandomResource() {
    return fetch(window.location.href + "?" + Math.random());
}

setup(function() {
    // Get the browser into a consistent state.
    performance.clearResourceTimings();
    performance.setResourceTimingBufferSize(3);
});

let gatherEntries = new Promise(function(resolve, reject) {
    // Gather up 3 Resource Entries to kick off the rest of test behavior.
    let resources = 0;
    let observer = new PerformanceObserver(function(list) {
        resources += list.getEntriesByType("resource").length;
        if (resources !== 3)
            return;
        observer.disconnect();
        resolve();
    });
    observer.observe({entryTypes: ["resource"]});
    for (let i = 0; i < 3; ++i)
        loadRandomResource();
});

let setBufferSize = new Promise(function(resolve, reject) {
    performance.onresourcetimingbufferfull = function() {
        eventFired = true;
        performance.clearResourceTimings();
    };
    resolve();
});

promise_test(function() {
    return gatherEntries;
}, "Reset the entries number");
promise_test(function() {
    return setBufferSize;
}, "Set the buffer size");
promise_test(function() {
    return new Promise(function(resolve, reject) {
        loadRandomResource().then(resolve);
    });
}, "Overflow the buffer");
/*
promise_test(function() {
    return new Promise(function(resolve, reject) {
        let waitForIt = function() {
            if (eventFired) {
                eventFired = false;
                resolve();
            }
        }
        step_timeout(waitForIt, 0);
    });
}, "Wait for event");
*/
promise_test(function() {
    return new Promise(function(resolve, reject) {
        performance.clearResourceTimings();
        loadRandomResource().then(function() {
            resolve();
    })});
}, "Clear and add another entry to the buffer");
promise_test(function() {
    return new Promise(function(resolve, reject) {
        let waitForIt = function() {
            if (performance.getEntriesByType("resource").length) {
                resolve();
            } else {
                reject("After buffer full, entry never added to primary");
            }
        }
        step_timeout(waitForIt, 0);
    });
}, "Wait for entry to be added");
</script>
