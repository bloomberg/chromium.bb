<!DOCTYPE html>
<!-- This test is prefixed with `chromium.` because the equivalent version
  available in Web Platform Tests is known to cause timeout errors in the
  Chromium automated build system. It should be maintained only to preserve
  test converage until the corresponding versions in Web Platform Tests can be
  made to pass consistently. See https://crbug.com/658997 -->
<title>Service Worker: getRegistrations()</title>
<script src="../resources/testharness.js"></script>
<script src="../resources/testharnessreport.js"></script>
<script src="resources/test-helpers.js"></script>
<script src="../resources/get-host-info.js"></script>
<script>
// Purge the existing registrations for the origin.
// getRegistrations() is used in order to avoid adding additional complexity
// e.g. adding an internal function.
promise_test(function(t) {
    var resolve;
    var timer;
    var p = new Promise(function(r) { resolve = r; });
    navigator.serviceWorker.getRegistrations()
      .then(function(regs) {
          return Promise.all(regs.map(function(r) { r.unregister(); }));
        })
      .then(function() {
          // As registration.unregister() promises resolve before the
          // corresponding registrations are deleted from the storage, we must
          // wait until the registrations are actually removed from the storage.
          // Spec reference: https://slightlyoff.github.io/ServiceWorker/spec/service_worker/#unregister-algorithm
          timer = setInterval(function() {
              navigator.serviceWorker.getRegistrations()
                .then(function(regs) {
                    if (regs.length == 0) {
                      clearInterval(timer);
                      resolve();
                    }
                  });
            }, 100);
        });
    return p;
  }, 'Purge the existing registrations.');

promise_test(function(t) {
    var scope = 'resources/scope/getregistrations/normal';
    var script = 'resources/empty-worker.js';
    var registrations = [];
    return service_worker_unregister_and_register(t, script, scope)
      .then(function(r) {
          registrations.push(r);
          return navigator.serviceWorker.getRegistrations();
        })
      .then(function(value) {
          assert_array_equals(
            value,
            registrations,
            'getRegistrations should resolve with array of registrations.');
          return service_worker_unregister(t, scope);
        });
  }, 'Register then getRegistrations');

promise_test(function(t) {
    var scope1 = 'resources/scope/getregistrations/scope1';
    var scope2 = 'resources/scope/getregistrations/scope2';
    var script = 'resources/empty-worker.js';
    var registrations = [];
    return service_worker_unregister_and_register(t, script, scope1)
      .then(function(r) {
          registrations.push(r);
          return service_worker_unregister_and_register(t, script, scope2);
        })
      .then(function(r) {
          registrations.push(r);
          return navigator.serviceWorker.getRegistrations();
        })
      .then(function(value) {
          assert_array_equals(
            value,
            registrations,
            'getRegistrations should resolve with array of registrations.');
          return service_worker_unregister(t, scope1);
        })
      .then(function() {
          return service_worker_unregister(t, scope2);
        });
  }, 'Register multiple times then getRegistrations');

promise_test(function(t) {
    var scope = 'resources/scope/getregistrations/register-unregister';
    var script = 'resources/empty-worker.js';
    return service_worker_unregister_and_register(t, script, scope)
      .then(function(registration) {
          return registration.unregister();
        })
      .then(function() {
          return navigator.serviceWorker.getRegistrations();
        })
      .then(function(value) {
          assert_array_equals(
            value,
            [],
            'getRegistrations should resolve with an empty array.');
        });
  }, 'Register then Unregister then getRegistrations');

promise_test(function(t) {
    // Top-level window's origin: http://127.0.0.1:8000.
    // Frame's origin: http://localhost:8000.
    var host_info = get_host_info();
    var frame_url = host_info['HTTP_REMOTE_ORIGIN'] +
                    '/serviceworker/resources/frame-for-getregistrations.html';
    var scope = 'resources/scope-for-getregistrations';
    var script = 'resources/empty-worker.js';
    var frame;
    var registrations = [];

    return with_iframe(frame_url)
      .then(function(f) {
          frame = f;

          var resolve;
          var p = new Promise(function(r) { resolve = r; });

          var channel = new MessageChannel();

          channel.port1.onmessage = function(e) {
            // Frame's registration is registered.
            if (e.data == 'registered') {
              // Top-level window registers a registration scoped
              // http://127.0.0.1:8000/serviceworker/resources/scope-for-getregistrations.
              service_worker_unregister_and_register(t, script, scope)
                .then(function(r) {
                    registrations.push(r);
                    return navigator.serviceWorker.getRegistrations();
                  })
                .then(function(value) {
                    assert_array_equals(value, registrations,
                      'getRegistrations should return only the same origin ' +
                      'registrations.');
                    channel.port1.postMessage('unregister');
                  });
            } else if (e.data == 'unregistered') {
              resolve();
            }
          };
          frame.contentWindow.postMessage('register', '*', [channel.port2]);
          return p;
        })
      .then(function() {
          frame.remove();
          return service_worker_unregister(t, scope);
        });
  }, 'getRegistrations promise resolves only with same origin registrations.');

done();
</script>
