<!DOCTYPE html>
<title>Credential Manager: create() basics.</title>
<script src="../resources/testharness.js"></script>
<script src="../resources/testharnessreport.js"></script>
<script src="/serviceworker/resources/interfaces.js"></script>
<script>
var publicKey = {
  challenge: new TextEncoder().encode("climb a mountain"),
  rp: {
    id: "1098237235409872",
    name: "Acme"
  },

  user: {
    id: "1098237235409872",
    name: "john.p.smith@example.com",
    displayName: "John P. Smith",
    icon: "https://pics.acme.com/00/p/aBjjjpqPb.png"
  },

  parameters: [
    {
    type: "public-key",
      algorithm: "ES256",
    }
  ],

  excludeList: [],
  extensions: {"webauthn.location": true}
};

add_completion_callback(() => {
  if (window.testRunner)
    window.testRunner.clearMockAuthenticatorResponse();
});

// Constructs a gin-compatible ArrayBuffer.
// TextEncoder.encode() alone produces a TypedArray whoe buffer is the 
// underlying internal buffer for the Blink-side String passed in, and 
// crashes with "Cannot mix blink and gin ArrayBuffers".
function GinCompatibleArrayBuffer(string) {
  return new Uint8Array(new TextEncoder("utf-8").encode(string));
}

promise_test(function(t) {
    var credential_data = {
        id: 'id',
        password: 'pencil',
    };

    return navigator.credentials.create({password: credential_data})
        .then(function(credential) {
            assert_equals(credential.idName, 'username');
            assert_equals(credential.passwordName, 'password');
            assert_equals(credential.additionalData, null);
        });
}, "navigator.credentials.create() with valid PasswordCredentialData");

promise_test(function(t) {
    var f = document.createElement('form');
    f.innerHTML = "<input type='text' name='theId' value='musterman' autocomplete='username'>"
        + "<input type='text' name='thePassword' value='sekrit' autocomplete='current-password'>"
        + "<input type='text' name='theIcon' value='https://example.com/photo' autocomplete='photo'>"
        + "<input type='text' name='theExtraField' value='extra'>"
        + "<input type='text' name='theName' value='friendly name' autocomplete='name'>";

    return navigator.credentials.create({password: f})
        .then(function(credential) {
            assert_equals(credential.idName, 'theId');
            assert_equals(credential.passwordName, 'thePassword');

            assert_equals(credential.additionalData.get('theId'), 'musterman');
            assert_equals(credential.additionalData.get('thePassword'), 'sekrit');
            assert_equals(credential.additionalData.get('theIcon'),
                    'https://example.com/photo');
            assert_equals(credential.additionalData.get('theName'), 'friendly name');
            assert_equals(credential.additionalData.get('theExtraField'), 'extra');
        });
}, "navigator.credentials.create() with valid HTMLFormElement");

promise_test(() => {
  var rawId = GinCompatibleArrayBuffer("rawId");
  var id = btoa("rawId");
  var clientDataJSON = GinCompatibleArrayBuffer("clientDataJSON");
  var attestationObject = GinCompatibleArrayBuffer("attestationObject");

  if (window.testRunner) {
    testRunner.setMockAuthenticatorError("");
    testRunner.setMockAuthenticatorResponse(id, rawId, clientDataJSON,
        attestationObject, new Uint8Array(0), new Uint8Array(0));
  }
  return navigator.credentials.create({publicKey}).then(r => {
    assert_equals(r.id, id, "id");
    assert_true(r.rawId instanceof ArrayBuffer);
    assert_array_equals(new Uint8Array(r.rawId),
        rawId, "rawId returned is the same");

    assert_true(r.response instanceof AuthenticatorAttestationResponse);
    assert_true(r.response.clientDataJSON instanceof ArrayBuffer);
    assert_array_equals(new Uint8Array(r.response.clientDataJSON),
        clientDataJSON, "clientDataJSON returned is the same");

    assert_true(r.response.attestationObject instanceof ArrayBuffer);
    assert_array_equals(new Uint8Array(r.response.attestationObject),
        attestationObject, "attestationObject returned is the same");

    assert_not_exists(r.response, 'attestationData');
    assert_not_exists(r.response, 'signature');
  });
}, "Verify that the mock returns the values we give it.");

promise_test(function (t) {
  if (window.testRunner)
    return promise_rejects(t, "NotSupportedError",
        navigator.credentials.create());
}, "navigator.credentials.create() with no argument.");

promise_test(function (t) {
  if (window.testRunner)
    testRunner.setMockAuthenticatorError("cancelled");

  return promise_rejects(t, "NotAllowedError",
      navigator.credentials.create({ publicKey }));
}, "Verify that cancelled error returned by mock is properly handled.");

promise_test(function (t) {
  if (window.testRunner)
    testRunner.setMockAuthenticatorError("unknown");

  return promise_rejects(t, "NotReadableError",
      navigator.credentials.create({ publicKey }));
}, "Verify that unknown error returned by mock is properly handled.");

promise_test(function (t) {
  if (window.testRunner)
    testRunner.setMockAuthenticatorError("not allowed");

  return promise_rejects(t, "NotAllowedError",
      navigator.credentials.create({ publicKey }));
}, "Verify that not allowed error returned by mock is properly handled.");

promise_test(function (t) {
  if (window.testRunner)
    testRunner.setMockAuthenticatorError("not supported");

  return promise_rejects(t, "NotSupportedError",
      navigator.credentials.create({ publicKey }));
}, "Verify that not supported error returned by mock is properly handled.");

promise_test(function (t) {
  if (window.testRunner)
    testRunner.setMockAuthenticatorError("security");

  return promise_rejects(t, "SecurityError",
      navigator.credentials.create({ publicKey }));
}, "Verify that security error returned by mock is properly handled.");

promise_test(function (t) {
  if (window.testRunner)
    testRunner.setMockAuthenticatorError("not implemented");

  return promise_rejects(t, "NotAllowedError",
      navigator.credentials.create({ publicKey }));
}, "Verify that not implemented error returned by mock is properly handled.");
</script>

