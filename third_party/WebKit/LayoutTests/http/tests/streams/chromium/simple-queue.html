<!DOCTYPE html>
<meta charset="utf-8">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script>
// ReadableStream and WritableStream use a Javascript queue implementation
// called SimpleQueue. It uses nodes of 16K elements. These tests exercise the
// code paths which create and switch nodes. They are not in the
// web-platform-tests because they are only relevant to Chromium.

// Chosen to be (quite a lot) larger than 16K.
const NUMBER_OF_WRITES = 40000;

// Verify that wraparound works correctly in SimpleQueue by creating a queue
// with more than 16K elements. This tests push(), shift() and peek().
promise_test(t => {
  let expectedNextValue = 0;
  const ws = new WritableStream({
    write: t.step_func(chunk => {
      assert_equals(expectedNextValue, chunk,
                    'chunk should have the expected value');
      ++expectedNextValue;
    })
  });
  const writer = ws.getWriter();
  let lastPromise;
  // Because this loop is synchronous, the elements all have to be queued before
  // they can be processed.
  for (let i = 0; i < NUMBER_OF_WRITES; ++i) {
    lastPromise = writer.write(i);
  }
  assert_equals(1 - NUMBER_OF_WRITES, writer.desiredSize,
                'underlying sink write() should not have been called yet');
  return lastPromise;
}, 'queueing more than 16K chunks should work');

// Verify that forEach() works. It is used by WritableStream when it needs to
// reject all outstanding promises to error the stream.
promise_test(t => {
  const ws = new WritableStream();
  const writer = ws.getWriter();
  const rejections = [];
  for (let i = 0; i < NUMBER_OF_WRITES; ++i) {
    rejections.push(
        promise_rejects(t, new TypeError(), writer.write(i),
                        'write() promise should reject'));
  }
  return writer.abort().then(() => Promise.all(rejections));
}, 'rejecting more than 16K writes should work');
</script>
