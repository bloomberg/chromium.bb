<!--
Copyright (C) 2012 Samsung Electronics. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

1.  Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
2.  Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html>
<head>
<script>

DevToolsAPI = {};

InspectorTest = {};
InspectorTest._dispatchTable = [];
InspectorTest._requestId = -1;
InspectorTest._dumpInspectorProtocolMessages = false;
InspectorTest._embedderRequestId = -1;
InspectorTest.eventHandler = {};

InspectorTest.startDumpingProtocolMessages = function()
{
    InspectorTest._dumpInspectorProtocolMessages = true;
}

/**
 * @param {string} method
 * @param {object} params
 * @param {function({object} messageObject)=} handler
 */
InspectorTest.sendCommand = function(method, params, handler)
{
    this._dispatchTable[++this._requestId] = handler;

    var messageObject = { "method": method,
                          "params": params,
                          "id": this._requestId };

    if (InspectorTest._dumpInspectorProtocolMessages)
        testRunner.logToStderr("frontend: " + JSON.stringify(messageObject));
    var embedderMessage = { "id": ++this._embedderRequestId, "method": "dispatchProtocolMessage", "params": [JSON.stringify(messageObject)] };
    DevToolsHost.sendMessageToEmbedder(JSON.stringify(embedderMessage));
    return this._requestId;
}

InspectorTest.sendCommandOrDie = function(command, properties, callback)
{
    var fulfill;
    var result = new Promise(f => fulfill = f);

    InspectorTest.sendCommand(command, properties || {}, commandCallback);
    function commandCallback(msg)
    {
        if (msg.error) {
            InspectorTest.log("ERROR: " + msg.error.message);
            InspectorTest.completeTest();
            return;
        }
        if (callback)
            callback(msg.result);
        fulfill(msg.result);
    }
    return result;
}

InspectorTest.sendCommandPromise = function(method, params)
{
    var callback;
    var promise = new Promise(fulfill => callback = fulfill);
    InspectorTest.sendCommand(method, params, callback);
    return promise;
}

InspectorTest.waitForEventPromise = function(eventName)
{
    return new Promise(fulfill => InspectorTest.eventHandler[eventName] = fullfillAndClearListener.bind(null, fulfill));

    function fullfillAndClearListener(fulfill, result)
    {
        fulfill(result);
        delete InspectorTest.eventHandler[eventName];
    }
}

InspectorTest.domUndo = function(callback)
{
    InspectorTest.sendCommandOrDie("DOM.undo", {}, callback);
}

InspectorTest.undoAndNext = function(next)
{
    return InspectorTest.domUndo.bind(InspectorTest, next);
}

InspectorTest.runTestSuite = function(testSuite)
{
    function nextTest()
    {
        if (!testSuite.length) {
            InspectorTest.completeTest();
            return;
        }
        var fun = testSuite.shift();
        InspectorTest.log("\nRunning test: " + fun.name);
        fun(nextTest);
    }

    nextTest();
}

/**
 * @param {function(object)=} callback
 */
InspectorTest.wrapCallback = function(callback)
{
    /**
     * @param {object} message
     */
    function callbackWrapper(message)
    {
        if (InspectorTest.completeTestIfError(message))
            return;
        if (!callback)
            return;
        try {
            callback(message["result"]);
        } catch (e) {
            InspectorTest.log("Exception " + e + " while invoking callback: " + callback);
            InspectorTest.completeTest();
        }
    }
    return callbackWrapper;
}

/**
 * @param {string} command
 * @param {function({object} messageObject)=} handler
 */
InspectorTest.sendRawCommand = function(command, handler)
{
    this._dispatchTable[++this._requestId] = handler;
    var embedderMessage = { "id": ++this._embedderRequestId, "method": "dispatchProtocolMessage", "params": [command] };
    DevToolsHost.sendMessageToEmbedder(JSON.stringify(embedderMessage));
    return this._requestId;
}

InspectorTest.readyForTest = function()
{
    var embedderMessage = { "id": ++this._embedderRequestId, "method": "readyForTest" };
    DevToolsHost.sendMessageToEmbedder(JSON.stringify(embedderMessage));
}

/**
 * @param {string|!Object} messageOrObject
 */
DevToolsAPI.dispatchMessage = function(messageOrObject)
{
    var messageObject = (typeof messageOrObject === "string" ? JSON.parse(messageOrObject) : messageOrObject);
    if (InspectorTest._dumpInspectorProtocolMessages)
        testRunner.logToStderr("backend: " + JSON.stringify(messageObject));
    var messageId = messageObject["id"];
    try {
        if (typeof messageId === "number") {
            var handler = InspectorTest._dispatchTable[messageId];
            if (handler && typeof handler === "function")
                handler(messageObject);
        } else {
            var eventName = messageObject["method"];
            var eventHandler = InspectorTest.eventHandler[eventName];
            if (eventHandler)
                eventHandler(messageObject);
        }
    } catch(e) {
        InspectorTest.log("Exception when dispatching message: " + e + "\n" + e.stack + "\n message = " + JSON.stringify(messageObject, null, 2));
        InspectorTest.completeTest();
    }
}

/**
 * @param {number} callId
 * @param {string} script
 */
DevToolsAPI.evaluateForTestInFrontend = function(callId, script)
{
    try {
        eval(script);
    } catch (e) {
        InspectorTest.log("FAIL: exception in evaluateForTestInFrontend: " + e);
        InspectorTest.completeTest();
    }
}

/**
* Logs message to document.
* @param {string} message
*/
InspectorTest.log = function(message)
{
    this.sendCommand("Runtime.evaluate", { "expression": "log(" + JSON.stringify(message) + ")" } );
}

/**
* Formats and logs object to document.
* @param {Object} object
* @param {string=} title
* @param {Array<string>=} unstableKeys
*/
InspectorTest.logObject = function(object, title, unstableKeys)
{
    var lines = [];

    function dumpValue(value, prefix, prefixWithName)
    {
        if (typeof value === "object" && value !== null) {
            if (value instanceof Array)
                dumpItems(value, prefix, prefixWithName);
            else
                dumpProperties(value, prefix, prefixWithName);
        } else {
            lines.push(prefixWithName + String(value).replace(/\n/g, " "));
        }
    }

    function dumpProperties(object, prefix, firstLinePrefix)
    {
        prefix = prefix || "";
        firstLinePrefix = firstLinePrefix || prefix;
        lines.push(firstLinePrefix + "{");

        var propertyNames = Object.keys(object);
        propertyNames.sort();
        for (var i = 0; i < propertyNames.length; ++i) {
            var name = propertyNames[i];
            if (!object.hasOwnProperty(name))
                continue;
            var prefixWithName = "    " + prefix + name + " : ";
            var value = object[name];
            if (unstableKeys && unstableKeys.indexOf(name) !== -1)
                value = "<" + typeof(value) + ">";
            dumpValue(value, "    " + prefix, prefixWithName);
        }
        lines.push(prefix + "}");
    }

    function dumpItems(object, prefix, firstLinePrefix)
    {
        prefix = prefix || "";
        firstLinePrefix = firstLinePrefix || prefix;
        lines.push(firstLinePrefix + "[");
        for (var i = 0; i < object.length; ++i)
            dumpValue(object[i], "    " + prefix, "    " + prefix + "[" + i + "] : ");
        lines.push(prefix + "]");
    }

    dumpValue(object, "", title);
    InspectorTest.log(lines.join("\n"));
}

/**
* Logs message directly to process stdout via alert function (hopefully followed by flush call).
* This message should survive process crash or kill by timeout.
* @param {string} message
*/
InspectorTest.debugLog = function(message)
{
    this.sendCommand("Runtime.evaluate", { "expression": "debugLog(" + JSON.stringify(message) + ")" } );
}

InspectorTest.completeTest = function()
{
    this.sendCommand("Runtime.evaluate", { "expression": "closeTest();"} );
}

/**
 * Evaluates string in page.
 * @param {string} message
 * @param {!function} callback
 */
InspectorTest.evaluateInPage = function(string, callback)
{
    this.sendCommand("Runtime.evaluate", { "expression": string }, function(message) {
        if (message.error)
            InspectorTest.log("Error while executing '" + string + "': " + message.error.message);
        else if (callback)
            callback(message.result.result.value);
    });
};

/**
 * Evaluates expression in page.
 * @param {string} expression
 * @return {!Promise<?>}
 */
InspectorTest.evaluateInPagePromise = function(expression)
{
    return InspectorTest.sendCommandPromise("Runtime.evaluate", { "expression": expression, awaitPromise: false, returnByValue: true });
};

InspectorTest.evaluateInPageAsync = function(expression)
{
    return InspectorTest.sendCommandPromise("Runtime.evaluate", { "expression": expression, awaitPromise: true, returnByValue: true }).then((message) => message.result.result.value);
}

InspectorTest.completeTestIfError = function(messageObject)
{
    if (messageObject.error) {
        InspectorTest.log(messageObject.error.message);
        InspectorTest.completeTest();
        return true;
    }
    return false;
}

InspectorTest.checkExpectation = function(fail, name, messageObject)
{
    if (fail === !!messageObject.error) {
        InspectorTest.log("PASS: " + name);
        return true;
    }

    InspectorTest.log("FAIL: " + name + ": " + JSON.stringify(messageObject));
    InspectorTest.completeTest();
    return false;
}
InspectorTest.expectedSuccess = InspectorTest.checkExpectation.bind(null, false);
InspectorTest.expectedError = InspectorTest.checkExpectation.bind(null, true);

/**
 * @param {string} scriptName
 */
InspectorTest.importScript = function(scriptName)
{
    var xhr = new XMLHttpRequest();
    xhr.open("GET", scriptName, false);
    xhr.send(null);
    window.eval(xhr.responseText + "\n//# sourceURL=" + scriptName);
}

InspectorTest.safeWrap = function(func, onexception)
{
    function result()
    {
        if (!func)
            return;
        var wrapThis = this;
        try {
            return func.apply(wrapThis, arguments);
        } catch(e) {
            InspectorTest.log("Exception while running: " + func + "\n" + (e.stack || e));
            if (onexception)
                InspectorTest.safeWrap(onexception)();
            else
                InspectorTest.completeTest();
        }
    }
    return result;
}

InspectorTest.navigate = function(url, callback)
{
    InspectorTest._pageLoadedCallback = InspectorTest.safeWrap(callback);
    InspectorTest.evaluateInPage("navigateProtocolTest('" + url + "')");
}

InspectorTest.pageReloaded = function()
{
    InspectorTest.log("Page reloaded.");
    var callback = InspectorTest._pageLoadedCallback;
    delete InspectorTest._pageLoadedCallback;
    if (callback)
        callback();
}

InspectorTest.reloadProtocolTest = function(ignoreCache, callback)
{
    InspectorTest._pageLoadedCallback = afterReload;
    // This will ensure we maintain logs after navigate.

    getLogs(getOldLogsCallback);

    function getLogs(getLogsCallback)
    {
        InspectorTest.evaluateInPage("outputElement.innerHTML", data => getLogsCallback(data.split("<br>")));
    }

    function clearLogs(clearLogsCallback)
    {
        InspectorTest.evaluateInPage("outputElement.textContent = \"\"", clearLogsCallback);
    }

    var oldLogs;

    function getOldLogsCallback(data)
    {
        oldLogs = data;
        prepareForReload();
    }

    function prepareForReload()
    {
        InspectorTest.evaluateInPage("prepareForReload()", reload);
    }

    function reload()
    {
        InspectorTest.sendCommand("Page.reload", { "ignoreCache": ignoreCache });
    }

    function afterReload()
    {
        var currentLogs;
        getLogs(data => {
            currentLogs = data;
            clearLogs(addLogsBack);
        });

        function addLogsBack()
        {
            for (var log of oldLogs)
                InspectorTest.log(log);
            for (var log of currentLogs)
                InspectorTest.log(log);
            callback();
        }
    }
}

window.addEventListener("load", InspectorTest.readyForTest.bind(InspectorTest), false);

</script>
</head>
</html>
