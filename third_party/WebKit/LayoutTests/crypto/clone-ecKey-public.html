<!DOCTYPE html>
<html>
<head>
<script src="../resources/js-test.js"></script>
<script src="resources/common.js"></script>
</head>
<body>
<p id="description"></p>
<div id="console"></div>

<script>
description("Tests structured cloning of EC public keys");

jsTestIsAsync = true;

// Tests the 12 permutations of keys generated by:
//   kPossibleAlgorithms x kPossibleExtractable x kPossibleKeyUsages x kPossibleCurves
//
// For practical reasons these tests are not exhaustive.

var kPossibleAlgorithms = ['ECDSA'];
var kPossibleExtractable = [true, false];
var kPossibleKeyUsages = [[], ['verify']];
var kPossibleNamedCurves = ['P-256', 'P-384', 'P-521'];

// A mapping from curve name, to SPKI data (hex-encoded) for a valid public key.
var kKeyDataForCurve = {
    "P-256": "3059301306072A8648CE3D020106082A8648CE3D030107034200049CB0CF69303DAFC761D4E4687B4ECF039E6D34AB964AF80810D8D558A4A8D6F72D51233A1788920A86EE08A1962C79EFA317FB7879E297DAD2146DB995FA1C78",
    "P-384": "3076301006072A8648CE3D020106052B81040022036200040874A2E0B8FF448F0E54321E27F4F1E64D064CDEB7D26F458C32E930120F4E57DC85C2693F977EED4A8ECC8DB981B4D91F69446DF4F4C6F5DE19003F45F891D0EBCD2FFFDB5C81C040E8D6994C43C7FEEDB98A4A31EDFB35E89A30013C3B9267",
    "P-521": "30819B301006072A8648CE3D020106052B81040023038186000400F50A08703250C15F043C8C46E99783435245CF98F4F2694B0E2F8D029A514DD6F0B086D4ED892000CD5590107AAE69C4C0A7A95F7CF74E5770A07D5DB55BCE4AB400F2C770BAB8B9BE4CDB6ECD3DC26C698DA0D2599CEBF3D904F7F9CA3A55E64731810D73CD317264E50BABA4BC2860857E16D6CBB79501BC9E3A32BD172EA8A71DEE"
};

function runTest(algorithmName, namedCurve, extractable, keyUsages)
{
    var keyDataHex = kKeyDataForCurve[namedCurve];
    var importData = hexStringToUint8Array(keyDataHex);
    var importAlgorithm = { name: algorithmName, namedCurve: namedCurve };

    var results = {};

    return crypto.subtle.importKey('spki', importData, importAlgorithm, extractable, keyUsages).then(function(importedKey) {
        results.importedKey = importedKey;
        importedKey.extraProperty = 'hi';
        return cloneKey(importedKey);
    }).then(function(clonedKey) {
        results.clonedKey = clonedKey;
        if (extractable)
            return crypto.subtle.exportKey('spki', clonedKey);
        return null;
    }).then(function(clonedKeyData) {
        importedKey = results.importedKey;
        clonedKey = results.clonedKey;

        shouldEvaluateAs("importedKey.extraProperty", "hi");
        shouldEvaluateAs("importedKey.type", "public");
        shouldEvaluateAs("importedKey.extractable", extractable);
        shouldEvaluateAs("importedKey.algorithm.name", algorithmName);
        shouldEvaluateAs("importedKey.algorithm.namedCurve", namedCurve);
        shouldEvaluateAs("importedKey.usages.join(',')", keyUsages.join(","));

        shouldNotBe("importedKey", "clonedKey");

        shouldBeUndefined("clonedKey.extraProperty");
        shouldEvaluateAs("clonedKey.type", "public");
        shouldEvaluateAs("clonedKey.extractable", extractable);
        shouldEvaluateAs("clonedKey.algorithm.name", algorithmName);
        shouldEvaluateAs("clonedKey.algorithm.namedCurve", namedCurve);
        shouldEvaluateAs("clonedKey.usages.join(',')", keyUsages.join(","));

        logSerializedKey(importedKey);

        if (extractable)
            bytesShouldMatchHexString("Cloned key exported data", keyDataHex, clonedKeyData);

        debug("");
    });
}

var lastPromise = Promise.resolve(null);

kPossibleAlgorithms.forEach(function(algorithmName) {
    kPossibleExtractable.forEach(function(extractable) {
        kPossibleKeyUsages.forEach(function(keyUsages) {
              kPossibleNamedCurves.forEach(function(namedCurve) {
                  lastPromise = lastPromise.then(runTest.bind(null, algorithmName, namedCurve, extractable, keyUsages));
              });
        });
    });
});

lastPromise.then(finishJSTest, failAndFinishJSTest);

</script>

</body>
</html>
