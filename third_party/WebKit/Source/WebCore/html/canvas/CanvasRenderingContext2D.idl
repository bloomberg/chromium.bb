/*
 * Copyright (C) 2006 Apple Computer, Inc.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

enum CanvasWindingRule { "nonzero", "evenodd" };

interface CanvasRenderingContext2D : CanvasRenderingContext {

    void save();
    void restore();

    void scale([Optional=DefaultIsUndefined] float sx,
               [Optional=DefaultIsUndefined] float sy);
    void rotate([Optional=DefaultIsUndefined] float angle);
    void translate([Optional=DefaultIsUndefined] float tx,
                   [Optional=DefaultIsUndefined] float ty);
    void transform([Optional=DefaultIsUndefined] float m11,
                   [Optional=DefaultIsUndefined] float m12,
                   [Optional=DefaultIsUndefined] float m21,
                   [Optional=DefaultIsUndefined] float m22,
                   [Optional=DefaultIsUndefined] float dx,
                   [Optional=DefaultIsUndefined] float dy);
    void setTransform([Optional=DefaultIsUndefined] float m11,
                      [Optional=DefaultIsUndefined] float m12,
                      [Optional=DefaultIsUndefined] float m21,
                      [Optional=DefaultIsUndefined] float m22,
                      [Optional=DefaultIsUndefined] float dx,
                      [Optional=DefaultIsUndefined] float dy);

    attribute float globalAlpha;
    [TreatNullAs=NullString] attribute DOMString globalCompositeOperation;

    [RaisesException] CanvasGradient createLinearGradient([Optional=DefaultIsUndefined] float x0,
                                        [Optional=DefaultIsUndefined] float y0,
                                        [Optional=DefaultIsUndefined] float x1,
                                        [Optional=DefaultIsUndefined] float y1);
    [RaisesException] CanvasGradient createRadialGradient([Optional=DefaultIsUndefined] float x0,
                                        [Optional=DefaultIsUndefined] float y0,
                                        [Optional=DefaultIsUndefined] float r0,
                                        [Optional=DefaultIsUndefined] float x1,
                                        [Optional=DefaultIsUndefined] float y1,
                                        [Optional=DefaultIsUndefined] float r1);

    attribute float lineWidth;
    [TreatNullAs=NullString] attribute DOMString lineCap;
    [TreatNullAs=NullString] attribute DOMString lineJoin;
    attribute float miterLimit;

    attribute float shadowOffsetX;
    attribute float shadowOffsetY;
    attribute float shadowBlur;
    [TreatNullAs=NullString] attribute DOMString shadowColor;

    void setLineDash(sequence<float> dash);
    sequence<float> getLineDash();
    attribute float lineDashOffset;

    // FIXME: These attributes should be implemented.
    // [Custom] attribute Array webkitLineDash;
    // attribute float webkitLineDashOffset;

    void clearRect([Optional=DefaultIsUndefined] float x,
                   [Optional=DefaultIsUndefined] float y,
                   [Optional=DefaultIsUndefined] float width,
                   [Optional=DefaultIsUndefined] float height);
    void fillRect([Optional=DefaultIsUndefined] float x,
                  [Optional=DefaultIsUndefined] float y,
                  [Optional=DefaultIsUndefined] float width,
                  [Optional=DefaultIsUndefined] float height);

    void beginPath();

#if defined(ENABLE_CANVAS_PATH) && ENABLE_CANVAS_PATH
    attribute DOMPath currentPath;
#endif

    // FIXME: These methods should be shared with CanvasRenderingContext2D in the CanvasPathMethods interface.
    void closePath();
    void moveTo([Optional=DefaultIsUndefined] float x,
                [Optional=DefaultIsUndefined] float y);
    void lineTo([Optional=DefaultIsUndefined] float x,
                [Optional=DefaultIsUndefined] float y);
    void quadraticCurveTo([Optional=DefaultIsUndefined] float cpx,
                          [Optional=DefaultIsUndefined] float cpy,
                          [Optional=DefaultIsUndefined] float x,
                          [Optional=DefaultIsUndefined] float y);
    void bezierCurveTo([Optional=DefaultIsUndefined] float cp1x,
                       [Optional=DefaultIsUndefined] float cp1y,
                       [Optional=DefaultIsUndefined] float cp2x,
                       [Optional=DefaultIsUndefined] float cp2y,
                       [Optional=DefaultIsUndefined] float x,
                       [Optional=DefaultIsUndefined] float y);
    [RaisesException] void arcTo([Optional=DefaultIsUndefined] float x1,
               [Optional=DefaultIsUndefined] float y1,
               [Optional=DefaultIsUndefined] float x2,
               [Optional=DefaultIsUndefined] float y2,
               [Optional=DefaultIsUndefined] float radius);
    void rect([Optional=DefaultIsUndefined] float x,
              [Optional=DefaultIsUndefined] float y,
              [Optional=DefaultIsUndefined] float width,
              [Optional=DefaultIsUndefined] float height);
    [RaisesException] void arc([Optional=DefaultIsUndefined] float x,
             [Optional=DefaultIsUndefined] float y,
             [Optional=DefaultIsUndefined] float radius,
             [Optional=DefaultIsUndefined] float startAngle,
             [Optional=DefaultIsUndefined] float endAngle,
             [Optional=DefaultIsUndefined] boolean anticlockwise);

    void fill([Optional] CanvasWindingRule winding);
    void stroke();
    void clip([Optional] CanvasWindingRule winding);
    boolean isPointInPath([Optional=DefaultIsUndefined] float x,
                          [Optional=DefaultIsUndefined] float y,
                          [Optional] CanvasWindingRule winding);
    boolean isPointInStroke([Optional=DefaultIsUndefined] float x,
                            [Optional=DefaultIsUndefined] float y);

    // text
    attribute DOMString font;
    attribute DOMString textAlign;
    attribute DOMString textBaseline;

    TextMetrics measureText([Optional=DefaultIsUndefined] DOMString text);

    // other

    void setAlpha([Optional=DefaultIsUndefined] float alpha);
    void setCompositeOperation([Optional=DefaultIsUndefined] DOMString compositeOperation);

    void setLineWidth([Optional=DefaultIsUndefined] float width);
    void setLineCap([Optional=DefaultIsUndefined] DOMString cap);
    void setLineJoin([Optional=DefaultIsUndefined] DOMString join);
    void setMiterLimit([Optional=DefaultIsUndefined] float limit);

    void clearShadow();

    void fillText(DOMString text, float x, float y, [Optional] float maxWidth);
    void strokeText(DOMString text, float x, float y, [Optional] float maxWidth);

    void setStrokeColor([StrictTypeChecking] DOMString color, [Optional] float alpha);
    void setStrokeColor(float grayLevel, [Optional] float alpha);
    void setStrokeColor(float r, float g, float b, float a);
    void setStrokeColor(float c, float m, float y, float k, float a);

    void setFillColor([StrictTypeChecking] DOMString color, [Optional] float alpha);
    void setFillColor(float grayLevel, [Optional] float alpha);
    void setFillColor(float r, float g, float b, float a);
    void setFillColor(float c, float m, float y, float k, float a);

    void strokeRect([Optional=DefaultIsUndefined] float x,
                    [Optional=DefaultIsUndefined] float y,
                    [Optional=DefaultIsUndefined] float width,
                    [Optional=DefaultIsUndefined] float height,
                    [Optional] float lineWidth);

    [RaisesException] void drawImage(HTMLImageElement? image, float x, float y);
    [RaisesException] void drawImage(HTMLImageElement? image, float x, float y, float width, float height);
    [RaisesException] void drawImage(HTMLImageElement? image, float sx, float sy, float sw, float sh, float dx, float dy, float dw, float dh);
    [RaisesException] void drawImage(HTMLCanvasElement? canvas, float x, float y);
    [RaisesException] void drawImage(HTMLCanvasElement? canvas, float x, float y, float width, float height);
    [RaisesException] void drawImage(HTMLCanvasElement? canvas, float sx, float sy, float sw, float sh, float dx, float dy, float dw, float dh);
#if defined(ENABLE_VIDEO) && ENABLE_VIDEO
    [RaisesException] void drawImage(HTMLVideoElement? video, float x, float y);
    [RaisesException] void drawImage(HTMLVideoElement? video, float x, float y, float width, float height);
    [RaisesException] void drawImage(HTMLVideoElement? video, float sx, float sy, float sw, float sh, float dx, float dy, float dw, float dh);
#endif

    void drawImageFromRect(HTMLImageElement image,
                           [Optional] float sx, [Optional] float sy, [Optional] float sw, [Optional] float sh,
                           [Optional] float dx, [Optional] float dy, [Optional] float dw, [Optional] float dh,
                           [Optional] DOMString compositeOperation);

    void setShadow(float width, float height, float blur, [Optional, StrictTypeChecking] DOMString color, [Optional] float alpha);
    void setShadow(float width, float height, float blur, float grayLevel, [Optional] float alpha);
    void setShadow(float width, float height, float blur, float r, float g, float b, float a);
    void setShadow(float width, float height, float blur, float c, float m, float y, float k, float a);

    [RaisesException] void putImageData(ImageData? imagedata, float dx, float dy);
    [RaisesException] void putImageData(ImageData? imagedata, float dx, float dy, float dirtyX, float dirtyY, float dirtyWidth, float dirtyHeight);

    [RaisesException] void webkitPutImageDataHD(ImageData? imagedata, float dx, float dy);
    [RaisesException] void webkitPutImageDataHD(ImageData? imagedata, float dx, float dy, float dirtyX, float dirtyY, float dirtyWidth, float dirtyHeight);

    [RaisesException] CanvasPattern createPattern(HTMLCanvasElement? canvas, [TreatNullAs=NullString] DOMString repetitionType);
    [RaisesException] CanvasPattern createPattern(HTMLImageElement? image, [TreatNullAs=NullString] DOMString repetitionType);
    [RaisesException] ImageData createImageData(ImageData? imagedata);
    [RaisesException] ImageData createImageData(float sw, float sh);

    [Custom] attribute custom strokeStyle;
    [Custom] attribute custom fillStyle;

    // pixel manipulation
    [RaisesException] ImageData getImageData([Optional=DefaultIsUndefined] float sx, [Optional=DefaultIsUndefined] float sy,
                           [Optional=DefaultIsUndefined] float sw, [Optional=DefaultIsUndefined] float sh);

    [RaisesException] ImageData webkitGetImageDataHD([Optional=DefaultIsUndefined] float sx, [Optional=DefaultIsUndefined] float sy,
                                   [Optional=DefaultIsUndefined] float sw, [Optional=DefaultIsUndefined] float sh);

    readonly attribute float webkitBackingStorePixelRatio;

    attribute boolean webkitImageSmoothingEnabled;
};

