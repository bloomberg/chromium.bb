// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file has been auto-generated by code_generator_v8.py. DO NOT MODIFY!

#ifndef UnionTypeCore_h
#define UnionTypeCore_h

#include "bindings/core/v8/Dictionary.h"
#include "bindings/core/v8/ExceptionState.h"
#include "bindings/core/v8/V8Binding.h"
#include "platform/heap/Handle.h"

namespace blink {

class DOMUint8Array;
class Node;
class NodeList;
class TestArrayBuffer;
class TestArrayBufferView;
class TestDictionary;
class TestInterface2;
class TestInterfaceEmpty;
class TestInterfaceGarbageCollected;
class TestInterfaceImplementation;
class TestInterfaceWillBeGarbageCollected;

class ArrayBufferOrArrayBufferViewOrDictionary final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    ArrayBufferOrArrayBufferViewOrDictionary();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isArrayBuffer() const { return m_type == SpecificTypeArrayBuffer; }
    PassRefPtr<TestArrayBuffer> getAsArrayBuffer() const;
    void setArrayBuffer(PassRefPtr<TestArrayBuffer>);
    static ArrayBufferOrArrayBufferViewOrDictionary fromArrayBuffer(PassRefPtr<TestArrayBuffer>);

    bool isArrayBufferView() const { return m_type == SpecificTypeArrayBufferView; }
    PassRefPtr<TestArrayBufferView> getAsArrayBufferView() const;
    void setArrayBufferView(PassRefPtr<TestArrayBufferView>);
    static ArrayBufferOrArrayBufferViewOrDictionary fromArrayBufferView(PassRefPtr<TestArrayBufferView>);

    bool isDictionary() const { return m_type == SpecificTypeDictionary; }
    Dictionary getAsDictionary() const;
    void setDictionary(Dictionary);
    static ArrayBufferOrArrayBufferViewOrDictionary fromDictionary(Dictionary);

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeArrayBuffer,
        SpecificTypeArrayBufferView,
        SpecificTypeDictionary,
    };
    SpecificTypes m_type;

    RefPtr<TestArrayBuffer> m_arrayBuffer;
    RefPtr<TestArrayBufferView> m_arrayBufferView;
    Dictionary m_dictionary;

    friend v8::Local<v8::Value> toV8(const ArrayBufferOrArrayBufferViewOrDictionary&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8ArrayBufferOrArrayBufferViewOrDictionary final {
public:
    static void toImpl(v8::Isolate*, v8::Local<v8::Value>, ArrayBufferOrArrayBufferViewOrDictionary&, ExceptionState&);
};

v8::Local<v8::Value> toV8(const ArrayBufferOrArrayBufferViewOrDictionary&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, ArrayBufferOrArrayBufferViewOrDictionary& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<ArrayBufferOrArrayBufferViewOrDictionary> {
    static ArrayBufferOrArrayBufferViewOrDictionary nativeValue(v8::Local<v8::Value>, v8::Isolate*, ExceptionState&);
};

class BooleanOrStringOrUnrestrictedDouble final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    BooleanOrStringOrUnrestrictedDouble();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isBoolean() const { return m_type == SpecificTypeBoolean; }
    bool getAsBoolean() const;
    void setBoolean(bool);
    static BooleanOrStringOrUnrestrictedDouble fromBoolean(bool);

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static BooleanOrStringOrUnrestrictedDouble fromString(String);

    bool isUnrestrictedDouble() const { return m_type == SpecificTypeUnrestrictedDouble; }
    double getAsUnrestrictedDouble() const;
    void setUnrestrictedDouble(double);
    static BooleanOrStringOrUnrestrictedDouble fromUnrestrictedDouble(double);

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeBoolean,
        SpecificTypeString,
        SpecificTypeUnrestrictedDouble,
    };
    SpecificTypes m_type;

    bool m_boolean;
    String m_string;
    double m_unrestrictedDouble;

    friend v8::Local<v8::Value> toV8(const BooleanOrStringOrUnrestrictedDouble&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8BooleanOrStringOrUnrestrictedDouble final {
public:
    static void toImpl(v8::Isolate*, v8::Local<v8::Value>, BooleanOrStringOrUnrestrictedDouble&, ExceptionState&);
};

v8::Local<v8::Value> toV8(const BooleanOrStringOrUnrestrictedDouble&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, BooleanOrStringOrUnrestrictedDouble& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<BooleanOrStringOrUnrestrictedDouble> {
    static BooleanOrStringOrUnrestrictedDouble nativeValue(v8::Local<v8::Value>, v8::Isolate*, ExceptionState&);
};

class DoubleOrString final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    DoubleOrString();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isDouble() const { return m_type == SpecificTypeDouble; }
    double getAsDouble() const;
    void setDouble(double);
    static DoubleOrString fromDouble(double);

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static DoubleOrString fromString(String);

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeDouble,
        SpecificTypeString,
    };
    SpecificTypes m_type;

    double m_double;
    String m_string;

    friend v8::Local<v8::Value> toV8(const DoubleOrString&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8DoubleOrString final {
public:
    static void toImpl(v8::Isolate*, v8::Local<v8::Value>, DoubleOrString&, ExceptionState&);
};

v8::Local<v8::Value> toV8(const DoubleOrString&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, DoubleOrString& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<DoubleOrString> {
    static DoubleOrString nativeValue(v8::Local<v8::Value>, v8::Isolate*, ExceptionState&);
};

class NodeOrNodeList final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    NodeOrNodeList();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isNode() const { return m_type == SpecificTypeNode; }
    PassRefPtrWillBeRawPtr<Node> getAsNode() const;
    void setNode(PassRefPtrWillBeRawPtr<Node>);
    static NodeOrNodeList fromNode(PassRefPtrWillBeRawPtr<Node>);

    bool isNodeList() const { return m_type == SpecificTypeNodeList; }
    PassRefPtrWillBeRawPtr<NodeList> getAsNodeList() const;
    void setNodeList(PassRefPtrWillBeRawPtr<NodeList>);
    static NodeOrNodeList fromNodeList(PassRefPtrWillBeRawPtr<NodeList>);

    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeNode,
        SpecificTypeNodeList,
    };
    SpecificTypes m_type;

    RefPtrWillBeMember<Node> m_node;
    RefPtrWillBeMember<NodeList> m_nodeList;

    friend v8::Local<v8::Value> toV8(const NodeOrNodeList&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8NodeOrNodeList final {
public:
    static void toImpl(v8::Isolate*, v8::Local<v8::Value>, NodeOrNodeList&, ExceptionState&);
};

v8::Local<v8::Value> toV8(const NodeOrNodeList&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, NodeOrNodeList& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<NodeOrNodeList> {
    static NodeOrNodeList nativeValue(v8::Local<v8::Value>, v8::Isolate*, ExceptionState&);
};

class StringOrArrayBufferOrArrayBufferView final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    StringOrArrayBufferOrArrayBufferView();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static StringOrArrayBufferOrArrayBufferView fromString(String);

    bool isArrayBuffer() const { return m_type == SpecificTypeArrayBuffer; }
    PassRefPtr<TestArrayBuffer> getAsArrayBuffer() const;
    void setArrayBuffer(PassRefPtr<TestArrayBuffer>);
    static StringOrArrayBufferOrArrayBufferView fromArrayBuffer(PassRefPtr<TestArrayBuffer>);

    bool isArrayBufferView() const { return m_type == SpecificTypeArrayBufferView; }
    PassRefPtr<TestArrayBufferView> getAsArrayBufferView() const;
    void setArrayBufferView(PassRefPtr<TestArrayBufferView>);
    static StringOrArrayBufferOrArrayBufferView fromArrayBufferView(PassRefPtr<TestArrayBufferView>);

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeString,
        SpecificTypeArrayBuffer,
        SpecificTypeArrayBufferView,
    };
    SpecificTypes m_type;

    String m_string;
    RefPtr<TestArrayBuffer> m_arrayBuffer;
    RefPtr<TestArrayBufferView> m_arrayBufferView;

    friend v8::Local<v8::Value> toV8(const StringOrArrayBufferOrArrayBufferView&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8StringOrArrayBufferOrArrayBufferView final {
public:
    static void toImpl(v8::Isolate*, v8::Local<v8::Value>, StringOrArrayBufferOrArrayBufferView&, ExceptionState&);
};

v8::Local<v8::Value> toV8(const StringOrArrayBufferOrArrayBufferView&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, StringOrArrayBufferOrArrayBufferView& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<StringOrArrayBufferOrArrayBufferView> {
    static StringOrArrayBufferOrArrayBufferView nativeValue(v8::Local<v8::Value>, v8::Isolate*, ExceptionState&);
};

class StringOrDouble final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    StringOrDouble();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static StringOrDouble fromString(String);

    bool isDouble() const { return m_type == SpecificTypeDouble; }
    double getAsDouble() const;
    void setDouble(double);
    static StringOrDouble fromDouble(double);

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeString,
        SpecificTypeDouble,
    };
    SpecificTypes m_type;

    String m_string;
    double m_double;

    friend v8::Local<v8::Value> toV8(const StringOrDouble&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8StringOrDouble final {
public:
    static void toImpl(v8::Isolate*, v8::Local<v8::Value>, StringOrDouble&, ExceptionState&);
};

v8::Local<v8::Value> toV8(const StringOrDouble&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, StringOrDouble& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<StringOrDouble> {
    static StringOrDouble nativeValue(v8::Local<v8::Value>, v8::Isolate*, ExceptionState&);
};

class StringOrStringSequence final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    StringOrStringSequence();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static StringOrStringSequence fromString(String);

    bool isStringSequence() const { return m_type == SpecificTypeStringSequence; }
    const Vector<String>& getAsStringSequence() const;
    void setStringSequence(const Vector<String>&);
    static StringOrStringSequence fromStringSequence(const Vector<String>&);

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeString,
        SpecificTypeStringSequence,
    };
    SpecificTypes m_type;

    String m_string;
    Vector<String> m_stringSequence;

    friend v8::Local<v8::Value> toV8(const StringOrStringSequence&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8StringOrStringSequence final {
public:
    static void toImpl(v8::Isolate*, v8::Local<v8::Value>, StringOrStringSequence&, ExceptionState&);
};

v8::Local<v8::Value> toV8(const StringOrStringSequence&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, StringOrStringSequence& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<StringOrStringSequence> {
    static StringOrStringSequence nativeValue(v8::Local<v8::Value>, v8::Isolate*, ExceptionState&);
};

class TestEnumOrDouble final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    TestEnumOrDouble();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isTestEnum() const { return m_type == SpecificTypeTestEnum; }
    String getAsTestEnum() const;
    void setTestEnum(String);
    static TestEnumOrDouble fromTestEnum(String);

    bool isDouble() const { return m_type == SpecificTypeDouble; }
    double getAsDouble() const;
    void setDouble(double);
    static TestEnumOrDouble fromDouble(double);

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeTestEnum,
        SpecificTypeDouble,
    };
    SpecificTypes m_type;

    String m_testEnum;
    double m_double;

    friend v8::Local<v8::Value> toV8(const TestEnumOrDouble&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8TestEnumOrDouble final {
public:
    static void toImpl(v8::Isolate*, v8::Local<v8::Value>, TestEnumOrDouble&, ExceptionState&);
};

v8::Local<v8::Value> toV8(const TestEnumOrDouble&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, TestEnumOrDouble& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<TestEnumOrDouble> {
    static TestEnumOrDouble nativeValue(v8::Local<v8::Value>, v8::Isolate*, ExceptionState&);
};

class TestInterface2OrUint8Array final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    TestInterface2OrUint8Array();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isTestInterface2() const { return m_type == SpecificTypeTestInterface2; }
    PassRefPtr<TestInterface2> getAsTestInterface2() const;
    void setTestInterface2(PassRefPtr<TestInterface2>);
    static TestInterface2OrUint8Array fromTestInterface2(PassRefPtr<TestInterface2>);

    bool isUint8Array() const { return m_type == SpecificTypeUint8Array; }
    PassRefPtr<DOMUint8Array> getAsUint8Array() const;
    void setUint8Array(PassRefPtr<DOMUint8Array>);
    static TestInterface2OrUint8Array fromUint8Array(PassRefPtr<DOMUint8Array>);

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeTestInterface2,
        SpecificTypeUint8Array,
    };
    SpecificTypes m_type;

    RefPtr<TestInterface2> m_testInterface2;
    RefPtr<DOMUint8Array> m_uint8Array;

    friend v8::Local<v8::Value> toV8(const TestInterface2OrUint8Array&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8TestInterface2OrUint8Array final {
public:
    static void toImpl(v8::Isolate*, v8::Local<v8::Value>, TestInterface2OrUint8Array&, ExceptionState&);
};

v8::Local<v8::Value> toV8(const TestInterface2OrUint8Array&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, TestInterface2OrUint8Array& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<TestInterface2OrUint8Array> {
    static TestInterface2OrUint8Array nativeValue(v8::Local<v8::Value>, v8::Isolate*, ExceptionState&);
};

class TestInterfaceGarbageCollectedOrString final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    TestInterfaceGarbageCollectedOrString();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isTestInterfaceGarbageCollected() const { return m_type == SpecificTypeTestInterfaceGarbageCollected; }
    TestInterfaceGarbageCollected* getAsTestInterfaceGarbageCollected() const;
    void setTestInterfaceGarbageCollected(TestInterfaceGarbageCollected*);
    static TestInterfaceGarbageCollectedOrString fromTestInterfaceGarbageCollected(TestInterfaceGarbageCollected*);

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static TestInterfaceGarbageCollectedOrString fromString(String);

    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeTestInterfaceGarbageCollected,
        SpecificTypeString,
    };
    SpecificTypes m_type;

    Member<TestInterfaceGarbageCollected> m_testInterfaceGarbageCollected;
    String m_string;

    friend v8::Local<v8::Value> toV8(const TestInterfaceGarbageCollectedOrString&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8TestInterfaceGarbageCollectedOrString final {
public:
    static void toImpl(v8::Isolate*, v8::Local<v8::Value>, TestInterfaceGarbageCollectedOrString&, ExceptionState&);
};

v8::Local<v8::Value> toV8(const TestInterfaceGarbageCollectedOrString&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, TestInterfaceGarbageCollectedOrString& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<TestInterfaceGarbageCollectedOrString> {
    static TestInterfaceGarbageCollectedOrString nativeValue(v8::Local<v8::Value>, v8::Isolate*, ExceptionState&);
};

class TestInterfaceOrLong final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    TestInterfaceOrLong();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isTestInterface() const { return m_type == SpecificTypeTestInterface; }
    PassRefPtr<TestInterfaceImplementation> getAsTestInterface() const;
    void setTestInterface(PassRefPtr<TestInterfaceImplementation>);
    static TestInterfaceOrLong fromTestInterface(PassRefPtr<TestInterfaceImplementation>);

    bool isLong() const { return m_type == SpecificTypeLong; }
    int getAsLong() const;
    void setLong(int);
    static TestInterfaceOrLong fromLong(int);

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeTestInterface,
        SpecificTypeLong,
    };
    SpecificTypes m_type;

    RefPtr<TestInterfaceImplementation> m_testInterface;
    int m_long;

    friend v8::Local<v8::Value> toV8(const TestInterfaceOrLong&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8TestInterfaceOrLong final {
public:
    static void toImpl(v8::Isolate*, v8::Local<v8::Value>, TestInterfaceOrLong&, ExceptionState&);
};

v8::Local<v8::Value> toV8(const TestInterfaceOrLong&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, TestInterfaceOrLong& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<TestInterfaceOrLong> {
    static TestInterfaceOrLong nativeValue(v8::Local<v8::Value>, v8::Isolate*, ExceptionState&);
};

class TestInterfaceOrTestInterfaceEmpty final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    TestInterfaceOrTestInterfaceEmpty();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isTestInterface() const { return m_type == SpecificTypeTestInterface; }
    PassRefPtr<TestInterfaceImplementation> getAsTestInterface() const;
    void setTestInterface(PassRefPtr<TestInterfaceImplementation>);
    static TestInterfaceOrTestInterfaceEmpty fromTestInterface(PassRefPtr<TestInterfaceImplementation>);

    bool isTestInterfaceEmpty() const { return m_type == SpecificTypeTestInterfaceEmpty; }
    PassRefPtr<TestInterfaceEmpty> getAsTestInterfaceEmpty() const;
    void setTestInterfaceEmpty(PassRefPtr<TestInterfaceEmpty>);
    static TestInterfaceOrTestInterfaceEmpty fromTestInterfaceEmpty(PassRefPtr<TestInterfaceEmpty>);

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeTestInterface,
        SpecificTypeTestInterfaceEmpty,
    };
    SpecificTypes m_type;

    RefPtr<TestInterfaceImplementation> m_testInterface;
    RefPtr<TestInterfaceEmpty> m_testInterfaceEmpty;

    friend v8::Local<v8::Value> toV8(const TestInterfaceOrTestInterfaceEmpty&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8TestInterfaceOrTestInterfaceEmpty final {
public:
    static void toImpl(v8::Isolate*, v8::Local<v8::Value>, TestInterfaceOrTestInterfaceEmpty&, ExceptionState&);
};

v8::Local<v8::Value> toV8(const TestInterfaceOrTestInterfaceEmpty&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, TestInterfaceOrTestInterfaceEmpty& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<TestInterfaceOrTestInterfaceEmpty> {
    static TestInterfaceOrTestInterfaceEmpty nativeValue(v8::Local<v8::Value>, v8::Isolate*, ExceptionState&);
};

class TestInterfaceWillBeGarbageCollectedOrTestDictionary final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    TestInterfaceWillBeGarbageCollectedOrTestDictionary();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isTestInterfaceWillBeGarbageCollected() const { return m_type == SpecificTypeTestInterfaceWillBeGarbageCollected; }
    PassRefPtrWillBeRawPtr<TestInterfaceWillBeGarbageCollected> getAsTestInterfaceWillBeGarbageCollected() const;
    void setTestInterfaceWillBeGarbageCollected(PassRefPtrWillBeRawPtr<TestInterfaceWillBeGarbageCollected>);
    static TestInterfaceWillBeGarbageCollectedOrTestDictionary fromTestInterfaceWillBeGarbageCollected(PassRefPtrWillBeRawPtr<TestInterfaceWillBeGarbageCollected>);

    bool isTestDictionary() const { return m_type == SpecificTypeTestDictionary; }
    TestDictionary getAsTestDictionary() const;
    void setTestDictionary(TestDictionary);
    static TestInterfaceWillBeGarbageCollectedOrTestDictionary fromTestDictionary(TestDictionary);

    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeTestInterfaceWillBeGarbageCollected,
        SpecificTypeTestDictionary,
    };
    SpecificTypes m_type;

    RefPtrWillBeMember<TestInterfaceWillBeGarbageCollected> m_testInterfaceWillBeGarbageCollected;
    TestDictionary m_testDictionary;

    friend v8::Local<v8::Value> toV8(const TestInterfaceWillBeGarbageCollectedOrTestDictionary&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8TestInterfaceWillBeGarbageCollectedOrTestDictionary final {
public:
    static void toImpl(v8::Isolate*, v8::Local<v8::Value>, TestInterfaceWillBeGarbageCollectedOrTestDictionary&, ExceptionState&);
};

v8::Local<v8::Value> toV8(const TestInterfaceWillBeGarbageCollectedOrTestDictionary&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, TestInterfaceWillBeGarbageCollectedOrTestDictionary& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<TestInterfaceWillBeGarbageCollectedOrTestDictionary> {
    static TestInterfaceWillBeGarbageCollectedOrTestDictionary nativeValue(v8::Local<v8::Value>, v8::Isolate*, ExceptionState&);
};

class UnrestrictedDoubleOrString final {
    ALLOW_ONLY_INLINE_ALLOCATION();
public:
    UnrestrictedDoubleOrString();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isUnrestrictedDouble() const { return m_type == SpecificTypeUnrestrictedDouble; }
    double getAsUnrestrictedDouble() const;
    void setUnrestrictedDouble(double);
    static UnrestrictedDoubleOrString fromUnrestrictedDouble(double);

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static UnrestrictedDoubleOrString fromString(String);

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeUnrestrictedDouble,
        SpecificTypeString,
    };
    SpecificTypes m_type;

    double m_unrestrictedDouble;
    String m_string;

    friend v8::Local<v8::Value> toV8(const UnrestrictedDoubleOrString&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8UnrestrictedDoubleOrString final {
public:
    static void toImpl(v8::Isolate*, v8::Local<v8::Value>, UnrestrictedDoubleOrString&, ExceptionState&);
};

v8::Local<v8::Value> toV8(const UnrestrictedDoubleOrString&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, UnrestrictedDoubleOrString& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<UnrestrictedDoubleOrString> {
    static UnrestrictedDoubleOrString nativeValue(v8::Local<v8::Value>, v8::Isolate*, ExceptionState&);
};

class V8DoubleOrStringOrNull final {
public:
    static void toImpl(v8::Isolate* isolate, v8::Local<v8::Value> v8Value, DoubleOrString& impl, ExceptionState& exceptionState)
    {
        if (isUndefinedOrNull(v8Value))
            return;
        V8DoubleOrString::toImpl(isolate, v8Value, impl, exceptionState);
    }
};

} // namespace blink

#endif // UnionTypeCore_h
