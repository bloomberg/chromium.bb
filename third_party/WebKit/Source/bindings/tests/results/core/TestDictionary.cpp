// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file has been auto-generated by code_generator_v8.py.
// DO NOT MODIFY!

// This file has been generated from the Jinja2 template in
// third_party/WebKit/Source/bindings/templates/dictionary_impl.cpp.tmpl

// clang-format off
#include "TestDictionary.h"

#include "bindings/tests/idls/core/TestInterfaceGarbageCollected.h"
#include "bindings/tests/idls/core/TestInterfaceImplementation.h"
#include "bindings/tests/idls/core/TestObject.h"
#include "core/dom/Element.h"
#include "core/dom/events/EventTarget.h"
#include "platform/wtf/Vector.h"

namespace blink {

TestDictionary::TestDictionary() {
  setDoubleOrStringMember(DoubleOrString::fromDouble(3.14));
  setEnumMember("foo");
  setLongMember(1);
  setOtherDoubleOrStringMember(DoubleOrString::fromString("default string value"));
  setRestrictedDoubleMember(3.14);
  setStringOrNullMember("default string value");
  setStringSequenceMember(Vector<String>());
  setTestInterfaceGarbageCollectedSequenceMember(HeapVector<Member<TestInterfaceGarbageCollected>>());
  setTestInterfaceSequenceMember(HeapVector<Member<TestInterfaceImplementation>>());
  setUnrestrictedDoubleMember(3.14);
}

TestDictionary::~TestDictionary() {}

TestDictionary::TestDictionary(const TestDictionary&) = default;

TestDictionary& TestDictionary::operator=(const TestDictionary&) = default;

bool TestDictionary::hasAnyInRecordMember() const {
  return has_any_in_record_member_;
}
const Vector<std::pair<String, ScriptValue>>& TestDictionary::anyInRecordMember() const {
  DCHECK(has_any_in_record_member_);
  return any_in_record_member_;
}
void TestDictionary::setAnyInRecordMember(const Vector<std::pair<String, ScriptValue>>& value) {
  any_in_record_member_ = value;
  has_any_in_record_member_ = true;
}
bool TestDictionary::hasAnyMember() const {
  return !(any_member_.IsEmpty() || any_member_.IsNull() || any_member_.IsUndefined());
}
ScriptValue TestDictionary::anyMember() const {
  return any_member_;
}
void TestDictionary::setAnyMember(ScriptValue value) {
  any_member_ = value;
}
bool TestDictionary::hasBooleanMember() const {
  return has_boolean_member_;
}
bool TestDictionary::booleanMember() const {
  DCHECK(has_boolean_member_);
  return boolean_member_;
}
void TestDictionary::setBooleanMember(bool value) {
  boolean_member_ = value;
  has_boolean_member_ = true;
}
bool TestDictionary::hasCreateMember() const {
  return has_create_member_;
}
bool TestDictionary::createMember() const {
  DCHECK(has_create_member_);
  return create_member_;
}
void TestDictionary::setCreateMember(bool value) {
  create_member_ = value;
  has_create_member_ = true;
}
bool TestDictionary::hasDictionaryMember() const {
  return !dictionary_member_.IsUndefinedOrNull();
}
Dictionary TestDictionary::dictionaryMember() const {
  return dictionary_member_;
}
void TestDictionary::setDictionaryMember(Dictionary value) {
  dictionary_member_ = value;
}
bool TestDictionary::hasDoubleOrNullMember() const {
  return has_double_or_null_member_;
}
double TestDictionary::doubleOrNullMember() const {
  DCHECK(has_double_or_null_member_);
  return double_or_null_member_;
}
void TestDictionary::setDoubleOrNullMember(double value) {
  double_or_null_member_ = value;
  has_double_or_null_member_ = true;
}
void TestDictionary::setDoubleOrNullMemberToNull() {
  has_double_or_null_member_ = false;
}
bool TestDictionary::hasDoubleOrStringMember() const {
  return !double_or_string_member_.isNull();
}
const DoubleOrString& TestDictionary::doubleOrStringMember() const {
  return double_or_string_member_;
}
void TestDictionary::setDoubleOrStringMember(const DoubleOrString& value) {
  double_or_string_member_ = value;
}
bool TestDictionary::hasDoubleOrStringSequenceMember() const {
  return has_double_or_string_sequence_member_;
}
const HeapVector<DoubleOrString>& TestDictionary::doubleOrStringSequenceMember() const {
  DCHECK(has_double_or_string_sequence_member_);
  return double_or_string_sequence_member_;
}
void TestDictionary::setDoubleOrStringSequenceMember(const HeapVector<DoubleOrString>& value) {
  double_or_string_sequence_member_ = value;
  has_double_or_string_sequence_member_ = true;
}
bool TestDictionary::hasElementOrNullMember() const {
  return element_or_null_member_;
}
Element* TestDictionary::elementOrNullMember() const {
  return element_or_null_member_;
}
void TestDictionary::setElementOrNullMember(Element* value) {
  element_or_null_member_ = value;
}
void TestDictionary::setElementOrNullMemberToNull() {
  element_or_null_member_ = Member<Element>();
}
bool TestDictionary::hasEnumMember() const {
  return !enum_member_.IsNull();
}
const String& TestDictionary::enumMember() const {
  return enum_member_;
}
void TestDictionary::setEnumMember(const String& value) {
  enum_member_ = value;
}
bool TestDictionary::hasEnumSequenceMember() const {
  return has_enum_sequence_member_;
}
const Vector<String>& TestDictionary::enumSequenceMember() const {
  DCHECK(has_enum_sequence_member_);
  return enum_sequence_member_;
}
void TestDictionary::setEnumSequenceMember(const Vector<String>& value) {
  enum_sequence_member_ = value;
  has_enum_sequence_member_ = true;
}
bool TestDictionary::hasEventTargetMember() const {
  return event_target_member_;
}
EventTarget* TestDictionary::eventTargetMember() const {
  return event_target_member_;
}
void TestDictionary::setEventTargetMember(EventTarget* value) {
  event_target_member_ = value;
}
bool TestDictionary::hasGarbageCollectedRecordMember() const {
  return has_garbage_collected_record_member_;
}
const HeapVector<std::pair<String, Member<TestObject>>>& TestDictionary::garbageCollectedRecordMember() const {
  DCHECK(has_garbage_collected_record_member_);
  return garbage_collected_record_member_;
}
void TestDictionary::setGarbageCollectedRecordMember(const HeapVector<std::pair<String, Member<TestObject>>>& value) {
  garbage_collected_record_member_ = value;
  has_garbage_collected_record_member_ = true;
}
bool TestDictionary::hasInternalDictionarySequenceMember() const {
  return has_internal_dictionary_sequence_member_;
}
const HeapVector<InternalDictionary>& TestDictionary::internalDictionarySequenceMember() const {
  DCHECK(has_internal_dictionary_sequence_member_);
  return internal_dictionary_sequence_member_;
}
void TestDictionary::setInternalDictionarySequenceMember(const HeapVector<InternalDictionary>& value) {
  internal_dictionary_sequence_member_ = value;
  has_internal_dictionary_sequence_member_ = true;
}
bool TestDictionary::hasIsPublic() const {
  return has_is_public_;
}
bool TestDictionary::isPublic() const {
  DCHECK(has_is_public_);
  return is_public_;
}
void TestDictionary::setIsPublic(bool value) {
  is_public_ = value;
  has_is_public_ = true;
}
bool TestDictionary::hasLongMember() const {
  return has_long_member_;
}
int32_t TestDictionary::longMember() const {
  DCHECK(has_long_member_);
  return long_member_;
}
void TestDictionary::setLongMember(int32_t value) {
  long_member_ = value;
  has_long_member_ = true;
}
bool TestDictionary::hasObjectMember() const {
  return !(object_member_.IsEmpty() || object_member_.IsNull() || object_member_.IsUndefined());
}
ScriptValue TestDictionary::objectMember() const {
  return object_member_;
}
void TestDictionary::setObjectMember(ScriptValue value) {
  object_member_ = value;
}
bool TestDictionary::hasObjectOrNullMember() const {
  return !(object_or_null_member_.IsEmpty() || object_or_null_member_.IsNull() || object_or_null_member_.IsUndefined());
}
ScriptValue TestDictionary::objectOrNullMember() const {
  return object_or_null_member_;
}
void TestDictionary::setObjectOrNullMember(ScriptValue value) {
  object_or_null_member_ = value;
}
void TestDictionary::setObjectOrNullMemberToNull() {
  object_or_null_member_ = ScriptValue();
}
bool TestDictionary::hasOtherDoubleOrStringMember() const {
  return !other_double_or_string_member_.isNull();
}
const DoubleOrString& TestDictionary::otherDoubleOrStringMember() const {
  return other_double_or_string_member_;
}
void TestDictionary::setOtherDoubleOrStringMember(const DoubleOrString& value) {
  other_double_or_string_member_ = value;
}
bool TestDictionary::hasPrefixGetMember() const {
  return !(prefix_get_member_.IsEmpty() || prefix_get_member_.IsNull() || prefix_get_member_.IsUndefined());
}
ScriptValue TestDictionary::getPrefixGetMember() const {
  return prefix_get_member_;
}
void TestDictionary::setPrefixGetMember(ScriptValue value) {
  prefix_get_member_ = value;
}
bool TestDictionary::hasRecordMember() const {
  return has_record_member_;
}
const Vector<std::pair<String, int8_t>>& TestDictionary::recordMember() const {
  DCHECK(has_record_member_);
  return record_member_;
}
void TestDictionary::setRecordMember(const Vector<std::pair<String, int8_t>>& value) {
  record_member_ = value;
  has_record_member_ = true;
}
bool TestDictionary::hasRestrictedDoubleMember() const {
  return has_restricted_double_member_;
}
double TestDictionary::restrictedDoubleMember() const {
  DCHECK(has_restricted_double_member_);
  return restricted_double_member_;
}
void TestDictionary::setRestrictedDoubleMember(double value) {
  restricted_double_member_ = value;
  has_restricted_double_member_ = true;
}
bool TestDictionary::hasRuntimeMember() const {
  return has_runtime_member_;
}
bool TestDictionary::runtimeMember() const {
  DCHECK(has_runtime_member_);
  return runtime_member_;
}
void TestDictionary::setRuntimeMember(bool value) {
  runtime_member_ = value;
  has_runtime_member_ = true;
}
bool TestDictionary::hasStringMember() const {
  return !string_member_.IsNull();
}
const String& TestDictionary::stringMember() const {
  return string_member_;
}
void TestDictionary::setStringMember(const String& value) {
  string_member_ = value;
}
bool TestDictionary::hasStringOrNullMember() const {
  return !string_or_null_member_.IsNull();
}
const String& TestDictionary::stringOrNullMember() const {
  return string_or_null_member_;
}
void TestDictionary::setStringOrNullMember(const String& value) {
  string_or_null_member_ = value;
}
void TestDictionary::setStringOrNullMemberToNull() {
  string_or_null_member_ = String();
}
bool TestDictionary::hasStringSequenceMember() const {
  return has_string_sequence_member_;
}
const Vector<String>& TestDictionary::stringSequenceMember() const {
  DCHECK(has_string_sequence_member_);
  return string_sequence_member_;
}
void TestDictionary::setStringSequenceMember(const Vector<String>& value) {
  string_sequence_member_ = value;
  has_string_sequence_member_ = true;
}
bool TestDictionary::hasTestInterface2OrUint8ArrayMember() const {
  return !test_interface_2_or_uint8_array_member_.isNull();
}
const TestInterface2OrUint8Array& TestDictionary::testInterface2OrUint8ArrayMember() const {
  return test_interface_2_or_uint8_array_member_;
}
void TestDictionary::setTestInterface2OrUint8ArrayMember(const TestInterface2OrUint8Array& value) {
  test_interface_2_or_uint8_array_member_ = value;
}
bool TestDictionary::hasTestInterfaceGarbageCollectedMember() const {
  return test_interface_garbage_collected_member_;
}
TestInterfaceGarbageCollected* TestDictionary::testInterfaceGarbageCollectedMember() const {
  return test_interface_garbage_collected_member_;
}
void TestDictionary::setTestInterfaceGarbageCollectedMember(TestInterfaceGarbageCollected* value) {
  test_interface_garbage_collected_member_ = value;
}
bool TestDictionary::hasTestInterfaceGarbageCollectedOrNullMember() const {
  return test_interface_garbage_collected_or_null_member_;
}
TestInterfaceGarbageCollected* TestDictionary::testInterfaceGarbageCollectedOrNullMember() const {
  return test_interface_garbage_collected_or_null_member_;
}
void TestDictionary::setTestInterfaceGarbageCollectedOrNullMember(TestInterfaceGarbageCollected* value) {
  test_interface_garbage_collected_or_null_member_ = value;
}
void TestDictionary::setTestInterfaceGarbageCollectedOrNullMemberToNull() {
  test_interface_garbage_collected_or_null_member_ = Member<TestInterfaceGarbageCollected>();
}
bool TestDictionary::hasTestInterfaceGarbageCollectedSequenceMember() const {
  return has_test_interface_garbage_collected_sequence_member_;
}
const HeapVector<Member<TestInterfaceGarbageCollected>>& TestDictionary::testInterfaceGarbageCollectedSequenceMember() const {
  DCHECK(has_test_interface_garbage_collected_sequence_member_);
  return test_interface_garbage_collected_sequence_member_;
}
void TestDictionary::setTestInterfaceGarbageCollectedSequenceMember(const HeapVector<Member<TestInterfaceGarbageCollected>>& value) {
  test_interface_garbage_collected_sequence_member_ = value;
  has_test_interface_garbage_collected_sequence_member_ = true;
}
bool TestDictionary::hasTestInterfaceMember() const {
  return test_interface_member_;
}
TestInterfaceImplementation* TestDictionary::testInterfaceMember() const {
  return test_interface_member_;
}
void TestDictionary::setTestInterfaceMember(TestInterfaceImplementation* value) {
  test_interface_member_ = value;
}
bool TestDictionary::hasTestInterfaceOrNullMember() const {
  return test_interface_or_null_member_;
}
TestInterfaceImplementation* TestDictionary::testInterfaceOrNullMember() const {
  return test_interface_or_null_member_;
}
void TestDictionary::setTestInterfaceOrNullMember(TestInterfaceImplementation* value) {
  test_interface_or_null_member_ = value;
}
void TestDictionary::setTestInterfaceOrNullMemberToNull() {
  test_interface_or_null_member_ = Member<TestInterfaceImplementation>();
}
bool TestDictionary::hasTestInterfaceSequenceMember() const {
  return has_test_interface_sequence_member_;
}
const HeapVector<Member<TestInterfaceImplementation>>& TestDictionary::testInterfaceSequenceMember() const {
  DCHECK(has_test_interface_sequence_member_);
  return test_interface_sequence_member_;
}
void TestDictionary::setTestInterfaceSequenceMember(const HeapVector<Member<TestInterfaceImplementation>>& value) {
  test_interface_sequence_member_ = value;
  has_test_interface_sequence_member_ = true;
}
bool TestDictionary::hasTestObjectSequenceMember() const {
  return has_test_object_sequence_member_;
}
const HeapVector<Member<TestObject>>& TestDictionary::testObjectSequenceMember() const {
  DCHECK(has_test_object_sequence_member_);
  return test_object_sequence_member_;
}
void TestDictionary::setTestObjectSequenceMember(const HeapVector<Member<TestObject>>& value) {
  test_object_sequence_member_ = value;
  has_test_object_sequence_member_ = true;
}
bool TestDictionary::hasUint8ArrayMember() const {
  return uint8_array_member_;
}
NotShared<DOMUint8Array> TestDictionary::uint8ArrayMember() const {
  return uint8_array_member_;
}
void TestDictionary::setUint8ArrayMember(NotShared<DOMUint8Array> value) {
  uint8_array_member_ = value.View();
}
bool TestDictionary::hasUnionInRecordMember() const {
  return has_union_in_record_member_;
}
const HeapVector<std::pair<String, LongOrBoolean>>& TestDictionary::unionInRecordMember() const {
  DCHECK(has_union_in_record_member_);
  return union_in_record_member_;
}
void TestDictionary::setUnionInRecordMember(const HeapVector<std::pair<String, LongOrBoolean>>& value) {
  union_in_record_member_ = value;
  has_union_in_record_member_ = true;
}
bool TestDictionary::hasUnionWithTypedefs() const {
  return !union_with_typedefs_.isNull();
}
const FloatOrBoolean& TestDictionary::unionWithTypedefs() const {
  return union_with_typedefs_;
}
void TestDictionary::setUnionWithTypedefs(const FloatOrBoolean& value) {
  union_with_typedefs_ = value;
}
bool TestDictionary::hasUnrestrictedDoubleMember() const {
  return has_unrestricted_double_member_;
}
double TestDictionary::unrestrictedDoubleMember() const {
  DCHECK(has_unrestricted_double_member_);
  return unrestricted_double_member_;
}
void TestDictionary::setUnrestrictedDoubleMember(double value) {
  unrestricted_double_member_ = value;
  has_unrestricted_double_member_ = true;
}

DEFINE_TRACE(TestDictionary) {
  visitor->Trace(double_or_string_member_);
  visitor->Trace(double_or_string_sequence_member_);
  visitor->Trace(element_or_null_member_);
  visitor->Trace(event_target_member_);
  visitor->Trace(garbage_collected_record_member_);
  visitor->Trace(internal_dictionary_sequence_member_);
  visitor->Trace(other_double_or_string_member_);
  visitor->Trace(test_interface_2_or_uint8_array_member_);
  visitor->Trace(test_interface_garbage_collected_member_);
  visitor->Trace(test_interface_garbage_collected_or_null_member_);
  visitor->Trace(test_interface_garbage_collected_sequence_member_);
  visitor->Trace(test_interface_member_);
  visitor->Trace(test_interface_or_null_member_);
  visitor->Trace(test_interface_sequence_member_);
  visitor->Trace(test_object_sequence_member_);
  visitor->Trace(uint8_array_member_);
  visitor->Trace(union_in_record_member_);
  visitor->Trace(union_with_typedefs_);
  IDLDictionaryBase::Trace(visitor);
}

}  // namespace blink
