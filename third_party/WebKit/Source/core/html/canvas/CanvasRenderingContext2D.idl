/*
 * Copyright (C) 2006 Apple Computer, Inc.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

enum CanvasWindingRule { "nonzero", "evenodd" };

interface CanvasRenderingContext2D {

    readonly attribute HTMLCanvasElement canvas;

    void save();
    void restore();

    [StrictTypeChecking, RuntimeEnabled=ExperimentalCanvasFeatures] attribute SVGMatrix currentTransform;
    void scale(float sx, float sy);
    void rotate(float angle);
    void translate(float tx, float ty);
    void transform(float m11, float m12, float m21, float m22, float dx, float dy);
    void setTransform(float m11, float m12, float m21, float m22, float dx, float dy);
    void resetTransform();

    attribute float globalAlpha;
    [TreatNullAs=NullString] attribute DOMString globalCompositeOperation;

    [RaisesException] CanvasGradient createLinearGradient(float x0, float y0, float x1, float y1);
    [RaisesException] CanvasGradient createRadialGradient(float x0, float y0, float r0, float x1, float y1, float r1);

    attribute float lineWidth;
    [TreatNullAs=NullString] attribute DOMString lineCap;
    [TreatNullAs=NullString] attribute DOMString lineJoin;
    attribute float miterLimit;

    attribute float shadowOffsetX;
    attribute float shadowOffsetY;
    attribute float shadowBlur;
    [TreatNullAs=NullString] attribute DOMString shadowColor;

    void setLineDash(sequence<float> dash);
    sequence<float> getLineDash();
    attribute float lineDashOffset;

    void clearRect(float x, float y, float width, float height);
    void fillRect(float x, float y, float width, float height);

    void beginPath();

    attribute Path2D currentPath;

    // FIXME: Simplify these using optional CanvasWindingRule once crbug.com/339000 gets fixed.
    void fill();
    [RuntimeEnabled=Path2D, StrictTypeChecking] void fill(Path2D path);
    [StrictTypeChecking] void fill(CanvasWindingRule winding);
    [RuntimeEnabled=Path2D, StrictTypeChecking] void fill(Path2D path, CanvasWindingRule winding);
    void stroke();
    [RuntimeEnabled=Path2D, StrictTypeChecking] void stroke(Path2D path);
    // FIXME: Simplify these using optional CanvasWindingRule once crbug.com/339000 gets fixed.
    void clip();
    [RuntimeEnabled=Path2D, StrictTypeChecking] void clip(Path2D path);
    [StrictTypeChecking] void clip(CanvasWindingRule winding);
    [RuntimeEnabled=Path2D, StrictTypeChecking] void clip(Path2D path, CanvasWindingRule winding);

    // FIXME: Simplify these using optional CanvasWindingRule once crbug.com/339000 gets fixed.
    boolean isPointInPath(float x, float y);
    [RuntimeEnabled=Path2D, StrictTypeChecking] boolean isPointInPath(Path2D path, float x, float y);
    [StrictTypeChecking] boolean isPointInPath(float x, float y, CanvasWindingRule winding);
    [RuntimeEnabled=Path2D, StrictTypeChecking] boolean isPointInPath(Path2D path, float x, float y, CanvasWindingRule winding);
    boolean isPointInStroke(float x, float y);
    [RuntimeEnabled=Path2D, StrictTypeChecking] boolean isPointInStroke(Path2D path, float x, float y);

    [RuntimeEnabled=ExperimentalCanvasFeatures] void scrollPathIntoView();
    [RuntimeEnabled=ExperimentalCanvasFeatures, StrictTypeChecking] void scrollPathIntoView(Path2D path);

    // text
    attribute DOMString font;
    attribute DOMString textAlign;
    attribute DOMString textBaseline;

    TextMetrics measureText(DOMString text);

    // Context state
    // Should be merged with WebGL counterpart in CanvasRenderingContext, once no-longer experimental
    [RuntimeEnabled=ExperimentalCanvasFeatures] boolean isContextLost();

    // other

    void setAlpha(float alpha);
    void setCompositeOperation(DOMString compositeOperation);

    void setLineWidth(float width);
    void setLineCap(DOMString cap);
    void setLineJoin(DOMString join);
    void setMiterLimit(float limit);

    void clearShadow();

    void fillText(DOMString text, float x, float y, optional float maxWidth);
    void strokeText(DOMString text, float x, float y, optional float maxWidth);

    void setStrokeColor([StrictTypeChecking] DOMString color, optional float alpha);
    void setStrokeColor(float grayLevel, optional float alpha);
    void setStrokeColor(float r, float g, float b, float a);
    void setStrokeColor(float c, float m, float y, float k, float a);

    void setFillColor([StrictTypeChecking] DOMString color, optional float alpha);
    void setFillColor(float grayLevel, optional float alpha);
    void setFillColor(float r, float g, float b, float a);
    void setFillColor(float c, float m, float y, float k, float a);

    void strokeRect(float x, float y, float width, float height);

    [RaisesException, StrictTypeChecking] void drawImage(HTMLImageElement image, float x, float y);
    [RaisesException, StrictTypeChecking] void drawImage(HTMLImageElement image, float x, float y, float width, float height);
    [RaisesException, StrictTypeChecking] void drawImage(HTMLImageElement image, float sx, float sy, float sw, float sh, float dx, float dy, float dw, float dh);
    [RaisesException, StrictTypeChecking] void drawImage(HTMLCanvasElement canvas, float x, float y);
    [RaisesException, StrictTypeChecking] void drawImage(HTMLCanvasElement canvas, float x, float y, float width, float height);
    [RaisesException, StrictTypeChecking] void drawImage(HTMLCanvasElement canvas, float sx, float sy, float sw, float sh, float dx, float dy, float dw, float dh);
    [RaisesException, StrictTypeChecking] void drawImage(HTMLVideoElement video, float x, float y);
    [RaisesException, StrictTypeChecking] void drawImage(HTMLVideoElement video, float x, float y, float width, float height);
    [RaisesException, StrictTypeChecking] void drawImage(HTMLVideoElement video, float sx, float sy, float sw, float sh, float dx, float dy, float dw, float dh);
    [RuntimeEnabled=ExperimentalCanvasFeatures, RaisesException, StrictTypeChecking] void drawImage(ImageBitmap imageBitmap, float x, float y);
    [RuntimeEnabled=ExperimentalCanvasFeatures, RaisesException, StrictTypeChecking] void drawImage(ImageBitmap imageBitmap, float x, float y, float width, float height);
    [RuntimeEnabled=ExperimentalCanvasFeatures, RaisesException, StrictTypeChecking] void drawImage(ImageBitmap imageBitmap, float sx, float sy, float sw, float sh, float dx, float dy, float dw, float dh);

    [StrictTypeChecking] void drawImageFromRect(HTMLImageElement? image,
                                                optional float sx, optional float sy, optional float sw, optional float sh,
                                                optional float dx, optional float dy, optional float dw, optional float dh,
                                                optional DOMString compositeOperation);

    void setShadow(float width, float height, float blur, [StrictTypeChecking] optional DOMString color, optional float alpha);
    void setShadow(float width, float height, float blur, float grayLevel, optional float alpha);
    void setShadow(float width, float height, float blur, float r, float g, float b, float a);
    void setShadow(float width, float height, float blur, float c, float m, float y, float k, float a);

    [RaisesException, StrictTypeChecking] void putImageData(ImageData imagedata, float dx, float dy);
    [RaisesException, StrictTypeChecking] void putImageData(ImageData imagedata, float dx, float dy, float dirtyX, float dirtyY, float dirtyWidth, float dirtyHeight);

    [RaisesException, StrictTypeChecking] CanvasPattern createPattern(HTMLCanvasElement canvas, [TreatNullAs=NullString] DOMString repetitionType);
    [RaisesException, StrictTypeChecking] CanvasPattern createPattern(HTMLImageElement image, [TreatNullAs=NullString] DOMString repetitionType);
    [RaisesException, StrictTypeChecking] CanvasPattern createPattern(HTMLVideoElement image, [TreatNullAs=NullString] DOMString repetitionType);
    [StrictTypeChecking] ImageData createImageData(ImageData imagedata);
    [RaisesException] ImageData createImageData(float sw, float sh);

    [Custom] attribute object strokeStyle;
    [Custom] attribute object fillStyle;

    // pixel manipulation
    [RaisesException] ImageData getImageData(float sx, float sy, float sw, float sh);

    // Focus rings
    [RuntimeEnabled=ExperimentalCanvasFeatures, StrictTypeChecking] void drawFocusIfNeeded(Element element);
    [RuntimeEnabled=ExperimentalCanvasFeatures, StrictTypeChecking] void drawFocusIfNeeded(Path2D path, Element element);
    [RuntimeEnabled=ExperimentalCanvasFeatures, StrictTypeChecking] boolean drawCustomFocusRing(Element element);

    [ImplementedAs=imageSmoothingEnabled, MeasureAs=PrefixedImageSmoothingEnabled] attribute boolean webkitImageSmoothingEnabled;
    [MeasureAs=UnprefixedImageSmoothingEnabled] attribute boolean imageSmoothingEnabled;

    Canvas2DContextAttributes getContextAttributes();
};

CanvasRenderingContext2D implements CanvasPathMethods;
