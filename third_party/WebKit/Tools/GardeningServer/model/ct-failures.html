<!--
Copyright 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="../lib/net.html">
<link rel="import" href="../lib/update-util.html">
<link rel="import" href="ct-builder-revisions.html">
<link rel="import" href="ct-failure.html">
<link rel="import" href="ct-failure-group.html">
<link rel="import" href="ct-commit-list.html">

<script>
function CTFailures(commitLog) {
  this.commitLog = commitLog;
  this.builderLatestRevisions = null;
  // Maps a tree id to an array of CTFailureGroups within that tree.
  this.failures = {};
  this.lastUpdateDate = null;

  // FIXME: Get this from
  // https://chromium.googlesource.com/chromium/tools/build/+/master/scripts/slave/gatekeeper_trees.json?format=text.
  this._trees = {
    blink: [
      "https://build.chromium.org/p/chromium.webkit",
    ],
    chromium: [
      "https://build.chromium.org/p/chromium",
      "https://build.chromium.org/p/chromium.chrome",
      "https://build.chromium.org/p/chromium.chromiumos",
      "https://build.chromium.org/p/chromium.gpu",
      "https://build.chromium.org/p/chromium.linux",
      "https://build.chromium.org/p/chromium.mac",
      "https://build.chromium.org/p/chromium.memory",
      "https://build.chromium.org/p/chromium.win"
    ],
  };
}

// Reverse sorting order, if a > b, return a negative number.
CTFailures.prototype._failureByTreeListComparator = function(tree, a, b) {
  if (tree === undefined)
    tree = 'chromium';

  var rev_a = a.commitList.revisions;
  var rev_b = b.commitList.revisions;

  if (!rev_a || !Object.keys(rev_a).length) {
    if (!rev_b || !Object.keys(rev_b).length)
      return 0;
    return 1;
  } else if (!rev_b || !Object.keys(rev_b).length) {
    return -1;
  }

  // Prioritize the tree's revision, if they are unequal (else, fallback below)
  if (rev_a[tree] && rev_b[tree] &&
      rev_a[tree].last() != rev_b[tree].last()) {
    return rev_b[tree].last() - rev_a[tree].last();
  }

  // Compare other revisions in alphabetical order.
  var keys = Object.keys(rev_a).sort();
  for (var i = 0; i < keys.length; i++) {
    if (keys[i] == tree)  // Already taken care of, above.
      continue;

    var a_list = rev_a[keys[i]];
    var b_list = rev_b[keys[i]];
    if (!b_list)
      return -1;

    if (a_list.last() != b_list.last())
      return b_list.last() - a_list.last();
  }
  return 0;
};

CTFailures.prototype.update = function() {
  var annotationPromise = CTFailureGroup.fetchAnnotations();

  return net.json('http://sheriff-o-matic.appspot.com/alerts').then(function(data) {
    return annotationPromise.then(function(annotations) {
      // FIXME: Don't special-case the blink master.
      this.builderLatestRevisions = new CTBuilderRevisions(data.latest_builder_info['chromium.webkit']);
      var newFailures = {};
      this.lastUpdateDate = new Date(data.date * 1000);
      // Update |failures| with the appropriate CTFailureGroup's for each
      // tree.
      data.range_groups.forEach(function(rangeGroup) {
        this._processFailuresForRangeGroup(newFailures, rangeGroup, data.alerts, annotations);
      }.bind(this));
      // Sort failure groups so that newer failures are shown at the top
      // of the UI.
      Object.keys(newFailures, function (tree, failuresByTree) {
        failuresByTree.sort(this._failureByTreeListComparator.bind(this, tree));
      }.bind(this));
      this.failures = updateUtil.updateLeft(this.failures, newFailures);
    }.bind(this));
  }.bind(this));
};

CTFailures.prototype._failureComparator = function(a, b) {
  if (a.step > b.step)
    return 1;
  if (a.step < b.step)
    return -1
  if (a.testName > b.testName)
    return 1;
  if (a.testName < b.testName)
    return -1
  return 0;
};

CTFailures.prototype._processFailuresForRangeGroup = function(newFailures, rangeGroup, alerts, annotations) {
  var masterToTree = {};
  Object.keys(this._trees, function(tree, masters) {
    masters.forEach(function(master) {
      masterToTree[master] = tree;
    });
  });

  // A rangeGroup may be related to multiple alerts (via |failure_keys|). Categorize
  // these failures by reason (cause of failure), so that they can be grouped in the UI
  // (via a CTFailureGroup). Failures will be grouped in |failuresByReason|.
  var failuresByReason = {};
  rangeGroup.failure_keys.forEach(function(failure_key) {
    var failure = alerts.find(function(item) { return item.key == failure_key; });
    // Establish the key to uniquely identify a failure by reason.
    var reason, failureType;
    if (failure.reason) {
      // FIXME: Store the actual failure type in a different field instead of smashing it into the reason.
      var parts = failure.reason.split(':');
      reason = parts[0];
      failureType = parts[1] || 'FAIL';
    } else {
      reason = null;
      failureType = 'UNKNOWN';
    }

    var failureKey = CTFailure.createKey(failure);

    var reasonKey = JSON.stringify({
      step: failure.step_name,
      reason: reason,
    });

    // FIXME: Figure out what tree masters that aren't in masterToTree
    // we should have.
    var tree = masterToTree[failure.master_url];

    // FIXME: Use a model class instead of a dumb object.
    if (!failuresByReason[reasonKey])
      failuresByReason[reasonKey] = {};
    if (!failuresByReason[reasonKey][tree])
      failuresByReason[reasonKey][tree] = {};
    failuresByReason[reasonKey][tree][failure.builder_name] = {
      key: failureKey,
      // FIXME: Rename to failureType.
      actual: failureType,
      lastFailingBuild: failure.last_failing_build,
      earliestFailingBuild: failure.failing_build,
      masterUrl: failure.master_url,
      failingBuildCount: failure.failing_build_count,
      annotation: annotations[failureKey],
    };
  }.bind(this));

  if (!Object.keys(failuresByReason).length)
    return;

  // Maps a tree id to a list of CTFailures in that tree.
  var groupedFailures = {};
  Object.keys(failuresByReason, function(reasonKey, resultsByTree) {
    var failure = JSON.parse(reasonKey);
    Object.keys(resultsByTree, function(tree, resultsByBuilder) {
      if (!groupedFailures[tree])
        groupedFailures[tree] = [];
      groupedFailures[tree].push(
          new CTFailure(failure.step, failure.reason, resultsByBuilder));
    })
  });

  Object.keys(groupedFailures, function(tree, failures) {
    failures.sort(this._failureComparator);

    if (!newFailures[tree])
      newFailures[tree] = [];
    var commitList = new CTCommitList(this.commitLog, rangeGroup.likely_revisions);
    newFailures[tree].push(new CTFailureGroup(rangeGroup.sort_key, failures, commitList));
  }.bind(this));
};

</script>
