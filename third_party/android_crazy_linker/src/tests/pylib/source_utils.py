# Copyright 2018 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Common utility functions to generate C++ source fragments."""

_AUTO_GENERATED_HEADER_BEGIN_TEMPLATE = (
r'''// Copyright 2018 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef {guard_macro_name}
#define {guard_macro_name}

// clang-format off
// BEGIN_AUTO_GENERATED [{script_name}] DO NOT EDIT!!
//

namespace crazy {{
namespace testing {{

''')

_AUTO_GENERATED_HEADER_END_TEMPLATE = (
r'''
}}  // namespace testing
}}  // namespace crazy

// END_AUTO_GENERATED_CODE [{script_name}]
// clang-format on

#endif  // {guard_macro_name}'''
)

def CSourceForIntegerHexArray(values, num_bits, margin=4, width=80):
  """Turn an array of integers into a C source array data definition.

  Args:
    values: An array of integers.
    num_bits: The number of bits of said integers (i.e. 8, 16, 32 or 64).
    margin: Left-side margin / indentation level (must be > 0).
    width: Maximum line width.
  Returns:
    A string containing the data definition as a C source fragment.
  """
  chars_per_word = num_bits / 4
  # Account for 0x prefix + one space + one comma
  max_items_per_line = (width - margin - 2) / (4 + chars_per_word)
  line_start = ' ' * (margin - 1)
  slen = len(values)
  n = 0
  format_str = ' 0x%%0%dx,' % chars_per_word
  out = ''
  while n < slen:
    out += line_start
    n2 = min(n + max_items_per_line, slen)
    while n < n2:
      out += format_str % values[n]
      n += 1
    out += '\n';
  return out


def CSourceForConstCharArray(chars, variable_name, margin=4, width=80):
  """Return C source fragment for static const char C array.

  Args:
    chars: An array or string containing all the characters for array.
    variable_name: Name of the array variable.
  Returns:
    A new string holding a C source fragment for the array definition.
  """
  slen = len(chars)
  out = 'static const char %s[%d] = {\n' % (variable_name, slen)
  line_start = ' ' * margin
  # Allow for margin + 4 spaces on the right.
  max_width = width - margin - 4
  rpos = 0
  wpos = margin + 1
  while rpos < slen:
    out += line_start
    wpos = 0
    comma = ''
    while rpos < slen and wpos < max_width:
      ch = chars[rpos]
      code = ord(ch)
      if code < 32 or code > 127:
        ch = "'\\%d'" % code
      else:
        ch = "'%s'" % ch
      ch = comma + ch
      if wpos + len(ch) > max_width: # Too long, break line before this char.
        break
      out += ch
      rpos += 1
      wpos += len(ch)
      comma = ','
    if rpos == slen:
      break
    out += ',\n'

  out += '};\n'
  return out


def CSourceForComments(lines):
  """Wrap the content of |lines| instead into C++ comments."""
  out = ''
  for line in lines.split('\n'):
    out += '// %s\n' % line
  return out


def CSourceBeginAutoGeneratedHeader(script_name, guard_macro_name):
  return _AUTO_GENERATED_HEADER_BEGIN_TEMPLATE.format(
      script_name=script_name,
      guard_macro_name=guard_macro_name)

def CSourceEndAutoGeneratedHeader(script_name, guard_macro_name):
  return _AUTO_GENERATED_HEADER_END_TEMPLATE.format(
      script_name=script_name,
      guard_macro_name=guard_macro_name)
