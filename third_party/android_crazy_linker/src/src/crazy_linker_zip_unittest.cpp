// Copyright 2018 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "crazy_linker_zip.h"

#include "crazy_linker_system_mock.h"

#include "crazy_linker_util.h"  // FOR CRAZY_OFFSET_FAILED?

#include <gtest/gtest.h>

namespace {

// START OF AUTO-GENERATED SECTION - DO NOT EDIT
// This section was generated by generate_zip_test_tables.sh

// An empty zip archive
unsigned char empty_archive_zip[] = {
    0x50, 0x4b, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned int empty_archive_zip_len = 22;

// A zip archive with a single file named 'hello_world.txt' that
// contains the bytes for 'Hello World Hello World\n' without
// compression.
unsigned char hello_zip[] = {
    0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x75,
    0x49, 0x4c, 0xfd, 0x95, 0x3b, 0x3f, 0x18, 0x00, 0x00, 0x00, 0x18, 0x00,
    0x00, 0x00, 0x0f, 0x00, 0x1c, 0x00, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x5f,
    0x77, 0x6f, 0x72, 0x6c, 0x64, 0x2e, 0x74, 0x78, 0x74, 0x55, 0x54, 0x09,
    0x00, 0x03, 0xd6, 0xa4, 0x7d, 0x5a, 0xd6, 0xa4, 0x7d, 0x5a, 0x75, 0x78,
    0x0b, 0x00, 0x01, 0x04, 0xab, 0x6f, 0x00, 0x00, 0x04, 0x88, 0x13, 0x00,
    0x00, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64,
    0x20, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64,
    0x0a, 0x50, 0x4b, 0x01, 0x02, 0x1e, 0x03, 0x0a, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x13, 0x75, 0x49, 0x4c, 0xfd, 0x95, 0x3b, 0x3f, 0x18, 0x00, 0x00,
    0x00, 0x18, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x81, 0x00, 0x00, 0x00, 0x00, 0x68,
    0x65, 0x6c, 0x6c, 0x6f, 0x5f, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x2e, 0x74,
    0x78, 0x74, 0x55, 0x54, 0x05, 0x00, 0x03, 0xd6, 0xa4, 0x7d, 0x5a, 0x75,
    0x78, 0x0b, 0x00, 0x01, 0x04, 0xab, 0x6f, 0x00, 0x00, 0x04, 0x88, 0x13,
    0x00, 0x00, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
    0x01, 0x00, 0x55, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned int hello_zip_len = 204;

// The same zip archive, but with the file stored compressed.
unsigned char hello_compressed_zip[] = {
    0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x02, 0x00, 0x08, 0x00, 0x13, 0x75,
    0x49, 0x4c, 0xfd, 0x95, 0x3b, 0x3f, 0x11, 0x00, 0x00, 0x00, 0x18, 0x00,
    0x00, 0x00, 0x0f, 0x00, 0x1c, 0x00, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x5f,
    0x77, 0x6f, 0x72, 0x6c, 0x64, 0x2e, 0x74, 0x78, 0x74, 0x55, 0x54, 0x09,
    0x00, 0x03, 0xd6, 0xa4, 0x7d, 0x5a, 0xd6, 0xa4, 0x7d, 0x5a, 0x75, 0x78,
    0x0b, 0x00, 0x01, 0x04, 0xab, 0x6f, 0x00, 0x00, 0x04, 0x88, 0x13, 0x00,
    0x00, 0xf3, 0x48, 0xcd, 0xc9, 0xc9, 0x57, 0x08, 0xcf, 0x2f, 0xca, 0x49,
    0x51, 0xf0, 0x40, 0xb0, 0xb9, 0x00, 0x50, 0x4b, 0x01, 0x02, 0x1e, 0x03,
    0x14, 0x00, 0x02, 0x00, 0x08, 0x00, 0x13, 0x75, 0x49, 0x4c, 0xfd, 0x95,
    0x3b, 0x3f, 0x11, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x0f, 0x00,
    0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xa0, 0x81,
    0x00, 0x00, 0x00, 0x00, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x5f, 0x77, 0x6f,
    0x72, 0x6c, 0x64, 0x2e, 0x74, 0x78, 0x74, 0x55, 0x54, 0x05, 0x00, 0x03,
    0xd6, 0xa4, 0x7d, 0x5a, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xab, 0x6f,
    0x00, 0x00, 0x04, 0x88, 0x13, 0x00, 0x00, 0x50, 0x4b, 0x05, 0x06, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x55, 0x00, 0x00, 0x00, 0x5a,
    0x00, 0x00, 0x00, 0x00, 0x00};
unsigned int hello_compressed_zip_len = 197;

// END OF AUTO-GENERATED SECTION

// Convenience function to add a file to the mock filesystem from the
// data tables above.
void AddZipArchiveBytes(crazy::SystemMock* sys,
                        const char* file_name,
                        const unsigned char* data,
                        unsigned int data_size) {
  sys->AddRegularFile(file_name, reinterpret_cast<const char*>(data),
                      static_cast<size_t>(data_size));
}

}  // namespace

namespace crazy {

TEST(ZipParser, EmptyFile) {
  SystemMock sys;
  static const char kFilePath[] = "empty-file";
  sys.AddRegularFile(kFilePath, "", 0);

  EXPECT_EQ(CRAZY_OFFSET_FAILED,
            FindStartOffsetOfFileInZipFile(kFilePath, "hello"));
}

TEST(ZipParser, EmptyArchive) {
  SystemMock sys;
  static const char kFilePath[] = "empty.zip";
  AddZipArchiveBytes(&sys, kFilePath, empty_archive_zip, empty_archive_zip_len);

  EXPECT_EQ(CRAZY_OFFSET_FAILED,
            FindStartOffsetOfFileInZipFile(kFilePath, "hello"));
}

TEST(ZipParse, SimpleArchive) {
  SystemMock sys;
  static const char kFilePath[] = "hello.zip";
  AddZipArchiveBytes(&sys, kFilePath, hello_zip, hello_zip_len);

  EXPECT_EQ(CRAZY_OFFSET_FAILED,
            FindStartOffsetOfFileInZipFile(kFilePath, "hello"));

  int off = FindStartOffsetOfFileInZipFile(kFilePath, "hello_world.txt");
  EXPECT_GT(off, 0);
  EXPECT_LT(off, static_cast<int>(hello_zip_len));

  static const char kExpected[] = "Hello World Hello World\n";
  const size_t kExpectedSize = sizeof(kExpected) - 1;

  ASSERT_LT(kExpectedSize, static_cast<size_t>(hello_zip_len));
  EXPECT_LT(off, static_cast<int>(hello_zip_len - kExpectedSize));
}

TEST(ZipParse, SimpleArchiveWithCompressedFile) {
  SystemMock sys;
  static const char kFilePath[] = "hello.zip";
  AddZipArchiveBytes(&sys, kFilePath, hello_compressed_zip,
                     hello_compressed_zip_len);

  EXPECT_EQ(CRAZY_OFFSET_FAILED,
            FindStartOffsetOfFileInZipFile(kFilePath, "hello_world.txt"));
}

}  // namespace crazy
