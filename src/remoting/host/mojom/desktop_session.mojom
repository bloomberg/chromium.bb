// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module remoting.mojom;

import "mojo/public/mojom/base/byte_string.mojom";
import "remoting/host/mojom/webrtc_types.mojom";
import "remoting/host/mojom/wrapped_primitives.mojom";
import "ui/gfx/geometry/mojom/geometry.mojom";

// Contains clipboard event data.
// This struct mirrors the remoting::protocol::ClipboardEvents protobuf struct.
struct ClipboardEvent {
  // The MIME type of |data|.
  string mime_type;

  // The clipboard data. The original protobuf type is string but we use a
  // ByteString because that is the preferred mojom type.
  mojo_base.mojom.ByteString data;
};

// Contains the data needed to inject a keyboard key event.
// This struct mirrors the remoting::protocol::KeyEvent protobuf struct.
struct KeyEvent {
  // True for key press events, and false for key release.
  bool pressed;

  // The USB key code.
  // The upper 16-bits are the USB Page (0x07 for key events).
  // The lower 16-bits are the USB Usage ID (which identifies the actual key).
  uint32 usb_keycode;

  // Legacy keyboard lock states. Prefer the discrete entries below.
  // Flags defined in remoting::protocol::KeyEvent::LockStates.
  uint32 lock_states;

  // Keyboard lock states. The field should be specified only if the state can
  // be reliably determined by the client. E.g., OS X does not have num lock, so
  // only caps_lock should be provided by a client running on OS X.
  Bool? caps_lock_state;
  Bool? num_lock_state;
};

// This enum mirrors the remoting::protocol::MouseEvent::MouseButton enum.
enum MouseButton {
  kUndefined = 0,
  kLeft = 1,
  kMiddle = 2,
  kRight = 3,
  kBack = 4,
  kForward = 5,
};

// Contains the data needed to inject a mouse event.
// This struct mirrors the remoting::protocol::MouseEvent protobuf struct.
struct MouseEvent {
  // Mouse absolute position information. When using WebRTC-based protocol the
  // coordinates are in DIPs. Otherwise they are in host's physical pixels. In
  // both coordinates systems, the top-left monitor on the system always starts
  // from (0, 0).
  Int32? x;
  Int32? y;

  // Mouse button event.
  MouseButton button;
  // |button_down| is not set when |button| is kUndefined.
  Bool? button_down;

  // Mouse wheel information.
  // These values encode the number of pixels and 'ticks' of movement that
  // would result from the wheel event on the client system.
  Float? wheel_delta_x;
  Float? wheel_delta_y;
  Float? wheel_ticks_x;
  Float? wheel_ticks_y;

  // Mouse movement information. Provided only when mouse lock is engaged.
  Int32? delta_x;
  Int32? delta_y;
};

// Text input event for input method different from physical keyboards,
// including software keyboard, gesture typing, voice input, etc.
// This struct mirrors the remoting::protocol::TextEvent protobuf struct.
struct TextEvent {
  // Unicode sequence for the event in UTF-8.
  string text;
};

// Describes the attributes for a single touch point, used in TouchEvent to
// describe a touch gesture.
// This struct mirrors the remoting::protocol::TouchEventPoint protobuf struct.
struct TouchEventPoint {
  // The ID for the touch point.
  uint32 id;

  // The absolute position of the touch point. These values on-the-wire are host
  // physical pixel coordinates: the top-left monitor on the system always
  // starts from (0, 0).
  gfx.mojom.PointF position;

  // The size of the touch point, used to aid hit-testing.
  // Scaled to match the size on host.
  gfx.mojom.PointF radius;

  // Angle in degrees from the y-axis of the touch point.
  float angle;

  // The pressure of the touch point.
  // The value should be in [0.0, 1.0].
  float pressure;
};

// This enum mirrors the remoting::protocol::TouchEvent::TouchEventType enum.
enum TouchEventType {
  kUndefined = 0,
  kStart = 1,
  kMove = 2,
  kEnd = 3,
  kCancel = 4,
};

// Describes a touch gesture event (start, stop, move) along with the set of
// touch points to include in the gesture.
struct TouchEvent {
  // The event type.
  TouchEventType event_type;

  // Only the changed touch points are added to this field.
  array<TouchEventPoint> touch_points;
};

// The state of the URL forwarder setup.
enum UrlForwarderState {
  kUnknown = 0,

  // The URL forwarder has been set up properly.
  kSetUp = 1,

  // The URL forwarder has not been set up.
  kNotSetUp = 2,

  // We have attempted to set up the URL forwarder but it failed.
  kFailed = 3,

  // The URL forwarder is being set up but it requires user intervention.
  kSetupPendingUserIntervention = 4,
};

// Allows the desktop process to request that the daemon process perform an
// action on its behalf. Though both processes are high-privilege, the daemon
// process brokers the IPC channel between the desktop and network processes and
// owns the lifetime of the network process. It also has the ability to execute
// actions from session 0 (whereas the desktop process runs in a user session)
// on Windows.
// The remote for this interface is owned in the high-privilege desktop
// integration process and the receiver is bound in the high-privilege daemon
// process.
interface DesktopSessionRequestHandler {
  // Ask the daemon process to forward the |desktop_pipe| handle to the network
  // process in order to establish an IPC connection between the desktop and
  // network processes.
  ConnectDesktopChannel(handle<message_pipe> desktop_pipe);

  // Ask the daemon process to inject the secure attention sequence for the
  // remoted session.
  InjectSecureAttentionSequence();

  // Ask the daemon process to crash the network process. The desktop process
  // will request this when it receives invalid IPC requests or messages from
  // the network process.
  CrashNetworkProcess();
};

// Allows the network process to ask the daemon process to create, update, or
// destroy the current desktop session.
// The remote for this interface is owned in the low-privilege network process
// and the receiver is bound in the high-privilege daemon process.
interface DesktopSessionManager {
  // Creates a chromoting desktop environment for the session identified by
  // |terminal_id|. This is done by injecting a desktop agent process and
  // establishing IPC channels between the daemon, desktop, and network
  // processes.
  CreateDesktopSession(int32 terminal_id, ScreenResolution screen_resolution,
                       bool is_virtual_terminal);

  // Closes the desktop session identified by |terminal_id|. This involves
  // terminating the desktop agent process and removing any references to the
  // session being closed in the daemon and network processes. Not changes are
  // made at an OS level, meaning the user can reconnect to the same session
  // without a loss of state.
  CloseDesktopSession(int32 terminal_id);

  // Sends the updated screen resolution to the desktop agent running in the
  // |terminal_id| session.
  SetScreenResolution(int32 terminal_id, ScreenResolution screen_resolution);
};

// A set of options used to customize the desktop session behavior.
struct DesktopEnvironmentOptions {
  // True if the curtain mode should be enabled.
  bool enable_curtaining;

  // True if a user-interactive windows should be displayed on the desktop.
  bool enable_user_interface;

  // True if a notification should be shown when a remote user is connected.
  bool enable_notifications;

  // True if the session should be terminated when local input is detected.
  bool terminate_upon_input;

  // True if this host has file transfer enabled.
  bool enable_file_transfer;

  // True if this host has the remote open URL feature enabled.
  bool enable_remote_open_url;

  // True if this host has the remote WebAuthn feature enabled.
  bool enable_remote_webauthn;

  // If set, this value is used to constrain the amount of data that can be
  // transferred using ClipboardEvents. A value of 0 will effectively disable
  // clipboard sharing.
  UInt32? clipboard_size;

  // The DesktopCaptureOptions to initialize DesktopCapturer.
  DesktopCaptureOptions desktop_capture_options;
};

// Describes a screen's dimensions and DPI.
struct ScreenResolution {
  // Dimensions of the screen in pixels.
  DesktopSize dimensions;

  // The vertical and horizontal DPI of the screen.
  DesktopVector dpi;
};

// Starts the agent in the desktop session and returns an interface to allow the
// caller to inject input events and control A/V capture.
// The remote for this interface is owned in the low-privilege network process
// and the receiver is bound in the high-privilege desktop integration process.
interface DesktopSessionAgent {
  // Passes the client session data to the desktop session agent and starts it.
  // Note: This must only be called once per desktop process instance.
  Start(string authenticated_jid, ScreenResolution resolution,
        DesktopEnvironmentOptions options) =>
      (pending_associated_remote<DesktopSessionControl>
             desktop_session_control);
};

// Allows the network process to inject input events and control A/V capture in
// the desktop session.
// The remote for this interface is owned in the low-privilege network process
// and the receiver is bound in the high-privilege desktop integration process.
interface DesktopSessionControl {
  // Requests that a new frame be captured.
  CaptureFrame();

  // Selects a display source in a multi-monitor system.
  SelectSource(int32 desktop_display_id);

  // Changes the screen resolution in the desktop session.
  SetScreenResolution(ScreenResolution new_resolution);

  // Locks the current desktop session.
  LockWorkstation();

  // Asks the desktop session to inject the send attention sequence (SAS).
  InjectSendAttentionSequence();

  // Used to inject clipboard events received from the client.
  InjectClipboardEvent(ClipboardEvent event);

  // Used to inject keyboard events received from the client.
  InjectKeyEvent(KeyEvent event);

  // Used to inject mouse events received from the client.
  InjectMouseEvent(MouseEvent event);

  // Used to inject text events received from the client.
  InjectTextEvent(TextEvent event);

  // Used to inject touch events received from the client.
  InjectTouchEvent(TouchEvent event);

  // Used to set up the URL forwarder as the default browser.  State changes
  // will be reported via the
  // DesktopSessionEventHandler::OnUrlForwarderStateChange() method.
  SetUpUrlForwarder();
};

// Allows the desktop process to forward events and data to the network process
// which may process it (e.g. encode a video frame) or forward it to the client
// (in the case of updated clipboard contents).
// The remote for this interface is owned in the high-privilege desktop
// integration process and the receiver is bound in the low-privilege network
// process.
interface DesktopSessionEventHandler {
  // Used to forward clipboard events from the host to the client.
  OnClipboardEvent(ClipboardEvent event);

  // OnUrlForwarderStateChange is immediately called once the desktop agent
  // starts to provide the initial state, then it will be called to report state
  // changes caused by calling DesktopSessionControl::SetUpUrlForwarder().
  OnUrlForwarderStateChange(UrlForwarderState state);
};

// This enum mirrors the remoting::protocol::ErrorCode enum.
enum ProtocolErrorCode {
  kOk = 0,
  kPeerIsOffline = 1,
  kSessionRejected = 2,
  kIncompatibleProtocol = 3,
  kAuthenticationFailed = 4,
  kInvalidAccount = 5,
  kChannelConnectionError = 6,
  kSignalingError = 7,
  kSignalingTimeout = 8,
  kHostOverload = 9,
  kMaxSessionLength = 10,
  kHostConfigurationError = 11,
  kUnknownError = 12,
  kElevationError = 13,
  kHostCertificateError = 14,
  kHostRegistrationError = 15,
  kExistingAdminSession = 16,
  kAuthzPolicyCheckFailed = 17,
  kDisallowedByPolicy = 18,
};

// Provides the desktop integration process with a mechanism for controlling the
// client session owned by the network process.
// The remote for this interface is owned in the high-privilege desktop
// integration process and the receiver is bound in the low-privilege network
// process.
interface DesktopSessionStateHandler {
  // Disconnects the remote client from the host machine, |error_code| is
  // passed to the remote client as the reason for the disconnection. An example
  // usage is when the 'disconnect' button is clicked on the local disconnect
  // window. The desktop process should expect to be terminated shortly after
  // calling this method.
  DisconnectSession(ProtocolErrorCode error_code);
};
