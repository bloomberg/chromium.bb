// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: process_state.proto

#ifndef PROTOBUF_process_5fstate_2eproto__INCLUDED
#define PROTOBUF_process_5fstate_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_process_5fstate_2eproto();
void protobuf_AssignDesc_process_5fstate_2eproto();
void protobuf_ShutdownFile_process_5fstate_2eproto();

class ProcessStateProto;
class ProcessStateProto_Crash;
class ProcessStateProto_Thread;
class StackFrame;
class CodeModule;

// ===================================================================

class ProcessStateProto_Crash : public ::google::protobuf::Message {
 public:
  ProcessStateProto_Crash();
  virtual ~ProcessStateProto_Crash();
  
  ProcessStateProto_Crash(const ProcessStateProto_Crash& from);
  
  inline ProcessStateProto_Crash& operator=(const ProcessStateProto_Crash& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessStateProto_Crash& default_instance();
  
  void Swap(ProcessStateProto_Crash* other);
  
  // implements Message ----------------------------------------------
  
  ProcessStateProto_Crash* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessStateProto_Crash& from);
  void MergeFrom(const ProcessStateProto_Crash& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string reason = 1;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 1;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  
  // required int64 address = 2;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 2;
  inline ::google::protobuf::int64 address() const;
  inline void set_address(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:ProcessStateProto.Crash)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* reason_;
  static const ::std::string _default_reason_;
  ::google::protobuf::int64 address_;
  friend void  protobuf_AddDesc_process_5fstate_2eproto();
  friend void protobuf_AssignDesc_process_5fstate_2eproto();
  friend void protobuf_ShutdownFile_process_5fstate_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ProcessStateProto_Crash* default_instance_;
};
// -------------------------------------------------------------------

class ProcessStateProto_Thread : public ::google::protobuf::Message {
 public:
  ProcessStateProto_Thread();
  virtual ~ProcessStateProto_Thread();
  
  ProcessStateProto_Thread(const ProcessStateProto_Thread& from);
  
  inline ProcessStateProto_Thread& operator=(const ProcessStateProto_Thread& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessStateProto_Thread& default_instance();
  
  void Swap(ProcessStateProto_Thread* other);
  
  // implements Message ----------------------------------------------
  
  ProcessStateProto_Thread* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessStateProto_Thread& from);
  void MergeFrom(const ProcessStateProto_Thread& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .StackFrame frames = 1;
  inline int frames_size() const;
  inline void clear_frames();
  static const int kFramesFieldNumber = 1;
  inline const ::StackFrame& frames(int index) const;
  inline ::StackFrame* mutable_frames(int index);
  inline ::StackFrame* add_frames();
  inline const ::google::protobuf::RepeatedPtrField< ::StackFrame >&
      frames() const;
  inline ::google::protobuf::RepeatedPtrField< ::StackFrame >*
      mutable_frames();
  
  // @@protoc_insertion_point(class_scope:ProcessStateProto.Thread)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::StackFrame > frames_;
  friend void  protobuf_AddDesc_process_5fstate_2eproto();
  friend void protobuf_AssignDesc_process_5fstate_2eproto();
  friend void protobuf_ShutdownFile_process_5fstate_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ProcessStateProto_Thread* default_instance_;
};
// -------------------------------------------------------------------

class ProcessStateProto : public ::google::protobuf::Message {
 public:
  ProcessStateProto();
  virtual ~ProcessStateProto();
  
  ProcessStateProto(const ProcessStateProto& from);
  
  inline ProcessStateProto& operator=(const ProcessStateProto& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessStateProto& default_instance();
  
  void Swap(ProcessStateProto* other);
  
  // implements Message ----------------------------------------------
  
  ProcessStateProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessStateProto& from);
  void MergeFrom(const ProcessStateProto& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ProcessStateProto_Crash Crash;
  typedef ProcessStateProto_Thread Thread;
  
  // accessors -------------------------------------------------------
  
  // optional int64 time_date_stamp = 1;
  inline bool has_time_date_stamp() const;
  inline void clear_time_date_stamp();
  static const int kTimeDateStampFieldNumber = 1;
  inline ::google::protobuf::int64 time_date_stamp() const;
  inline void set_time_date_stamp(::google::protobuf::int64 value);
  
  // optional .ProcessStateProto.Crash crash = 2;
  inline bool has_crash() const;
  inline void clear_crash();
  static const int kCrashFieldNumber = 2;
  inline const ::ProcessStateProto_Crash& crash() const;
  inline ::ProcessStateProto_Crash* mutable_crash();
  
  // optional string assertion = 3;
  inline bool has_assertion() const;
  inline void clear_assertion();
  static const int kAssertionFieldNumber = 3;
  inline const ::std::string& assertion() const;
  inline void set_assertion(const ::std::string& value);
  inline void set_assertion(const char* value);
  inline void set_assertion(const char* value, size_t size);
  inline ::std::string* mutable_assertion();
  
  // optional int32 requesting_thread = 4;
  inline bool has_requesting_thread() const;
  inline void clear_requesting_thread();
  static const int kRequestingThreadFieldNumber = 4;
  inline ::google::protobuf::int32 requesting_thread() const;
  inline void set_requesting_thread(::google::protobuf::int32 value);
  
  // repeated .ProcessStateProto.Thread threads = 5;
  inline int threads_size() const;
  inline void clear_threads();
  static const int kThreadsFieldNumber = 5;
  inline const ::ProcessStateProto_Thread& threads(int index) const;
  inline ::ProcessStateProto_Thread* mutable_threads(int index);
  inline ::ProcessStateProto_Thread* add_threads();
  inline const ::google::protobuf::RepeatedPtrField< ::ProcessStateProto_Thread >&
      threads() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProcessStateProto_Thread >*
      mutable_threads();
  
  // repeated .CodeModule modules = 6;
  inline int modules_size() const;
  inline void clear_modules();
  static const int kModulesFieldNumber = 6;
  inline const ::CodeModule& modules(int index) const;
  inline ::CodeModule* mutable_modules(int index);
  inline ::CodeModule* add_modules();
  inline const ::google::protobuf::RepeatedPtrField< ::CodeModule >&
      modules() const;
  inline ::google::protobuf::RepeatedPtrField< ::CodeModule >*
      mutable_modules();
  
  // optional string os = 7;
  inline bool has_os() const;
  inline void clear_os();
  static const int kOsFieldNumber = 7;
  inline const ::std::string& os() const;
  inline void set_os(const ::std::string& value);
  inline void set_os(const char* value);
  inline void set_os(const char* value, size_t size);
  inline ::std::string* mutable_os();
  
  // optional string os_short = 8;
  inline bool has_os_short() const;
  inline void clear_os_short();
  static const int kOsShortFieldNumber = 8;
  inline const ::std::string& os_short() const;
  inline void set_os_short(const ::std::string& value);
  inline void set_os_short(const char* value);
  inline void set_os_short(const char* value, size_t size);
  inline ::std::string* mutable_os_short();
  
  // optional string os_version = 9;
  inline bool has_os_version() const;
  inline void clear_os_version();
  static const int kOsVersionFieldNumber = 9;
  inline const ::std::string& os_version() const;
  inline void set_os_version(const ::std::string& value);
  inline void set_os_version(const char* value);
  inline void set_os_version(const char* value, size_t size);
  inline ::std::string* mutable_os_version();
  
  // optional string cpu = 10;
  inline bool has_cpu() const;
  inline void clear_cpu();
  static const int kCpuFieldNumber = 10;
  inline const ::std::string& cpu() const;
  inline void set_cpu(const ::std::string& value);
  inline void set_cpu(const char* value);
  inline void set_cpu(const char* value, size_t size);
  inline ::std::string* mutable_cpu();
  
  // optional string cpu_info = 11;
  inline bool has_cpu_info() const;
  inline void clear_cpu_info();
  static const int kCpuInfoFieldNumber = 11;
  inline const ::std::string& cpu_info() const;
  inline void set_cpu_info(const ::std::string& value);
  inline void set_cpu_info(const char* value);
  inline void set_cpu_info(const char* value, size_t size);
  inline ::std::string* mutable_cpu_info();
  
  // optional int32 cpu_count = 12;
  inline bool has_cpu_count() const;
  inline void clear_cpu_count();
  static const int kCpuCountFieldNumber = 12;
  inline ::google::protobuf::int32 cpu_count() const;
  inline void set_cpu_count(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:ProcessStateProto)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int64 time_date_stamp_;
  ::ProcessStateProto_Crash* crash_;
  ::std::string* assertion_;
  static const ::std::string _default_assertion_;
  ::google::protobuf::int32 requesting_thread_;
  ::google::protobuf::RepeatedPtrField< ::ProcessStateProto_Thread > threads_;
  ::google::protobuf::RepeatedPtrField< ::CodeModule > modules_;
  ::std::string* os_;
  static const ::std::string _default_os_;
  ::std::string* os_short_;
  static const ::std::string _default_os_short_;
  ::std::string* os_version_;
  static const ::std::string _default_os_version_;
  ::std::string* cpu_;
  static const ::std::string _default_cpu_;
  ::std::string* cpu_info_;
  static const ::std::string _default_cpu_info_;
  ::google::protobuf::int32 cpu_count_;
  friend void  protobuf_AddDesc_process_5fstate_2eproto();
  friend void protobuf_AssignDesc_process_5fstate_2eproto();
  friend void protobuf_ShutdownFile_process_5fstate_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ProcessStateProto* default_instance_;
};
// -------------------------------------------------------------------

class StackFrame : public ::google::protobuf::Message {
 public:
  StackFrame();
  virtual ~StackFrame();
  
  StackFrame(const StackFrame& from);
  
  inline StackFrame& operator=(const StackFrame& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StackFrame& default_instance();
  
  void Swap(StackFrame* other);
  
  // implements Message ----------------------------------------------
  
  StackFrame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StackFrame& from);
  void MergeFrom(const StackFrame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 instruction = 1;
  inline bool has_instruction() const;
  inline void clear_instruction();
  static const int kInstructionFieldNumber = 1;
  inline ::google::protobuf::int64 instruction() const;
  inline void set_instruction(::google::protobuf::int64 value);
  
  // optional .CodeModule module = 2;
  inline bool has_module() const;
  inline void clear_module();
  static const int kModuleFieldNumber = 2;
  inline const ::CodeModule& module() const;
  inline ::CodeModule* mutable_module();
  
  // optional string function_name = 3;
  inline bool has_function_name() const;
  inline void clear_function_name();
  static const int kFunctionNameFieldNumber = 3;
  inline const ::std::string& function_name() const;
  inline void set_function_name(const ::std::string& value);
  inline void set_function_name(const char* value);
  inline void set_function_name(const char* value, size_t size);
  inline ::std::string* mutable_function_name();
  
  // optional int64 function_base = 4;
  inline bool has_function_base() const;
  inline void clear_function_base();
  static const int kFunctionBaseFieldNumber = 4;
  inline ::google::protobuf::int64 function_base() const;
  inline void set_function_base(::google::protobuf::int64 value);
  
  // optional string source_file_name = 5;
  inline bool has_source_file_name() const;
  inline void clear_source_file_name();
  static const int kSourceFileNameFieldNumber = 5;
  inline const ::std::string& source_file_name() const;
  inline void set_source_file_name(const ::std::string& value);
  inline void set_source_file_name(const char* value);
  inline void set_source_file_name(const char* value, size_t size);
  inline ::std::string* mutable_source_file_name();
  
  // optional int32 source_line = 6;
  inline bool has_source_line() const;
  inline void clear_source_line();
  static const int kSourceLineFieldNumber = 6;
  inline ::google::protobuf::int32 source_line() const;
  inline void set_source_line(::google::protobuf::int32 value);
  
  // optional int64 source_line_base = 7;
  inline bool has_source_line_base() const;
  inline void clear_source_line_base();
  static const int kSourceLineBaseFieldNumber = 7;
  inline ::google::protobuf::int64 source_line_base() const;
  inline void set_source_line_base(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:StackFrame)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int64 instruction_;
  ::CodeModule* module_;
  ::std::string* function_name_;
  static const ::std::string _default_function_name_;
  ::google::protobuf::int64 function_base_;
  ::std::string* source_file_name_;
  static const ::std::string _default_source_file_name_;
  ::google::protobuf::int32 source_line_;
  ::google::protobuf::int64 source_line_base_;
  friend void  protobuf_AddDesc_process_5fstate_2eproto();
  friend void protobuf_AssignDesc_process_5fstate_2eproto();
  friend void protobuf_ShutdownFile_process_5fstate_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StackFrame* default_instance_;
};
// -------------------------------------------------------------------

class CodeModule : public ::google::protobuf::Message {
 public:
  CodeModule();
  virtual ~CodeModule();
  
  CodeModule(const CodeModule& from);
  
  inline CodeModule& operator=(const CodeModule& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CodeModule& default_instance();
  
  void Swap(CodeModule* other);
  
  // implements Message ----------------------------------------------
  
  CodeModule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CodeModule& from);
  void MergeFrom(const CodeModule& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int64 base_address = 1;
  inline bool has_base_address() const;
  inline void clear_base_address();
  static const int kBaseAddressFieldNumber = 1;
  inline ::google::protobuf::int64 base_address() const;
  inline void set_base_address(::google::protobuf::int64 value);
  
  // optional int64 size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline ::google::protobuf::int64 size() const;
  inline void set_size(::google::protobuf::int64 value);
  
  // optional string code_file = 3;
  inline bool has_code_file() const;
  inline void clear_code_file();
  static const int kCodeFileFieldNumber = 3;
  inline const ::std::string& code_file() const;
  inline void set_code_file(const ::std::string& value);
  inline void set_code_file(const char* value);
  inline void set_code_file(const char* value, size_t size);
  inline ::std::string* mutable_code_file();
  
  // optional string code_identifier = 4;
  inline bool has_code_identifier() const;
  inline void clear_code_identifier();
  static const int kCodeIdentifierFieldNumber = 4;
  inline const ::std::string& code_identifier() const;
  inline void set_code_identifier(const ::std::string& value);
  inline void set_code_identifier(const char* value);
  inline void set_code_identifier(const char* value, size_t size);
  inline ::std::string* mutable_code_identifier();
  
  // optional string debug_file = 5;
  inline bool has_debug_file() const;
  inline void clear_debug_file();
  static const int kDebugFileFieldNumber = 5;
  inline const ::std::string& debug_file() const;
  inline void set_debug_file(const ::std::string& value);
  inline void set_debug_file(const char* value);
  inline void set_debug_file(const char* value, size_t size);
  inline ::std::string* mutable_debug_file();
  
  // optional string debug_identifier = 6;
  inline bool has_debug_identifier() const;
  inline void clear_debug_identifier();
  static const int kDebugIdentifierFieldNumber = 6;
  inline const ::std::string& debug_identifier() const;
  inline void set_debug_identifier(const ::std::string& value);
  inline void set_debug_identifier(const char* value);
  inline void set_debug_identifier(const char* value, size_t size);
  inline ::std::string* mutable_debug_identifier();
  
  // optional string version = 7;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 7;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  
  // @@protoc_insertion_point(class_scope:CodeModule)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int64 base_address_;
  ::google::protobuf::int64 size_;
  ::std::string* code_file_;
  static const ::std::string _default_code_file_;
  ::std::string* code_identifier_;
  static const ::std::string _default_code_identifier_;
  ::std::string* debug_file_;
  static const ::std::string _default_debug_file_;
  ::std::string* debug_identifier_;
  static const ::std::string _default_debug_identifier_;
  ::std::string* version_;
  static const ::std::string _default_version_;
  friend void  protobuf_AddDesc_process_5fstate_2eproto();
  friend void protobuf_AssignDesc_process_5fstate_2eproto();
  friend void protobuf_ShutdownFile_process_5fstate_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CodeModule* default_instance_;
};
// ===================================================================


// ===================================================================

// ProcessStateProto_Crash

// required string reason = 1;
inline bool ProcessStateProto_Crash::has_reason() const {
  return _has_bit(0);
}
inline void ProcessStateProto_Crash::clear_reason() {
  if (reason_ != &_default_reason_) {
    reason_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ProcessStateProto_Crash::reason() const {
  return *reason_;
}
inline void ProcessStateProto_Crash::set_reason(const ::std::string& value) {
  _set_bit(0);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void ProcessStateProto_Crash::set_reason(const char* value) {
  _set_bit(0);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void ProcessStateProto_Crash::set_reason(const char* value, size_t size) {
  _set_bit(0);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessStateProto_Crash::mutable_reason() {
  _set_bit(0);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  return reason_;
}

// required int64 address = 2;
inline bool ProcessStateProto_Crash::has_address() const {
  return _has_bit(1);
}
inline void ProcessStateProto_Crash::clear_address() {
  address_ = GOOGLE_LONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::int64 ProcessStateProto_Crash::address() const {
  return address_;
}
inline void ProcessStateProto_Crash::set_address(::google::protobuf::int64 value) {
  _set_bit(1);
  address_ = value;
}

// -------------------------------------------------------------------

// ProcessStateProto_Thread

// repeated .StackFrame frames = 1;
inline int ProcessStateProto_Thread::frames_size() const {
  return frames_.size();
}
inline void ProcessStateProto_Thread::clear_frames() {
  frames_.Clear();
}
inline const ::StackFrame& ProcessStateProto_Thread::frames(int index) const {
  return frames_.Get(index);
}
inline ::StackFrame* ProcessStateProto_Thread::mutable_frames(int index) {
  return frames_.Mutable(index);
}
inline ::StackFrame* ProcessStateProto_Thread::add_frames() {
  return frames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::StackFrame >&
ProcessStateProto_Thread::frames() const {
  return frames_;
}
inline ::google::protobuf::RepeatedPtrField< ::StackFrame >*
ProcessStateProto_Thread::mutable_frames() {
  return &frames_;
}

// -------------------------------------------------------------------

// ProcessStateProto

// optional int64 time_date_stamp = 1;
inline bool ProcessStateProto::has_time_date_stamp() const {
  return _has_bit(0);
}
inline void ProcessStateProto::clear_time_date_stamp() {
  time_date_stamp_ = GOOGLE_LONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::int64 ProcessStateProto::time_date_stamp() const {
  return time_date_stamp_;
}
inline void ProcessStateProto::set_time_date_stamp(::google::protobuf::int64 value) {
  _set_bit(0);
  time_date_stamp_ = value;
}

// optional .ProcessStateProto.Crash crash = 2;
inline bool ProcessStateProto::has_crash() const {
  return _has_bit(1);
}
inline void ProcessStateProto::clear_crash() {
  if (crash_ != NULL) crash_->::ProcessStateProto_Crash::Clear();
  _clear_bit(1);
}
inline const ::ProcessStateProto_Crash& ProcessStateProto::crash() const {
  return crash_ != NULL ? *crash_ : *default_instance_->crash_;
}
inline ::ProcessStateProto_Crash* ProcessStateProto::mutable_crash() {
  _set_bit(1);
  if (crash_ == NULL) crash_ = new ::ProcessStateProto_Crash;
  return crash_;
}

// optional string assertion = 3;
inline bool ProcessStateProto::has_assertion() const {
  return _has_bit(2);
}
inline void ProcessStateProto::clear_assertion() {
  if (assertion_ != &_default_assertion_) {
    assertion_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& ProcessStateProto::assertion() const {
  return *assertion_;
}
inline void ProcessStateProto::set_assertion(const ::std::string& value) {
  _set_bit(2);
  if (assertion_ == &_default_assertion_) {
    assertion_ = new ::std::string;
  }
  assertion_->assign(value);
}
inline void ProcessStateProto::set_assertion(const char* value) {
  _set_bit(2);
  if (assertion_ == &_default_assertion_) {
    assertion_ = new ::std::string;
  }
  assertion_->assign(value);
}
inline void ProcessStateProto::set_assertion(const char* value, size_t size) {
  _set_bit(2);
  if (assertion_ == &_default_assertion_) {
    assertion_ = new ::std::string;
  }
  assertion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessStateProto::mutable_assertion() {
  _set_bit(2);
  if (assertion_ == &_default_assertion_) {
    assertion_ = new ::std::string;
  }
  return assertion_;
}

// optional int32 requesting_thread = 4;
inline bool ProcessStateProto::has_requesting_thread() const {
  return _has_bit(3);
}
inline void ProcessStateProto::clear_requesting_thread() {
  requesting_thread_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 ProcessStateProto::requesting_thread() const {
  return requesting_thread_;
}
inline void ProcessStateProto::set_requesting_thread(::google::protobuf::int32 value) {
  _set_bit(3);
  requesting_thread_ = value;
}

// repeated .ProcessStateProto.Thread threads = 5;
inline int ProcessStateProto::threads_size() const {
  return threads_.size();
}
inline void ProcessStateProto::clear_threads() {
  threads_.Clear();
}
inline const ::ProcessStateProto_Thread& ProcessStateProto::threads(int index) const {
  return threads_.Get(index);
}
inline ::ProcessStateProto_Thread* ProcessStateProto::mutable_threads(int index) {
  return threads_.Mutable(index);
}
inline ::ProcessStateProto_Thread* ProcessStateProto::add_threads() {
  return threads_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProcessStateProto_Thread >&
ProcessStateProto::threads() const {
  return threads_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProcessStateProto_Thread >*
ProcessStateProto::mutable_threads() {
  return &threads_;
}

// repeated .CodeModule modules = 6;
inline int ProcessStateProto::modules_size() const {
  return modules_.size();
}
inline void ProcessStateProto::clear_modules() {
  modules_.Clear();
}
inline const ::CodeModule& ProcessStateProto::modules(int index) const {
  return modules_.Get(index);
}
inline ::CodeModule* ProcessStateProto::mutable_modules(int index) {
  return modules_.Mutable(index);
}
inline ::CodeModule* ProcessStateProto::add_modules() {
  return modules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CodeModule >&
ProcessStateProto::modules() const {
  return modules_;
}
inline ::google::protobuf::RepeatedPtrField< ::CodeModule >*
ProcessStateProto::mutable_modules() {
  return &modules_;
}

// optional string os = 7;
inline bool ProcessStateProto::has_os() const {
  return _has_bit(6);
}
inline void ProcessStateProto::clear_os() {
  if (os_ != &_default_os_) {
    os_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& ProcessStateProto::os() const {
  return *os_;
}
inline void ProcessStateProto::set_os(const ::std::string& value) {
  _set_bit(6);
  if (os_ == &_default_os_) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void ProcessStateProto::set_os(const char* value) {
  _set_bit(6);
  if (os_ == &_default_os_) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void ProcessStateProto::set_os(const char* value, size_t size) {
  _set_bit(6);
  if (os_ == &_default_os_) {
    os_ = new ::std::string;
  }
  os_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessStateProto::mutable_os() {
  _set_bit(6);
  if (os_ == &_default_os_) {
    os_ = new ::std::string;
  }
  return os_;
}

// optional string os_short = 8;
inline bool ProcessStateProto::has_os_short() const {
  return _has_bit(7);
}
inline void ProcessStateProto::clear_os_short() {
  if (os_short_ != &_default_os_short_) {
    os_short_->clear();
  }
  _clear_bit(7);
}
inline const ::std::string& ProcessStateProto::os_short() const {
  return *os_short_;
}
inline void ProcessStateProto::set_os_short(const ::std::string& value) {
  _set_bit(7);
  if (os_short_ == &_default_os_short_) {
    os_short_ = new ::std::string;
  }
  os_short_->assign(value);
}
inline void ProcessStateProto::set_os_short(const char* value) {
  _set_bit(7);
  if (os_short_ == &_default_os_short_) {
    os_short_ = new ::std::string;
  }
  os_short_->assign(value);
}
inline void ProcessStateProto::set_os_short(const char* value, size_t size) {
  _set_bit(7);
  if (os_short_ == &_default_os_short_) {
    os_short_ = new ::std::string;
  }
  os_short_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessStateProto::mutable_os_short() {
  _set_bit(7);
  if (os_short_ == &_default_os_short_) {
    os_short_ = new ::std::string;
  }
  return os_short_;
}

// optional string os_version = 9;
inline bool ProcessStateProto::has_os_version() const {
  return _has_bit(8);
}
inline void ProcessStateProto::clear_os_version() {
  if (os_version_ != &_default_os_version_) {
    os_version_->clear();
  }
  _clear_bit(8);
}
inline const ::std::string& ProcessStateProto::os_version() const {
  return *os_version_;
}
inline void ProcessStateProto::set_os_version(const ::std::string& value) {
  _set_bit(8);
  if (os_version_ == &_default_os_version_) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
}
inline void ProcessStateProto::set_os_version(const char* value) {
  _set_bit(8);
  if (os_version_ == &_default_os_version_) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
}
inline void ProcessStateProto::set_os_version(const char* value, size_t size) {
  _set_bit(8);
  if (os_version_ == &_default_os_version_) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessStateProto::mutable_os_version() {
  _set_bit(8);
  if (os_version_ == &_default_os_version_) {
    os_version_ = new ::std::string;
  }
  return os_version_;
}

// optional string cpu = 10;
inline bool ProcessStateProto::has_cpu() const {
  return _has_bit(9);
}
inline void ProcessStateProto::clear_cpu() {
  if (cpu_ != &_default_cpu_) {
    cpu_->clear();
  }
  _clear_bit(9);
}
inline const ::std::string& ProcessStateProto::cpu() const {
  return *cpu_;
}
inline void ProcessStateProto::set_cpu(const ::std::string& value) {
  _set_bit(9);
  if (cpu_ == &_default_cpu_) {
    cpu_ = new ::std::string;
  }
  cpu_->assign(value);
}
inline void ProcessStateProto::set_cpu(const char* value) {
  _set_bit(9);
  if (cpu_ == &_default_cpu_) {
    cpu_ = new ::std::string;
  }
  cpu_->assign(value);
}
inline void ProcessStateProto::set_cpu(const char* value, size_t size) {
  _set_bit(9);
  if (cpu_ == &_default_cpu_) {
    cpu_ = new ::std::string;
  }
  cpu_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessStateProto::mutable_cpu() {
  _set_bit(9);
  if (cpu_ == &_default_cpu_) {
    cpu_ = new ::std::string;
  }
  return cpu_;
}

// optional string cpu_info = 11;
inline bool ProcessStateProto::has_cpu_info() const {
  return _has_bit(10);
}
inline void ProcessStateProto::clear_cpu_info() {
  if (cpu_info_ != &_default_cpu_info_) {
    cpu_info_->clear();
  }
  _clear_bit(10);
}
inline const ::std::string& ProcessStateProto::cpu_info() const {
  return *cpu_info_;
}
inline void ProcessStateProto::set_cpu_info(const ::std::string& value) {
  _set_bit(10);
  if (cpu_info_ == &_default_cpu_info_) {
    cpu_info_ = new ::std::string;
  }
  cpu_info_->assign(value);
}
inline void ProcessStateProto::set_cpu_info(const char* value) {
  _set_bit(10);
  if (cpu_info_ == &_default_cpu_info_) {
    cpu_info_ = new ::std::string;
  }
  cpu_info_->assign(value);
}
inline void ProcessStateProto::set_cpu_info(const char* value, size_t size) {
  _set_bit(10);
  if (cpu_info_ == &_default_cpu_info_) {
    cpu_info_ = new ::std::string;
  }
  cpu_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessStateProto::mutable_cpu_info() {
  _set_bit(10);
  if (cpu_info_ == &_default_cpu_info_) {
    cpu_info_ = new ::std::string;
  }
  return cpu_info_;
}

// optional int32 cpu_count = 12;
inline bool ProcessStateProto::has_cpu_count() const {
  return _has_bit(11);
}
inline void ProcessStateProto::clear_cpu_count() {
  cpu_count_ = 0;
  _clear_bit(11);
}
inline ::google::protobuf::int32 ProcessStateProto::cpu_count() const {
  return cpu_count_;
}
inline void ProcessStateProto::set_cpu_count(::google::protobuf::int32 value) {
  _set_bit(11);
  cpu_count_ = value;
}

// -------------------------------------------------------------------

// StackFrame

// required int64 instruction = 1;
inline bool StackFrame::has_instruction() const {
  return _has_bit(0);
}
inline void StackFrame::clear_instruction() {
  instruction_ = GOOGLE_LONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::int64 StackFrame::instruction() const {
  return instruction_;
}
inline void StackFrame::set_instruction(::google::protobuf::int64 value) {
  _set_bit(0);
  instruction_ = value;
}

// optional .CodeModule module = 2;
inline bool StackFrame::has_module() const {
  return _has_bit(1);
}
inline void StackFrame::clear_module() {
  if (module_ != NULL) module_->::CodeModule::Clear();
  _clear_bit(1);
}
inline const ::CodeModule& StackFrame::module() const {
  return module_ != NULL ? *module_ : *default_instance_->module_;
}
inline ::CodeModule* StackFrame::mutable_module() {
  _set_bit(1);
  if (module_ == NULL) module_ = new ::CodeModule;
  return module_;
}

// optional string function_name = 3;
inline bool StackFrame::has_function_name() const {
  return _has_bit(2);
}
inline void StackFrame::clear_function_name() {
  if (function_name_ != &_default_function_name_) {
    function_name_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& StackFrame::function_name() const {
  return *function_name_;
}
inline void StackFrame::set_function_name(const ::std::string& value) {
  _set_bit(2);
  if (function_name_ == &_default_function_name_) {
    function_name_ = new ::std::string;
  }
  function_name_->assign(value);
}
inline void StackFrame::set_function_name(const char* value) {
  _set_bit(2);
  if (function_name_ == &_default_function_name_) {
    function_name_ = new ::std::string;
  }
  function_name_->assign(value);
}
inline void StackFrame::set_function_name(const char* value, size_t size) {
  _set_bit(2);
  if (function_name_ == &_default_function_name_) {
    function_name_ = new ::std::string;
  }
  function_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StackFrame::mutable_function_name() {
  _set_bit(2);
  if (function_name_ == &_default_function_name_) {
    function_name_ = new ::std::string;
  }
  return function_name_;
}

// optional int64 function_base = 4;
inline bool StackFrame::has_function_base() const {
  return _has_bit(3);
}
inline void StackFrame::clear_function_base() {
  function_base_ = GOOGLE_LONGLONG(0);
  _clear_bit(3);
}
inline ::google::protobuf::int64 StackFrame::function_base() const {
  return function_base_;
}
inline void StackFrame::set_function_base(::google::protobuf::int64 value) {
  _set_bit(3);
  function_base_ = value;
}

// optional string source_file_name = 5;
inline bool StackFrame::has_source_file_name() const {
  return _has_bit(4);
}
inline void StackFrame::clear_source_file_name() {
  if (source_file_name_ != &_default_source_file_name_) {
    source_file_name_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& StackFrame::source_file_name() const {
  return *source_file_name_;
}
inline void StackFrame::set_source_file_name(const ::std::string& value) {
  _set_bit(4);
  if (source_file_name_ == &_default_source_file_name_) {
    source_file_name_ = new ::std::string;
  }
  source_file_name_->assign(value);
}
inline void StackFrame::set_source_file_name(const char* value) {
  _set_bit(4);
  if (source_file_name_ == &_default_source_file_name_) {
    source_file_name_ = new ::std::string;
  }
  source_file_name_->assign(value);
}
inline void StackFrame::set_source_file_name(const char* value, size_t size) {
  _set_bit(4);
  if (source_file_name_ == &_default_source_file_name_) {
    source_file_name_ = new ::std::string;
  }
  source_file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StackFrame::mutable_source_file_name() {
  _set_bit(4);
  if (source_file_name_ == &_default_source_file_name_) {
    source_file_name_ = new ::std::string;
  }
  return source_file_name_;
}

// optional int32 source_line = 6;
inline bool StackFrame::has_source_line() const {
  return _has_bit(5);
}
inline void StackFrame::clear_source_line() {
  source_line_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 StackFrame::source_line() const {
  return source_line_;
}
inline void StackFrame::set_source_line(::google::protobuf::int32 value) {
  _set_bit(5);
  source_line_ = value;
}

// optional int64 source_line_base = 7;
inline bool StackFrame::has_source_line_base() const {
  return _has_bit(6);
}
inline void StackFrame::clear_source_line_base() {
  source_line_base_ = GOOGLE_LONGLONG(0);
  _clear_bit(6);
}
inline ::google::protobuf::int64 StackFrame::source_line_base() const {
  return source_line_base_;
}
inline void StackFrame::set_source_line_base(::google::protobuf::int64 value) {
  _set_bit(6);
  source_line_base_ = value;
}

// -------------------------------------------------------------------

// CodeModule

// optional int64 base_address = 1;
inline bool CodeModule::has_base_address() const {
  return _has_bit(0);
}
inline void CodeModule::clear_base_address() {
  base_address_ = GOOGLE_LONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::int64 CodeModule::base_address() const {
  return base_address_;
}
inline void CodeModule::set_base_address(::google::protobuf::int64 value) {
  _set_bit(0);
  base_address_ = value;
}

// optional int64 size = 2;
inline bool CodeModule::has_size() const {
  return _has_bit(1);
}
inline void CodeModule::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::int64 CodeModule::size() const {
  return size_;
}
inline void CodeModule::set_size(::google::protobuf::int64 value) {
  _set_bit(1);
  size_ = value;
}

// optional string code_file = 3;
inline bool CodeModule::has_code_file() const {
  return _has_bit(2);
}
inline void CodeModule::clear_code_file() {
  if (code_file_ != &_default_code_file_) {
    code_file_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& CodeModule::code_file() const {
  return *code_file_;
}
inline void CodeModule::set_code_file(const ::std::string& value) {
  _set_bit(2);
  if (code_file_ == &_default_code_file_) {
    code_file_ = new ::std::string;
  }
  code_file_->assign(value);
}
inline void CodeModule::set_code_file(const char* value) {
  _set_bit(2);
  if (code_file_ == &_default_code_file_) {
    code_file_ = new ::std::string;
  }
  code_file_->assign(value);
}
inline void CodeModule::set_code_file(const char* value, size_t size) {
  _set_bit(2);
  if (code_file_ == &_default_code_file_) {
    code_file_ = new ::std::string;
  }
  code_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CodeModule::mutable_code_file() {
  _set_bit(2);
  if (code_file_ == &_default_code_file_) {
    code_file_ = new ::std::string;
  }
  return code_file_;
}

// optional string code_identifier = 4;
inline bool CodeModule::has_code_identifier() const {
  return _has_bit(3);
}
inline void CodeModule::clear_code_identifier() {
  if (code_identifier_ != &_default_code_identifier_) {
    code_identifier_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& CodeModule::code_identifier() const {
  return *code_identifier_;
}
inline void CodeModule::set_code_identifier(const ::std::string& value) {
  _set_bit(3);
  if (code_identifier_ == &_default_code_identifier_) {
    code_identifier_ = new ::std::string;
  }
  code_identifier_->assign(value);
}
inline void CodeModule::set_code_identifier(const char* value) {
  _set_bit(3);
  if (code_identifier_ == &_default_code_identifier_) {
    code_identifier_ = new ::std::string;
  }
  code_identifier_->assign(value);
}
inline void CodeModule::set_code_identifier(const char* value, size_t size) {
  _set_bit(3);
  if (code_identifier_ == &_default_code_identifier_) {
    code_identifier_ = new ::std::string;
  }
  code_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CodeModule::mutable_code_identifier() {
  _set_bit(3);
  if (code_identifier_ == &_default_code_identifier_) {
    code_identifier_ = new ::std::string;
  }
  return code_identifier_;
}

// optional string debug_file = 5;
inline bool CodeModule::has_debug_file() const {
  return _has_bit(4);
}
inline void CodeModule::clear_debug_file() {
  if (debug_file_ != &_default_debug_file_) {
    debug_file_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& CodeModule::debug_file() const {
  return *debug_file_;
}
inline void CodeModule::set_debug_file(const ::std::string& value) {
  _set_bit(4);
  if (debug_file_ == &_default_debug_file_) {
    debug_file_ = new ::std::string;
  }
  debug_file_->assign(value);
}
inline void CodeModule::set_debug_file(const char* value) {
  _set_bit(4);
  if (debug_file_ == &_default_debug_file_) {
    debug_file_ = new ::std::string;
  }
  debug_file_->assign(value);
}
inline void CodeModule::set_debug_file(const char* value, size_t size) {
  _set_bit(4);
  if (debug_file_ == &_default_debug_file_) {
    debug_file_ = new ::std::string;
  }
  debug_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CodeModule::mutable_debug_file() {
  _set_bit(4);
  if (debug_file_ == &_default_debug_file_) {
    debug_file_ = new ::std::string;
  }
  return debug_file_;
}

// optional string debug_identifier = 6;
inline bool CodeModule::has_debug_identifier() const {
  return _has_bit(5);
}
inline void CodeModule::clear_debug_identifier() {
  if (debug_identifier_ != &_default_debug_identifier_) {
    debug_identifier_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& CodeModule::debug_identifier() const {
  return *debug_identifier_;
}
inline void CodeModule::set_debug_identifier(const ::std::string& value) {
  _set_bit(5);
  if (debug_identifier_ == &_default_debug_identifier_) {
    debug_identifier_ = new ::std::string;
  }
  debug_identifier_->assign(value);
}
inline void CodeModule::set_debug_identifier(const char* value) {
  _set_bit(5);
  if (debug_identifier_ == &_default_debug_identifier_) {
    debug_identifier_ = new ::std::string;
  }
  debug_identifier_->assign(value);
}
inline void CodeModule::set_debug_identifier(const char* value, size_t size) {
  _set_bit(5);
  if (debug_identifier_ == &_default_debug_identifier_) {
    debug_identifier_ = new ::std::string;
  }
  debug_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CodeModule::mutable_debug_identifier() {
  _set_bit(5);
  if (debug_identifier_ == &_default_debug_identifier_) {
    debug_identifier_ = new ::std::string;
  }
  return debug_identifier_;
}

// optional string version = 7;
inline bool CodeModule::has_version() const {
  return _has_bit(6);
}
inline void CodeModule::clear_version() {
  if (version_ != &_default_version_) {
    version_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& CodeModule::version() const {
  return *version_;
}
inline void CodeModule::set_version(const ::std::string& value) {
  _set_bit(6);
  if (version_ == &_default_version_) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void CodeModule::set_version(const char* value) {
  _set_bit(6);
  if (version_ == &_default_version_) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void CodeModule::set_version(const char* value, size_t size) {
  _set_bit(6);
  if (version_ == &_default_version_) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CodeModule::mutable_version() {
  _set_bit(6);
  if (version_ == &_default_version_) {
    version_ = new ::std::string;
  }
  return version_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_process_5fstate_2eproto__INCLUDED
