# Copyright 2022 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/config/c++/c++.gni")
import("//build/config/clang/clang.gni")
import("//build/config/rust.gni")
import("//build/config/sysroot.gni")

# Template to build Rust/C++ bindings using autocxx tooling. This also works
# to build bindings with cxx tooling. This is meant for use by higher level
# templates. Prefer to write GN targets with those higher level templates,
# such as rust_static_library or mixed_static_library, as they provide
# bindings generation by making use of this template.
#
# This template expands to a static_library containing the C++ side of the
# bindings. Simply treat it as a public dependency. The Rust target will also
# need to depend upon this target, as autocxx generates a .rs file which is then
# included by a macro within the Rust compilation step.
#
# Parameters:
#
# sources:
#   The .rs files containing a #[cxx::bridge] mod or a
#   autocxx::include_cpp! macro.
#
# export_symbols:
#   Whether the C++ side of the bindings should be exported from any shared
#   objects in which it finds itself. This is not necessary if the Rust and
#   C++ side of the bindings will always find themselves within the same
#   final linking target, and are not exposed via public_deps. It should always
#   be true when is_component_build is true, in case the code is linked into a
#   shared library and exposed by public_deps. And it should also be true when
#   explicitly part of a shared_library target. This does the equivalent of
#   adding BASE_EXPORT or similar.
#
# deps: (optional)
#   C++ targets on which the headers depend in order to build successfully.
#
# configs: (optional)
#   C++ compilation targets determine the correct list of -D and -I flags based
#   on their dependencies and any configs applied. The same applies here. Set
#   any configs here as if this were a C++ target.
#
# Rust targets depending on the output of this target must also set:
#   rustenv = [ "AUTOCXX_RS_FILE=" +
#    rebase_path("$target_gen_dir/main.rs/gen0.include.rs") ]
# TODO(crbug.com/1306841): remove this.
#
template("rust_autocxx") {
  assert(defined(invoker.sources),
         "Must specify the Rust file(s) to use as sources.")
  _target_name = target_name
  _testonly = false
  if (defined(invoker.testonly)) {
    _testonly = invoker.testonly
  }
  if (defined(invoker.visibility)) {
    _visibility = invoker.visibility
  }
  _deps = []
  if (defined(invoker.deps)) {
    _deps += invoker.deps
  }

  action_foreach("${_target_name}_gen") {
    testonly = _testonly
    visibility = [ ":${_target_name}" ]
    if (defined(_visibility)) {
      visibility += _visibility
    }

    sources = invoker.sources
    if (defined(invoker.configs)) {
      configs = invoker.configs
    }

    output_prefix = "{{source_name_part}}"
    output_dir = "{{source_gen_dir}}/{{source_file_part}}"

    # Two .cc files are generated by autocxx for each set of bindings
    # To keep gn/ninja happy, we have to ensure they have unique names,
    # not just unique paths.
    out_gen0_cc = "$output_dir/${output_prefix}_gen0.cc"
    out_gen1_cc = "$output_dir/${output_prefix}_gen1.cc"

    # A single .rs file is generated for each set of bindings, which
    # is then include!d by autocxx_macro. The path to this file
    # will need to be fed to the macro via the AUTOCXX_RS_FILE variable
    # (this is set automatically in rust_target.gni).
    out_gen0_rs = "$output_dir/gen0.include.rs"

    # Header file used internally within autocxx generated code. No external
    # code needs to include this. Needs exactly this name.
    out_gen0_h = "$output_dir/gen0.h"

    # Header file describing available calls from C++ -> Rust.
    # We give this a sensible name so it can be included in other
    # C++ code, and put it somewhere that other C++ code can include it easily.
    output_h = "{{source_gen_dir}}/{{source_file_part}}.h"

    autocxx_gen_target =
        "//third_party/rust/autocxx_gen/v0_17:autocxx_gen($host_toolchain)"

    autocxx_gen_obj_dir = get_label_info(autocxx_gen_target, "root_out_dir")
    autocxx_gen_executable = rebase_path("${autocxx_gen_obj_dir}/autocxx_gen")
    if (is_win) {
      autocxx_gen_executable = rebase_path("${autocxx_gen_executable}.exe")
    }

    script = rebase_path("//build/rust/run_autocxx_gen.py")
    inputs = [
      autocxx_gen_executable,
      script,
    ]
    outputs = [
      out_gen0_cc,
      out_gen0_rs,
      out_gen1_cc,
      out_gen0_h,
      output_h,
    ]

    deps = [ autocxx_gen_target ]

    # autocxx relies on knowing the {{defines}} and {{include_dirs}} required
    # to build the C++ headers which it's parsing. These are passed to the
    # script's args and are populated using deps and configs.
    deps += _deps

    args = [
      "--exe",
      autocxx_gen_executable,
      "--outdir",
      output_dir,
      "--cxx-h-path",
      "third_party/rust/cxx/v1/crate/include/",
      "--ld-library-path",
      rebase_path(clang_base_path + "/lib"),
      "--output-prefix",
      output_prefix,
      "--header",
      output_h,
      "--source",
      "{{source}}",
    ]

    if (invoker.export_symbols) {
      # See explanation of 'export_symbols' above for what this does.
      # Implementation note: we could have required users of this template to
      # specify a preprocessor symbol, e.g. BASE_EXPORT, which would vary
      # per-component. However, since we're building only the definition of the
      # bindings, not any header files, the export specifications are
      # predictable and we don't need to foist that complexity on users of this
      # template. The default behavior here should be correct. If this proves to
      # be insufficient in future, this template should be modified to accept a
      # parameter where users can specify 'BASE_EXPORT' or the equivalent for
      # their component. cxxbridge --cxx-impl-annotations adds this annotation
      # to each exported C++ function.
      args += [ "--cxx-impl-annotations" ]
      if (is_win) {
        args += [ "__declspec(dllexport)" ]
      } else {
        args += [ "__attribute__((visibility(\"default\")))" ]
      }
    }

    # TODO(crbug.com/1306841): solve by passing cflags (and similar) to action
    # targets as well as defines and includes.
    args += [
      "--",
      "{{defines}}",
      "{{include_dirs}}",
      "-fparse-all-comments",  # so rustdoc includes comments of the form
                               # // This is what this API does
                               # not just
                               # /// This is what this API does
      "-std=c++17",  # Keep in sync with main Chromium build.
      "-nostdinc++",
      "-isystem" + rebase_path(libcxx_prefix + "/include"),
      "-isystem" + rebase_path(libcxxabi_prefix + "/include"),
      "--sysroot=" + rebase_path(sysroot),
      "-isystem" + rebase_path(
              clang_base_path + "/lib/clang/" + clang_version + "/include"),
    ]
  }

  static_library(target_name) {
    testonly = _testonly
    if (defined(invoker.visibility)) {
      visibility = invoker.visibility
    }
    _all_sources = get_target_outputs(":${target_name}_gen")
    sources = filter_exclude(_all_sources, [ "*.rs" ])
    deps = _deps
    deps += [
      ":${target_name}_gen",
      "//build/rust:cxx_cppdeps",
    ]
  }
}
