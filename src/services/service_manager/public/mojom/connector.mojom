// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module service_manager.mojom;

import "mojo/public/mojom/base/token.mojom";
import "services/service_manager/public/mojom/constants.mojom";
import "services/service_manager/public/mojom/interface_provider.mojom";
import "services/service_manager/public/mojom/service_filter.mojom";

// TODO(beng): Evaluate the utility of this enum. There are some inconsistencies
//             in its use with BindInterface/WarmService.
enum ConnectResult {
  // The operation was completed successfully.
  SUCCEEDED,

  // The given service name specified by |name| does not match a known service.
  INVALID_ARGUMENT,

  // Policy prevented the successful completion of this operation. Either
  // requests to bind to |name| are forbidden from the calling service by its
  // manifest, or the service attempted to connect to an instance in an instance
  // group with which it's not allowed to communicate.
  ACCESS_DENIED
};

// A collection of metadata that disambiguates instances in the service manager.
struct Identity {
  // A name identifying a service.
  string name;

  // Identifies the instance group to which a service instance belongs. Most
  // running service instances can only reach (via Connector) other service
  // instances running in the same instance group. This facilitates a mode of
  // isolation which is useful for modeling, e.g., different users in a multi-
  // user system. Must always be non-zero.
  mojo_base.mojom.Token instance_group;

  // Disambiguates multiple instances of the same service potentially running
  // within the same instance group. Used for more granular isolation of
  // instances. May be zero.
  //
  // At any given moment, there can be at most ONE service instance running with
  // any given combination of |name|, |instance_group|, and |instance_id|.
  mojo_base.mojom.Token instance_id;

  // A Token which globally and uniquely identifies a service instance across
  // space and time. This value is generated and assigned by the Service Manager
  // when starting a new instance, or is given to the Service Manager by a
  // privileged client using the |Connector.RegisterServiceInstance()| API.
  //
  // In either case, this value is always unique to a single service instance.
  mojo_base.mojom.Token globally_unique_id;
};

// Static metadata about a service the Service Manager knows about. This is
// information pertaining to the service definition itself (e.g. registered
// manifest contents), not to any particular service instance running in the
// system.
struct ServiceInfo {
  // A string describing the kind of sandboxing the service has declared for
  // itself in its manifest.
  string sandbox_type;
};

// Implemented by an object in the service manager associated with a specific
// instance. Tells the service manager the PID for a process launched by the
// client.
interface PIDReceiver {
  SetPID(uint32 pid);
};

// An interface that allows the holder to start other services & bind to
// interfaces exposed by them.
interface Connector {
  // Asks the Service Manager to route an interface request to another service
  // instance. The target instance is selected by |filter|, subject to various
  // constraints. With some exceptions and limitations, if no existing service
  // instance is found matching the given |filter|, a new instance is started
  // which meets the constraints of the filter.
  //
  // Upon success, |result| will be |SUCCEEDED| and |identity| will contain the
  // full identity of the service instance to which the request was successfully
  // routed. Upon failure |result| will take on a different value and |identity|
  // will be null.
  //
  // If |filter| filters only by service name, the Service Manager may select
  // any running service instance with that service name. If the named service
  // is not a singleton or otherwise shared across all instance groups, the
  // selection space is limited to the caller's own instance group.
  //
  // If |filter| includes an instance group ID, either that group ID must match
  // the caller's own, or the caller must have set the
  // |can_connect_to_instances_in_any_group| option in its own manifest.
  //
  // If |filter| includes an instance ID, the caller must have set the
  // |can_connect_to_other_services_with_any_instance_name| option in its own
  // manifest.
  //
  // If |filter| includes a globally unique ID, it must include a group ID and
  // instance ID as well. Requests like this will only ever match a specific
  // service instance that is already running. Unlike in other cases, the
  // Service Manager will NEVER create a new service instance to fulfill this
  // request.
  BindInterface(ServiceFilter filter,
                string interface_name,
                handle<message_pipe> interface_pipe)
      => (ConnectResult result, Identity? identity);

  // Asks the Service Manager for details about the service named
  // |service_name|. No processes are started as a result of this request. On
  // response, |info| provides information about the service. If the Service
  // Manager is not familiar the named service, |info| will be null.
  QueryService(string service_name) => (ServiceInfo? info);

  // Asks the Service Manager to ensure that a service instance which would
  // match |filter| (from the caller's perspective) is running. This is
  // essentially equivalent to |BindInterface()| above but no interface request
  // is given to bind. This is mainly here as a performance measure, as a client
  // may wish to ensure that a service is warmed up by the time the client
  // actually needs it.
  //
  // See comments on |BindInterface()| above for details on filtering
  // constraints, instance creation, and response values.
  WarmService(ServiceFilter filter)
      => (ConnectResult result, Identity? identity);

  // Typically, the Service Manager will start a process for a service the first
  // time it receives a |BindInterface()| or |WarmService()| request for a
  // filter it can't match to an existing instance.
  //
  // This call allows new service instances to be explicitly injected into the
  // Service Manager's set of running services. As such, this is considered to
  // be a highly privileged API. A service calling this API must have the
  // |can_create_other_service_instances| option set to |true| in its own
  // manifest or the request will be rejected.
  //
  // |identity| is the full identity of the service instance to introduce. This
  // must include a valid instance group and a valid, random, globally unique
  // ID.
  //
  // |service| is a |Service| interface pipe (i.e. a ServicePtr in C++).
  //
  // |pid_receiver_request| is the receiving end of a PIDReceiver pipe. The
  // caller is expected to call |SetPid()| on the other end of this pipe in
  // order to inform the Service Manager about which process is actually hosting
  // the service instance.
  //
  // TODO(https://crbug.com/904137): We should be able to be more typesafe here
  // for the |service| argument, but Service's definition requires Connector's
  // definition and we don't yet support circular mojom imports. Hence the raw
  // message pipe.
  RegisterServiceInstance(Identity identity,
                          handle<message_pipe> service,
                          PIDReceiver& pid_receiver_request) =>
      (ConnectResult result);

  // Binds another Connector pipe to this same implementation. This effectively
  // allows the client to "clone" its Connector arbitrarily many times, for
  // example to mint Connector endpoints for different threads to use.
  Clone(Connector& request);

  // Filter interface requests received from |source| according to the policy
  // specified in this service's manifest in an InterfaceProviderSpec named
  // |spec|.
  //
  // The flow is basically - remote service wishes to (generically) request
  // interfaces from this service, and so sends us an InterfaceProvider request
  // (|source_request|) which it would like us to bind. We forward this request
  // to the Service Manager, passing our actual InterfaceProvider implementation
  // in |target|. The Service Manager will only forward interface requests that
  // were permitted by intersecting |source|'s manifest requirements with the
  // contents of |spec|.
  //
  // DEPRECATED: Please do not introduce new uses of this API, as it will be
  // removed soon. Please instead avoid using InterfaceProvider altogether in
  // favor of explicit factory interfaces. i.e., instead of an InterfaceProvider
  // hooked up to a BinderRegistry, prefer to define something like:
  //
  //   interface MyInterfaceBroker {
  //     GetFoo(Foo& request);
  //     GetBar(Bar& request);
  //   };
  //
  FilterInterfaces(string spec,
                   Identity source,
                   InterfaceProvider& source_request,
                   InterfaceProvider target);
};
