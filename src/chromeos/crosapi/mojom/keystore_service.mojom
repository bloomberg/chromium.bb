// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module crosapi.mojom;

// This interface mirrors the enterprise.platformKeys extension API.
// TODO(https://crbug.com/1128022): Figure out the appropriate API surface for
// long-term stabilization.

// The system has a keystore and a certificate store. Keys are tuples
// of (private key, public key). These are generated by the system and the
// private key is never shared. Certificates provide proof of ownership of a
// private key. There are many uses for keys and certificates -- this interface
// currently focuses on the use cases for the enterprise_platform_keys extension
// API.

// Unless otherwise noted, all certificates are DER encoded X.509. In addition,
// the certificates allow UTF-8 encoding in fields where PrintableString is
// expected to support enterprises with non-compliant DER-encodings. See
// crbug.com/770323 and crbug.com/788655.

// Both keystores and certificate stores have two variants: device and user.
// Device keys/certificates are available to all affiliated users on the device.
// User keys/certificates are only available to the current user.
[Stable, Extensible]
enum KeystoreType {
  kUser = 0,
  kDevice = 1,
};

// Input parameters for RSASSA-PKCS1-v1_5. Parameters othan than modulus_length
// are currently not supported when used as inputs to GenerateKey().
[Stable, Extensible]
struct KeystorePKCS115Params {
  [MinVersion=0]
  uint32 modulus_length@0;
  [MinVersion=1]
  array<uint8>? public_exponent@1;
};

// Input parameters for ECDSA. |named_curve| uses WebCrypto nomenclature.
// Currently "P-256" is the only supported curve.
[Stable, Extensible]
struct KeystoreECDSAParams {
  string named_curve;
};

// A signing algorithm is fully described by choice of algorithm and parameters.
[Stable, Extensible]
union KeystoreSigningAlgorithm {
  KeystorePKCS115Params pkcs115;
  KeystoreECDSAParams ecdsa;
};

// The name of a WebCrypto signing algorithm.
[Stable, Extensible]
enum KeystoreSigningAlgorithmName {
  kUnknown = 0,
  kRsassaPkcs115 = 1,
  kEcdsa = 2,
};

// Recognized WebCrypto signing schemes.
[Stable, Extensible]
enum KeystoreSigningScheme {
  kUnknown = 0,
  kRsassaPkcs1V15None = 1,  // The data is PKCS#1 v1.5 padded but not hashed.
  kRsassaPkcs1V15Sha1 = 2,
  kRsassaPkcs1V15Sha256 = 3,
  kRsassaPkcs1V15Sha384 = 4,
  kRsassaPkcs1V15Sha512 = 5,
  kEcdsaSha1 = 6,
  kEcdsaSha256 = 7,
  kEcdsaSha384 = 8,
  kEcdsaSha512 = 9,
};

// Returned by methods that either return a string, or an error.
[Stable, RenamedFrom="crosapi.mojom.ChallengeAttestationOnlyKeystoreResult"]
union KeystoreStringResult {
  // Implies failure.
  string error_message;

  // Implies success.
  string challenge_response;
};

[Stable]
union KeystoreBinaryResult {
  // Implies failure.
  string error_message;

  // Implies success.
  array<uint8> blob;
};

// Returned by GetCertificates().
[Stable]
union GetCertificatesResult {
  // Implies failure.
  string error_message;

  // Implies success.
  array<array<uint8>> certificates;
};

// Returned by GetKeyStores().
[Stable]
union GetKeyStoresResult {
  // Implies failure.
  string error_message;

  // Implies success.
  array<KeystoreType> key_stores;
};

// Returned by GetPublicKey() on success.
[Stable]
struct GetPublicKeySuccessResult {
  // The public key of the matching certificate.
  array<uint8> public_key;

  // Provides details about the signing algorithm.
  KeystoreSigningAlgorithm algorithm_properties;
};

// Returned by GetPublicKey().
[Stable]
union GetPublicKeyResult {
  // Implies failure.
  string error_message;

  // Implies success.
  GetPublicKeySuccessResult success_result;
};

// This interface is implemented by ash-chrome. It provides lacros-chrome a
// mechanism to modify and query the attestation-only and generate purpose
// keystores.
[Stable, Uuid="308635fd-110b-4f24-bfa8-9f43be31c61e"]
interface KeystoreService {
  // This API serves a challenge to a special "attestation-only" keystore. This
  // keystore only contains 2 private keys (1 for the user, 1 for the device).
  // The challenge must be generated via the Verified Access Web API. If
  // |migrate| is true, then after the attestation, the key is migrated
  // from the attestation-only keystore to the regular keystore. A new
  // "attestation-only" key is generated on demand if a key does not exist
  // because it was recently migrated. If a key is migrated, the expectation is
  // that the caller will later call ImportCertificate() to associate a
  // certificate with the migrated key.
  ChallengeAttestationOnlyKeystore@0(
      string challenge, KeystoreType type, bool migrate) =>
          (KeystoreStringResult result);

  // Returns the keystores available to the client. These are used as inputs to
  // the other methods on this interface.
  [MinVersion=1]
  GetKeyStores@1() => (GetKeyStoresResult result);

  // Returns the certificates in the indicated keystore. The result is an array
  // of DER encoded X.509 certificates.
  [MinVersion=2]
  GetCertificates@2(KeystoreType keystore) => (GetCertificatesResult result);

  // Generates a private/public key-pair with |algorithm| and stores the results
  // in |keystore|. Returns the public key as a binary blob.
  [MinVersion=2]
  GenerateKey@3(KeystoreType keystore, KeystoreSigningAlgorithm algorithm) =>
      (KeystoreBinaryResult result);

  // Adds a DER encoded X.509 certificate to the indicated keystore. Returns
  // empty string on success. It is only valid to call this with a certificate
  // whose corresponding private key is already present in the key store. This
  // must have been previously generated via GenerateKey().
  [MinVersion=2]
  AddCertificate@4(KeystoreType keystore, array<uint8> certificate) =>
      (string error);

  // Removes a DER encoded X.509 certificate from the indicated keystore.
  // Returns empty string on success.
  [MinVersion=2]
  RemoveCertificate@5(KeystoreType keystore, array<uint8> certificate) =>
      (string error);

  // Checks whether |certificate| certifies a key that allows usage of the
  // WebCrypto algorithm |algorithm_name|. If so, returns the key info and
  // details about the signing algorithm. |certificate| must be a DER encoded
  // X.509 certificate.
  [MinVersion=3]
  GetPublicKey@6(array<uint8> certificate,
      KeystoreSigningAlgorithmName algorithm_name) =>
      (GetPublicKeyResult result);

  // Signs some data using a previously generated key, indicated with
  // |public_key|. |scheme| is the WebCrypto signing scheme. |extension_id| is
  // needed to determine if the extension is allowed to use the key.
  // TODO(https://crbug.com/1166105): In the long term it doesn't make sense to
  // pass |extension_id|. We should find a better solution.
  [MinVersion=4]
  Sign@7(KeystoreType keystore, array<uint8> public_key,
      KeystoreSigningScheme scheme,
      array<uint8> data, string extension_id) => (KeystoreBinaryResult result);
};

