// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module gpu.mojom;

import "gpu/ipc/common/capabilities.mojom";
import "gpu/ipc/common/context_result.mojom";
import "gpu/ipc/common/mailbox.mojom";
import "gpu/ipc/common/surface_handle.mojom";
import "gpu/ipc/common/sync_token.mojom";
import "mojo/public/mojom/base/shared_memory.mojom";
import "services/viz/public/mojom/compositing/resource_format.mojom";
import "skia/public/mojom/image_info.mojom";
import "skia/public/mojom/surface_origin.mojom";
import "ui/gfx/geometry/mojom/geometry.mojom";
import "ui/gfx/mojom/buffer_types.mojom";
import "ui/gfx/mojom/color_space.mojom";
import "ui/gfx/mojom/gpu_fence_handle.mojom";
import "ui/gl/mojom/gpu_preference.mojom";
import "url/mojom/url.mojom";

// Maps to its namesake in gpu/command_buffer/common/context_creation_attribs.h.
enum ContextType {
  kWebGL1,
  kWebGL2,
  kOpenGLES2,
  kOpenGLES3,
  kOpenGLES31ForTesting,
  kWebGPU,
};

// Maps to its namesake in gpu/command_buffer/common/context_creation_attribs.h.
enum ContextColorSpace {
  kUnspecified,
  kSRGB,
  kDisplayP3,
};

// Maps to its namesake in gpu/command_buffer/common/scheduling_priority.h.
enum SchedulingPriority {
  kHigh,
  kNormal,
  kLow,
};

// Maps to its namesake in gpu/command_buffer/common/context_creation_attribs.h.
struct ContextCreationAttribs {
  gfx.mojom.Size offscreen_framebuffer_size;
  gl.mojom.GpuPreference gpu_preference = kLowPower;

  // -1 if invalid or unspecified.
  int32 alpha_size = -1;
  int32 blue_size = -1;
  int32 green_size = -1;
  int32 red_size = -1;
  int32 depth_size = -1;
  int32 stencil_size = -1;
  int32 samples = -1;
  int32 sample_buffers = -1;
  bool buffer_preserved = true;
  bool bind_generates_resource = true;
  bool fail_if_major_perf_caveat = false;
  bool lose_context_when_out_of_memory = false;
  bool should_use_native_gmb_for_backbuffer = false;
  bool own_offscreen_surface = false;
  bool single_buffer = false;
  bool enable_gles2_interface = true;
  bool enable_grcontext = false;
  bool enable_raster_interface = false;
  bool enable_oop_rasterization = false;
  bool enable_swap_timestamps_if_supported = false;

  ContextType context_type = kOpenGLES2;
  ContextColorSpace color_space = kUnspecified;
};

struct CreateCommandBufferParams {
  SurfaceHandle surface_handle;
  int32 share_group_id;
  int32 stream_id;
  SchedulingPriority stream_priority;
  ContextCreationAttribs attribs;
  url.mojom.Url active_url;
};

// Corresponds to the definition in gpu/command_buffer/common/constants.h.
[Native]
enum Error;

// Corresponds to the definition in gpu/command_buffer/common/constants.h.
[Native]
enum ContextLostReason;

// Information used by the GPU service to convey the current state of a specific
// CommandBuffer instance. Corresponds to gpu::CommandBuffer::State. See
// gpu/command_buffer/common/command_buffer.h.
struct CommandBufferState {
  int32 get_offset;
  int32 token;
  uint64 release_count;
  Error error;
  ContextLostReason context_lost_reason;
  uint32 generation;
  uint32 set_get_buffer_count;
};

struct ScheduleImageDecodeParams {
  array<uint8> encoded_data;
  gfx.mojom.Size output_size;
  int32 raster_decoder_route_id;
  uint32 transfer_cache_entry_id;
  int32 discardable_handle_shm_id;
  uint32 discardable_handle_shm_offset;
  uint64 discardable_handle_release_count;
  gfx.mojom.ColorSpace target_color_space;
  bool needs_mips;
};

// Main control interface for a GPU process connection. For now an instance of
// this interface is associated with each C++ GpuChannel/Host's underlying
// IPC::Channel interface. Eventually it will replace the IPC::Channel.
interface GpuChannel {
  // Crashes the GPU process in a similar way to how chrome://gpucrash does.
  // This is only supported in testing environments with the GPU benchmarking
  // extension enabled and is otherwise ignored.
  //
  // NOTE: It's important to handle this message early, on the IO thread, in
  // case the main thread is hung. This is the purpose of this message:
  // generating minidumps on the bots, which are symbolized later by the test
  // harness.
  CrashForTesting();

  // Terminates the GPU process with an exit code of 0. This message is handled
  // only in tests when the GPU benchmarking extension is enabled. Its purpose
  // is to enable test coverage of scenarios where the GPU process is
  // intentionally terminated with an exit code of 0.
  TerminateForTesting();

  // A simple no-op message used as a fence to ensure all previously sent
  // messages have been received.
  //
  // NoInterrupt is safe on this message because it's handled immediately on the
  // GPU IO thread, which is never allowed to block.
  [Sync, NoInterrupt] Flush() => ();

  // Tells the GPU process to create a new command buffer. A corresponding
  // CommandBufferStub is created.  If `params` provides a non-null
  // SurfaceHandle, |size| is ignored and it will render directly to the native
  // surface (only the browser process is allowed to create those). Otherwise it
  // will create an offscreen backbuffer of dimensions `size`.
  [Sync, NoInterrupt] CreateCommandBuffer(
      CreateCommandBufferParams params, int32 routing_id,
      mojo_base.mojom.UnsafeSharedMemoryRegion shared_state)
      => (ContextResult result, Capabilities capabilties);

  // The CommandBufferProxy sends this to the CommandBufferStub in its
  // destructor, so that the stub deletes the actual CommandBufferService
  // object that it's hosting.
  [Sync, NoInterrupt] DestroyCommandBuffer(int32 routing_id) => ();

  // Schedules a hardware-accelerated image decode in the GPU process. Renderers
  // should use gpu::ImageDecodeAcceleratorProxy to schedule decode requests
  // which are processed by gpu::ImageDecodeAcceleratorStub on the service side.
  ScheduleImageDecode(ScheduleImageDecodeParams params,
                      uint64 decode_release_count);

  // Sends a batch of DeferredRequests to be executed by the service.
  FlushDeferredRequests(array<DeferredRequest> requests);

  // Creates a StreamTexture associated with the given `stream_id`.
  [Sync] CreateStreamTexture(int32 stream_id) => (bool success);

  // Instructs the command buffer to wait asynchronously until its State is
  // changed by the reader to have a current token value within the (inclusive)
  // range [start, end]. Once in range, the command buffer will reply and
  // unblock the caller.
  //
  // TODO(rockot): This should move to the CommandBuffer interface, but it has
  // unique dispatching constraints which require it to be processed
  // out-of-order from other scheduled messages targeting the command buffer.
  // For now we use a GpuChannel message with a `routing_id` to target a
  // specific CommandBuffer.
  [Sync, NoInterrupt] WaitForTokenInRange(
      int32 routing_id, int32 start, int32 end) => (CommandBufferState state);

  // Instructs the command buffer to wait asynchronously until its State is
  // changed by the reader to have a current get offset within the (inclusive)
  // range [start, end], on the get buffer identified by `set_get_buffer_count`.
  // Once in range, the command buffer will reply and unblock the caller.
  //
  // TODO(rockot): This should move to the CommandBuffer interface, but it has
  // unique dispatching constraints which require it to be processed
  // out-of-order from other scheduled messages targeting the command buffer.
  // For now we use a GpuChannel message with a `routing_id` to target a
  // specific CommandBuffer.
  [Sync, NoInterrupt] WaitForGetOffsetInRange(
      int32 routing_id, uint32 set_get_buffer_count, int32 start, int32 end)
      => (CommandBufferState state);
};

// DeferredRequests are batched locally by clients and sent to the service only
// when flushing the channel via GpuChannelHost's EnsureFlush or VerifyFlush.
struct DeferredRequest {
  // Parameters for the specific type of request.
  DeferredRequestParams params;

  // A list of SyncTokens which must be released before the request can be
  // processed.
  array<SyncToken> sync_token_fences;
};

// Details of a batched request.
union DeferredRequestParams {
  // This request targets a specific command buffer instance.
  DeferredCommandBufferRequest command_buffer_request;

  // This request pertains to shared image management.
  DeferredSharedImageRequest shared_image_request;

  // Sent to indicate the client wants to destroy the StreamTexture identified
  // by this ID.
  [EnableIf=is_android]
  int32 destroy_stream_texture;
};

// Details of a batched request targeting a specific command buffer.
struct DeferredCommandBufferRequest {
  // Identifies the command buffer targeted by this request.
  int32 routing_id;

  // The specific request parameters.
  DeferredCommandBufferRequestParams params;
};

// Details of a batched request targeting a specific command buffer.
union DeferredCommandBufferRequestParams {
  // See AsyncFlushParams.
  AsyncFlushParams async_flush;

  // Destroys a transfer buffer identified by this ID.
  int32 destroy_transfer_buffer;

  // Takes the front buffer into a mailbox. Allows another context to draw the
  // output of this context.
  // NOTE: This exists only to support PNaCl.
  Mailbox take_front_buffer;

  // See ReturnFrontBufferParams.
  ReturnFrontBufferParams return_front_buffer;
};

// Details of a batched request pertaining to shared image management.
union DeferredSharedImageRequest {
  // Sent by clients to record a point in the sequence of pending deferred
  // messages. Actual value is ignored.
  uint8 nop;

  // See CreateSharedImageParams.
  CreateSharedImageParams create_shared_image;

  // See CreateSharedImageWithDataParams.
  CreateSharedImageWithDataParams create_shared_image_with_data;

  // See CreateSharedImageVideoPlanesParams
  [EnableIf=is_win]
  CreateSharedImageVideoPlanesParams create_shared_image_video_planes;

  // See CreateSharedImageWithAHBParams.
  [EnableIf=is_android]
  CreateSharedImageWithAHBParams create_shared_image_with_ahb;

  // See UpdateSharedImageParams.
  UpdateSharedImageParams update_shared_image;

  // Destroys the shared image identified by this Mailbox.
  Mailbox destroy_shared_image;

  // See CreateSwapChainParams.
  [EnableIf=is_win]
  CreateSwapChainParams create_swap_chain;

  // See PresentSwapChainParams.
  [EnableIf=is_win]
  PresentSwapChainParams present_swap_chain;
};

// Asynchronously synchronize the put and get offsets of both processes.
// Caller passes its current put offset. Current state (including get offset)
// is returned in shared memory.
// TODO(sunnyps): This is an internal implementation detail of the gpu service
// and is not sent by the client. Remove this once the non-scheduler code path
// is removed.
struct AsyncFlushParams {
  int32 put_offset;
  uint32 flush_id;
  array<SyncToken> sync_token_fences;
};

// Returns a front buffer taken via TakeFrontBufferParams in a previous
// DeferredRequest. This allows it to be reused.
// NOTE: This exists only to support PNaCl.
struct ReturnFrontBufferParams {
  // The mailbox which last took the front buffer in question.
  Mailbox mailbox;

  // Indicates that the resource was lost and should be destroyed.
  bool is_lost;
};

// Creates a new shared image.
struct CreateSharedImageParams {
  // The mailbox used to identify the shared image.
  Mailbox mailbox;

  // The pixel format of the image.
  viz.mojom.ResourceFormat format;

  // Size in pixels.
  gfx.mojom.Size size;

  // Color space.
  gfx.mojom.ColorSpace color_space;

  // Usage flags corresponding to values defined in
  // gpu/command_buffer/common/shared_image_usage.h.
  uint32 usage;

  // The fence to release once the image is created.
  uint32 release_id;

  // Which corner is considered the origin of the new image.
  skia.mojom.SurfaceOrigin surface_origin;

  // Indicates how the alpha component of each pixel is interpreted.
  skia.mojom.AlphaType alpha_type;
};

// Creates a new shared image and populates it with pixel data from a shared
// memory region previously configured by the client.
struct CreateSharedImageWithDataParams {
  // The mailbox used to identify the shared image.
  Mailbox mailbox;

  // The pixel format of the image.
  viz.mojom.ResourceFormat format;

  // Size in pixels.
  gfx.mojom.Size size;

  // Color space.
  gfx.mojom.ColorSpace color_space;

  // Usage flags corresponding to values defined in
  // gpu/command_buffer/common/shared_image_usage.h.
  uint32 usage;

  // The fence to release once the image is created.
  uint32 release_id;

  // Offset from which to copy data out of the current image upload shared
  // memory region.
  uint32 pixel_data_offset;

  // Size of data to copy out of the current image upload shared memory region.
  uint32 pixel_data_size;

  // If `true`, this is the last usage of the current image upload shared memory
  // region, so the region can be discarded after servicing this request.
  bool done_with_shm;

  // Which corner is considered the origin of the new image.
  skia.mojom.SurfaceOrigin surface_origin;

  // Indicates how the alpha component of each pixel is interpreted.
  skia.mojom.AlphaType alpha_type;
};

// Creates shared images for each plane of a multi-planar GpuMemoryBuffer.
[EnableIf=is_win]
struct CreateSharedImageVideoPlanesParams {
  // Mailboxes for each plane.
  array<Mailbox> mailboxes;

  // Handle for the GpuMemoryBuffer.
  gfx.mojom.GpuMemoryBufferHandle gmb_handle;

  // Size in pixels.
  gfx.mojom.Size size;

  // GpuMemoryBuffer format.
  gfx.mojom.BufferFormat format;

  // Usage flags corresponding to values defined in
  // gpu/command_buffer/common/shared_image_usage.h.
  uint32 usage;

  // The fence to release once the image is created.
  uint32 release_id;
};

// Creates a new shared image from an existing one backed by an AHardwareBuffer.
[EnableIf=is_android]
struct CreateSharedImageWithAHBParams {
  // Mailbox to identify the new image.
  Mailbox out_mailbox;

  // Mailbox identifying the existing shared image whose AHardwareBuffer will
  // back the new image.
  Mailbox in_mailbox;

  // Usage flags corresponding to values defined in
  // gpu/command_buffer/common/shared_image_usage.h.
  uint32 usage;

  // The fence to release once the image is created.
  uint32 release_id;
};

// Updates the contents of a shared image from whatever is backing it, if
// applicable.
struct UpdateSharedImageParams {
  // The mailbox identifying the shared image to update.
  Mailbox mailbox;

  // The fence to release once the image has been updated.
  uint32 release_id;

  // An optional GpuFenceHandle for the server to wait on before updating the
  // image from whatever backs it.
  gfx.mojom.GpuFenceHandle? in_fence_handle;
};

[EnableIf=is_win]
struct CreateSwapChainParams {
  // Mailbox identifying the front buffer of the swap chain.
  Mailbox front_buffer_mailbox;

  // Mailbox identifying the back buffer of the swap chain.
  Mailbox back_buffer_mailbox;

  // Pixel format of the front and back buffers.
  viz.mojom.ResourceFormat format;

  // Size of the buffers.
  gfx.mojom.Size size;

  // Color space of the buffers.
  gfx.mojom.ColorSpace color_space;

  // Usage flags corresponding to values defined in
  // gpu/command_buffer/common/shared_image_usage.h.
  uint32 usage;

  // The fence to release once the swap chain is created.
  uint32 release_id;

  // Which corner is considered the origin of the swap chain's buffers.
  skia.mojom.SurfaceOrigin surface_origin;

  // Indicates how the alpha component of each pixel is interpreted.
  skia.mojom.AlphaType alpha_type;
};

[EnableIf=is_win]
struct PresentSwapChainParams {
  // Mailbox identifying the swap chain to present.
  Mailbox mailbox;

  // The fence to release once the swap chain is presented.
  uint32 release_id;
};
