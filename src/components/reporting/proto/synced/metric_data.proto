// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto2";

option optimize_for = LITE_RUNTIME;

package reporting;

// Diagnostics routine verdict.
enum RoutineVerdict {
  ROUTINE_VERDICT_UNSPECIFIED = 0;
  // Routine ran successfully and no connectivity problem found.
  NO_PROBLEM = 1;
  // Routine ran successfully and connectivity problem found.
  PROBLEM = 2;
  // Routine has not been run.
  NOT_RUN = 3;
}

// Https latency problems.
enum HttpsLatencyProblem {
  HTTPS_LATENCY_PROBLEM_UNSPECIFIED = 0;
  // One or more DNS resolutions resulted in a failure.
  FAILED_DNS_RESOLUTIONS = 1;
  // One or more HTTPS requests resulted in a failure.
  FAILED_HTTPS_REQUESTS = 2;
  // HTTPS request latency is high.
  HIGH_LATENCY = 3;
  // HTTPS request latency is very high.
  VERY_HIGH_LATENCY = 4;
}

// Data that describe the result of the https latency diagnostics routine.
message HttpsLatencyRoutineData {
  // Https latency routine verdict.
  optional RoutineVerdict verdict = 1;
  // Https latency routine problem if a problem occurred.
  optional HttpsLatencyProblem problem = 2;
  // Https latency in milliseconds if routine succeeded or failed because of
  // `HIGH_LATENCY` or `VERY_HIGH_LATENCY`.
  optional int64 latency_ms = 3;
}

// Network connection state.
enum NetworkConnectionState {
  NETWORK_CONNECTION_STATE_UNSPECIFIED = 0;
  // The network is connected and internet connectivity is available.
  ONLINE = 1;
  // The network is connected and not in a detected portal state, but
  // internet connectivity may not be available.
  CONNECTED = 2;
  // The network is connected but a portal state was detected. Internet
  // connectivity may be limited.
  PORTAL = 3;
  // The network is in the process of connecting.
  CONNECTING = 4;
  // The network is not connected.
  NOT_CONNECTED = 5;
}

// Network connection type.
enum NetworkType {
  NETWORK_TYPE_UNSPECIFIED = 0;
  CELLULAR = 1;
  ETHERNET = 2;
  TETHER = 3;
  VPN = 4;
  WIFI = 5;
}

// A single network telemetry data collected at a specific point of time.
message NetworkTelemetry {
  // Unique identifier of the network.
  optional string guid = 1;
  // Current connection state of the network.
  optional NetworkConnectionState connection_state = 2;
  // Signal strength of the network provided only for wireless networks. Values
  // are normalized between 0 to 100 inclusive.
  optional int32 signal_strength = 3;
  // For networks associated with a device, the path of the device.
  optional string device_path = 4;
  // The IP address this interface is bound to, if any.
  optional string ip_address = 5;
  // The gateway IP for this interface, if any.
  optional string gateway = 6;
  // Network connection type.
  optional NetworkType type = 7;
}

// Configured networks telemetry data.
message NetworksTelemetry {
  // List of each network telemetry.
  repeated NetworkTelemetry network_telemetry = 1;
  // Https latency diagnostics routine result.
  optional HttpsLatencyRoutineData https_latency_data = 2;
}

// Security level of the thunderbolt bus.
enum ThunderboltSecurityLevel {
  UNSPECIFIED_THUNDERBOLT_SECURITY_LEVEL = 0;
  // All devices are automatically connected by the firmware. No user approval
  // is needed.
  THUNDERBOLT_SECURITY_NONE_LEVEL = 1;
  // User is asked whether the device is allowed to be connected.
  THUNDERBOLT_SECURITY_USER_LEVEL = 2;
  // User is asked whether the device is allowed to be connected. In addition
  // the device is sent a challenge that should match the expected one based on
  // a random key written to the key sysfs attribute
  THUNDERBOLT_SECURITY_SECURE_LEVEL = 3;
  // The firmware automatically creates tunnels for thunderbolt.
  THUNDERBOLT_SECURITY_DP_ONLY_LEVEL = 4;
  // The firmware automatically creates tunnels for the USB controller and
  // Display Port in a dock. All PCIe links downstream of the dock are removed.
  THUNDERBOLT_SECURITY_USB_ONLY_LEVEL = 5;
  // PCIE tunneling is disabled.
  THUNDERBOLT_SECURITY_NO_PCIE_LEVEL = 6;
};

message ThunderboltInfo {
  optional ThunderboltSecurityLevel security_level = 1;
}

// currently we are only reporting bus device info for thunderbolt, though we
// will certainly add more in the future.
message BusDeviceInfo {
  optional ThunderboltInfo thunderbolt_info = 1;
}

enum MemoryEncryptionState {
  UNSPECIFIED_MEMORY_ENCRYPTION_STATE = 0;
  // The memory encryption state is unknown.
  MEMORY_ENCRYPTION_STATE_UNKNOWN = 1;
  // Memory encrpytion on the device is disabled.
  MEMORY_ENCRYPTION_STATE_DISABLED = 2;
  // Memory encryption on the device uses total memory encryption.
  MEMORY_ENCRYPTION_STATE_TME = 3;
  // Memory encryption on the device uses multi-key total memory encryption.
  MEMORY_ENCRYPTION_STATE_MKTME = 4;
}

enum MemoryEncryptionAlgorithm {
  UNSPECIFIED_MEMORY_ENCRYPTION_ALGORITHM = 0;
  // The memory encryption algorithm being used is unknown.
  MEMORY_ENCRYPTION_ALGORITHM_UNKNOWN = 1;
  // The memory encryption algorithm is using the AES_XTS encryption algorithm
  // with a 128 bit block cypher.
  MEMORY_ENCRYPTION_ALGORITHM_AES_XTS_128 = 2;
  // The memory encryption algorithm is using the AES_XTS encryption algorithm
  // with a 256 bit block cypher.
  MEMORY_ENCRYPTION_ALGORITHM_AES_XTS_256 = 3;
}

message TotalMemoryEncryptionInfo {
  // The state of memory encryption on the device.
  optional MemoryEncryptionState encryption_state = 1;
  // The maximum number of keys that can be used for encryption.
  optional uint32 max_keys = 2;
  // The length of the encryption keys.
  optional uint32 key_length = 3;
  // The encryption algorithm being used on the device.
  optional MemoryEncryptionAlgorithm encryption_algorithm = 4;
}

message MemoryInfo {
  // TME info for the device.
  optional TotalMemoryEncryptionInfo tme_info = 1;
}

// Information about keylocker. This is supported on Intel CPUs.
message KeylockerInfo {
  // If keylocker is supported on the devices CPUs.
  optional bool supported = 1;
  // If keylocker is configured on the devices CPUs.
  optional bool configured = 2;
}

message CpuInfo {
  // Information about keylocker for the devices CPUs.
  optional KeylockerInfo keylocker_info = 1;
}

// Data that is considered immutable, should only be reported on startup and
// policy enablment.
message InfoData {
  // CPU info for the device.
  optional CpuInfo cpu_info = 1;
  // Bus Device info for the device.
  optional BusDeviceInfo bus_device_info = 2;
  // Memory info for the device.
  optional MemoryInfo memory_info = 3;
}

// Audio telemetry data recorded intermittently
message AudioTelemetry {
  // Is active output device mute or not.
  optional bool output_mute = 1;
  // Is active input device mute or not.
  optional bool input_mute = 2;
  // Active output device's volume in [0, 100].
  optional int32 output_volume = 3;
  // Active output device's name.
  optional string output_device_name = 4;
  // Active input device's gain in [0, 100].
  optional int32 input_gain = 5;
  // Active input device's name.
  optional string input_device_name = 6;
}

// Data that can change over time, collected and reported every specific period
// of time or when an event occur.
message TelemetryData {
  // At least one of the following telemetry should be present.

  // Networks telemetry data.
  optional NetworksTelemetry networks_telemetry = 1;
  // Audio telemetry data.
  optional AudioTelemetry audio_telemetry = 2;
}

enum MetricEventType {
  EVENT_TYPE_UNSPECIFIED = 0;
  NETWORK_HTTPS_LATENCY_CHANGE = 1;
  NETWORK_CONNECTION_STATE_CHANGE = 2;
  NETWORK_SIGNAL_STRENGTH_CHANGE = 3;
  AUDIO_SEVERE_UNDERRUN = 4;
}

// Indicates one of the following conditions occurred on the device, data
// associated with the event will be reported as TelemetryData.
message EventData {
  optional MetricEventType type = 1;
}

// Main message to be reported, can contain `InfoData`, `TelemetryData`, or
// `EventData`. Data, associated with an event or collected in response to an
// event, is added as `TelemetryData` along with EventData.
message MetricData {
  // The time from epoch when the data was collected.
  optional int64 timestamp_ms = 1;

  oneof metric_type {
    // Info data collected.
    InfoData info_data = 2;
    // Telemetry data collected.
    TelemetryData telemetry_data = 3;
  }

  // Event data collected.
  optional EventData event_data = 4;
}