// Copyright 2018 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto2";

option optimize_for = LITE_RUNTIME;
option java_package = "org.chromium.chrome.browser.autofill_assistant.proto";
option java_multiple_files = true;

package autofill_assistant;

import "browser/action_strategy.proto";
import "browser/action_value.proto";
import "browser/cud_condition.proto";
import "browser/dom_action.proto";
import "browser/generic_ui.proto";
import "browser/model.proto";
import "browser/view_layout.proto";
import "content/common/proto/semantic_feature_overrides.proto";
import "browser/public/external_action.proto";

// A field trial containing the name of the trial and the name of the
// randomly selected trial group.
message FieldTrialProto {
  optional string trial_name = 1;
  optional string group_name = 2;
}

// Context contains client environment details.
// Next ID: 21
message ClientContextProto {
  message Chrome {
    optional string chrome_version = 1;
    repeated FieldTrialProto active_field_trials = 2;
  }
  oneof client { Chrome chrome = 1; }

  // locale will be the language tag of the default locale. The tag should
  // be a well-formed IETF BCP 47 language tag with language and country code
  // (e.g., "en-US").
  // The intent is to communicate the client language preferences to the server.
  optional string locale = 5;

  // country should be a country code as defined by ISO 3166-1-alpha-2.
  // The intent is to communicate the client's location to the server. Location
  // is extracted from Chrome Variations Service latest country.
  optional string country = 6;

  // Experiment ids string provided by the 'caller'.
  optional string experiment_ids = 7;

  // True if the script is called from a Chrome Custom Tab created for Autofill
  // Assistant.
  optional bool is_cct = 8;

  // True if the onboarding screen was shown to the user.
  optional bool is_onboarding_shown = 10;

  // True if the script was triggered by a direct action.
  optional bool is_direct_action = 9;

  // True if this an in-Chrome triggered flow, rather than an externally
  // triggered one.
  optional bool is_in_chrome_triggered = 17;

  // The type of trigger script that was shown and accepted at the beginning of
  // this flow, if any.
  optional TriggerScriptProto.TriggerUIType trigger_ui_type = 18;

  message DeviceContextProto {
    message VersionProto {
      // The Android SDK version of the device.
      optional int32 sdk_int = 1;
    }
    optional VersionProto version = 1;

    // The manufacturer of the device.
    optional string manufacturer = 2;

    // The model of the device.
    optional string model = 3;
  }
  optional DeviceContextProto device_context = 11;

  enum AccountsMatchingStatus {
    // The account was not present in the intent.
    UNKNOWN = 0;

    // The account in the intent and the current chrome account match.
    ACCOUNTS_MATCHING = 1;

    // The account in the intent and the current chrome account DON'T match.
    ACCOUNTS_NOT_MATCHING = 2;
  }
  // Whether the account from the intent and the chrome account match.
  optional AccountsMatchingStatus accounts_matching_status = 12;

  // Whether a11y (talkback and touch exploration) is enabled or not.
  optional bool accessibility_enabled = 13;

  enum SignedIntoChromeStatus {
    UNDEFINED = 0;

    // There is no account signed into Chrome.
    NOT_SIGNED_IN = 1;

    // An account is signed into Chrome.
    SIGNED_IN = 2;
  }
  optional SignedIntoChromeStatus signed_into_chrome_status = 14;

  // The size of the current Chrome window. This not only includes the part of
  // the window that renders the website but also everything around it
  // (toolbars, omnibox, ...).
  message WindowSize {
    optional int32 height_pixels = 1;
    optional int32 width_pixels = 2;
  }
  optional WindowSize window_size = 15;

  // The current orientation of the device.
  enum ScreenOrientation {
    UNDEFINED_ORIENTATION = 0;
    PORTRAIT = 1;
    LANDSCAPE = 2;
  }
  optional ScreenOrientation screen_orientation = 16;

  // The type of platform the device is running on, e.g. Android, Desktop, or
  // iOS.
  enum PlatformType {
    PLATFORM_TYPE_UNDEFINED = 0;
    PLATFORM_TYPE_ANDROID = 1;
    PLATFORM_TYPE_IOS = 2;
    PLATFORM_TYPE_DESKTOP = 3;
  }
  optional PlatformType platform_type = 20;

  reserved 19;
}

// Get the list of scripts that can potentially be run on a url.
message SupportsScriptRequestProto {
  optional string url = 1;

  // Parameters that can be used to filter the scripts suitable for execution.
  repeated ScriptParameterProto script_parameters = 2;

  optional ClientContextProto client_context = 3;
}

// Parameters for testers and developers of implicit triggering. This proto can
// be specified via the base64-encoded command line switch
// --autofill-assistant-implicit-triggering-debug-parameters. Values will take
// precedence over existing values in case of conflict.
message ImplicitTriggeringDebugParametersProto {
  // The list of additional script parameters to send to the backend. This is
  // mainly intended to allow specifying DEBUG_SOCKET_ID and DEBUG_BUNDLE_ID.
  // Note: only a small set of parameters is allowlisted for GetTriggerScripts,
  // see components/autofill_assistant/browser/script_parameters.cc
  repeated ScriptParameterProto additional_script_parameters = 1;
}

message ScriptParameterProto {
  // Parameter name, as found in the Intent, without prefix.
  optional string name = 3;
  optional string value = 2;
}

// Response of the list of supported scripts.
message SupportsScriptResponseProto {
  repeated SupportedScriptProto scripts = 1;

  // Defines what should happen if no scripts in [scripts] becomes runnable,
  // because of preconditions.
  optional ScriptTimeoutError script_timeout_error = 2;

  optional ClientSettingsProto client_settings = 3;

  // The ScriptStoreConfig to use with the initial GetActions request.
  optional ScriptStoreConfig script_store_config = 6;

  // Semantic selector related policy configuration.
  optional SemanticSelectorPolicy semantic_selector_policy = 7;

  reserved 4, 5;
}

// A privacy sensitive way to look up Capabilities. Allows querying for
// capabilities by hashing the requested domain urls and sending only some of
// the leading bits, such that the recipient will be unable to reconstruct the
// original URL.
message GetCapabilitiesByHashPrefixRequestProto {
  // Required. Number of bits in each hash prefix. Value must be in the range
  // [15, 64].
  optional uint32 hash_prefix_length = 1;
  // Required. Hash prefixes for requested urls. The prefix will be taken as the
  // first `hash_prefix_length` number of bits of this uint64. Other bits will
  // be ignored. CityHash64 should be used to calculate the hashes. Encoding of
  // the domain url prior to hashing should be UTF-8, it should include the
  // http(s) header and exclude the last '/' character.
  // Examples:
  // - https://www.exampledomain.com
  // - https://example.domain.com
  // - https://domain.com
  repeated uint64 hash_prefix = 2 [packed = true];
  // The client context of the device for which you want to know script
  // capabilities.
  // NOTE: Currently, this will only contain the Chrome version number, locale
  // and country for privacy reasons.
  optional ClientContextProto client_context = 3;
  // There is only a subset of parameters allowed to be sent from the client.
  // INTENT parameter is required.
  repeated ScriptParameterProto script_parameters = 4;
}

message GetCapabilitiesByHashPrefixResponseProto {
  message MatchInfoProto {
    // Domain url that matches one of the requested hash prefixes.
    optional string url_match = 1;
    // The list of script parameters for the client to use.
    // Note: The list only contains additional or changed script parameters.
    // This will specifically NOT include mandatory script parameters such as
    // ENABLED or START_IMMEDIATELY, and will also not contain the INTENT.
    // Clients are required to add those parameters themselves if needed to.
    // They are omitted here to reduce the size of the response.
    repeated ScriptParameterProto script_parameters_override = 2;
  }
  // Match information for the requested hash prefixes. No correlation should
  // be assumed between the order of returned info and the order of requested
  // prefixes. Clients are expected to match the returned urls to determine
  // which responses they are interested in.
  repeated MatchInfoProto match_info = 1;
}

// Request to get user data.
message GetUserDataRequestProto {
  message PaymentMethodRequest {
    // The client token, generated by GMS Core.
    optional bytes client_token = 1;
    // The list of supported card networks.
    repeated string supported_card_networks = 2;
    // The list of known payment instruments from a previous call.
    repeated string preexisting_ids = 3;
  }
  message AddressRequest {
    // The list of known addresses from a previous call.
    repeated string preexisting_ids = 1;
  }

  // For logging, to know which run this request has originated from.
  optional uint64 run_id = 1;

  optional bool request_name = 2;
  optional bool request_email = 3;
  optional bool request_phone = 4;
  optional AddressRequest request_shipping_addresses = 8;
  optional PaymentMethodRequest request_payment_methods = 7;

  reserved 5, 6;
}

// Response with user data.
message GetUserDataResponseProto {
  // The locale to be used when creating this data. This can have influence
  // on the potential processing by Autofill.
  optional string locale = 3;

  repeated ProfileProto available_contacts = 1;
  // The identifier of the contact to select. If not specified, the client
  // will use its own heuristics to select a default contact.
  optional string selected_contact_identifier = 5;

  // Available phone numbers to select.
  repeated PhoneNumberProto available_phone_numbers = 10;
  // The identifier of the phone number to select. If not specified,
  // the client will use its own heuristics to select a default payment
  // instrument.
  optional string selected_phone_number_identifier = 11;

  // Available (shipping) addresses to select.
  repeated ProfileProto available_addresses = 4;
  // The identifier of the shipping address to select. If not specified, the
  // client will use its own heuristics to select a default shipping address.
  optional string selected_shipping_address_identifier = 6;
  // An opaque token to launch the GMS address editor for creating a new
  // address.
  optional bytes add_address_token = 8;

  // Available payment instruments to select.
  repeated PaymentInstrumentProto available_payment_instruments = 2;
  // The identifier of the payment instrument to select. If not specified,
  // the client will use its own heuristics to select a default payment
  // instrument.
  optional string selected_payment_instrument_identifier = 7;
  // An opaque token returned by the |GetInstrumentListResponse| to launch
  // the GMS card editor to create a new credit card.
  optional bytes add_payment_instrument_token = 9;
}

// Overlay image to be drawn on top of full overlays.
message OverlayImageProto {
  // TODO(b/170202574): Remove legacy |image_url|.
  // If set, |image_size| is mandatory.
  oneof image {
    // Deprecated, but currently still supported. The image to display.
    string image_url = 1;
    // The image to display.
    DrawableProto image_drawable = 8;
  }
  // The size of the image to display.
  optional ClientDimensionProto image_size = 2;
  // The margin between the top of the page (anchor) and the image.
  optional ClientDimensionProto image_top_margin = 3;
  // The margin between the bottom of the image and the baseline of the text.
  optional ClientDimensionProto image_bottom_margin = 4;
  // The text to display beneath the image. If set, |text_color| and |text_size|
  // are mandatory.
  optional string text = 5;
  // Supported formats: #RRGGBB or #AARRGGBB.
  optional string text_color = 6;
  // The size of the text to display.
  optional ClientDimensionProto text_size = 7;
}

// Next ID: 26
message ClientSettingsProto {
  message IntegrationTestSettings {
    // Disables animations for the poodle and the progress bar.
    optional bool disable_header_animations = 1;
    // Disables change animations in the actions carousel.
    optional bool disable_carousel_change_animations = 2;
  }

  // Time between two periodic script precondition checks.
  optional int32 periodic_script_check_interval_ms = 1;

  // Time between two element checks in the script executor.
  optional int32 periodic_element_check_interval_ms = 2;

  // Run that many periodic checks before giving up unless something happens to
  // wake it up, such as the user touching the screen.
  optional int32 periodic_script_check_count = 3;

  // Time between two element position refreshes, when displaying highlighted
  // areas in prompt state.
  optional int32 element_position_update_interval_ms = 4;

  // Maximum amount of time normal actions should implicitly wait for a selector
  // to show up.
  optional int32 short_wait_for_element_deadline_ms = 5;

  // Time to wait between two checks of the box model, when waiting for an
  // element to become stable, such as before clicking.
  optional int32 box_model_check_interval_ms = 6;

  // Maximum number of checks to run while waiting for the element position to
  // become stable.
  optional int32 box_model_check_count = 7;

  // Maximum time to wait until document has reached "ready" state.
  optional int32 document_ready_check_timeout_ms = 20;

  // How much time to give users to tap undo when they tap a cancel button.
  optional int32 cancel_delay_ms = 12;

  // If the user taps the overlay that many time within |tap_duration| turn the
  // UI off and give them |tap_shutdown_delay| to undo. If 0, unexpected taps
  // are ignored.
  optional int32 tap_count = 13;

  // Reset the unexpected tap counter after that time.
  optional int32 tap_tracking_duration_ms = 14;

  // How much time to give users to tap undo when after |tap_count| unexpected
  // taps where
  optional int32 tap_shutdown_delay_ms = 15;

  // Optional image drawn on top of overlays.
  optional OverlayImageProto overlay_image = 16;

  // Optional settings intended for integration tests.
  optional IntegrationTestSettings integration_test_settings = 17;

  // Optional setting defining the size of the bottom sheet when Talkback is
  // enabled as a fraction of the available height. When set, the bottomsheet
  // will stop resizing automatically in talkback mode. It will always have the
  // specified size instead.
  optional float talkback_sheet_size_fraction = 18;

  // Deprecated, should be moved into |display_strings|.
  message BackButtonSettings {
    // The label of the highlighted "Undo" action.
    optional string undo_label = 2;

    reserved 1;
  }
  optional BackButtonSettings back_button_settings = 19;

  // Settings to define the behavior for showing warnings about slow connection
  // and/or websites to users.
  message SlowWarningSettings {
    enum MessageMode {
      UNKNOWN = 0;
      // The warning message will be appended to the existing status message.
      CONCATENATE = 1;
      // The warning message will replace the current status message.
      REPLACE = 2;
    }
    // Whether to show warnings related to a slow connection to the user.
    optional bool enable_slow_connection_warnings = 1;
    // Whether to show warnings related to a slow website to the user.
    optional bool enable_slow_website_warnings = 2;
    // If true, only one warning will be shown to the user, i.e. either the slow
    // connection or website, depending on which one triggers first.
    optional bool only_show_warning_once = 3;
    // If true, the slow connection warning will be shown only once.
    optional bool only_show_connection_warning_once = 4;
    // If true, the website warning will be shown only once.
    optional bool only_show_website_warning_once = 5;
    // Defines the maximum wait on a dom find element operation before showing
    // the slow website warning.
    optional int32 warning_delay_ms = 6;
    // Defines the threshold above which a roundtrip is considered too slow.
    optional int32 slow_roundtrip_threshold_ms = 7;
    // Defines the number of consecutive slow roundtrips allowed before showing
    // the slow connection warning.
    optional int32 max_consecutive_slow_roundtrips = 8;
    // The message to show as a warning to inform the user of a slow connection.
    // If this is not set, no warning will be shown in case of slow connection.
    optional string slow_connection_message = 9;
    // The message to show as a warning to inform the user of a slow website.
    // If this is not set, no warning will be shown in case of a slow website.
    optional string slow_website_message = 10;
    // The minimum duration that the message will be shown for (only applies to
    // the slow connection messages).
    optional int32 minimum_warning_message_duration_ms = 11;
    // Whether the warning message should replace the current status message or
    // should be concatenated.
    optional MessageMode message_mode = 12;
  }
  optional SlowWarningSettings slow_warning_settings = 21;

  // Strings that are needed for Chrome Client UI.
  enum DisplayStringId {
    // Unspecified value
    UNSPECIFIED = 0;

    // Text label that is shown when autofill assistant cannot help anymore,
    // because of a user action.
    GIVE_UP = 1;

    // Text label shown next to an UNDO button when user action indicate they
    // want to continue on their own.
    MAYBE_GIVE_UP = 2;

    // Text label that is shown when autofill assistant cannot help anymore,
    // because something went wrong.
    DEFAULT_ERROR = 3;

    // Text on the payment request primary button to confirm payment information
    PAYMENT_INFO_CONFIRM = 4;

    // Generic label for a button to continue to the next screen.
    CONTINUE_BUTTON = 5;

    // Text label that is shown when stopping the Autofill Assistant.
    STOPPED = 6;

    // Option shown in the menu when clicking the Autofill Assistant profile
    // icon. Clicking this option will open a feedback sharing dialog.
    SEND_FEEDBACK = 7;

    // A generic term for Close on buttons and menus.
    CLOSE = 8;

    // Title for Chrome's Settings.
    SETTINGS = 9;

    // Undo message for snackbar.
    UNDO = 10;
  }

  // A Chrome display string along with its ID. This is used to create a map of
  // display strings below.
  message DisplayString {
    optional DisplayStringId id = 1;
    optional string value = 2;
  }
  // A map of display strings keyed by the ID. Note that the locale of these
  // strings must be provided in |display_strings_locale|. These strings are
  // ignored if locale is not provided.
  repeated DisplayString display_strings = 22;

  // The locale of |display_strings|. If |display_strings_locale| is not
  // provided, we ignore |display_strings|. When locale
  // is updated/switched to a new locale, we replace the set of
  // |display_strings|, even if empty. The provided locale should be in BCP 47
  // format, e.g. "en-US".
  optional string display_strings_locale = 23;

  // Extra time SelectorObserver has to finish. If it takes longer than
  // max_wait_time + extra_timeout (this value) it assumes something went
  // wrong and fails with a |TIMED_OUT| error.
  optional int32 selector_observer_extra_timeout_ms = 24;

  // SelectorObserver will wait until no DOM mutation notifications are received
  // for this amount of time to check the selectors.
  optional int32 selector_observer_debounce_interval_ms = 25;

  reserved 8 to 11;
}

message ScriptTimeoutError {
  // Wait for that long before considering that scripts preconditions have timed
  // out and executing the script specified in script_path.
  //
  // The script might be called more than once if the script terminates
  // successfully and again still nothing is found after timeout_ms.
  optional int32 timeout_ms = 1;

  // The script to execute when the error happens.
  optional string script_path = 2;
}

// Supported script.
message SupportedScriptProto {
  // This is the internal name of the script.
  optional string path = 1;

  message PresentationProto {
    // Precondition contains a set of conditions that must hold for a script to
    // be executed. No precondition means that a script can run in any case.
    optional ScriptPreconditionProto precondition = 3;

    // Display priority of the script. Lowest number has highest priority, which
    // means a script with priority 0 should be displayed before a script with
    // priority 1.
    optional int32 priority = 5;

    // Optionally map this script to a direct action.
    optional DirectActionProto direct_action = 13;

    // When set to true this script can be run in 'autostart mode'.
    optional bool autostart = 8;

    // When set to true this script will be run from WaitForDom actions with
    // allow_interrupt=true.
    optional bool interrupt = 9;

    // Message to show once the script has been started. This is shown while
    // loading the actions.
    optional string start_message = 14;

    // Show the UI if it's not shown yet. Setting this to false is useful for
    // scripts started by direct actions.
    optional bool needs_ui = 15 [default = true];

    reserved 1, 2, 4, 6, 7, 10 to 12, 16 to 18;
  }
  optional PresentationProto presentation = 2;

  reserved 3;
}

message ScriptPreconditionProto {
  // Pattern of the path parts of the URL, including query and '#''.
  repeated string path_pattern = 5;
  // Domain (exact match) excluding the last '/' character.
  repeated string domain = 6;

  // Combined with AND: all matches must be true for precondition to hold.
  repeated ScriptParameterMatchProto script_parameter_match = 7;

  // Script can only run if the given condition match.
  optional ElementConditionProto element_condition = 10;

  reserved 3, 8, 9;
}

message ScriptParameterMatchProto {
  // Parameter name, as found in the Intent, without prefix.
  optional string name = 4;

  // Checks whether the script parameter is present.
  optional bool exists = 2 [default = true];

  // Checks whether the script parameter has exact value. Empty or missing value
  // is treated as wildcard - any value will pass.
  optional string value_equals = 3;
}

enum PolicyType {
  UNKNOWN_POLICY = 0;
  SCRIPT = 1;
}

message CUPRequestData {
  // A serialized ScriptActionRequestProto.
  optional bytes request = 1;
  // Combination of public key id and random nonce.
  optional bytes query_cup2key = 2;
  // SHA2 hash of the request.
  optional bytes hash_hex = 3;
}

message ScriptActionRequestProto {
  // CUP-signed version of this proto. When set, the rest of the fields in
  // ScriptActionRequestProto should be ignored.
  optional CUPRequestData cup_data = 11;

  optional ClientContextProto client_context = 7;

  // Global payload from the previous response, possibly for another script.
  optional bytes global_payload = 8;

  // Script payload from the previous response, for the same script.
  //
  // For backward compatibility, for initial requests, forward the last returned
  // script_payload.
  optional bytes script_payload = 2;

  oneof request {
    InitialScriptActionsRequestProto initial_request = 4;
    NextScriptActionsRequestProto next_request = 5;
  }

  reserved 6, 9, 10;
}

// Message specifying how to retrieve the scripts. If bundle_path is set, it
// will read that bundle with the associated version.
message ScriptStoreConfig {
  optional string bundle_path = 2;
  optional int64 bundle_version = 3;
}

// Initial request to get a script's actions.
message InitialScriptActionsRequestProto {
  message QueryProto {
    // The backend expects the |script_path| to be a repeated field. This field
    // is expected to contain only one element.
    repeated string script_path = 1;
    // The exact URL on which the script was initially started.
    optional string url = 2;
    optional PolicyType policy = 3;

    reserved 4 to 12;
  }
  optional QueryProto query = 3;

  repeated ScriptParameterProto script_parameters = 2;

  // Specify a bundle and version to run.
  optional ScriptStoreConfig script_store_config = 6;

  reserved 1, 4, 5, 7 to 11;
}

message RoundtripTimingStats {
  // Reports how long it took for the previous roundtrip to the backend to
  // complete.
  optional int64 roundtrip_time_ms = 1;
  // Reports the total client processing time for the executed batch of actions.
  optional int64 client_time_ms = 2;
}

message RoundtripNetworkStats {
  message ActionNetworkStats {
    // The action type.
    optional int32 action_info_case = 1;
    // The size of this action after decoding, in bytes.
    optional int64 decoded_size_bytes = 2;
  }
  // The total size of the received HTTP response body in bytes, before
  // decoding. This is essentially the network footprint of the received
  // response, modulo HTTP headers.
  optional int64 roundtrip_encoded_body_size_bytes = 1;
  // The total size of the received HTTP response body in bytes, after
  // decoding. This is essentially the memory footprint of the received proto,
  // and a baseline to compare the footprint of individual actions with.
  optional int64 roundtrip_decoded_body_size_bytes = 2;
  // The network stats for ALL received actions. Note that this may include
  // actions that were not executed, so this list can be longer than
  // |processed_actions|.
  repeated ActionNetworkStats action_stats = 3;
}

// Next request to get a script's actions.
message NextScriptActionsRequestProto {
  // The result of processing each ActionProto from the previous response. This
  // field must be in the same order as the actions in the original response.
  // It may have less actions in case of failure.
  repeated ProcessedActionProto processed_actions = 1;
  // Contains all roundtrip level (as opposed to action level) timing stats.
  optional RoundtripTimingStats timing_stats = 2;
  // Tracks whether the last roundtrip triggered a slow connection warning and
  // whether it was shown to the user.
  optional SlowWarningStatus slow_connection_warning = 34;
  // Roundtrip network stats for this RPC.
  optional RoundtripNetworkStats network_stats = 3;
}

message CUPResponseData {
  // A serialized ActionsResponseProto.
  optional bytes response = 1;
  // The signature signing both the response, as well as the request hash, key
  // ID, and nonce of the corresponding ScriptActionRequestProto. See
  // https://source.chromium.org/chromium/chromium/src/+/main:docs/updater/cup.md
  // for the signing scheme.
  optional bytes ecdsa_signature = 2;
}

// Response of a script's actions.
message ActionsResponseProto {
  // CUP-signed version of this proto. When set, the rest of the fields in
  // ActionsResponseProto should be ignored.
  optional CUPResponseData cup_data = 11;

  // Opaque data to send to the next ScriptActionRequestProto.
  optional bytes global_payload = 4;

  // Opaque data to send to the next ScriptActionRequestProto for the same
  // script.
  optional bytes script_payload = 2;

  // Actions to be performed in order.
  // Should stop processing as soon as an action fails.
  repeated ActionProto actions = 3;

  // List of scripts to update.
  //
  // The client is expected to update the cache of scripts with this new
  // information. No action is needed when this field is not set. If the field
  // is set with an empty list of scripts, then no script is eligible to run
  // anymore.
  //
  // Note: This is an intermediate solution and the logic associated with this
  // field will eventually be absorbed into the supports script response from
  // the backend.
  message UpdateScriptListProto { repeated SupportedScriptProto scripts = 1; }
  optional UpdateScriptListProto update_script_list = 5;

  // Id of the current run.
  optional uint64 run_id = 12;

  reserved 1, 6 to 10;
}

// RPC request to fetch the available trigger scripts for a particular domain.
message GetTriggerScriptsRequestProto {
  // The exact url for which to fetch the trigger scripts.
  optional string url = 1;
  // The client context.
  // NOTE: Currently, this will only contain the Chrome version number for
  // privacy reasons.
  optional ClientContextProto client_context = 2;
  // Optional script parameters.
  repeated ScriptParameterProto script_parameters = 3;
}

// The RPC response to a |GetTriggerScriptsRequestProto|.
message GetTriggerScriptsResponseProto {
  // The available trigger scripts, if any.
  repeated TriggerScriptProto trigger_scripts = 1;

  // A list of additional domains and subdomains. Trigger scripts will
  // automatically cancel the ongoing session if the user navigates away from
  // the original domain or any of the additional domains.
  repeated string additional_allowed_domains = 2;

  // The amount of time a trigger script may evaluate trigger conditions while
  // invisible. If a trigger script is invisible for this amount of time, it
  // will automatically finish with TRIGGER_CONDITION_TIMEOUT.
  // If not specified, there is no automatic timeout.
  //
  // This is only counted while no trigger script is shown, and the time is
  // reset on tab switch and whenever a trigger script is hidden. Note that this
  // only counts the time in-between checks, so the actual timeout will be
  // slightly longer.
  optional int32 trigger_condition_timeout_ms = 3;

  // The amount of time between consecutive checks of trigger conditions. Should
  // not be too small to limit performance impact.
  optional int32 trigger_condition_check_interval_ms = 4 [default = 1000];

  // The list of script parameters for the client to use. This can be different
  // from the list the client sent in the GetTriggerScriptsRequest.
  //
  // For some flows, the GetTriggerScripts RPC is the first and only
  // communication with the backend prior to the start of the regular flow. As
  // such, the backend needs to send any additional script parameters (such as
  // appropriate overlay colors) back to the client such that the regular flows
  // are guaranteed to have a full set of script parameters when/if they start.
  repeated ScriptParameterProto script_parameters = 5;
}

// A trigger script contains the full specification for a trigger script that is
// run when a specific condition is true, prior to the full run.
message TriggerScriptProto {
  enum TriggerScriptAction {
    UNDEFINED = 0;
    // The current trigger script is cancelled. If the prompt is not currently
    // being shown, this has no effect. If the prompt is currently being shown,
    // the prompt is hidden and the trigger script is restarted once the trigger
    // condition has become false again.
    NOT_NOW = 1;
    // Cancels the current trigger script and does not restart it for this
    // session.
    CANCEL_SESSION = 2;
    // Cancels the current trigger script and prevents trigger scripts from ever
    // running again. TODO(b/172039582): allow a per-domain opt-out.
    CANCEL_FOREVER = 3;
    // Displays a popup to give users additional cancel options.
    SHOW_CANCEL_POPUP = 4;
    // Stop the trigger script and start the regular script.
    ACCEPT = 5;
  }

  // Set of TriggerUIType to group UKM metrics by.
  //
  // The set of available values is defined by AutofillAssistantTriggerUIType in
  // tools/metrics/histograms/enums.xml
  enum TriggerUIType {
    UNSPECIFIED_TRIGGER_UI_TYPE = 0;

    // Explicit trigger requests by some external trigger surface, i.e., a link
    // or button.
    SHOPPING_CART_FIRST_TIME_USER = 1;
    SHOPPING_CART_RETURNING_USER = 2;
    SHOPPING_CHECKOUT_FIRST_TIME_USER = 3;
    SHOPPING_CHECKOUT_RETURNING_USER = 4;
    FOOD_ORDERING_CART_FIRST_TIME_USER = 9;
    FOOD_ORDERING_CART_RETURNING_USER = 10;

    // Implicit trigger requests started by Chrome itself.
    IN_CHROME_SHOPPING_CART_FIRST_TIME_USER = 5;
    IN_CHROME_SHOPPING_CART_RETURNING_USER = 6;
    IN_CHROME_SHOPPING_CHECKOUT_FIRST_TIME_USER = 7;
    IN_CHROME_SHOPPING_CHECKOUT_RETURNING_USER = 8;
    IN_CHROME_FOOD_ORDERING_CART_FIRST_TIME_USER = 11;
    IN_CHROME_FOOD_ORDERING_CART_RETURNING_USER = 12;
  }

  // The |trigger_condition| must be true for the script to trigger.
  optional TriggerScriptConditionProto trigger_condition = 1;

  // The user interface to show.
  optional TriggerScriptUIProto user_interface = 3;

  // What should happen if the user swipe-dismisses the bottom sheet.
  optional TriggerScriptAction on_swipe_to_dismiss = 4
      [default = CANCEL_SESSION];

  // An identifier for the type of trigger UI this trigger represents, for UKM.
  optional TriggerUIType trigger_ui_type = 7;

  reserved 2, 5, 6;
}

message TriggerScriptConditionProto {
  message DocumentReadyStateCondition {
    // The minimum document ready state for the condition to be true.
    optional DocumentReadyState min_document_ready_state = 1;

    // If specified, check the document in the given frame, instead
    // of the main document.
    optional SelectorProto frame = 2;
  }

  oneof type {
    // The condition matches if all of these conditions match.
    TriggerScriptConditionsProto all_of = 1;
    // The condition matches if at least one of these conditions matches.
    TriggerScriptConditionsProto any_of = 2;
    // The condition matches if none of these conditions match.
    TriggerScriptConditionsProto none_of = 3;

    // The condition matches if the specified selector matches the current DOM..
    SelectorProto selector = 8;
    // The condition matches if the user has stored login credentials for the
    // domain.
    Empty stored_login_credentials = 5;
    // The condition matches if the user has never seen a trigger script before.
    Empty is_first_time_user = 6;
    // The condition matches if the client is in the specified experiment.
    int32 experiment_id = 7;
    // The condition matches if the keyboard is hidden.
    Empty keyboard_hidden = 9;
    // The condition describes a parameter value that must be set to trigger.
    ScriptParameterMatchProto script_parameter_match = 10;
    // Pattern of the path parts of the URL, including query and '#'.
    string path_pattern = 11;
    // Domain (exact match), including the scheme (e.g.
    // "https://www.example.com").
    string domain_with_scheme = 12;
    // The condition matches if the DOM state of the specified frame matches
    // |document_ready_state|.
    DocumentReadyStateCondition document_ready_state = 13;
  }

  reserved 4;
}

message TriggerScriptConditionsProto {
  repeated TriggerScriptConditionProto conditions = 1;
}

message TriggerScriptUIProto {
  message ProgressBar {
    repeated DrawableProto step_icons = 1;
    optional int32 active_step = 2;
  }

  message TriggerChip {
    optional ChipProto chip = 1;
    optional TriggerScriptProto.TriggerScriptAction action = 2;
  }
  message Popup {
    message Choice {
      // The text to display.
      optional string text = 1;
      // The action to execute if this popup item is selected.
      optional TriggerScriptProto.TriggerScriptAction action = 2;
    }
    // The available popup items.
    repeated Choice choices = 1;
  }

  // The status message to display.
  optional string status_message = 1;
  // The callout to display. If not specified, no callout will be shown.
  optional string callout_message = 2;
  // The progress bar to display. If not specified, no progress bar will be
  // shown.
  optional ProgressBar progress_bar = 3;
  // The cancel popup, usually associated with a particular chip.
  optional Popup cancel_popup = 4;
  // The available left-aligned chips, specified in order from left to right.
  repeated TriggerChip left_aligned_chips = 5;
  // The available right-aligned chips, specified in order from left to right.
  repeated TriggerChip right_aligned_chips = 6;
  // The status message to display when transitioning from this trigger script
  // to the regular script.
  optional string regular_script_loading_status_message = 7;
  // Whether the visual viewport should be resized to allow scrolling to the
  // bottom of the page while the trigger script is being displayed.
  optional bool resize_visual_viewport = 8;
  // Whether the bottom sheet should temporarily disappear when scrolling down
  // the website, to move out of the way. This setting is ignored if
  // |ui_timeout_ms| is specified.
  //
  // The value of resize_visual_viewport is ignored when scroll_to_hide is true.
  // This allows the backend setting both to true and letting chrome choose
  // scroll_to_hide if it is supported.
  optional bool scroll_to_hide = 9;
  // The amount of time that the UI may be shown to the user. If not specified,
  // there is no limit. This is intended for websites where the UI could block
  // important parts of the website underneath and |scroll_to_hide| does not
  // mitigate the issue. If this field is specified, |scroll_to_hide| will be
  // ignored. |resize_visual_viewport| will be applied if requested.
  //
  // Once hidden, the UI may be shown again the next time the trigger condition
  // is true (same behavior as NOT_NOW). Note that the timeout is disabled if
  // the user taps either the overflow icon or the confirm chip.
  optional int32 ui_timeout_ms = 10;
}

// An action could be performed.
message ActionProto {
  // Wait these many milliseconds before executing the action, if set.
  optional int32 action_delay_ms = 3;

  // Opaque data that should not be interpreted by the client. The client must
  // pass this back unchanged in the next request
  optional bytes server_payload = 4;

  // The action to be executed.
  //
  // WARNING: proto messages in this oneof and all protos they depend on must
  // meet the requirements listed on jspb_parse.h to be callable conveniently
  // from RunJsFlow. In practice, this means don't add any new fields of type
  // bytes, uint32, uint64, fixed32, fixed64, sfixed32 or sfixed64.
  oneof action_info {
    SelectOptionProto select_option = 7;
    NavigateProto navigate = 9;
    PromptProto prompt = 10;
    TellProto tell = 11;
    ShowCastProto show_cast = 12;
    WaitForDomProto wait_for_dom = 19;
    UseCreditCardProto use_card = 28;
    UseAddressProto use_address = 29;
    UploadDomProto upload_dom = 18;
    ShowProgressBarProto show_progress_bar = 24;
    ShowDetailsProto show_details = 32;
    StopProto stop = 35;
    CollectUserDataProto collect_user_data = 36;
    SetAttributeProto set_attribute = 37;
    ShowInfoBoxProto show_info_box = 39;
    ExpectNavigationProto expect_navigation = 40;
    WaitForNavigationProto wait_for_navigation = 41;
    ConfigureBottomSheetProto configure_bottom_sheet = 42;
    ShowFormProto show_form = 43;
    PopupMessageProto popup_message = 44;
    WaitForDocumentProto wait_for_document = 45;
    ShowGenericUiProto show_generic_ui = 49;
    GeneratePasswordForFormFieldProto generate_password_for_form_field = 52;
    SaveGeneratedPasswordProto save_generated_password = 53;
    ConfigureUiStateProto configure_ui_state = 54;
    PresaveGeneratedPasswordProto presave_generated_password = 55;
    GetElementStatusProto get_element_status = 56;
    ScrollIntoViewProto scroll_into_view = 57;
    WaitForDocumentToBecomeInteractiveProto
        wait_for_document_to_become_interactive = 58;
    WaitForDocumentToBecomeCompleteProto wait_for_document_to_become_complete =
        59;
    SendClickEventProto send_click_event = 60;
    SendTapEventProto send_tap_event = 61;
    JsClickProto js_click = 62;
    SendKeystrokeEventsProto send_keystroke_events = 63;
    SendChangeEventProto send_change_event = 64;
    SetElementAttributeProto set_element_attribute = 65;
    SelectFieldValueProto select_field_value = 66;
    FocusFieldProto focus_field = 67;
    WaitForElementToBecomeStableProto wait_for_element_to_become_stable = 68;
    CheckElementIsOnTopProto check_element_is_on_top = 69;
    ReleaseElementsProto release_elements = 70;
    DispatchJsEventProto dispatch_js_event = 72;
    SendKeyEventProto send_key_event = 73;
    SelectOptionElementProto select_option_element = 74;
    CheckElementTagProto check_element_tag = 75;
    CheckOptionElementProto check_option_element = 76;
    SetPersistentUiProto set_persistent_ui = 77;
    ClearPersistentUiProto clear_persistent_ui = 78;
    ScrollIntoViewIfNeededProto scroll_into_view_if_needed = 79;
    ScrollWindowProto scroll_window = 80;
    ScrollContainerProto scroll_container = 81;
    SetTouchableAreaProto set_touchable_area = 82;
    DeleteSelectedPasswordProto delete_password = 83;
    EditSelectedPasswordProto edit_password = 84;
    BlurFieldProto blur_field = 85;
    ResetPendingCredentialsProto reset_pending_credentials = 86;
    SaveSubmittedPasswordProto save_submitted_password = 87;
    UpdateClientSettingsProto update_client_settings = 89;
    JsFlowProto js_flow = 92;
    ExecuteJsProto execute_js = 93;
    RegisterPasswordResetRequestProto register_password_reset_request = 94;
    ExternalActionProto external_action = 95;
  }

  // Set to true to make the client remove any contextual information if the
  // script finishes with this action. It has no effect if there is any other
  // action sent to the client after this one. Default is false.
  optional bool clean_contextual_ui = 33;

  reserved 5, 6, 8, 13 to 17, 20 to 23, 25 to 27, 30, 31, 34, 38, 46 to 48, 50,
      51, 71, 88, 90, 91;
}

// Result of |CollectUserDataProto| to be sent to the server.
message CollectUserDataResultProto {
  optional string card_issuer_network = 1;
  // Whether the integrated terms and conditions approval checkbox was checked.
  optional bool is_terms_and_conditions_accepted = 2;
  // The email address of the payer.
  optional string payer_email = 3;
  // If set, this means that the user triggered the action in
  // |CollectUserDataProto.additional_actions| that has index
  // |additional_action_index|.
  optional int32 additional_action_index = 4;
  // If set, this means that the user clicked on one of the terms and conditions
  // links.
  optional int32 terms_link = 5;

  oneof payload_or_tag {
    // The payload of the chosen login option, from LoginOptionsProto.payload.
    bytes login_payload = 6;
    // The payload of the chosen login option, from LoginOptionsProto.tag.
    string login_tag = 21;
  }
  // The values obtained by the generic user interface.
  optional ModelProto model = 9;
  // The memory keys of all non-empty text inputs, corresponding to the memory
  // keys specified in |TextInputProto|. The values themselves are stored in the
  // client and do not leave the device.
  repeated string set_text_input_memory_keys = 10;
  // The values obtained from the additional sections.
  repeated ModelProto.ModelValue additional_sections_values = 15;
  // Indicates whether the UI was shown to the user. This can be false if
  // only the login section was requested and the choice was implicitly made.
  optional bool shown_to_user = 16;
  // Indicates that the chosen login option was missing the username.
  optional bool login_missing_username = 17;

  reserved 7, 8, 11 to 14, 18 to 20;
}

message ActionTimingStats {
  // Requested delay before executing the action.
  optional int64 delay_ms = 1;
  // Time actively spent by the client to execute the action.
  optional int64 active_time_ms = 2;
  // Time spent waiting for users to complete a task and/or for website
  // loading/navigation.
  optional int64 wait_time_ms = 3;
}

// Enum used to track the slow warnings that can trigger due to slow connection
// or long running wait for dom actions.
enum SlowWarningStatus {
  // The warning wasn't triggered.
  NO_WARNING = 0;
  // The warning was triggered but not shown to the user.
  WARNING_TRIGGERED = 1;
  // The warning was triggered and shown to the user.
  WARNING_SHOWN = 2;
}

message ProcessedActionProto {
  // The action that was processed.
  optional ActionProto action = 1;

  optional ProcessedActionStatusProto status = 2;

  optional ProcessedActionStatusDetailsProto status_details = 19;

  oneof result_data {
    PromptProto.Result prompt_choice = 5;
    // Should be set as a result of CollectUserDataAction.
    CollectUserDataResultProto collect_user_data_result = 15;
    // May be set as a result of WaitForDomProto.
    WaitForDomProto.Result wait_for_dom_result = 22;
    // Should be set as a result of FormAction.
    FormProto.Result form_result = 21;
    WaitForDocumentProto.Result wait_for_document_result = 25;
    // Should be set as a result of ShowGenericUiProto.
    ShowGenericUiProto.Result show_generic_ui_result = 28;
    // Should be set as a result of GetElementStatusProto.
    GetElementStatusProto.Result get_element_status_result = 31;
    // Should be set as a result of UploadDomProto.
    UploadDomProto.Result upload_dom_result = 33;
    // Should be set as a result of CheckOptionElementProto.
    CheckOptionElementProto.Result check_option_element_result = 35;
    // Should be set as a result of SendKeystrokeEventsProto.
    SendKeystrokeEventsProto.Result send_key_stroke_events_result = 36;
    // Should be set as a result of JsFlowProto.
    JsFlowProto.Result js_flow_result = 37;
    // Should be set as a result of SaveSubmittedPassword.
    SaveSubmittedPasswordProto.Result save_submitted_password_result = 38;
  }

  // Reports information about navigation that happened while
  // processing the action. This is meant for debugging.
  optional NavigationInfoProto navigation_info = 20;

  // Reports how long it took for the client to run the action. This does not
  // include the delay specified in action.delay_ms.
  optional int64 run_time_ms = 23;

  // Collects the timing stats related to the action execution.
  optional ActionTimingStats timing_stats = 32;

  // Tracks whether the action triggered a slow website warning and whether it
  // was shown to the user.
  optional SlowWarningStatus slow_warning_status = 34;

  reserved 3, 4, 6 to 14, 16 to 18, 24, 26, 27, 29, 30;
}

// Extended information about the action status, which provides more details
// about what happened than a simple ProcessedActionStatusProto can.
message ProcessedActionStatusDetailsProto {
  // More information included for unexpected errors.
  //
  // Only set for action whose status are OTHER_ACTION_STATUS or
  // UNEXPECTED_JS_ERROR.
  optional UnexpectedErrorInfoProto unexpected_error_info = 1;

  // In some case, such as USER_ABORTED_ACTION and NAVIGATION_ERROR, the status
  // reported by the action is overridden after the action failed, to report a
  // more appropriate error. When that happens, this field contains the original
  // status, to help debugging.
  optional ProcessedActionStatusProto original_status = 2;

  // More information included for autofill related errors.
  optional AutofillErrorInfoProto autofill_error_info = 3;

  // Additional information from the |WebController|.
  optional WebControllerErrorInfoProto web_controller_error_info = 5;

  // Additional information from the |ElementFinder|.
  repeated ElementFinderInfoProto element_finder_info = 6;

  reserved 4;
}

message NavigationInfoProto {
  // Navigation started while processing the current action.
  optional bool started = 1;

  // Navigation ended while processing the current action.
  optional bool ended = 2;

  // Navigation failed before or during the processing of the current action.
  optional bool has_error = 3;

  // Unexpected navigation started while processing the current action. This
  // will happen during some actions, such as PROMPT action but it should
  // normally not happen during scripts that have been updated to use
  // expect_navigation.
  optional bool unexpected = 4;
}

// Extra debugging information included in case of unexpected errors.
//
// Presence of this element either points to a problem in the executed
// javascript (in which case, the relevant js_exception_xxx fields should be
// set) or a bug in the client code.
message UnexpectedErrorInfoProto {
  // Source file, within the client code, where an unexpected error was detected
  // and reported.
  //
  // Only filled for unexpected errors OTHER_ACTION_STATUS and
  // UNEXPECTED_JS_ERROR.
  //
  // This and source_line are only meaningful for the exact version reported in
  // the client context.
  optional string source_file = 1;

  // Line number, within the client's source file, where the error was detected.
  optional int32 source_line_number = 2;

  // JavaScript exception class name, if reporting a JavaScript error.
  optional string js_exception_classname = 3;

  // JavaScript exception line numbers, within the js snippet that was sent to
  // devtools runtime by the client, if reporting a JavaScript error. Together
  // with |js_exception_column_numbers| this forms a stack trace.
  repeated int32 js_exception_line_numbers = 4;

  // JavaScript exception column number, within the js snippet that was sent to
  // devtools runtime by the client, if reporting a JavaScript error. Together
  // with |js_exception_line_numbers| this forms a stack trace.
  repeated int32 js_exception_column_numbers = 5;

  // Error code returned by devtools, if any. 0 is considered a success.
  optional int32 devtools_error_code = 6;

  // Error message returned by devtools, if any.
  optional string devtools_error_message = 7;
}

// Message to report autofill related errors for debugging purposes.
message AutofillErrorInfoProto {
  message AutofillFieldError {
    // The field the error occurred for.
    optional SelectorProto field = 1;

    // The value expression associated with the field that caused the error.
    optional string value_expression = 5;

    oneof error_type {
      // No fallback value for this field.
      bool no_fallback_value = 3;

      // The status of the action.
      ProcessedActionStatusProto status = 4;

      // The field was required and expected to be filled during the fallback
      // flow but was empty in the end.
      bool empty_after_fallback = 6;

      // The field was expected to be cleared during the fallback flow but
      // still had a value in the end.
      bool filled_after_clear = 7;
    }

    reserved 2;
  }

  // Comma separated list of address keys in the client memory when the
  // unexpected error occurred. Memory values are never reported this way since
  // they may contain PII. Only the address key names!
  optional string client_memory_address_key_names = 1;

  // Name of the address key requested in the list of keys in
  // |client_memory_address_key_names|.
  optional string address_key_requested = 2;

  // Whether the client memory at |address_key_requested| pointed to null.
  optional bool address_pointee_was_null = 3;

  // Error status of the Chrome autofill attempt.
  optional ProcessedActionStatusProto autofill_error_status = 4;

  // Errors that occurred during fallback filling of autofill fields.
  repeated AutofillFieldError autofill_field_error = 5;

  // These values should match the values in FullCardRequest::FailureType.
  enum GetFullCardFailureType {
    UNKNOWN_FAILURE_TYPE = 0;

    // The user closed the prompt. The following scenarios are possible:
    // 1) The user declined to enter their CVC and closed the prompt.
    // 2) The user provided their CVC, got auth declined and then closed the
    //    prompt without attempting a second time.
    // 3) The user provided their CVC and closed the prompt before waiting for
    //    the result.
    PROMPT_CLOSED = 1;

    // The card could not be looked up due to card auth declined or failed.
    VERIFICATION_DECLINED = 2;

    // The request failed for technical reasons, such as a closing page or lack
    // of network connection.
    GENERIC_FAILURE = 3;
  }
  // Failure type from the |FullCardRequest|.
  optional GetFullCardFailureType get_full_card_failure_type = 6;
}

// Message to report errors related to WebController execution.
message WebControllerErrorInfoProto {
  enum WebAction {
    UNSPECIFIED_WEB_ACTION = 0;

    // Scroll an element into view by centering it on the page. This uses
    // native JS functionality.
    SCROLL_INTO_VIEW = 1;

    // Waiting for the document ready state to be interactive.
    WAIT_FOR_DOCUMENT_TO_BECOME_INTERACTIVE = 2;

    // Send a click or tap event to an element.
    CLICK_OR_TAP_ELEMENT = 3;

    // Select an option from an HTML dropdown.
    SELECT_OPTION = 4;

    // Scroll the element into view with padding. This uses native JS
    // functionality for the initial scrolling and calculates the scrolling
    // for padding manually.
    SCROLL_INTO_VIEW_WITH_PADDING = 6;

    // Get the |value| attribute of an element.
    GET_FIELD_VALUE = 7;

    // Get any attribute of an element.
    GET_STRING_ATTRIBUTE = 8;

    // Select an element's value. This does only work for text elements.
    SELECT_FIELD_VALUE = 9;

    // Set the |value| attribute of an element.
    SET_VALUE_ATTRIBUTE = 10;

    // Set any attribute of an element.
    SET_ATTRIBUTE = 11;

    // Send a series of keystroke inputs. This requires an element to have
    // focus to receive them.
    SEND_KEYBOARD_INPUT = 12;

    // Get the outer HTML of an element.
    GET_OUTER_HTML = 13;

    // Get the tag of an element.
    GET_ELEMENT_TAG = 14;

    // Set active focus on a field.
    FOCUS_FIELD = 15;

    // Wait for an element position to stabilize before clicking or a tapping.
    // Fails with ELEMENT_UNSTABLE.
    WAIT_UNTIL_ELEMENT_IS_STABLE = 16;

    // Check that the element is on top, usually as part of clicking.
    // Fails with ELEMENT_NOT_ON_TOP.
    ON_TOP = 17;

    // Waiting for a certain document ready state failed.
    WAIT_FOR_DOCUMENT_READY_STATE = 18;

    // Trigger a change event.
    SEND_CHANGE_EVENT = 19;

    // Dispatch a 'duplexweb' event on document.
    DISPATCH_EVENT_ON_DOCUMENT = 20;

    // Send a single key event.
    SEND_KEY_EVENT = 21;

    // Set the selected option of an element.
    SELECT_OPTION_ELEMENT = 22;

    // Send a JS click to the element.
    JS_CLICK_ELEMENT = 23;

    // Check the selected option of an element.
    CHECK_OPTION_ELEMENT = 24;

    // Scroll an element into view only if needed.
    SCROLL_INTO_VIEW_IF_NEEDED = 25;

    // Scroll the window of a frame by a certain amount.
    SCROLL_WINDOW = 26;

    // Scroll the container by a certain amount.
    SCROLL_CONTAINER = 27;

    // Blur an element that might have focus to remove its focus.
    BLUR_FIELD = 28;

    // Execute JS on an element.
    EXECUTE_JS = 29;

    reserved 5;
  }

  // The web-action that failed. This is usually a step in an execution chain
  // for an action.
  optional WebAction failed_web_action = 1;
}

message ElementFinderInfoProto {
  // Tracking ID of the |Selector|.
  optional int64 tracking_id = 1;

  // If the Selector fails to be resolved, this index holds the starting index
  // of filters currently being applied.
  optional int32 failed_filter_index_range_start = 2;

  // If a filter failed, this index holds the filter that was supposed to be
  // applied next.
  optional int32 failed_filter_index_range_end = 3;

  // The original status of |ElementFinder|.
  optional ProcessedActionStatusProto status = 4;

  // If set, the document could not be resolved.
  optional bool get_document_failed = 5;

  enum SemanticInferenceStatus {
    // Unknown error. Should not occur.
    UNKNOWN = 0;
    // The model was run successfully.
    SUCCESS = 1;
    // An unexpected error happened when the model was run. E.g. the frame
    // was not available where it was expected to be.
    UNEXPECTED_ERROR = 2;
    // The model was successfully loaded but could not initialize the executor.
    INITIALIZATION_ERROR = 3;
    // The model could not be loaded. This is unexpected and should not occur.
    MODEL_LOAD_ERROR = 4;
    // The model loading timed out.
    MODEL_LOAD_TIMEOUT = 5;
  }
  message PredictedElement {
    // Whether the inference returned the expectation.
    optional bool matches_css_element = 1;
    // The predicted objective and predicted role of this element.
    optional SelectorProto.SemanticInformation semantic_information = 2;
    // The element's backend node id.
    optional int32 backend_node_id = 3;
  }
  message SemanticInferenceResult {
    // If this is empty, the model inference did not find any results.
    repeated PredictedElement predicted_elements = 1;
    // Status per frame. The order is not predictable, the results are
    // collected async and arrive in random order.
    repeated SemanticInferenceStatus status_per_frame = 2;
  }
  optional SemanticInferenceResult semantic_inference_result = 6;
}

// The pseudo type values come from
// https://chromedevtools.github.io/devtools-protocol/tot/DOM#type-PseudoType.
enum PseudoType {
  UNDEFINED = 0;
  FIRST_LINE = 1;
  FIRST_LETTER = 2;
  BEFORE = 3;
  AFTER = 4;
  BACKDROP = 5;
  SELECTION = 6;
  FIRST_LINE_INHERITED = 7;
  SCROLLBAR = 8;
  SCROLLBAR_THUMB = 9;
  SCROLLBAR_BUTTON = 10;
  SCROLLBAR_TRACK = 11;
  SCROLLBAR_TRACK_PIECE = 12;
  SCROLLBAR_CORNER = 13;
  RESIZER = 14;
  INPUT_LIST_BUTTON = 15;
}

// A reference to one or more elements on the page, possibly nested in frames.
// Next ID: 15
message SelectorProto {
  // Filters for the element on the page. Filter are applied sequentially, using
  // the output of the previous filter as input. The root of these filters is
  // the main frame's document.
  repeated Filter filters = 9;

  // An ID that's used to identify selector in logs, as they pass through
  // different layers. It is passed to the client only as FYI. Client might
  // choose to echo back these ids when reporting specific selectors as
  // matching or not matching.
  optional int64 tracking_id = 10;

  // A filter that starts with one or more elements and returns one on more
  // elements. Filters are meant to be applied sequentially.
  //
  // The returned elements will be sorted by their order in the document.
  // Elements that were matched via the labelled filter will have the same order
  // as their label.
  message Filter {
    oneof filter {
      // Enter the document of an iframe or shadow root. The next filters apply
      // to the document inside of the iframe(s) or on the shadow element.
      //
      // Fails if there are more than one match.
      EmptyFilter enter_frame = 1;

      // Evaluate the given CSS selector on all start elements and use
      // the result as end elements.
      string css_selector = 2;

      // Check the inner text of all start elements, using the Javascript
      // innerText property. Keep only the element whose innerText match the
      // given regular expression.
      TextFilter inner_text = 3;

      // Check the value of all start elements, using the Javascript value
      // property. Keep only the element whose value property match the given
      // regular expression.
      TextFilter value = 4;

      // Select the pseudo-element of the given type associated with the current
      // elements.
      PseudoType pseudo_type = 5;

      // Only keep elements that have a box model, even if it is empty.
      //
      // This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
      // renamed as having a bounding box is not enough to imply visibility.
      BoundingBoxFilter bounding_box = 6;

      // Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
      // not enough matches.
      NthMatchFilter nth_match = 7;

      // Only keep elements that have a pseudo-element with the given content.
      //
      // This only works with BEFORE and AFTER.
      //
      // Note that this just filters out elements. It doesn't select the
      // pseudo-element; use pseudo_type for that.
      //
      // Deprecated: prefer css_style. This should be removed in Chrome M89.
      PseudoElementContent pseudo_element_content = 8;

      // Go from label to the labelled control. Only works starting with current
      // elements that are LABEL.
      //
      // For example if we have:
      //  <label for="someid">First Name</label>...<input id="someid" ...>
      // then labelled, goes from the label to the form element.
      //
      // So, the form element can be accessed as "label~=/FirstName/ labelled".
      // This is especially useful in situations where someid can change.
      //
      // The same selector also works in the case where the element is inside of
      // the label, so we don't need to worry which implementation is used when
      // building the selector:
      //   <label>First Name <input ...></label>
      EmptyFilter labelled = 9;

      // Only keep results that match the given CSS selector.
      string match_css_selector = 11;

      // Only keep elements whose computed style match the given filter. This is
      // based on Window.computedStyle()
      CssStyleFilter css_style = 12;

      // Filter out elements whose center point are covered by another element.
      //
      // This first calls Element.scrollIntoViewIfNeeded to make sure the
      // element can be moved to the viewport, then calls
      // DocumentOrShadowDom.getElementFromPoint and compares the result with
      // the expected element. If the element at point is not the element, a
      // descendant of the element or a label of the element, there is an
      // overlay.
      //
      // Note that:
      //
      // - this filter will also weed out elements with no bounding box. Check
      // with bounding_box { } first.
      //
      // - this filter will also weed out elements that cannot be scrolled into
      // the viewport.
      //
      // - an element might be covered by an overlay and still be visible if the
      // overlay is transparent. An element might be covered by an overlay and
      // still be clickable, if the overlay intercepts and forwards events.
      // Overlays with pointer-events set to none are ignored.
      //
      // - an element might be only partially covered by an overlay. This filter
      // only checks the center of the element, since this is where the click
      // action sends its clicks or taps.
      //
      // - this filter only detects overlays in the current frame. To detect
      // overlays that cover the frame element itself, apply this filter on the
      // frame element before calling enter_frame.
      OnTopFilter on_top = 13;

      // Filtering against an element property.
      //
      // This filter replaces |inner_text| and |value|.
      PropertyFilter property = 14;

      // Retrieve parent of current elements.
      EmptyFilter parent = 15;
    }

    reserved 10;
  }

  // A regular expression value for filtering.
  message PropertyFilter {
    // The property to filter against.
    optional string property = 1;

    oneof value {
      TextFilter text_filter = 2;
      AutofillValueRegexp autofill_value_regexp = 3;
    }
  }

  // A way of filtering elements by their pseudo-element content.
  message PseudoElementContent {
    optional PseudoType pseudo_type = 1;
    optional TextFilter content = 2;
  }

  // Only keep elements whose computed style match the given filter. This is
  // based on Window.computedStyle()
  //
  // See
  // https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle
  message CssStyleFilter {
    // CSS property name.
    optional string property = 3;

    // Name of the pseudo-element whose style should be checked. Leave it unset
    // or set to the empty string to check the style of the real element.
    //
    // This is the pseudoElt argument of JavaScript's
    // window.getComputedStyle(element, [, pseudoElt]).
    optional string pseudo_element = 4;

    // By default the text filter in |value| must match. Set this to false to
    // require the text condition not to match.
    optional bool should_match = 5 [default = true];

    // CSS property value match.
    //
    // Valid computed CSS properties always have a value, even if it's a default
    // value. The default value depends on the property.
    optional TextFilter value = 6;

    reserved 1, 2;
  }

  // Only keep elements that have a bounding box.
  message BoundingBoxFilter {
    // If require_nonempty=false, which is the default, require elements to have
    // at least one bounding rect returned by Element.getClientRects()
    //
    // If require_nonempty=true, additionally require the element's bounding
    // client rect to have a nonzero width and height.
    optional bool require_nonempty = 1;
  }

  // Filter out elements covered by other elements, such as overlays.
  message OnTopFilter {
    // If true, scroll the element into view before checking whether
    // it's on top.
    //
    // The logic for checking whether an element is on top only works on
    // elements that are positioned within the current viewport. Setting it to
    // false turns off automatic scrolling to make the element visible, so the
    // caller must make sure it's already the case.
    optional bool scroll_into_view_if_needed = 1 [default = true];

    // If true and the element cannot be scrolled into view, so the filter
    // cannot check whether the element is on top, keep the element in the match
    // set.
    //
    // This can be combined with scroll_into_view_if_needed=false to make
    // this filter best effort and only check elements that are already in view.
    optional bool accept_element_if_not_in_view = 2;
  }

  message EmptyFilter {}

  message NthMatchFilter {
    // Take the match at the given |index|.
    optional int32 index = 1;
  }

  // If set, and the model inference is enabled on the client, will run model
  // inference and compare if the found element has been inferred along
  // the expectation.
  message SemanticInformation {
    // The objective we expect this Selector to have.
    optional int32 objective = 1;
    // The role we expect this Selector to have.
    optional int32 semantic_role = 2;
    // Timeout, defaults to 5s.
    // TODO(b/218482826): Consider moving this to settings.
    optional int32 model_timeout_ms = 3 [default = 5000];
    // If true, ignore the objective and treat it as a wildcard '*' when
    // matching.
    optional bool ignore_objective = 4;
    // If true, executes CSS alongside, comparing the results at the end. Uses
    // the CSS result going forward.
    optional bool check_matches_css_element = 5;
  }
  optional SemanticInformation semantic_information = 11;

  reserved 1 to 8;
}

enum OptionalStep {
  STEP_UNSPECIFIED = 0;
  SKIP_STEP = 1;
  REPORT_STEP_RESULT = 2;
  REQUIRE_STEP_SUCCESS = 3;
}

// Contain all arguments to perform a select option action. This action also
// fires a "change" event on the element. If the option is not found, an
// |OPTION_VALUE_NOT_FOUND| error is returned. If the action is used on an
// element that is not an HTML <select> element, an |INVALID_TARGET| error is
// returned.
message SelectOptionProto {
  // The drop down element on which to select an option.
  optional SelectorProto element = 2;

  oneof value {
    // Value of the option to use.
    TextFilter text_filter_value = 7;
    // A value from an Autofill source. Note that this must be preceded by a
    // |CollectUserDataAction|.
    AutofillValueRegexp autofill_regexp_value = 8;
  }

  // Defines which attribute to use for comparing the option to the expected
  // value.
  enum OptionComparisonAttribute {
    NOT_SET = 0;
    // Compare the option's value.
    VALUE = 1;
    // Compare the option's label.
    LABEL = 2;
  }
  optional OptionComparisonAttribute option_comparison_attribute = 6;

  // If |strict|, only one match is allowed. Multiple matches will return a
  // |TOO_MANY_OPTION_VALUES_FOUND| error. If not |strict| and multiple matches
  // are found, the first one is selected.
  optional bool strict = 9;

  reserved 1, 3 to 5;
}

// Contains an update to ClientSettings. This is used to update Display Strings
// for locales from the backend.
message UpdateClientSettingsProto {
  // The new ClientSettings to be used. Please see comments on how display
  // strings are updated for display string locales in the description of
  // |ClientSettingsProto|.
  optional ClientSettingsProto client_settings = 1;
}

// Contain a localized text message from the server.
message TellProto {
  message TextToSpeech {
    // Optional field to override the text to synthesize and play using
    // TTS ('message' is used as the default text to play).
    optional string tts_message = 1;

    // Whether the current TTS message should be played immediately or not. If
    // this is false, the message will instead only play when the user taps the
    // TTS icon.
    optional bool play_now = 2;
  }

  // The message to show in the status bar. The behavior is now the following
  //
  //  * If the field is set, the status bar is updated (explicitly setting an
  //    empty string clears the status bar).
  //  * If the field is not set, the status bar is not updated.
  optional string message = 1;

  // Show the UI if it's not shown yet, such as when a script has been started
  // by a direct action.
  optional bool needs_ui = 2 [default = true];

  // Config for TextToSpeech (TTS) functionality.
  optional TextToSpeech text_to_speech = 3;
}

// Contain all arguments to show cast on an element.
message ShowCastProto {
  message TopPadding {
    oneof top_padding {
      // Padding in CSS pixels. Eg. 20.
      int32 pixels = 1;
      // Ratio in relation to the window.innerHeight. Eg. 0.25.
      float ratio = 2;
    }
  }

  // Element to scroll to.
  optional SelectorProto element_to_present = 1;

  // Restrict interaction to a series of rectangular areas.
  optional ElementAreaProto touchable_element_area = 6;

  // The padding that will be added between the focused element and the top.
  // If |container| is specified, this will indicate the padding between the
  // focused element and the top of the container instead.
  optional TopPadding top_padding = 7;

  // Configure whether the scrolling should wait for the element to be stable
  // before scrolling.
  //
  // If set to REQUIRE_STEP_SUCCESS, scrolling may fail with ELEMENT_UNSTABLE.
  optional OptionalStep wait_for_stable_element = 9;

  // Maximum rounds to stable check.
  optional int32 stable_check_max_rounds = 10 [default = 50];

  // Interval for stable check in ms.
  optional int32 stable_check_interval_ms = 11 [default = 200];

  // Optional: the container to be scrolled to focus |element_to_present|. If
  // not set, the window will be scrolled.
  optional SelectorProto container = 12;

  reserved 2 to 5, 8;
}

// Set the touchable and restricted area of the overlay.
message SetTouchableAreaProto {
  optional ElementAreaProto element_area = 1;
}

// An area made up of rectangles whole border are made defined by the position
// of a given set of elements.
message ElementAreaProto {
  // A rectangle, drawn by one or more elements.
  //
  // The rectangle is the smallest rectangle that includes all listed elements.
  message Rectangle {
    repeated SelectorProto elements = 1;

    // If true, the width of the rectangle always corresponds to the width of
    // the screen.
    optional bool full_width = 2;
  }

  // The rectangles that will be highlighted and touchable.
  repeated Rectangle touchable = 1;

  // The rectangles that should be neither highlighted nor touchable. Those
  // rectangles have precedence over the |touchable| rectangles.
  repeated Rectangle restricted = 2;
}

// Message used to indicate what form fields should be filled with what
// information coming from either the address or the credit card.
message RequiredFieldProto {
  // A value expression containing any number of |key| placeholders, where the
  // |key| is an integer corresponding to entries from field_types.h or
  // |AutofillFormatProto::AutofillAssistantCustomField|.
  // Example:
  // * 3 -> First name.
  // * 51 -> Full card name.
  // Note that the set of actually available fields are outside of our
  // control and are retrieved automatically.
  // An empty value expression will clear the field.
  optional ValueExpression value_expression = 12;

  // The element to fill.
  optional SelectorProto element = 2;

  // The strategy used to execute filling the value.
  // This is only considered for text fields and ignored for dropdowns.
  optional KeyboardValueFillStrategy fill_strategy = 7;

  // Delay between two key presses when simlulating.
  // This is only considered for text fields and ignored for dropdowns.
  optional int32 delay_in_millisecond = 4 [default = 20];

  // The strategy used to select a value option. If no
  // |option_comparison_value_expression_re2| is set, this is used to
  // differentiate between "starts with" and "match".
  optional DropdownSelectStrategy select_strategy = 8;

  // The attribute to compare for selecting an option.
  // This is only considered for dropdowns and ignored for text fields. If set,
  // takes precedence over |select_strategy|.
  optional SelectOptionProto.OptionComparisonAttribute
      option_comparison_attribute = 13;

  // In case of a dropdown, this should be used instead of the
  // |value_expression_proto|. If it's empty, |value_expression_proto| will be
  // used. This is only considered for dropdowns and ignored for text fields.
  optional ValueExpressionRegexp option_comparison_value_expression_re2 = 14;

  // Fill in the value even if it's non-empty. This is useful to work around
  // cases where the way Autofill sets the field doesn't work on the website.
  optional bool forced = 5;

  // The field is optional. If there is no value from Autofill available or
  // the element is not found, the field will be skipped.
  optional bool is_optional = 11;

  // For JavaScript implemented dropdowns. This first clicks on the |element|,
  // then waits for |option_element_to_click| to appear and clicks it. The
  // selector must match a generic option, an |inner_text_pattern| will be
  // added to this element reference to match a single option.
  // Both clicks use the same |click_type|.
  optional SelectorProto option_element_to_click = 9;
  optional ClickType click_type = 10;

  reserved 1, 3, 6;
}

// Fill a form with an address if there is, otherwise fail this action.
message UseAddressProto {
  oneof address_source {
    // The client memory key from which to retrieve the address.
    string name = 1;
    // The client model identifier from which to retrieve the address.
    string model_identifier = 9;
  }

  // Reference to an element in the form that should be filled.
  optional SelectorProto form_field_element = 4;

  // An optional list of fields that should be filled by this action.
  repeated RequiredFieldProto required_fields = 6;

  // If true, this skips the Autofill step jumping straight to the
  // |required_fields|.
  optional bool skip_autofill = 10;

  reserved 2, 7, 8;
}

// Fill a form with a credit card if there is one stored in client memory,
// otherwise fail this action.
message UseCreditCardProto {
  // The client model identifier from which to retrieve the credit card.
  // If not specified, will use the card stored in client memory instead.
  optional string model_identifier = 4;

  // A reference to the card number field in the form that should be filled.
  optional SelectorProto form_field_element = 3;

  repeated RequiredFieldProto required_fields = 7;

  // If true, this skips the Autofill step jumping straight to the
  // |required_fields|.
  optional bool skip_autofill = 8;

  // If true, this skips resolving the CreditCard. The card can be used to fill
  // fields like name or expiration date. Be aware that you cannot fill CVC or
  // credit card number without resolving the card.
  // This skips the autofill step, regardless of |skip_autofill|.
  optional bool skip_resolve = 9;

  reserved 1, 5, 6;
}

// Ask Chrome to wait for an element in the DOM. This can be used to only
// proceed to the next action once the page is ready.
message WaitForDomProto {
  // Fail after waiting this amount of time.
  optional int32 timeout_ms = 1;

  // Wait until this condition becomes true. If, at the end of the timeout, the
  // condition is not true, returns ELEMENT_RESOLUTION_FAILED.
  // The |wait_condition| can be used to store matches on the client by
  // annotating a |match| condition with a |client_id|. Note that matches that
  // were not found will be removed from the store, e.g. if they were entered
  // by a previous |WaitForDomProto|. The store also gets updated if the action
  // fails.
  optional ElementConditionProto wait_condition = 9;

  // If true, run scripts flagged with 'interrupt=true' as soon as their
  // preconditions match.
  optional bool allow_interrupt = 3;

  reserved 4 to 8;

  // Result to include into ProcessedActionProto.
  message Result {
    // Payload of all matching conditions, from ElementConditionProto.payload.
    repeated bytes matching_condition_payloads = 1;

    // Payload of all matching conditions, from ElementConditionProto.tag.
    repeated string matching_condition_tags = 2;
  }
}

// A condition that expects a specific combination of elements. An empty
// condition is true.
message ElementConditionProto {
  oneof type {
    // The condition matches if all of these conditions match.
    ElementConditionsProto all_of = 1;

    // The condition matches if at least one of these conditions matches.
    ElementConditionsProto any_of = 2;

    // The condition matches if none of these conditions match.
    ElementConditionsProto none_of = 3;

    // The condition matches if the given element exists. An empty
    // ElementReference never match.
    SelectorProto match = 4;
  }

  // A payload that identifies this condition. WaitForDom puts this payload
  // into the result. This is ignored outside of WaitForDom.
  //
  // Prefer using tag.
  optional bytes payload = 5;

  // A tag that is echoed back to WaitForDom.Result if the condition matches.
  //
  // This is ignored outside of WaitForDom.
  optional string tag = 8;

  // Optional. If set, the element of |match| will be stored under this
  // identifier on the client. If |require_unique_element| is not set to true,
  // the first match will be stored.
  optional ClientIdProto client_id = 6;

  // Optional. If set to true, the finding of element of |match| will be done
  // in a strict manner, failing if multiple elements match the Selector. By
  // default the matching is non-strict, selecting the first match.
  optional bool require_unique_element = 7;
}

message ElementConditionsProto {
  repeated ElementConditionProto conditions = 1;
}

// Volatile upload of a portion of the dom for backend analysis, does not store
// anything.
message UploadDomProto {
  message Result {
    // The outer HTML of the element(s) matched by |tree_root|.
    repeated string outer_htmls = 1;
  }

  // The element that should be a root of uploaded DOM. If empty then the whole
  // page is returned.
  optional SelectorProto tree_root = 1;

  // Whether |tree_root| can match multiple elements. If false and multiple
  // elements are matched, this action will fail with TOO_MANY_MATCHES.
  optional bool can_match_multiple_elements = 2;

  // Whether innerText of DOM should be included.
  optional bool include_all_inner_text = 3;
}

// Shows the progress bar.
message ShowProgressBarProto {
  oneof progress_indicator {
    // Value between 0 and |N| (where N is the size of the initial
    // |step_icons|) indicating the current step the flow is in, marking
    // all previous steps as complete. The active step will not be marked as
    // complete but instead be marked as active with a pulsating animation.
    // Setting the value to |N| or -1 will mark all steps as complete with no
    // step being active anymore.
    int32 active_step = 8;

    // The string reference of an icon defined in the
    // |StepProgressBarConfiguration|. This sets the |active_step| to that icon
    // with the same logic as |active_step| itself.
    string active_step_identifier = 11;

    // Completes the progress in whichever progress bar is active.
    bool complete_progress = 12;
  }

  // Whether the step progress bar should go into an error state.
  // If the active step is smaller than |N|, this will simply mark the last icon
  // as failed. If the active step is |N|, meaning that all steps have been
  // completed, this will mark the entire progress bar as failed.
  optional bool error_state = 10;

  // Hide the progress bar in the UI.
  optional bool hide = 7;

  message StepProgressBarIcon {
    optional DrawableProto icon = 1;

    // The reference identifier of this step.
    optional string identifier = 2;
  }

  // The configuration of the step progress bar. Only has an impact if the new
  // progress bar is being used. This configuration should only be sent once in
  // the initial call of the progress bar, as each appearance may cause the
  // progress bar being rerendered. The previous configuration will be carried
  // over in each new progress |ShowProgressBarAction|.
  message StepProgressBarConfiguration {
    // Set the icons for the new progress bar. The size of the |step_icons|
    // gives the length of the progress bar. As such an empty list is not
    // supported. The list needs to be at least 2 items long.
    repeated StepProgressBarIcon annotated_step_icons = 3;

    reserved 1, 2;
  }
  optional StepProgressBarConfiguration step_progress_bar_configuration = 9;

  reserved 1 to 6;
}

// Controls the browser navigation.
message NavigateProto {
  oneof value {
    // Navigate to the given URL.
    string url = 1;
    // Navigate backward in the history. Action will return PRECONDITION_FAILED
    // if it is not possible.
    bool go_backward = 2;
    // Navigate forward in the history. Action will return PRECONDITION_FAILED
    // if it is not possible.
    bool go_forward = 3;
  }
}

// Specify from which point in the script navigation is expected for the next
// call to WaitForNavigation.
message ExpectNavigationProto {}

// Wait for the browser to have navigated to a new page since the last
// ExpectNavigation or Navigate. This returns as soon as an HTTP response that's
// not a redirect was received for the new page, possibly before even loading
// the page content.
//
// Will return immediately if navigation already happened.
//
// Client errors:
//   NAVIGATION_ERROR if navigation failed
//   TIMED_OUT if timed out waiting for navigation to start
//   INVALID_ACTION no ExpectNavigation or Navigate action was executed in the
//     current script.
message WaitForNavigationProto {
  // How long to wait for navigation to start before failing with client status
  // TIMED_OUT. The action waits 20s by default.
  //
  // This is usually used to track cases where expected navigation doesn't
  // happen, because, for example, a click wasn't registered.
  optional int32 timeout_ms = 1;
}

// Chrome document.readyState values.
//
// Number is significant, as the document goes through these state in order,
// from initialized to complete.
enum DocumentReadyState {
  option allow_alias = true;

  DOCUMENT_UNKNOWN_READY_STATE = 0;
  DOCUMENT_UNINITIALIZED = 1;
  DOCUMENT_LOADING = 2;
  DOCUMENT_LOADED = 3;
  DOCUMENT_INTERACTIVE = 4;
  DOCUMENT_COMPLETE = 5;

  // Maximum value above.
  DOCUMENT_MAX_READY_STATE = 5;
}

// Wait for the document to be ready before proceeding.
//
// Client errors:
//   TIMED_OUT if timed out waiting for an acceptable state.
//   ELEMENT_RESOLUTION_FAILED if the specified frame selector could not be
//   found.
message WaitForDocumentProto {
  // Maximum amount of time to wait for the state to change. Set it to 0 to
  // check once and report the result immediately, without waiting.
  optional int32 timeout_ms = 1 [default = 5000];

  // If specified, check the document in the given frame, instead
  // of the main document.
  optional SelectorProto frame = 2;

  // The minimum ready state needed to satisfy the requirement.
  optional DocumentReadyState min_ready_state = 3
      [default = DOCUMENT_INTERACTIVE];

  message Result {
    // The ready state found when the action started.
    optional DocumentReadyState start_ready_state = 1;

    // The ready state found when the action ended.
    //
    // This is filled even when the action fails, so it is not guaranteed to
    // match min_ready_state.
    optional DocumentReadyState end_ready_state = 2;
  }
}

// Show backend-specified user interface elements to the user.
//
// Note that this action will behave similar to a prompt, i.e., it requires a
// specific EndAction interaction (usually tied to tapping a Chip) to end.
//
// Client errors:
//   INVALID_ACTION if |generic_user_interface| was ill-defined or incomplete,
//   or if the client failed to instantiate the UI for some reason. The Chrome
//   log should contain additional information about the issue, if verbose
//   logging is enabled (suggested level: 2 or 3).
message ShowGenericUiProto {
  message RequestUserData {
    message AdditionalValue {
      // The client memory identifier (from |UserData|).
      optional string source_identifier = 1;
      // The model identifier to write the value to (to |UserModel|).
      optional string model_identifier = 2;
    }
    // Additional values to write from |UserData| to |UserModel|.
    repeated AdditionalValue additional_values = 1;
  }
  message Result {
    // The model containing the values for all keys specified in
    // |output_model_identifiers|.
    optional ModelProto model = 1;
    // Set to true if the action was interrupted by a navigation event.
    optional bool navigation_ended = 2;
  }

  // The generic user interface to show.
  optional GenericUserInterfaceProto generic_user_interface = 1;

  // The set of model identifiers to write to the result. Note: this must be a
  // subset of the input model identifiers!
  repeated string output_model_identifiers = 2;

  message PeriodicElementChecks {
    message ElementCheck {
      // The element condition to be checked during the action.
      optional ElementConditionProto element_condition = 1;
      // The model identifier to write the result to.
      optional string model_identifier = 2;
    }
    repeated ElementCheck element_checks = 1;
  }
  optional PeriodicElementChecks periodic_element_checks = 6;
  // When set to true, end this action on navigation events. The result will
  // have |navigation_ended| set to true.
  optional bool end_on_navigation = 7;
  // If true, run scripts flagged with |interrupt=true| as soon as their
  // preconditions match, then go back to the parent action.
  optional bool allow_interrupt = 8;
  // If specified, will write the requested values from |UserData| to
  // |UserModel|. Will fail the action with PRECONDITION_FAILED if any of the
  // requested values is missing. Note that all values will have
  // |is_client_side_only| set to true.
  optional RequestUserData request_user_data = 9;

  reserved 3 to 5, 10;
}

// Show backend-specified user interface elements to the user until dismissed.
//
// The UI will be shown until cleared by ClearPersistentUi or overwritten
// by a subsequent SetPersistentUi.
// The Ui is also cleared at the end of the script if it ended in error or if
// the last action had |clean_contextual_ui| = true.
//
// Client errors:
//   INVALID_ACTION if |generic_user_interface| was ill-defined or incomplete,
//   or if the client failed to instantiate the UI for some reason. The Chrome
//   log should contain additional information about the issue, if verbose
//   logging is enabled (suggested level: 2 or 3).
message SetPersistentUiProto {
  // Required. The generic user interface to show.
  //
  // The following interaction callbacks aren't supported:
  // - SetUserActions
  // - ToggleUserAction
  // - EndAction
  optional GenericUserInterfaceProto generic_user_interface = 1;
}

// Clears the Ui set by SetPersistentUi.
message ClearPersistentUiProto {}

// Allow choosing one or more possibility. If ShowCast was called just
// before, allow interaction with the touchable element area, otherwise don't
// allow any interactions.
message PromptProto {
  // Display this message to the user.
  optional string message = 1;

  // A choice that can be triggered:
  // - by clicking on a chip, if a chip is set
  // - by triggering a direct action, if direct action names are set
  // - indirectly, DOM change, if auto_select_when if set
  //
  // One of these protos must is transmitted as-is back to the server as part of
  // ProcessedActionProto.
  message Choice {
    // The chip to display to the UI.
    optional ChipProto chip = 11;

    // Auto-select this choice when the condition is met.
    optional ElementConditionProto auto_select_when = 15;

    // This chip is only visible or enabled if this condition is met.
    optional ElementConditionProto show_only_when = 16;

    // Disable the chip instead of hiding it completely, if the preconditions
    // don't match.
    optional bool allow_disabling = 9;

    // Server payload originally sent by the server. This should
    // be transmitted as-is by the client without interpreting.
    //
    // Prefer using tag.
    optional bytes server_payload = 5;

    // Tag set by the server. It is put into PromptProto.Result.tag
    optional string tag = 18;

    reserved 4, 6, 8, 12 to 14, 17;
  }
  repeated Choice choices = 4;

  // If true, run scripts flagged with 'interrupt=true' as soon as their
  // preconditions match, then go back to the prompt.
  optional bool allow_interrupt = 5;

  // If this is true, then we do not force expand the sheet when entering the
  // prompt state. When false or not set, this keeps the default behavior.
  optional bool disable_force_expand_sheet = 6;

  // If this is true, go into browse mode where navigation and user gestures
  // like go_back do not shut down autofill assistant.
  // TODO(marianfe): Consider introducing a BrowseAction instead.
  optional bool browse_mode = 7;

  // EXPERIMENTAL.
  // Only relevant if |browse_mode| is true. If set, the bottom sheet will
  // completely disappear when the action starts, and re-appear when the action
  // ends.
  //
  // Note: invisible prompts can't show chips to the user. This flag is intended
  // to be used with prompts that exclusively use choices which are
  // auto-selected based on DOM state, i.e., |auto_select_when|.
  optional bool browse_mode_invisible = 10;

  // When set to true, end prompt on navigation events happening during a prompt
  // action. The result sent back to the server in
  // ProcessedActionProto.prompt_choice will have |navigation_ended| set to
  // true.
  optional bool end_on_navigation = 8;

  // A list of domains and subdomains to allow users to navigate to when in
  // browse mode.
  repeated string browse_domains_allowlist = 9;

  // Result to pass to ProcessedActionProto.
  message Result {
    // This field is only used when crafting a response Choice for the server
    // when the |end_on_navigation| option is set. It means there was a
    // navigation event while in prompt mode that ended the action.
    optional bool navigation_ended = 2;

    // Server payload originally found in Choice.server_payload. This should be
    // transmitted as-is by the client without interpreting.
    optional bytes server_payload = 5;

    // Tag originally set in Choice.tag.
    optional string choice_tag = 6;

    reserved 1;
  }
}

message ContactDetailsProto {
  // A subset of fields available for autofill profiles. See
  // |components/autofill/code/browser/field_types.h|.
  enum AutofillContactField {
    NAME_FULL = 7;
    EMAIL_ADDRESS = 9;
    PHONE_HOME_WHOLE_NUMBER = 14;
  }

  // Data saved under this name can be reused by UseAddressAction.
  optional string contact_details_name = 1;
  // If true asks user for full name.
  optional bool request_payer_name = 2;
  // If true asks user for email.
  optional bool request_payer_email = 3;
  // If true asks user for phone.
  optional bool request_payer_phone = 4;
  // This controls the summary of the selected contact in the collapsed contact
  // section (one line per field, in the order specified, up to and including
  // |max_number_summary_fields| lines).
  repeated AutofillContactField summary_fields = 5;
  // The maximum number of lines for the selected contact in the collapsed
  // contact section.
  optional int32 max_number_summary_lines = 6;
  // This controls the full description of contacts in the expanded contact
  // section (one line per field, in the order specified, up to and including
  // |max_number_full_lines| lines).
  repeated AutofillContactField full_fields = 7;
  // The maximum number of lines for contacts in the expanded contact section.
  optional int32 max_number_full_lines = 8;
  // If present, it will be used as the title to be displayed for the contact
  // details section instead of the default one.
  optional string contact_details_section_title = 9;
  // Defines how to evaluate validity of this contact.
  repeated RequiredDataPiece required_data_piece = 10;

  // If true, the phone number will be asked in a separate section from the
  // rest of the contact info. If true, |request_payer_phone| must be false.
  // Only supported for backend-provided data.
  optional bool separate_phone_number_section = 11;
  // The title of the separate phone number section.
  // Required if |separate_phone_number_section| is true, ignored if false.
  optional string phone_number_section_title = 12;
  // Defines how to evaluate the validity of the phone number in the separate
  // section. Ignored if |separate_phone_number_section| is false.
  repeated RequiredDataPiece phone_number_required_data_piece = 13;
}

message LoginDetailsProto {
  // A custom login option which will be handled by the backend, e.g.,
  // 'Guest checkout' or 'Log in with Google'.
  message LoginOptionCustomProto {
    // The label to display to the user.
    optional string label = 1;
  }

  // Offers all matching Chrome password manager logins for the current website.
  message LoginOptionPasswordManagerProto {}

  message LoginOptionProto {
    // If set, an info icon will be shown that displays a popup when tapped.
    optional InfoPopupProto info_popup = 6;

    // The optional sublabel to display beneath the label.
    optional string sublabel = 7;
    optional string sublabel_accessibility_hint = 8;

    // The optional content description of the edit button. There are three
    // possible states:
    // - unset: the content description will be inferred from the button.
    // - set to empty string: this button is not important for a11y.
    // - set to non-empty string: the button will have the specified content
    // description.
    optional string edit_button_content_description = 10;

    oneof payload_or_tag {
      // The payload attached to this login option, to be echoed back to the
      // caller when the option is chosen.
      //
      // Prefer using tag.
      bytes payload = 1;

      // The tag attached to this login option, to be echoed back to the
      // caller when the option is chosen.
      string tag = 21;
    }

    // Whether the UI should automatically choose this login option if no
    // password manager login options are available.
    optional bool choose_automatically_if_no_stored_login = 2;

    // Determines the priority with which to pre-select this login choice.
    // The lower the value, the higher the priority.
    optional int32 preselection_priority = 3;
    oneof type {
      LoginOptionCustomProto custom = 4;
      LoginOptionPasswordManagerProto password_manager = 5;
    }

    reserved 9;
  }
  // The title for the login selection (e.g., 'Login details for <domain>').
  optional string section_title = 1;
  // The list of available login options.
  repeated LoginOptionProto login_options = 2;
}

// A section showing a simple text message.
message StaticTextSectionProto {
  oneof value {
    // The text to display. Can contain markup tags like <b>.
    string text = 1;
    // Key to read the display string value from client memory.
    // Note: Corresponding action will fail if we do not find
    // a non-empty single display string value.
    string client_memory_key = 2;
  }
}

// A single text input.
message TextInputProto {
  optional string hint = 1;
  enum InputType {
    UNDEFINED = 0;
    // Regular text, no special formatting rules.
    INPUT_TEXT = 1;
    // An alphanumeric input, e.g. postal code or discount code.
    INPUT_ALPHANUMERIC = 2;
  }
  optional InputType input_type = 2;

  // The client memory key to store the result in.
  optional string client_memory_key = 3;

  // The initial value of the text input.
  optional string value = 4;
}

// A section containing one or multiple text inputs.
message TextInputSectionProto {
  repeated TextInputProto input_fields = 1;
}

message UserFormSectionProto {
  optional string title = 1;

  oneof section {
    StaticTextSectionProto static_text_section = 2;
    TextInputSectionProto text_input_section = 3;
    PopupListSectionProto popup_list_section = 4;
  }
  // Whether to send the result values to the backend.
  optional bool send_result_to_backend = 5;
}

// A section that when tapped presents the user a popup with a list of options.
// The selected option is displayed in the section.
message PopupListSectionProto {
  // The key used to store the selection in CollectUserDataResultProto
  optional string additional_value_key = 1;

  // The name of the items to be displayed
  repeated string item_names = 2;

  // The list of the indexes of the items to be initially selected.
  repeated int32 initial_selection = 3;

  // Whether to allow the selection of multiple items or just one.
  optional bool allow_multiselect = 4;

  // Whether the selection of this section is required to proceed.
  optional bool selection_mandatory = 5 [default = true];

  // The error message displayed when the selection is mandatory and missing.
  // Ignored if |selection_mandatory| is false.
  optional string no_selection_error_message = 6;
}

message AutofillEntryProto {
  // The value that this data point holds.
  optional string value = 1;
  // The value should be used exactly as specified. Use this only in
  // exceptional circumstances, as you will lose any of the additional
  // processing done automatically by Autofill, such as:
  // - Setting a NAME_FULL will split it and also set NAME_FIRST, NAME_MIDDLE
  //   and NAME_LAST as applicable.
  // - Setting a PHONE_HOME_WHOLE_NUMBER will also set PHONE_HOME_NUMBER,
  //   PHONE_HOME_CITY_CODE, PHONE_HOME_COUNTRY_CODE and
  //   PHONE_HOME_CITY_AND_NUMBER.
  optional bool raw = 2;
}

message ProfileProto {
  // The values, where the key is one of autofill::ServerFieldType.
  map<int32, AutofillEntryProto> values = 2;
  // The identifier for this set of profile data.
  optional string identifier = 3;
  // The token to edit this profile. This is only available for profiles
  // originating from an address source.
  optional bytes edit_token = 4;

  reserved 1;
}

message PhoneNumberProto {
  // The identifier of this phone number.
  optional string identifier = 1;
  // The canonical value of the phone number, including country and area code
  // without any separators.
  optional AutofillEntryProto value = 2;
}

message PaymentInstrumentProto {
  // The values for the card, where the key is one of autofill::ServerFieldType.
  map<int32, AutofillEntryProto> card_values = 2;
  // The payments instrument id used to identify and unmask the credit card.
  optional int64 instrument_id = 7;
  // The network of the card.
  optional string network = 5;
  // The last 4 digits of the card.
  optional string last_four_digits = 6;
  // The values for the billing address, where the key is one of
  // autofill::ServerFieldType.
  map<int32, AutofillEntryProto> address_values = 3;
  // The identifier for this payment instrument (credit card + billing address).
  optional string identifier = 4;
  // The token to edit this payment instrument.
  optional bytes edit_token = 8;

  reserved 1;
}

message DataOriginNoticeProto {
  // Text of the link to the dialog.
  optional string link_text = 1;

  // Content of the dialog
  optional string dialog_title = 2;
  optional string dialog_text = 3;
  optional string dialog_button_text = 4;
}

// Asks to provide the data used by UseAddressAction and
// UseCreditCardAction.
// Next: 40
message CollectUserDataProto {
  enum TermsAndConditionsState {
    // No choice has been made yet.
    NOT_SELECTED = 0;
    // The 'accept' radio button is toggled.
    ACCEPTED = 1;
    // The 'review' radio button is toggled.
    REVIEW_REQUIRED = 2;
  }

  // Specifies information about the data source to be used.
  message DataSource {}

  optional string prompt = 1;
  // NOTE: The action does not ask separately for billing address.
  // The billing address is associated with the credit card that was picked.
  optional string billing_address_name = 2;
  // If present will save the shipping address inside the memory under the
  // specified name. If empty we won't ask for the shipping address. Data saved
  // under this name can be reused by UseAddressAction.
  optional string shipping_address_name = 3;
  // If present, it will be used as the title to be displayed for the shipping
  // address section instead of the default one.
  optional string shipping_address_section_title = 32;
  // When 'true' will ask for the credit card.
  optional bool request_payment_method = 4;
  // If non-empty, the UI will filter the available basic-card networks
  // accordingly (e.g., only `visa' and `mastercard').
  repeated string supported_basic_card_networks = 6;
  // Contact details that should be gathered.
  optional ContactDetailsProto contact_details = 5;
  // Optional specification for the confirm button (defaults to standard confirm
  // chip if not specified).
  optional ChipProto confirm_chip = 33;
  // The initial state of the terms & conditions choice.
  optional TermsAndConditionsState terms_and_conditions_state = 8;
  // When 'false', hide the terms and conditions box in the UI.
  optional bool request_terms_and_conditions = 9 [default = true];
  // Whether the terms and conditions should be displayed as a single checkbox
  // with |accept_terms_and_conditions_text| as text. If false, the accept terms
  // will be displayed as a radio button next to an additional "Read and agree
  // later on domain.com" choice.
  optional bool show_terms_as_checkbox = 12;
  // The text for the terms and conditions "I accept..." choice. The text is
  // formatted such that '<b>text</b>' will be bold and '<link0>clickable
  // link</link0>', '<link1>other link</link1>', etc will be clickable links
  // that will finish this action and return the clicked link in the action
  // result.
  optional string accept_terms_and_conditions_text = 13;
  // Message that indicates that the user wants to review the terms and
  // conditions of a 3rd party's domain, e.g., 'example.com'.
  optional string terms_require_review_text = 20;
  // Privacy notice telling users that autofill assistant will send personal
  // data to a third partys website.
  optional string privacy_notice_text = 21;
  // Additional actions available to the user. This can be used for instance to
  // display a "Show terms" button that will navigate the user to the terms and
  // conditions page when clicked.
  repeated UserActionProto additional_actions = 11;
  // The error message to display when the selected credit card is expired.
  optional string credit_card_expired_text = 23;
  // The login details that should be gathered.
  optional LoginDetailsProto login_details = 16;
  // If set, shows the data origin section to the user.
  optional DataOriginNoticeProto data_origin_notice = 39;
  // An optional list of additional sections, which is above all other sections.
  repeated UserFormSectionProto additional_prepended_sections = 18;
  // An optional list of additional sections, which is below all other sections.
  repeated UserFormSectionProto additional_appended_sections = 19;
  // Backend-configured user interface to show below
  // |additional_prepended_sections|.
  optional GenericUserInterfaceProto generic_user_interface_prepended = 22;
  // Backend-configured user interface to show below
  // |additional_appended_sections|.
  optional GenericUserInterfaceProto generic_user_interface_appended = 25;
  // Optional. Text to be shown in a separate info section.
  optional string info_section_text = 24;
  // Optional. If true the text in the info section will be centered.
  optional bool info_section_text_center = 31;
  // Optional. If specified, the continue button will only be enabled if the
  // boolean at this location is true (and everything else is valid too).
  optional string additional_model_identifier_to_check = 27;
  // Clears any previously selected credit card. The client will revert to
  // default-selecting the card instead. NOTE: When clearing the credit card
  // selection, the billing address should also be cleared!
  optional bool clear_previous_credit_card_selection = 28;
  // Clears the previously selected login option, if any. The client will revert
  // to default-selecting the login option instead.
  optional bool clear_previous_login_selection = 29;
  // The names of the selected profiles to clear. Should be a subset of
  // {billing_address_name, shipping_address_name,
  // contact_details.contact_details_name}. NOTE: when clearing the billing
  // address, the selected credit card should also be cleared!
  repeated string clear_previous_profile_selection = 30;
  // Defines how to evaluate validitiy of an address or credit card.
  repeated RequiredDataPiece required_shipping_address_data_piece = 34;
  repeated RequiredDataPiece required_credit_card_data_piece = 35;
  repeated RequiredDataPiece required_billing_address_data_piece = 36;

  // If set, will request data from the GetUserData remote backend, rather than
  // Chrome Autofill. Takes precedence over |user_data|.
  optional DataSource data_source = 38;

  reserved 7, 10, 14, 15, 17, 26, 37;
}

// Stop Autofill Assistant.
message StopProto {
  // If true, close the Chrome Custom Tab, in addition to shutting down Autofill
  // Assistant.
  optional bool close_cct = 2;

  // Whether to show the feedback chip once Autofill Assistant has stopped.
  // Note that this is only relevant if the UI is still being shown after the
  // stop, which happens only if:
  // - close_cct is false.
  // - The action preceding this one is a Tell action.
  optional bool show_feedback_chip = 3;

  reserved 1;  // stop_action_type
}

message DetailsChangesProto {
  // Whether the changes require user approval. This de-emphasize
  // non-highlighted fields.
  optional bool user_approval_required = 1;

  // Whether the title should be highlighted.
  optional bool highlight_title = 2;

  // Whether the first description line should be highlighted.
  optional bool highlight_line1 = 3;

  // Whether the second description line should be highlighted.
  optional bool highlight_line2 = 4;

  // Whether the third description line should be highlighted.
  optional bool highlight_line3 = 5;
}

message DetailsProto {
  optional string title = 1;

  optional string image_url = 2;

  // Specifies the hint for accessibility. If set to empty, the image will not
  // be announced by accessibility.
  optional string image_accessibility_hint = 14;

  // Specifies what happens when user tap on the image in the details section.
  message ImageClickthroughData {
    // Whether to show the original URL where image is extracted from. Only
    // useful when 'image_url' is set.
    optional bool allow_clickthrough = 1;

    // When image clickthrough is allowed, below texts are used to customize the
    // modal dialog shown to user *if* they are set, otherwise default texts
    // will be used.
    optional string description = 2;
    optional string positive_text = 3;
    optional string negative_text = 4;

    // The url to present when user did choose to clickthrough.
    optional string clickthrough_url = 5;
  }

  optional ImageClickthroughData image_clickthrough_data = 12;

  // Optional label to provide additional price information.
  optional string total_price_label = 9;
  // The price containing the total amount and the currency to pay, formatted
  // in the client's locale (e.g., $123.00).
  optional string total_price = 6;

  optional string description_line_1 = 7;
  optional string description_line_2 = 8;
  optional string description_line_3 = 13;

  // Deprecated, but currently still necessary and supported. We can get rid of
  // these fields when the backend starts setting description_line_1 and 2.
  optional DateTimeProto datetime = 3;
  optional string description = 4;

  // The configuration for the placeholders.
  message PlaceholdersConfiguration {
    // Show a placeholder if |DetailsProto.image_url| is empty.
    optional bool show_image_placeholder = 1;

    // Show a placeholder if |DetailsProto.title| is empty.
    optional bool show_title_placeholder = 2;

    // Show a placeholder if |DetailsProto.description_line_1| is empty.
    optional bool show_description_line_1_placeholder = 3;

    // Show a placeholder if |DetailsProto.description_line_2| is empty.
    optional bool show_description_line_2_placeholder = 4;

    // Show a placeholder if |DetailsProto.description_line_3| is empty.
    optional bool show_description_line_3_placeholder = 5;
  }

  // The placeholders configuration. Note that a placeholder will be shown only
  // if the associated data is empty.
  optional PlaceholdersConfiguration placeholders = 15;

  // Deprecated, no longer supported.
  reserved 5, 10, 11;
}

// Show contextual information.
message ShowDetailsProto {
  oneof data_to_show {
    DetailsProto details = 1;
    // Shows full name and email address.
    string contact_details = 3;
    bool credit_card = 4;
    // Shows full name and address.
    string shipping_address = 5;
  }

  // Flags indicating which parts of the details (if any) have changed.
  // This field is taken into account only if |details| is filled.
  optional DetailsChangesProto change_flags = 2;

  // Whether the details should be added/appended instead of replacing the
  // current details.
  optional bool append = 6;

  // If set, add a delay of |delay_ms| before setting/appending the details.
  //
  // The details will never be shown if another ShowDetailsProto action with
  // |append| = false is sent after this action and before the delay is reached.
  //
  // Note that it's not possible to delay the clearing of the details. If
  // |data_to_show| is not set, then the details will be cleared directly.
  optional int32 delay_ms = 7;
}

// Asks the password manager to generate a suitable password for |element|. The
// generated password can be filled in subsequent actions.
message GeneratePasswordForFormFieldProto {
  // A reference to the form element for which to generate a password.
  optional SelectorProto element = 1;
  // The client memory key to store the generated password.
  optional string memory_key = 2;
}

// Presaves generated password to the password store.
// Presaving stores a generated password with empty username.
// Only possible if a password has already been generated using
// |GeneratePasswordForFormFieldProto|.
message PresaveGeneratedPasswordProto {
  // The client memory key of the stored password.
  optional string memory_key = 1;
}

// Asks the password save manager to save generated password after successful
// submission.
message SaveGeneratedPasswordProto {
  // The client memory key of stored password.
  optional string memory_key = 1;
}

// Deletes password for |UserData::selected_login_| from Chrome Password
// Manager. For flows, other than password change, |CollectUserData| must be
// called before |DeleteSelectedPasswowrd|.
message DeleteSelectedPasswordProto {}

// Edits password for |UserData::selected_login_| in Chrome Password Manager.
// For flows, other than password change, |CollectUserData| must be
// called before |DeleteSelectedPasswowrd|.
message EditSelectedPasswordProto {
  // The client memory key where the new password is stored.
  optional string memory_key = 1;
}

// Clears potentially submitted or pending forms in password manager. Used to
// make password manager "forget" about any previously processed form that
// is pending or submitted.
message ResetPendingCredentialsProto {}

// Saves the current submitted password to the password store. The action
// fails if the password manager has no record of a submitted password.
message SaveSubmittedPasswordProto {
  // If leak_detection_timeout_ms is specified, the action performs a
  // leak check for the submitted credential. If leak_detection_timeout_ms is
  // specified, but zero, the default value in SaveSubmittedPasswordAction
  // is used.
  optional int32 leak_detection_timeout_ms = 1;
  message Result {
    // If the same password was used and therefore the credential is still
    // insecure, the action succeeds to avoid script termination.
    // Instead it returns a result flagging the re-use of the
    // password so that the Autobot flow can try again.
    optional bool used_same_password = 1;
    // If the new credential is still leaked, return a result flag that states
    // this. The flow can choose to react to this, e.g. prompting the user
    // to user another password.
    optional bool used_leaked_credential = 2;
  }
}

// Notifies the client that a password reset has been requested. This is
// relevant for analyzing the outcome of password change flows. The action
// fails if login details are not saved in the client's |UserData|.
message RegisterPasswordResetRequestProto {}

// Configures the UI of the autofill assistant client.
message ConfigureUiStateProto {
  enum OverlayBehavior {
    // The overlay is decided according to the state the client is in.
    DEFAULT = 0;
    // The overlay is always hidden.
    HIDDEN = 1;
  }
  optional OverlayBehavior overlay_behavior = 1;
}

// Set an element attribute to a specific value.
message SetAttributeProto {
  // A reference to the form element whose attribute should be set.
  optional SelectorProto element = 1;

  // The attribute to set, e.g. ["style", "position"] to change
  // element.style.position.
  repeated string attribute = 2;

  // The value to set.
  optional string value = 3;
}

message InfoBoxProto {
  // Optional path to an image. Ok tick used if not set.
  optional string image_path = 1;

  // The explanation to show in the box. Not setting this field will clear an
  // existing info box.
  optional string explanation = 2;
}

// Shows an info box with informational content. The info box content is cleared
// when |info_box| is not set.
message ShowInfoBoxProto {
  optional InfoBoxProto info_box = 1;
}

// Allow scripts to configure the peek height of the sheet and whether we should
// resize the viewport by this peek height. If talkback is enabled, the mode is
// set to RESIZE_VISUAL_VIEWPORT. Changes to the mode are only applied after
// talkback is disabled.
message ConfigureBottomSheetProto {
  enum ViewportResizing {
    // Don't change resizing configuration.
    NO_CHANGE = 0;

    // Resize the layout viewport such that it is completely visible when the
    // sheet is in the peek state.
    RESIZE_LAYOUT_VIEWPORT = 1;

    // Don't resize the viewport such that it is overlaid by the sheet, even in
    // the peek state.
    NO_RESIZE = 2;

    // Dynamically resize the visual viewport by the height of the sheet. This
    // allows to fully scroll the page above the sheet at any time.
    RESIZE_VISUAL_VIEWPORT = 3;
  }

  // The peek mode allows to set what components are visible when the sheet is
  // in the peek (minimized) state.
  enum PeekMode {
    UNDEFINED_PEEK_MODE = 0;

    // Only show the swipe handle.
    HANDLE = 1;

    // Show the swipe handle, header (status message, poodle, profile icon) and
    // progress bar.
    HANDLE_HEADER = 2;

    // Show swipe handle, header, progress bar, suggestions and actions.
    HANDLE_HEADER_CAROUSELS = 3;
  }

  // Whether the viewport should be resized. Resizing the viewport is an
  // expensive operation, so toggling the resize on/off should be done
  // cautiously.
  optional ViewportResizing viewport_resizing = 1;

  // Set the peek mode. This will change the peek mode of the sheet without
  // actually updating the sheet to that setting. If viewport_resizing is set
  // to RESIZE_LAYOUT_VIEWPORT or was set by a previous ConfigureBottomSheet
  // action, the viewport will be resized to match the new peek height.
  optional PeekMode peek_mode = 2;

  // Maximum time to wait for the window to resize before continuing with the
  // script. If 0 or unset, the action doesn't wait.
  optional int32 resize_timeout_ms = 3;

  // Option to automatically expand or collapse the sheet or leave as is.
  oneof apply_state {
    // Go to the expanded state (same as if the user swiped the bottom sheet
    // up).
    bool expand = 4;
    // Go to the peek state (same as if the user swiped the bottom
    // sheet down).
    bool collapse = 5;
  }
}

// Allow scripts to display a form with multiple inputs.
message ShowFormProto {
  // The form to display.
  optional FormProto form = 1;

  // The chip to display below the form. This chip will be enabled only if all
  // form inputs are valid.
  optional ChipProto chip = 2;

  reserved 3;
}

message FormProto {
  // A result associated to this form, such that |input_results[i]| is the
  // result of |inputs[i]|. If the user clicks a link while in the form action,
  // |link| will be set to the index of the clicked link and |input_results|
  // may be incomplete.
  message Result {
    repeated FormInputProto.Result input_results = 1;
    // If this is set, it contains the index of the text link that was clicked.
    // E.g., <link4>Details</link4> will populate this field with '4' when
    // clicked.
    optional int32 link = 2;
  }

  // The different inputs to display.
  repeated FormInputProto inputs = 1;

  // Optionally adds an informational text below the form.
  optional string info_label = 2;
  // If set, an info icon will be shown next to the info label that prompts a
  // popup when tapped. Ignored if info_label is not set.
  optional InfoPopupProto info_popup = 3;
}

message FormInputProto {
  message Result {
    oneof input_type {
      CounterInputProto.Result counter = 1;
      SelectionInputProto.Result selection = 2;
    }
  }

  oneof input_type {
    CounterInputProto counter = 1;
    SelectionInputProto selection = 2;
  }
}

// An input that is made of one or more counters. This input is considered valid
// if its |validation_rule| is satisfied or if it doesn't have one.
message CounterInputProto {
  // A single counter.
  message Counter {
    // The label shown with the counter. All occurrences of the '{value}'
    // substring will be replaced by the current counter value. May contain
    // links of the form <link1>Some text</link1>.
    optional string label = 1;

    // Text shown below the label. Optional. May contain links of the form
    // <link1>Some text</link1>.
    optional string description_line_1 = 5;

    // Text shown below |description_line_2|. Optional. May contain links of the
    // form <link1>Some text</link1>.
    optional string description_line_2 = 8;

    // The possible values this counter can have. If empty, the possible values
    // will be all integer values between |min_value| and |max_value|.
    // Note that the order of the values matters and they will not be
    // automatically sorted.
    repeated int32 allowed_values = 6;

    // The minimum value this counter can have. Ignored if |allowed_values| is
    // not empty.
    optional int32 min_value = 2 [default = -0x80000000];  // kint32min

    // The maximum value this counter can have. Ignored if |allowed_values| is
    // not empty.
    optional int32 max_value = 3 [default = 0x7FFFFFFF];  // kint32max

    // The initial value of the counter. If |allowed_values| is not empty, it
    // must contain |initial_value| or it will otherwise default to the first
    // value.
    optional int32 initial_value = 4 [default = 0];

    // The weight of adding 1 in this counter. Defaults to 1. Incrementing by 1
    // in counter has an effect of incrementing by |size| in the counter
    // section. For example, a family ticket in showtimes counts as |size|
    // tickets in total amount restriction.
    optional int32 size = 9 [default = 1];

    reserved 7;
  }

  // A result associated to this counter.
  message Result {
    // The values of all counters from this CounterInputProto, such that
    // |values[i]| is the value of |counters[i]|.
    repeated int32 values = 1;
  }

  // A validation rule to validate this input values.
  message ValidationRule {
    // A rule to combine sub rules. This rule allows to express the following:
    //  - Rule A and Rule B must be satisfied.
    //  - Rule A or Rule B must be satisfied.
    //  - Rule A must not be satisfied.
    //  - At least 2 of Rules A, B or C must be satisfied.
    //
    // This rule is satisfied if the number of satisfied |sub_rules| is >=
    // min_satisfied_rules and <= max_satisfied_rules.
    message BooleanRule {
      // The sub rules to check.
      repeated ValidationRule sub_rules = 1;

      // The minimum number of rules that must be satisfied.
      optional int32 min_satisfied_rules = 2 [default = 0];

      // The maximum number of rules that must be satisfied.
      optional int32 max_satisfied_rules = 3
          [default = 0x7FFFFFFF];  // kint32max
    }

    // A rule on the value of one of the |counters|. This rule is satisfied if
    // min_value <= counter.value <= max_value.
    message CounterRule {
      // The index of the counter in |counters|. Must be >= 0 and <
      // |counters.size|.
      optional int32 counter_index = 1;

      // The minimum value this counter can have.
      optional int32 min_value = 2 [default = -0x80000000];  // kint32min

      // The maximum value this counter can have.
      optional int32 max_value = 3 [default = 0x7FFFFFFF];  // kint32max
    }

    // A rule on the sum of the |counters|. This rule satisfied if the sum of
    // all |counters| is >= min_value and <= max_value. If there is an overflow
    // when computing the sum, the behavior is undefined.
    message CountersSumRule {
      // The minimum value the total can have.
      optional int64 min_value = 1
          [default = -0x8000000000000000];  // kint64min

      // The maximum value this counter can have.
      optional int64 max_value = 2 [default = 0x7FFFFFFFFFFFFFFF];  // kint64max
    }

    oneof rule_type {
      BooleanRule boolean = 1;
      CounterRule counter = 2;
      CountersSumRule counters_sum = 3;
    }
  }

  // An optional label shown above the different counters.
  optional string label = 1;

  // The counters to display.
  repeated Counter counters = 2;

  // If specified, the input will initially display maximum |minimized_count|
  // counters. If |counters|.size > |minimized_count|, the remaining counters
  // will be displayed in an expandable section below the first
  // |minimized_count| counters. Setting this value will have no effect if
  // |expand_text| and |minimize_text| are not set.
  optional int32 minimized_count = 3 [default = 0x7FFFFFFF];  // kint32max

  // Text shown when counters are inside the expandable section and the section
  // is minimized. Clicking this text will expand the section and show the
  // remaining counters.
  optional string expand_text = 4;

  // Text shown when counters are inside the expandable section and the section
  // is expanded. Clicking this text will minimize the section and hide the
  // counters inside it.
  optional string minimize_text = 5;

  // Validation rule used to check whether the current values of this input are
  // valid.
  optional ValidationRule validation_rule = 6;

  // The minimum value of the sum of the counters. All counters decrease button
  // will be disabled if sum <= min_counters_sum.
  optional int64 min_counters_sum = 7
      [default = -0x8000000000000000];  // kint64min

  // The maximum value of the sum of the counters. All counters increase button
  // will be disabled if sum >= max_counters_sum.
  optional int64 max_counters_sum = 8
      [default = 0x7FFFFFFFFFFFFFFF];  // kint64max
}

// An input that allows the user to choose one or multiple options. This input
// is considered valid if the number of selected choices is bigger or equal than
// |min_choices|.
message SelectionInputProto {
  message Choice {
    // The label of this choice. May contain links of the form <link1>Some
    // text</link1>.
    optional string label = 1;

    // Text shown below the label. Optional. May contain links of the form
    // <link1>Some text</link1>.
    optional string description_line_1 = 3;

    // Text shown below |description_line_2|. Optional. May contain links of the
    // form <link1>Some text</link1>.
    optional string description_line_2 = 4;

    // Whether this choice is selected by default. If |allow_multiple| is false,
    // then maximum 1 Choice can have this set to true, otherwise the associated
    // FormAction will fail.
    optional bool selected = 2 [default = false];

    reserved 7;
  }

  message Result {
    // Stores whether each choice was selected or not, such that |selected[i]|
    // is true if |choices[i]| was selected.
    repeated bool selected = 1;
  }

  // An optional label shown above the different choices.
  optional string label = 1;

  // The choices to display.
  repeated Choice choices = 2;

  // Whether the user will be allowed to select multiple choices. If false, each
  // choice will be displayed with a radio button. Otherwise, it will be
  // displayed with checkboxes.
  optional bool allow_multiple = 3 [default = false];

  // The minimum number of choices that should be selected to consider this
  // input valid.
  optional int32 min_selected_choices = 4 [default = 1];
}

// Action to show a popup bubble on top of the bottom sheet, anchored at the
// icon. Setting an empty message will remove any existing and visible popup
// message. A second action replaces a previously shown message.
message PopupMessageProto {
  // Message to show in the popup.
  optional string message = 1;
}

// Action to get an element's status.
message GetElementStatusProto {
  oneof element {
    SelectorProto selector = 1;
    ClientIdProto client_id = 5;
  }

  optional ValueMatch expected_value_match = 2;
  optional ValueSource value_source = 4;

  // If set and a mismatch happens, the action will report a failure status
  // with |ELEMENT_MISMATCH|. If this flag is set to false, the action will not
  // fail and simply report the result.
  optional bool mismatch_should_fail = 3;

  // The result that gets sent as part of |ProcessedActionProto.result_data|.
  message Result {
    // The field is considered not empty.
    optional bool not_empty = 1;
    // The field matches the expected input.
    optional bool match_success = 2;
    // The field was expected to match an empty expectation. For a value this
    // means an empty expected value, for a RegExp this means the extracted
    // match was empty.
    optional bool expected_empty_match = 4;

    // For logging and debugging.
    repeated ComparisonReport reports = 3;
  }

  enum ValueSource {
    NOT_SET = 0;
    // Compare the element's |value| attribute against this expected match.
    VALUE = 1;
    // Compare the element's |innerText| attribute against this expected match.
    INNER_TEXT = 2;
  }

  message MatchOptions {
    optional bool case_sensitive = 1;
    optional bool remove_space = 2;
    optional string find_and_remove_re2 = 3;
  }

  message MatchExpectation {
    optional MatchOptions match_options = 1;

    oneof match_level {
      bool full_match = 2;
      bool contains = 3;
      bool starts_with = 4;
      bool ends_with = 5;
    }
  }

  message TextMatch {
    oneof value_source {
      // A regular expression.
      string re2 = 4;
      // A value resolvable to a text. May require to be preceded by a
      // |CollectUserDataAction|.
      TextValue text_value = 5;
    }

    // Optional. The expectations to declare this as a matching success. If
    // left empty, the action will always be treated as successful.
    optional MatchExpectation match_expectation = 3;

    reserved 1, 2;
  }

  message ValueMatch { optional TextMatch text_match = 1; }

  message ComparisonReport {
    optional MatchOptions match_options = 1;

    optional bool full_match = 2;
    optional bool contains = 3;
    optional bool starts_with = 4;
    optional bool ends_with = 5;

    optional bool empty = 6;
    optional bool expected_empty_match = 7;
  }
}

message ReleaseElementsProto {
  repeated ClientIdProto client_ids = 1;
}

// Action to unconditionally dispatch a custom JS event 'duplexweb' on document.
message DispatchJsEventProto {}

// Executes a javascript flow in an isolated environment. Additional actions may
// be requested directly from the flow. See
// components/autofill_assistant/browser/js_flow_executor_impl.h for details.
message JsFlowProto {
  message Result {
    // A serialized JSON object containing the overall result value of the flow.
    // This will never contain string values, for reasons of privacy and
    // security. If the script attempts to return string values anyway, this
    // field will be empty and the action will return INVALID_ACTION.
    optional string result_json = 1;
  }
  // The JS flow to execute in a sandbox.
  optional string js_flow = 1;
}

// Action which forwards a proto to the owner of the |ExternalScriptController|
// for the current flow. Not supported for internal flows.
message ExternalActionProto {
  // The opaque proto to be forwarded to the owner of the
  // |ExternalScriptController| for this flow.
  optional external.ActionInfo info = 1;

  // Whether to show the touchable area in the overlay.
  // If true, it will consume the current touchable area.
  optional bool show_touchable_area = 2;

  // Whether interrupts should be executed while Autofill Assistant is in prompt
  // state.
  optional bool allow_interrupt = 3;
}
