// Copyright 2018 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto2";

option optimize_for = LITE_RUNTIME;
option java_package = "org.chromium.chrome.browser.autofill_assistant.proto";
option java_multiple_files = true;

package autofill_assistant;

import "action_strategy.proto";
import "action_value.proto";
import "dom_action.proto";
import "generic_ui.proto";
import "model.proto";
import "view_layout.proto";

// A field trial containing the name of the trial and the name of the
// randomly selected trial group.
message FieldTrialProto {
  optional string trial_name = 1;
  optional string group_name = 2;
}

// Context contains client environment details.
message ClientContextProto {
  message Chrome {
    optional string chrome_version = 1;
    repeated FieldTrialProto active_field_trials = 2;
  }
  oneof client { Chrome chrome = 1; }

  // locale will be the language tag of the default locale. The tag should
  // be a well-formed IETF BCP 47 language tag with language and country code
  // (e.g., "en-US").
  // The intent is to communicate the client language preferences to the server.
  optional string locale = 5;

  // country should be a country code as defined by ISO 3166-1-alpha-2.
  // The intent is to communicate the client's location to the server.
  optional string country = 6;

  // Experiment ids string provided by the 'caller'.
  optional string experiment_ids = 7;

  // True if the script is called from a Chrome Custom Tab created for Autofill
  // Assistant.
  optional bool is_cct = 8;

  // True if the onboarding screen was shown to the user.
  optional bool is_onboarding_shown = 10;

  // True if the script was triggered by a direct action.
  optional bool is_direct_action = 9;

  message DeviceContextProto {
    message VersionProto {
      // The Android SDK version of the device.
      optional int32 sdk_int = 1;
    }
    optional VersionProto version = 1;

    // The manufacturer of the device.
    optional string manufacturer = 2;

    // The model of the device.
    optional string model = 3;
  }
  optional DeviceContextProto device_context = 11;

  enum AccountsMatchingStatus {
    // The account was not present in the intent.
    UNKNOWN = 0;

    // The account in the intent and the current chrome account match.
    ACCOUNTS_MATCHING = 1;

    // The account in the intent and the current chrome account DON'T match.
    ACCOUNTS_NOT_MATCHING = 2;
  }
  // Whether the account from the intent and the chrome account match.
  optional AccountsMatchingStatus accounts_matching_status = 12;

  // Whether a11y (talkback and touch exploration) is enabled or not.
  optional bool accessibility_enabled = 13;

  enum SignedIntoChromeStatus {
    UNDEFINED = 0;

    // There is no account signed into Chrome.
    NOT_SIGNED_IN = 1;

    // An account is signed into Chrome.
    SIGNED_IN = 2;
  }
  optional SignedIntoChromeStatus signed_into_chrome_status = 14;

  // The size of the current Chrome window. This not only includes the part of
  // the window that renders the website but also everything around it
  // (toolbars, omnibox, ...).
  message WindowSize {
    optional int32 height_pixels = 1;
    optional int32 width_pixels = 2;
  }
  optional WindowSize window_size = 15;

  // The current orientation of the device.
  enum ScreenOrientation {
    UNDEFINED_ORIENTATION = 0;
    PORTRAIT = 1;
    LANDSCAPE = 2;
  }
  optional ScreenOrientation screen_orientation = 16;
}

// Get the list of scripts that can potentially be run on a url.
message SupportsScriptRequestProto {
  optional string url = 1;

  // Parameters that can be used to filter the scripts suitable for execution.
  repeated ScriptParameterProto script_parameters = 2;

  optional ClientContextProto client_context = 3;
}

message ScriptParameterProto {
  // Parameter name, as found in the Intent, without prefix.
  optional string name = 3;
  optional string value = 2;
}

// Response of the list of supported scripts.
message SupportsScriptResponseProto {
  repeated SupportedScriptProto scripts = 1;

  // Defines what should happen if no scripts in [scripts] becomes runnable,
  // because of preconditions.
  optional ScriptTimeoutError script_timeout_error = 2;

  optional ClientSettingsProto client_settings = 3;

  // The ScriptStoreConfig to use with the initial GetActions request.
  optional ScriptStoreConfig script_store_config = 6;

  reserved 4, 5;
}

// Overlay image to be drawn on top of full overlays.
message OverlayImageProto {
  // TODO(b/170202574): Remove legacy |image_url|.
  // If set, |image_size| is mandatory.
  oneof image {
    // Deprecated, but currently still supported. The image to display.
    string image_url = 1;
    // The image to display.
    DrawableProto image_drawable = 8;
  }
  // The size of the image to display.
  optional ClientDimensionProto image_size = 2;
  // The margin between the top of the page (anchor) and the image.
  optional ClientDimensionProto image_top_margin = 3;
  // The margin between the bottom of the image and the baseline of the text.
  optional ClientDimensionProto image_bottom_margin = 4;
  // The text to display beneath the image. If set, |text_color| and |text_size|
  // are mandatory.
  optional string text = 5;
  // Supported formats: #RRGGBB or #AARRGGBB.
  optional string text_color = 6;
  // The size of the text to display.
  optional ClientDimensionProto text_size = 7;
}

// Next ID: 22
message ClientSettingsProto {
  message IntegrationTestSettings {
    // Disables animations for the poodle and the progress bar.
    optional bool disable_header_animations = 1;
    // Disables change animations in the actions carousel.
    optional bool disable_carousel_change_animations = 2;
  }

  // Time between two periodic script precondition checks.
  optional int32 periodic_script_check_interval_ms = 1;

  // Time between two element checks in the script executor.
  optional int32 periodic_element_check_interval_ms = 2;

  // Run that many periodic checks before giving up unless something happens to
  // wake it up, such as the user touching the screen.
  optional int32 periodic_script_check_count = 3;

  // Time between two element position refreshes, when displaying highlighted
  // areas in prompt state.
  optional int32 element_position_update_interval_ms = 4;

  // Maximum amount of time normal actions should implicitly wait for a selector
  // to show up.
  optional int32 short_wait_for_element_deadline_ms = 5;

  // Time to wait between two checks of the box model, when waiting for an
  // element to become stable, such as before clicking.
  optional int32 box_model_check_interval_ms = 6;

  // Maximum number of checks to run while waiting for the element position to
  // become stable.
  optional int32 box_model_check_count = 7;

  // Maximum time to wait until document has reached "ready" state.
  optional int32 document_ready_check_timeout_ms = 20;

  // How much time to give users to tap undo when they tap a cancel button.
  optional int32 cancel_delay_ms = 12;

  // If the user taps the overlay that many time within |tap_duration| turn the
  // UI off and give them |tap_shutdown_delay| to undo. If 0, unexpected taps
  // are ignored.
  optional int32 tap_count = 13;

  // Reset the unexpected tap counter after that time.
  optional int32 tap_tracking_duration_ms = 14;

  // How much time to give users to tap undo when after |tap_count| unexpected
  // taps where
  optional int32 tap_shutdown_delay_ms = 15;

  // Optional image drawn on top of overlays.
  optional OverlayImageProto overlay_image = 16;

  // Optional settings intended for integration tests.
  optional IntegrationTestSettings integration_test_settings = 17;

  // Optional setting defining the size of the bottom sheet when Talkback is
  // enabled as a fraction of the available height. When set, the bottomsheet
  // will stop resizing automatically in talkback mode. It will always have the
  // specified size instead.
  optional float talkback_sheet_size_fraction = 18;

  // Strings to define the back button behaviour. This will show the user a
  // message with an Undo button. If this setting is not present, the back
  // button will show a Snackbar with Undo option.
  message BackButtonSettings {
    // The message being shown in the header.
    optional string message = 1;

    // The label of the highlighted "Undo" action.
    optional string undo_label = 2;
  }
  optional BackButtonSettings back_button_settings = 19;

  // Settings to define the behavior for showing warnings about slow connection
  // and/or websites to users.
  message SlowWarningSettings {
    enum MessageMode {
      UNKNOWN = 0;
      // The warning message will be appended to the existing status message.
      CONCATENATE = 1;
      // The warning message will replace the current status message.
      REPLACE = 2;
    }
    // Whether to show warnings related to a slow connection to the user.
    optional bool enable_slow_connection_warnings = 1;
    // Whether to show warnings related to a slow website to the user.
    optional bool enable_slow_website_warnings = 2;
    // If true, only one warning will be shown to the user, i.e. either the slow
    // connection or website, depending on which one triggers first.
    optional bool only_show_warning_once = 3;
    // If true, the slow connection warning will be shown only once.
    optional bool only_show_connection_warning_once = 4;
    // If true, the website warning will be shown only once.
    optional bool only_show_website_warning_once = 5;
    // Defines the maximum wait on a dom find element operation before showing
    // the slow website warning.
    optional int32 warning_delay_ms = 6;
    // Defines the threshold above which a roundtrip is considered too slow.
    optional int32 slow_roundtrip_threshold_ms = 7;
    // Defines the number of consecutive slow roundtrips allowed before showing
    // the slow connection warning.
    optional int32 max_consecutive_slow_roundtrips = 8;
    // The message to show as a warning to inform the user of a slow connection.
    // If this is not set, no warning will be shown in case of slow connection.
    optional string slow_connection_message = 9;
    // The message to show as a warning to inform the user of a slow website.
    // If this is not set, no warning will be shown in case of a slow website.
    optional string slow_website_message = 10;
    // The minimum duration that the message will be shown for (only applies to
    // the slow connection messages).
    optional int32 minimum_warning_message_duration_ms = 11;
    // Whether the warning message should replace the current status message or
    // should be concatenated.
    optional MessageMode message_mode = 12;
  }
  optional SlowWarningSettings slow_warning_settings = 21;

  reserved 8 to 11;
}

message ScriptTimeoutError {
  // Wait for that long before considering that scripts preconditions have timed
  // out and executing the script specified in script_path.
  //
  // The script might be called more than once if the script terminates
  // successfully and again still nothing is found after timeout_ms.
  optional int32 timeout_ms = 1;

  // The script to execute when the error happens.
  optional string script_path = 2;
}

// Supported script.
message SupportedScriptProto {
  // This is the internal name of the script.
  optional string path = 1;

  message PresentationProto {
    // Precondition contains a set of conditions that must hold for a script to
    // be executed. No precondition means that a script can run in any case.
    optional ScriptPreconditionProto precondition = 3;

    // Text display at the same time as the script is proposed. If more than one
    // script has an initial prompt, the prompt of the highest-priority script
    // wins.
    optional string initial_prompt = 4;

    // Display priority of the script. Lowest number has highest priority, which
    // means a script with priority 0 should be displayed before a script with
    // priority 1.
    optional int32 priority = 5;

    // An optional chip to display.
    optional ChipProto chip = 12;

    // Optionally map this script to a direct action.
    optional DirectActionProto direct_action = 13;

    // When set to true this script can be run in 'autostart mode'.
    optional bool autostart = 8;

    // When set to true this script will be run from WaitForDom actions with
    // allow_interrupt=true.
    optional bool interrupt = 9;

    // Message to show once the script has been started. This is shown while
    // loading the actions.
    optional string start_message = 14;

    // Show the UI if it's not shown yet. Setting this to false is useful for
    // scripts started by direct actions.
    optional bool needs_ui = 15 [default = true];

    reserved 1, 2, 6, 7, 10, 11, 16 to 18;
  }
  optional PresentationProto presentation = 2;

  reserved 3;
}

enum ScriptStatusProto {
  // Never explicitly set. Reading this value means the enum field is either
  // not set or set to a value not listed here.
  UNKNOWN_SCRIPT_STATUS = 0;
  // The script finished successfully.
  SCRIPT_STATUS_SUCCESS = 1;
  // The script failed.
  SCRIPT_STATUS_FAILURE = 2;
  // The user cancelled the script.
  SCRIPT_STATUS_CANCELLED = 3;
  // The script is currently running.
  SCRIPT_STATUS_RUNNING = 4;
  // The script was not run.
  SCRIPT_STATUS_NOT_RUN = 5;
}

// Condition on the status of a previous script run.
message ScriptStatusMatchProto {
  enum Comparator {
    UNSPECIFIED = 0;
    EQUAL = 1;
    DIFFERENT = 2;
  }

  // Required. Path of the script whose status should be checked.
  optional string script = 1;

  // Required. The status the script should have for the condition to hold.
  optional ScriptStatusProto status = 2;

  // Optional. The comparison performed when checking the status. It will be
  // interpreted as EQUAL if not set.
  optional Comparator comparator = 3;
}

message ScriptPreconditionProto {
  // Pattern of the path parts of the URL, including query and '#''.
  repeated string path_pattern = 5;
  // Domain (exact match) excluding the last '/' character.
  repeated string domain = 6;

  // Combined with AND: all matches must be true for precondition to hold.
  repeated ScriptParameterMatchProto script_parameter_match = 7;
  repeated ScriptStatusMatchProto script_status_match = 8;

  // Script can only run if the given condition match.
  optional ElementConditionProto element_condition = 10;

  reserved 3, 9;
}

message ScriptParameterMatchProto {
  // Parameter name, as found in the Intent, without prefix.
  optional string name = 4;

  // Checks whether the script parameter is present.
  optional bool exists = 2 [default = true];

  // Checks whether the script parameter has exact value. Empty or missing value
  // is treated as wildcard - any value will pass.
  optional string value_equals = 3;
}

enum PolicyType {
  UNKNOWN_POLICY = 0;
  SCRIPT = 1;
}

message ScriptActionRequestProto {
  optional ClientContextProto client_context = 7;

  // Global payload from the previous response, possibly for another script.
  optional bytes global_payload = 8;

  // Script payload from the previous response, for the same script.
  //
  // For backward compatibility, for initial requests, forward the last returned
  // script_payload.
  optional bytes script_payload = 2;

  oneof request {
    InitialScriptActionsRequestProto initial_request = 4;
    NextScriptActionsRequestProto next_request = 5;
  }
}

// Message specifying how to retrieve the scripts. If bundle_path is set, it
// will read that bundle with the associated version.
message ScriptStoreConfig {
  optional string bundle_path = 2;
  optional int64 bundle_version = 3;
}

// Initial request to get a script's actions.
message InitialScriptActionsRequestProto {
  message QueryProto {
    // The backend expects the |script_path| to be a repeated field. This field
    // is expected to contain only one element.
    repeated string script_path = 1;
    // The exact URL on which the script was initially started.
    optional string url = 2;
    optional PolicyType policy = 3;
  }
  optional QueryProto query = 3;

  repeated ScriptParameterProto script_parameters = 2;

  // Specify a bundle and version to run.
  optional ScriptStoreConfig script_store_config = 6;
}

message RoundtripTimingStats {
  // Reports how long it took for the previous roundtrip to the backend to
  // complete.
  optional int64 roundtrip_time_ms = 1;
  // Reports the total client processing time for the executed batch of actions.
  optional int64 client_time_ms = 2;
}

// Next request to get a script's actions.
message NextScriptActionsRequestProto {
  // The result of processing each ActionProto from the previous response. This
  // field must be in the same order as the actions in the original response.
  // It may have less actions in case of failure.
  repeated ProcessedActionProto processed_actions = 1;
  // Contains all roundtrip level (as opposed to action level) timing stats.
  optional RoundtripTimingStats timing_stats = 2;
  // Tracks whether the last roundtrip triggered a slow connection warning and
  // whether it was shown to the user.
  optional SlowWarningStatus slow_connection_warning = 34;
}

// Response of a script's actions.
message ActionsResponseProto {
  // Opaque data to send to the next ScriptActionRequestProto.
  optional bytes global_payload = 4;

  // Opaque data to send to the next ScriptActionRequestProto for the same
  // script.
  optional bytes script_payload = 2;

  // Actions to be performed in order.
  // Should stop processing as soon as an action fails.
  repeated ActionProto actions = 3;

  // List of scripts to update.
  //
  // The client is expected to update the cache of scripts with this new
  // information. No action is needed when this field is not set. If the field
  // is set with an empty list of scripts, then no script is eligible to run
  // anymore.
  //
  // Note: This is an intermediate solution and the logic associated with this
  // field will eventually be absorbed into the supports script response from
  // the backend.
  message UpdateScriptListProto { repeated SupportedScriptProto scripts = 1; }
  optional UpdateScriptListProto update_script_list = 5;

  reserved 1, 6 to 10;
}

// Can be used to indicate the presence of a field, without the ambiguity that
// a boolean field would have.
message Empty {}

// RPC request to fetch the available trigger scripts for a particular domain.
message GetTriggerScriptsRequestProto {
  // The exact url for which to fetch the trigger scripts.
  optional string url = 1;
  // The client context.
  // NOTE: Currently, this will only contain the Chrome version number for
  // privacy reasons.
  optional ClientContextProto client_context = 2;
  // Optional debug script parameters.
  repeated ScriptParameterProto debug_script_parameters = 3;
}

// The RPC response to a |GetTriggerScriptsRequestProto|.
message GetTriggerScriptsResponseProto {
  // The available trigger scripts, if any.
  repeated TriggerScriptProto trigger_scripts = 1;

  // A list of additional domains and subdomains. Trigger scripts will
  // automatically cancel the ongoing session if the user navigates away from
  // the original domain or any of the additional domains.
  repeated string additional_allowed_domains = 2;

  // The amount of time a trigger script may evaluate trigger conditions while
  // invisible. If a trigger script is invisible for this amount of time, it
  // will automatically finish with LITE_SCRIPT_TRIGGER_CONDITION_TIMEOUT.
  // If not specified, there is no automatic timeout.
  //
  // This is only counted while no trigger script is shown, and the time is
  // reset on tab switch and whenever a trigger script is hidden. Note that this
  // only counts the time in-between checks, so the actual timeout will be
  // slightly longer.
  optional int32 timeout_ms = 3;

  // The amount of time between consecutive checks of trigger conditions. Should
  // not be too small to limit performance impact.
  optional int32 trigger_condition_check_interval_ms = 4 [default = 1000];
}

// A trigger script contains the full specification for a trigger script that is
// run when a specific condition is true, prior to the full run.
message TriggerScriptProto {
  enum TriggerScriptAction {
    UNDEFINED = 0;
    // The current trigger script is cancelled. If the prompt is not currently
    // being shown, this has no effect. If the prompt is currently being shown,
    // the prompt is hidden and the trigger script is restarted once the trigger
    // condition has become false again.
    NOT_NOW = 1;
    // Cancels the current trigger script and does not restart it for this
    // session.
    CANCEL_SESSION = 2;
    // Cancels the current trigger script and prevents trigger scripts from ever
    // running again. TODO(b/172039582): allow a per-domain opt-out.
    CANCEL_FOREVER = 3;
    // Displays a popup to give users additional cancel options.
    SHOW_CANCEL_POPUP = 4;
    // Stop the trigger script and start the regular script.
    ACCEPT = 5;
  }

  // The |trigger_condition| must be true for the script to trigger.
  optional TriggerScriptConditionProto trigger_condition = 1;

  // The user interface to show.
  optional TriggerScriptUIProto user_interface = 3;

  // What should happen if the user swipe-dismisses the bottom sheet.
  optional TriggerScriptAction on_swipe_to_dismiss = 4
      [default = CANCEL_SESSION];

  // An identifier for the type of trigger UI this trigger represents, for UKM.
  optional TriggerUIType trigger_ui_type = 5;

  reserved 2;
}

// Set of TriggerUIType to group UKM metrics by.
//
// The set of available values is defined by AutofillAssistantTriggerUIType in
// tools/metrics/histograms/enums.xml
enum TriggerUIType {
  UNSPECIFIED_TRIGGER_UI_TYPE = 0;
  CART_FIRST_TIME_USER = 1;
  CART_RETURNING_USER = 2;
  CHECKOUT_FIRST_TIME_USER = 3;
  CHECKOUT_RETURNING_USER = 4;
}

message TriggerScriptConditionProto {
  oneof type {
    // The condition matches if all of these conditions match.
    TriggerScriptConditionsProto all_of = 1;
    // The condition matches if at least one of these conditions matches.
    TriggerScriptConditionsProto any_of = 2;
    // The condition matches if none of these conditions match.
    TriggerScriptConditionsProto none_of = 3;

    // The condition matches if the specified selector matches the current DOM..
    SelectorProto selector = 8;
    // The condition matches if the user has stored login credentials for the
    // domain.
    Empty stored_login_credentials = 5;
    // The condition matches if the user has never seen a trigger script before.
    Empty is_first_time_user = 6;
    // The condition matches if the client is in the specified experiment.
    int32 experiment_id = 7;
    // The condition matches if the keyboard is hidden.
    Empty keyboard_hidden = 9;
    // The condition describes a parameter value that must be set to trigger.
    ScriptParameterMatchProto script_parameter_match = 10;
    // Pattern of the path parts of the URL, including query and '#'.
    string path_pattern = 11;
    // Domain (exact match), including the scheme (e.g.
    // "https://www.example.com").
    string domain_with_scheme = 12;
  }

  reserved 4;
}

message TriggerScriptConditionsProto {
  repeated TriggerScriptConditionProto conditions = 1;
}

message TriggerScriptUIProto {
  message ProgressBar {
    repeated DrawableProto step_icons = 1;
    optional int32 active_step = 2;
  }

  message TriggerChip {
    optional ChipProto chip = 1;
    optional TriggerScriptProto.TriggerScriptAction action = 2;
  }
  message Popup {
    message Choice {
      // The text to display.
      optional string text = 1;
      // The action to execute if this popup item is selected.
      optional TriggerScriptProto.TriggerScriptAction action = 2;
    }
    // The available popup items.
    repeated Choice choices = 1;
  }

  // The status message to display.
  optional string status_message = 1;
  // The callout to display. If not specified, no callout will be shown.
  optional string callout_message = 2;
  // The progress bar to display. If not specified, no progress bar will be
  // shown.
  optional ProgressBar progress_bar = 3;
  // The cancel popup, usually associated with a particular chip.
  optional Popup cancel_popup = 4;
  // The available left-aligned chips, specified in order from left to right.
  repeated TriggerChip left_aligned_chips = 5;
  // The available right-aligned chips, specified in order from left to right.
  repeated TriggerChip right_aligned_chips = 6;
  // The status message to display when transitioning from this trigger script
  // to the regular script.
  optional string regular_script_loading_status_message = 7;
  // Whether the visual viewport should be resized to allow scrolling to the
  // bottom of the page while the trigger script is being displayed.
  optional bool resize_visual_viewport = 8;
  // Whether the bottom sheet should temporarily disappear when scrolling down
  // the website, to move out of the way.
  //
  // The value of resize_visual_viewport is ignored when scroll_to_hide is true.
  // This allows the backend setting both to true and letting chrome choose
  // scroll_to_hide if it is supported.
  optional bool scroll_to_hide = 9;
}

// An action could be performed.
message ActionProto {
  // Wait these many milliseconds before executing the action, if set.
  optional int32 action_delay_ms = 3;

  // Opaque data that should not be interpreted by the client. The client must
  // pass this back unchanged in the next request
  optional bytes server_payload = 4;

  oneof action_info {
    ClickProto click = 5;
    SetFormFieldValueProto set_form_value = 6;
    SelectOptionProto select_option = 7;
    NavigateProto navigate = 9;
    PromptProto prompt = 10;
    TellProto tell = 11;
    ShowCastProto show_cast = 12;
    WaitForDomProto wait_for_dom = 19;
    UseCreditCardProto use_card = 28;
    UseAddressProto use_address = 29;
    UploadDomProto upload_dom = 18;
    ShowProgressBarProto show_progress_bar = 24;
    HighlightElementProto highlight_element = 31;
    ShowDetailsProto show_details = 32;
    StopProto stop = 35;
    CollectUserDataProto collect_user_data = 36;
    SetAttributeProto set_attribute = 37;
    ShowInfoBoxProto show_info_box = 39;
    ExpectNavigationProto expect_navigation = 40;
    WaitForNavigationProto wait_for_navigation = 41;
    ConfigureBottomSheetProto configure_bottom_sheet = 42;
    ShowFormProto show_form = 43;
    PopupMessageProto popup_message = 44;
    WaitForDocumentProto wait_for_document = 45;
    ShowGenericUiProto show_generic_ui = 49;
    GeneratePasswordForFormFieldProto generate_password_for_form_field = 52;
    SaveGeneratedPasswordProto save_generated_password = 53;
    ConfigureUiStateProto configure_ui_state = 54;
    PresaveGeneratedPasswordProto presave_generated_password = 55;
    GetElementStatusProto get_element_status = 56;
    ScrollIntoViewProto scroll_into_view = 57;
    WaitForDocumentToBecomeInteractiveProto
        wait_for_document_to_become_interactive = 58;
    WaitForDocumentToBecomeCompleteProto wait_for_document_to_become_complete =
        59;
    SendClickEventProto send_click_event = 60;
    SendTapEventProto send_tap_event = 61;
    JsClickProto js_click = 62;
    SendKeystrokeEventsProto send_keystroke_events = 63;
    SendChangeEventProto send_change_event = 64;
    SetElementAttributeProto set_element_attribute = 65;
    SelectFieldValueProto select_field_value = 66;
    FocusFieldProto focus_field = 67;
    WaitForElementToBecomeStableProto wait_for_element_to_become_stable = 68;
    CheckElementIsOnTopProto check_element_is_on_top = 69;
    ReleaseElementsProto release_elements = 70;
    DispatchJsEventProto dispatch_js_event = 72;
    SendKeyEventProto send_key_event = 73;
  }

  // Set to true to make the client remove any contextual information if the
  // script finishes with this action. It has no effect if there is any other
  // action sent to the client after this one. Default is false.
  optional bool clean_contextual_ui = 33;

  reserved 8, 13 to 17, 20 to 23, 25 to 27, 30, 34, 38, 46 to 48, 50, 51, 71;
}

// Result of |CollectUserDataProto| to be sent to the server.
message CollectUserDataResultProto {
  optional string card_issuer_network = 1;
  // Whether the integrated terms and conditions approval checkbox was checked.
  optional bool is_terms_and_conditions_accepted = 2;
  // The email address of the payer.
  optional string payer_email = 3;
  // If set, this means that the user triggered the action in
  // |CollectUserDataProto.additional_actions| that has index
  // |additional_action_index|.
  optional int32 additional_action_index = 4;
  // If set, this means that the user clicked on one of the terms and conditions
  // links.
  optional int32 terms_link = 5;
  // The payload of the chosen login option.
  optional bytes login_payload = 6;
  // The values obtained by the generic user interface.
  optional ModelProto model = 9;
  // The memory keys of all non-empty text inputs, corresponding to the memory
  // keys specified in |TextInputProto|. The values themselves are stored in the
  // client and do not leave the device.
  repeated string set_text_input_memory_keys = 10;
  // The start date of the date/time range, if requested.
  optional DateProto date_range_start_date = 11;
  // The index of the selected timeslot for the start of the date/time range.
  optional int32 date_range_start_timeslot = 12;
  // The end date of the date/time range, if requested.
  optional DateProto date_range_end_date = 13;
  // The index of the selected timeslot for the end of the date/time range.
  optional int32 date_range_end_timeslot = 14;
  // The values obtained from the additional sections.
  repeated ModelProto.ModelValue additional_sections_values = 15;
  // Indicates whether the UI was shown to the user. This can be false if
  // only the login section was requested and the choice was implicitly made.
  optional bool shown_to_user = 16;
  // Indicates that the chosen login option was missing the username.
  optional bool login_missing_username = 17;
  // Indicates what profile data is available for the Contact.
  repeated string non_empty_contact_field = 18;
  // Indicates what profile data is available for the Shipping address.
  repeated string non_empty_shipping_address_field = 19;
  // Indicates what profile data is available for the Billing address.
  repeated string non_empty_billing_address_field = 20;

  reserved 7, 8;
}

message ActionTimingStats {
  // Requested delay before executing the action.
  optional int64 delay_ms = 1;
  // Time actively spent by the client to execute the action.
  optional int64 active_time_ms = 2;
  // Time spent waiting for users to complete a task and/or for website
  // loading/navigation.
  optional int64 wait_time_ms = 3;
}

// Enum used to track the slow warnings that can trigger due to slow connection
// or long running wait for dom actions.
enum SlowWarningStatus {
  // The warning wasn't triggered.
  NO_WARNING = 0;
  // The warning was triggered but not shown to the user.
  WARNING_TRIGGERED = 1;
  // The warning was triggered and shown to the user.
  WARNING_SHOWN = 2;
}

message ProcessedActionProto {
  // The action that was processed.
  optional ActionProto action = 1;

  optional ProcessedActionStatusProto status = 2;

  optional ProcessedActionStatusDetailsProto status_details = 19;

  oneof result_data {
    PromptProto.Result prompt_choice = 5;
    // Should be set as a result of CollectUserDataAction.
    CollectUserDataResultProto collect_user_data_result = 15;
    // Should be set as a result of SetFormFieldValueAction.
    SetFormFieldValueProto.Result set_form_field_value_result = 17;
    // May be set as a result of WaitForDomProto.
    WaitForDomProto.Result wait_for_dom_result = 22;
    // Should be set as a result of FormAction.
    FormProto.Result form_result = 21;
    WaitForDocumentProto.Result wait_for_document_result = 25;
    // Should be set as a result of ShowGenericUiProto.
    ShowGenericUiProto.Result show_generic_ui_result = 28;
    // Should be set as a result of GetElementStatusProto.
    GetElementStatusProto.Result get_element_status_result = 31;
    // Should be set as a result of UploadDomProto.
    UploadDomProto.Result upload_dom_result = 33;
  }

  // Reports information about navigation that happened while
  // processing the action. This is meant for debugging.
  optional NavigationInfoProto navigation_info = 20;

  // Reports how long it took for the client to run the action. This does not
  // include the delay specified in action.delay_ms.
  optional int64 run_time_ms = 23;

  // Collects the timing stats related to the action execution.
  optional ActionTimingStats timing_stats = 32;

  // If true, the user triggered, during the client action, at least one user
  // action, such as a prompt choice, through a direct action instead of
  // selecting a chip on the UI. This is meant for monitoring and debugging.
  optional bool direct_action = 24;

  // Tracks whether the action triggered a slow website warning and whether it
  // was shown to the user.
  optional SlowWarningStatus slow_warning_status = 34;

  reserved 3, 4, 6 to 14, 16, 18, 26, 27, 29, 30;
}

// Extended information about the action status, which provides more details
// about what happened than a simple ProcessedActionStatusProto can.
message ProcessedActionStatusDetailsProto {
  // More information included for unexpected errors.
  //
  // Only set for action whose status are OTHER_ACTION_STATUS or
  // UNEXPECTED_JS_ERROR.
  optional UnexpectedErrorInfoProto unexpected_error_info = 1;

  // In some case, such as USER_ABORTED_ACTION and NAVIGATION_ERROR, the status
  // reported by the action is overridden after the action failed, to report a
  // more appropriate error. When that happens, this field contains the original
  // status, to help debugging.
  optional ProcessedActionStatusProto original_status = 2;

  // More information included for autofill related errors.
  optional AutofillErrorInfoProto autofill_error_info = 3;

  // More information included for |SetFormFieldValueProto| related errors.
  optional SetFormFieldErrorInfoProto form_field_error_info = 4;

  // Additional information from the |WebController|.
  optional WebControllerErrorInfoProto web_controller_error_info = 5;
}

message NavigationInfoProto {
  // Navigation started while processing the current action.
  optional bool started = 1;

  // Navigation ended while processing the current action.
  optional bool ended = 2;

  // Navigation failed before or during the processing of the current action.
  optional bool has_error = 3;

  // Unexpected navigation started while processing the current action. This
  // will happen during some actions, such as PROMPT action but it should
  // normally not happen during scripts that have been updated to use
  // expect_navigation.
  optional bool unexpected = 4;
}

// Extra debugging information included in case of unexpected errors.
//
// Presence of this element is usually the sign of a bug in the client code and
// is always the sign that the client code needs to be updated: such issues
// should be either fixed or reported as proper, expected error with a useful
// status code.
message UnexpectedErrorInfoProto {
  // Source file, within the client code, where an unexpected error was detected
  // and reported.
  //
  // Only filled for unexpected errors OTHER_ACTION_STATUS and
  // UNEXPECTED_JS_ERROR.
  //
  // This and source_line are only meaningful for the exact version reported in
  // the client context.
  optional string source_file = 1;

  // Line number, within the client's source file, where the error was detected.
  optional int32 source_line_number = 2;

  // JavaScript exception class name, if reporting a JavaScript error.
  optional string js_exception_classname = 3;

  // JavaScript exception line number, within the js snippet that was sent to
  // devtools runtime by the client, if reporting a JavaScript error.
  optional int32 js_exception_line_number = 4;

  // JavaScript exception column number, within the js snippet that was sent to
  // devtools runtime by the client, if reporting a JavaScript error.
  optional int32 js_exception_column_number = 5;

  // Error code returned by devtools, if any. 0 is considered a success.
  optional int32 devtools_error_code = 6;

  // Error message returned by devtools, if any.
  optional string devtools_error_message = 7;
}

// Message to report autofill related errors for debugging purposes.
message AutofillErrorInfoProto {
  message AutofillFieldError {
    // The field the error occurred for.
    optional SelectorProto field = 1;

    // The value expression associated with the field that caused the error.
    optional string value_expression = 5;

    oneof error_type {
      // No fallback value for this field.
      bool no_fallback_value = 3;

      // The status of the action.
      ProcessedActionStatusProto status = 4;

      // The field was required and expected to be filled during the fallback
      // flow but was empty in the end.
      bool empty_after_fallback = 6;

      // The field was expected to be cleared during the fallback flow but
      // still had a value in the end.
      bool filled_after_clear = 7;
    }

    reserved 2;
  }

  // Comma separated list of address keys in the client memory when the
  // unexpected error occurred. Memory values are never reported this way since
  // they may contain PII. Only the address key names!
  optional string client_memory_address_key_names = 1;

  // Name of the address key requested in the list of keys in
  // |client_memory_address_key_names|.
  optional string address_key_requested = 2;

  // Whether the client memory at |address_key_requested| pointed to null.
  optional bool address_pointee_was_null = 3;

  // Error status of the Chrome autofill attempt.
  optional ProcessedActionStatusProto autofill_error_status = 4;

  // Errors that occurred during fallback filling of autofill fields.
  repeated AutofillFieldError autofill_field_error = 5;

  // These values should match the values in FullCardRequest::FailureType.
  enum GetFullCardFailureType {
    UNKNOWN_FAILURE_TYPE = 0;

    // The user closed the prompt. The following scenarios are possible:
    // 1) The user declined to enter their CVC and closed the prompt.
    // 2) The user provided their CVC, got auth declined and then closed the
    //    prompt without attempting a second time.
    // 3) The user provided their CVC and closed the prompt before waiting for
    //    the result.
    PROMPT_CLOSED = 1;

    // The card could not be looked up due to card auth declined or failed.
    VERIFICATION_DECLINED = 2;

    // The request failed for technical reasons, such as a closing page or lack
    // of network connection.
    GENERIC_FAILURE = 3;
  }
  // Failure type from the |FullCardRequest|.
  optional GetFullCardFailureType get_full_card_failure_type = 6;
}

// Message to report |SetFormFieldValueProto| related errors for debugging
// purposes.
message SetFormFieldErrorInfoProto {
  // The index of |keypress| that caused the action to be invalid.
  optional int32 invalid_keypress_index = 1;
}

// Message to report errors related to WebController execution.
message WebControllerErrorInfoProto {
  enum WebAction {
    UNSPECIFIED_WEB_ACTION = 0;

    // Scroll an element into view by centering it on the page. This uses
    // native JS functionality.
    SCROLL_INTO_VIEW = 1;

    // Waiting for the document ready state to be interactive.
    WAIT_FOR_DOCUMENT_TO_BECOME_INTERACTIVE = 2;

    // Send a click or tap event to an element.
    CLICK_OR_TAP_ELEMENT = 3;

    // Select an option from an HTML dropdown.
    SELECT_OPTION = 4;

    // Set the element's style to be highlighted by adding a BoxShadow to the
    // element.
    HIGHLIGHT_ELEMENT = 5;

    // Scroll the element into view with padding. This uses native JS
    // functionality for the initial scrolling and calculates the scrolling
    // for padding manually.
    SCROLL_INTO_VIEW_WITH_PADDING = 6;

    // Get the |value| attribute of an element.
    GET_FIELD_VALUE = 7;

    // Get any attribute of an element.
    GET_STRING_ATTRIBUTE = 8;

    // Select an element's value. This does only work for text elements.
    SELECT_FIELD_VALUE = 9;

    // Set the |value| attribute of an element.
    SET_VALUE_ATTRIBUTE = 10;

    // Set any attribute of an element.
    SET_ATTRIBUTE = 11;

    // Send a series of keystroke inputs. This requires an element to have
    // focus to receive them.
    SEND_KEYBOARD_INPUT = 12;

    // Get the outer HTML of an element.
    GET_OUTER_HTML = 13;

    // Get the tag of an element.
    GET_ELEMENT_TAG = 14;

    // Set active focus on a field.
    FOCUS_FIELD = 15;

    // Wait for an element position to stabilize before clicking or a tapping.
    // Fails with ELEMENT_UNSTABLE.
    WAIT_UNTIL_ELEMENT_IS_STABLE = 16;

    // Check that the element is on top, usually as part of clicking.
    // Fails with ELEMENT_NOT_ON_TOP.
    ON_TOP = 17;

    // Waiting for a certain document ready state failed.
    WAIT_FOR_DOCUMENT_READY_STATE = 18;

    // Trigger a change event.
    SEND_CHANGE_EVENT = 19;

    // Dispatch a 'duplexweb' event on document.
    DISPATCH_EVENT_ON_DOCUMENT = 20;

    // Send a single key event.
    SEND_KEY_EVENT = 21;
  }

  // The web-action that failed. This is usually a step in an execution chain
  // for an action.
  optional WebAction failed_web_action = 1;
}

// The pseudo type values come from
// https://chromedevtools.github.io/devtools-protocol/tot/DOM#type-PseudoType.
enum PseudoType {
  UNDEFINED = 0;
  FIRST_LINE = 1;
  FIRST_LETTER = 2;
  BEFORE = 3;
  AFTER = 4;
  BACKDROP = 5;
  SELECTION = 6;
  FIRST_LINE_INHERITED = 7;
  SCROLLBAR = 8;
  SCROLLBAR_THUMB = 9;
  SCROLLBAR_BUTTON = 10;
  SCROLLBAR_TRACK = 11;
  SCROLLBAR_TRACK_PIECE = 12;
  SCROLLBAR_CORNER = 13;
  RESIZER = 14;
  INPUT_LIST_BUTTON = 15;
}

// A reference to one or more elements on the page, possibly nested in frames.
message SelectorProto {
  // Filters for the element on the page. Filter are applied sequentially, using
  // the output of the previous filter as input. The root of these filters is
  // the main frame's document.
  repeated Filter filters = 9;

  // A filter that starts with one or more elements and returns one on more
  // elements. Filters are meant to be applied sequentially.
  //
  // The returned elements will be sorted by their order in the document.
  // Elements that were matched via the labelled filter will have the same order
  // as their label.
  message Filter {
    oneof filter {
      // Enter the document of an iframe or shadow root. The next filters apply
      // to the document inside of the iframe(s) or on the shadow element.
      //
      // Fails if there are more than one match.
      EmptyFilter enter_frame = 1;

      // Evaluate the given CSS selector on all start elements and use
      // the result as end elements.
      string css_selector = 2;

      // Check the inner text of all start elements, using the Javascript
      // innerText property. Keep only the element whose innerText match the
      // given regular expression.
      TextFilter inner_text = 3;

      // Check the value of all start elements, using the Javascript value
      // property. Keep only the element whose value property match the given
      // regular expression.
      TextFilter value = 4;

      // Select the pseudo-element of the given type associated with the current
      // elements.
      PseudoType pseudo_type = 5;

      // Only keep elements that have a box model, even if it is empty.
      //
      // This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
      // renamed as having a bounding box is not enough to imply visibility.
      BoundingBoxFilter bounding_box = 6;

      // Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
      // not enough matches.
      NthMatchFilter nth_match = 7;

      // Only keep elements that have a pseudo-element with the given content.
      //
      // This only works with BEFORE and AFTER.
      //
      // Note that this just filters out elements. It doesn't select the
      // pseudo-element; use pseudo_type for that.
      //
      // Deprecated: prefer css_style. This should be removed in Chrome M89.
      PseudoElementContent pseudo_element_content = 8;

      // Go from label to the labelled control. Only works starting with current
      // elements that are LABEL.
      //
      // For example if we have:
      //  <label for="someid">First Name</label>...<input id="someid" ...>
      // then labelled, goes from the label to the form element.
      //
      // So, the form element can be accessed as "label~=/FirstName/ labelled".
      // This is especially useful in situations where someid can change.
      //
      // The same selector also works in the case where the element is inside of
      // the label, so we don't need to worry which implementation is used when
      // building the selector:
      //   <label>First Name <input ...></label>
      EmptyFilter labelled = 9;

      // Only keep results that match the given CSS selector.
      string match_css_selector = 11;

      // Only keep elements whose computed style match the given filter. This is
      // based on Window.computedStyle()
      CssStyleFilter css_style = 12;

      // Filter out elements whose center point are covered by another element.
      //
      // This first calls Element.scrollIntoViewIfNeeded to make sure the
      // element can be moved to the viewport, then calls
      // DocumentOrShadowDom.getElementFromPoint and compares the result with
      // the expected element. If the element at point is not the element, a
      // descendant of the element or a label of the element, there is an
      // overlay.
      //
      // Note that:
      //
      // - this filter will also weed out elements with no bounding box. Check
      // with bounding_box { } first.
      //
      // - this filter will also weed out elements that cannot be scrolled into
      // the viewport.
      //
      // - an element might be covered by an overlay and still be visible if the
      // overlay is transparent. An element might be covered by an overlay and
      // still be clickable, if the overlay intercepts and forwards events.
      // Overlays with pointer-events set to none are ignored.
      //
      // - an element might be only partially covered by an overlay. This filter
      // only checks the center of the element, since this is where the click
      // action sends its clicks or taps.
      //
      // - this filter only detects overlays in the current frame. To detect
      // overlays that cover the frame element itself, apply this filter on the
      // frame element before calling enter_frame.
      OnTopFilter on_top = 13;
    }

    reserved 10;
  }

  // A way of filtering elements by their pseudo-element content.
  message PseudoElementContent {
    optional PseudoType pseudo_type = 1;
    optional TextFilter content = 2;
  }

  // Only keep elements whose computed style match the given filter. This is
  // based on Window.computedStyle()
  //
  // See
  // https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle
  message CssStyleFilter {
    // CSS property name.
    optional string property = 3;

    // Name of the pseudo-element whose style should be checked. Leave it unset
    // or set to the empty string to check the style of the real element.
    //
    // This is the pseudoElt argument of JavaScript's
    // window.getComputedStyle(element, [, pseudoElt]).
    optional string pseudo_element = 4;

    // By default the text filter in |value| must match. Set this to false to
    // require the text condition not to match.
    optional bool should_match = 5 [default = true];

    // CSS property value match.
    //
    // Valid computed CSS properties always have a value, even if it's a default
    // value. The default value depends on the property.
    optional TextFilter value = 6;

    reserved 1, 2;
  }

  // Only keep elements that have a bounding box.
  message BoundingBoxFilter {
    // If require_nonempty=false, which is the default, require elements to have
    // at least one bounding rect returned by Element.getClientRects()
    //
    // If require_nonempty=true, additionally require the element's bounding
    // client rect to have a nonzero width and height.
    optional bool require_nonempty = 1;
  }

  // Filter out elements covered by other elements, such as overlays.
  message OnTopFilter {
    // If true, scroll the element into view before checking whether
    // it's on top.
    //
    // The logic for checking whether an element is on top only works on
    // elements that are positioned within the current viewport. Setting it to
    // false turns off automatic scrolling to make the element visible, so the
    // caller must make sure it's already the case.
    optional bool scroll_into_view_if_needed = 1 [default = true];

    // If true and the element cannot be scrolled into view, so the filter
    // cannot check whether the element is on top, keep the element in the match
    // set.
    //
    // This can be combined with scroll_into_view_if_needed=false to make
    // this filter best effort and only check elements that are already in view.
    optional bool accept_element_if_not_in_view = 2;
  }

  message EmptyFilter {}

  message NthMatchFilter {
    // Take the match at the given |index|.
    optional int32 index = 1;
  }

  reserved 1 to 8;
}

// Contain all arguments to perform a click.
message ClickProto {
  optional SelectorProto element_to_click = 1;
  optional ClickType click_type = 2;

  // Configure whether click should check whether the element is the topmost
  // element before clicking on it.
  //
  // If set to REQUIRE_STEP_SUCCESS, click might fail with ELEMENT_NOT_ON_TOP.
  optional OptionalStep on_top = 3;
}

enum OptionalStep {
  STEP_UNSPECIFIED = 0;
  SKIP_STEP = 1;
  REPORT_STEP_RESULT = 2;
  REQUIRE_STEP_SUCCESS = 3;
}

// Contain all arguments to perform a select option action.
message SelectOptionProto {
  // The drop down element on which to select an option.
  optional SelectorProto element = 2;

  oneof value {
    // Value of the option to use.
    TextFilter text_filter_value = 7;
    // A value from an Autofill source. Note that this must be preceded by a
    // |CollectUserDataAction|.
    AutofillValueRegexp autofill_value = 8;
  }

  // Defines which attribute to use for comparing the option to the expected
  // value.
  enum OptionComparisonAttribute {
    NOT_SET = 0;
    // Compare the option's value.
    VALUE = 1;
    // Compare the option's label.
    LABEL = 2;
  }
  optional OptionComparisonAttribute option_comparison_attribute = 6;

  reserved 1, 3 to 5;
}

// Contain a localized text message from the server.
message TellProto {
  // The message to show in the status bar. The behavior is now the following
  //
  //  * If the field is set, the status bar is updated (explicitly setting an
  //    empty string clears the status bar).
  //  * If the field is not set, the status bar is not updated.
  optional string message = 1;

  // Show the UI if it's not shown yet, such as when a script has been started
  // by a direct action.
  optional bool needs_ui = 2 [default = true];
}

// Contain all arguments to show cast on an element.
message ShowCastProto {
  message TopPadding {
    oneof top_padding {
      // Padding in CSS pixels. Eg. 20.
      int32 pixels = 1;
      // Ratio in relation to the window.innerHeight. Eg. 0.25.
      float ratio = 2;
    }
  }

  // Element to scroll to.
  optional SelectorProto element_to_present = 1;

  // Optional title to show in the status bar.
  optional string title = 2;

  // Restrict interaction to the area spanned by the given elements.
  //
  // Deprecated: use touchable_element_area instead. Ignored if
  // touchable_element_area is non-empty.
  repeated SelectorProto deprecated_touchable_elements = 5;

  // Restrict interaction to a series of rectangular areas.
  optional ElementAreaProto touchable_element_area = 6;

  // The padding that will be added between the focused element and the top.
  // If |container| is specified, this will indicate the padding between the
  // focused element and the top of the container instead.
  optional TopPadding top_padding = 7;

  // Configure whether the scrolling should wait for the element to be stable
  // before scrolling.
  //
  // If set to REQUIRE_STEP_SUCCESS, scrolling may fail with ELEMENT_UNSTABLE.
  optional OptionalStep wait_for_stable_element = 9;

  // Maximum rounds to stable check.
  optional int32 stable_check_max_rounds = 10 [default = 50];

  // Interval for stable check in ms.
  optional int32 stable_check_interval_ms = 11 [default = 200];

  // Optional: the container to be scrolled to focus |element_to_present|. If
  // not set, the window will be scrolled.
  optional SelectorProto container = 12;

  reserved 3, 4, 8;
}

// An area made up of rectangles whole border are made defined by the position
// of a given set of elements.
message ElementAreaProto {
  // A rectangle, drawn by one or more elements.
  //
  // The rectangle is the smallest rectangle that includes all listed elements.
  message Rectangle {
    repeated SelectorProto elements = 1;

    // If true, the width of the rectangle always corresponds to the width of
    // the screen.
    optional bool full_width = 2;
  }

  // The rectangles that will be highlighted and touchable.
  repeated Rectangle touchable = 1;

  // The rectangles that should be neither highlighted nor touchable. Those
  // rectangles have precedence over the |touchable| rectangles.
  repeated Rectangle restricted = 2;
}

// Fill a form with an address if there is, otherwise fail this action.
message UseAddressProto {
  // Message used to indicate what form fields should be filled with what
  // information coming from the address.
  message RequiredField {
    // A string containing any number of "${key}" placeholders, where the key
    // is an integer corresponding to entries from field_types.h or
    // |AutofillFormatProto::AutofillAssistantCustomField|.
    // Example:
    // * "3" -> First name.
    // * "${3}" -> First name.
    // * "(+${12}) (${11}) ${10}" -> phone country code, city code, number,
    //   e.g., (+41) (79) (1234567)
    // Note that the set of actually available fields are outside of our
    // control and are retrieved automatically from the provided profile.
    // An value expression set to an empty string will clear the field.
    optional string value_expression = 6;

    optional SelectorProto element = 2;

    // The strategy used to execute filling the value.
    optional KeyboardValueFillStrategy fill_strategy = 7;

    // The strategy used to select a value option.
    optional DropdownSelectStrategy select_strategy = 8;

    // Delay between two key presses when simlulating.
    optional int32 delay_in_millisecond = 4 [default = 20];

    // Fill in the fill even if it's non-empty. This is useful to work around
    // cases where the way autofill sets the field doesn't work on the website.
    // Usually used together with simulate_key_presses.
    optional bool forced = 5;

    // For JavaScript implemented dropdowns. This first clicks on the |element|,
    // then waits for |option_element_to_click| to appear and clicks it. The
    // selector must match a generic option, an |inner_text_pattern| will be
    // added to this element reference to match a single option.
    // Both clicks use the same |click_type|.
    optional SelectorProto option_element_to_click = 9;
    optional ClickType click_type = 10;

    reserved 1, 3;
  }

  oneof address_source {
    // The client memory key from which to retrieve the address.
    string name = 1;
    // The client model identifier from which to retrieve the address.
    string model_identifier = 9;
  }

  // Reference to an element in the form that should be filled.
  optional SelectorProto form_field_element = 4;

  // An optional list of fields that should be filled by this action.
  repeated RequiredField required_fields = 6;

  // If true, this skips the Autofill step jumping straight to the
  // |required_fields|.
  optional bool skip_autofill = 10;

  reserved 2, 7, 8;
}

// Fill a form with a credit card if there is one stored in client memory,
// otherwise fail this action.
message UseCreditCardProto {
  // Message used to indicate what form fields should be filled with what
  // information.
  message RequiredField {
    // A string containing any number of "${key}" placeholders, where the key
    // is an integer corresponding to entries from field_types.h or
    // |AutofillFormatProto::AutofillAssistantCustomField|.
    // Example:
    // * "51" -> Full name.
    // * "${51}" -> Full Name.
    // * "${53}/${55}" -> expiration month / expiration year
    // Note that the set of actually available fields are outside of our
    // control and are retrieved automatically from the provided credit card.
    // An value expression set to an empty string will clear the field.
    optional string value_expression = 6;

    optional SelectorProto element = 2;

    // The strategy used to execute filling the value.
    optional KeyboardValueFillStrategy fill_strategy = 7;

    // The strategy used to select a value option.
    optional DropdownSelectStrategy select_strategy = 8;

    // Delay between two key presses when simlulating.
    optional int32 delay_in_millisecond = 4 [default = 20];

    // Fill in the fill even if it's non-empty. This is useful to work around
    // cases where the way autofill sets the field doesn't work on the website.
    // Usually used together with simulate_key_presses.
    optional bool forced = 5;

    // For JavaScript implemented dropdowns. This first clicks on the |element|,
    // then waits for |option_element_to_click| to appear and clicks it. The
    // selector must match a generic option, an |inner_text_pattern| will be
    // added to this element reference to match a single option.
    // Both clicks use the same |click_type|.
    optional SelectorProto option_element_to_click = 9;
    optional ClickType click_type = 10;

    reserved 1, 3;
  }

  // The client model identifier from which to retrieve the credit card.
  // If not specified, will use the card stored in client memory instead.
  optional string model_identifier = 4;

  // A reference to the card number field in the form that should be filled.
  optional SelectorProto form_field_element = 3;

  repeated RequiredField required_fields = 7;

  // If true, this skips the Autofill step jumping straight to the
  // |required_fields|.
  optional bool skip_autofill = 8;

  reserved 1, 5, 6;
}

// Ask Chrome to wait for an element in the DOM. This can be used to only
// proceed to the next action once the page is ready.
message WaitForDomProto {
  // Fail after waiting this amount of time.
  optional int32 timeout_ms = 1;

  // Wait until this condition becomes true. If, at the end of the timeout, the
  // condition is not true, returns ELEMENT_RESOLUTION_FAILED.
  // The |wait_condition| can be used to store matches on the client by
  // annotating a |match| condition with a |client_id|. Note that matches that
  // were not found will be removed from the store, e.g. if they were entered
  // by a previous |WaitForDomProto|. The store also gets updated if the action
  // fails.
  optional ElementConditionProto wait_condition = 9;

  // If true, run scripts flagged with 'interrupt=true' as soon as their
  // preconditions match.
  optional bool allow_interrupt = 3;

  reserved 4 to 8;

  // Result to include into ProcessedActionProto.
  message Result {
    // Payload of all matching conditions, if one is set.
    repeated bytes matching_condition_payloads = 1;
  }
}

// A condition that expects a specific combination of elements. An empty
// condition is true.
message ElementConditionProto {
  oneof type {
    // The condition matches if all of these conditions match.
    ElementConditionsProto all_of = 1;

    // The condition matches if at least one of these conditions matches.
    ElementConditionsProto any_of = 2;

    // The condition matches if none of these conditions match.
    ElementConditionsProto none_of = 3;

    // The condition matches if the given element exists. An empty
    // ElementReference never match.
    SelectorProto match = 4;
  }

  // A payload that identifies this condition. WaitForDom puts this payload
  // into the result. This is ignored outside of WaitForDom.
  optional bytes payload = 5;

  // Optional. If set, the element of |match| will be stored under this
  // identifier on the client.
  optional ClientIdProto client_id = 6;
}

message ElementConditionsProto {
  repeated ElementConditionProto conditions = 1;
}

// Volatile upload of a portion of the dom for backend analysis, does not store
// anything.
message UploadDomProto {
  message Result {
    // The outer HTML of the element(s) matched by |tree_root|.
    repeated string outer_htmls = 1;
  }

  // The element that should be a root of uploaded DOM. If empty then the whole
  // page is returned.
  optional SelectorProto tree_root = 1;

  // Whether |tree_root| can match multiple elements. If false and multiple
  // elements are matched, this action will fail with TOO_MANY_MATCHES.
  optional bool can_match_multiple_elements = 2;
}

// Shows the progress bar.
message ShowProgressBarProto {
  // Message to show on the progress bar while loading.
  optional string message = 3;

  oneof progress_indicator {
    // Value between 0 and 100 indicating the current progress. Values above 100
    // will be capped to 100, values below 0 will be capped to 0 by the client.
    int32 progress = 6;

    // Value between 0 and |N| (where N is the size of the initial
    // |step_icons|) indicating the current step the flow is in, marking
    // all previous steps as complete. The active step will not be marked as
    // complete but instead be marked as active with a pulsating animation.
    // Setting the value to |N| or -1 will mark all steps as complete with no
    // step being active anymore.
    int32 active_step = 8;

    // The string reference of an icon defined in the
    // |StepProgressBarConfiguration|. This sets the |active_step| to that icon
    // with the same logic as |active_step| itself.
    string active_step_identifier = 11;

    // Completes the progress in whichever progress bar is active.
    bool complete_progress = 12;
  }

  // Whether the step progress bar should go into an error state.
  // If the active step is smaller than |N|, this will simply mark the last icon
  // as failed. If the active step is |N|, meaning that all steps have been
  // completed, this will mark the entire progress bar as failed.
  optional bool error_state = 10;

  // Hide the progress bar in the UI.
  optional bool hide = 7;

  message StepProgressBarIcon {
    optional DrawableProto icon = 1;

    // The reference identifier of this step.
    optional string identifier = 2;
  }

  // The configuration of the step progress bar. Only has an impact if the new
  // progress bar is being used. This configuration should only be sent once in
  // the initial call of the progress bar, as each appearance may cause the
  // progress bar being rerendered. The previous configuration will be carried
  // over in each new progress |ShowProgressBarAction|.
  message StepProgressBarConfiguration {
    // This boolean should always be true, unless you wish to switch to the
    // old progress bar during the flow. This is not recommended!
    optional bool use_step_progress_bar = 1;

    // Set the icons for the new progress bar. The size of the |step_icons|
    // gives the length of the progress bar. As such an empty list is not
    // supported. The list needs to be at least 2 items long.
    repeated StepProgressBarIcon annotated_step_icons = 3;

    reserved 2;
  }
  optional StepProgressBarConfiguration step_progress_bar_configuration = 9;

  reserved 1, 2, 4, 5;
}

// Contain all arguments to perform a highlight element action.
message HighlightElementProto {
  // The element to highlight.
  optional SelectorProto element = 1;
}

// Controls the browser navigation.
message NavigateProto {
  oneof value {
    // Navigate to the given URL.
    string url = 1;
    // Navigate backward in the history. Action will return PRECONDITION_FAILED
    // if it is not possible.
    bool go_backward = 2;
    // Navigate forward in the history. Action will return PRECONDITION_FAILED
    // if it is not possible.
    bool go_forward = 3;
  }
}

// Specify from which point in the script navigation is expected for the next
// call to WaitForNavigation.
message ExpectNavigationProto {}

// Wait for the browser to have navigated to a new page since the last
// ExpectNavigation or Navigate. This returns as soon as an HTTP response that's
// not a redirect was received for the new page, possibly before even loading
// the page content.
//
// Will return immediately if navigation already happened.
//
// Client errors:
//   NAVIGATION_ERROR if navigation failed
//   TIMED_OUT if timed out waiting for navigation to start
//   INVALID_ACTION no ExpectNavigation or Navigate action was executed in the
//     current script.
message WaitForNavigationProto {
  // How long to wait for navigation to start before failing with client status
  // TIMED_OUT. The action waits 20s by default.
  //
  // This is usually used to track cases where expected navigation doesn't
  // happen, because, for example, a click wasn't registered.
  optional int32 timeout_ms = 1;
}

// Chrome document.readyState values.
//
// Number is significant, as the document goes through these state in order,
// from initialized to complete.
enum DocumentReadyState {
  option allow_alias = true;

  DOCUMENT_UNKNOWN_READY_STATE = 0;
  DOCUMENT_UNINITIALIZED = 1;
  DOCUMENT_LOADING = 2;
  DOCUMENT_LOADED = 3;
  DOCUMENT_INTERACTIVE = 4;
  DOCUMENT_COMPLETE = 5;

  // Maximum value above.
  DOCUMENT_MAX_READY_STATE = 5;
}

// Wait for the document to be ready before proceeding.
//
// Client errors:
//   TIMED_OUT if timed out waiting for an acceptable state.
//   ELEMENT_RESOLUTION_FAILED if the specified frame selector could not be
//   found.
message WaitForDocumentProto {
  // Maximum amount of time to wait for the state to change. Set it to 0 to
  // check once and report the result immediately, without waiting.
  optional int32 timeout_ms = 1 [default = 5000];

  // If specified, check the document in the given frame, instead
  // of the main document.
  optional SelectorProto frame = 2;

  // The minimum ready state needed to satisfy the requirement.
  optional DocumentReadyState min_ready_state = 3
      [default = DOCUMENT_INTERACTIVE];

  message Result {
    // The ready state found when the action started.
    optional DocumentReadyState start_ready_state = 1;

    // The ready state found when the action ended.
    //
    // This is filled even when the action fails, so it is not guaranteed to
    // match min_ready_state.
    optional DocumentReadyState end_ready_state = 2;
  }
}

// Show backend-specified user interface elements to the user.
//
// Note that this action will behave similar to a prompt, i.e., it requires a
// specific EndAction interaction (usually tied to tapping a Chip) to end.
//
// Client errors:
//   INVALID_ACTION if |generic_user_interface| was ill-defined or incomplete,
//   or if the client failed to instantiate the UI for some reason. The Chrome
//   log should contain additional information about the issue, if verbose
//   logging is enabled (suggested level: 2 or 3).
message ShowGenericUiProto {
  message RequestAutofillCreditCards { optional string model_identifier = 1; }
  message RequestAutofillProfiles { optional string model_identifier = 1; }
  message RequestLoginOptions {
    message PasswordManagerLogins {
      optional string sublabel = 1;
      optional bytes payload = 2;
    }
    message LoginOption {
      oneof type {
        LoginOptionProto custom_login_option = 1;
        PasswordManagerLogins password_manager_logins = 2;
      }
    }

    repeated LoginOption login_options = 1;
    optional string model_identifier = 2;
  }
  message RequestUserData {
    message AdditionalValue {
      // The client memory identifier (from |UserData|).
      optional string source_identifier = 1;
      // The model identifier to write the value to (to |UserModel|).
      optional string model_identifier = 2;
    }
    // Additional values to write from |UserData| to |UserModel|.
    repeated AdditionalValue additional_values = 1;
  }
  message Result {
    // The model containing the values for all keys specified in
    // |output_model_identifiers|.
    optional ModelProto model = 1;
    // Set to true if the action was interrupted by a navigation event.
    optional bool navigation_ended = 2;
  }

  // The generic user interface to show.
  optional GenericUserInterfaceProto generic_user_interface = 1;

  // The set of model identifiers to write to the result. Note: this must be a
  // subset of the input model identifiers!
  repeated string output_model_identifiers = 2;

  // If specified, available autofill credit cards will be provided and
  // auto-updated in the specified |model_identifier|.
  optional RequestAutofillCreditCards request_credit_cards = 3;

  // If specified, available autofill profiles will be provided and auto-updated
  // in the specified |model_identifier|.
  optional RequestAutofillProfiles request_profiles = 4;

  // If specified, available login options (including those provided by password
  // manager) will be provided and auto-updated in the specified
  // |model_identifier|.
  optional RequestLoginOptions request_login_options = 5;

  message PeriodicElementChecks {
    message ElementCheck {
      // The element condition to be checked during the action.
      optional ElementConditionProto element_condition = 1;
      // The model identifier to write the result to.
      optional string model_identifier = 2;
    }
    repeated ElementCheck element_checks = 1;
  }
  optional PeriodicElementChecks periodic_element_checks = 6;
  // When set to true, end this action on navigation events. The result will
  // have |navigation_ended| set to true.
  optional bool end_on_navigation = 7;
  // If true, run scripts flagged with |interrupt=true| as soon as their
  // preconditions match, then go back to the parent action.
  optional bool allow_interrupt = 8;
  // If specified, will write the requested values from |UserData| to
  // |UserModel|. Will fail the action with PRECONDITION_FAILED if any of the
  // requested values is missing. Note that all values will have
  // |is_client_side_only| set to true.
  optional RequestUserData request_user_data = 9;

  reserved 10;
}

// Allow choosing one or more possibility. If ShowCast was called just
// before, allow interaction with the touchable element area, otherwise don't
// allow any interactions.
message PromptProto {
  // Display this message to the user.
  optional string message = 1;

  // A choice that can be triggered:
  // - by clicking on a chip, if a chip is set
  // - by triggering a direct action, if direct action names are set
  // - indirectly, DOM change, if auto_select_when if set
  //
  // One of these protos must is transmitted as-is back to the server as part of
  // ProcessedActionProto.
  message Choice {
    // The chip to display to the UI.
    optional ChipProto chip = 11;

    // Map this choice to a direct action.
    optional DirectActionProto direct_action = 12;

    // Auto-select this choice when the condition is met.
    optional ElementConditionProto auto_select_when = 15;

    // This chip is only visible or enabled if this condition is met.
    optional ElementConditionProto show_only_when = 16;

    // Disable the chip instead of hiding it completely, if the preconditions
    // don't match.
    optional bool allow_disabling = 9;

    // Server payload originally sent by the server. This should
    // be transmitted as-is by the client without interpreting.
    optional bytes server_payload = 5;

    reserved 4, 6, 8, 13, 14, 17;
  }
  repeated Choice choices = 4;

  // If true, run scripts flagged with 'interrupt=true' as soon as their
  // preconditions match, then go back to the prompt.
  optional bool allow_interrupt = 5;

  // If this is true, then we do not force expand the sheet when entering the
  // prompt state. When false or not set, this keeps the default behavior.
  optional bool disable_force_expand_sheet = 6;

  // If this is true, go into browse mode where navigation and user gestures
  // like go_back do not shut down autofill assistant.
  // TODO(marianfe): Consider introducing a BrowseAction instead.
  optional bool browse_mode = 7;

  // EXPERIMENTAL.
  // Only relevant if |browse_mode| is true. If set, the bottom sheet will
  // completely disappear when the action starts, and re-appear when the action
  // ends.
  //
  // Note: invisible prompts can't show chips to the user. This flag is intended
  // to be used with prompts that exclusively use choices which are
  // auto-selected based on DOM state, i.e., |auto_select_when|.
  optional bool browse_mode_invisible = 10;

  // When set to true, end prompt on navigation events happening during a prompt
  // action. The result sent back to the server in
  // ProcessedActionProto.prompt_choice will have |navigation_ended| set to
  // true.
  optional bool end_on_navigation = 8;

  // A list of domains and subdomains to allow users to navigate to when in
  // browse mode.
  repeated string browse_domains_allowlist = 9;

  // Result to pass to ProcessedActionProto.
  message Result {
    // This field is only used when crafting a response Choice for the server
    // when the |end_on_navigation| option is set. It means there was a
    // navigation event while in prompt mode that ended the action.
    optional bool navigation_ended = 2;

    // Server payload originally found in Choice.server_payload. This should be
    // transmitted as-is by the client without interpreting.
    optional bytes server_payload = 5;

    reserved 1;
  }
}

message ContactDetailsProto {
  // A subset of fields available for autofill profiles. See
  // |components/autofill/code/browser/field_types.h|.
  enum AutofillContactField {
    NAME_FULL = 7;
    EMAIL_ADDRESS = 9;
    PHONE_HOME_WHOLE_NUMBER = 14;
  }

  // Data saved under this name can be reused by UseAddressAction.
  optional string contact_details_name = 1;
  // If true asks user for full name.
  optional bool request_payer_name = 2;
  // If true asks user for email.
  optional bool request_payer_email = 3;
  // If true asks user for phone.
  optional bool request_payer_phone = 4;
  // This controls the summary of the selected contact in the collapsed contact
  // section (one line per field, in the order specified, up to and including
  // |max_number_summary_fields| lines).
  repeated AutofillContactField summary_fields = 5;
  // The maximum number of lines for the selected contact in the collapsed
  // contact section.
  optional int32 max_number_summary_lines = 6;
  // This controls the full description of contacts in the expanded contact
  // section (one line per field, in the order specified, up to and including
  // |max_number_full_lines| lines).
  repeated AutofillContactField full_fields = 7;
  // The maximum number of lines for contacts in the expanded contact section.
  optional int32 max_number_full_lines = 8;
  // If present, it will be used as the title to be displayed for the contact
  // details section instead of the default one.
  optional string contact_details_section_title = 9;
}

message LoginDetailsProto {
  // A custom login option which will be handled by the backend, e.g.,
  // 'Guest checkout' or 'Log in with Google'.
  message LoginOptionCustomProto {
    // The label to display to the user.
    optional string label = 1;
  }

  // Offers all matching Chrome password manager logins for the current website.
  message LoginOptionPasswordManagerProto {}

  message LoginOptionProto {
    // If set, an info icon will be shown that displays a popup when tapped.
    optional InfoPopupProto info_popup = 6;

    // The optional sublabel to display beneath the label.
    optional string sublabel = 7;
    optional string sublabel_accessibility_hint = 8;

    // The optional content description of the edit button. There are three
    // possible states:
    // - unset: the content description will be inferred from the button.
    // - set to empty string: this button is not important for a11y.
    // - set to non-empty string: the button will have the specified content
    // description.
    optional string edit_button_content_description = 10;

    // If the option was chosen, this payload will be returned to the server.
    optional bytes payload = 1;

    // Whether the UI should automatically choose this login option if no
    // password manager login options are available.
    optional bool choose_automatically_if_no_stored_login = 2;

    // Determines the priority with which to pre-select this login choice.
    // The lower the value, the higher the priority.
    optional int32 preselection_priority = 3;
    oneof type {
      LoginOptionCustomProto custom = 4;
      LoginOptionPasswordManagerProto password_manager = 5;
    }

    reserved 9;
  }
  // The title for the login selection (e.g., 'Login details for <domain>').
  optional string section_title = 1;
  // The list of available login options.
  repeated LoginOptionProto login_options = 2;
}

message DateTimeRangeProto {
  message TimeSlot {
    // The label to display.
    optional string label = 1;
    // The comparison value to be used to compare this timeslot
    // to others. Smaller values indicate earlier times. This will be used to
    // prevent start > end and vice-versa.
    optional int32 comparison_value = 2;
  }

  // The initial start date of the date/time range.
  optional DateProto start_date = 15;
  // The index of the initial start time slot to select.
  optional int32 start_time_slot = 13;
  // The initial end date of the date/time range.
  optional DateProto end_date = 16;
  // The index of the initial end time slot to select.
  optional int32 end_time_slot = 14;
  // The minimum allowed date of the date/time range.
  optional DateProto min_date = 3;
  // The maximum allowed date of the date/time range.
  optional DateProto max_date = 4;
  // The label for the start date (e.g., 'Pick up date').
  optional string start_date_label = 8;
  // The label for the start time (e.g., 'Pick up time').
  optional string start_time_label = 9;
  // The label for the end date (e.g., 'Drop off date').
  optional string end_date_label = 10;
  // The label for the end time (e.g., 'Drop off time').
  optional string end_time_label = 11;
  // The time slots to offer (e.g., 08:00 AM, 08:30 AM, ...)
  repeated TimeSlot time_slots = 12;
  // The error message to display if the date is not set.
  optional string date_not_set_error = 17;
  // The error message to display if the time is not set.
  optional string time_not_set_error = 18;

  reserved 1, 2, 5, 6, 7;
}

// A section showing a simple text message.
message StaticTextSectionProto {
  // The text to display. Can contain markup tags like <b>.
  optional string text = 1;
}

// A single text input.
message TextInputProto {
  optional string hint = 1;
  enum InputType {
    UNDEFINED = 0;
    // Regular text, no special formatting rules.
    INPUT_TEXT = 1;
    // An alphanumeric input, e.g. postal code or discount code.
    INPUT_ALPHANUMERIC = 2;
  }
  optional InputType input_type = 2;

  // The client memory key to store the result in.
  optional string client_memory_key = 3;

  // The initial value of the text input.
  optional string value = 4;
}

// A section containing one or multiple text inputs.
message TextInputSectionProto {
  repeated TextInputProto input_fields = 1;
}

message UserFormSectionProto {
  optional string title = 1;

  oneof section {
    StaticTextSectionProto static_text_section = 2;
    TextInputSectionProto text_input_section = 3;
    PopupListSectionProto popup_list_section = 4;
  }
  // Whether to send the result values to the backend.
  optional bool send_result_to_backend = 5;
}

// A section that when tapped presents the user a popup with a list of options.
// The selected option is displayed in the section.
message PopupListSectionProto {
  // The key used to store the selection in CollectUserDataResultProto
  optional string additional_value_key = 1;

  // The name of the items to be displayed
  repeated string item_names = 2;

  // The list of the indexes of the items to be initially selected.
  repeated int32 initial_selection = 3;

  // Whether to allow the selection of multiple items or just one.
  optional bool allow_multiselect = 4;

  // Whether the selection of this section is required to proceed.
  optional bool selection_mandatory = 5 [default = true];

  // The error message displayed when the selection is mandatory and missing.
  // Ignored if |selection_mandatory| is false.
  optional string no_selection_error_message = 6;
}

// Asks to provide the data used by UseAddressAction and
// UseCreditCardAction.
// Next: 34
message CollectUserDataProto {
  enum TermsAndConditionsState {
    // No choice has been made yet.
    NOT_SELECTED = 0;
    // The 'accept' radio button is toggled.
    ACCEPTED = 1;
    // The 'review' radio button is toggled.
    REVIEW_REQUIRED = 2;
  }

  optional string prompt = 1;
  // NOTE: The action does not ask separately for billing address.
  // The billing address is associated with the credit card that was picked.
  optional string billing_address_name = 2;
  // If present will save the shipping address inside the memory under the
  // specified name. If empty we won't ask for the shipping address. Data saved
  // under this name can be reused by UseAddressAction.
  optional string shipping_address_name = 3;
  // If present, it will be used as the title to be displayed for the shipping
  // address section instead of the default one.
  optional string shipping_address_section_title = 32;
  // When 'true' will ask for the credit card.
  optional bool request_payment_method = 4;
  // If non-empty, the UI will filter the available basic-card networks
  // accordingly (e.g., only `visa' and `mastercard').
  repeated string supported_basic_card_networks = 6;
  // Contact details that should be gathered.
  optional ContactDetailsProto contact_details = 5;
  // Optional specification for the confirm button (defaults to standard confirm
  // chip if not specified).
  optional ChipProto confirm_chip = 33;
  // Optionally allows confirming through the given direct actions.
  optional DirectActionProto confirm_direct_action = 10;
  // The initial state of the terms & conditions choice.
  optional TermsAndConditionsState terms_and_conditions_state = 8;
  // When 'false', hide the terms and conditions box in the UI.
  optional bool request_terms_and_conditions = 9 [default = true];
  // Whether the terms and conditions should be displayed as a single checkbox
  // with |accept_terms_and_conditions_text| as text. If false, the accept terms
  // will be displayed as a radio button next to an additional "Read and agree
  // later on domain.com" choice.
  optional bool show_terms_as_checkbox = 12;
  // The text for the terms and conditions "I accept..." choice. The text is
  // formatted such that '<b>text</b>' will be bold and '<link0>clickable
  // link</link0>', '<link1>other link</link1>', etc will be clickable links
  // that will finish this action and return the clicked link in the action
  // result.
  optional string accept_terms_and_conditions_text = 13;
  // Message that indicates that the user wants to review the terms and
  // conditions of a 3rd party's domain, e.g., 'example.com'.
  optional string terms_require_review_text = 20;
  // Privacy notice telling users that autofill assistant will send personal
  // data to a third partys website.
  optional string privacy_notice_text = 21;
  // Additional actions available to the user. This can be used for instance to
  // display a "Show terms" button that will navigate the user to the terms and
  // conditions page when clicked.
  repeated UserActionProto additional_actions = 11;
  // Optionally requests a payment method with a billing address that has a
  // postcode value.
  optional bool require_billing_postal_code = 14;
  // The error message to display when the billing address is missing the
  // postal code. This field is mandatory if |require_postal_code| is true.
  optional string billing_postal_code_missing_text = 15;
  // The error message to display when the selected credit card is expired.
  optional string credit_card_expired_text = 23;
  // The login details that should be gathered.
  optional LoginDetailsProto login_details = 16;
  // The date/time range that should be gathered.
  optional DateTimeRangeProto date_time_range = 17;
  // An optional list of additional sections, which is above all other sections.
  repeated UserFormSectionProto additional_prepended_sections = 18;
  // An optional list of additional sections, which is below all other sections.
  repeated UserFormSectionProto additional_appended_sections = 19;
  // Backend-configured user interface to show below
  // |additional_prepended_sections|.
  optional GenericUserInterfaceProto generic_user_interface_prepended = 22;
  // Backend-configured user interface to show below
  // |additional_appended_sections|.
  optional GenericUserInterfaceProto generic_user_interface_appended = 25;
  // Optional. Text to be shown in a separate info section.
  optional string info_section_text = 24;
  // Optional. If true the text in the info section will be centered.
  optional bool info_section_text_center = 31;
  // Optional. If specified, the continue button will only be enabled if the
  // boolean at this location is true (and everything else is valid too).
  optional string additional_model_identifier_to_check = 27;
  // Clears any previously selected credit card. The client will revert to
  // default-selecting the card instead. NOTE: When clearing the credit card
  // selection, the billing address should also be cleared!
  optional bool clear_previous_credit_card_selection = 28;
  // Clears the previously selected login option, if any. The client will revert
  // to default-selecting the login option instead.
  optional bool clear_previous_login_selection = 29;
  // The names of the selected profiles to clear. Should be a subset of
  // {billing_address_name, shipping_address_name,
  // contact_details.contact_details_name}. NOTE: when clearing the billing
  // address, the selected credit card should also be cleared!
  repeated string clear_previous_profile_selection = 30;

  reserved 7, 26;
}

// Stop Autofill Assistant.
message StopProto {
  // If true, close the Chrome Custom Tab, in addition to shutting down Autofill
  // Assistant.
  optional bool close_cct = 2;

  // Whether to show the feedback chip once Autofill Assistant has stopped.
  // Note that this is only relevant if the UI is still being shown after the
  // stop, which happens only if:
  // - close_cct is false.
  // - The action preceding this one is a Tell action.
  optional bool show_feedback_chip = 3;

  reserved 1;  // stop_action_type
}

message DetailsChangesProto {
  // Whether the changes require user approval. This de-emphasize
  // non-highlighted fields.
  optional bool user_approval_required = 1;

  // Whether the title should be highlighted.
  optional bool highlight_title = 2;

  // Whether the first description line should be highlighted.
  optional bool highlight_line1 = 3;

  // Whether the second description line should be highlighted.
  optional bool highlight_line2 = 4;

  // Whether the third description line should be highlighted.
  optional bool highlight_line3 = 5;
}

message DetailsProto {
  optional string title = 1;

  optional string image_url = 2;

  // Specifies the hint for accessibility. If set to empty, the image will not
  // be announced by accessibility.
  optional string image_accessibility_hint = 14;

  // Specifies what happens when user tap on the image in the details section.
  message ImageClickthroughData {
    // Whether to show the original URL where image is extracted from. Only
    // useful when 'image_url' is set.
    optional bool allow_clickthrough = 1;

    // When image clickthrough is allowed, below texts are used to customize the
    // modal dialog shown to user *if* they are set, otherwise default texts
    // will be used.
    optional string description = 2;
    optional string positive_text = 3;
    optional string negative_text = 4;

    // The url to present when user did choose to clickthrough.
    optional string clickthrough_url = 5;
  }

  optional ImageClickthroughData image_clickthrough_data = 12;

  // Optional label to provide additional price information.
  optional string total_price_label = 9;
  // The price containing the total amount and the currency to pay, formatted
  // in the client's locale (e.g., $123.00).
  optional string total_price = 6;

  optional string description_line_1 = 7;
  optional string description_line_2 = 8;
  optional string description_line_3 = 13;

  // Deprecated, but currently still necessary and supported. We can get rid of
  // these fields when the backend starts setting description_line_1 and 2.
  optional DateTimeProto datetime = 3;
  optional string description = 4;

  // The configuration for the placeholders.
  message PlaceholdersConfiguration {
    // Show a placeholder if |DetailsProto.image_url| is empty.
    optional bool show_image_placeholder = 1;

    // Show a placeholder if |DetailsProto.title| is empty.
    optional bool show_title_placeholder = 2;

    // Show a placeholder if |DetailsProto.description_line_1| is empty.
    optional bool show_description_line_1_placeholder = 3;

    // Show a placeholder if |DetailsProto.description_line_2| is empty.
    optional bool show_description_line_2_placeholder = 4;

    // Show a placeholder if |DetailsProto.description_line_3| is empty.
    optional bool show_description_line_3_placeholder = 5;
  }

  // The placeholders configuration. Note that a placeholder will be shown only
  // if the associated data is empty.
  optional PlaceholdersConfiguration placeholders = 15;

  // Deprecated, no longer supported.
  reserved 5, 10, 11;
}

// Show contextual information.
message ShowDetailsProto {
  oneof data_to_show {
    DetailsProto details = 1;
    // Shows full name and email address.
    string contact_details = 3;
    bool credit_card = 4;
    // Shows full name and address.
    string shipping_address = 5;
  }

  // Flags indicating which parts of the details (if any) have changed.
  // This field is taken into account only if |details| is filled.
  optional DetailsChangesProto change_flags = 2;

  // Whether the details should be added/appended instead of replacing the
  // current details.
  optional bool append = 6;

  // If set, add a delay of |delay_ms| before setting/appending the details.
  //
  // The details will never be shown if another ShowDetailsProto action with
  // |append| = false is sent after this action and before the delay is reached.
  //
  // Note that it's not possible to delay the clearing of the details. If
  // |data_to_show| is not set, then the details will be cleared directly.
  optional int32 delay_ms = 7;
}

// Set the value of an form element.
message SetFormFieldValueProto {
  message Result { optional bool fallback_to_simulate_key_presses = 1; }
  message KeyPress {
    oneof keypress {
      // Text to insert as-is into a form field.
      string text = 1;
      // DEPRECATED: A single US-ASCII character (e.g., 13 for carriage return).
      int32 keycode = 2;
      // Text as generated by processing a virtual key code with a keyboard
      // layout. This can also be used for keyboard control sequences such
      // as "\r" or "\t".
      string keyboard_input = 3;
      // Use the username from the Chrome password manager login previously
      // selected in a CollectUserDataAction.
      bool use_username = 4;
      // Use the password from the Chrome password manager login previously
      // selected in a CollectUserDataAction.
      bool use_password = 5;
      // Use the value stored at the specified memory location.
      string client_memory_key = 6;
      // A value from an Autofill source. Note that this must be preceded by a
      // |CollectUserDataAction|.
      AutofillValue autofill_value = 8;
    }

    reserved 7;
  }

  // A reference to the form element whose value should be set.
  optional SelectorProto element = 1;

  // The value to set.
  repeated KeyPress value = 2;

  // The strategy used to execute filling the value.
  optional KeyboardValueFillStrategy fill_strategy = 7;

  // Delay between two key presses when simlulating.
  optional int32 delay_in_millisecond = 6 [default = 20];

  reserved 5;
}

// Asks the password manager to generate a suitable password for |element|. The
// generated password can be filled in subsequent SetFormFieldValueProto
// actions.
message GeneratePasswordForFormFieldProto {
  // A reference to the form element for which to generate a password.
  optional SelectorProto element = 1;
  // The client memory key to store the generated password.
  optional string memory_key = 2;
}

// Presaves generated password to the password store.
// Presaving stores a generated password with empty username.
// Only possible if a password has already been generated using
// |GeneratePasswordForFormFieldProto|.
message PresaveGeneratedPasswordProto {
  // The client memory key of the stored password.
  optional string memory_key = 1;
}

// Asks the password save manager to save generated password after successful
// submission.
message SaveGeneratedPasswordProto {
  // The client memory key of stored password.
  optional string memory_key = 1;
}

// Configures the UI of the autofill assistant client.
message ConfigureUiStateProto {
  enum OverlayBehavior {
    // The overlay is decided according to the state the client is in.
    DEFAULT = 0;
    // The overlay is always hidden.
    HIDDEN = 1;
  }
  optional OverlayBehavior overlay_behavior = 1;
}

// Set an element attribute to a specific value.
message SetAttributeProto {
  // A reference to the form element whose attribute should be set.
  optional SelectorProto element = 1;

  // The attribute to set, e.g. ["style", "position"] to change
  // element.style.position.
  repeated string attribute = 2;

  // The value to set.
  optional string value = 3;
}

message InfoBoxProto {
  // Optional path to an image. Ok tick used if not set.
  optional string image_path = 1;

  // The explanation to show in the box. Not setting this field will clear an
  // existing info box.
  optional string explanation = 2;
}

// Shows an info box with informational content. The info box content is cleared
// when |info_box| is not set.
message ShowInfoBoxProto {
  optional InfoBoxProto info_box = 1;
}

// Allow scripts to configure the peek height of the sheet and whether we should
// resize the viewport by this peek height. If talkback is enabled, the mode is
// set to RESIZE_VISUAL_VIEWPORT. Changes to the mode are only applied after
// talkback is disabled.
message ConfigureBottomSheetProto {
  enum ViewportResizing {
    // Don't change resizing configuration.
    NO_CHANGE = 0;

    // Resize the layout viewport such that it is completely visible when the
    // sheet is in the peek state.
    RESIZE_LAYOUT_VIEWPORT = 1;

    // Don't resize the viewport such that it is overlaid by the sheet, even in
    // the peek state.
    NO_RESIZE = 2;

    // Dynamically resize the visual viewport by the height of the sheet. This
    // allows to fully scroll the page above the sheet at any time.
    RESIZE_VISUAL_VIEWPORT = 3;
  }

  // The peek mode allows to set what components are visible when the sheet is
  // in the peek (minimized) state.
  enum PeekMode {
    UNDEFINED_PEEK_MODE = 0;

    // Only show the swipe handle.
    HANDLE = 1;

    // Show the swipe handle, header (status message, poodle, profile icon) and
    // progress bar.
    HANDLE_HEADER = 2;

    // Show swipe handle, header, progress bar, suggestions and actions.
    HANDLE_HEADER_CAROUSELS = 3;
  }

  // Whether the viewport should be resized. Resizing the viewport is an
  // expensive operation, so toggling the resize on/off should be done
  // cautiously.
  optional ViewportResizing viewport_resizing = 1;

  // Set the peek mode. This will change the peek mode of the sheet without
  // actually updating the sheet to that setting. If viewport_resizing is set
  // to RESIZE_LAYOUT_VIEWPORT or was set by a previous ConfigureBottomSheet
  // action, the viewport will be resized to match the new peek height.
  optional PeekMode peek_mode = 2;

  // Maximum time to wait for the window to resize before continuing with the
  // script. If 0 or unset, the action doesn't wait.
  optional int32 resize_timeout_ms = 3;

  // Option to automatically expand or collapse the sheet or leave as is.
  oneof apply_state {
    // Go to the expanded state (same as if the user swiped the bottom sheet
    // up).
    bool expand = 4;
    // Go to the peek state (same as if the user swiped the bottom
    // sheet down).
    bool collapse = 5;
  }
}

// Allow scripts to display a form with multiple inputs.
message ShowFormProto {
  // The form to display.
  optional FormProto form = 1;

  // The chip to display below the form. This chip will be enabled only if all
  // form inputs are valid.
  optional ChipProto chip = 2;

  // Optionally allow confirming the prompt using given direct actions.
  optional DirectActionProto direct_action = 3;
}

message FormProto {
  // A result associated to this form, such that |input_results[i]| is the
  // result of |inputs[i]|. If the user clicks a link while in the form action,
  // |link| will be set to the index of the clicked link and |input_results|
  // may be incomplete.
  message Result {
    repeated FormInputProto.Result input_results = 1;
    // If this is set, it contains the index of the text link that was clicked.
    // E.g., <link4>Details</link4> will populate this field with '4' when
    // clicked.
    optional int32 link = 2;
  }

  // The different inputs to display.
  repeated FormInputProto inputs = 1;

  // Optionally adds an informational text below the form.
  optional string info_label = 2;
  // If set, an info icon will be shown next to the info label that prompts a
  // popup when tapped. Ignored if info_label is not set.
  optional InfoPopupProto info_popup = 3;
}

message FormInputProto {
  message Result {
    oneof input_type {
      CounterInputProto.Result counter = 1;
      SelectionInputProto.Result selection = 2;
    }
  }

  oneof input_type {
    CounterInputProto counter = 1;
    SelectionInputProto selection = 2;
  }
}

// An input that is made of one or more counters. This input is considered valid
// if its |validation_rule| is satisfied or if it doesn't have one.
message CounterInputProto {
  // A single counter.
  message Counter {
    // The label shown with the counter. All occurrences of the '{value}'
    // substring will be replaced by the current counter value. May contain
    // links of the form <link1>Some text</link1>.
    optional string label = 1;

    // Text shown below the label. Optional. May contain links of the form
    // <link1>Some text</link1>.
    optional string description_line_1 = 5;

    // Text shown below |description_line_2|. Optional. May contain links of the
    // form <link1>Some text</link1>.
    optional string description_line_2 = 8;

    // The possible values this counter can have. If empty, the possible values
    // will be all integer values between |min_value| and |max_value|.
    // Note that the order of the values matters and they will not be
    // automatically sorted.
    repeated int32 allowed_values = 6;

    // The minimum value this counter can have. Ignored if |allowed_values| is
    // not empty.
    optional int32 min_value = 2 [default = -0x80000000];  // kint32min

    // The maximum value this counter can have. Ignored if |allowed_values| is
    // not empty.
    optional int32 max_value = 3 [default = 0x7FFFFFFF];  // kint32max

    // The initial value of the counter. If |allowed_values| is not empty, it
    // must contain |initial_value| or it will otherwise default to the first
    // value.
    optional int32 initial_value = 4 [default = 0];

    reserved 7;
  }

  // A result associated to this counter.
  message Result {
    // The values of all counters from this CounterInputProto, such that
    // |values[i]| is the value of |counters[i]|.
    repeated int32 values = 1;
  }

  // A validation rule to validate this input values.
  message ValidationRule {
    // A rule to combine sub rules. This rule allows to express the following:
    //  - Rule A and Rule B must be satisfied.
    //  - Rule A or Rule B must be satisfied.
    //  - Rule A must not be satisfied.
    //  - At least 2 of Rules A, B or C must be satisfied.
    //
    // This rule is satisfied if the number of satisfied |sub_rules| is >=
    // min_satisfied_rules and <= max_satisfied_rules.
    message BooleanRule {
      // The sub rules to check.
      repeated ValidationRule sub_rules = 1;

      // The minimum number of rules that must be satisfied.
      optional int32 min_satisfied_rules = 2 [default = 0];

      // The maximum number of rules that must be satisfied.
      optional int32 max_satisfied_rules = 3
          [default = 0x7FFFFFFF];  // kint32max
    }

    // A rule on the value of one of the |counters|. This rule is satisfied if
    // min_value <= counter.value <= max_value.
    message CounterRule {
      // The index of the counter in |counters|. Must be >= 0 and <
      // |counters.size|.
      optional int32 counter_index = 1;

      // The minimum value this counter can have.
      optional int32 min_value = 2 [default = -0x80000000];  // kint32min

      // The maximum value this counter can have.
      optional int32 max_value = 3 [default = 0x7FFFFFFF];  // kint32max
    }

    // A rule on the sum of the |counters|. This rule satisfied if the sum of
    // all |counters| is >= min_value and <= max_value. If there is an overflow
    // when computing the sum, the behavior is undefined.
    message CountersSumRule {
      // The minimum value the total can have.
      optional int64 min_value = 1
          [default = -0x8000000000000000];  // kint64min

      // The maximum value this counter can have.
      optional int64 max_value = 2 [default = 0x7FFFFFFFFFFFFFFF];  // kint64max
    }

    oneof rule_type {
      BooleanRule boolean = 1;
      CounterRule counter = 2;
      CountersSumRule counters_sum = 3;
    }
  }

  // An optional label shown above the different counters.
  optional string label = 1;

  // The counters to display.
  repeated Counter counters = 2;

  // If specified, the input will initially display maximum |minimized_count|
  // counters. If |counters|.size > |minimized_count|, the remaining counters
  // will be displayed in an expandable section below the first
  // |minimized_count| counters. Setting this value will have no effect if
  // |expand_text| and |minimize_text| are not set.
  optional int32 minimized_count = 3 [default = 0x7FFFFFFF];  // kint32max

  // Text shown when counters are inside the expandable section and the section
  // is minimized. Clicking this text will expand the section and show the
  // remaining counters.
  optional string expand_text = 4;

  // Text shown when counters are inside the expandable section and the section
  // is expanded. Clicking this text will minimize the section and hide the
  // counters inside it.
  optional string minimize_text = 5;

  // Validation rule used to check whether the current values of this input are
  // valid.
  optional ValidationRule validation_rule = 6;

  // The minimum value of the sum of the counters. All counters decrease button
  // will be disabled if sum <= min_counters_sum.
  optional int64 min_counters_sum = 7
      [default = -0x8000000000000000];  // kint64min

  // The maximum value of the sum of the counters. All counters increase button
  // will be disabled if sum >= max_counters_sum.
  optional int64 max_counters_sum = 8
      [default = 0x7FFFFFFFFFFFFFFF];  // kint64max
}

// An input that allows the user to choose one or multiple options. This input
// is considered valid if the number of selected choices is bigger or equal than
// |min_choices|.
message SelectionInputProto {
  message Choice {
    // The label of this choice. May contain links of the form <link1>Some
    // text</link1>.
    optional string label = 1;

    // Text shown below the label. Optional. May contain links of the form
    // <link1>Some text</link1>.
    optional string description_line_1 = 3;

    // Text shown below |description_line_2|. Optional. May contain links of the
    // form <link1>Some text</link1>.
    optional string description_line_2 = 4;

    // Whether this choice is selected by default. If |allow_multiple| is false,
    // then maximum 1 Choice can have this set to true, otherwise the associated
    // FormAction will fail.
    optional bool selected = 2 [default = false];

    reserved 7;
  }

  message Result {
    // Stores whether each choice was selected or not, such that |selected[i]|
    // is true if |choices[i]| was selected.
    repeated bool selected = 1;
  }

  // An optional label shown above the different choices.
  optional string label = 1;

  // The choices to display.
  repeated Choice choices = 2;

  // Whether the user will be allowed to select multiple choices. If false, each
  // choice will be displayed with a radio button. Otherwise, it will be
  // displayed with checkboxes.
  optional bool allow_multiple = 3 [default = false];

  // The minimum number of choices that should be selected to consider this
  // input valid.
  optional int32 min_selected_choices = 4 [default = 1];
}

// Action to show a popup bubble on top of the bottom sheet, anchored at the
// icon. Setting an empty message will remove any existing and visible popup
// message. A second action replaces a previously shown message.
message PopupMessageProto {
  // Message to show in the popup.
  optional string message = 1;
}

// Action to get an element's status.
message GetElementStatusProto {
  optional SelectorProto element = 1;

  optional ValueMatch expected_value_match = 2;
  optional ValueSource value_source = 4;

  // If set and a mismatch happens, the action will report an failure status
  // with |ELEMENT_MISMATCH|. If this flag is set to false, the action will not
  // fail and simply report the result.
  optional bool mismatch_should_fail = 3;

  // The result that gets sent as part of |ProcessedActionProto.result_data|.
  message Result {
    // The field is considered not empty.
    optional bool not_empty = 1;
    // The field matches the expected input.
    optional bool match_success = 2;
    // The field was expected to match an empty expectation. For a value this
    // means an empty expected value, for a RegExp this means the extracted
    // match was empty.
    optional bool expected_empty_match = 4;

    // For logging and debugging.
    repeated ComparisonReport reports = 3;
  }

  enum ValueSource {
    NOT_SET = 0;
    // Compare the element's |value| attribute against this expected match.
    VALUE = 1;
    // Compare the element's |innerText| attribute against this expected match.
    INNER_TEXT = 2;
  }

  message MatchOptions {
    optional bool case_sensitive = 1;
    optional bool remove_space = 2;
  }

  message MatchExpectation {
    optional MatchOptions match_options = 1;

    oneof match_level {
      bool full_match = 2;
      bool contains = 3;
      bool starts_with = 4;
      bool ends_with = 5;
    }
  }

  message TextMatch {
    oneof value_source {
      // The value to check against.
      string value = 1;
      // A value from an Autofill source. Note that this must be preceded by a
      // |CollectUserDataAction|.
      AutofillValue autofill_value = 2;
      // A regular expression.
      string re2 = 4;
    }

    // Optional. The expectations to declare this as a matching success. If
    // left empty, the action will always be treated as successful.
    optional MatchExpectation match_expectation = 3;
  }

  message ValueMatch { optional TextMatch text_match = 1; }

  message ComparisonReport {
    optional MatchOptions match_options = 1;

    optional bool full_match = 2;
    optional bool contains = 3;
    optional bool starts_with = 4;
    optional bool ends_with = 5;

    optional bool empty = 6;
    optional bool expected_empty_match = 7;
  }
}

message ReleaseElementsProto {
  repeated ClientIdProto client_ids = 1;
}

// Action to unconditionally dispatch a custom JS event 'duplexweb' on document.
message DispatchJsEventProto {}
