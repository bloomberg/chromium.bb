// Copyright 2018 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto2";

option optimize_for = LITE_RUNTIME;
option java_package = "org.chromium.chrome.browser.autofill_assistant.proto";
option java_multiple_files = true;

package autofill_assistant;

import "generic_ui.proto";
import "model.proto";
import "view_layout.proto";

// A field trial containing the name of the trial and the name of the
// randomly selected trial group.
message FieldTrialProto {
  optional string trial_name = 1;
  optional string group_name = 2;
}

// Context contains client environment details.
message ClientContextProto {
  message Chrome {
    optional string chrome_version = 1;
    repeated FieldTrialProto active_field_trials = 2;
  }
  oneof client { Chrome chrome = 1; }

  // locale will be the language tag of the default locale. The tag should
  // be a well-formed IETF BCP 47 language tag with language and country code
  // (e.g., "en-US").
  // The intent is to communicate the client language preferences to the server.
  optional string locale = 5;

  // country should be a country code as defined by ISO 3166-1-alpha-2.
  // The intent is to communicate the client's location to the server.
  optional string country = 6;

  // Experiment ids string provided by the 'caller'.
  optional string experiment_ids = 7;

  // True if the script is called from a Chrome Custom Tab created for Autofill
  // Assistant.
  optional bool is_cct = 8;

  // True if the onboarding screen was shown to the user.
  optional bool is_onboarding_shown = 10;

  // True if the script was triggered by a direct action.
  optional bool is_direct_action = 9;

  message DeviceContextProto {
    message VersionProto {
      // The Android SDK version of the device.
      optional int32 sdk_int = 1;
    }
    optional VersionProto version = 1;

    // The manufacturer of the device.
    optional string manufacturer = 2;

    // The model of the device.
    optional string model = 3;
  }
  optional DeviceContextProto device_context = 11;

  enum AccountsMatchingStatus {
    // The account was not present in the intent.
    UNKNOWN = 0;

    // The account in the intent and the current chrome account match.
    ACCOUNTS_MATCHING = 1;

    // The account in the intent and the current chrome account DON'T match.
    ACCOUNTS_NOT_MATCHING = 2;
  }
  // Whether the account from the intent and the chrome account match.
  optional AccountsMatchingStatus accounts_matching_status = 12;
}

// Get the list of scripts that can potentially be run on a url.
message SupportsScriptRequestProto {
  optional string url = 1;

  // Parameters that can be used to filter the scripts suitable for execution.
  repeated ScriptParameterProto script_parameters = 2;

  optional ClientContextProto client_context = 3;
}

message ScriptParameterProto {
  // Parameter name, as found in the Intent, without prefix.
  optional string name = 3;
  optional string value = 2;
}

// Response of the list of supported scripts.
message SupportsScriptResponseProto {
  repeated SupportedScriptProto scripts = 1;

  // Defines what should happen if no scripts in [scripts] becomes runnable,
  // because of preconditions.
  optional ScriptTimeoutError script_timeout_error = 2;

  optional ClientSettingsProto client_settings = 3;
}

// Overlay image to be drawn on top of full overlays.
message OverlayImageProto {
  // The image to display. If set, |image_size| is mandatory.
  optional string image_url = 1;
  // The size of the image to display.
  optional ClientDimensionProto image_size = 2;
  // The margin between the top of the page (anchor) and the image.
  optional ClientDimensionProto image_top_margin = 3;
  // The margin between the bottom of the image and the baseline of the text.
  optional ClientDimensionProto image_bottom_margin = 4;
  // The text to display beneath the image. If set, |text_color| and |text_size|
  // are mandatory.
  optional string text = 5;
  // Supported formats: #RRGGBB or #AARRGGBB.
  optional string text_color = 6;
  // The size of the text to display.
  optional ClientDimensionProto text_size = 7;
}

message ClientSettingsProto {
  reserved 10, 11;
  message IntegrationTestSettings {
    // Disables animations for the poodle and the progress bar.
    optional bool disable_header_animations = 1;
    // Disables change animations in the actions carousel.
    optional bool disable_carousel_change_animations = 2;
  }

  // Time between two periodic script precondition checks.
  optional int32 periodic_script_check_interval_ms = 1;

  // Time between two element checks in the script executor.
  optional int32 periodic_element_check_interval_ms = 2;

  // Run that many periodic checks before giving up unless something happens to
  // wake it up, such as the user touching the screen.
  optional int32 periodic_script_check_count = 3;

  // Time between two element position refreshes, when displaying highlighted
  // areas in prompt state.
  optional int32 element_position_update_interval_ms = 4;

  // Maximum amount of time normal actions should implicitly wait for a selector
  // to show up.
  optional int32 short_wait_for_element_deadline_ms = 5;

  // Time to wait between two checks of the box model, when waiting for an
  // element to become stable, such as before clicking.
  optional int32 box_model_check_interval_ms = 6;

  // Maximum number of checks to run while waiting for the element position to
  // become stable.
  optional int32 box_model_check_count = 7;

  // Time to wait between two checks of the document state, when waiting for the
  // document to become ready.
  optional int32 document_ready_check_interval_ms = 8;

  // Maximum number of checks to run while waiting for the document to become
  // ready.
  optional int32 document_ready_check_count = 9;

  // How much time to give users to tap undo when they tap a cancel button.
  optional int32 cancel_delay_ms = 12;

  // If the user taps the overlay that many time within |tap_duration| turn the
  // UI off and give them |tap_shutdown_delay| to undo. If 0, unexpected taps
  // are ignored.
  optional int32 tap_count = 13;

  // Reset the unexpected tap counter after that time.
  optional int32 tap_tracking_duration_ms = 14;

  // How much time to give users to tap undo when after |tap_count| unexpected
  // taps where
  optional int32 tap_shutdown_delay_ms = 15;

  // Optional image drawn on top of overlays.
  optional OverlayImageProto overlay_image = 16;

  // Optional settings intended for integration tests.
  optional IntegrationTestSettings integration_test_settings = 17;

  // Optional setting defining the size of the bottom sheet when Talkback is
  // enabled as a fraction of the available height. When set, the bottomsheet
  // will stop resizing automatically in talkback mode. It will always have the
  // specified size instead.
  optional float talkback_sheet_size_fraction = 18;
}

message ScriptTimeoutError {
  // Wait for that long before considering that scripts preconditions have timed
  // out and executing the script specified in script_path.
  //
  // The script might be called more than once if the script terminates
  // successfully and again still nothing is found after timeout_ms.
  optional int32 timeout_ms = 1;

  // The script to execute when the error happens.
  optional string script_path = 2;
}

// Supported script.
message SupportedScriptProto {
  // This is the internal name of the script.
  optional string path = 1;

  message PresentationProto {
    // Precondition contains a set of conditions that must hold for a script to
    // be executed. No precondition means that a script can run in any case.
    optional ScriptPreconditionProto precondition = 3;

    // Text display at the same time as the script is proposed. If more than one
    // script has an initial prompt, the prompt of the highest-priority script
    // wins.
    optional string initial_prompt = 4;

    // Display priority of the script. Lowest number has highest priority, which
    // means a script with priority 0 should be displayed before a script with
    // priority 1.
    optional int32 priority = 5;

    // An optional chip to display.
    optional ChipProto chip = 12;

    // Optionally map this script to a direct action.
    optional DirectActionProto direct_action = 13;

    // When set to true this script can be run in 'autostart mode'.
    optional bool autostart = 8;

    // When set to true this script will be run from WaitForDom actions with
    // allow_interrupt=true.
    optional bool interrupt = 9;

    // Message to show once the script has been started. This is shown while
    // loading the actions.
    optional string start_message = 14;

    // Show the UI if it's not shown yet. Setting this to false is useful for
    // scripts started by direct actions.
    optional bool needs_ui = 15 [default = true];
  }
  optional PresentationProto presentation = 2;
}

enum ScriptStatusProto {
  // Never explicitly set. Reading this value means the enum field is either
  // not set or set to a value not listed here.
  UNKNOWN_SCRIPT_STATUS = 0;
  // The script finished successfully.
  SCRIPT_STATUS_SUCCESS = 1;
  // The script failed.
  SCRIPT_STATUS_FAILURE = 2;
  // The user cancelled the script.
  SCRIPT_STATUS_CANCELLED = 3;
  // The script is currently running.
  SCRIPT_STATUS_RUNNING = 4;
  // The script was not run.
  SCRIPT_STATUS_NOT_RUN = 5;
}

// Condition on the status of a previous script run.
message ScriptStatusMatchProto {
  enum Comparator {
    UNSPECIFIED = 0;
    EQUAL = 1;
    DIFFERENT = 2;
  }

  // Required. Path of the script whose status should be checked.
  optional string script = 1;

  // Required. The status the script should have for the condition to hold.
  optional ScriptStatusProto status = 2;

  // Optional. The comparison performed when checking the status. It will be
  // interpreted as EQUAL if not set.
  optional Comparator comparator = 3;
}

message ScriptPreconditionProto {
  // Pattern of the path parts of the URL, including query and '#''.
  repeated string path_pattern = 5;
  // Domain (exact match) excluding the last '/' character.
  repeated string domain = 6;

  // Combined with AND: all matches must be true for precondition to hold.
  repeated ScriptParameterMatchProto script_parameter_match = 7;
  repeated ScriptStatusMatchProto script_status_match = 8;

  // Script can only run if the given condition match.
  optional ElementConditionProto element_condition = 10;

  reserved 3, 9;
}

message ScriptParameterMatchProto {
  // Parameter name, as found in the Intent, without prefix.
  optional string name = 4;

  // Checks whether the script parameter is present.
  optional bool exists = 2 [default = true];

  // Checks whether the script parameter has exact value. Empty or missing value
  // is treated as wildcard - any value will pass.
  optional string value_equals = 3;
}

enum PolicyType {
  UNKNOWN_POLICY = 0;
  SCRIPT = 1;
}

message ScriptActionRequestProto {
  optional ClientContextProto client_context = 7;

  // Global payload from the previous response, possibly for another script.
  optional bytes global_payload = 8;

  // Script payload from the previous response, for the same script.
  //
  // For backward compatibility, for initial requests, forward the last returned
  // script_payload.
  optional bytes script_payload = 2;

  oneof request {
    InitialScriptActionsRequestProto initial_request = 4;
    NextScriptActionsRequestProto next_request = 5;
  }
}

// Initial request to get a script's actions.
message InitialScriptActionsRequestProto {
  message QueryProto {
    // The backend expects the |script_path| to be a repeated field. This field
    // is expected to contain only one element.
    repeated string script_path = 1;
    // The exact URL on which the script was initially started.
    optional string url = 2;
    optional PolicyType policy = 3;
  }
  optional QueryProto query = 3;

  repeated ScriptParameterProto script_parameters = 2;
}

// Next request to get a script's actions.
message NextScriptActionsRequestProto {
  // The result of processing each ActionProto from the previous response. This
  // field must be in the same order as the actions in the original response.
  // It may have less actions in case of failure.
  repeated ProcessedActionProto processed_actions = 1;
}

// Response of a script's actions.
message ActionsResponseProto {
  // Opaque data to send to the next ScriptActionRequestProto.
  optional bytes global_payload = 4;

  // Opaque data to send to the next ScriptActionRequestProto for the same
  // script.
  optional bytes script_payload = 2;

  // Actions to be performed in order.
  // Should stop processing as soon as an action fails.
  repeated ActionProto actions = 3;

  // List of scripts to update.
  //
  // The client is expected to update the cache of scripts with this new
  // information. No action is needed when this field is not set. If the field
  // is set with an empty list of scripts, then no script is eligible to run
  // anymore.
  //
  // Note: This is an intermediate solution and the logic associated with this
  // field will eventually be absorbed into the supports script response from
  // the backend.
  message UpdateScriptListProto { repeated SupportedScriptProto scripts = 1; }
  optional UpdateScriptListProto update_script_list = 5;
}

enum KeyboardValueFillStrategy {
  UNSPECIFIED_KEYBAORD_STRATEGY = 0;

  // Send a `node.value = "<value>"` JS command.
  SET_VALUE = 1;

  // Send a `node.value = ""` JS command to clear the field, then send single
  // key strokes.
  SIMULATE_KEY_PRESSES = 2;

  // Send a `node.select()` JS command to select the current field value, then
  // send single key strokes overwriting the current value.
  SIMULATE_KEY_PRESSES_SELECT_VALUE = 3;
}

enum DropdownSelectStrategy {
  UNSPECIFIED_SELECT_STRATEGY = 0;

  // Match by the option's value, case insensitive.
  VALUE_MATCH = 1;

  // Match by the option's label, case insensitive.
  LABEL_MATCH = 2;

  // Match by the option's label by `label.startsWith`, case insensitive.
  LABEL_STARTS_WITH = 3;
}

// This type disambiguates the term "clicking" on a node in the DOM by defining
// what strategy should be used to execute the "click".
enum ClickType {
  NOT_SET = 0;

  // Send a tap event to the node.
  TAP = 1;

  // Use JavaScript's `node.click()` to click the element.
  JAVASCRIPT = 2;

  // Send a click event to the node.
  CLICK = 3;
}

// An action could be performed.
message ActionProto {
  // Wait these many milliseconds before executing the action, if set.
  optional int32 action_delay_ms = 3;

  // Opaque data that should not be interpreted by the client. The client must
  // pass this back unchanged in the next request
  optional bytes server_payload = 4;

  oneof action_info {
    ClickProto click = 5;
    SetFormFieldValueProto set_form_value = 6;
    SelectOptionProto select_option = 7;
    NavigateProto navigate = 9;
    PromptProto prompt = 10;
    TellProto tell = 11;
    FocusElementProto focus_element = 12;
    WaitForDomProto wait_for_dom = 19;
    UseCreditCardProto use_card = 28;
    UseAddressProto use_address = 29;
    UploadDomProto upload_dom = 18;
    ShowProgressBarProto show_progress_bar = 24;
    HighlightElementProto highlight_element = 31;
    ShowDetailsProto show_details = 32;
    StopProto stop = 35;
    CollectUserDataProto collect_user_data = 36;
    SetAttributeProto set_attribute = 37;
    ShowInfoBoxProto show_info_box = 39;
    ExpectNavigationProto expect_navigation = 40;
    WaitForNavigationProto wait_for_navigation = 41;
    ConfigureBottomSheetProto configure_bottom_sheet = 42;
    ShowFormProto show_form = 43;
    PopupMessageProto popup_message = 44;
    WaitForDocumentProto wait_for_document = 45;
    ShowGenericUiProto show_generic_ui = 49;
    GeneratePasswordForFormFieldProto generate_password_for_form_field = 52;
    SaveGeneratedPasswordProto save_generated_password = 53;
  }

  // Set to true to make the client remove any contextual information if the
  // script finishes with this action. It has no effect if there is any other
  // action sent to the client after this one. Default is false.
  optional bool clean_contextual_ui = 33;

  reserved 34, 46, 47, 48, 50, 51;
}

// Result of |CollectUserDataProto| to be sent to the server.
message CollectUserDataResultProto {
  optional string card_issuer_network = 1;
  // Whether the integrated terms and conditions approval checkbox was checked.
  optional bool is_terms_and_conditions_accepted = 2;
  // The email address of the payer.
  optional string payer_email = 3;
  // If set, this means that the user triggered the action in
  // |CollectUserDataProto.additional_actions| that has index
  // |additional_action_index|.
  optional int32 additional_action_index = 4;
  // If set, this means that the user clicked on one of the terms and conditions
  // links.
  optional int32 terms_link = 5;
  // The payload of the chosen login option.
  optional bytes login_payload = 6;
  // The values obtained by the generic user interface.
  optional ModelProto model = 9;
  // The memory keys of all non-empty text inputs, corresponding to the memory
  // keys specified in |TextInputProto|. The values themselves are stored in the
  // client and do not leave the device.
  repeated string set_text_input_memory_keys = 10;
  // The start date of the date/time range, if requested.
  optional DateProto date_range_start_date = 11;
  // The index of the selected timeslot for the start of the date/time range.
  optional int32 date_range_start_timeslot = 12;
  // The end date of the date/time range, if requested.
  optional DateProto date_range_end_date = 13;
  // The index of the selected timeslot for the end of the date/time range.
  optional int32 date_range_end_timeslot = 14;
  // The values obtained from the additional sections.
  repeated ModelProto.ModelValue additional_sections_values = 15;
  // Indicates whether the UI was shown to the user. This can be false if
  // only the login section was requested and the choice was implicitly made.
  optional bool shown_to_user = 16;

  reserved 7, 8;
}

message ProcessedActionProto {
  // The action that was processed.
  optional ActionProto action = 1;

  optional ProcessedActionStatusProto status = 2;

  optional ProcessedActionStatusDetailsProto status_details = 19;

  oneof result_data {
    PromptProto.Choice prompt_choice = 5;
    string html_source = 12;
    // Should be set as a result of CollectUserDataAction.
    CollectUserDataResultProto collect_user_data_result = 15;
    // Should be set as a result of SetFormFieldValueAction.
    SetFormFieldValueProto.Result set_form_field_value_result = 17;
    // May be set as a result of WaitForDomProto.
    WaitForDomProto.Result wait_for_dom_result = 22;
    // Should be set as a result of FormAction.
    FormProto.Result form_result = 21;

    WaitForDocumentProto.Result wait_for_document_result = 25;
    // Should be set as a result of ShowGenericUiProto.
    ShowGenericUiProto.Result show_generic_ui_result = 28;
  }

  // Reports information about navigation that happened while
  // processing the action. This is meant for debugging.
  optional NavigationInfoProto navigation_info = 20;

  // Reports how long it took for the client to run the action. This does not
  // include the delay specified in action.delay_ms.
  optional int64 run_time_ms = 23;

  // If true, the user triggered, during the client action, at least one user
  // action, such as a prompt choice, through a direct action instead of
  // selecting a chip on the UI. This is meant for monitoring and debugging.
  optional bool direct_action = 24;

  reserved 26, 27;
}

// Extended information about the action status, which provides more details
// about what happened than a simple ProcessedActionStatusProto can.
message ProcessedActionStatusDetailsProto {
  // More information included for unexpected errors.
  //
  // Only set for action whose status are OTHER_ACTION_STATUS or
  // UNEXPECTED_JS_ERROR.
  optional UnexpectedErrorInfoProto unexpected_error_info = 1;

  // In some case, such as USER_ABORTED_ACTION and NAVIGATION_ERROR, the status
  // reported by the action is overridden after the action failed, to report a
  // more appropriate error. When that happens, this field contains the original
  // status, to help debugging.
  optional ProcessedActionStatusProto original_status = 2;

  // More information included for autofill related errors.
  optional AutofillErrorInfoProto autofill_error_info = 3;
}

message NavigationInfoProto {
  // Navigation started while processing the current action.
  optional bool started = 1;

  // Navigation ended while processing the current action.
  optional bool ended = 2;

  // Navigation failed before or during the processing of the current action.
  optional bool has_error = 3;

  // Unexpected navigation started while processing the current action. This
  // will happen during some actions, such as PROMPT action but it should
  // normally not happen during scripts that have been updated to use
  // expect_navigation.
  optional bool unexpected = 4;
}

// Extra debugging information included in case of unexpected errors.
//
// Presence of this element is usually the sign of a bug in the client code and
// is always the sign that the client code needs to be updated: such issues
// should be either fixed or reported as proper, expected error with a useful
// status code.
message UnexpectedErrorInfoProto {
  // Source file, within the client code, where an unexpected error was detected
  // and reported.
  //
  // Only filled for unexpected errors OTHER_ACTION_STATUS and
  // UNEXPECTED_JS_ERROR.
  //
  // This and source_line are only meaningful for the exact version reported in
  // the client context.
  optional string source_file = 1;

  // Line number, within the client's source file, where the error was detected.
  optional int32 source_line_number = 2;

  // JavaScript exception class name, if reporting a JavaScript error.
  optional string js_exception_classname = 3;

  // JavaScript exception line number, within the js snippet that was sent to
  // devtools runtime by the client, if reporting a JavaScript error.
  optional int32 js_exception_line_number = 4;

  // JavaScript exception column number, within the js snippet that was sent to
  // devtools runtime by the client, if reporting a JavaScript error.
  optional int32 js_exception_column_number = 5;

  // Error code returned by devtools, if any. 0 is considered a success.
  optional int32 devtools_error_code = 6;

  // Error message returned by devtools, if any.
  optional string devtools_error_message = 7;
}

// Message to report autofill related errors for debugging purposes.
message AutofillErrorInfoProto {
  message AutofillFieldError {
    // The field the error occurred for.
    optional ElementReferenceProto field = 1;

    // The value expression associated with the field that caused the error.
    optional string value_expression = 5;

    oneof error_type {
      // No fallback value for this field.
      bool no_fallback_value = 3;

      // The status of the action.
      ProcessedActionStatusProto status = 4;
    }

    reserved 2;
  }

  // Comma separated list of address keys in the client memory when the
  // unexpected error occurred. Memory values are never reported this way since
  // they may contain PII. Only the address key names!
  optional string client_memory_address_key_names = 1;

  // Name of the address key requested in the list of keys in
  // |client_memory_address_key_names|.
  optional string address_key_requested = 2;

  // Whether the client memory at |address_key_requested| pointed to null.
  optional bool address_pointee_was_null = 3;

  // Error status of the Chrome autofill attempt.
  optional ProcessedActionStatusProto autofill_error_status = 4;

  // Errors that occurred during fallback filling of autofill fields.
  repeated AutofillFieldError autofill_field_error = 5;
}

// The pseudo type values come from
// https://chromedevtools.github.io/devtools-protocol/tot/DOM#type-PseudoType.
enum PseudoType {
  UNDEFINED = 0;
  FIRST_LINE = 1;
  FIRST_LETTER = 2;
  BEFORE = 3;
  AFTER = 4;
  BACKDROP = 5;
  SELECTION = 6;
  FIRST_LINE_INHERITED = 7;
  SCROLLBAR = 8;
  SCROLLBAR_THUMB = 9;
  SCROLLBAR_BUTTON = 10;
  SCROLLBAR_TRACK = 11;
  SCROLLBAR_TRACK_PIECE = 12;
  SCROLLBAR_CORNER = 13;
  RESIZER = 14;
  INPUT_LIST_BUTTON = 15;
}

// A reference to an unique element on the page, possibly nested in frames.
message ElementReferenceProto {
  // A sequence of CSS selectors. Any non-final CSS selector is expected to
  // arrive at a frame or an iframe, i.e. an element that contains another
  // document.
  // APIs are free to reject element references that do not refer to unique
  // elements (i.e. resolve to more than one element on the page).
  repeated string selectors = 2;

  // If non-empty, only take into accounts the elements matched by selector
  // whose inner text matches the given JavaScript regex. This does a search,
  // not a full match. Add ^ and $ as necessary.
  //
  // This is used to filter the elements matching the last selector, before
  // trying to get the pseudo_type, if any was set.
  optional string inner_text_pattern = 4;

  // If non-empty, only take into accounts the elements matched by selector
  // whose value matches the given JavaScript regex. This does a search,
  // not a full match. Add ^ and $ as necessary.
  //
  // This is used to filter the elements matching the last selector, before
  // trying to get the pseudo_type, if any was set.
  optional string value_pattern = 6;

  // Specifies whether the matched element(s) must be visible.
  //
  // Visibility applies to the element matched in selectors; the pseudo type is
  // checked afterwards.
  optional VisibilityRequirement visibility_requirement = 5;

  // An optional pseudo type. This pseudo type is associated to the final
  // element matched, which means that we currently don't handle matching an
  // element inside a pseudo element.
  optional PseudoType pseudo_type = 3;
}

enum VisibilityRequirement {
  UNSPECIFIED_VISIBILITY = 0;

  // Element must be visible. Visible elements are elements that have a box
  // model. The box model is not checked at all, so an element with a zero size
  // bounding box is considered visible.
  MUST_BE_VISIBLE = 1;

  // It's enough for the element to exist in the DOM tree for it to match.
  MUST_EXIST = 2;
}

// Contain all arguments to perform a click.
message ClickProto {
  optional ElementReferenceProto element_to_click = 1;
  optional ClickType click_type = 2;
}

// Contain all arguments to perform a select option action.
message SelectOptionProto {
  // The drop down element on which to select an option.
  optional ElementReferenceProto element = 2;

  // Value of the option to use.
  optional string selected_option = 3;

  // The strategy used to select a value option. This defaults to
  // |LABEL_STARTS_WITH| for the legacy case.
  optional DropdownSelectStrategy select_strategy = 4
      [default = LABEL_STARTS_WITH];
}

// Contain a localized text message from the server.
message TellProto {
  // The message to show in the status bar. The behavior is now the following
  //
  //  * If the field is set, the status bar is updated (explicitly setting an
  //    empty string clears the status bar).
  //  * If the field is not set, the status bar is not updated.
  optional string message = 1;

  // Show the UI if it's not shown yet, such as when a script has been started
  // by a direct action.
  optional bool needs_ui = 2 [default = true];
}

// Contain all arguments to focus on an element.
message FocusElementProto {
  message TopPadding {
    oneof top_padding {
      // Padding in CSS pixels. Eg. 20.
      int32 pixels = 1;
      // Ratio in relation to the window.innerHeight. Eg. 0.25.
      float ratio = 2;
    }
  }
  // Element to focus on.
  optional ElementReferenceProto element = 1;

  // Optional title to show in the status bar.
  optional string title = 2;

  // Restrict interaction to the area spanned by the given elements.
  //
  // Deprecated: use touchable_element_area instead. Ignored if
  // touchable_element_area is non-empty.
  repeated ElementReferenceProto deprecated_touchable_elements = 5;

  // Restrict interaction to a series of rectangular areas.
  optional ElementAreaProto touchable_element_area = 6;

  // The padding that will be added between the focused element and the top.
  optional TopPadding top_padding = 7;
}

// An area made up of rectangles whole border are made defined by the position
// of a given set of elements.
message ElementAreaProto {
  // A rectangle, drawn by one or more elements.
  //
  // The rectangle is the smallest rectangle that includes all listed elements.
  message Rectangle {
    repeated ElementReferenceProto elements = 1;

    // If true, the width of the rectangle always corresponds to the width of
    // the screen.
    optional bool full_width = 2;
  }

  // The rectangles that will be highlighted and touchable.
  repeated Rectangle touchable = 1;

  // The rectangles that should be neither highlighted nor touchable. Those
  // rectangles have precedence over the |touchable| rectangles.
  repeated Rectangle restricted = 2;
}

// Fill a form with an address if there is, otherwise fail this action.
message UseAddressProto {
  // Message used to indicate what form fields should be filled with what
  // information coming from the address.
  message RequiredField {
    // Fields we add that are not mapped to field_types.h. The values must be
    // negative not to overlap with the source.
    enum AutofillAssistantCustomField { UNDEFINED = 0; }

    // A string containing either a single integer key or multiple "${key}"
    // placeholders, where the key is an integer corresponding to entries from
    // field_types.h or RequiredField::AutofillAssistantCustomField.
    // Example:
    // * "3" -> First name.
    // * "${3}" -> First name.
    // * "(+${12}) (${11}) ${10}" -> phone country code, city code, number,
    //   e.g., (+41) (79) (1234567)
    // Note that the set of actually available fields are outside of our
    // control and are retrieved automatically from the provided profile.
    optional string value_expression = 6;

    optional ElementReferenceProto element = 2;

    // The strategy used to execute filling the value.
    optional KeyboardValueFillStrategy fill_strategy = 7;

    // The strategy used to select a value option.
    optional DropdownSelectStrategy select_strategy = 8;

    // Delay between two key presses when simlulating.
    optional int32 delay_in_millisecond = 4 [default = 20];

    // Fill in the fill even if it's non-empty. This is useful to work around
    // cases where the way autofill sets the field doesn't work on the website.
    // Usually used together with simulate_key_presses.
    optional bool forced = 5;

    // For JavaScript implemented dropdowns. This first clicks on the |element|,
    // then waits for |option_element_to_click| to appear and clicks it. The
    // selector must match a generic option, an |inner_text_pattern| will be
    // added to this element reference to match a single option.
    // Both clicks use the same |click_type|.
    optional ElementReferenceProto option_element_to_click = 9;
    optional ClickType click_type = 10;

    reserved 1, 3;
  }

  // An optional name to allow to handle multiple addresses selection (for
  // instance a billing and a delivery address).
  optional string name = 1;

  // An optional message to show to the user when asking to select an address.
  // TODO(crbug.com/806868): Make the prompt a required field.
  optional string prompt = 2;

  // Reference to an element in the form that should be filled.
  optional ElementReferenceProto form_field_element = 4;

  // An optional list of fields that should be filled by this action.
  repeated RequiredField required_fields = 6;

  // If true, this skips the Autofill step jumping straight to the
  // |required_fields|.
  optional bool skip_autofill = 10;

  reserved 7, 8, 9;
}

// Fill a form with a credit card if there is one stored in client memory,
// otherwise fail this action.
message UseCreditCardProto {
  // Message used to indicate what form fields should be filled with what
  // information.
  message RequiredField {
    // Fields we add that are not mapped to field_types.h. The values must be
    // negative not to overlap with the source.
    enum AutofillAssistantCustomField {
      UNDEFINED = 0;
      CREDIT_CARD_VERIFICATION_CODE = -1;
      CREDIT_CARD_NETWORK = -2;
      CREDIT_CARD_RAW_NUMBER = -3;
    }

    // A string containing either a single integer key or multiple "${key}"
    // placeholders, where the key is an integer corresponding to entries from
    // field_types.h or RequiredField::AutofillAssistantCustomField.
    // Example:
    // * "51" -> Full name.
    // * "${51}" -> Full Name.
    // * "${53}/${55}" -> expiration month / expiration year
    // Note that the set of actually available fields are outside of our
    // control and are retrieved automatically from the provided credit card.
    optional string value_expression = 6;

    optional ElementReferenceProto element = 2;

    // The strategy used to execute filling the value.
    optional KeyboardValueFillStrategy fill_strategy = 7;

    // The strategy used to select a value option.
    optional DropdownSelectStrategy select_strategy = 8;

    // Delay between two key presses when simlulating.
    optional int32 delay_in_millisecond = 4 [default = 20];

    // Fill in the fill even if it's non-empty. This is useful to work around
    // cases where the way autofill sets the field doesn't work on the website.
    // Usually used together with simulate_key_presses.
    optional bool forced = 5;

    // For JavaScript implemented dropdowns. This first clicks on the |element|,
    // then waits for |option_element_to_click| to appear and clicks it. The
    // selector must match a generic option, an |inner_text_pattern| will be
    // added to this element reference to match a single option.
    // Both clicks use the same |click_type|.
    optional ElementReferenceProto option_element_to_click = 9;
    optional ClickType click_type = 10;

    reserved 1, 3;
  }

  // An optional message to show to the user when asking to select a card.
  // TODO(crbug.com/806868): Make the prompt a required field.
  optional string prompt = 1;

  // A reference to the card number field in the form that should be filled.
  optional ElementReferenceProto form_field_element = 3;

  repeated RequiredField required_fields = 7;

  // If true, this skips the Autofill step jumping straight to the
  // |required_fields|.
  optional bool skip_autofill = 8;

  reserved 4, 5, 6;
}

// Ask Chrome to wait for an element in the DOM. This can be used to only
// proceed to the next action once the page is ready.
message WaitForDomProto {
  // Fail after waiting this amount of time.
  optional int32 timeout_ms = 1;

  // Wait until this condition becomes true. If, at the end of the timeout, the
  // condition is not true, returns ELEMENT_RESOLUTION_FAILED.
  optional ElementConditionProto wait_condition = 9;

  // If true, run scripts flagged with 'interrupt=true' as soon as their
  // preconditions match.
  optional bool allow_interrupt = 3;

  reserved 4 to 8;

  // Result to include into ProcessedActionProto.
  message Result {
    // Payload of all matching conditions, if one is set.
    repeated bytes matching_condition_payloads = 1;
  }
}

// A condition that expects a specific combination of elements. An empty
// condition is true.
message ElementConditionProto {
  oneof type {
    // The condition matches if all of these conditions match.
    ElementConditionsProto all_of = 1;

    // The condition matches if at least one of these conditions matches.
    ElementConditionsProto any_of = 2;

    // The condition matches if none of these conditions match.
    ElementConditionsProto none_of = 3;

    // The condition matches if the given element exists. An empty
    // ElementReference never match.
    ElementReferenceProto match = 4;
  }

  // A payload that identifies this condition. WaitForDom puts this payload
  // into the result. This is ignored outside of WaitForDom.
  optional bytes payload = 5;
}

message ElementConditionsProto {
  repeated ElementConditionProto conditions = 1;
}

// Volatile upload of a portion of the dom for backend analysis, does not store
// anything.
message UploadDomProto {
  // The element that should be a root of uploaded DOM. If empty then the whole
  // page is returned.
  optional ElementReferenceProto tree_root = 1;
}

// Shows the progress bar.
message ShowProgressBarProto {
  // Message to show on the progress bar while loading.
  optional string message = 3;

  // Value between 0 and 100 indicating the current progress. Values above 100
  // will be capped to 100, values below 0 will be capped to 0 by the client.
  // NOTE: Setting |progress| to 100 is an equivalent of setting |done| to true.
  optional int32 progress = 6;

  // Hide the progress bar in the UI.
  optional bool hide = 7;
}

// Contain all arguments to perform a highlight element action.
message HighlightElementProto {
  // The element to highlight.
  optional ElementReferenceProto element = 1;
}

// Controls the browser navigation.
message NavigateProto {
  oneof value {
    // Navigate to the given URL.
    string url = 1;
    // Navigate backward in the history. Action will return PRECONDITION_FAILED
    // if it is not possible.
    bool go_backward = 2;
    // Navigate forward in the history. Action will return PRECONDITION_FAILED
    // if it is not possible.
    bool go_forward = 3;
  }
}

// Specify from which point in the script navigation is expected for the next
// call to WaitForNavigation.
message ExpectNavigationProto {}

// Wait for the browser to have navigated to a new page since the last
// ExpectNavigation or Navigate. This returns as soon as an HTTP response that's
// not a redirect was received for the new page, possibly before even loading
// the page content.
//
// Will return immediately if navigation already happened.
//
// Client errors:
//   NAVIGATION_ERROR if navigation failed
//   TIMED_OUT if timed out waiting for navigation to start
//   INVALID_ACTION no ExpectNavigation or Navigate action was executed in the
//     current script.
message WaitForNavigationProto {
  // How long to wait for navigation to start before failing with client status
  // TIMED_OUT. The action waits 20s by default.
  //
  // This is usually used to track cases where expected navigation doesn't
  // happen, because, for example, a click wasn't registered.
  optional int32 timeout_ms = 1;
}

// Chrome document.readyState values.
//
// Number is significant, as the document goes through these state in order,
// from initialized to complete.
enum DocumentReadyState {
  option allow_alias = true;

  DOCUMENT_UNKNOWN_READY_STATE = 0;
  DOCUMENT_UNINITIALIZED = 1;
  DOCUMENT_LOADING = 2;
  DOCUMENT_LOADED = 3;
  DOCUMENT_INTERACTIVE = 4;
  DOCUMENT_COMPLETE = 5;

  // Maximum value above.
  DOCUMENT_MAX_READY_STATE = 5;
}

// Wait for the document to be ready before proceeding.
//
// Client errors:
//   TIMED_OUT if timed out waiting for an acceptable state.
//   ELEMENT_RESOLUTION_FAILED if the specified frame selector could not be
//   found.
message WaitForDocumentProto {
  // Maximum amount of time to wait for the state to change. Set it to 0 to
  // check once and report the result immediately, without waiting.
  optional int32 timeout_ms = 1 [default = 5000];

  // If specified, check the document in the given frame, instead
  // of the main document.
  optional ElementReferenceProto frame = 2;

  // The minimum ready state needed to satisfy the requirement.
  optional DocumentReadyState min_ready_state = 3
      [default = DOCUMENT_INTERACTIVE];

  message Result {
    // The ready state found when the action started.
    optional DocumentReadyState start_ready_state = 1;

    // The ready state found when the action ended.
    //
    // This is filled even when the action fails, so it is not guaranteed to
    // match min_ready_state.
    optional DocumentReadyState end_ready_state = 2;
  }
}

// Show backend-specified user interface elements to the user.
//
// Note that this action will behave similar to a prompt, i.e., it requires a
// specific EndAction interaction (usually tied to tapping a Chip) to end.
//
// Client errors:
//   INVALID_ACTION if |generic_user_interface| was ill-defined or incomplete,
//   or if the client failed to instantiate the UI for some reason. The Chrome
//   log should contain additional information about the issue, if verbose
//   logging is enabled (suggested level: 2 or 3).
message ShowGenericUiProto {
  message RequestAutofillCreditCards { optional string model_identifier = 1; }
  message RequestAutofillProfiles { optional string model_identifier = 1; }
  message RequestLoginOptions {
    message PasswordManagerLogins {
      optional string sublabel = 1;
      optional bytes payload = 2;
    }
    message LoginOption {
      oneof type {
        LoginOptionProto custom_login_option = 1;
        PasswordManagerLogins password_manager_logins = 2;
      }
    }

    repeated LoginOption login_options = 1;
    optional string model_identifier = 2;
  }
  message Result {
    // The model containing the values for all keys specified in
    // |output_model_identifiers|.
    optional ModelProto model = 1;
  }

  // The generic user interface to show.
  optional GenericUserInterfaceProto generic_user_interface = 1;

  // The set of model identifiers to write to the result. Note: this must be a
  // subset of the input model identifiers!
  repeated string output_model_identifiers = 2;

  // If specified, available autofill credit cards will be provided and
  // auto-updated in the specified |model_identifier|.
  optional RequestAutofillCreditCards request_credit_cards = 3;

  // If specified, available autofill profiles will be provided and auto-updated
  // in the specified |model_identifier|.
  optional RequestAutofillProfiles request_profiles = 4;

  // If specified, available login options (including those provided by password
  // manager) will be provided and auto-updated in the specified
  // |model_identifier|.
  optional RequestLoginOptions request_login_options = 5;
}

// Allow choosing one or more possibility. If FocusElement was called just
// before, allow interaction with the touchable element area, otherwise don't
// allow any interactions.
message PromptProto {
  // Display this message to the user.
  optional string message = 1;

  // A choice that can be triggered:
  // - by clicking on a chip, if a chip is set
  // - by triggering a direct action, if direct action names are set
  // - indirectly, DOM change, if auto_select_when if set
  //
  // One of these protos must is transmitted as-is back to the server as part of
  // ProcessedActionProto.
  message Choice {
    // The chip to display to the UI.
    optional ChipProto chip = 11;

    // Map this choice to a direct action.
    optional DirectActionProto direct_action = 12;

    // Auto-select this choice when the condition is met.
    optional ElementConditionProto auto_select_when = 15;

    // This chip is only visible or enabled if this condition is met.
    optional ElementConditionProto show_only_when = 16;

    // Disable the chip instead of hiding it completely, if the preconditions
    // don't match.
    optional bool allow_disabling = 9;

    // Server payload originally sent by the server. This should
    // be transmitted as-is by the client without interpreting.
    optional bytes server_payload = 5;

    // This field is only used when crafting a response Choice for the server
    // when the |end_on_navigation| option is set. It means there was a
    // navigation event while in prompt mode that ended the action.
    optional bool navigation_ended = 17;

    reserved 4, 6, 8, 13, 14;
  }
  repeated Choice choices = 4;

  // If true, run scripts flagged with 'interrupt=true' as soon as their
  // preconditions match, then go back to the prompt.
  optional bool allow_interrupt = 5;

  // If this is true, then we do not force expand the sheet when entering the
  // prompt state. When false or not set, this keeps the default behavior.
  optional bool disable_force_expand_sheet = 6;

  // If this is true, go into browse mode where navigation and user gestures
  // like go_back do not shut down autofill assistant.
  // TODO(marianfe): Consider introducing a BrowseAction instead.
  optional bool browse_mode = 7;

  // When set to true, end prompt on navigation events happening during a prompt
  // action. The result sent back to the server will contain a Choice marked as
  // |navigation_ended|.
  optional bool end_on_navigation = 8;

  // A list of domains and subdomains to allow users to navigate to when in
  // browse mode.
  repeated string browse_domains_whitelist = 9;
}

message ContactDetailsProto {
  // A subset of fields available for autofill profiles. See
  // |components/autofill/code/browser/field_types.h|.
  enum AutofillContactField {
    NAME_FULL = 7;
    EMAIL_ADDRESS = 9;
    PHONE_HOME_WHOLE_NUMBER = 14;
  }

  // Data saved under this name can be reused by UseAddressAction.
  optional string contact_details_name = 1;
  // If true asks user for full name.
  optional bool request_payer_name = 2;
  // If true asks user for email.
  optional bool request_payer_email = 3;
  // If true asks user for phone.
  optional bool request_payer_phone = 4;
  // This controls the summary of the selected contact in the collapsed contact
  // section (one line per field, in the order specified, up to and including
  // |max_number_summary_fields| lines).
  repeated AutofillContactField summary_fields = 5;
  // The maximum number of lines for the selected contact in the collapsed
  // contact section.
  optional int32 max_number_summary_lines = 6;
  // This controls the full description of contacts in the expanded contact
  // section (one line per field, in the order specified, up to and including
  // |max_number_full_lines| lines).
  repeated AutofillContactField full_fields = 7;
  // The maximum number of lines for contacts in the expanded contact section.
  optional int32 max_number_full_lines = 8;
  // If present, it will be used as the title to be displayed for the contact
  // details section instead of the default one.
  optional string contact_details_section_title = 9;
}

message LoginDetailsProto {
  // A custom login option which will be handled by the backend, e.g.,
  // 'Guest checkout' or 'Log in with Google'.
  message LoginOptionCustomProto {
    // The label to display to the user.
    optional string label = 1;
  }

  // Offers all matching Chrome password manager logins for the current website.
  message LoginOptionPasswordManagerProto {}

  message LoginOptionProto {
    // If set, an info icon will be shown that displays a popup when tapped.
    optional InfoPopupProto info_popup = 6;

    // The optional sublabel to display beneath the label.
    optional string sublabel = 7;
    optional string sublabel_accessibility_hint = 8;

    // If the option was chosen, this payload will be returned to the server.
    optional bytes payload = 1;

    // Whether the UI should automatically choose this login option if no
    // password manager login options are available.
    optional bool choose_automatically_if_no_stored_login = 2;

    // Determines the priority with which to pre-select this login choice.
    // The lower the value, the higher the priority.
    optional int32 preselection_priority = 3;
    oneof type {
      LoginOptionCustomProto custom = 4;
      LoginOptionPasswordManagerProto password_manager = 5;
    }
  }
  // The title for the login selection (e.g., 'Login details for <domain>').
  optional string section_title = 1;
  // The list of available login options.
  repeated LoginOptionProto login_options = 2;
}

message DateTimeRangeProto {
  message TimeSlot {
    // The label to display.
    optional string label = 1;
    // The comparison value to be used to compare this timeslot
    // to others. Smaller values indicate earlier times. This will be used to
    // prevent start > end and vice-versa.
    optional int32 comparison_value = 2;
  }

  // The initial start date of the date/time range.
  optional DateProto start_date = 15;
  // The index of the initial start time slot to select.
  optional int32 start_time_slot = 13;
  // The initial end date of the date/time range.
  optional DateProto end_date = 16;
  // The index of the initial end time slot to select.
  optional int32 end_time_slot = 14;
  // The minimum allowed date of the date/time range.
  optional DateProto min_date = 3;
  // The maximum allowed date of the date/time range.
  optional DateProto max_date = 4;
  // The label for the start date (e.g., 'Pick up date').
  optional string start_date_label = 8;
  // The label for the start time (e.g., 'Pick up time').
  optional string start_time_label = 9;
  // The label for the end date (e.g., 'Drop off date').
  optional string end_date_label = 10;
  // The label for the end time (e.g., 'Drop off time').
  optional string end_time_label = 11;
  // The time slots to offer (e.g., 08:00 AM, 08:30 AM, ...)
  repeated TimeSlot time_slots = 12;
  // The error message to display if the date is not set.
  optional string date_not_set_error = 17;
  // The error message to display if the time is not set.
  optional string time_not_set_error = 18;

  reserved 1, 2, 5, 6, 7;
}

// A section showing a simple text message.
message StaticTextSectionProto {
  // The text to display. Can contain markup tags like <b>.
  optional string text = 1;
}

// A single text input.
message TextInputProto {
  optional string hint = 1;
  enum InputType {
    UNDEFINED = 0;
    // Regular text, no special formatting rules.
    INPUT_TEXT = 1;
    // An alphanumeric input, e.g. postal code or discount code.
    INPUT_ALPHANUMERIC = 2;
  }
  optional InputType input_type = 2;

  // The client memory key to store the result in.
  optional string client_memory_key = 3;

  // The initial value of the text input.
  optional string value = 4;
}

// A section containing one or multiple text inputs.
message TextInputSectionProto {
  repeated TextInputProto input_fields = 1;
}

message UserFormSectionProto {
  optional string title = 1;

  oneof section {
    StaticTextSectionProto static_text_section = 2;
    TextInputSectionProto text_input_section = 3;
    PopupListSectionProto popup_list_section = 4;
  }
  // Whether to send the result values to the backend.
  optional bool send_result_to_backend = 5;
}

// A section that when tapped presents the user a popup with a list of options.
// The selected option is displayed in the section.
message PopupListSectionProto {
  // The key used to store the selection in CollectUserDataResultProto
  optional string additional_value_key = 1;

  // The name of the items to be displayed
  repeated string item_names = 2;

  // The list of the indexes of the items to be initially selected.
  repeated int32 initial_selection = 3;

  // Whether to allow the selection of multiple items or just one.
  optional bool allow_multiselect = 4;

  // Whether the selection of this section is required to proceed.
  optional bool selection_mandatory = 5 [default = true];

  // The error message displayed when the selection is mandatory and missing.
  // Ignored if |selection_mandatory| is false.
  optional string no_selection_error_message = 6;
}

// Asks to provide the data used by UseAddressAction and
// UseCreditCardAction.
// Next: 33
message CollectUserDataProto {
  enum TermsAndConditionsState {
    // No choice has been made yet.
    NOT_SELECTED = 0;
    // The 'accept' radio button is toggled.
    ACCEPTED = 1;
    // The 'review' radio button is toggled.
    REVIEW_REQUIRED = 2;
  }

  optional string prompt = 1;
  // NOTE: The action does not ask separately for billing address.
  // The billing address is associated with the credit card that was picked.
  optional string billing_address_name = 2;
  // If present will save the shipping address inside the memory under the
  // specified name. If empty we won't ask for the shipping address. Data saved
  // under this name can be reused by UseAddressAction.
  optional string shipping_address_name = 3;
  // If present, it will be used as the title to be displayed for the shipping
  // address section instead of the default one.
  optional string shipping_address_section_title = 32;
  // When 'true' will ask for the credit card.
  optional bool request_payment_method = 4;
  // If non-empty, the UI will filter the available basic-card networks
  // accordingly (e.g., only `visa' and `mastercard').
  repeated string supported_basic_card_networks = 6;
  // Contact details that should be gathered.
  optional ContactDetailsProto contact_details = 5;
  // Override for the text of the confirm button.
  optional string confirm_button_text = 7;
  // The initial state of the terms & conditions choice.
  optional TermsAndConditionsState terms_and_conditions_state = 8;
  // When 'false', hide the terms and conditions box in the UI.
  optional bool request_terms_and_conditions = 9 [default = true];
  // Whether the terms and conditions should be displayed as a single checkbox
  // with |accept_terms_and_conditions_text| as text. If false, the accept terms
  // will be displayed as a radio button next to an additional "Read and agree
  // later on domain.com" choice.
  optional bool show_terms_as_checkbox = 12;
  // The text for the terms and conditions "I accept..." choice. The text is
  // formatted such that '<b>text</b>' will be bold and '<link0>clickable
  // link</link0>', '<link1>other link</link1>', etc will be clickable links
  // that will finish this action and return the clicked link in the action
  // result.
  optional string accept_terms_and_conditions_text = 13;
  // Message that indicates that the user wants to review the terms and
  // conditions of a 3rd party's domain, e.g., 'example.com'.
  optional string terms_require_review_text = 20;
  // Privacy notice telling users that autofill assistant will send personal
  // data to a third party’s website.
  optional string privacy_notice_text = 21;
  // Optionally allows confiriming through the given direct actions.
  optional DirectActionProto confirm_direct_action = 10;
  // Additional actions available to the user. This can be used for instance to
  // display a "Show terms" button that will navigate the user to the terms and
  // conditions page when clicked.
  repeated UserActionProto additional_actions = 11;
  // Optionally requests a payment method with a billing address that has a
  // postcode value.
  optional bool require_billing_postal_code = 14;
  // The error message to display when the billing address is missing the
  // postal code. This field is mandatory if |require_postal_code| is true.
  optional string billing_postal_code_missing_text = 15;
  // The error message to display when the selected credit card is expired.
  optional string credit_card_expired_text = 23;
  // The login details that should be gathered.
  optional LoginDetailsProto login_details = 16;
  // The date/time range that should be gathered.
  optional DateTimeRangeProto date_time_range = 17;
  // An optional list of additional sections, which is above all other sections.
  repeated UserFormSectionProto additional_prepended_sections = 18;
  // An optional list of additional sections, which is below all other sections.
  repeated UserFormSectionProto additional_appended_sections = 19;
  // Backend-configured user interface to show below
  // |additional_prepended_sections|.
  optional GenericUserInterfaceProto generic_user_interface_prepended = 22;
  // Backend-configured user interface to show below
  // |additional_appended_sections|.
  optional GenericUserInterfaceProto generic_user_interface_appended = 25;
  // Optional. Text to be shown in a separate info section.
  optional string info_section_text = 24;
  // Optional. If true the text in the info section will be centered.
  optional bool info_section_text_center = 31;
  // Optional. If specified, the continue button will only be enabled if the
  // boolean at this location is true (and everything else is valid too).
  optional string additional_model_identifier_to_check = 27;
  // Clears any previously selected credit card. The client will revert to
  // default-selecting the card instead. NOTE: When clearing the credit card
  // selection, the billing address should also be cleared!
  optional bool clear_previous_credit_card_selection = 28;
  // Clears the previously selected login option, if any. The client will revert
  // to default-selecting the login option instead.
  optional bool clear_previous_login_selection = 29;
  // The names of the selected profiles to clear. Should be a subset of
  // {billing_address_name, shipping_address_name,
  // contact_details.contact_details_name}. NOTE: when clearing the billing
  // address, the selected credit card should also be cleared!
  repeated string clear_previous_profile_selection = 30;

  reserved 26;
}

// Stop Autofill Assistant.
message StopProto {
  // If true, close the Chrome Custom Tab, in addition to shutting down Autofill
  // Assistant.
  optional bool close_cct = 2;

  reserved 1;  // stop_action_type
}

message DetailsChangesProto {
  // Whether the changes require user approval. This de-emphasize
  // non-highlighted fields.
  optional bool user_approval_required = 1;

  // Whether the title should be highlighted.
  optional bool highlight_title = 2;

  // Whether the first description line should be highlighted.
  optional bool highlight_line1 = 3;

  // Whether the second description line should be highlighted.
  optional bool highlight_line2 = 4;

  // Whether the third description line should be highlighted.
  optional bool highlight_line3 = 5;
}

message DetailsProto {
  optional string title = 1;

  oneof image {
    string image_url = 2;
    // When set to true shows placeholder in place of an image.
    bool show_image_placeholder = 10;
  }
  // Specifies the hint for accessibility. If set to empty, the image will not
  // be announced by accessibility.
  optional string image_accessibility_hint = 14;

  // Specifies what happens when user tap on the image in the details section.
  message ImageClickthroughData {
    // Whether to show the original URL where image is extracted from. Only
    // useful when 'image_url' is set.
    optional bool allow_clickthrough = 1;

    // When image clickthrough is allowed, below texts are used to customize the
    // modal dialog shown to user *if* they are set, otherwise default texts
    // will be used.
    optional string description = 2;
    optional string positive_text = 3;
    optional string negative_text = 4;

    // The url to present when user did choose to clickthrough.
    optional string clickthrough_url = 5;
  }

  optional ImageClickthroughData image_clickthrough_data = 12;

  // Optional label to provide additional price information.
  optional string total_price_label = 9;
  // The price containing the total amount and the currency to pay, formatted
  // in the client's locale (e.g., $123.00).
  optional string total_price = 6;

  optional string description_line_1 = 7;
  optional string description_line_2 = 8;
  optional string description_line_3 = 13;

  // Deprecated, but currently still necessary and supported. We can get rid of
  // these fields when the backend starts setting description_line_1 and 2.
  optional DateTimeProto datetime = 3;
  optional string description = 4;

  // Asks the UI to show animated placeholders for missing fields.
  // The placeholder will be shown on effectively missing:
  // * title
  // * image
  // * description line (1, 2 or 3)
  // TODO(crbug.com/806868): Make the fields for displaying placeholders
  // configurable by the server.
  optional bool animate_placeholders = 11;

  // Deprecated, no longer supported.
  reserved 5;
}

// Show contextual information.
message ShowDetailsProto {
  oneof data_to_show {
    DetailsProto details = 1;
    // Shows full name and email address.
    string contact_details = 3;
    bool credit_card = 4;
    // Shows full name and address.
    string shipping_address = 5;
  }

  // Flags indicating which parts of the details (if any) have changed.
  // This field is taken into account only if |details| is filled.
  optional DetailsChangesProto change_flags = 2;
}

// Set the value of an form element.
message SetFormFieldValueProto {
  message Result { optional bool fallback_to_simulate_key_presses = 1; }
  message KeyPress {
    oneof keypress {
      // Text to insert as-is into a form field.
      string text = 1;
      // DEPRECATED: A single US-ASCII character (e.g., 13 for carriage return).
      int32 keycode = 2;
      // Text as generated by processing a virtual key code with a keyboard
      // layout. This can also be used for keyboard control sequences such
      // as "\r" or "\t".
      string keyboard_input = 3;
      // Use the username from the Chrome password manager login previously
      // selected in a CollectUserDataAction.
      bool use_username = 4;
      // Use the password from the Chrome password manager login previously
      // selected in a CollectUserDataAction.
      bool use_password = 5;
      // Use the value stored at the specified memory location.
      string client_memory_key = 6;
    }

    reserved 7;
  }

  // A reference to the form element whose value should be set.
  optional ElementReferenceProto element = 1;

  // The value to set.
  repeated KeyPress value = 2;

  // The strategy used to execute filling the value.
  optional KeyboardValueFillStrategy fill_strategy = 7;

  // Delay between two key presses when simlulating.
  optional int32 delay_in_millisecond = 6 [default = 20];

  reserved 5;
}

// Asks the password manager to generate a suitable password for |element|. The
// generated password can be filled in subsequent SetFormFieldValueProto
// actions. Generated password will be presaved to password store,
// login details need to be available in the client memory for this action.
message GeneratePasswordForFormFieldProto {
  // A reference to the form element for which to generate a password.
  optional ElementReferenceProto element = 1;
  // The client memory key to store the generated password.
  optional string memory_key = 2;
}

// Asks the password save manager to save generated password after successful
// submission.
message SaveGeneratedPasswordProto {
  // The client memory key of stored password.
  optional string memory_key = 1;
}

// Set an element attribute to a specific value.
message SetAttributeProto {
  // A reference to the form element whose attribute should be set.
  optional ElementReferenceProto element = 1;

  // The attribute to set, e.g. ["style", "position"] to change
  // element.style.position.
  repeated string attribute = 2;

  // The value to set.
  optional string value = 3;
}

message InfoBoxProto {
  // Optional path to an image. Ok tick used if not set.
  optional string image_path = 1;

  // The explanation to show in the box. Not setting this field will clear an
  // existing info box.
  optional string explanation = 2;
}

// Shows an info box with informational content. The info box content is cleared
// when |info_box| is not set.
message ShowInfoBoxProto {
  optional InfoBoxProto info_box = 1;
}

// Allow scripts to configure the peek height of the sheet and whether we should
// resize the viewport by this peek height. If talkback is enabled, the mode is
// set to RESIZE_VISUAL_VIEWPORT. Changes to the mode are only applied after
// talkback is disabled.
message ConfigureBottomSheetProto {
  enum ViewportResizing {
    // Don't change resizing configuration.
    NO_CHANGE = 0;

    // Resize the layout viewport such that it is completely visible when the
    // sheet is in the peek state.
    RESIZE_LAYOUT_VIEWPORT = 1;

    // Don't resize the viewport such that it is overlaid by the sheet, even in
    // the peek state.
    NO_RESIZE = 2;

    // Dynamically resize the visual viewport by the height of the sheet. This
    // allows to fully scroll the page above the sheet at any time.
    RESIZE_VISUAL_VIEWPORT = 3;
  }

  // The peek mode allows to set what components are visible when the sheet is
  // in the peek (minimized) state.
  enum PeekMode {
    UNDEFINED_PEEK_MODE = 0;

    // Only show the swipe handle.
    HANDLE = 1;

    // Show the swipe handle, header (status message, poodle, profile icon) and
    // progress bar.
    HANDLE_HEADER = 2;

    // Show swipe handle, header, progress bar, suggestions and actions.
    HANDLE_HEADER_CAROUSELS = 3;
  }

  // Whether the viewport should be resized. Resizing the viewport is an
  // expensive operation, so toggling the resize on/off should be done
  // cautiously.
  optional ViewportResizing viewport_resizing = 1;

  // Set the peek mode. This will change the peek mode of the sheet without
  // actually updating the sheet to that setting. If viewport_resizing is set
  // to RESIZE_LAYOUT_VIEWPORT or was set by a previous ConfigureBottomSheet
  // action, the viewport will be resized to match the new peek height.
  optional PeekMode peek_mode = 2;

  // Maximum time to wait for the window to resize before continuing with the
  // script. If 0 or unset, the action doesn't wait.
  optional int32 resize_timeout_ms = 3;

  // Option to automatically expand or collapse the sheet or leave as is.
  oneof apply_state {
    // Go to the expanded state (same as if the user swiped the bottom sheet
    // up).
    bool expand = 4;
    // Go to the peek state (same as if the user swiped the bottom
    // sheet down).
    bool collapse = 5;
  }
}

// Allow scripts to display a form with multiple inputs.
message ShowFormProto {
  // The form to display.
  optional FormProto form = 1;

  // The chip to display below the form. This chip will be enabled only if all
  // form inputs are valid.
  optional ChipProto chip = 2;

  // Optionally allow confirming the prompt using given direct actions.
  optional DirectActionProto direct_action = 3;
}

message FormProto {
  // A result associated to this form, such that |input_results[i]| is the
  // result of |inputs[i]|. If the user clicks a link while in the form action,
  // |link| will be set to the index of the clicked link and |input_results|
  // may be incomplete.
  message Result {
    repeated FormInputProto.Result input_results = 1;
    // If this is set, it contains the index of the text link that was clicked.
    // E.g., <link4>Details</link4> will populate this field with '4' when
    // clicked.
    optional int32 link = 2;
  }

  // The different inputs to display.
  repeated FormInputProto inputs = 1;

  // Optionally adds an informational text below the form.
  optional string info_label = 2;
  // If set, an info icon will be shown next to the info label that prompts a
  // popup when tapped. Ignored if info_label is not set.
  optional InfoPopupProto info_popup = 3;
}

message FormInputProto {
  message Result {
    oneof input_type {
      CounterInputProto.Result counter = 1;
      SelectionInputProto.Result selection = 2;
    }
  }

  oneof input_type {
    CounterInputProto counter = 1;
    SelectionInputProto selection = 2;
  }
}

// An input that is made of one or more counters. This input is considered valid
// if its |validation_rule| is satisfied or if it doesn't have one.
message CounterInputProto {
  // A single counter.
  message Counter {
    // The label shown with the counter. All occurrences of the '{value}'
    // substring will be replaced by the current counter value. May contain
    // links of the form <link1>Some text</link1>.
    optional string label = 1;

    // Text shown below the label. Optional. May contain links of the form
    // <link1>Some text</link1>.
    optional string description_line_1 = 5;

    // Text shown below |description_line_2|. Optional. May contain links of the
    // form <link1>Some text</link1>.
    optional string description_line_2 = 8;

    // The possible values this counter can have. If empty, the possible values
    // will be all integer values between |min_value| and |max_value|.
    // Note that the order of the values matters and they will not be
    // automatically sorted.
    repeated int32 allowed_values = 6;

    // The minimum value this counter can have. Ignored if |allowed_values| is
    // not empty.
    optional int32 min_value = 2 [default = -0x80000000];  // kint32min

    // The maximum value this counter can have. Ignored if |allowed_values| is
    // not empty.
    optional int32 max_value = 3 [default = 0x7FFFFFFF];  // kint32max

    // The initial value of the counter. If |allowed_values| is not empty, it
    // must contain |initial_value| or it will otherwise default to the first
    // value.
    optional int32 initial_value = 4 [default = 0];

    reserved 7;
  }

  // A result associated to this counter.
  message Result {
    // The values of all counters from this CounterInputProto, such that
    // |values[i]| is the value of |counters[i]|.
    repeated int32 values = 1;
  }

  // A validation rule to validate this input values.
  message ValidationRule {
    // A rule to combine sub rules. This rule allows to express the following:
    //  - Rule A and Rule B must be satisfied.
    //  - Rule A or Rule B must be satisfied.
    //  - Rule A must not be satisfied.
    //  - At least 2 of Rules A, B or C must be satisfied.
    //
    // This rule is satisfied if the number of satisfied |sub_rules| is >=
    // min_satisfied_rules and <= max_satisfied_rules.
    message BooleanRule {
      // The sub rules to check.
      repeated ValidationRule sub_rules = 1;

      // The minimum number of rules that must be satisfied.
      optional int32 min_satisfied_rules = 2 [default = 0];

      // The maximum number of rules that must be satisfied.
      optional int32 max_satisfied_rules = 3
          [default = 0x7FFFFFFF];  // kint32max
    }

    // A rule on the value of one of the |counters|. This rule is satisfied if
    // min_value <= counter.value <= max_value.
    message CounterRule {
      // The index of the counter in |counters|. Must be >= 0 and <
      // |counters.size|.
      optional int32 counter_index = 1;

      // The minimum value this counter can have.
      optional int32 min_value = 2 [default = -0x80000000];  // kint32min

      // The maximum value this counter can have.
      optional int32 max_value = 3 [default = 0x7FFFFFFF];  // kint32max
    }

    // A rule on the sum of the |counters|. This rule satisfied if the sum of
    // all |counters| is >= min_value and <= max_value. If there is an overflow
    // when computing the sum, the behavior is undefined.
    message CountersSumRule {
      // The minimum value the total can have.
      optional int64 min_value = 1
          [default = -0x8000000000000000];  // kint64min

      // The maximum value this counter can have.
      optional int64 max_value = 2 [default = 0x7FFFFFFFFFFFFFFF];  // kint64max
    }

    oneof rule_type {
      BooleanRule boolean = 1;
      CounterRule counter = 2;
      CountersSumRule counters_sum = 3;
    }
  }

  // An optional label shown above the different counters.
  optional string label = 1;

  // The counters to display.
  repeated Counter counters = 2;

  // If specified, the input will initially display maximum |minimized_count|
  // counters. If |counters|.size > |minimized_count|, the remaining counters
  // will be displayed in an expandable section below the first
  // |minimized_count| counters. Setting this value will have no effect if
  // |expand_text| and |minimize_text| are not set.
  optional int32 minimized_count = 3 [default = 0x7FFFFFFF];  // kint32max

  // Text shown when counters are inside the expandable section and the section
  // is minimized. Clicking this text will expand the section and show the
  // remaining counters.
  optional string expand_text = 4;

  // Text shown when counters are inside the expandable section and the section
  // is expanded. Clicking this text will minimize the section and hide the
  // counters inside it.
  optional string minimize_text = 5;

  // Validation rule used to check whether the current values of this input are
  // valid.
  optional ValidationRule validation_rule = 6;

  // The minimum value of the sum of the counters. All counters decrease button
  // will be disabled if sum <= min_counters_sum.
  optional int64 min_counters_sum = 7
      [default = -0x8000000000000000];  // kint64min

  // The maximum value of the sum of the counters. All counters increase button
  // will be disabled if sum >= max_counters_sum.
  optional int64 max_counters_sum = 8
      [default = 0x7FFFFFFFFFFFFFFF];  // kint64max
}

// An input that allows the user to choose one or multiple options. This input
// is considered valid if the number of selected choices is bigger or equal than
// |min_choices|.
message SelectionInputProto {
  message Choice {
    // The label of this choice. May contain links of the form <link1>Some
    // text</link1>.
    optional string label = 1;

    // Text shown below the label. Optional. May contain links of the form
    // <link1>Some text</link1>.
    optional string description_line_1 = 3;

    // Text shown below |description_line_2|. Optional. May contain links of the
    // form <link1>Some text</link1>.
    optional string description_line_2 = 4;

    // Whether this choice is selected by default. If |allow_multiple| is false,
    // then maximum 1 Choice can have this set to true, otherwise the associated
    // FormAction will fail.
    optional bool selected = 2 [default = false];

    reserved 7;
  }

  message Result {
    // Stores whether each choice was selected or not, such that |selected[i]|
    // is true if |choices[i]| was selected.
    repeated bool selected = 1;
  }

  // An optional label shown above the different choices.
  optional string label = 1;

  // The choices to display.
  repeated Choice choices = 2;

  // Whether the user will be allowed to select multiple choices. If false, each
  // choice will be displayed with a radio button. Otherwise, it will be
  // displayed with checkboxes.
  optional bool allow_multiple = 3 [default = false];

  // The minimum number of choices that should be selected to consider this
  // input valid.
  optional int32 min_selected_choices = 4 [default = 1];
}

// Action to show a popup bubble on top of the bottom sheet, anchored at the
// icon. Setting an empty message will remove any existing and visible popup
// message. A second action replaces a previously shown message.
message PopupMessageProto {
  // Message to show in the popup.
  optional string message = 1;
}
