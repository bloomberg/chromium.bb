// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef STORAGE_BROWSER_QUOTA_QUOTA_DATABASE_H_
#define STORAGE_BROWSER_QUOTA_QUOTA_DATABASE_H_

#include <stddef.h>
#include <stdint.h>

#include <memory>
#include <set>
#include <string>

#include "base/callback.h"
#include "base/component_export.h"
#include "base/files/file_path.h"
#include "base/macros.h"
#include "base/sequence_checker.h"
#include "base/time/time.h"
#include "base/timer/timer.h"
#include "base/util/type_safety/id_type.h"
#include "components/services/storage/public/cpp/quota_error_or.h"
#include "third_party/blink/public/mojom/quota/quota_types.mojom-shared.h"
#include "url/origin.h"

namespace sql {
class Database;
class MetaTable;
}

namespace storage {

class SpecialStoragePolicy;

// IDs will always be generated by SQLite, and all valid BucketIds are positive.
using BucketId = util::IdType64<class BucketTag>;

// Stores all quota managed origin bucket data and metadata.
//
// Instances are owned by QuotaManagerImpl. There is one instance per
// QuotaManagerImpl instance. All the methods of this class, except the
// constructor, must called on the DB thread.
class COMPONENT_EXPORT(STORAGE_BROWSER) QuotaDatabase {
 public:
  struct COMPONENT_EXPORT(STORAGE_BROWSER) BucketTableEntry {
    BucketTableEntry();
    BucketTableEntry(int64_t bucket_id,
                     url::Origin origin,
                     blink::mojom::StorageType type,
                     std::string name,
                     int use_count,
                     const base::Time& last_accessed,
                     const base::Time& last_modified);

    BucketTableEntry(const BucketTableEntry&);
    BucketTableEntry& operator=(const BucketTableEntry&);

    int64_t bucket_id = -1;
    url::Origin origin;
    blink::mojom::StorageType type = blink::mojom::StorageType::kUnknown;
    std::string name;
    int use_count = 0;
    base::Time last_accessed;
    base::Time last_modified;
  };

  // If 'path' is empty, an in memory database will be used.
  explicit QuotaDatabase(const base::FilePath& path);
  ~QuotaDatabase();

  // Returns whether the record could be found.
  bool GetHostQuota(const std::string& host,
                    blink::mojom::StorageType type,
                    int64_t* quota);

  // Returns whether the operation succeeded.
  bool SetHostQuota(const std::string& host,
                    blink::mojom::StorageType type,
                    int64_t quota);
  bool DeleteHostQuota(const std::string& host, blink::mojom::StorageType type);

  // Creates a bucket with `bucket_name` for the `origin` and returns the bucket
  // id. Returns an QuotaError if a bucket with the same `bucket_name` for an
  // `origin` already exists or if the operation has failed.
  // TODO(crbug/1203467): Include more policies when supported.
  QuotaErrorOr<BucketId> CreateBucket(const url::Origin& origin,
                                      const std::string& bucket_name);

  // Retrieves the bucket id of the bucket with `bucket_name` for `origin`.
  // If one does not exist, it will return an empty BucketId. Returns an error
  // if the operation has failed.
  QuotaErrorOr<BucketId> GetBucketId(const url::Origin& origin,
                                     const std::string& bucket_name);

  // TODO(crbug.com/1202167): Remove once all usages have updated to use
  // SetBucketLastAccessTime.
  bool SetOriginLastAccessTime(const url::Origin& origin,
                               blink::mojom::StorageType type,
                               base::Time last_accessed);

  // Called by QuotaClient implementers to update when the bucket was last
  // accessed.
  bool SetBucketLastAccessTime(int64_t bucket_id, base::Time last_accessed);

  // TODO(crbug.com/1202167): Remove once all usages have updated to use
  // SetBucketLastModifiedTime.
  bool SetOriginLastModifiedTime(const url::Origin& origin,
                                 blink::mojom::StorageType type,
                                 base::Time last_modified);

  // Called by QuotaClient implementers to update when the bucket was last
  // modified.
  bool SetBucketLastModifiedTime(int64_t bucket_id, base::Time last_modified);

  bool GetOriginLastEvictionTime(const url::Origin& origin,
                                 blink::mojom::StorageType type,
                                 base::Time* last_eviction_time);

  // Sets the time the origin was last evicted. Returns whether the operation
  // succeeded.
  bool SetOriginLastEvictionTime(const url::Origin& origin,
                                 blink::mojom::StorageType type,
                                 base::Time last_eviction_time);
  bool DeleteOriginLastEvictionTime(const url::Origin& origin,
                                    blink::mojom::StorageType type);

  // Register initial `origins` info `type` to the database.
  // This method is assumed to be called only after the installation or
  // the database schema reset.
  bool RegisterInitialOriginInfo(const std::set<url::Origin>& origins,
                                 blink::mojom::StorageType type);

  // TODO(crbug.com/1202167): Remove once all usages have been updated to use
  // GetBucketInfo. Gets the BucketTableEntry for `origin`. Returns whether the
  // record for an origin's default bucket could be found.
  bool GetOriginInfo(const url::Origin& origin,
                     blink::mojom::StorageType type,
                     BucketTableEntry* entry);

  // Gets the table entry for `bucket`. Returns whether the record for an
  // origin bucket can be found.
  bool GetBucketInfo(int64_t bucket_id, BucketTableEntry* entry);

  // TODO(crbug.com/1202167): Remove once all usages have been updated to use
  // DeleteBucketInfo. Deletes the default bucket for `origin`.
  bool DeleteOriginInfo(const url::Origin& origin,
                        blink::mojom::StorageType type);

  // Deletes the specified bucket.
  bool DeleteBucketInfo(int64_t bucket_id);

  // TODO(crbug.com/1202167): Remove once all usages have been updated to use
  // GetLRUBucket. Sets `origin` to the least recently used origin of origins
  // not included in `exceptions` and not granted the special unlimited storage
  // right. Returns false when it fails in accessing the database.
  // `origin` is set to nullopt when there is no matching origin.
  // This is limited to the origin's default bucket.
  bool GetLRUOrigin(blink::mojom::StorageType type,
                    const std::set<url::Origin>& exceptions,
                    SpecialStoragePolicy* special_storage_policy,
                    absl::optional<url::Origin>* origin);

  // Sets `bucket_id` to the least recently used bucket from origins not
  // included in `exceptions` and not granted special unlimited storage right.
  // Returns false when it fails in accessing the database. `bucket_id` is
  // set to nullopt when there is no matching bucket.
  bool GetLRUBucket(blink::mojom::StorageType type,
                    const std::set<url::Origin>& exceptions,
                    SpecialStoragePolicy* special_storage_policy,
                    absl::optional<int64_t>* bucket_id);

  // TODO(crbug.com/1202167): Remove once all usages have been updated to use
  // GetBucketsModifiedBetween. Populates `origins` with the ones that have had
  // their default bucket modified since the `begin` and until the `end`.
  // Returns whether the operation succeeded.
  bool GetOriginsModifiedBetween(blink::mojom::StorageType type,
                                 std::set<url::Origin>* origins,
                                 base::Time begin,
                                 base::Time end);

  // Populates `bucket_ids` with the buckets that have been modified since the
  // `begin` and until the `end`. Returns whether the operation succeeded.
  bool GetBucketsModifiedBetween(blink::mojom::StorageType type,
                                 std::set<int64_t>* bucket_ids,
                                 base::Time begin,
                                 base::Time end);

  // Returns false if SetOriginDatabaseBootstrapped has never
  // been called before, which means existing origins may not have been
  // registered.
  bool IsOriginDatabaseBootstrapped();
  bool SetOriginDatabaseBootstrapped(bool bootstrap_flag);

 private:
  struct COMPONENT_EXPORT(STORAGE_BROWSER) QuotaTableEntry {
    std::string host;
    blink::mojom::StorageType type = blink::mojom::StorageType::kUnknown;
    int64_t quota = 0;
  };
  friend COMPONENT_EXPORT(STORAGE_BROWSER) bool operator<(
      const QuotaTableEntry& lhs,
      const QuotaTableEntry& rhs);
  friend COMPONENT_EXPORT(STORAGE_BROWSER) bool operator<(
      const BucketTableEntry& lhs,
      const BucketTableEntry& rhs);

  // Structures used for CreateSchema.
  struct TableSchema {
    const char* table_name;
    const char* columns;
  };
  struct IndexSchema {
    const char* index_name;
    const char* table_name;
    const char* columns;
    bool unique;
  };

  using QuotaTableCallback =
      base::RepeatingCallback<bool(const QuotaTableEntry&)>;
  using BucketTableCallback =
      base::RepeatingCallback<bool(const BucketTableEntry&)>;

  // For long-running transactions support.  We always keep a transaction open
  // so that multiple transactions can be batched.  They are flushed
  // with a delay after a modification has been made.  We support neither
  // nested transactions nor rollback (as we don't need them for now).
  void Commit();
  void ScheduleCommit();

  bool LazyOpen(bool create_if_needed);
  bool EnsureDatabaseVersion();
  bool ResetSchema();
  bool UpgradeSchema(int current_version);
  bool InsertOrReplaceHostQuota(const std::string& host,
                                blink::mojom::StorageType type,
                                int64_t quota);

  bool CreateSchema();
  bool CreateTable(const TableSchema& table);
  bool CreateIndex(const IndexSchema& index);

  // `callback` may return false to stop reading data.
  bool DumpQuotaTable(const QuotaTableCallback& callback);
  bool DumpBucketTable(const BucketTableCallback& callback);

  const base::FilePath db_file_path_;

  std::unique_ptr<sql::Database> db_;
  std::unique_ptr<sql::MetaTable> meta_table_;
  bool is_recreating_;
  bool is_disabled_;

  base::OneShotTimer timer_;

  friend class QuotaDatabaseTest;
  friend class QuotaDatabaseMigrations;
  friend class QuotaDatabaseMigrationsTest;
  friend class QuotaManagerImpl;

  static const char kDefaultBucket[];
  static const TableSchema kTables[];
  static const size_t kTableCount;
  static const IndexSchema kIndexes[];
  static const size_t kIndexCount;

  SEQUENCE_CHECKER(sequence_checker_);
  DISALLOW_COPY_AND_ASSIGN(QuotaDatabase);
};

}  // namespace storage

#endif  // STORAGE_BROWSER_QUOTA_QUOTA_DATABASE_H_
