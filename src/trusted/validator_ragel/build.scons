# -*- python -*-
# Copyright (c) 2012 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import sys

from SCons.Errors import UserError

Import('env')

# Dir to place c files generated by 'dfagen' target (it's under source control).
gen_dir = '$MAIN_DIR/src/trusted/validator_ragel/gen'
# Currently we only provide ragel pre-built for Linux.
ragel_binary = '$MAIN_DIR/../third_party/ragel/ragel.linux'

INSTRUCTION_DEFINITIONS = map(env.File, [
    'instruction_definitions/general_purpose_instructions.def',
    'instruction_definitions/system_instructions.def',
    'instruction_definitions/x87_instructions.def',
    'instruction_definitions/mmx_instructions.def',
    'instruction_definitions/xmm_instructions.def',
    'instruction_definitions/nops.def'
])

# These objects are included in both dfa_validate_x86_xx and rdfa_validator
# libraries, so we have to introduce intermediate scons nodes.
validator32 = env.ComponentObject('gen/validator_x86_32.c')
validator64 = env.ComponentObject('gen/validator_x86_64.c')

features = [
    env.ComponentObject('validator_features_all.c'),
    env.ComponentObject('validator_features_validator.c')
]

# Glue library called from service runtime. The source file depends on the
# target architecture.  In library_deps.py this library is marked as
# dependant of dfa_validate_x86_xx.
if env.Bit('target_x86'):
  caller_lib = 'dfa_validate_caller_x86_%s' % env.get('TARGET_SUBARCH')
  env.ComponentLibrary(
      caller_lib,
      ['dfa_validate_%s.c' % env.get('TARGET_SUBARCH'),
       {'32': validator32, '64': validator64}[env.get('TARGET_SUBARCH')],
       'dfa_validate_common.c',
       features])

# Low-level platform-independent interface supporting both 32 and 64 bit,
# used in ncval and in validator_benchmark.
env.ComponentLibrary('rdfa_validator',
                     [validator32, validator64] + features)

validator_benchmark = env.ComponentProgram(
    'rdfa_validator_benchmark',
    ['validator_benchmark.cc'],
    EXTRA_LIBS=['rdfa_validator', 'platform', 'elf_load']
)

run_benchmark = env.AutoDepsCommand(
    'run_validator_ragel_benchmark.out',
    [validator_benchmark, env.GetIrtNexe(), '10000']
)

env.AlwaysBuild(env.Alias('dfavalidatorbenchmark', run_benchmark))

# We don't run this test under qemu because it attempts to execute host python
# binary.
gen_dfa_test = env.CommandTest(
    'gen_dfa_test.out',
    ['${PYTHON}', env.File('gen_dfa_test.py')] + INSTRUCTION_DEFINITIONS,
    direct_emulation=False)

env.AddNodeToTestSuite(
    gen_dfa_test,
    ['small_tests', 'validator_tests'],
    'run_gen_dfa_test')

dll_env = env.Clone(COMPONENT_STATIC=False)

if env.Bit('windows'):
  # On windows we don't need to recompile specifically for dynamic linking.
  validator32_dll = validator32
  validator64_dll = validator64
  features_dll = features
else:
  dll_env.Append(CCFLAGS=['-fPIC'])
  validator32_dll = dll_env.ComponentObject('gen/validator_x86_32.c')
  validator64_dll = dll_env.ComponentObject('gen/validator_x86_64.c')

  features_dll = [
      dll_env.ComponentObject('validator_features_all.c'),
      dll_env.ComponentObject('validator_features_validator.c')
  ]

nacl_log_for_dll_dll = dll_env.ComponentObject('nacl_log_for_dll.c')

validator_dll = dll_env.ComponentLibrary(
    'rdfa_validator_dll',
    [validator32_dll, validator64_dll, nacl_log_for_dll_dll] + features_dll)

# Here for simplicity we make assumption that python used to run scons
# is the same as the one invoked by scons to run tests.
python_bitness = {2**31 - 1: 32, 2**63 - 1: 64}[sys.maxsize]
bitness = int(env.get('TARGET_SUBARCH'))
assert bitness in [32, 64]
# Note that it is possible that we build on one machine and run tests on another
# one, so we build DLL even if python bitness does not match target bitness.
# Asan does not instrument DLLs (only executables), so we will be unable to
# run tests under asan.
python_can_load_dll = python_bitness == bitness and not env.Bit('asan')

if python_can_load_dll:
  validator_py_test = env.AutoDepsCommand(
        'validator_py_out',
        ['${PYTHON}',
         env.File('validator.py'),
         validator_dll])

  env.AddNodeToTestSuite(
      validator_py_test,
      ['small_tests', 'validator_tests'],
      'run_validator_py_test')

# Source generation:
#
#   dfagen : Regenerate any autogenerated source files.

ragel_targets = set(['dfagen', 'dfacheckdecoder', 'dfacheckvalidator'])
ragel_involved = ragel_targets.intersection(COMMAND_LINE_TARGETS)

if ragel_involved:
  if not env.Bit('host_linux'):
    raise UserError('Right now DFA generation is only supported on Linux')

  # Source generation step 1: Build generator of ragel files.
  #
  # We have generator which reads .def files and produced automaton definition.
  #
  # Ragel is included in most Linux distributions, but it's not standard tool
  # on MacOS/Windows thus we only support gneration of automata under Linux.
  # This also means that we don't need to make sure gen_dfa.cc is portable to
  # non-POSIX platforms (in particular it's not Windows compatible).

  env_gen_dfa = env.Clone()
  env_gen_dfa.Append(CCFLAGS=['-DNACL_TRUSTED_BUT_NOT_TCB'])

  # Generate byte_machines.rl from byte_machines.py
  (byte_machines,) = env.AutoDepsCommand(
      'byte_machines.rl',
      ['${PYTHON}',
       env.File('byte_machines.py'),
       '>${TARGET}'])

  # Source generation step 2: Generate decoder automata.
  #
  # Now we are back to conditionally defining the large automata generated
  # by gen_dfa.

  def MakeAutomaton(bits, automaton, ragel_flags):
    (rl_instruction_file,) = env.AutoDepsCommand(
        '%s_x86_%s_instruction.rl' % (automaton, bits),
        ['${PYTHON}',
         env.File('gen_dfa.py'),
         '--bitness', bits,
         '--mode', automaton,
         '>${TARGET}',
         ] + INSTRUCTION_DEFINITIONS)

    include_dir = rl_instruction_file.dir.get_abspath()
    assert include_dir == byte_machines.dir.get_abspath()

    rl_file = env.File('%s_x86_%s.rl' % (automaton, bits))

    (c_file,) = env.AutoDepsCommand(
        '%s_x86_%s.c' % (automaton, bits),
        [ragel_binary,
         ragel_flags,
         '-LL',
         '-I..',
         '-I%s' % include_dir,
         rl_file,
         '-o', '${TARGET}'],
        extra_deps=[byte_machines,
                    rl_instruction_file,
                    'parse_instruction.rl'])

    (xml_file,) = env.AutoDepsCommand(
        '%s_x86_%s.xml' % (automaton, bits),
        [ragel_binary,
         '-x',
         '-LL',
         '-I..',
         '-I%s' % include_dir,
         rl_file,
         '-o', '${TARGET}'],
        extra_deps=[byte_machines, rl_instruction_file])

    def InjectGeneratedFileHeader(target, source, env):
      source_filename = source[0].get_abspath()
      target_filename = target[0].get_abspath()

      architecture = {'32': 'ia32', '64': 'x86-64'}[bits]

      with open(source_filename, 'r') as source_file:
        comment, sep, rest = source_file.read().partition('*/')
        if sep == '':
          raise UserError('Generated file %s does not have '
                          'header comment block' % source_filename)

      _, _, short_name = target_filename.rpartition('/native_client/')

      with open(target_filename, 'w') as target_file:
        target_file.write(
            ('/* native_client/%s\n'
             ' * THIS FILE IS AUTO-GENERATED. DO NOT EDIT.\n'
             ' * Compiled for %s mode.\n'
             ' */') % (short_name, architecture))

        target_file.write(rest)

    # inject comments and place files to appropriate dir
    return (
        env.Command(
            target='%s/%s' % (gen_dir, c_file),
            source=c_file,
            action=InjectGeneratedFileHeader),
        xml_file)

  (decoder32, decoder32_xml) = MakeAutomaton(
      '32', 'decoder',
      '-T0')
  (validator32, validator32_xml) = MakeAutomaton(
      '32', 'validator',
      '-G2')
  (decoder64, decoder64_xml) = MakeAutomaton(
      '64', 'decoder',
      '-T0')
  (validator64, validator64_xml) = MakeAutomaton(
      '64', 'validator',
      '-GT2')

  automata = [decoder32, validator32, decoder64, validator64]

  # Prepair 'dfacheckdecoder' test.
  #
  # In this test, all acceptable instructions are enumerated
  # by DFA traversal, and for each one objdump output and
  # DFA-based decoder output are compared.
  # It takes few hours to run the test, so it's not included
  # into any suits and is supposed to be run manually when
  # changes are made to DFA definitions.
  # Also, since DFA generation is currently linux-only,
  # this test is somewhat platform-dependent as well.

  env.ComponentLibrary('dfa_decode_x86_32', [decoder32])
  env.ComponentLibrary('dfa_decode_x86_64', [decoder64])

  # Command-line decoder.
  decoder_test = env.ComponentProgram(
      'decoder_test',
      ['unreviewed/decoder_test.c'],
      EXTRA_LIBS=['dfa_decode_x86_32', 'dfa_decode_x86_64'])

  objdump, gas = env.Command(
      target=['objdump', 'gas'],
      source=['obtain_binutils.py'],
      action='${PYTHON} ${SOURCES[0]} ${TARGETS[0]} ${TARGETS[1]}')

  check_decoders = []

  for bits, xml in [('32', decoder32_xml), ('64', decoder64_xml)]:
    check_decoder = env.AutoDepsCommand(
        'check_decoder_test_results_%s' % bits,
        ['${PYTHON}',
         env.File('check_decoder.py'),
         xml,
         '--gas', gas,
         '--objdump', objdump,
         '--decoder', decoder_test,
         '--bits', bits])

    check_decoders.append(check_decoder)

  # Never run decoder tests in parallel because they can take all CPU.
  SideEffect('check_decoder', check_decoders)

  env.AlwaysBuild(env.Alias('dfagen', automata))
  env.AlwaysBuild(env.Alias('dfacheckdecoder', check_decoders))

  if python_can_load_dll:
    for bitness, xml in [('32', validator32_xml), ('64', validator64_xml)]:
      superinstruction = env.AutoDepsCommand(
          'superinstructions_x86_%s.txt' % bitness,
          ['${PYTHON}',
           env.File('verify_validators_dfa.py'),
           xml,
           '-o', '${TARGET}'])

      superinstruction_verified = env.AutoDepsCommand(
        'superinstructions_verified_x86_%s.out' % bitness,
        ['${PYTHON}',
         env.File('verify_superinstructions.py'),
         '--bitness', bitness,
         '--gas', gas,
         '--objdump', objdump,
         '--validator_dll', validator_dll,
         superinstruction])

      env32 = env.Clone(BUILD_TARGET_NAME='x86-32')
      env64 = env.Clone(BUILD_TARGET_NAME='x86-64')
      old_ncval32 = env32.File('$STAGING_DIR/ncval$PROGSUFFIX')
      old_ncval64 = env64.File('$STAGING_DIR/ncval$PROGSUFFIX')

      regular_instructions_test = env.AutoDepsCommand(
        'regular_instructions_test_x86_%s.out' % bitness,
        ['${PYTHON}',
         env.File('verify_regular_instructions.py'),
         xml,
         '--bitness', bitness,
         '--gas', gas,
         '--objdump', objdump,
         '--validator_dll', validator_dll,
         '--ncval32', old_ncval32,
         '--ncval64', old_ncval64,
         '--errors', '${TARGET}'])

      # Never run decoder tests in parallel because they can take all CPU.
      SideEffect('check_validator', regular_instructions_test)

      env.AlwaysBuild(env.Alias(
        'dfacheckvalidator',
        [superinstruction_verified, regular_instructions_test]))
