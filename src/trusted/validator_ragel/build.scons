# -*- python -*-
# Copyright (c) 2012 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import re

from SCons.Errors import UserError

Import('env')

#
#
# Build on x86 only.
#
#
if not env.Bit('target_x86'):
  Return()

# Defines the source directory where validator generated files should be added.
rl_src_dir = '$OBJ_ROOT/src/trusted/validator_ragel'
val_src_dir = '$MAIN_DIR/src/trusted/validator_ragel/gen'
# Currently we only provide ragel pre-built for Linux.
ragel_binary = '$MAIN_DIR/../third_party/ragel/ragel.linux'

INST_DEFS = [
    'unreviewed/general_purpose_instructions.def',
    'unreviewed/system_instructions.def',
    'unreviewed/x87_instructions.def',
    'unreviewed/mmx_instructions.def',
    'unreviewed/xmm_instructions.def',
    'unreviewed/nops.def'
]

# Generate 32 and 64 bit versions of decoders and validators.  Both libraries
# are used for command-line decoder and validator those detect specific
# architecture of the ELF file provided.
glue_files = ['unreviewed/dfa_validate_common.c',
              'unreviewed/validator_features_all.c',
              'unreviewed/validator_features_validator.c']
env.ComponentLibrary('dfa_validate_x86_32',
                     ['gen/validator_x86_32.c'] +
                      (glue_files if env.get('TARGET_SUBARCH') == '32' else []))
env.ComponentLibrary('dfa_validate_x86_64',
                     ['gen/validator_x86_64.c'] +
                      (glue_files if env.get('TARGET_SUBARCH') == '64' else []))
env.ComponentLibrary('dfa_decode_x86_32',
                     ['gen/decoder_x86_32.c'])
env.ComponentLibrary('dfa_decode_x86_64',
                     ['gen/decoder_x86_64.c'])

# Glue library called from service runtime. The source file depends on the
# target architecture.
caller_lib = 'dfa_validate_caller_x86_%s' % env.get('TARGET_SUBARCH')
env.ComponentLibrary(
    caller_lib,
    'unreviewed/dfa_validate_%s.c' % env.get('TARGET_SUBARCH')
)

# Command-line decoder.
decoder_test = env.ComponentProgram(
    'decoder_test',
    ['unreviewed/decoder_test.c'],
    EXTRA_LIBS=['dfa_decode_x86_32', 'dfa_decode_x86_64'])

env.ComponentLibrary(
    'elf_load',
    ['elf_load.cc'],
    EXTRA_LIBS=['platform'])

validator_benchmark = env.ComponentProgram(
    'rdfa_validator_benchmark',
    ['validator_benchmark.cc'],
    EXTRA_LIBS=['dfa_validate_x86_32', 'dfa_validate_x86_64', 'platform',
                'elf_load']
)

run_benchmark = env.Command(
    target='run_validator_ragel_benchmark.out',
    source=[validator_benchmark, env.GetIrtNexe()],
    action='${SOURCES[0]} ${SOURCES[1]} 10000'
)

env.AlwaysBuild(env.Alias('dfavalidatorbenchmark', run_benchmark))

ncval_new = env.ComponentProgram(
    'ncval_new',
    ['ncval.cc'],
    EXTRA_LIBS=['dfa_validate_x86_32', 'dfa_validate_x86_64', 'platform',
                'elf_load']
)

# Source generation:
#
#   dfagen : Regenerate any autogenerated source files.

dfa_aliases = 'dfagen', 'dfaclean', 'dfacheckdecoder'

generate =  any(a in COMMAND_LINE_TARGETS for a in dfa_aliases)

if generate:
  if not env.Bit('host_linux'):
    raise UserError('Right now DFA generation is only supported on Linux')

  # Source generation step 1: Build generator of ragel files.
  #
  # We have generator which reads .def files and produced automaton definition.
  #
  # Ragel is included in most Linux distributions, but it's not standard tool
  # on MacOS/Windows thus we only support gneration of automata under Linux.
  # This also means that we don't need to make sure gen_dfa.cc is portable to
  # non-POSIX platforms (in particular it's not Windows compatible).

  env_gen_dfa = env.Clone()
  env_gen_dfa.Append(CCFLAGS=['-DNACL_TRUSTED_BUT_NOT_TCB'])

  gen_dfa = env_gen_dfa.ComponentProgram(
      'gen_dfa',
      ['unreviewed/gen_dfa.cc'])

  # Source generation step 2: Generate decoder automata.
  #
  # Now we are back to conditionally defining the large automata generated
  # by gen_dfa.

  def MakeAutomaton(bits, automaton, dfa_gen_actions, ragel_flags):
    rl_file = '%s_x86_%s_instruction.rl' % (automaton, bits)

    # We are cheating here: there are two autogenerated files:
    #  .rl and _consts.c, but we only track .rl one.  This is safe because
    #  _consts.c file includes constants referenced by .rl file and if .rl
    #  file is not changed _consts.c is guaranteed to be the same (reverse
    #  is not true).

    const_file = '%s/%s_x86_%s_instruction_consts.h' % (
        val_src_dir, automaton, bits)

    env.Command(
        target=rl_file,
        source=[gen_dfa] + INST_DEFS,
        action=(
            '${SOURCES[0]} -o ${TARGET} -c %s -m %s -d %s %s') % (
                # Const file (-c): not tracked by SCONS (see above)
                const_file,
                # Argument for CPU type (-m): either "ia32" or "amd64".
                {'32': 'ia32', '64': 'amd64'}[bits],
                # (-d):
                dfa_gen_actions,
                # pass inst defs as remaining parameters
                ' '.join('${SOURCES[%d]}' % (i + 1)
                         for i in range(len(INST_DEFS)))
        )
    )
    c_file = '%s_x86_%s.c' % (automaton, bits)
    c_full_filename = '%s/%s' % (val_src_dir, c_file)
    env.Command(
        target=c_file,
        source=['unreviewed/%s_x86_%s.rl' % (automaton, bits),
                '%s/byte_machines.rl' % rl_src_dir,
                'unreviewed/parse_instruction.rl',
                rl_file],
        action=['%s %s -LL -I.. -I%s ${SOURCES[0]} -o ${TARGET}' % (
            ragel_binary, ragel_flags, rl_src_dir)]
    )

    def InjectGeneratedFileHeader(target, source, env):
      source_filename = source[0].get_abspath()
      target_filename = target[0].get_abspath()

      architecture = {'32': 'ia32', '64': 'x86-64'}[bits]

      with open(source_filename, 'r') as source_file:
        comment, sep, rest = source_file.read().partition('*/')
        if sep == '':
          raise UserError('Generated file %s does not have '
                          'header comment block' % source_filename)

      _, _, short_name = target_filename.rpartition('/native_client/')

      with open(target_filename, 'w') as target_file:
        target_file.write(
            ('/* native_client/%s\n'
             ' * THIS FILE IS AUTO-GENERATED. DO NOT EDIT.\n'
             ' * Compiled for %s mode.\n'
             ' */') % (short_name, architecture))

        target_file.write(rest)

    # inject comments and place files to appropriate dir
    env.Command(
        target=c_full_filename,
        source=['%s/%s' % (rl_src_dir, c_file)],
        action=InjectGeneratedFileHeader
    )

    return rl_file, c_file, c_full_filename

  decoder32 = MakeAutomaton(
      '32', 'decoder',
      'check_access,opcode,parse_operands_states',
      '-T0')
  validator32 = MakeAutomaton(
      '32', 'validator',
      ('check_access,opcode,parse_operands,parse_operands_states,'
       'instruction_name,nacl-forbidden'),
      '-G2')
  decoder64 = MakeAutomaton(
      '64', 'decoder',
      'check_access,opcode,parse_operands_states',
      '-T0')
  validator64 = MakeAutomaton(
      '64', 'validator',
      ('opcode,instruction_name,nacl-forbidden,parse_nonwrite_registers,'
       'parse_x87_operands,parse_mmx_operands,parse_xmm_operands,'
       'parse_ymm_operands,parse_relative_operands,parse_immediate_operands,'
       'parse_operands_states,parse_operand_positions'),
      '-GT2')

  automata = list(decoder32 + validator32 + decoder64 + validator64)

  # Gnerate byte_machines.rl from byte_machines.py
  env.Command(
      target='byte_machines.rl',
      source=['unreviewed/byte_machines.py'],
      action=('${PYTHON} ${SOURCES[0]} -o ${TARGET}')
  )

  # Prepair 'dfacheckdecoder' test.
  #
  # In this test, all acceptable instructions are enumerated
  # by DFA traversal, and for each one objdump output and
  # DFA-based decoder output are compared.
  # It takes few hours to run the test, so it's not included
  # into any suits and is supposed to be run manually when
  # changes are made to DFA definitions.
  # Also, since DFA generation is currently linux-only,
  # this test is somewhat platform-dependent as well.

  test_env = env.Clone()
  test_env.Append(
      CCFLAGS=['-g', '-Wno-unused-function'],
      LINKFLAGS='-g',
      CPPPATH='unreviewed')

  objdump, gas = env.Command(
      target=['objdump', 'gas'],
      source=['obtain_binutils.py'],
      action='${PYTHON} ${SOURCES[0]} ${TARGETS[0]} ${TARGETS[1]}'
  )

  check_decoders = []

  for bits in ('32', '64'):
    (one_valid_instr_rl,) = env.AutoDepsCommand(
        'one_valid_instruction_x86_%s.rl' % bits,
        [gen_dfa, '-o', '${TARGET}'] + map(env.File, INST_DEFS) +
        ['-d', 'check_access,vex_prefix,opcode,parse_operands_states',
         '-d', 'parse_operands,instruction_name',
         '-m', {'32': 'ia32', '64': 'amd64'}[bits]])

    include_dir = one_valid_instr_rl.dir.get_abspath()

    (one_instr_xml,) = env.AutoDepsCommand(
        'one_instruction_x86_%s.xml' % bits,
        [ragel_binary,
         '-x',
         '-I%s' % include_dir,
         '-I..',
         env.File('unreviewed/one_instruction_x86_%s.rl' % bits),
         '-o', '${TARGET}'],
        extra_deps=[
            one_valid_instr_rl,
            'unreviewed/parse_instruction.rl',
            '%s/byte_machines.rl' % rl_src_dir])

    check_decoder = env.AutoDepsCommand(
        'check_decoder_test_results_%s' % bits,
        ['${PYTHON}',
         env.File('check_decoder.py'),
         one_instr_xml,
         '--gas', gas,
         '--objdump', objdump,
         '--decoder', decoder_test,
         '--bits', bits])

    check_decoders.append(check_decoder)

  # Never run decoder tests in parallel because they can take all CPU.
  SideEffect('check_decoder', check_decoders)

  env.AlwaysBuild(env.Alias('dfagen', automata))
  env.AlwaysBuild(env.Alias('dfaclean', action=map(Delete, automata)))
  env.AlwaysBuild(env.Alias('dfacheckdecoder', check_decoders))
