@hex:
  # Originally these tests came from
  # https://github.com/mseaborn/x86-decoder/blob/x86-64/validator_test.py
  
  # Check some simple allowed instructions.
  # nop
  90
  # hlt
  f4
  # mov $0x12345678, %rax
  48 c7 c0 78 56 34 12
  # mov $0x1234567812345678, %rax
  48 b8 78 56 34 12 78 56 34 12
@dis:
     0:	90                   	nop
     1:	f4                   	hlt    
     2:	48 c7 c0 78 56 34 12 	mov    $0x12345678,%rax
     9:	48 b8 78 56 34 12 78 	mov    $0x1234567812345678,%rax
    10:	56 34 12 
@rdfa_output:
  return code: 0
----------------------------------------------------------------------
@hex:
  # Check a disallowed instruction.
  # nop
  90
  # int $0x80
  cd 80
@dis:
     0:	90                   	nop
     1:	cd 80                	int    $0x80
@rdfa_output:
  1: [0] unrecognized instruction
  return code: 1
----------------------------------------------------------------------
@hex:
  # ret
  c3
@dis:
     0:	c3                   	retq   
@rdfa_output:
  0: [0] unrecognized instruction
  return code: 1
----------------------------------------------------------------------
@hex:
  # syscall
  0f 05
@dis:
     0:	0f 05                	syscall 
@rdfa_output:
  0: [0] unrecognized instruction
  return code: 1
----------------------------------------------------------------------
@hex:
  # mov $0x1234567812345678, %rax
  48 b8 78 56 34 12 78 56 34 12
  # mov $0x1234567812345678, %rax
  48 b8 78 56 34 12 78 56 34 12
  # mov $0x1234567812345678, %rax
  48 b8 78 56 34 12 78 56 34 12
  # mov $0x1234567812345678, %rax
  48 b8 78 56 34 12 78 56 34 12
@dis:
     0:	48 b8 78 56 34 12 78 	mov    $0x1234567812345678,%rax
     7:	56 34 12 
     a:	48 b8 78 56 34 12 78 	mov    $0x1234567812345678,%rax
    11:	56 34 12 
    14:	48 b8 78 56 34 12 78 	mov    $0x1234567812345678,%rax
    1b:	56 34 12 
    1e:	48 b8 78 56 34 12 78 	mov    $0x1234567812345678,%rax
    25:	56 34 12 
@rdfa_output:
  1e: [0] unrecognized instruction
  20: [0] direct jump out of range
  24: [0] direct jump out of range
  return code: 1
----------------------------------------------------------------------
@hex:
  # Forwards and backwards jumps.
  # nop
  90
  # jmp .+6
  eb 04
  # jmp .+0
  eb fe
  # jmp .-2
  eb fc
  # jmp .-4
  eb fa
@dis:
     0:	90                   	nop
     1:	eb 04                	jmp    0x7
     3:	eb fe                	jmp    0x3
     5:	eb fc                	jmp    0x3
     7:	eb fa                	jmp    0x3
@rdfa_output:
  return code: 0
----------------------------------------------------------------------
@hex:
  # Out-of-range unaligned jump.
  # jmp .-1
  eb fd
@dis:
     0:	eb fd                	jmp    0xffffffff
@rdfa_output:
  0: [0] direct jump out of range
  return code: 1
----------------------------------------------------------------------
@hex:
  # Out-of-range unaligned jump.
  # jmp .+33
  eb 1f
@dis:
     0:	eb 1f                	jmp    0x21
@rdfa_output:
  0: [0] direct jump out of range
  return code: 1
----------------------------------------------------------------------
@hex:
  # Jump into instruction.
  # mov $0x1234567812345678, %rax
  48 b8 78 56 34 12 78 56 34 12
  # jmp .-5
  eb f9
@dis:
     0:	48 b8 78 56 34 12 78 	mov    $0x1234567812345678,%rax
     7:	56 34 12 
     a:	eb f9                	jmp    0x5
@rdfa_output:
  a: [0] bad jump target
  return code: 1
----------------------------------------------------------------------
@hex:
  # Unmasked indirect jumps are disallowed.
  # jmp *%rax
  ff e0
@dis:
     0:	ff e0                	jmpq   *%rax
@rdfa_output:
  0: [0] unrecognized instruction
  return code: 1
----------------------------------------------------------------------
@hex:
  # jmp *(%rax)
  ff 20
@dis:
     0:	ff 20                	jmpq   *(%rax)
@rdfa_output:
  0: [0] unrecognized instruction
  return code: 1
----------------------------------------------------------------------
@hex:
  # call *%rax
  ff d0
@dis:
     0:	ff d0                	callq  *%rax
@rdfa_output:
  0: [0] unrecognized instruction
  return code: 1
----------------------------------------------------------------------
@hex:
  # call *(%rax)
  ff 10
@dis:
     0:	ff 10                	callq  *(%rax)
@rdfa_output:
  0: [0] unrecognized instruction
  return code: 1
----------------------------------------------------------------------
@hex:
  # Masking instructions on their own are allowed.
  # and $~31, %eax
  83 e0 e0
  # and $~31, %ebx
  83 e3 e0
  # and $~31, %rax
  48 83 e0 e0
  # and $~31, %rbx
  48 83 e3 e0
@dis:
     0:	83 e0 e0             	and    $0xffffffffffffffe0,%eax
     3:	83 e3 e0             	and    $0xffffffffffffffe0,%ebx
     6:	48 83 e0 e0          	and    $0xffffffffffffffe0,%rax
     a:	48 83 e3 e0          	and    $0xffffffffffffffe0,%rbx
@rdfa_output:
  return code: 0
----------------------------------------------------------------------
@hex:
  # and $~31, %eax
  83 e0 e0
  # add %r15, %rax
  4c 01 f8
  
  # and $~31, %ebx
  83 e3 e0
  # add %r15, %rbx
  4c 01 fb
@dis:
     0:	83 e0 e0             	and    $0xffffffffffffffe0,%eax
     3:	4c 01 f8             	add    %r15,%rax
     6:	83 e3 e0             	and    $0xffffffffffffffe0,%ebx
     9:	4c 01 fb             	add    %r15,%rbx
@rdfa_output:
  return code: 0
----------------------------------------------------------------------
@hex:
  # Masked indirect jumps are allowed.
  # and $~31, %eax
  83 e0 e0 \\
  # add %r15, %rax
  4c 01 f8 \\
  # jmp *%rax
  ff e0
@dis:
     0:	83 e0 e0             	and    $0xffffffffffffffe0,%eax
     3:	4c 01 f8             	add    %r15,%rax
     6:	ff e0                	jmpq   *%rax
@rdfa_output:
  return code: 0
----------------------------------------------------------------------
@hex:
  # and $~31, %ebx
  83 e3 e0 \\
  # add %r15, %rbx
  4c 01 fb \\
  # call *%rbx
  ff d3
@dis:
     0:	83 e3 e0             	and    $0xffffffffffffffe0,%ebx
     3:	4c 01 fb             	add    %r15,%rbx
     6:	ff d3                	callq  *%rbx
@rdfa_output:
  return code: 0
----------------------------------------------------------------------
@hex:
  # The registers must match up for the mask and the jump.
  # and $~31, %ebx
  83 e3 e0
  # add %r15, %rax
  4c 01 f8
  # jmp *%rax
  ff e0
@dis:
     0:	83 e3 e0             	and    $0xffffffffffffffe0,%ebx
     3:	4c 01 f8             	add    %r15,%rax
     6:	ff e0                	jmpq   *%rax
@rdfa_output:
  6: [0] unrecognized instruction
  return code: 1
----------------------------------------------------------------------
@hex:
  # and $~31, %eax
  83 e0 e0
  # add %r15, %rbx
  4c 01 fb
  # jmp *%rax
  ff e0
@dis:
     0:	83 e0 e0             	and    $0xffffffffffffffe0,%eax
     3:	4c 01 fb             	add    %r15,%rbx
     6:	ff e0                	jmpq   *%rax
@rdfa_output:
  6: [0] unrecognized instruction
  return code: 1
----------------------------------------------------------------------
@hex:
  # and $~31, %eax
  83 e0 e0
  # add %r15, %rax
  4c 01 f8
  # jmp *%rbx
  ff e3
@dis:
     0:	83 e0 e0             	and    $0xffffffffffffffe0,%eax
     3:	4c 01 f8             	add    %r15,%rax
     6:	ff e3                	jmpq   *%rbx
@rdfa_output:
  6: [0] unrecognized instruction
  return code: 1
----------------------------------------------------------------------
@hex:
  # and $~31, %eax
  83 e0 e0
  # add %r15, %rbx
  4c 01 fb
  # jmp *%rbx
  ff e3
@dis:
     0:	83 e0 e0             	and    $0xffffffffffffffe0,%eax
     3:	4c 01 fb             	add    %r15,%rbx
     6:	ff e3                	jmpq   *%rbx
@rdfa_output:
  6: [0] unrecognized instruction
  return code: 1
----------------------------------------------------------------------
@hex:
  # and $~31, %ebx
  83 e3 e0
  # add %r15, %rbx
  4c 01 fb
  # jmp *%rax
  ff e0
@dis:
     0:	83 e3 e0             	and    $0xffffffffffffffe0,%ebx
     3:	4c 01 fb             	add    %r15,%rbx
     6:	ff e0                	jmpq   *%rax
@rdfa_output:
  6: [0] unrecognized instruction
  return code: 1
----------------------------------------------------------------------
@hex:
  # The mask and the jump must be adjacent.
  # and $~31, %eax
  83 e0 e0
  # nop
  90
  # add %r15, %rax
  4c 01 f8
  # jmp *%rax
  ff e0
@dis:
     0:	83 e0 e0             	and    $0xffffffffffffffe0,%eax
     3:	90                   	nop
     4:	4c 01 f8             	add    %r15,%rax
     7:	ff e0                	jmpq   *%rax
@rdfa_output:
  7: [0] unrecognized instruction
  return code: 1
----------------------------------------------------------------------
@hex:
  # and $~31, %eax
  83 e0 e0
  # add %r15, %rax
  4c 01 f8
  # nop
  90
  # jmp *%rax
  ff e0
@dis:
     0:	83 e0 e0             	and    $0xffffffffffffffe0,%eax
     3:	4c 01 f8             	add    %r15,%rax
     6:	90                   	nop
     7:	ff e0                	jmpq   *%rax
@rdfa_output:
  7: [0] unrecognized instruction
  return code: 1
----------------------------------------------------------------------
@hex:
  # Jumping into the middle of the superinstruction must be rejected.
  # and $~31, %eax
  83 e0 e0
  # add %r15, %rax
  4c 01 f8
  # jmp *%rax
  ff e0
  # jmp .-2
  eb fc
@dis:
     0:	83 e0 e0             	and    $0xffffffffffffffe0,%eax
     3:	4c 01 f8             	add    %r15,%rax
     6:	ff e0                	jmpq   *%rax
     8:	eb fc                	jmp    0x6
@rdfa_output:
  8: [0] bad jump target
  return code: 1
----------------------------------------------------------------------
@hex:
  # and $~31, %eax
  83 e0 e0
  # add %r15, %rax
  4c 01 f8
  # jmp *%rax
  ff e0
  # jmp .-5
  eb f9
@dis:
     0:	83 e0 e0             	and    $0xffffffffffffffe0,%eax
     3:	4c 01 f8             	add    %r15,%rax
     6:	ff e0                	jmpq   *%rax
     8:	eb f9                	jmp    0x3
@rdfa_output:
  8: [0] bad jump target
  return code: 1
----------------------------------------------------------------------
@hex:
  # Read-only access to special registers is allowed.
  # push %rax
  50
  # push %rbp
  55
  # push %rsp
  54
  # push %r15
  41 57
  # mov %rsp, %rax
  48 89 e0
@dis:
     0:	50                   	push   %rax
     1:	55                   	push   %rbp
     2:	54                   	push   %rsp
     3:	41 57                	push   %r15
     5:	48 89 e0             	mov    %rsp,%rax
@rdfa_output:
  return code: 0
----------------------------------------------------------------------
@hex:
  # Write access to special registers is not allowed.
  # pop %rax
  58
@dis:
     0:	58                   	pop    %rax
@rdfa_output:
  return code: 0
----------------------------------------------------------------------
@hex:
  # pop %rbp
  5d
@dis:
     0:	5d                   	pop    %rbp
@rdfa_output:
  0: [0] error - %bpl or %bp is changed
  return code: 1
----------------------------------------------------------------------
@hex:
  # pop %rsp
  5c
@dis:
     0:	5c                   	pop    %rsp
@rdfa_output:
  0: [0] error - %spl or %sp is changed
  return code: 1
----------------------------------------------------------------------
@hex:
  # pop %r15
  41 5f
@dis:
     0:	41 5f                	pop    %r15
@rdfa_output:
  0: [0] error - %r15 is changed
  return code: 1
----------------------------------------------------------------------
@hex:
  # Memory accesses.
  # mov %eax, %eax
  89 c0 \\
  # mov (%r15, %rax), %ebx
  41 8b 1c 07
@dis:
     0:	89 c0                	mov    %eax,%eax
     2:	41 8b 1c 07          	mov    (%r15,%rax,1),%ebx
@rdfa_output:
  return code: 0
@spec:
  SAFE
----------------------------------------------------------------------
@hex:
  # Test for a top-bit-set register.
  # mov %r12d, %r12d
  45 89 e4 \\
  # mov (%r15, %r12), %ebx
  43 8b 1c 27
@dis:
     0:	45 89 e4             	mov    %r12d,%r12d
     3:	43 8b 1c 27          	mov    (%r15,%r12,1),%ebx
@rdfa_output:
  return code: 0
@spec:
  SAFE
----------------------------------------------------------------------
@hex:
  # Check %edi and %esi because the first 'mov' also begins superinstructions.
  # mov %edi, %edi
  89 ff \\
  # mov (%r15, %rdi), %ebx
  41 8b 1c 3f
@dis:
     0:	89 ff                	mov    %edi,%edi
     2:	41 8b 1c 3f          	mov    (%r15,%rdi,1),%ebx
@rdfa_output:
  return code: 0
@spec:
  SAFE
----------------------------------------------------------------------
@hex:
  # mov %esi, %esi
  89 f6 \\
  # mov (%r15, %rsi), %ebx
  41 8b 1c 37
@dis:
     0:	89 f6                	mov    %esi,%esi
     2:	41 8b 1c 37          	mov    (%r15,%rsi,1),%ebx
@rdfa_output:
  return code: 0
@spec:
  SAFE
----------------------------------------------------------------------
@hex:
  # Check mask on its own.
  # mov %eax, %eax
  89 c0
@dis:
     0:	89 c0                	mov    %eax,%eax
@rdfa_output:
  return code: 0
@spec:
  SAFE
----------------------------------------------------------------------
@hex:
  # mov (%r15, %rax), %ebx
  41 8b 1c 07
@dis:
     0:	41 8b 1c 07          	mov    (%r15,%rax,1),%ebx
@rdfa_output:
  0: [0] improper memory address - bad index
  return code: 1
@spec:
  0: register %rax should be restricted, while in fact None is restricted
----------------------------------------------------------------------
@hex:
  # mov %eax, %eax
  89 c0
  # mov (%r15, %rax), %ebx
  41 8b 1c 07
  # jmp .-4
  eb fa
@dis:
     0:	89 c0                	mov    %eax,%eax
     2:	41 8b 1c 07          	mov    (%r15,%rax,1),%ebx
     6:	eb fa                	jmp    0x2
@rdfa_output:
  6: [0] bad jump target
  return code: 1
@spec:
  6: jump into a middle of instruction (0x2)
----------------------------------------------------------------------
@hex:
  # Check that post-conditions do not leak from a superinstruction.  In the
  # PyDFA validator, to share DFT states, the first instruction of the
  # nacljmp, "and $~31, %eax", records a post-condition, just as when it is
  # used on its own.  Although the code below is safe, we don't really want
  # the post-condition to leak through.
  # and $~31, %eax
  83 e0 e0
  # add %r15, %rax
  4c 01 f8
  # jmp *%rax
  ff e0
  # %rax should not be regarded as zero-extended here.
  # mov (%r15, %rax), %ebx
  41 8b 1c 07
@dis:
     0:	83 e0 e0             	and    $0xffffffffffffffe0,%eax
     3:	4c 01 f8             	add    %r15,%rax
     6:	ff e0                	jmpq   *%rax
     8:	41 8b 1c 07          	mov    (%r15,%rax,1),%ebx
@rdfa_output:
  8: [0] improper memory address - bad index
  return code: 1
----------------------------------------------------------------------
@hex:
  # mov %edi, %edi
  89 ff
  # lea (%r15, %rdi), %rdi
  49 8d 3c 3f
  # rep stos %al, %es:(%rdi)
  f3 aa
  # %rdi should not be regarded as zero-extended here.
  # mov (%r15, %rdi), %ebx
  41 8b 1c 3f
@dis:
     0:	89 ff                	mov    %edi,%edi
     2:	49 8d 3c 3f          	lea    (%r15,%rdi,1),%rdi
     6:	f3 aa                	rep stos %al,%es:(%rdi)
     8:	41 8b 1c 3f          	mov    (%r15,%rdi,1),%ebx
@rdfa_output:
  8: [0] improper memory address - bad index
  return code: 1
----------------------------------------------------------------------
@hex:
  # mov %esi, %esi
  89 f6
  # lea (%r15, %rsi), %rsi
  49 8d 34 37
  # mov %edi, %edi
  89 ff
  # lea (%r15, %rdi), %rdi
  49 8d 3c 3f
  # rep movsb %ds:(%rsi), %es:(%rdi)
  f3 a4
  # %rsi should not be regarded as zero-extended here.
  # mov (%r15, %rsi), %ebx
  41 8b 1c 37
@dis:
     0:	89 f6                	mov    %esi,%esi
     2:	49 8d 34 37          	lea    (%r15,%rsi,1),%rsi
     6:	89 ff                	mov    %edi,%edi
     8:	49 8d 3c 3f          	lea    (%r15,%rdi,1),%rdi
     c:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
     e:	41 8b 1c 37          	mov    (%r15,%rsi,1),%ebx
@rdfa_output:
  e: [0] improper memory address - bad index
  return code: 1
----------------------------------------------------------------------
@hex:
  # Non-%r15-based memory accesses.
  # mov 0x1234(%rip), %eax
  8b 05 34 12 00 00
  # mov 0x1234(%rsp), %eax
  8b 84 24 34 12 00 00
  # mov 0x1234(%rbp), %eax
  8b 85 34 12 00 00
@dis:
     0:	8b 05 34 12 00 00    	mov    0x1234(%rip),%eax        # 0x123a
     6:	8b 84 24 34 12 00 00 	mov    0x1234(%rsp),%eax
     d:	8b 85 34 12 00 00    	mov    0x1234(%rbp),%eax
@rdfa_output:
  return code: 0
----------------------------------------------------------------------
@hex:
  # mov 0x1234(%rsp, %rbx), %eax
  8b 84 1c 34 12 00 00
@dis:
     0:	8b 84 1c 34 12 00 00 	mov    0x1234(%rsp,%rbx,1),%eax
@rdfa_output:
  0: [0] improper memory address - bad index
  return code: 1
----------------------------------------------------------------------
@hex:
  # mov 0x1234(%rbp, %rbx), %eax
  8b 84 1d 34 12 00 00
@dis:
     0:	8b 84 1d 34 12 00 00 	mov    0x1234(%rbp,%rbx,1),%eax
@rdfa_output:
  0: [0] improper memory address - bad index
  return code: 1
----------------------------------------------------------------------
@hex:
  # mov %ebx, %ebx
  89 db \\
  # mov 0x1234(%rsp, %rbx), %eax
  8b 84 1c 34 12 00 00
@dis:
     0:	89 db                	mov    %ebx,%ebx
     2:	8b 84 1c 34 12 00 00 	mov    0x1234(%rsp,%rbx,1),%eax
@rdfa_output:
  return code: 0
----------------------------------------------------------------------
@hex:
  # mov %ebx, %ebx
  89 db \\
  # mov 0x1234(%rbp, %rbx), %eax
  8b 84 1d 34 12 00 00
@dis:
     0:	89 db                	mov    %ebx,%ebx
     2:	8b 84 1d 34 12 00 00 	mov    0x1234(%rbp,%rbx,1),%eax
@rdfa_output:
  return code: 0
----------------------------------------------------------------------
@hex:
  # 'lea' is not a memory access.
  # lea (%rbx, %rcx, 4), %rax
  48 8d 04 8b
@dis:
     0:	48 8d 04 8b          	lea    (%rbx,%rcx,4),%rax
@rdfa_output:
  return code: 0
----------------------------------------------------------------------
@hex:
  # Stack operations.
  # mov %rsp, %rbp
  48 89 e5
  # mov %rbp, %rsp
  48 89 ec
@dis:
     0:	48 89 e5             	mov    %rsp,%rbp
     3:	48 89 ec             	mov    %rbp,%rsp
@rdfa_output:
  return code: 0
----------------------------------------------------------------------
@hex:
  # add $8, %ebp
  83 c5 08 \\
  # add %r15, %rbp
  4c 01 fd
@dis:
     0:	83 c5 08             	add    $0x8,%ebp
     3:	4c 01 fd             	add    %r15,%rbp
@rdfa_output:
  return code: 0
----------------------------------------------------------------------
@hex:
  # add $8, %ebp
  83 c5 08
  # add %r15, %rbp
  4c 01 fd
  # jmp .-3
  eb fb
@dis:
     0:	83 c5 08             	add    $0x8,%ebp
     3:	4c 01 fd             	add    %r15,%rbp
     6:	eb fb                	jmp    0x3
@rdfa_output:
  6: [0] bad jump target
  return code: 1
----------------------------------------------------------------------
@hex:
  # A stack fixup on its own is not allowed.
  # add %r15, %rbp
  4c 01 fd
@dis:
     0:	4c 01 fd             	add    %r15,%rbp
@rdfa_output:
  0: [0] improper %rbp sandboxing
  return code: 1
----------------------------------------------------------------------
@hex:
  # add %r15, %rsp
  4c 01 fc
@dis:
     0:	4c 01 fc             	add    %r15,%rsp
@rdfa_output:
  0: [0] improper %rsp sandboxing
  return code: 1
----------------------------------------------------------------------
@hex:
  # add %r15, %r15
  4d 01 ff
@dis:
     0:	4d 01 ff             	add    %r15,%r15
@rdfa_output:
  0: [0] error - %r15 is changed
  return code: 1
----------------------------------------------------------------------
@hex:
  # Sandboxing is not required on prefetch instructions.
  # prefetchnta (%rax)
  0f 18 00
@dis:
     0:	0f 18 00             	prefetchnta (%rax)
@rdfa_output:
  return code: 0
----------------------------------------------------------------------
@hex:
  # Segment register manipulations are forbidden
  # mov %rax, %es
  48 8e c0
@dis:
     0:	48 8e c0             	mov    %rax,%es
@rdfa_output:
  0: [0] unrecognized instruction
  return code: 1
----------------------------------------------------------------------
@hex:
  # mov %es, %rax
  48 8c c0
@dis:
     0:	48 8c c0             	mov    %es,%rax
@rdfa_output:
  0: [0] unrecognized instruction
  return code: 1
