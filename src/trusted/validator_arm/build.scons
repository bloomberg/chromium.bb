# -*- python -*-
# Copyright (c) 2012 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import os
Import('env')

if not env.Bit('linux'): Return()

env.Append(
  # TODO(cbiffle): give everyone else these warnings too.
  # TODO(karl): Why does -fno-rtti cause linking issues.
  # CXXFLAGS='-Weffc++ -Woverloaded-virtual -fno-rtti -fomit-frame-pointer',
  CXXFLAGS='-Weffc++ -Woverloaded-virtual -fomit-frame-pointer',
)

# ------------------------------------------------------------------
# Source generation is controlled by command line directives.
# The two directives are:
#   valclean : Delete the existing versions of the generated files.
#       This step should be done whenever ANY change may effect
#       the generated sources.
#
#   valgen : Regenerate any deleted source files. Note: some generated
#       source files do understand dependencies and do not need to be
#       deleted before calling valgen. However, do not count on this,
#       as some dependencies are not caught. To be safe, if you have
#       modified a file that effects source generation, run "valclean"
#       followed by a "valgen" to guarantee that generated sources are
#       up to date.
gen_env = env.Clone();

# Defines this source directory.
GEN_SRC_DIR = '${MAIN_DIR}/src/trusted/validator_arm/gen'

# Defines the full file name for a generated file.
def _gen_file(filename):
  return '%s/%s' % (GEN_SRC_DIR, filename)

# Set of generated source files.
GEN_LIST = [_gen_file(x) for x in
            ['arm32_decode.cc', 'arm32_decode.h',
             'arm32_decode_named.cc' ,
             'arm32_decode_named_classes.h',
             'arm32_decode_named_decoder.h',
             'arm32_decode_tests.cc']]

# If non-empty, it should include the list of table names (in
# armv7.table) that valgen should generate tests for. Allows testing
# of a small number of tables without the overhead of running tests
# for all tables.
GEN_TABLES=""

generate = False
gen_env = env.Clone();
if 'valgen' in COMMAND_LINE_TARGETS: generate = True
if 'valclean' in COMMAND_LINE_TARGETS: generate = True

if generate:
  gen_env.AlwaysBuild(gen_env.Alias('valgen', GEN_LIST))
  gen_env.AlwaysBuild(
    gen_env.Alias('valclean', action=[Delete(x) for x in GEN_LIST]))

def _generate_source(filename):
  env.Command(target=filename,
              source=['armv7.table',
                      'generate_decoder.py',
                      'dgen_core.py',
                      'dgen_input.py',
                      'dgen_opt.py',
                      'dgen_output.py',
                      'dgen_decoder_output.py',
                      'dgen_test_output.py',
                      ],
              action=['${SOURCES[1].abspath} ${SOURCES[0].abspath} '
                      '${TARGET.abspath} Arm32DecoderState ' + GEN_TABLES])

for f in GEN_LIST:
  _generate_source(f)

env.ComponentLibrary('arm_validator_core',
                     ['address_set.cc',
                      'actual_classes.cc',
                      'actual_classes_statics.cc',
                      'baseline_classes.cc',
                      'baseline_classes_statics.cc',
                      'inst_classes.cc',
                      'validator.cc',
                      'gen/arm32_decode.cc'])

env.ComponentLibrary('ncvalidate_arm_v2',
                     ['ncvalidate.cc'],
                     LIBS=['arm_validator_core',
                           '${OPTIONAL_COVERAGE_LIBS}'])

ncval = env.ComponentProgram(
    'arm-ncval-core',
    ['ncval.cc'],
    LIBS=['arm_validator_core',
          env.NaClTargetArchSuffix('ncfileutils'),
          '${OPTIONAL_COVERAGE_LIBS}'])

env.SDKInstallBin('ncval', ncval, target='arm')

# Build test environment to show that we are compiling in the test
# environment (rather than for the TCB).
gtest_env = env.MakeGTestEnv()
gtest_env.Append(CCFLAGS=['-DNACL_TRUSTED_BUT_NOT_TCB'])

gtest_env.ComponentProgram('address_set_test_binary',
                           ['address_set_test.cc'],
                           LIBS=['arm_validator_core',
                                 '${OPTIONAL_COVERAGE_LIBS}'])

address_set_test = gtest_env.Command(target='address_set_test.out',
                                     source=['address_set_test_binary'],
                                     action=['${SOURCES[0].abspath}'])

# TODO(cbiffle): get this wrapped in QEMU.
#env.AddNodeToTestSuite(address_set_test, ['small_tests'], 'address_set_test')

validator_tests = {
  'test_external_jumps': 1,
  'test_forbidden_instructions': 1,
  'test_internal_jumps': 1,
  'test_sp_updates': 1,
  'test_stores': 1,
  'test_vector_stores': 1,
  'test_loads': 1,
  'test_vector_loads': 1,
}

for test, exit_status in validator_tests.iteritems():
  node = gtest_env.CommandTest(
      test + '_actual.out',
      [ncval, gtest_env.File('testdata/' + test + '.nexe')],
      exit_status = str(exit_status),
      filter_regex = "'^ncval'",
      # NOTE: all stdout_golden are currently empty
      stdout_golden = gtest_env.File('testdata/' + test + '.out'),
      stderr_golden = gtest_env.File('testdata/' + test + '.err'))

  gtest_env.AddNodeToTestSuite(node, ['small_tests', 'validator_tests'],
                               "run_arm_" + test)

gtest_env.ComponentLibrary('decoder_test_tools',
                           ['decoder_tester.cc',
                            'inst_classes_testers.cc',
                            'actual_vs_baseline.cc',
                            'gen/arm32_decode_named.cc']);

# Do NOT name this program 'validator_tests' because this is the same name as
# a test suite, and scons will run that test suite if it ever builds
# a program of the same name.
validator_tests_exe = gtest_env.ComponentProgram('arm_validator_tests',
                               ['validator_tests.cc'],
                               EXTRA_LIBS=['arm_validator_core'])

test_node = gtest_env.CommandTest(
    'validator_tests.out',
    command=[validator_tests_exe])
gtest_env.AddNodeToTestSuite(test_node, ['small_tests'],
    'run_arm_validator_tests')

# Test ARM (32-bit) instruction decoding.
decoder_tests_exe = gtest_env.ComponentProgram(
    'arm32_decode_tests',
    ['gen/arm32_decode_tests.cc'],
    EXTRA_LIBS=['decoder_test_tools', 'arm_validator_core'])

decoder_test_node = gtest_env.CommandTest(
    'arm32_decode_tests.out',
    command=[decoder_tests_exe],
    scale_timeout=1000)

gtest_env.AddNodeToTestSuite(decoder_test_node,
                             ['huge_tests', 'arm_decoder_tests'],
                              'run_arm_decoder_tests')
