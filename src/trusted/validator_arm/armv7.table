# ARMv7 Instruction Encodings
#
# This table is derived from the "ARM Architecture Reference Manual, ARMv7-A
# and ARMv7-R edition" and is used here with the permission of ARM Limited.
# Reproduction for purposes other than the development and distribution of
# Native Client may require the explicit permission of ARM Limited.

# This file defines the Native Client "instruction classes" assigned to every
# possible ARMv7 instruction encoding.  It is organized into a series of tables,
# and directly parallels the ARM Architecture Reference Manual cited above.
#
# Each table consists of
# - A name,
# - A citation in the Architecture Reference Manual,
# - One or more columns defining bitfields to match, and
# - One or more rows describing patterns in those bitfields.
#
# A leading tilde (~) negates a pattern.  A hyphen (-) is short for a string of
# don't-care bits (x).  A double-quote (") indicates that a pattern is the same
# as the row above it.
#
# Each row may specify a terminal instruction class ("=InstClass"), or forward
# the reader to a different table ("->table_name").
#
# If an encoding is not valid in every ARM architecture rev, the instruction
# class may indicate the rev or feature that makes the encoding valid in
# parentheses.
#
# For documentation and testing, an "=InstClass" can be followed by up to 3
# additional identifiers, and has the form:
#     =InstClass Rule Pattern Constraints
# where
#     InstClass - is the class decoder to return when matched.
#     Rule - is the Arm rule that applies to the match (see below).
#     Pattern - is a bitpattern for testing instances of the rule.
#     Constraints - identifies what additional constraints are assumed
#            by the corresponding rule.
#
# The Rules are identified with an identifier of the form:
#     NNN_Rule_SS_AA_Pppp
# where
#    NNN is the nmenonic of the instruction.
#    SS is the section number in A8.6.SS that define the instruction.
#    AA is the instruction form on that page,
#    pp is the page number in A8-pp that the instruction is on.
#
# Patterns are sequences of 32 characters as follows:
#   '1' - Bit must be value 1.
#   '0' - Bit must be value 0.
#   'cccc' - Bits defining condition.
#   'dddd' - Bits defining register Rd.
#   'ii...i' - Bits defining an immediate value.
#   'II...I' - Bits defining an immediate value (test sampling only).
#   'mmmm' - Bits defining register Rm.
#   'nnnn' - Bits defining register Rn.
#   'ssss' - Bits defining register Rs.
#   'tttt' - Bits defining register Rt.
#   'tt'   - Bits defining the shift type (for register operations).
#   'u'    - Bit(20) defining whether register flags is updated (deprecated)
#   's'    - Bit(20) defining whether register flags is updated.
#   'w'    - Bit(21) defining writes flag.
#   'r'    - Bit(22) defining if SPSR register is read.
#   'd'    - Bit(23) Direction (add vs subtract) of offset. (deprecated)
#   'u'    - Bit(23) Direction (add vs subtract) of offset.
#   'p'    - Bit(24) defining if pre-indexing should be used.
#
# Constraints can be broken into three categories:
#    Parse precondition - Don't test the instruction if the parse
#        precondition is met.
#    Safety constraint - Safety should not have allowed the
#        instruction to be parsed if the given constraint is defined.
#    Parse precondition and safety constraint - Contains both
#        parse precondition(s) and safety constraint(s).
#
# Parse constraints are only necessary because our pattern language is
# too simple. In most cases, the decoder tables will chose the
# appropriate class decoder. However, it will be different than the
# one being tested. Hence, we add a precondition parse check to
# make sure we don't test these cases.
#
# Parse preconditions:
#    NotRdIsPcAndS - not (Rd is Pc (R15) and S=1 (updates register bit)).
#    NeitherRdIsPcAndSNorRnIsPcAndNotS - Neither
#        (1) Rd is Pc and S=1; nor
#        (2) Rn is Pc ans S=0;
#    NeitherImm5NotZeroNorNotRdIsPcAndS - Neither combination of the above two
#        (1) The immediate (5-bit) value must not be zero; nor
#        (2) Not (Rd is Pc (R15) and S=1 (updates register bit)).
#    NotRnIsPc - Rn!=Pc.
#    NotRnIsSp - Rn!=Sp.
#
# Safety constraints:
#    RegsNotPc - All registers defined by instruction are not Pc (R15).
#
# Parse precondition and safety constraint:
#    NotRaIsPcAndRegsNotPc - Parse precondition Ra!=Pc and safety
#         constraint that all registers defined by the instruction
#         are not Pc (R15).
#    NotRnIsPcAndRegsNotPc - Parse precondition Rn!=pc and safety
#         constraint that all registers defined by the instruction
#         are not Pc (R15).

##############################################################
# The following defines a class decoder hierarchy used to select the
# appropriate tester. We want to add class hierarchy information for
# classes that want their tester to be defined on a superclass.
# By providing this information, the generator can pick out
# the corresponding baseline class tester to use, and does
# not need to define separate testers for derived classes of
# the baseline class tester.
# #############################################################

class BreakPointAndConstantPoolHead : Immediate16Use
class Binary3RegisterImmedShiftedOpRegsNotPc : Binary3RegisterImmedShiftedOp
class ForbiddenCondNop : UnsafeCondNop
class ForbiddenUncondNop : UnsafeUncondNop
class LoadRegisterList : LoadStoreRegisterList      
class LoadStoreVectorRegister : LoadStoreVectorOp
class LoadVectorRegister : LoadStoreVectorRegister
class LoadVectorRegisterList : LoadStoreVectorRegisterList
class Load3RegisterDoubleOp : LoadStore3RegisterDoubleOp
class Load2RegisterImm8DoubleOp : LoadStore2RegisterImm8DoubleOp
class Load2RegisterImm8Op : LoadStore2RegisterImm8Op
class Load2RegisterImm12Op : LoadStore2RegisterImm12Op
class Load3RegisterImm5Op : LoadStore3RegisterImm5Op
class Load3RegisterOp : LoadStore3RegisterOp
class MaskedBinary2RegisterImmediateOp : Binary2RegisterImmediateOp
class MaskedBinaryRegisterImmediateTest : BinaryRegisterImmediateTest
class StoreRegisterList : LoadStoreRegisterList
class Store2RegisterImm12OpRnNotRtOnWriteback : Store2RegisterImm12Op
class Store3RegisterDoubleOp : LoadStore3RegisterDoubleOp
class Store2RegisterImm8DoubleOp : LoadStore2RegisterImm8DoubleOp
class Store2RegisterImm8Op : LoadStore2RegisterImm8Op
class Store2RegisterImm12Op : LoadStore2RegisterImm12Op
class Store3RegisterImm5Op : LoadStore3RegisterImm5Op
class Store3RegisterOp : LoadStore3RegisterOp
class Unary2RegisterOpNotRmIsPcNoCondUpdates : Unary2RegisterOpNotRmIsPc

##############################################################
# The following define decoder tables.
##############################################################

+-- ARMv7 (See Section A5.1)
| cond(31:28) op1(27:25) op(4)
| ~1111       00x        -     ->data_processing_and_miscellaneous_instructions
| "           010        -     ->load_store_word_and_unsigned_byte
| "           011        0     ->load_store_word_and_unsigned_byte
| "           "          1     ->media_instructions
| "           10x        -     ->branch_branch_with_link_and_block_data_transfer
| "           11x        -     ->coprocessor_instructions_and_supervisor_call
| 1111        -          -     ->unconditional_instructions
+--

+-- data_processing_and_miscellaneous_instructions (See Section A5.2)
| op(25) op1(24:20) op2(7:4)
| 0      ~10xx0     xxx0     ->data_processing_register
| "      "          0xx1     ->data_processing_register_shifted_register
| "      10xx0      0xxx     ->miscellaneous_instructions
| "      "          1xx0     ->halfword_multiply_and_multiply_accumulate
| "      0xxxx      1001     ->multiply_and_multiply_accumulate
| "      1xxxx      1001     ->synchronization_primitives
| "      ~0xx1x     1011     ->extra_load_store_instructions
| "      "          11x1     "
| "      0xx1x      1011     =Forbidden  # Load/Store Unprivileged, plus undef
| "      "          11x1     "
| 1      ~10xx0     -        ->data_processing_immediate
| "      10000      -        = Unary1RegisterImmediateOp => Defs12To15 # MOVW A8-194
                               Mov_Rule_96_A2_P194
                               cccc00110000iiiiddddIIIIIIIIIIII
                               RegsNotPc
                               (v6T2)
| "      10100      -        = Unary1RegisterImmediateOp => Defs12To15 # MOVT A8-200
                               Mov_Rule_99_A1_P200
                               cccc00110100iiiiddddIIIIIIIIIIII
                               RegsNotPc
                               (v6T2)
| "      10x10      -        ->msr_immediate_and_hints
+--

# Note: We track conditions flags on many of the class decoders
# in this section, since they can be used to change the value of SP,
# and we want to allow masking to follow in the next instruction.
+-- data_processing_register (See Section A5.2.1)
| op1(24:20) op2(11:7) op3(6:5)
| 0000x      -         -        = Binary3RegisterImmedShiftedOp
                                     => Defs12To15
                                     And_Rule_7_A1_P36
                                     cccc0000000unnnnddddiiiiitt0mmmm
                                     NotRdIsPcAndS
| 0001x      -         -        = Binary3RegisterImmedShiftedOp
                                     => Defs12To15CondsDontCare
                                     Eor_Rule_45_A1_P96
                                     cccc0000001unnnnddddiiiiitt0mmmm
                                     NotRdIsPcAndS
| 0010x      -         -        = Binary3RegisterImmedShiftedOp
                                     => Defs12To15
# Note: For arm, the case where Rn=SP is NOT a special case (only in thumb2).
# Hence, parse restriction does not apply (See Sub_Rule_216_P428 in manual).
                                     Sub_Rule_213_A1_P422
                                     cccc0000010unnnnddddiiiiitt0mmmm
                                     NotRdIsPcAndS
| 0011x      -         -        = Binary3RegisterImmedShiftedOp
                                     => Defs12To15
                                     Rsb_Rule_143_P286
                                     cccc0000011unnnnddddiiiiitt0mmmm
                                     NotRdIsPcAndS
| 0100x      -         -        = Binary3RegisterImmedShiftedOp
                                     => Defs12To15
# Note: For arm, the case where Rn=SP is NOT a special case (only in thumb2).
# Hence, parse restriction does not apply (See Add_Rule_8_A1_P28 in manual).
                                     Add_Rule_6_A1_P24
                                     cccc0000100unnnnddddiiiiitt0mmmm
                                     NotRdIsPcAndS
| 0101x      -         -        = Binary3RegisterImmedShiftedOp
                                     => Defs12To15
                                     Adc_Rule_2_A1_P16
                                     cccc0000101unnnnddddiiiiitt0mmmm
                                     NotRdIsPcAndS
| 0110x      -         -        = Binary3RegisterImmedShiftedOp
                                     => Defs12To15
                                     Sbc_Rule_152_A1_P304
                                     cccc0000110unnnnddddiiiiitt0mmmm
                                     NotRdIsPcAndS
| 0111x      -         -        = Binary3RegisterImmedShiftedOp
                                     => Defs12To15
                                     Rsc_Rule_146_A1_P292
                                     cccc0000111unnnnddddiiiiitt0mmmm
                                     NotRdIsPcAndS
| 10001      -         -        = Binary2RegisterImmedShiftedTest
                                     => DontCareInst
                                     Tst_Rule_231_A1_P456
                                     cccc00010001nnnn0000iiiiitt0mmmm 
| 10011      -         -        = Binary2RegisterImmedShiftedTest
                                     => DontCareInst
                                     Teq_Rule_228_A1_P450
                                     cccc00010011nnnn0000iiiiitt0mmmm
| 10101      -         -        = Binary2RegisterImmedShiftedTest
                                     => DontCareInst
                                     Cmp_Rule_36_A1_P82
                                     cccc00010101nnnn0000iiiiitt0mmmm
| 10111      -         -        = Binary2RegisterImmedShiftedTest
                                     => DontCareInst
                                     Cmn_Rule_33_A1_P76
                                     cccc00010111nnnn0000iiiiitt0mmmm
# TODO(jfb) op==10xx0 should be unreachable from here:
#           the previous table should handle it.
| 1100x      -         -        = Binary3RegisterImmedShiftedOp
                                     => Defs12To15
                                     Orr_Rule_114_A1_P230
                                     cccc0001100unnnnddddiiiiitt0mmmm
                                     NotRdIsPcAndS
| 1101x      00000     00       = Unary2RegisterOp
                                     => Defs12To15
                                     Mov_Rule_97_A1_P196
                                     cccc0001101u0000dddd00000000mmmm
                                     NotRdIsPcAndS
| "          ~00000    00       = Unary2RegisterImmedShiftedOp
                                     => Defs12To15
                                     Lsl_Rule_88_A1_P178
                                     cccc0001101u0000ddddiiiii000mmmm
                                     NeitherImm5NotZeroNorNotRdIsPcAndS
| "          -         01       = Unary2RegisterImmedShiftedOp
                                     => Defs12To15
                                     Lsr_Rule_90_A1_P182
                                     cccc0001101u0000ddddiiiii010mmmm
                                     NotRdIsPcAndS
| "          -         10       = Unary2RegisterImmedShiftedOp
                                     => Defs12To15
                                     Asr_Rule_14_A1_P40
                                     cccc0001101u0000ddddiiiii100mmmm
                                     NotRdIsPcAndS
| "          00000     11       = Unary2RegisterOp
                                     => Defs12To15
                                     Rrx_Rule_141_A1_P282
                                     cccc0001101u0000dddd00000110mmmm
                                     NotRdIsPcAndS
| "          ~00000    11       = Unary2RegisterImmedShiftedOp
                                     => Defs12To15
                                     Ror_Rule_139_A1_P278
                                     cccc0001101u0000ddddiiiii110mmmm
                                     NeitherImm5NotZeroNorNotRdIsPcAndS
| 1110x      -         -        = Binary3RegisterImmedShiftedOp
                                     => Defs12To15
                                     Bic_Rule_20_A1_P52
                                     cccc0001110unnnnddddiiiiitt0mmmm
                                     NotRdIsPcAndS
| 1111x      -         -        = Unary2RegisterImmedShiftedOp
                                     => Defs12To15
                                     Mvn_Rule_107_A1_P216
                                     cccc0001111u0000ddddiiiiitt0mmmm
                                     NotRdIsPcAndS
+--

+-- data_processing_register_shifted_register (See Section A5.2.2)
| op1(24:20) op2(6:5)
| 0000x      -        = Binary4RegisterShiftedOp
                           => Defs12To15RdRnRsRmNotPc
                           And_Rule_13_A1_P38
                           cccc0000000snnnnddddssss0tt1mmmm RegsNotPc
| 0001x      -        = Binary4RegisterShiftedOp
                           => Defs12To15CondsDontCareRdRnRsRmNotPc
                           Eor_Rule_46_A1_P98
                           cccc0000001snnnnddddssss0tt1mmmm RegsNotPc
| 0010x      -        = Binary4RegisterShiftedOp
                           => Defs12To15RdRnRsRmNotPc
                           Sub_Rule_214_A1_P424
                           cccc0000010snnnnddddssss0tt1mmmm RegsNotPc
| 0011x      -        = Binary4RegisterShiftedOp
                            => Defs12To15RdRnRsRmNotPc
                           Rsb_Rule_144_A1_P288
                           cccc0000011snnnnddddssss0tt1mmmm RegsNotPc
| 0100x      -        = Binary4RegisterShiftedOp
                           => Defs12To15RdRnRsRmNotPc
                           Add_Rule_7_A1_P26 
                           cccc0000100snnnnddddssss0tt1mmmm RegsNotPc
| 0101x      -        = Binary4RegisterShiftedOp
                           => Defs12To15RdRnRsRmNotPc
                           Adc_Rule_3_A1_P18
                           cccc0000101snnnnddddssss0tt1mmmm RegsNotPc      
| 0110x      -        = Binary4RegisterShiftedOp
                           => Defs12To15RdRnRsRmNotPc
                           Sbc_Rule_153_A1_P306
                           cccc0000110snnnnddddssss0tt1mmmm RegsNotPc
| 0111x      -        = Binary4RegisterShiftedOp
                           => Defs12To15RdRnRsRmNotPc
                           Rsc_Rule_147_A1_P294
                           cccc0000111snnnnddddssss0tt1mmmm RegsNotPc
# TODO(jfb) op==10xx0 should be unreachable from here:
#           the previous table should handle it.
| 10001      -        = Binary3RegisterShiftedTest
                           => DontCareInstRnRsRmNotPc
                           Tst_Rule_232_A1_P458
                           cccc00010001nnnn0000ssss0tt1mmmm RegsNotPc
| 10011      -        = Binary3RegisterShiftedTest
                           => DontCareInstRnRsRmNotPc
                           Teq_Rule_229_A1_P452
                           cccc00010011nnnn0000ssss0tt1mmmm RegsNotPc
| 10101      -        = Binary3RegisterShiftedTest
                           => DontCareInstRnRsRmNotPc
                           Cmp_Rule_37_A1_P84
                           cccc00010101nnnn0000ssss0tt1mmmm RegsNotPc
| 10111      -        = Binary3RegisterShiftedTest
                           => DontCareInstRnRsRmNotPc
                           Cmn_Rule_34_A1_P78
                           cccc00010111nnnn0000ssss0tt1mmmm RegsNotPc
| 1100x      -        = Binary4RegisterShiftedOp
                           => Defs12To15RdRnRsRmNotPc
                           Orr_Rule_115_A1_P212
                           cccc0001100snnnnddddssss0tt1mmmm RegsNotPc
| 1101x      00       = Binary3RegisterOp
                           => Defs12To15RdRmRnNotPc
                           Lsl_Rule_89_A1_P180
                           cccc0001101s0000ddddmmmm0001nnnn RegsNotPc
| "          01       = Binary3RegisterOp
                           => Defs12To15RdRmRnNotPc
                           Lsr_Rule_91_A1_P184
                           cccc0001101s0000ddddmmmm0011nnnn RegsNotPc
| "          10       = Binary3RegisterOp
                           => Defs12To15RdRmRnNotPc
                           Asr_Rule_15_A1_P42
                           cccc0001101s0000ddddmmmm0101nnnn RegsNotPc
| "          11       = Binary3RegisterOp
                           => Defs12To15RdRmRnNotPc
                           Ror_Rule_140_A1_P280
                           cccc0001101s0000ddddmmmm0111nnnn RegsNotPc
| 1110x      -        = Binary4RegisterShiftedOp
                           => Defs12To15RdRnRsRmNotPc
                           Bic_Rule_21_A1_P54
                           cccc0001110snnnnddddssss0tt1mmmm RegsNotPc
| 1111x      -        = Unary3RegisterShiftedOp
                           => Defs12To15RdRmRnNotPc
                           Mvn_Rule_108_A1_P218
                           cccc0001111s0000ddddssss0tt1mmmm RegsNotPc
+--

+-- data_processing_immediate (See Section A5.2.3)
# Note: The two interesting instructions in this set are
# TestIfAddressMasked and MaskAddress. These two instructions are the
# ones that we allow testing/setting of bits to mask data addresses
# appropriately.
| op(24:20) Rn(19:16)
| 0000x      -        = Binary2RegisterImmediateOp
                           => Defs12To15
                           And_Rule_11_A1_P34
                           cccc0010000snnnnddddiiiiiiiiiiii NotRdIsPcAndS
| 0001x      -        = Binary2RegisterImmediateOp
                           => Defs12To15
                           Eor_Rule_44_A1_P94
                           cccc0010001snnnnddddiiiiiiiiiiii NotRdIsPcAndS
| 0010x      ~1111    = Binary2RegisterImmediateOp
                           => Defs12To15
                           Sub_Rule_212_A1_P420
                           cccc0010010snnnnddddiiiiiiiiiiii
                           NeitherRdIsPcAndSNorRnIsPcAndNotS
                        # Note: Table says that op=0010x for ADR, but
                        # patterns for ADR do not match (page A8-32).
                        # Causes parsing conflicts with SUB (previous
                        # row). Added restriction to ADR that bit 20
                        # (updates flags register) must be 0 (rather than
                        # x), to match what is on A8.6.10 (page A8-32).
                        # Note that this also matches restrictions of
                        # A8.6.212 (page A8-420).
| 00100      1111     = Unary1RegisterImmediateOp
                           => Defs12To15
                           Adr_Rule_10_A2_P32
                           cccc001001001111ddddiiiiiiiiiiii
| 00101      1111     = Forbidden # SUBS PC, LR and related instructions
| 0011x      -        = Binary2RegisterImmediateOp
                           => Defs12To15
                           Rsb_Rule_142_A1_P284
                           cccc0010011snnnnddddiiiiiiiiiiii NotRdIsPcAndS
| 0100x      ~1111    = Binary2RegisterImmediateOp
                           => Defs12To15
                           Add_Rule_5_A1_P22
                           cccc0010100snnnnddddiiiiiiiiiiii 
                           NeitherRdIsPcAndSNorRnIsPcAndNotS
                        # Note: Table says that op=0100x for ADR, but
                        # patterns for ADR do not match (page A8-32).
                        # Causes parsing conflicts with ADD (previous
                        # row). Added restriction to ADR that bit 20
                        # (updates flags register) must be 0 (rather than
                        # x), to match what is on A8.6.10 (page A8-32).
                        # Note that this also matches restrictions of
                        # A8.6.5 (page A8-22).
| 01000      1111     = Unary1RegisterImmediateOp
                           => Defs12To15
                           Adr_Rule_10_A1_P32
                           cccc001010001111ddddiiiiiiiiiiii
| 01001      1111     = Forbidden # SUBS PC, LR and related instructions
| 0101x      -        = Binary2RegisterImmediateOp
                           => Defs12To15
                           Adc_Rule_6_A1_P14
                           cccc0010101snnnnddddiiiiiiiiiiii NotRdIsPcAndS
| 0110x      -        = Binary2RegisterImmediateOp
                           => Defs12To15
                           Sbc_Rule_151_A1_P302
                           cccc0010110snnnnddddiiiiiiiiiiii NotRdIsPcAndS
| 0111x      -        = Binary2RegisterImmediateOp
                           => Defs12To15
                           Rsc_Rule_145_A1_P290
                           cccc0010111snnnnddddiiiiiiiiiiii NotRdIsPcAndS
# TODO(jfb) op==10xx0 should be unreachable from here:
#           the previous table should handle it.
                        # Note: Following instruction is used to test
                        # if the immediate value appropriately (data address)
                        # masks the value in Rn.
| 10001      -        = MaskedBinaryRegisterImmediateTest
                           => TestIfAddressMasked
                           Tst_Rule_230_A1_P454
                           cccc00110001nnnn0000iiiiiiiiiiii
| 10011      -        = BinaryRegisterImmediateTest
                           => DontCareInst
                           Teq_Rule_227_A1_P448
                           cccc00110011nnnn0000iiiiiiiiiiii
| 10101      -        = BinaryRegisterImmediateTest
                           => DontCareInst
                           Cmp_Rule_35_A1_P80
                           cccc00110101nnnn0000iiiiiiiiiiii
| 10111      -        = BinaryRegisterImmediateTest
                           => DontCareInst
                           Cmn_Rule_32_A1_P74
                           cccc00110111nnnn0000iiiiiiiiiiii
| 1100x      -        = Binary2RegisterImmediateOp
                           => Defs12To15
                           Orr_Rule_113_A1_P228
                           cccc0011100snnnnddddiiiiiiiiiiii NotRdIsPcAndS
| 1101x      -        = Unary1RegisterImmediateOp
                           => Defs12To15
                           Mov_Rule_96_A1_P194
                           cccc0011101s0000ddddiiiiiiiiiiii NotRdIsPcAndS
                        # Note: The following instruction is used to mask
                        # memory addresses.
| 1110x      -        = MaskedBinary2RegisterImmediateOp
                           => MaskAddress
                           Bic_Rule_19_A1_P50
                           cccc0011110snnnnddddiiiiiiiiiiii NotRdIsPcAndS
| 1111x      -        = Unary1RegisterImmediateOp
                           => Defs12To15
                           Mvn_Rule_106_A1_P214
                           cccc0011111s0000ddddiiiiiiiiiiii NotRdIsPcAndS
+--

# Note: in all of these cases there's a currently unhandled restriction:
#         if ArchVersion() < 6 && d == n then Unpredictable.
#       And for long versions:
#         if ArchVersion() < 6 && ((dhi == n) || (dlo == n)) then Unpredictable.
#       Revisit if we want to support chips before v6.
+-- multiply_and_multiply_accumulate (See Section A5.2.5)
| op(23:20)
| 000x      = Binary3RegisterOpAltA
                 => Defs16To19CondsDontCareRdRmRnNotPc
                 Mul_Rule_105_A1_P212
                 cccc0000000sdddd0000mmmm1001nnnn RegsNotPc
| 001x      = Binary4RegisterDualOp
                 => Defs16To19CondsDontCareRdRaRmRnNotPc
                 Mla_Rule_94_A1_P190
                 cccc0000001sddddaaaammmm1001nnnn RegsNotPc
| 0100      = Binary4RegisterDualResult
                 => Defs12To19CondsDontCareRdRmRnNotPc
                 Umaal_Rule_244_A1_P482
                 cccc00000100hhhhllllmmmm1001nnnn RegsNotPc (v6)
| 0101      = Undefined
| 0110      = Binary4RegisterDualOp
                 => Defs16To19CondsDontCareRdRaRmRnNotPc
                 Mls_Rule_95_A1_P192
                 cccc00000110ddddaaaammmm1001nnnn RegsNotPc (v6T2)
| 0111      = Undefined
| 100x      = Binary4RegisterDualResult
                 => Defs12To19CondsDontCareRdRmRnNotPc
                 Umull_Rule_246_A1_P486
                 cccc0000100shhhhllllmmmm1001nnnn RegsNotPc                 
| 101x      = Binary4RegisterDualResult
                 => Defs12To19CondsDontCareRdRmRnNotPc
                 Umlal_Rule_245_A1_P484
                 cccc0000101shhhhllllmmmm1001nnnn RegsNotPc
| 110x      = Binary4RegisterDualResult
                 => Defs12To19CondsDontCareRdRmRnNotPc
                 Smull_Rule_179_A1_P356
                 cccc0000110shhhhllllmmmm1001nnnn RegsNotPc   
| 111x      = Binary4RegisterDualResult
                 => Defs12To19CondsDontCareRdRmRnNotPc
                 Smlal_Rule_168_A1_P334
                 cccc0000111shhhhllllmmmm1001nnnn RegsNotPc
+--

+-- saturating_addition_and_subtraction (See Section A5.2.6)
| op(22:21)
| 00        = Binary3RegisterOpAltB
              => Defs12To15CondsDontCareRnRdRmNotPc
              Qadd_Rule_124_A1_P250
              cccc00010000nnnndddd00000101mmmm RegsNotPc (v5TE)
| 01        = Binary3RegisterOpAltB
              => Defs12To15CondsDontCareRnRdRmNotPc
              Qsub_Rule_131_A1_P264
              cccc00010010nnnndddd00000101mmmm RegsNotPc (v5TE)
| 10        = Binary3RegisterOpAltB
              => Defs12To15CondsDontCareRnRdRmNotPc
              Qdadd_Rule_128_A1_P258
              cccc00010100nnnndddd00000101mmmm RegsNotPc (v5TE)
| 11        = Binary3RegisterOpAltB
              => Defs12To15CondsDontCareRnRdRmNotPc
              Qdsub_Rule_129_A1_P260
              cccc00010110nnnndddd00000101mmmm RegsNotPc (v5TE)
+--

+-- halfword_multiply_and_multiply_accumulate (See Section A5.2.7)
| op1(22:21) op(5)
                     # Implements Smlabb, Smlabt, Smlatb, and Smlatt
                     # where the t/b bits (xx) are in bits 5:6.
| 00         -     = Binary4RegisterDualOp
                        => Defs16To19CondsDontCareRdRaRmRnNotPc
                        Smlaxx_Rule_166_A1_P330
                        cccc00010000ddddaaaammmm1xx0nnnn RegsNotPc (v5TE)
                     # Implements Smlawb and Smlawt where the t/b (X)
                     # bit is in bit 6.
| 01         0     = Binary4RegisterDualOp
                        => Defs16To19CondsDontCareRdRaRmRnNotPc
                        Smlawx_Rule_171_A1_340
                        cccc00010010ddddaaaammmm1x00nnnn RegsNotPc (v5TE)
                     # Implements Smulwb and Smulwt where the t/b (x)
                     # bit is in bit 6.
| 01         1     = Binary3RegisterOpAltA
                        => Defs16To19CondsDontCareRdRmRnNotPc
                        Smulwx_Rule_180_A1_P358
                        cccc00010010dddd0000mmmm1x10nnnn RegsNotPc (v5TE) 
                     # Implements Smlalbb, Smlalbt, Smlaltb, and Smlaltt
                     # where the t/b bits (xx) are in bits 5:6.
| 10         -     = Binary4RegisterDualResult
                        => Defs12To19CondsDontCareRdRmRnNotPc
                        Smlalxx_Rule_169_A1_P336
                        cccc00010100hhhhllllmmmm1xx0nnnn RegsNotPc (v5TE)
                     # Implements Smulbb, Smulbt, Smultb, and Smultt
                     # where the t/b bits (xx) are in bits 5:6.
| 11         -     = Binary3RegisterOpAltA
                        => Defs16To19CondsDontCareRdRmRnNotPc
                        Smulxx_Rule_178_P354
                        cccc00010110dddd0000mmmm1xx0nnnn RegsNotPc (v5TE)
+--

+-- extra_load_store_instructions (See Section A5.2.8)
| op2(6:5) op1(24:20) Rn(19:16)
# Note the following encodings which lead to a different table and aren't
# handled in this table.
# TODO(jfb) Should we make them Forbidden?
# 00       -          -         ->data_processing_and_miscellaneous_instructions
# -        0xx11      -         "
# 0x       0xx10      -         "
#
| 01       xx0x0      -         = Store3RegisterOp => StoreBasedOffsetMemory
                                  Strh_Rule_208_A1_P412
                                  cccc000pu0w0nnnntttt00001011mmmm
| "        xx0x1      -         = Load3RegisterOp => LoadBasedOffsetMemory
                                  Ldrh_Rule_76_A1_P156
                                  cccc000pu0w1nnnntttt00001011mmmm
| "        xx1x0      -         = Store2RegisterImm8Op
                                  => StoreBasedImmedMemory
                                  Strh_Rule_207_A1_P410
                                  cccc000pu1w0nnnnttttiiii1011iiii
| "        xx1x1      ~1111     = Load2RegisterImm8Op 
                                  => LoadBasedImmedMemory
                                  Ldrh_Rule_74_A1_P152
                                  cccc000pu1w1nnnnttttiiii1011iiii
| "        "          1111      = Load2RegisterImm8Op
                                  => LoadBasedImmedMemory
                                  Ldrh_Rule_75_A1_P154
                                  cccc0001u1011111ttttiiii1011iiii
| 10       xx0x0      -         = Load3RegisterDoubleOp
                                  => LoadBasedOffsetMemoryDouble
                                  Ldrd_Rule_68_A1_P140
                                  cccc000pu0w0nnnntttt00001101mmmm (v5TE)
| "        xx0x1      -         = Load3RegisterOp => LoadBasedOffsetMemory
                                  Ldrsb_Rule_80_A1_P164
                                  cccc000pu0w1nnnntttt00001101mmmm
| "        xx1x0      ~1111     = Load2RegisterImm8DoubleOp
                                  => LoadBasedImmedMemoryDouble
                                  Ldrd_Rule_66_A1_P136
                                  cccc000pu1w0nnnnttttiiii1101iiii (v5TE)
| "        "          1111      = Load2RegisterImm8DoubleOp
                                  => LoadBasedImmedMemoryDouble 
                                  Ldrd_Rule_67_A1_P138
                                  cccc0001u1001111ttttiiii1101iiii (v5TE)
| "        xx1x1      ~1111     = Load2RegisterImm8Op
                                  => LoadBasedImmedMemory
                                  Ldrsb_Rule_78_A1_P160
                                  cccc000pu1w1nnnnttttiiii1101iiii
| "        "          1111      = Load2RegisterImm8Op
                                  => LoadBasedImmedMemory
                                  ldrsb_Rule_79_A1_162
                                  cccc0001u1011111ttttiiii1101iiii
| 11       xx0x0      -         = Store3RegisterDoubleOp
                                  => StoreBasedOffsetMemoryDouble
                                  Strd_Rule_201_A1_P398
                                  cccc000pu0w0nnnntttt00001111mmmm
| "        xx0x1      -         = Load3RegisterOp => LoadBasedOffsetMemory
                                  Ldrsh_Rule_84_A1_P172
                                  cccc000pu0w1nnnntttt00001111mmmm
| "        xx1x0      -         = Store2RegisterImm8DoubleOp
                                  => StoreBasedImmedMemoryDouble
                                  Strd_Rule_200_A1_P396
                                  cccc000pu1w0nnnnttttiiii1111iiii
| "        xx1x1      ~1111     = Load2RegisterImm8Op
                                  => LoadBasedImmedMemory
                                  Ldrsh_Rule_82_A1_P168
                                  cccc000pu1w1nnnnttttiiii1111iiii
| "        "          1111      = Load2RegisterImm8Op
                                  => LoadBasedImmedMemory
                                  Ldrsh_Rule_83_A1_P170
                                  cccc0001u1011111ttttiiii1111iiii
+--

# extra_load_store_instructions_unpriviledged (See section A5.2.9)
# Table omitted: modeled as Forbidden.
# They are not expected in user code.

+-- synchronization_primitives (See Section A5.2.10)
| op(23:20)
| 0x00      = Deprecated      # SWP, SWPB  TODO(karl): model these? a8-432
| 1000      = StoreExclusive3RegisterOp => StoreBasedMemoryRtBits0To3
              Strex_Rule_202_A1_P400
              cccc00011000nnnndddd11111001tttt (v6)
| 1001      = LoadExclusive2RegisterOp => LoadBasedMemory
              Ldrex_Rule_69_A1_P142
              cccc00011001nnnntttt111110011111 (v6)
| 1010      = StoreExclusive3RegisterDoubleOp
              => StoreBasedMemoryDoubleRtBits0To3
              Strexd_Rule_204_A1_P404
              cccc00011010nnnndddd11111001tttt (v6K)
| 1011      = LoadExclusive2RegisterDoubleOp => LoadBasedMemoryDouble
              Ldrexd_Rule_71_A1_P146
              cccc00011011nnnntttt111110011111 (v6K)
| 1100      = StoreExclusive3RegisterOp => StoreBasedMemoryRtBits0To3
              Strexb_Rule_203_A1_P402
              cccc00011100nnnndddd11111001tttt (v6K)
| 1101      = LoadExclusive2RegisterOp => LoadBasedMemory
              Ldrexb_Rule_70_A1_P144
              cccc00011101nnnndddd111110011111 (v6K)
| 1110      = StoreExclusive3RegisterOp  => StoreBasedMemoryRtBits0To3
              Strexh_Rule_205_A1_P406
              cccc00011110nnnndddd11111001tttt (v6K)
| 1111      = LoadExclusive2RegisterOp => LoadBasedMemory
              Ldrexh_Rule_72_A1_P148
              cccc00011111nnnntttt111110011111 (v6K)
| else:     = Undefined (v6K)            # Note on page A5-16
+--

+-- msr_immediate_and_hints (See Section A5.2.11)
| op(22) op1(19:16) op2(7:0)
| 0      0000       0000_0000  = CondNop => DontCareInst
                                 Nop_Rule_110_A1_P222
                                 cccc0011001000001111000000000000 (v6K,v6T2)
| "      "          0000_0001  = CondNop => DontCareInst
                                 Yield_Rule_413_A1_P812
                                 cccc0011001000001111000000000001 (v6K)
| "      "          0000_0010  = ForbiddenCondNop => Forbidden
                                 # Don't allow, may put hardware to sleep
                                 # until a send event occurs.
                                 Wfe_Rule_411_A1_P808
                                 cccc0011001000001111000000000010 (v6K)
| "      "          0000_0011  = ForbiddenCondNop => Forbidden
                                 # Don't allow, may put hardware to sleep
                                 # until a send event occurs.
                                 Wfi_Rule_412_A1_P810
                                 cccc0011001000001111000000000011 (v6K)
| "      "          0000_0100  = ForbiddenCondNop => Forbidden
                                 # Don't allow, causes an event to be
                                 # signalled to all processors in the
                                 # multiprocessor system.
                                 Sev_Rule_158_A1_P316
                                 cccc0011001000001111000000000100 (v6K)
| "      "          1111_xxxx  = CondNop => DontCareInst
                                 Dbg_Rule_40_A1_P88
                                 cccc001100100000111100001111iiii (v7)
| "      0100       -          = MoveImmediate12ToApsr => DontCareInst
                                 # Note: DontCareInst will act like the
                                 # conditions flag is always changed, which
                                 # is a safe presumption.
                                 Msr_Rule_103_A1_P208
| "      1x00       "          "
| "      xx01       -          = ForbiddenCondNop => Forbidden
                                 Msr_Rule_B6_1_6_A1_PB6_12
                                 cccc00110010ii011111iiiiiiiiiiii
                                 # MSR(immediate), ring0 version
| "      xx1x       -          = ForbiddenCondNop => Forbidden
                                 Msr_Rule_B6_1_6_A1_PB6_12
                                 cccc00110010ii1i1111iiiiiiiiiiii
                                 # MSR(immediate), ring0 version
| 1      -          -          = ForbiddenCondNop => Forbidden
                                 Msr_Rule_B6_1_6_A1_PB6_12
                                 cccc00110110iiii1111iiiiiiiiiiii
                                 # MSR(immediate), ring0 version
| else:                        = Forbidden  # Unallocated hints, page A5-17
+--

+-- miscellaneous_instructions (See Section A5.2.12)
| op2(6:4) op(22:21) op1(19:16)
| 000      x0        xxxx       = Unary1RegisterSet
                                  Mrs_Rule_102_A1_P206_Or_B6_10
                                  cccc00010r001111dddd000000000000
| "        01        xx00       = Unary1RegisterUse
                                  Msr_Rule_104_A1_P210
                                  cccc00010010mm00111100000000nnnn
| "        01        xx01       = ForbiddenCondNop => Forbidden
                                  Msr_Rule_B6_1_7_P14
                                  cccc00010010mm01111100000000nnnn
| "        "         xx1x       = ForbiddenCondNop => Forbidden
                                  Msr_Rule_B6_1_7_P14
                                  cccc00010010mm1m111100000000nnnn
| "        11        -          = ForbiddenCondNop => Forbidden
                                  Msr_Rule_B6_1_7_P14
                                  cccc00010110mmmm111100000000nnnn
| 001      01        -          = BranchToRegister => BxBlx
                                  Bx_Rule_25_A1_P62
                                  cccc000100101111111111110001mmmm (v4T)
| "        11        -          = Unary2RegisterOpNotRmIsPc
                                  => Defs12To15RdRnNotPc
                                  Clz_Rule_31_A1_P72
                                  cccc000101101111dddd11110001mmmm (v6)
| 010      01        -          = ForbiddenCondNop => Forbidden
                                  Bxj_Rule_26_A1_P64
                                  cccc000100101111111111110010mmmm
| 011      01        -          = BranchToRegister => BxBlx
                                  Blx_Rule_24_A1_P60
                                  cccc000100101111111111110011mmmm
                                  RegsNotPc (v5T)
| 101      -         -          ->saturating_addition_and_subtraction
| 111      01        -          = BreakPointAndConstantPoolHead
                                  => Breakpoint
                                  Bkpt_Rule_22_A1_P56
                                  cccc00010010iiiiiiiiiiii0111iiii (v5T)
| 111      11        -          = ForbiddenCondNop => Forbidden
                                  Smc_Rule_B6_1_9_P18
                                  cccc000101100000000000000111mmmm
| else:                         = Undefined     # Note on page A5-18
+--

+-- load_store_word_and_unsigned_byte (See Section A5.3)
# Note: Column op1 is repeated so that several rows can define
# (anded) multiple test conditions for this row.
| A(25) op1(24:20) B(4) Rn(19:16)  op1_repeated(24:20)
| 0     xx0x0      -    -          ~0x010 -> load_store_word_and_unsigned_byte_str_or_push
| 1     xx0x0      0    -          ~0x010
                                   = Store3RegisterImm5Op 
                                   => StoreBasedOffsetMemory
                                   Str_Rule_195_A1_P386
                                   cccc011pd0w0nnnnttttiiiiitt0mmmm
# STRT (rule 210, A1 and A2, page 416) define unprivledge stores, which
# NaCl doesn't allow.
| 0     0x010      -    -          - = Forbidden
| 1     0x010      0    -          - = Forbidden
| 0     xx0x1      -    ~1111      ~0x011
                                   = Load2RegisterImm12Op
                                   => LoadBasedImmedMemory
                                   Ldr_Rule_58_A1_P120
                                   cccc010pd0w1nnnnttttiiiiiiiiiiii NotRnIsPc
| "     xx0x1      "    1111       ~0x011  
                                   = Load2RegisterImm12Op
                                   => LoadBasedImmedMemory
                                   Ldr_Rule_59_A1_P122
                                   cccc0101d0011111ttttiiiiiiiiiiii
| 1     xx0x1      0    -          ~0x011
                                   = Load3RegisterImm5Op => LoadBasedOffsetMemory
                                   Ldr_Rule_60_A1_P124
                                   cccc011pd0w1nnnnttttiiiiitt0mmmm
# LDRT (rule 86, A1 and A2, page 176) define unprivledge loads, which
# NaCl doesn't allow.
| 0     0x011      -    -          - = Forbidden
| 1     0x011      0    -          - = Forbidden
| 0     xx1x0      -    -          ~0x110
                                   = Store2RegisterImm12Op
                                   => StoreBasedImmedMemory
                                   Strb_Rule_197_A1_P390
                                   cccc010pd1w0nnnnttttiiiiiiiiiiii
| 1     xx1x0      0    -          ~0x110
                                   = Store3RegisterImm5Op
                                   => StoreBasedOffsetMemory
                                   Strb_Rule_198_A1_P392
                                   cccc011pd1w0nnnnttttiiiiitt0mmmm
# Strbt (rule 199, A1 and A2, page 394) define unprivledged stores, which
# NaCl doesn't allow.
| 0     0x110      -    -          - = Forbidden # STRBT A8-394
| 1     0x110      0    -          - "
| 0     xx1x1      -    ~1111      ~0x111
                                   = Load2RegisterImm12Op
                                   => LoadBasedImmedMemory
                                   Ldrb_Rule_62_A1_P128
                                   cccc010pd1w1nnnnttttiiiiiiiiiiii NotRnIsPc
| "     xx1x1      "    1111       ~0x111
                                   = Load2RegisterImm12Op
                                   => LoadBasedImmedMemory
                                   Ldrb_Rule_63_A1_P130
                                   cccc0101d1011111ttttiiiiiiiiiiii
| 1     xx1x1      0    -          ~0x111
                                   = Load3RegisterImm5Op => LoadBasedOffsetMemory
                                   Ldrb_Rule_64_A1_P132
                                   cccc011pd1w1nnnnttttiiiiitt0mmmm
# Ldrbt (rule 65, A1 and A2, page 134) define unprivledged loads, which
# NaCl doesn't allow.
| 0     0x111      -    -          - = Forbidden
| 1     0x111      0    -          - "
+--

+-- load_store_word_and_unsigned_byte_str_or_push (See Section A5.3)
# This table is written to handle special variant of Str that also
# corresponds to a push, in table load_store_word_and_unsigned_byte.
| Flags(24:21) Rn(19:16) Imm12(11:0)
# Note: The baseline class Store2RegisterImm12OpRnNotRtOnWriteback guarantees
# that we don't allow Rt(15:12) to be PC or SP.
| 1001         1101      000000000100 = Store2RegisterImm12OpRnNotRtOnWriteback
                                      Push_Rule_123_A2_P248
                                      cccc010100101101tttt000000000100
| else:                               = Store2RegisterImm12Op
                                      => StoreBasedImmedMemory
                                      Str_Rule_194_A1_P384
                                      cccc010pu0w0nnnnttttiiiiiiiiiiii
                                      & ~cccc010100101101tttt000000000100
+--


+-- media_instructions (See Section A5.4)
| op1(24:20) op2(7:5) Rd(15:12) Rn(3:0)
| 000xx      -        -         -     ->parallel_addition_and_subtraction_signed
| 001xx      -        -         -     ->parallel_addition_and_subtraction_unsigned
| 01xxx      -        -         -     ->packing_unpacking_saturation_and_reversal
| 10xxx      -        -         -     ->signed_multiply_signed_and_unsigned_divide
| 11000      000      1111      -     = Binary3RegisterOpAltA
                                        => Defs16To19CondsDontCareRdRmRnNotPc
                                        Usad8_Rule_253_A1_P500
                                        cccc01111000dddd1111mmmm0001nnnn
                                        RegsNotPc (v6)
| "          000      ~1111     -     = Binary4RegisterDualOp
                                        => Defs16To19CondsDontCareRdRaRmRnNotPc
                                        Usada8_Rule_254_A1_P502
                                        cccc01111000ddddaaaammmm0001nnnn
                                        # Note: In baseline class, bits(15:12)
                                        # is Ra (not Rd as column name
                                        # suggests).
                                        RegsNotPc (v6)
| 1101x      x10      -         -     = Binary2RegisterBitRangeNotRnIsPc
                                        => Defs12To15CondsDontCareRdRnNotPc
# TODO(karl) Add restriction:
#   mdbit = lsbit + widthminus1
#   if msbit <= 32 then
#      R[d] = SignExtend(R[n]<msbit:lsbit>, 32)
#   else
#      UNPREDICTABLE.
                                        Sbfx_Rule_154_A1_P308
                                        cccc0111101wwwwwddddlllll101nnnn (v6T2)
# TODO(karl) Add RegsNotPc as safety constraint.
| 1110x      x00      -         1111  = Unary1RegisterBitRange
                                        # Note: Alternative form for clearing
                                        # bits in a memory address (i.e.
                                        # alternative for bic).
                                        Bfc_17_A1_P46
                                        cccc0111110mmmmmddddlllll0011111 (v6T2)
# TODO(karl) Add RegsNotPc as safety constraint.
| "          x00      -         ~1111 = Binary2RegisterBitRange
# TODO(karl) Add RegsNotPc as safety constraint.
                                        => Defs12To15CondsDontCare
                                        Bfi_Rule_18_A1_P48
                                        cccc0111110mmmmmddddlllll001nnnn
                                        (v6T2)
| 1111x      x10      -         -     = Binary2RegisterBitRangeNotRnIsPc
                                        => Defs12To15CondsDontCareRdRnNotPc
# TODO(karl) Add same restriction as for Sbfx_Rule_154_A1_P308
                                        Ubfx_Rule_236_A1_P466
                                        cccc0111111mmmmmddddlllll101nnnn (v6T2)
# TODO(karl) Add RegsNotPc as safety constraint.
| 11111      111      -         -     = Roadblock  # Permanently Undefined
| else:                               = Undefined  # Note on page A5-21
+--

+-- parallel_addition_and_subtraction_signed (See Section A5.4.1)
| op1(21:20) op2(7:5)
| 01         000      = Binary3RegisterOpAltB
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Sadd16_Rule_148_A1_P296
                        cccc01100001nnnndddd11110001mmmm RegsNotPc (v6)
| 01         001      = Binary3RegisterOpAltB
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Sasx_Rule_150_A1_P300
                        cccc01100001nnnndddd11110011mmmm RegsNotPc (v6)
| 01         010      = Binary3RegisterOpAltB
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Ssax_Rule_185_A1_P366
                        cccc01100001nnnndddd11110101mmmm RegsNotPc (v6)
| 01         011      = Binary3RegisterOpAltB
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Ssub16_Rule_186_A1_P368
                        cccc01100001nnnndddd11110111mmmm RegsNotPc (v6)
| 01         100      = Binary3RegisterOpAltB
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Ssad8_Rule_149_A1_P298
                        cccc01100001nnnndddd11111001mmmm RegsNotPc (v6)
| 01         111      = Binary3RegisterOpAltB
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Ssub8_Rule_187_A1_P370
                        cccc01100001nnnndddd11111111mmmm RegsNotPc (v6)
| 10         000      = Binary3RegisterOpAltB
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Qadd16_Rule_125_A1_P252
                        cccc01100010nnnndddd11110001mmmm RegsNotPc (v6)
| 10         001      = Binary3RegisterOpAltB
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Qasx_Rule_127_A1_P256
                        cccc01100010nnnndddd11110011mmmm RegsNotPc (v6)
| 10         010      = Binary3RegisterOpAltB
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Qsax_Rule_130_A1_P262
                        cccc01100010nnnndddd11110101mmmm RegsNotPc (v6)
| 10         011      = Binary3RegisterOpAltB
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Qsub16_Rule_132_A1_P266
                        cccc01100010nnnndddd11110111mmmm RegsNotPc (v6)
| 10         100      = Binary3RegisterOpAltB
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Qadd8_Rule_126_A1_P254
                        cccc01100010nnnndddd11111001mmmm RegsNotPc (v6)
| 10         111      = Binary3RegisterOpAltB
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Qsub8_Rule_133_A1_P268
                        cccc01100010nnnndddd11111111mmmm RegsNotPc (v6)
| 11         000      = Binary3RegisterOpAltBNoCondUpdates
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Shadd16_Rule_159_A1_P318
                        cccc01100011nnnndddd11110001mmmm RegsNotPc (v6)
| 11         001      = Binary3RegisterOpAltBNoCondUpdates
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Shasx_Rule_161_A1_P322
                        cccc01100011nnnndddd11110011mmmm RegsNotPc (v6)
| 11         010      = Binary3RegisterOpAltBNoCondUpdates
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Shsax_Rule_162_A1_P324
                        cccc01100011nnnndddd11110101mmmm RegsNotPc (v6)
| 11         011      = Binary3RegisterOpAltBNoCondUpdates
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Shsub16_Rule_163_A1_P326
                        cccc01100011nnnndddd11110111mmmm RegsNotPc (v6)
| 11         100      = Binary3RegisterOpAltBNoCondUpdates
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Shadd8_Rule_160_A1_P320
                        cccc01100011nnnndddd11111001mmmm RegsNotPc (v6)
| 11         111      = Binary3RegisterOpAltBNoCondUpdates
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Shsub8_Rule_164_A1_P328
                        cccc01100011nnnndddd11111111mmmm RegsNotPc (v6)
| else:               = Undefined  # Note on page A5-23
+--

+-- parallel_addition_and_subtraction_unsigned (See Section A5.4.2)
| op1(21:20) op2(7:5)
| 01         000      = Binary3RegisterOpAltB
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Uadd16_Rule_233_A1_P460
                        cccc01100101nnnndddd11110001mmmm RegsNotPc (v6)
| 01         001      = Binary3RegisterOpAltB
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Uasx_Rule_235_A1_P464
                        cccc01100101nnnndddd11110011mmmm RegsNotPc (v6)
| 01         010      = Binary3RegisterOpAltB
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Usax_Rule_257_A1_P508
                        cccc01100101nnnndddd11110101mmmm RegsNotPc (v6)
| 01         011      = Binary3RegisterOpAltB
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Usub16_Rule_258_A1_P510
                        cccc01100101nnnndddd11110111mmmm RegsNotPc (v6)
| 01         100      = Binary3RegisterOpAltB
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Uadd8_Rule_234_A1_P462
                        cccc01100101nnnndddd11111001mmmm RegsNotPc (v6)
| 01         111      = Binary3RegisterOpAltB
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Usub8_Rule_259_A1_P512
                        cccc01100101nnnndddd11111111mmmm RegsNotPc (v6)
| 10         000      = Binary3RegisterOpAltB
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Uqadd16_Rule_247_A1_P488
                        cccc01100110nnnndddd11110001mmmm RegsNotPc (v6)
| 10         001      = Binary3RegisterOpAltB
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Uqasx_Rule_249_A1_P492
                        cccc01100110nnnndddd11110011mmmm RegsNotPc (v6)
| 10         010      = Binary3RegisterOpAltB
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Uqsax_Rule_250_A1_P494
                        cccc01100110nnnndddd11110101mmmm RegsNotPc (v6)
| 10         011      = Binary3RegisterOpAltB
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Uqsub16_Rule_251_A1_P496
                        cccc01100110nnnndddd11110111mmmm RegsNotPc (v6)
| 10         100      = Binary3RegisterOpAltB
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Uqadd8_Rule_248_A1_P490
                        cccc01100110nnnndddd11111001mmmm RegsNotPc (v6)
| 10         111      = Binary3RegisterOpAltB
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Uqsub8_Rule_252_A1_P498
                        cccc01100110nnnndddd11111111mmmm RegsNotPc (v6)
| 11         000      = Binary3RegisterOpAltBNoCondUpdates
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Uhadd16_Rule_238_A1_P470
                        cccc01100111nnnndddd11110001mmmm RegsNotPc (v6)
| 11         001      = Binary3RegisterOpAltBNoCondUpdates
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Uhasx_Rule_240_A1_P474
                        cccc01100111nnnndddd11110011mmmm RegsNotPc (v6)
| 11         010      = Binary3RegisterOpAltBNoCondUpdates
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Uhsax_Rule_241_A1_P476
                        cccc01100111nnnndddd11110101mmmm RegsNotPc (v6)
| 11         011      = Binary3RegisterOpAltBNoCondUpdates
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Uhsub16_Rule_242_A1_P478
                        cccc01100111nnnndddd11110111mmmm RegsNotPc (v6)
| 11         100      = Binary3RegisterOpAltBNoCondUpdates
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Uhadd8_Rule_239_A1_P472
                        cccc01100111nnnndddd11111001mmmm RegsNotPc (v6)
| 11         111      = Binary3RegisterOpAltBNoCondUpdates
                        => Defs12To15CondsDontCareRnRdRmNotPc
                        Uhsub8_Rule_243_A1_P480
                        cccc01100111nnnndddd11111111mmmm RegsNotPc (v6)
| else:               = Undefined  # Note on page A5-23
+--

+-- packing_unpacking_saturation_and_reversal (See Section A5.4.3)
| op1(22:20) op2(7:5) A(19:16)
| 000        xx0      -        = Binary3RegisterImmedShiftedOpRegsNotPc
                                 => Defs12To15CondsDontCareRnRdRmNotPc
                                 Pkh_Rule_116_A1_P234
                                 cccc01101000nnnnddddiiiiit01mmmm
                                 RegsNotPc (v6)
| 01x        xx0      -        = Unary2RegisterSatImmedShiftedOp
                                 => Defs12To15CondsDontCareRdRnNotPc
                                 Ssat_Rule_183_A1_P362
                                 cccc0110101iiiiiddddiiiiis01nnnn (v6)
| 11x        xx0      -        = Unary2RegisterSatImmedShiftedOp
                                 => Defs12To15CondsDontCareRdRnNotPc
                                 Usat_Rule_255_A1_P504
                                 cccc0110111iiiiiddddiiiiis01nnnn (v6)
| 000        011      ~1111    = Binary3RegisterImmedShiftedOpRegsNotPc
                                 => Defs12To15CondsDontCareRdRnNotPc
                                 Sxtab16_Rule_221_A1_P436
                                 cccc01101000nnnnddddrr000111mmmm
                                 NotRnIsPcAndRegsNotPc (v6)
| "          "        1111     = Unary2RegisterImmedShiftedOpRegsNotPc
                                 => Defs12To15CondsDontCareRdRnNotPc
                                 Sxtb16_Rule_224_A1_P442
                                 cccc011010001111ddddrr000111mmmm (v6)
| "          101      -        = Binary3RegisterOpAltB
                                 => Defs12To15CondsDontCareRnRdRmNotPc
                                 Sel_Rule_156_A1_P312
                                 cccc01101000nnnndddd11111011mmmm
                                 RegsNotPc (v6)
| 010        001      -        = Unary2RegisterSatImmedShiftedOp
                                 => Defs12To15CondsDontCareRdRnNotPc
                                 Ssat16_Rule_184_A1_P364
                                 cccc01101010iiiidddd11110011nnnn (v6)
| "          011      ~1111    = Binary3RegisterOpAltB
                                 => Defs12To15CondsDontCareRdRnNotPc
                                 Sxtab_Rule_220_A1_P434
                                 cccc01101010nnnnddddrr000111mmmm
                                 NotRnIsPcAndRegsNotPc (v6)
| "          "        1111     = Unary2RegisterImmedShiftedOpRegsNotPc
                                 => Defs12To15CondsDontCareRdRnNotPc
                                 Sxtb_Rule_223_A1_P440
                                 cccc011010101111ddddrr000111mmmm (v6)
| 011        001      -        = Unary2RegisterOpNotRmIsPcNoCondUpdates
                                 => Defs12To15CondsDontCareRdRnNotPc
                                 Rev_Rule_135_A1_P272
                                 cccc011010111111dddd11110011mmmm (v6)
| "          011      ~1111    = Binary3RegisterOpAltBNoCondUpdates
                                 => Defs12To15CondsDontCareRdRnNotPc
                                 Sxtah_Rule_222_A1_P438
                                 cccc01101011nnnnddddrr000111mmmm
                                 NotRnIsPc (v6)
| "          "        1111     = Unary2RegisterOpNotRmIsPcNoCondUpdates
                                 => Defs12To15CondsDontCareRdRnNotPc
                                 Sxth_Rule_225_A1_P444
                                 cccc011010111111ddddrr000111mmmm (v6)
| 011        101      -        = Unary2RegisterOpNotRmIsPcNoCondUpdates
                                 => Defs12To15CondsDontCareRdRnNotPc
                                 Rev16_Rule_136_A1_P274
                                 cccc011010111111dddd11111011mmmm (v6)
| 100        011      ~1111    = Binary3RegisterOpAltBNoCondUpdates
                                 => Defs12To15CondsDontCareRdRnNotPc
                                 Uxtah_Rule_262_A1_P516
                                 cccc01101100nnnnddddrr000111mmmm
                                 NotRnIsPc (v6)
| "          "        1111     = Unary2RegisterOpNotRmIsPc
                                 => Defs12To15CondsDontCareRdRnNotPc
                                 Uxtb16_Rule_264_A1_P522
                                 cccc011011001111ddddrr000111mmmm (v6)
| 110        001      -        = Unary2RegisterSatImmedShiftedOp
                                 => Defs12To15CondsDontCareRdRnNotPc
                                 Usat16_Rule_256_A1_P506
                                 cccc01101110iiiidddd11110011nnnn (v6)
| "          011      ~1111    = Binary3RegisterOpAltBNoCondUpdates
                                 => Defs12To15CondsDontCareRdRnNotPc
                                 Uxtab_Rule_260_A1_P514
                                 cccc01101110nnnnddddrr000111mmmm
                                 NotRnIsPc (v6)
| "          "        1111     = Unary2RegisterOpNotRmIsPc
                                 => Defs12To15CondsDontCareRdRnNotPc
                                 Uxtb_Rule_263_A1_P520
                                 cccc011011101111ddddrr000111mmmm (v6)
| 111        001      -        = Unary2RegisterOpNotRmIsPc
                                 => Defs12To15CondsDontCareRdRnNotPc
                                 Rbit_Rule_134_A1_P270
                                 cccc011011111111dddd11110011mmmm (v6T2)
| "          011      ~1111    = Binary3RegisterOpAltBNoCondUpdates
                                 => Defs12To15CondsDontCareRdRnNotPc
                                 Uxtah_Rule_262_A1_P518
                                 cccc01101111nnnnddddrr000111mmmm
                                 NotRnIsPc (v6)
| "          "        1111     = Unary2RegisterOpNotRmIsPc
                                 => Defs12To15CondsDontCareRdRnNotPc
                                 Uxth_Rule_265_A1_P524
                                 cccc011011111111ddddrr000111mmmm (v6)
| "          101      -        = Unary2RegisterOpNotRmIsPc
                                 => Defs12To15CondsDontCareRdRnNotPc
                                 Revsh_Rule_137_A1_P276
                                 cccc011011111111dddd11111011mmmm (v6)
| else:                        = Undefined  # Note on page A5-24
+--

+-- signed_multiply_signed_and_unsigned_divide (See Section A5.4.4)
| op1(22:20) op2(7:5) A(15:12)
                                 # Implements Smlad and Smladx, where
                                 # the x form is chosen if bit 5 is 1.
| 000        00x      ~1111    = Binary4RegisterDualOp
                                 => Defs16To19CondsDontCareRdRaRmRnNotPc
                                 Smlad_Rule_167_P332
                                 cccc01110000ddddaaaammmm00x1nnnn
                                 NotRaIsPcAndRegsNotPc (v6T2)
                                 # Implements Smuad and Smuadx, where
                                 # the x form is chosen if bit 5 is 1.
| "          "        1111     = Binary3RegisterOpAltA
                                 => Defs16To19CondsDontCareRdRmRnNotPc
                                 Smuad_Rule_177_P352
                                 cccc01110000dddd1111mmmm00x1nnnn
                                 RegsNotPc (v6T2)
                                 # Implements Smlsd and Smlsdx, where
                                 # the x form is chosen if bit 5 is 1.
                                 # Note: This rule has the constraint that
                                 # Ra!=1111, but we did not test it since
                                 # its checked by the pattern (column A)
                                 # for this instruction.
| "          01x      ~1111    = Binary4RegisterDualOp
                                 => Defs16To19CondsDontCareRdRaRmRnNotPc
                                 Smlsd_Rule_172_P342
                                 cccc01110000ddddaaaammmm01x1nnnn
                                 NotRaIsPcAndRegsNotPc (v6T2)
                                 # Implements Smusd and Smusdx, where
                                 # the x form is chosen if bit 5 is 1.
| "          "        1111     = Binary3RegisterOpAltA
                                 => Defs16To19CondsDontCareRdRmRnNotPc
                                 Smusd_Rule_181_P360
                                 cccc01110000dddd1111mmmm01x1nnnn
                                 RegsNotPc (v6T2)
# TODO(jfb) Some of the the v7 implementations can implement UDIV and SDIV,
#           see ARM ARM for details. Those look like:
# 001        000      -          SDIV
# 011        "        -          UDIV
                                 # Implements Smalad and Smaladx, where
                                 # the x form is chosen if bit 5 is 1.
| 100        00x      -        = Binary4RegisterDualResult
                                 => Defs12To19CondsDontCareRdRmRnNotPc
                                 Smlald_Rule_170_P336
                                 cccc01110100hhhhllllmmmm00x1nnnn
                                 RegsNotPc (v6T2)
                                 # Implements Smlsld and Smlsldx, where
                                 # the x form is chosen if bit 5 is 1.
| "          01x      -        = Binary4RegisterDualResult
                                 => Defs12To19CondsDontCareRdRmRnNotPc
                                 Smlsld_Rule_173_P344
                                 cccc01110100hhhhllllmmmm01x1nnnn
                                 RegsNotPc (v6T2)
                                 # Implements Smmla and Smmlar, where
                                 # the r form is chosen if bit 5 is 1.
                                 # Note: This rule has the constraint that
                                 # Ra!=1111, but we did not test it since
                                 # its checked by the pattern (column A)
                                 # for this instruction.
| 101        00x      ~1111    = Binary4RegisterDualOp
                                 => Defs16To19CondsDontCareRdRaRmRnNotPc
                                 Smmla_Rule_174_P346
                                 cccc01110101ddddaaaammmm00x1nnnn
                                 NotRaIsPcAndRegsNotPc (v6T2)
                                 # Implements Smmul and Smmulr, where
                                 # the r form is chosen if bit 5 is 1.
| "          "        1111     = Binary3RegisterOpAltA
                                 => Defs16To19CondsDontCareRdRmRnNotPc
                                 Smmul_Rule_176_P350
                                 cccc01110101dddd1111mmmm00x1nnnn
                                 RegsNotPc (v6T2)
                                 # Implements Smmls and Smmlsr, where
                                 # the r form is chosen if bit 5 is 1.
| "          11x      -        = Binary4RegisterDualOp
                                 => Defs16To19CondsDontCareRdRaRmRnNotPc
                                 Smmls_Rule_175_P348
                                 cccc01110101ddddaaaammmm11x1nnnn
                                 RegsNotPc (v6T2)
| else:                        = Undefined  # Note on page A5-26
+--

+-- branch_branch_with_link_and_block_data_transfer (See Section A5.5)
# TODO(karl): Clean up the actual classes once baseline has been committed.
| op(25:20) R(15)
| 0000x0    -     = StoreRegisterList
                    Stmda_Stmed_Rule_190_A1_P376
                    cccc100000w0nnnnrrrrrrrrrrrrrrrr
| 0000x1    -     = LoadRegisterList => LoadMultiple
                    Ldmda_Ldmfa_Rule_54_A1_P112
                    cccc100000w1nnnnrrrrrrrrrrrrrrrr
| 0010x0    -     = StoreRegisterList
                    Stm_Stmia_Stmea_Rule_189_A1_P374
                    cccc100010w0nnnnrrrrrrrrrrrrrrrr
# Note: When W=1 and Rn=Sp, the following instruction implements POP.
| 0010x1    -     = LoadRegisterList => LoadMultiple
                    Ldm_Ldmia_Ldmfd_Rule_53_A1_P110
                    cccc100010w1nnnnrrrrrrrrrrrrrrrr
# Note: When W=1 and Rn=Sp, the following instruction implements PUSH.
| 0100x0    -     = StoreRegisterList
                    Stmdb_Stmfd_Rule_191_A1_P378
                    cccc100100w0nnnnrrrrrrrrrrrrrrrr
| 0100x1    -     = LoadRegisterList => LoadMultiple
                    Ldmdb_Ldmea_Rule_55_A1_P114
                    cccc100100w1nnnnrrrrrrrrrrrrrrrr
| 0110x0    -     = StoreRegisterList
                    Stmid_Stmfa_Rule_192_A1_P380
                    cccc100110w0nnnnrrrrrrrrrrrrrrrr
| 0110x1    -     = LoadRegisterList => LoadMultiple
                    Ldmib_Ldmed_Rule_56_A1_P116
                    cccc100110w1nnnnrrrrrrrrrrrrrrrr
| 0xx1x0    -     = ForbiddenCondNop => Forbidden
                    Stm_Rule_11_B6_A1_P22 # ring0 version
                    cccc100pu100nnnnrrrrrrrrrrrrrrrr
| 0xx1x1    0     = ForbiddenCondNop => Forbidden
                    Ldm_Rule_3_B6_A1_P7   # ring0 version
                    cccc100pu101nnnn0rrrrrrrrrrrrrrr
| "         1     = ForbiddenCondNop => Forbidden
                    Ldm_Rule_2_B6_A1_P5   # exception return
                    cccc100pu1w1nnnn1rrrrrrrrrrrrrrr
| 10xxxx    -     = BranchImmediate24 => Branch
                    B_Rule_16_A1_P44
                    cccc1010iiiiiiiiiiiiiiiiiiiiiiii
| 11xxxx    -     = BranchImmediate24 => Branch
                    Bl_Blx_Rule_23_A1_P58
                    cccc1011iiiiiiiiiiiiiiiiiiiiiiii
+--

+-- coprocessor_instructions_and_supervisor_call (See Section A5.6)
# Note: We currently only allow floating point (and advanced SIMD) 
# coprocessor operations (coproc=101x).
# Note: Column op1 is repeated so that the first three rows can define
# (anded) multiple test conditions for this row.
| op1(25:20) op(4) coproc(11:8) Rn(19:16) op1_repeated(25:20) 
| 0xxxxx     -     101x         -         ~000x0x
                   -> extension_register_load_store_instructions
| 0xxxx0     -     ~101x           -      ~000x0x
                   # Note: Never safe since coproc!=101x
                   = Forbidden  # STC A8-372
| 0xxxx1     -     ~101x        ~1111      ~000x0x
                   # Note: Never safe since coproc!=101x
                   = Forbidden        # LDC(immediate), LDC2(immediate) A8-106
| "          "     "            1111       -
                   # Note: Never safe since coproc!=101x
                   = Forbidden        # LDC(literal), LDC2(literal) # A8-108
| 00000x     -     -            -          -
                   = Undefined        # see table, section A5.6
| 00010x     -     101x         -          -
                   -> transfer_between_arm_core_and_extension_registers_64_bit
| 000100     -     ~101x        -          -
                   # Note: Never safe since coproc!=101x
                   = Forbidden (v5TE) # MCRR, MCRR2 A8-188
| 000101     -     ~101x        -          -
                   # Note: Never safe since coproc!=101x
                   = Forbidden (v5TE) # MRRC, MRRC2 A8-204
| 10xxxx     0     101x         -          -
                   -> floating_point_data_processing_instructions
| "          "     ~101x        -          -
                   # Note: Never safe since coproc!=101x
                   = Forbidden        # CDP, CDP2 A8-68
| "          1     101x         -          -
                   -> transfer_between_arm_core_and_extension_register_8_16_and_32_bit
| "          "     ~101x        -          -
                   # Note: Never safe since coproc!=101x
                   = Forbidden        # MCR, MCR2 A8-186
| 10xxx1     1     ~101x        -          -
                   # Note: Never safe since coproc!=101x
                   = Forbidden        # MRC, MRC2
| 11xxxx     -     -            -          -
                   = Forbidden        # SVC (nee SWI) A8-430
+--

+-- floating_point_data_processing_instructions (A7.5 Table A7-16, page A7-24)
# Three register VPD data-processing, CDP instructions for
# coprocessors 10/11.
| opc1(23:20) opc3(7:6)
| 0x00        -         = CondVfpOp => VfpOp
                          Vm_la_ls_Rule_423_A2_P636
                          cccc11100d00nnnndddd101snpm0mmmm
| 0x01        -         = CondVfpOp => VfpOp
                          Vnm_la_ls_ul_Rule_343_A1_P674
                          cccc11100d01nnnndddd101snpm0mmmm
| 0x10        x1        = CondVfpOp => VfpOp
                          Vnm_la_ls_ul_Rule_343_A2_P674
                          cccc11100d10nnnndddd101sn1m0mmmm
| "           x0        = CondVfpOp => VfpOp
                          Vmul_Rule_338_A2_P664
                          cccc11100d10nnnndddd101sn0m0mmmm
| 0x11        x0        = CondVfpOp => VfpOp
                          Vadd_Rule_271_A2_P536
                          cccc11100d11nnnndddd101sn0m0mmmm
| "           x1        = CondVfpOp => VfpOp
                          Vsub_Rule_402_A2_P790
                          cccc11100d11nnnndddd101sn1m0mmmm
| 1x00        x0        = CondVfpOp => VfpOp
                          Vdiv_Rule_301_A1_P590
                          cccc11101d00nnnndddd101sn0m0mmmm
| 1x11        -         -> other_floating_point_data_processing_instructions
+--

+-- other_floating_point_data_processing_instructions (A7.5 Table A7-17, page 17-25)
# Other VPD data-processing, CDP instructions for coprocessors 10/11. 
#
# Note: Currently, all instructions use class CoprocessorOp
# to follow what the previous version of the ARM validator did.
#
# TODO(karl): Fix the class decoders to do the right thing.
| opc2(19:16) opc3(7:6)
| -           x0        = CondVfpOp => VfpOp
                          Vmov_Rule_326_A2_P640
                          cccc11101d11iiiidddd101s0000iiii
| 0000        01        = CondVfpOp => VfpOp
                          Vmov_Rule_327_A2_P642
                          cccc11101d110000dddd101s01m0mmmm
| "           11        = CondVfpOp => VfpOp
                          Vabs_Rule_269_A2_P532
| 0001        01        = CondVfpOp => VfpOp
                          Vneg_Rule_342_A2_P672
                          cccc11101d110001dddd101s01m0mmmm
| "           11        = CondVfpOp => VfpOp
                          Vsqrt_Rule_388_A1_P762
                          cccc11101d110001dddd101s11m0mmmm
| 001x        x1        = CondVfpOp => VfpOp
                          Vcvtb_Vcvtt_Rule_300_A1_P588
                          cccc11101d11001pdddd1010t1m0mmmm
| 0100        x1        = CondVfpOp => VfpOp
                          Vcmp_Vcmpe_Rule_292_A1_P572
                          cccc11101d110100dddd101se1m0mmmm
| 0101        x1        = CondVfpOp => VfpOp
                          Vcmp_Vcmpe_Rule_292_A2_P572
                          cccc11101d110101dddd101se1000000
| 0111        11        = CondVfpOp => VfpOp
                          Vcvt_Rule_298_A1_P584
                          cccc11101d110111dddd101s11m0mmmm
| 1000        x1        = CondVfpOp => VfpOp
                          Vcvt_Vcvtr_Rule_295_A1_P578
                          # Note: table pattern forces opc2(18:16)=000 for
                          # instruction. This table also contains entry for
                          # opc2(18:16)=10x, but not other opc2 values.
                          # However, rule A1 doesn't mention this
                          # restriction.
                          cccc11101d111000dddd101sp1m0mmmm
| 101x        x1        = CondVfpOp => VfpOp
                          Vcvt_Rule_297_A1_P582
                          cccc11101d11101udddd101fx1i0iiii
| 110x        x1        = CondVfpOp => VfpOp
                          Vcvt_Vcvtr_Rule_295_A1_P578
                          # Note: table pattern forces opc2(18:16)=10x for
                          # instruction. This table also contains entry for
                          # opc2(18:16)=000, but not other opc2 values.
                          # However, rule A1 doesn't mention this
                          # restriction.
                          cccc11101d11110xdddd101sp1m0mmmm
| 111x        x1        = CondVfpOp => VfpOp
                          Vcvt_Rule_297_A1_P582
                          cccc11101d11111udddd101fx1i0iiii
+--

+-- extension_register_load_store_instructions (A7.6)
# LDC and STC instructions for coprocessors 10/11.
#
# TODO(karl): Decide if baseline classes should also be actual classes, once
#             we finish fixing all uses of StoreCoprocessor and LoadCoprocessor.
#
# Note: The following instructions handles both A1 and A2 forms of the
# instruction, by matching coproc(11:8)=101x.
#
| opcode(24:20) Rn(19:16)
| 0010x         -         -> transfer_between_arm_core_and_extension_registers_64_bit
| 01x00         -         = StoreVectorRegisterList
                            Vstm_Rule_399_A1_A2_P784
                            cccc11001d00nnnndddd101xiiiiiiii
| 01x10         -         = StoreVectorRegisterList
                            Vstm_Rule_399_A1_A2_P784
                            cccc11001d10nnnndddd101xiiiiiiii
| 1xx00         -         = StoreVectorRegister
                            Vstr_Rule_400_A1_A2_P786
                            cccc1101ud00nnnndddd101xiiiiiiii
| 10x10         ~1101     = StoreVectorRegisterList
                            Vstm_Rule_399_A1_A2_P784
                            cccc11010d10nnnndddd101xiiiiiiii
                            NotRnIsSp
| "             1101      = StoreVectorRegisterList
                            Vpush_355_A1_A2_P696
                            cccc11010d101101dddd101xiiiiiiii
| 01x01         -         = LoadVectorRegisterList
                            Vldm_Rule_319_A1_A2_P626
                            cccc11001d01nnnndddd101xiiiiiiii
| 01x11         ~1101     = LoadVectorRegisterList
                            Vldm_Rule_319_A1_A2_P626
                            cccc11001d11nnnndddd101xiiiiiiii
                            NotRnIsSp
| "             1101      = LoadVectorRegisterList
                            Vpop_Rule_354_A1_A2_P694
                            cccc11001d111101dddd101xiiiiiiii
| 1xx01         -         = LoadVectorRegister
                            Vldr_Rule_320_A1_A2_P628
                            cccc1101ud01nnnndddd101xiiiiiiii
| 10x11         -         = LoadVectorRegisterList
                            Vldm_Rule_318_A1_A2_P626
                            cccc11010d11nnnndddd101xiiiiiiii
+--

+-- transfer_between_arm_core_and_extension_register_8_16_and_32_bit (A7.8 page A7-31)
# MRC and MCR instructions for coprocessors 10/11.
| L(20) C(8) A(23:21) B(6:5)
| 0     0    000      -      = MoveVfpRegisterOp
                             Vmov_Rule_330_A1_P648
                             cccc11100000nnnntttt1010n0010000
| "     "    111      -      = VfpUsesRegOp => DontCareInstRdNotPc
                             Vmsr_Rule_336_A1_P660
                             cccc111011100001tttt101000010000
| 0     1    0xx      -      = MoveVfpRegisterOpWithTypeSel
                             # Note: reserving bit 23 to zero does not introduce
                             # any special properties to the safety checks.
                             # Hence, using MoveVfpRegisterOpWithTypeSel
                             # is safe.
                             Vmov_Rule_328_A1_P644
                             cccc11100ii0ddddtttt1011dii10000
| "     "    1xx      0x     = DuplicateToVfpRegisters
                             Vdup_Rule_303_A1_P594
                             cccc11101bq0ddddtttt1011d0e10000
| 1     0    000      -      = MoveVfpRegisterOp
                             Vmov_Rule_330_A1_P648
                             cccc11100001nnnntttt1010n0010000
| "     "    111      -      = VfpMrsOp
                             Vmrs_Rule_335_A1_P658
                             cccc111011110001tttt101000010000
| "     1    xxx      -      = MoveVfpRegisterOpWithTypeSel
                             Vmov_Rule_329_A1_P646
                             cccc1110iii1nnnntttt1011nii10000
| else:                      = Undefined  # Note on page A7-31
+--

+-- transfer_between_arm_core_and_extension_registers_64_bit (A7.8 page A7-32)
# These are 64-bit MRRC and MCRR instructions for coprocessors 10/11.
| C(8) op(7:4)
| 0    00x1    # TODO(karl): Fix this to do the right thing.
               # VMOV A8-650
               = MoveDoubleFromCoprocessor
| 1    00x1    # TODO(karl): Fix this to do the right thing.
               # VMOV A8-652
               = MoveDoubleFromCoprocessor
+--

+-- unconditional_instructions (See Section A5.7)
# Note: We currently only allow floating point (and advanced SIMD) 
# coprocessor operations (coproc=101x).
#
# Note: Most instructions in this table are forbidden because they
# aren't specific to the Vfp coprocessors (10, 11).
| op1(27:20) op(4) Rn(19:16)
| 0xxx_xxxx  -     -         ->memory_hints_andvanced_simd_instructions_and_miscellaneous_instructions
# Note: These instructions are not allowed for any coprocessor.
| 100x_x1x0  -     -         = ForbiddenUncondNop # SRS B6-20
                             => Forbidden (v6)
| 100x_x0x1  -     -         = ForbiddenUncondNop # RFE B6-16
                             => Forbidden (v6)
# Note: The following version of blx is forbidden because it
# can allow branches to lables divisible by 2, which may be the
# middle of an ARM instruction.
| 101x_xxxx  -     -         = ForbiddenUncondNop => Forbidden
                             Blx_Rule_23_A2_P58
                             1111101hiiiiiiiiiiiiiiiiiiiiiiii
# The following are load/store instructions to corresponding coprocessor
# registers. These are (currently) forbidden, since Vfp (coprocessor 10, 11)
# have explicit instructions for loading/storing values
# into Vfp registers.
| 1100_0x11  -     ~1111     = ForbiddenUncondNop # LDC(immed),
                             => Forbidden (v5)    # LDC2(immed) A8-106
| 1100_1xx1  -     1111      = ForbiddenUncondNop # LDC(literal),
                             => Forbidden (v5)    # LDC2(literal) A8-108
| 1101_xxx1  -     1111      = ForbiddenUncondNop # LDC(literal),
                             => Forbidden (v5)    # LDC2(literal) A8-106
| 1100_0x10  -     -         = ForbiddenUncondNop # STC, STC2 A8-372
                             => Forbidden (v5)
| 1100_1xx0  -     -         "
| 1101_xxx0  -     -         "
| 1100_0100  -     -         = ForbiddenUncondNop # MCRR, MCRR2 A8-188
                             => Forbidden (v6)
| 1100_0101  -     -         = ForbiddenUncondNop # MRRC, MRRC2 A8-204
                             => Forbidden (v6)
| 1110_xxx0  1     -         = ForbiddenUncondNop # MCR, MCR2 A8-186
                             => Forbidden (v5)
| 1110_xxx1  1     -         = ForbiddenUncondNop # MRC, MRC2 A8-202
                             => Forbidden (v5)
# The following applies a coprocessor operation, which we currently
# only allow for coprocessors 10 and 11.
| 1110_xxxx  0     -         = CoprocessorOp (v5) # CDP, CDP2 A8-68
| else:                      = Undefined          # Note on page A5-30
+--

+-- memory_hints_andvanced_simd_instructions_and_miscellaneous_instructions (See Section A5.7.1)
| op1(26:20) op2(7:4) Rn(19:16)
| 001_0000   xx0x     xxx0      =Forbidden  # CPS
| 001_0000   0000     xxx1      =Forbidden  # SETEND
| 01x_xxxx   -        -         ->advanced_simd_data_processing_instructions
| 100_xxx0   -        -         ->advanced_simd_element_or_structure_load_store_instructions
| 100_x001   -        -         =EffectiveNoOp(MP)    # Unallocated memory hint
| 100_x101   -        -         =EffectiveNoOp(v7)    # PLI(immediate, literal)
| 101_x001   -        ~1111     =EffectiveNoOp(MP)    # PLDW(immediate)
| "          -        1111      =Unpredictable
| 101_x101   -        ~1111     =EffectiveNoOp(v5TE)  # PLD(immediate)
| 101_x101   -        1111      =EffectiveNoOp(v5TE)  # PLD(literal)
| 101_0111   0001     -         =EffectiveNoOp(v6K)   # CLREX
| "          0100     -         =EffectiveNoOp(v6T2)  # DSB
| "          0101     -         =EffectiveNoOp(v7)    # DMB
| "          0110     -         =EffectiveNoOp(v6T2)  # ISB
| 10x_xx11   -        -         =Unpredictable
| 110_x001   xxx0     -         =EffectiveNoOp(MP)    # Unallocated memory hint
| 110_x101   xxx0     -         =EffectiveNoOp(v7)    # PLI(register)
| 111_x001   xxx0     -         =EffectiveNoOp(MP)    # PLDW(register)
| 111_x101   xxx0     -         =EffectiveNoOp(v5TE)  # PLD(register)
| 11x_xx11   xxx0     -         =Unpredictable
| else:                         =Undefined   # Note on page A5-31
+--

+-- advanced_simd_data_processing_instructions (See Section A7.4)
| U(24) A(23:19) B(11:8) C(7:4)
| -     0xxxx    -       -      -> simd_dp_3same
| "     1x000    -       0xx1   -> simd_dp_1imm
| "     1x001    -       0xx1   -> simd_dp_2shift
| "     1x01x    -       0xx1   "
| "     1x1xx    -       0xx1   "
| "     1xxxx    -       1xx1   "
| "     1x0xx    -       x0x0   -> simd_dp_3diff
| "     1x10x    -       x0x0   "
| "     1x0xx    -       x1x0   -> simd_dp_2scalar
| "     1x10x    -       x1x0   "
| 0     1x11x    -       xxx0   = VectorBinary3RegisterImmOp
                                  Vext_Rule_305_A1_P598
                                  111100101d11nnnnddddiiiinqm0mmmm
| 1     1x11x    0xxx    xxx0   -> simd_dp_2misc
| "     "        10xx    xxx0   = VectorBinary3RegisterLookupOp
                                  Vtbl_Vtbx_Rule_406_A1_P798
                                  111100111d11nnnndddd10ccnpm0mmmm
| "     "        1100    0xx0   = VectorUnary2RegisterDup
                                  Vdup_Rule_302_A1_P592
                                  111100111d11iiiidddd11000qm0mmmm
| else:                         = Undefined  # Note on page A7-10
+--

+-- simd_dp_3same (See Section A7.4.1)
# This table is much larger than it needs to be, since we don't model these
# ops (they work entirely in a separate register set, and cannot access memory).
# Unfortunately there are some UNDEFINED holes here, so we have to be precise.
| A(11:8) B(4) U(24) C(21:20)
| 0000    0    -     -        =EffectiveNoOp  # VHADD
| "       1    -     -        =EffectiveNoOp  # VQADD
| 0001    0    -     -        =EffectiveNoOp  # VRHADD
| "       1    0     00       =EffectiveNoOp  # VAND(register)
| "       "    "     01       =EffectiveNoOp  # VBIC(register)
| "       "    "     10       =EffectiveNoOp  # VORR(register)
| "       "    "     11       =EffectiveNoOp  # VORN(register)
| "       1    1     00       =EffectiveNoOp  # VEOR(register)
| "       "    "     01       =EffectiveNoOp  # VBSL
| "       "    "     10       =EffectiveNoOp  # VBIT
| "       "    "     11       =EffectiveNoOp  # VBIF
| 0010    0    -     -        =EffectiveNoOp  # VHSUB
| "       1    -     -        =EffectiveNoOp  # VQSUB
| 0011    0    -     -        =EffectiveNoOp  # VCGT(register)
| "       1    -     -        =EffectiveNoOp  # VCGE(register)
| 0100    0    -     -        =EffectiveNoOp  # VSHL(register)
| "       1    -     -        =EffectiveNoOp  # VQSHL(register)
| 0101    0    -     -        =EffectiveNoOp  # VRSHL(register)
| "       1    -     -        =EffectiveNoOp  # VQRSHL(register)
| 0110    -    -     -        =EffectiveNoOp  # VMAX, VMIN (integer)
| 0111    0    -     -        =EffectiveNoOp  # VABD, VABDL (integer)
| "       1    -     -        =EffectiveNoOp  # VABA, VABAL
| 1000    0    0     -        =EffectiveNoOp  # VADD(integer)
| "       "    1     -        =EffectiveNoOp  # VSUB(integer)
| "       1    0     -        =EffectiveNoOp  # VTST(integer)
| "       "    1     -        =EffectiveNoOp  # VCEQ(integer)
| 1001    0    -     -        =EffectiveNoOp  # VMLA, VMLAL, VMLS,
                                              # VMLSL (integer)
| "       1    -     -        =EffectiveNoOp  # VMUL, VMULL(integer/poly)
| 1010    -    -     -        =EffectiveNoOp  # VPMAX, VPMIN(integer)
| 1011    0    0     -        =EffectiveNoOp  # VQDMULH
| "       "    1     -        =EffectiveNoOp  # VQRDMULH
| "       1    0     -        =EffectiveNoOp  # VPADD(integer)
| 1101    0    0     0x       =EffectiveNoOp  # VADD(float)
| "       "    "     1x       =EffectiveNoOp  # VSUB(float)
| "       "    1     0x       =EffectiveNoOp  # VPADD(float)
| "       "    "     1x       =EffectiveNoOp  # VABD(float)
| "       1    0     -        =EffectiveNoOp  # VMLA, VMLS(float)
| "       "    1     0x       =EffectiveNoOp  # VMUL(float)
| 1110    0    0     0x       =EffectiveNoOp  # VCEQ(register)
| "       "    1     0x       =EffectiveNoOp  # VCGE(register)
| "       "    "     1x       =EffectiveNoOp  # VCGT(register)
| "       1    1     -        =EffectiveNoOp  # VACGE, VACGT, VACLE, VACLT
| 1111    0    0     -        =EffectiveNoOp  # VMAX, VMIN(float)
| "       "    1     -        =EffectiveNoOp  # VPMAX, VPMIN(float)
| "       1    0     0x       =EffectiveNoOp  # VRECPS
| "       "    0     1x       =EffectiveNoOp  # VRSQRTS
| else:                       =Undefined  # Note on page A7-12
+--

+-- simd_dp_3diff (See Section A7.4.2)
| A(11:8) U(24)
| 000x    -     =EffectiveNoOp  # VADDL
| 001x    -     =EffectiveNoOp  # VSUBL
| 0100    0     =EffectiveNoOp  # VADDHN
| "       1     =EffectiveNoOp  # VRADDHN
| 0101    -     =EffectiveNoOp  # VABA, VABAL
| 0110    0     =EffectiveNoOp  # VSUBHN
| "       1     =EffectiveNoOp  # VRSUBHN
| 0111    -     =EffectiveNoOp  # VABD, VABDL(integer)
| 10x0    -     =EffectiveNoOp  # VMLA, VMLAL, VMLS, VMLSL (integer)
| 10x1    0     =EffectiveNoOp  # VQDMLAL, VQDMLSL
| 1100    -     =EffectiveNoOp  # VMUL, VMULL (integer)
| 1101    0     =EffectiveNoOp  # VQDMULL
| 1110    -     =EffectiveNoOp  # VMUL, VMULL (polynomial)
| else:         =Undefined  # Note on page A7-15
+--

+-- simd_dp_2scalar (See Section A7.4.3)
| A(11:8) U(24)
| 0x0x    -     =EffectiveNoOp  # VMLA, VMLS (scalar)
| 0x10    -     =EffectiveNoOp  # VMLAL, VMLSL (scalar)
| 0x11    0     =EffectiveNoOp  # VQDMLAL, VMQDLSL
| 100x    -     =EffectiveNoOp  # VMUL(scalar)
| 1010    -     =EffectiveNoOp  # VMULL(scalar)
| 1011    0     =EffectiveNoOp  # VQDMULL
| 1100    -     =EffectiveNoOp  # VQDMULH
| 1101    -     =EffectiveNoOp  # VQRDMULH
| else:         =Undefined  # Note on page A7-16
+--

+-- simd_dp_2shift (See Section A7.4.4)
| A(11:8) U(24) B(6) L(7)
| 0000    -     -    -    =EffectiveNoOp  # VSHR
| 0001    -     -    -    =EffectiveNoOp  # VSRA
| 0010    -     -    -    =EffectiveNoOp  # VRSHR
| 0011    -     -    -    =EffectiveNoOp  # VRSRA
| 0100    1     -    -    =EffectiveNoOp  # VSRI
| 0101    0     -    -    =EffectiveNoOp  # VSHL(immediate)
| 0101    1     -    -    =EffectiveNoOp  # VSLI
| 011x    -     -    -    =EffectiveNoOp  # VQSHL, VQSHLU(immediate)
| 1000    0     0    0    =EffectiveNoOp  # VSHRN
| "       "     1    -    =EffectiveNoOp  # VRSHRN
| "       1     0    -    =EffectiveNoOp  # VQSHRUN
| "       "     1    -    =EffectiveNoOp  # VQRSHRUN
| 1001    -     0    -    =EffectiveNoOp  # VQSHRN
| "       -     1    -    =EffectiveNoOp  # VQRSHRN
| 1010    -     0    -    =EffectiveNoOp  # VSHLL, VMOVL
| 111x    -     -    -    =EffectiveNoOp  # VCVT (floating- and fixed-point)
| else:                   =Undefined  # Note on page A7-17
+--

+-- simd_dp_2misc (See Section A7.4.5)
| A(17:16) B(10:6)
| 00       0000x   =EffectiveNoOp  # VREV64
| "        0001x   =EffectiveNoOp  # VREV32
| "        0010x   =EffectiveNoOp  # VREV16
| "        010xx   =EffectiveNoOp  # VPADDL
| "        1000x   =EffectiveNoOp  # VCLS
| "        1001x   =EffectiveNoOp  # VCLZ
| "        1010x   =EffectiveNoOp  # VCNT
| "        1011x   =EffectiveNoOp  # VMVN(register)
| "        110xx   =EffectiveNoOp  # VPADAL
| "        1110x   =EffectiveNoOp  # VQABS
| "        1111x   =EffectiveNoOp  # VQNEG
| 01       x000x   =EffectiveNoOp  # VCGT (immediate #0)
| "        x001x   =EffectiveNoOp  # VCGE (immediate #0)
| "        x010x   =EffectiveNoOp  # VCEQ (immediate #0)
| "        x011x   =EffectiveNoOp  # VCLE (immediate #0)
| "        x100x   =EffectiveNoOp  # VCLT (immediate #0)
| "        x110x   =EffectiveNoOp  # VABS
| "        x111x   =EffectiveNoOp  # VNEG
| 10       0000x   =EffectiveNoOp  # VSWP
| "        0001x   =EffectiveNoOp  # VTRN
| "        0010x   =EffectiveNoOp  # VUZP
| "        0011x   =EffectiveNoOp  # VZIP
| "        01000   =EffectiveNoOp  # VMOVN
| "        01001   =EffectiveNoOp  # VQMOVUN
| "        0101x   =EffectiveNoOp  # VQMOVN
| "        01100   =EffectiveNoOp  # VSHLL
| "        11x00   =EffectiveNoOp  # VCVT (half- and single-precision)
| 11       10x0x   =EffectiveNoOp  # VRECPE
| "        10x1x   =EffectiveNoOp  # VRSQRTE
| "        11xxx   =EffectiveNoOp  # VCVT (float and integer)
| else:            =Undefined  # Note on page A7-19
+--

+-- simd_dp_1imm (See Section A7.4.6)
| op(5) cmode(11:8)
| 0     0xx0        =EffectiveNoOp  # VMOV(immediate)
| "     0xx1        =EffectiveNoOp  # VORR(immediate)
| "     10x0        =EffectiveNoOp  # VMOV(immediate)
| "     10x1        =EffectiveNoOp  # VORR(immediate)
| "     11xx        =EffectiveNoOp  # VMOV(immediate)
| 1     0xx0        =EffectiveNoOp  # VMVN(immediate)
| "     0xx1        =EffectiveNoOp  # VBIC(immediate)
| "     10x0        =EffectiveNoOp  # VMVN(immediate)
| "     10x1        =EffectiveNoOp  # VBIC(immediate)
| "     110x        =EffectiveNoOp  # VMVN(immediate)
| "     1110        =EffectiveNoOp  # VMOV(immediate)
| "     1111        =Undefined
+--

+-- advanced_simd_element_or_structure_load_store_instructions (See Section A7.7)
# This "table" is the first paragraph in A7.7.
| L(21)
| 0    ->simd_load_store_l0
| 1    ->simd_load_store_l1
+--

+-- simd_load_store_l0 (See Section A7.7, Table A7-20)
| A(23) B(11:8)
| 0     0010    =VectorStore  # VST1(multiple)
| "     011x    "
| "     1010    "
| "     0011    =VectorStore  # VST2(multiple)
| "     100x    "
| "     010x    =VectorStore  # VST3(multiple)
| "     000x    =VectorStore  # VST4(multiple)
| 1     0x00    =VectorStore  # VST1(single)
| "     1000    "
| "     0x01    =VectorStore  # VST2(single)
| "     1001    "
| "     0x10    =VectorStore  # VST3(single)
| "     1010    "
| "     0x11    =VectorStore  # VST4(single)
| "     1011    "
| else:         =Undefined    # Note on page A7-27
+--

+-- simd_load_store_l1 (See Section A7.7, Table A7-21)
| A(23) B(11:8)
| 0     0010    =VectorLoad  # VLD1(multiple)
| "     011x    "
| "     1010    "
| "     0011    =VectorLoad  # VLD2(multiple)
| "     100x    "
| "     010x    =VectorLoad  # VLD3(multiple)
| "     000x    =VectorLoad  # VLD4(multiple)
| 1     0x00    =VectorLoad  # VLD1(single)
| "     1000    "
| "     1100    =VectorLoad  # VLD1(single, all lanes)
| "     0x01    =VectorLoad  # VLD2(single)
| "     1001    "
| "     1101    =VectorLoad  # VLD2(single, all lanes)
| "     0x10    =VectorLoad  # VLD3(single)
| "     1010    "
| "     1110    =VectorLoad  # VLD3(single, all lanes)
| "     0x11    =VectorLoad  # VLD4(single)
| "     1011    "
| "     1111    =VectorLoad  # VLD4(single, all lanes)
| else:         =Undefined   # Note on page A7-27
+--
