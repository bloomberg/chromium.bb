// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file provides common functionality for different configurations of test
// extensions using the chrome.certificateProvider API.

'use strict';

const assertEq = chrome.test.assertEq;
const assertTrue = chrome.test.assertTrue;
const callbackPass = chrome.test.callbackPass;

// X.509 certificate in DER encoding issued by 'root.pem' which is set to be
// trusted by the test setup.
// Read from 'l1_leaf.der', generated by create_test_certs.sh .
let l1LeafCert = null;
const INVALID_CERT = new Uint8Array([1, 2, 3, 4, 5]);

function registerAsCertificateProvider() {
  function reportCertificates(request) {
    assertTrue(Number.isInteger(request.certificatesRequestId));
    const validCert = {
      certificateChain: [l1LeafCert.buffer],
      supportedAlgorithms: ['RSASSA_PKCS1_v1_5_SHA1']
    };
    const invalidCertBadDer = {
      certificateChain: [INVALID_CERT.buffer],
      supportedAlgorithms: ['RSASSA_PKCS1_v1_5_SHA256']
    };
    const invalidCertEmpty = {
      certificateChain: [],
      supportedAlgorithms: ['RSASSA_PKCS1_v1_5_SHA256']
    };
    const invalidCertNoAlgorithms = {
      certificateChain: [l1LeafCert.buffer],
      supportedAlgorithms: []
    };
    chrome.certificateProvider.setCertificates(
        {
          certificatesRequestId: request.certificatesRequestId,
          clientCertificates: [
            validCert, invalidCertBadDer, invalidCertEmpty,
            invalidCertNoAlgorithms
          ]
        },
        () => {
          chrome.test.succeed();
        });
  }

  chrome.certificateProvider.onCertificatesUpdateRequested.addListener(
      reportCertificates);
}

function registerAsLegacyCertificateProvider() {
  function checkResult(rejectedCerts) {
    assertEq(1, rejectedCerts.length);
    assertEq(INVALID_CERT, new Uint8Array(rejectedCerts[0]));
  }

  function reportCertificates(reportCallback) {
    const validCertInfo = {
      certificate: l1LeafCert.buffer,
      supportedHashes: ['SHA1']
    };
    const invalidCertInfo = {
      certificate: INVALID_CERT.buffer,
      supportedHashes: ['SHA256']
    };
    reportCallback([validCertInfo, invalidCertInfo], callbackPass(checkResult));
  }

  chrome.certificateProvider.onCertificatesRequested.addListener(
      callbackPass(reportCertificates));
}

// Use setCertificates to let the extension proactively provide certificates.
// This can be combined with registerAsCertificateProvider(), but can also be
// used on its own.
function setCertificates() {
  const validCert = {
    certificateChain: [l1LeafCert.buffer],
    supportedAlgorithms: ['RSASSA_PKCS1_v1_5_SHA1']
  };
  const invalidCertBadDer = {
    certificateChain: [INVALID_CERT.buffer],
    supportedAlgorithms: ['RSASSA_PKCS1_v1_5_SHA256']
  };
  const invalidCertEmpty = {
    certificateChain: [],
    supportedAlgorithms: ['RSASSA_PKCS1_v1_5_SHA256']
  };
  const invalidCertNoAlgorithms = {
    certificateChain: [l1LeafCert.buffer],
    supportedAlgorithms: []
  };
  chrome.certificateProvider.setCertificates(
      {
        clientCertificates: [
          validCert, invalidCertBadDer, invalidCertEmpty,
          invalidCertNoAlgorithms
        ]
      },
      () => {
        const success = !chrome.runtime.lastError;
        domAutomationController.send(success);
      });
}

// Indicates that there are no certificates available.
function unsetCertificates() {
  chrome.certificateProvider.setCertificates({clientCertificates: []}, () => {
    const success = !chrome.runtime.lastError;
    domAutomationController.send(success);
  });
}

let signatureRequestData;
let signatureCallback;

function registerForSignatureRequests() {
  chrome.certificateProvider.onSignatureRequested.addListener(function(
      request) {
    assertTrue(Number.isInteger(request.signRequestId));
    assertEq(l1LeafCert.buffer, request.certificate);
    // The sign request must refer to the only algorithm that was declared to be
    // supported.
    assertEq('RSASSA_PKCS1_v1_5_SHA1', request.algorithm);
    signatureCallback = (signature) => {
      chrome.certificateProvider.reportSignature(
          {signRequestId: request.signRequestId, signature: signature});
    };
    signatureRequestData = request.input;
    chrome.test.sendMessage('signature request received');
  });
}

function registerForLegacySignatureRequests() {
  chrome.certificateProvider.onSignDigestRequested.addListener(function(
      request, callback) {
    assertEq(l1LeafCert.buffer, request.certificate);
    // The sign request must refer to the only hash that was declared to be
    // supported.
    assertEq('SHA1', request.hash);
    signatureCallback = callback;
    signatureRequestData = request.digest;
    chrome.test.sendMessage('signature request received');
  });
}

function replyWithSignature(signature) {
  signatureCallback(signature.buffer);
}

function replyWithSignatureSecondTime() {
  const signature = new Uint8Array([1, 2, 3]);
  try {
    signatureCallback(signature.buffer);
  } catch (e) {
    domAutomationController.send(false);
    return false;
  }
  domAutomationController.send(true);
  return true;
}

// initialize is called from the cpp test.
// |cert| is the certificate data in an Uint8Array.
function initialize(cert) {
  l1LeafCert = cert;
}
