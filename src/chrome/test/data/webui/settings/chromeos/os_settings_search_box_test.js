// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import {OpenWindowProxyImpl, Router, routes, setPersonalizationSearchHandlerForTesting, setSettingsSearchHandlerForTesting, setUserActionRecorderForTesting} from 'chrome://os-settings/chromeos/os_settings.js';
import {loadTimeData} from 'chrome://resources/js/load_time_data.m.js';
import {flush} from 'chrome://resources/polymer/v3_0/polymer/polymer_bundled.min.js';
import {eventToPromise} from 'chrome://test/test_util.js';

import {assertDeepEquals, assertEquals, assertFalse, assertNotEquals, assertTrue} from '../../chai_assert.js';
import {TestBrowserProxy} from '../../test_browser_proxy.js';

import {FakePersonalizationSearchHandler} from './fake_personalization_search_handler.js';
import {FakeSettingsSearchHandler} from './fake_settings_search_handler.js';
import {FakeUserActionRecorder} from './fake_user_action_recorder.js';

/** @fileoverview Runs tests for the OS settings search box. */

/**
 * @implements {OpenWindowProxy}
 */
class TestOpenWindowProxy extends TestBrowserProxy {
  constructor() {
    super([
      'openURL',
    ]);
  }

  /** @override */
  openURL(url) {
    this.methodCalled('openURL', url);
  }
}

suite('OSSettingsSearchBox', () => {
  // TODO(hsuregan): Keep count and add getters for metrics.
  class MockMetricsPrivate {
    recordEnumerationValue(metricName, value, enumSize) {}

    recordSparseValue(metricName, value) {}

    recordTime(metricName, value) {}

    // Required to use recordSparsValue()
    recordSparseHashable(metricName, value) {}
  }

  /** @const {number} */
  const DEFAULT_RELEVANCE_SCORE = 0.5;

  /** @const {!Array<mojoBase.mojom.String16>} */
  const DEFAULT_PAGE_HIERARCHY = [];

  /** @type {?OsToolbar} */
  let toolbar;

  /** @type {?OsSettingsSearchBox} */
  let searchBox;

  /** @type {?CrSearchFieldElement} */
  let field;

  /** @type {?IronDropdownElement} */
  let dropDown;

  /** @type {?IronListElement} */
  let resultList;

  /** @type {FakePersonalizationSearchHandler} */
  let personalizationSearchHandler;

  /** @type {*} */
  let settingsSearchHandler;

  /** @type {?chromeos.settings.mojom.UserActionRecorderInterface} */
  let userActionRecorder;

  /** @type {?HTMLElement} */
  let noResultsSection;

  /** @type {?TestOpenWindowProxy} */
  let openWindowProxy = null;

  function isTextSelected() {
    const input = field.$.searchInput;
    return input.selectionStart === 0 &&
        input.selectionEnd === input.value.length;
  }

  /** @param {string} term */
  async function simulateSearch(term) {
    field.$.searchInput.value = term;
    field.onSearchTermInput();
    field.onSearchTermSearch();
    if (term) {
      // search-results-fetched only fires on a non-empty search term.
      await waitForResultsFetched();
    }
    flush();
  }

  async function waitForListUpdate() {
    // Wait for iron-list to complete resizing.
    await eventToPromise('iron-resize', resultList);
    flush();
  }

  async function waitForResultsFetched() {
    // Wait for search results to be fetched.
    await eventToPromise('search-results-fetched', searchBox);
    flush();
  }

  /**
   * @param {string} text Exact string of the result to be displayed.
   * @param {string} path Url path with optional params.
   * @param {?chromeos.settings.mojom.SearchResultIcon} icon Result icon enum.
   * @param {?Boolean} wasGeneratedFromTextMatch If result was generated by
   *     text match, defaults to true.
   * @param {?number} relevanceScore the score of this search result, defaults
   *     to |DEFAULT_RELEVANCE_SCORE|
   * @return {!chromeos.settings.mojom.SearchResult} A search result.
   */
  function fakeSettingsResult(
      text, urlPathWithParameters, icon, wasGeneratedFromTextMatch,
      relevanceScore) {
    return /** @type {!mojom.SearchResult} */ ({
      text: {
        data: Array.from(text, c => c.charCodeAt()),
      },
      canonicalText: {
        data: Array.from(text, c => c.charCodeAt()),
      },
      urlPathWithParameters: urlPathWithParameters,
      icon: icon ? icon : chromeos.settings.mojom.SearchResultIcon.MIN_VALUE,
      wasGeneratedFromTextMatch: wasGeneratedFromTextMatch === undefined ?
          true :
          wasGeneratedFromTextMatch,
      id: {
        section: chromeos.settings.mojom.Section.MIN_VALUE,
        subpage: chromeos.settings.mojom.Subpage.MIN_VALUE,
        setting: chromeos.settings.mojom.Setting.MIN_VALUE,
      },
      type: chromeos.settings.mojom.SearchResultType.MIN_VALUE,
      relevanceScore: typeof relevanceScore === 'number' ?
          relevanceScore :
          DEFAULT_RELEVANCE_SCORE,
      settingsPageHierarchy: DEFAULT_PAGE_HIERARCHY,
    });
  }

  /**
   * @param {string} text
   * @param {string} relativeUrl
   * @param {number} relevanceScore
   * @return {!ash.personalizationApp.mojom.SearchResult}
   */
  function fakePersonalizationResult(
      text, relativeUrl = '', relevanceScore = DEFAULT_RELEVANCE_SCORE) {
    return /** @type {!ash.personalizationApp.mojom.SearchResult} */ ({
      searchConceptId: ash.personalizationApp.mojom.SearchConceptId.MIN_VALUE,
      text: {
        data: Array.from(text, c => c.charCodeAt()),
      },
      relativeUrl,
      relevanceScore,
    });
  }

  function setupSearchBox() {
    chrome.metricsPrivate = new MockMetricsPrivate();

    personalizationSearchHandler = new FakePersonalizationSearchHandler();
    setPersonalizationSearchHandlerForTesting(personalizationSearchHandler);

    settingsSearchHandler = new FakeSettingsSearchHandler();
    setSettingsSearchHandlerForTesting(settingsSearchHandler);

    userActionRecorder = new FakeUserActionRecorder();
    setUserActionRecorderForTesting(userActionRecorder);

    toolbar = document.createElement('os-toolbar');
    assertTrue(!!toolbar);
    document.body.appendChild(toolbar);
    flush();

    searchBox = toolbar.$$('os-settings-search-box');
    assertTrue(!!searchBox);
    field = searchBox.$$('cr-toolbar-search-field');
    assertTrue(!!field);
    dropDown = searchBox.$$('iron-dropdown');
    assertTrue(!!dropDown);
    resultList = searchBox.$$('iron-list');
    assertTrue(!!resultList);
    noResultsSection = searchBox.$$('#noSearchResultsContainer');
    assertTrue(!!noResultsSection);
  }

  setup(function() {
    loadTimeData.overrideValues({isPersonalizationHubEnabled: true});
    setupSearchBox();
    Router.getInstance().navigateTo(routes.BASIC);

    openWindowProxy = new TestOpenWindowProxy();
    OpenWindowProxyImpl.setInstance(openWindowProxy);
  });

  teardown(async () => {
    // Clear search field for next test.
    await simulateSearch('');
    setPersonalizationSearchHandlerForTesting(null);
    setSettingsSearchHandlerForTesting(null);
    setUserActionRecorderForTesting(null);
  });

  test('Search availability changed', async () => {
    settingsSearchHandler.setFakeResults([fakeSettingsResult('result')]);
    await simulateSearch('test query');
    assertTrue(dropDown.opened);
    assertEquals(searchBox.searchResults_.length, 1);

    settingsSearchHandler.setFakeResults(
        [fakeSettingsResult('1'), fakeSettingsResult('2')]);
    assertTrue(dropDown.opened);
    assertEquals(searchBox.searchResults_.length, 1);

    // Check that the list updates when the dropdown is open, and the dropdown
    // remains open.
    settingsSearchHandler.simulateSearchResultsChanged();
    await waitForResultsFetched();
    assertTrue(dropDown.opened);
    assertEquals(searchBox.searchResults_.length, 2);

    // Personalization search results should also result in a new search.
    personalizationSearchHandler.setFakeResults(
        [fakePersonalizationResult('personalization')]);
    assertTrue(dropDown.opened);
    assertEquals(searchBox.searchResults_.length, 2);

    personalizationSearchHandler.simulateSearchResultsChanged();
    await waitForResultsFetched();
    assertTrue(dropDown.opened);
    assertEquals(searchBox.searchResults_.length, 3);

    // User clicks outside the search box, closing the dropdown.
    searchBox.blur();
    assertFalse(dropDown.opened);

    settingsSearchHandler.setFakeResults([fakeSettingsResult('result')]);
    assertFalse(dropDown.opened);
    assertEquals(searchBox.searchResults_.length, 3);

    // Check that the list updates when the dropdown is closed, and the dropdown
    // remains closed.
    settingsSearchHandler.simulateSearchResultsChanged();
    await waitForResultsFetched();
    assertFalse(dropDown.opened);
    assertEquals(searchBox.searchResults_.length, 2);

    // The first item should be selected immediately when the search results
    // change even if the change occurred while the dropdown was closed.
    field.$.searchInput.focus();
    await waitForListUpdate();
    assertTrue(dropDown.opened);
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().searchResult.resultText,
        searchBox.selectedItem_.resultText);
  });

  test('User action search event', async () => {
    settingsSearchHandler.setFakeResults([]);

    assertEquals(userActionRecorder.searchCount, 0);
    await simulateSearch('query');
    assertEquals(userActionRecorder.searchCount, 1);
  });

  test(
      'Clicking magnifying glass shows dropdown and selects all text',
      async () => {
        settingsSearchHandler.setFakeResults([fakeSettingsResult('a')]);
        await simulateSearch('query');
        await waitForListUpdate();
        assertTrue(dropDown.opened);
        searchBox.blur();

        assertFalse(dropDown.opened);
        assertFalse(isTextSelected());

        field.$.icon.click();
        assertTrue(isTextSelected());
        assertTrue(dropDown.opened);
      });

  test('Dropdown opens correctly when results are fetched', async () => {
    // Show no results in dropdown if no results are returned.
    settingsSearchHandler.setFakeResults([]);
    personalizationSearchHandler.setFakeResults([]);
    assertFalse(dropDown.opened);
    await simulateSearch('query 1');
    assertTrue(dropDown.opened);
    assertEquals(searchBox.searchResults_.length, 0);
    assertFalse(noResultsSection.hidden);

    assertEquals(userActionRecorder.searchCount, 1);

    // Show result list if results are returned, and hide no results div.
    settingsSearchHandler.setFakeResults([fakeSettingsResult('result')]);
    personalizationSearchHandler.setFakeResults([]);
    await simulateSearch('query 2');
    assertNotEquals(searchBox.searchResults_.length, 0);
    assertTrue(noResultsSection.hidden);

    // Show result list if personalization search results are returned, and hide
    // no results div.
    settingsSearchHandler.setFakeResults([]);
    personalizationSearchHandler.setFakeResults(
        [fakePersonalizationResult('personalization')]);
    await simulateSearch('query 3');
    assertNotEquals(searchBox.searchResults_.length, 0);
    assertTrue(noResultsSection.hidden);
  });

  test('Restore previous existing search results', async () => {
    settingsSearchHandler.setFakeResults([fakeSettingsResult('result 1')]);
    personalizationSearchHandler.setFakeResults(
        [fakePersonalizationResult('personalization')]);
    await simulateSearch('query');
    assertTrue(dropDown.opened);
    assertEquals(2, resultList.items.length);
    const [firstResult, secondResult] = resultList.items;

    // Child blur elements except field should not trigger closing of dropdown.
    resultList.blur();
    assertTrue(dropDown.opened);
    dropDown.blur();
    assertTrue(dropDown.opened);

    // User clicks outside the search box, closing the dropdown.
    searchBox.blur();
    assertFalse(dropDown.opened);

    // User clicks on input, restoring old results and opening dropdown.
    field.$.searchInput.focus();
    assertEquals('query', field.$.searchInput.value);
    assertTrue(dropDown.opened);

    // The same result rows exist.
    assertEquals(firstResult, resultList.items[0]);
    assertEquals(secondResult, resultList.items[1]);

    // Search field is blurred, closing the dropdown.
    field.$.searchInput.blur();
    assertFalse(dropDown.opened);

    // User clicks on input, restoring old results and opening dropdown.
    field.$.searchInput.focus();
    assertEquals('query', field.$.searchInput.value);
    assertTrue(dropDown.opened);

    // The same result rows exist.
    assertEquals(firstResult, resultList.items[0]);
    assertEquals(secondResult, resultList.items[1]);
  });

  test('Search result rows are selected correctly', async () => {
    settingsSearchHandler.setFakeResults([fakeSettingsResult('a')]);
    personalizationSearchHandler.setFakeResults(
        [fakePersonalizationResult('b')]);
    await simulateSearch('query');
    await waitForListUpdate();

    assertTrue(dropDown.opened);
    assertEquals(resultList.items.length, 2);

    // The first row should be selected when results are fetched.
    assertEquals(resultList.selectedItem, resultList.items[0]);

    // Test ArrowUp and ArrowDown interaction with selecting.
    const arrowUpEvent = new KeyboardEvent(
        'keydown', {cancelable: true, key: 'ArrowUp', keyCode: 38});
    const arrowDownEvent = new KeyboardEvent(
        'keydown', {cancelable: true, key: 'ArrowDown', keyCode: 40});

    // ArrowDown event should select next row.
    searchBox.dispatchEvent(arrowDownEvent);
    assertEquals(resultList.selectedItem, resultList.items[1]);

    // If last row selected, ArrowDown brings select back to first row.
    searchBox.dispatchEvent(arrowDownEvent);
    assertEquals(resultList.selectedItem, resultList.items[0]);

    // If first row selected, ArrowUp brings select back to last row.
    searchBox.dispatchEvent(arrowUpEvent);
    assertEquals(resultList.selectedItem, resultList.items[1]);

    // ArrowUp should bring select previous row.
    searchBox.dispatchEvent(arrowUpEvent);
    assertEquals(resultList.selectedItem, resultList.items[0]);

    // Test that ArrowLeft and ArrowRight do nothing.
    const arrowLeftEvent = new KeyboardEvent(
        'keydown', {cancelable: true, key: 'ArrowLeft', keyCode: 37});
    const arrowRightEvent = new KeyboardEvent(
        'keydown', {cancelable: true, key: 'ArrowRight', keyCode: 39});

    // No change on ArrowLeft
    searchBox.dispatchEvent(arrowLeftEvent);
    assertEquals(resultList.selectedItem, resultList.items[0]);

    // No change on ArrowRight
    searchBox.dispatchEvent(arrowRightEvent);
    assertEquals(resultList.selectedItem, resultList.items[0]);
  });

  test('Keydown Enter on search box can cause route change', async () => {
    settingsSearchHandler.setFakeResults(
        [fakeSettingsResult('WiFi Settings', 'networks?type=WiFi')]);
    await simulateSearch('fake query');
    await waitForListUpdate();

    const enterEvent = new KeyboardEvent(
        'keydown', {cancelable: true, key: 'Enter', keyCode: 13});

    // Keydown with Enter key on the searchBox causes navigation to selected
    // row's route.
    searchBox.dispatchEvent(enterEvent);
    flush();
    assertFalse(dropDown.opened);
    const router = Router.getInstance();
    assertEquals(router.getQueryParameters().get('search'), 'fake query');
    assertEquals(router.getCurrentRoute().path, '/networks');
    assertEquals(router.getQueryParameters().get('type'), 'WiFi');
  });

  test(
      'Keypress Enter on personalization result opens personalization hub',
      async () => {
        // Enable personalization hub feature.
        loadTimeData.overrideValues({isPersonalizationHubEnabled: true});
        assertTrue(loadTimeData.getBoolean('isPersonalizationHubEnabled'));

        personalizationSearchHandler.setFakeResults(
            [fakePersonalizationResult('result', 'test')]);
        settingsSearchHandler.setFakeResults([]);
        await simulateSearch('fake query 1');
        await waitForListUpdate();

        const selectedOsRow = searchBox.getSelectedOsSearchResultRow_();
        assertTrue(!!selectedOsRow);
        assertEquals('cr:open-in-new', selectedOsRow.getActionTypeIcon_());

        // Keypress with Enter key on any row specifically causes navigation to
        // selected row's route. This can't happen unless the row is focused.
        const enterEvent = new KeyboardEvent(
            'keypress', {cancelable: true, key: 'Enter', keyCode: 13});
        selectedOsRow.$.searchResultContainer.dispatchEvent(enterEvent);

        assertEquals(
            'chrome://personalization/test',
            await openWindowProxy.whenCalled('openURL'));
      });

  test(
      'Clicking on personalization result opens personalization hub',
      async () => {
        // Enable personalization hub feature.
        loadTimeData.overrideValues({isPersonalizationHubEnabled: true});
        assertTrue(loadTimeData.getBoolean('isPersonalizationHubEnabled'));


        personalizationSearchHandler.setFakeResults(
            [fakePersonalizationResult('Wallpaper', 'test')]);
        await simulateSearch('fake query 1');
        await waitForListUpdate();

        const selectedOsRow = searchBox.getSelectedOsSearchResultRow_();
        assertTrue(!!selectedOsRow);
        assertEquals('cr:open-in-new', selectedOsRow.getActionTypeIcon_());

        // Clicking on the searchResultContainer of the row opens a new window.
        selectedOsRow.$.searchResultContainer.click();

        assertEquals(
            'chrome://personalization/test',
            await openWindowProxy.whenCalled('openURL'));
      });

  test(
      'Clicking on settings personalization result causes route change' +
          ' if personalization hub feature is disabled',
      async () => {
        // Disable personalization hub feature.
        loadTimeData.overrideValues({isPersonalizationHubEnabled: false});
        assertFalse(loadTimeData.getBoolean('isPersonalizationHubEnabled'));

        const result =
            fakeSettingsResult('Wallpaper', 'personalization?settingId=500');
        result.id.setting = chromeos.settings.mojom.Setting.kOpenWallpaper;

        settingsSearchHandler.setFakeResults([result]);
        await simulateSearch('fake query 2');
        await waitForListUpdate();

        const selectedOsRow = searchBox.getSelectedOsSearchResultRow_();
        assertTrue(!!selectedOsRow);

        // Clicking on the searchResultContainer of the row correctly changes
        // the route and dropdown to close.
        selectedOsRow.$.searchResultContainer.click();
        assertFalse(dropDown.opened);
        assertEquals(0, openWindowProxy.getCallCount('openURL'));
        const router = Router.getInstance();
        assertEquals(router.getQueryParameters().get('search'), 'fake query 2');
        assertEquals(router.getCurrentRoute().path, '/personalization');
        assertEquals(router.getQueryParameters().get('settingId'), '500');
      });

  test('Keypress Enter on row causes route change', async () => {
    settingsSearchHandler.setFakeResults(
        [fakeSettingsResult('WiFi Settings', 'networks?type=WiFi')]);
    await simulateSearch('fake query 1');
    await waitForListUpdate();

    const selectedOsRow = searchBox.getSelectedOsSearchResultRow_();
    assertTrue(!!selectedOsRow);

    // Keypress with Enter key on any row specifically causes navigation to
    // selected row's route. This can't happen unless the row is focused.
    const enterEvent = new KeyboardEvent(
        'keypress', {cancelable: true, key: 'Enter', keyCode: 13});
    selectedOsRow.$.searchResultContainer.dispatchEvent(enterEvent);
    assertFalse(dropDown.opened);
    const router = Router.getInstance();
    assertEquals(router.getQueryParameters().get('search'), 'fake query 1');
    assertEquals(router.getCurrentRoute().path, '/networks');
    assertEquals(router.getQueryParameters().get('type'), 'WiFi');
  });

  test('Route change when result row is clicked', async () => {
    settingsSearchHandler.setFakeResults(
        [fakeSettingsResult('WiFi Settings', 'networks?type=WiFi')]);
    await simulateSearch('fake query 2');
    await waitForListUpdate();

    const searchResultRow = searchBox.getSelectedOsSearchResultRow_();

    // Clicking on the searchResultContainer of the row correctly changes the
    // route and dropdown to close.
    searchResultRow.$.searchResultContainer.click();

    assertFalse(dropDown.opened);
    const router = Router.getInstance();
    assertEquals(router.getQueryParameters().get('search'), 'fake query 2');
    assertEquals(router.getCurrentRoute().path, '/networks');
    assertEquals(router.getQueryParameters().get('type'), 'WiFi');
  });

  test('Selecting result a second time does not deselect it.', async () => {
    settingsSearchHandler.setFakeResults(
        [fakeSettingsResult('WiFi Settings', 'networks?type=WiFi')]);
    await simulateSearch('query');
    await waitForListUpdate();

    // Clicking a selected item does not deselect it.
    const searchResultRow = searchBox.getSelectedOsSearchResultRow_();
    searchResultRow.$.searchResultContainer.click();
    assertEquals(resultList.selectedItem, resultList.items[0]);
    assertFalse(dropDown.opened);

    // Open search drop down again.
    field.$.searchInput.focus();
    assertTrue(dropDown.opened);

    // Clicking again does not deslect the row.
    searchResultRow.$.searchResultContainer.click();
    assertEquals(resultList.selectedItem, resultList.items[0]);
  });

  test('Test no bolding if not generated from text match', async () => {
    settingsSearchHandler.setFakeResults([fakeSettingsResult(
        'Search and Assistant', undefined, undefined,
        /*wasGeneratedFromTextMatch=*/ false)]);
    await simulateSearch(`Search`);
    await waitForListUpdate();
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `Search and Assistant`);
  });

  test('Tokenize and match result text to query text', async () => {
    settingsSearchHandler.setFakeResults(
        [fakeSettingsResult('Search and Assistant')]);
    await simulateSearch(`Assistant Search`);
    await waitForListUpdate();
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `<b>Search</b> and <b>Assistant</b>`);
  });

  test('Bold result text to matching query', async () => {
    settingsSearchHandler.setFakeResults(
        [fakeSettingsResult('Search and Assistant')]);
    await simulateSearch(`a`);
    await waitForListUpdate();
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `Se<b>a</b>rch <b>a</b>nd <b>A</b>ssist<b>a</b>nt`);
  });

  test('Bold result including ignored characters', async () => {
    settingsSearchHandler.setFakeResults([fakeSettingsResult('Turn on Wi-Fi')]);
    await simulateSearch(`wif`);
    await waitForListUpdate();
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `Turn on <b>Wi-F</b>i`);
    await simulateSearch(`wi f`);
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `Turn on <b>Wi-F</b>i`);
    await simulateSearch(`wi-f`);
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `Turn on <b>Wi-F</b>i`);

    settingsSearchHandler.setFakeResults(
        [fakeSettingsResult('Touchpad tap-to-click')]);
    await simulateSearch(`tap to cli`);
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `Touchpad <b>tap-to-cli</b>ck`);

    await simulateSearch(`taptocli`);
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `Touchpad <b>tap-to-cli</b>ck`);
    await simulateSearch(`tap-to-cli`);
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `Touchpad <b>tap-to-cli</b>ck`);

    settingsSearchHandler.setFakeResults(
        [fakeSettingsResult('Touchpad tap-to-click')]);
    await simulateSearch(`tap top cli`);
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `Touchpad <b>tap-to-cli</b>ck`);

    settingsSearchHandler.setFakeResults(
        [fakeSettingsResult('wxyz Tap-To-Click')]);
    await simulateSearch(`tap toxy cli`);
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `w<b>xy</b>z <b>Tap-To</b>-Click`);

    settingsSearchHandler.setFakeResults(
        [fakeSettingsResult('Tap-to-click Tips Title')]);
    await simulateSearch(`tap ti`);
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `<b>Tap</b>-to-click <b>Ti</b>ps <b>Ti</b>tle`);
  });

  test('Test query longer than result blocks', async () => {
    settingsSearchHandler.setFakeResults([fakeSettingsResult('Turn on Wi-Fi')]);
    await simulateSearch(`onwifi`);
    await waitForListUpdate();
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `Turn <b>on</b> <b>Wi-Fi</b>`);
  });

  test('Test bolding of accented characters', async () => {
    settingsSearchHandler.setFakeResults([fakeSettingsResult('Crème Brûlée')]);
    await simulateSearch(`E U`);
    await waitForListUpdate();
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `Cr<b>è</b>me Br<b>û</b>l<b>é</b>e`);
  });

  test('Test no spaces nor characters that have upper/lower case', async () => {
    settingsSearchHandler.setFakeResults(
        [fakeSettingsResult('キーボード設定---')]);
    await simulateSearch(`キー設`);
    await waitForListUpdate();
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `<b>キ</b><b>ー</b>ボ<b>ー</b>ド<b>設</b>定---`);
  });

  test('Test blankspace types in result maintained', async () => {
    const resultText = 'Turn\xa0on  \xa0Wi-Fi ';

    settingsSearchHandler.setFakeResults([fakeSettingsResult(resultText)]);
    await simulateSearch(`wif`);
    await waitForListUpdate();
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `Turn&nbsp;on  &nbsp;<b>Wi-F</b>i `);
  });

  test('Test longest common substring for mispellings', async () => {
    settingsSearchHandler.setFakeResults([fakeSettingsResult('Linux')]);
    await simulateSearch(`Linuux`);
    await waitForListUpdate();
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `<b>Linu</b>x`);

    settingsSearchHandler.setFakeResults([fakeSettingsResult('Linux')]);
    await simulateSearch(`Llinuc`);
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `<b>Linu</b>x`);

    settingsSearchHandler.setFakeResults([fakeSettingsResult('Display')]);
    await simulateSearch(`Dispplay`);
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `<b>Disp</b>lay`);

    settingsSearchHandler.setFakeResults(
        [fakeSettingsResult('ABCDEF GHIJK LMNO')]);
    await simulateSearch(`MCDEMMM LM EF CDEABCDEFADBCDABDCEF`);
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `<b>ABCDEF</b> GHIJK <b>LM</b>NO`);
  });

  test('Focus search input behavior on attached', async () => {
    PolymerTest.clearBody();
    Router.getInstance().navigateTo(routes.BASIC);
    setupSearchBox();
    assertEquals(field.root.activeElement, field.$.searchInput);

    PolymerTest.clearBody();
    Router.getInstance().navigateTo(routes.KEYBOARD);
    assertEquals(field.root.activeElement, null);
  });

  test('No personalization search results when feature off', async () => {
    loadTimeData.overrideValues({isPersonalizationHubEnabled: false});

    personalizationSearchHandler.setFakeResults(
        [fakePersonalizationResult('bad')]);
    settingsSearchHandler.setFakeResults([]);
    await simulateSearch('query');
    await waitForListUpdate();

    assertEquals(0, resultList.items.length, 'no personalization result shown');

    // Clear the search box.
    await simulateSearch('');

    settingsSearchHandler.setFakeResults([fakeSettingsResult('good')]);
    await simulateSearch('query');
    await waitForListUpdate();

    assertEquals(1, resultList.items.length, 'one setting result shown');
    assertEquals(
        'good',
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        'text matches expected result');
  });

  test('search results sorted descending', async () => {
    personalizationSearchHandler.setFakeResults([
      fakePersonalizationResult(
          'one', /*relativeUrl=*/ '', /*relevanceScore=*/ 0.99),
      fakePersonalizationResult(
          'three', /*relativeUrl=*/ '', /*relevanceScore=*/ 0.75),
      fakePersonalizationResult(
          'cut', /*relativeUrl=*/ '', /*relevanceScore=*/ 0.2),
    ]);
    settingsSearchHandler.setFakeResults([
      fakeSettingsResult(
          'two', /*urlPathWithParameters=*/ '',
          /*icon=*/ chromeos.settings.mojom.SearchResultIcon.MIN_VALUE,
          /*wasGeneratedFromTextMatch=*/ true, /*relevanceScore=*/ 0.85),
      fakeSettingsResult(
          'four', /*urlPathWithParameters=*/ '',
          /*icon=*/ chromeos.settings.mojom.SearchResultIcon.MIN_VALUE,
          /*wasGeneratedFromTextMatch=*/ true, /*relevanceScore=*/ 0.55),
      fakeSettingsResult(
          'five', /*urlPathWithParameters=*/ '',
          /*icon=*/ chromeos.settings.mojom.SearchResultIcon.MIN_VALUE,
          /*wasGeneratedFromTextMatch=*/ true, /*relevanceScore=*/ 0.35),
    ]);

    await simulateSearch('fake query');
    await waitForListUpdate();

    assertEquals(5, resultList.items.length, 'results cut to show top 5');

    assertDeepEquals(
        [
          {text: 'one', relevanceScore: 0.99},
          {text: 'two', relevanceScore: 0.85},
          {text: 'three', relevanceScore: 0.75},
          {text: 'four', relevanceScore: 0.55},
          {text: 'five', relevanceScore: 0.35},
        ],
        resultList.items.map(item => {
          return {
            text: item.text.data.map(ch => String.fromCodePoint(ch)).join(''),
            relevanceScore: item.relevanceScore,
          };
        }),
        'search results sorted in expected order');
  });
});
