// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/browser/themes/theme_service.h"

#include "chrome/browser/extensions/component_loader.h"
#include "chrome/browser/extensions/extension_browsertest.h"
#include "chrome/browser/profiles/profile.h"
#include "chrome/browser/themes/test/theme_service_changed_waiter.h"
#include "chrome/browser/themes/theme_properties.h"
#include "chrome/browser/themes/theme_service_factory.h"
#include "chrome/browser/ui/browser.h"
#include "chrome/browser/ui/browser_window.h"
#include "chrome/common/pref_names.h"
#include "components/prefs/pref_service.h"
#include "content/public/test/browser_test.h"
#include "content/public/test/test_utils.h"

namespace {

// The ntp link color specified in the theme.
constexpr SkColor kThemeNtpLinkColor = SkColorSetRGB(36, 70, 0);

bool UsingCustomTheme(const ThemeService& theme_service) {
  return !theme_service.UsingSystemTheme() &&
         !theme_service.UsingDefaultTheme();
}

class ThemeServiceBrowserTest : public extensions::ExtensionBrowserTest {
 public:
  ThemeServiceBrowserTest() {
  }

  ThemeServiceBrowserTest(const ThemeServiceBrowserTest&) = delete;
  ThemeServiceBrowserTest& operator=(const ThemeServiceBrowserTest&) = delete;

  ~ThemeServiceBrowserTest() override {}

  void SetUp() override {
    extensions::ComponentLoader::EnableBackgroundExtensionsForTesting();
    extensions::ExtensionBrowserTest::SetUp();
  }
};

// Test that the theme is recreated from the extension when the data pack is
// unavailable or invalid (such as when the theme pack version is incremented).
// The PRE_ part of the test installs the theme and changes where Chrome looks
// for the theme data pack to make sure that Chrome does not find it.
IN_PROC_BROWSER_TEST_F(ThemeServiceBrowserTest, PRE_ThemeDataPackInvalid) {
  Profile* profile = browser()->profile();
  ThemeService* theme_service = ThemeServiceFactory::GetForProfile(profile);
  const ui::ThemeProvider* theme_provider =
      browser()->window()->GetThemeProvider();

  // Test initial state.
  EXPECT_FALSE(UsingCustomTheme(*theme_service));
  EXPECT_NE(kThemeNtpLinkColor,
            theme_provider->GetColor(ThemeProperties::COLOR_NTP_LINK));
  EXPECT_EQ(base::FilePath(),
            profile->GetPrefs()->GetFilePath(prefs::kCurrentThemePackFilename));

  test::ThemeServiceChangedWaiter waiter(theme_service);
  InstallExtension(test_data_dir_.AppendASCII("theme"), 1);
  waiter.WaitForThemeChanged();

  // Check that the theme was installed.
  EXPECT_TRUE(UsingCustomTheme(*theme_service));
  EXPECT_EQ(kThemeNtpLinkColor,
            theme_provider->GetColor(ThemeProperties::COLOR_NTP_LINK));
  EXPECT_NE(base::FilePath(),
            profile->GetPrefs()->GetFilePath(prefs::kCurrentThemePackFilename));

  // Change the theme data pack path to an invalid location such that second
  // part of the test is forced to recreate the theme pack when the theme
  // service is initialized.
  profile->GetPrefs()->SetFilePath(prefs::kCurrentThemePackFilename,
                                   base::FilePath());
}

IN_PROC_BROWSER_TEST_F(ThemeServiceBrowserTest, ThemeDataPackInvalid) {
  ThemeService* theme_service = ThemeServiceFactory::GetForProfile(
      browser()->profile());
  const ui::ThemeProvider* theme_provider =
      browser()->window()->GetThemeProvider();
  EXPECT_TRUE(UsingCustomTheme(*theme_service));
  EXPECT_EQ(kThemeNtpLinkColor,
            theme_provider->GetColor(ThemeProperties::COLOR_NTP_LINK));
}

IN_PROC_BROWSER_TEST_F(ThemeServiceBrowserTest, IncognitoTest) {
  // This test relies on incognito being meaningfully different than default,
  // which is not currently true in dark mode.
  ui::NativeTheme::GetInstanceForNativeUi()->set_use_dark_colors(false);

  // Should get a different ThemeProvider for incognito and original windows.
  Browser* incognito_browser = CreateIncognitoBrowser();
  const ui::ThemeProvider* provider = browser()->window()->GetThemeProvider();
  const ui::ThemeProvider* otr_provider =
      incognito_browser->window()->GetThemeProvider();
  EXPECT_NE(provider, otr_provider);
  // And (some) colors should be different.
  EXPECT_NE(provider->GetColor(ThemeProperties::COLOR_TOOLBAR),
            otr_provider->GetColor(ThemeProperties::COLOR_TOOLBAR));
}

IN_PROC_BROWSER_TEST_F(ThemeServiceBrowserTest,
                       IncognitoCustomColor_WithAutoGeneratedTheme) {
  Browser* incognito_browser = CreateIncognitoBrowser();
  const ui::ThemeProvider* provider = browser()->window()->GetThemeProvider();
  const ui::ThemeProvider* otr_provider =
      incognito_browser->window()->GetThemeProvider();

  const SkColor original_color =
      provider->GetColor(ThemeProperties::COLOR_TOOLBAR);
  const SkColor original_otr_color =
      otr_provider->GetColor(ThemeProperties::COLOR_TOOLBAR);

  ThemeServiceFactory::GetForProfile(profile())
      ->BuildAutogeneratedThemeFromColor(SkColorSetRGB(100, 100, 100));

  // The custom theme should affect the normal window, but not the incognito
  // window.
  EXPECT_NE(original_color, provider->GetColor(ThemeProperties::COLOR_TOOLBAR));
  EXPECT_EQ(original_otr_color,
            otr_provider->GetColor(ThemeProperties::COLOR_TOOLBAR));
}

IN_PROC_BROWSER_TEST_F(ThemeServiceBrowserTest,
                       IncognitoCustomColor_WithExtensionOverride) {
  Browser* incognito_browser = CreateIncognitoBrowser();
  const ui::ThemeProvider* provider = browser()->window()->GetThemeProvider();
  const ui::ThemeProvider* otr_provider =
      incognito_browser->window()->GetThemeProvider();

  const SkColor original_color =
      provider->GetColor(ThemeProperties::COLOR_TOOLBAR);
  const SkColor original_otr_color =
      otr_provider->GetColor(ThemeProperties::COLOR_TOOLBAR);

  ThemeService* theme_service =
      ThemeServiceFactory::GetForProfile(browser()->profile());
  test::ThemeServiceChangedWaiter waiter(theme_service);
  InstallExtension(test_data_dir_.AppendASCII("theme_minimal/"), 1);
  waiter.WaitForThemeChanged();
  EXPECT_TRUE(theme_service->UsingExtensionTheme());

  // The custom theme should affect the normal window, but not the incognito
  // window.
  EXPECT_NE(original_color, provider->GetColor(ThemeProperties::COLOR_TOOLBAR));
  EXPECT_EQ(original_otr_color,
            otr_provider->GetColor(ThemeProperties::COLOR_TOOLBAR));
}

IN_PROC_BROWSER_TEST_F(ThemeServiceBrowserTest, GetColorForToolbarButton) {
  // This test relies on toolbar buttons having no tint, which is not currently
  // true in dark mode.
  ui::NativeTheme::GetInstanceForNativeUi()->set_use_dark_colors(false);

  const ui::ThemeProvider* provider = browser()->window()->GetThemeProvider();
  SkColor default_toolbar_button_color =
      provider->GetColor(ThemeProperties::COLOR_TOOLBAR_BUTTON_ICON);

  ThemeService* theme_service =
      ThemeServiceFactory::GetForProfile(browser()->profile());
  {
    test::ThemeServiceChangedWaiter waiter(theme_service);
    InstallExtension(
        test_data_dir_.AppendASCII("theme_test_toolbar_button_color/"), 1);
    waiter.WaitForThemeChanged();
  }

  // Should get a new color after installing a theme.
  SkColor toolbar_button_explicit_color =
      provider->GetColor(ThemeProperties::COLOR_TOOLBAR_BUTTON_ICON);
  EXPECT_NE(toolbar_button_explicit_color, default_toolbar_button_color);

  {
    test::ThemeServiceChangedWaiter waiter(theme_service);
    InstallExtension(
        test_data_dir_.AppendASCII("theme_test_toolbar_button_tint/"), 1);
    waiter.WaitForThemeChanged();
  }

  // Should get the color based on a tint.
  SkColor toolbar_button_tinted_color =
      provider->GetColor(ThemeProperties::COLOR_TOOLBAR_BUTTON_ICON);
  EXPECT_NE(toolbar_button_tinted_color, default_toolbar_button_color);
  EXPECT_NE(toolbar_button_tinted_color, toolbar_button_explicit_color);
}

}  // namespace
