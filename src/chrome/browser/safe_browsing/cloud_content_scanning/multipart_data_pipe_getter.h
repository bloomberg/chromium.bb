// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_BROWSER_SAFE_BROWSING_CLOUD_CONTENT_SCANNING_MULTIPART_DATA_PIPE_GETTER_H_
#define CHROME_BROWSER_SAFE_BROWSING_CLOUD_CONTENT_SCANNING_MULTIPART_DATA_PIPE_GETTER_H_

#include <stdint.h>
#include <memory>

#include "base/files/file.h"
#include "base/files/memory_mapped_file.h"
#include "base/time/time.h"
#include "mojo/public/cpp/bindings/receiver_set.h"
#include "services/network/public/mojom/data_pipe_getter.mojom.h"

namespace safe_browsing {

// This class implements mojom::DataPipeGetter for a multipart request with a
// body that has the following format:
// --BOUNDARY
// Content-Type: application/octet-stream
//
// <file metadata>
// --BOUNDARY
// Content-Type: application/octet-stream
//
// <file data>
// --BOUNDARY--
//
class MultipartDataPipeGetter : public network::mojom::DataPipeGetter {
 public:
  MultipartDataPipeGetter(const std::string& boundary,
                          const std::string& metadata,
                          std::unique_ptr<base::MemoryMappedFile> file);
  ~MultipartDataPipeGetter() override;

  // network::mojom::DataPipeGetter:
  void Read(mojo::ScopedDataPipeProducerHandle pipe,
            ReadCallback callback) override;
  void Clone(
      mojo::PendingReceiver<network::mojom::DataPipeGetter> receiver) override;

  // Returns nullptr if |file| is invalid or if a memory mapped file can't be
  // created from it.
  static std::unique_ptr<MultipartDataPipeGetter> Create(
      const std::string& boundary,
      const std::string& metadata,
      base::File file);

  // Resets |pipe_|, |watcher_|, and |write_position_| so future calls to Read
  // can work correctly.
  void Reset();

  // The file makes blocking calls when closing, so this method is used to
  // release it on a different thread so |this| can call its dtor immediately.
  std::unique_ptr<base::MemoryMappedFile> ReleaseFile();

 private:
  // Callback used by |watcher_|.
  void MojoReadyCallback(MojoResult result,
                         const mojo::HandleSignalsState& state);

  // Calls the appropriate Write method according to |write_position_|.
  void Write();

  // Methods to write a string or a file to |pipe_|. Returns true if further
  // Write methods can be called.
  bool WriteString(const std::string& str, int64_t offset);
  bool WriteFileData();
  bool Write(const char* data, int64_t full_size, int64_t offset);

  // Returns the total size of the body generated by the class.
  int64_t FullSize();

  // Value to be written at the start of the body.
  std::string metadata_;

  // Value to be written at the end of the body.
  std::string last_boundary_;

  // This class uses a memory mapped file instead of a regular base::File to
  // avoid blocking calls on the main thread.
  std::unique_ptr<base::MemoryMappedFile> file_;
  int64_t write_position_ = 0;

  // Used for metrics.
  base::TimeTicks write_start_time_;

  mojo::ScopedDataPipeProducerHandle pipe_;
  std::unique_ptr<mojo::SimpleWatcher> watcher_;
  mojo::ReceiverSet<network::mojom::DataPipeGetter> receivers_;
};

}  // namespace safe_browsing

#endif  // CHROME_BROWSER_SAFE_BROWSING_CLOUD_CONTENT_SCANNING_MULTIPART_DATA_PIPE_GETTER_H_
