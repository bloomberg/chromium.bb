# Copyright 2019 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/config/android/rules.gni")
import("//build/config/locales.gni")
import("//chrome/android/modules/chrome_feature_modules.gni")

# Instantiates a Chrome-specific app bundle module.
#
# Supports most attributes of the android_app_bundle_module target, plus:
#   module_desc: Descriptor of this module. See
#     //chrome/android/modules/chrome_feature_modules.gni for the format.
#   module_name_suffix: Suffix added to the module name.
#   is_monochrome_or_trichrome: (Optional) Whether this module is packaged into
#     Monochrome or Trichrome.
#   is_64_bit_browser: (Optional) Whether Chrome (as opposed to WebView) runs in
#     64 bit.
#   include_32_bit_webview: (Optional) Whether to include 32 bit code for
#     WebView.
template("chrome_feature_module") {
  _module_desc = invoker.module_desc

  android_app_bundle_module(target_name) {
    forward_variables_from(invoker,
                           [
                             "base_module_target",
                             "manifest_package",
                             "min_sdk_version",
                             "uncompress_shared_libraries",
                             "version_code",
                             "version_name",
                           ])
    android_manifest = _module_desc.android_manifest

    # TODO(tiborg): Remove module_name flag from android_app_bundle_module.
    module_name = "${_module_desc.name}${invoker.module_name_suffix}"
    target_sdk_version = android_sdk_version
    deps = _module_desc.java_deps

    if (defined(_module_desc.proguard_async) && _module_desc.proguard_async) {
      enable_class_deps_output = "${_module_desc.name}_constant_pool_deps.txt"
    }

    # Don't embed more translations than required (http://crbug.com/932017).
    aapt_locale_whitelist = locales

    proguard_enabled = !is_java_debug

    package_name = _module_desc.name
    package_name_to_id_mapping = resource_packages_id_mapping

    _loadable_modules_32_bit = []
    _loadable_modules_64_bit = []
    if (defined(_module_desc.loadable_modules_32_bit)) {
      _loadable_modules_32_bit += _module_desc.loadable_modules_32_bit
    }
    if (defined(_module_desc.loadable_modules_64_bit)) {
      _loadable_modules_64_bit += _module_desc.loadable_modules_64_bit
    }

    if (defined(_module_desc.native_deps) && _module_desc.native_deps != []) {
      _is_monochrome_or_trichrome =
          defined(invoker.is_monochrome_or_trichrome) &&
          invoker.is_monochrome_or_trichrome
      _arch = ""
      _toolchain = ""
      _root_out_dir = root_out_dir
      if (android_64bit_target_cpu && _is_monochrome_or_trichrome) {
        if (defined(invoker.is_64_bit_browser) && invoker.is_64_bit_browser) {
          _arch = "_64"
        } else {
          _toolchain = "($android_secondary_abi_toolchain)"
          _root_out_dir =
              get_label_info(":foo($android_secondary_abi_toolchain)",
                             "root_out_dir")
        }
      }
      if (_is_monochrome_or_trichrome) {
        _base_target_name = "libmonochrome${_arch}"
      } else {
        _base_target_name = "libchrome${_arch}"
      }
      deps += [ "//chrome/android:${_base_target_name}_${_module_desc.name}${_toolchain}" ]
      _native_library = "${_root_out_dir}/${_base_target_name}_partitions/lib${_module_desc.name}.so"

      # Pass the correct library as both the 32 and 64-bit options. Underlying
      # logic will choose from the correct variable, and supply a dummy library
      # for the other architecture if required.
      _loadable_modules_32_bit += [ _native_library ]
      _loadable_modules_64_bit += [ _native_library ]
    } else if (defined(invoker.is_monochrome_or_trichrome)) {
      not_needed(invoker, [ "is_monochrome_or_trichrome" ])
    }

    if (defined(_module_desc.loadable_module_dep)) {
      assert(defined(_module_desc.loadable_module))
      deps += [ _module_desc.loadable_module_dep ]
      if (android_64bit_target_cpu) {
        _32_bit_toolchain_root_dir =
            get_label_info(":foo($android_secondary_abi_toolchain)",
                           "root_out_dir")
        _loadable_modules_64_bit =
            [ "$root_out_dir/${_module_desc.loadable_module}" ]
        _loadable_modules_32_bit =
            [ "$_32_bit_toolchain_root_dir/${_module_desc.loadable_module}" ]
        deps += [ _module_desc.loadable_module_dep +
                  "($android_secondary_abi_toolchain)" ]
      } else {
        _loadable_modules_32_bit =
            [ "$root_out_dir/${_module_desc.loadable_module}" ]
      }
    }

    if (_loadable_modules_32_bit != [] || _loadable_modules_64_bit != []) {
      # TODO(tiborg): Move loadable module selection logic here.
      native_switches = {
        is_64_bit_browser = invoker.is_64_bit_browser
        include_32_bit_webview = invoker.include_32_bit_webview
      }
      loadable_modules_if_32_bit = _loadable_modules_32_bit
      loadable_modules_if_64_bit = _loadable_modules_64_bit
    } else {
      if (defined(invoker.is_64_bit_browser)) {
        not_needed(invoker, [ "is_64_bit_browser" ])
      }
      if (defined(invoker.include_32_bit_webview)) {
        not_needed(invoker, [ "include_32_bit_webview" ])
      }
    }
  }
}
