/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//
// Specification of protocols used by the AndroidListener abstraction.
//
// Note: unless otherwise specified in a comment, all fields in all messages
// are required, even though they are listed as optional.

syntax = "proto2";

package com.google.protos.ipc.invalidation;

option optimize_for = LITE_RUNTIME;


option java_outer_classname = "NanoAndroidListenerProtocol";
option java_package = "com.google.protos.ipc.invalidation";


import "client.proto";
import "client_protocol.proto";

// Used to persist internal state between instantiations of Android listener
// objects.
message AndroidListenerState {
  // When a registration request has failed, we track state for that object that
  // allows retries to be delayed using exponential backoff.
  message RetryRegistrationState {
    // Identifier of the object for which there has been a failure.
    optional ObjectIdP object_id = 1;

    // State of exponential backoff delay generator that is used to delay any
    // registration retries for the object.
    optional ExponentialBackoffState exponential_backoff_state = 2;
  }

  // A scheduled registration retry.
  message ScheduledRegistrationRetry {
    // The registration command to execute.
    optional RegistrationCommand command = 1;

    // The time at which the retry should be attempted.
    optional int64 execute_time_ms = 2;
  }

  // Set of object ids tracking the application's desired registrations.
  repeated ObjectIdP registration = 1;

  // Set of states for registrations retries. When there is a transient
  // registration failure relative to an object, an entry is added. If
  // registration is successful or the user gives up on the request, the entry
  // is removed.
  repeated RetryRegistrationState retry_registration_state = 2;

  // Identifier of client with which this listener is associated. This client ID
  // is randomly generated by the Android listener whenever a new client is
  // started and has no relationship to 's application client ID.
  optional bytes client_id = 3;

  // Sequence number for alarm manager request codes. Sequence numbers are
  // assigned serially for each distinct client_id. This value indicates
  // the request code used for the last request.
  optional int32 request_code_seq_num = 4;

  // Registration retries currently pending execution.
  repeated ScheduledRegistrationRetry registration_retry = 5;
}

// Represents a command that registers or unregisters a set of objects. The
// command may be initiated by the application or by the Android listener when
// there is a registration failure.
message RegistrationCommand {
  // Indicates whether this is a register command (when true) or unregister
  // (when false) request.
  optional bool is_register = 1;

  // Identifies the objects to register or unregister.
  repeated ObjectIdP object_id = 2;

  // Identifier of client with which this listener is associated.
  optional bytes client_id = 3;

  // Indicates whether this is a delayed registration command. When a
  // registration command intent is handled by the Android listener, this field
  // is used to determine whether the command has been delayed yet or not. If it
  // has not already been delayed, the listener may choose to defer the command
  // until later.
  optional bool is_delayed = 4;
}

// Represents a command that starts an Android invalidation client.
message StartCommand {
  // Type of client to start.
  optional int32 client_type = 1;

  // Name of client to start.
  optional bytes client_name = 2;

  // Whether suppression is permitted for this client.
  optional bool allow_suppression = 3;
}

