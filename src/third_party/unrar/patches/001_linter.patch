diff --git a/third_party/unrar/src/arccmt.cpp b/third_party/unrar/src/arccmt.cpp
index 33f22045c36b..3de667ab2e2d 100644
--- a/third_party/unrar/src/arccmt.cpp
+++ b/third_party/unrar/src/arccmt.cpp
@@ -1,5 +1,3 @@
-static bool IsAnsiEscComment(const wchar *Data,size_t Size);
-
 bool Archive::GetComment(Array<wchar> *CmtData)
 {
   if (!MainComment)
@@ -43,7 +41,7 @@ bool Archive::GetComment(Array<wchar> *CmtData)
 #endif
   }
 #ifndef SFX_MODULE
-  if (Format==RARFMT14 && MainHead.PackComment || Format!=RARFMT14 && CommHead.Method!=0x30)
+  if ((Format==RARFMT14 && MainHead.PackComment) || (Format!=RARFMT14 && CommHead.Method!=0x30))
   {
     if (Format!=RARFMT14 && (CommHead.UnpVer < 15 || CommHead.UnpVer > VER_UNPACK || CommHead.Method > 0x35))
       return false;
diff --git a/third_party/unrar/src/archive.cpp b/third_party/unrar/src/archive.cpp
index 401fc34c3e01..7b0e12dd96a0 100644
--- a/third_party/unrar/src/archive.cpp
+++ b/third_party/unrar/src/archive.cpp
@@ -106,6 +106,7 @@ RARFORMAT Archive::IsSignature(const byte *D,size_t Size)
 {
   RARFORMAT Type=RARFMT_NONE;
   if (Size>=1 && D[0]==0x52)
+  {
 #ifndef SFX_MODULE
     if (Size>=4 && D[1]==0x45 && D[2]==0x7e && D[3]==0x5e)
       Type=RARFMT14;
@@ -125,6 +126,7 @@ RARFORMAT Archive::IsSignature(const byte *D,size_t Size)
             if (D[6]>1 && D[6]<5)
               Type=RARFMT_FUTURE;
       }
+  }
   return Type;
 }
 
@@ -208,7 +210,7 @@ bool Archive::IsArchive(bool EnableBroken)
     HEADER_TYPE Type=GetHeaderType();
     // In RAR 5.0 we need to quit after reading HEAD_CRYPT if we wish to
     // avoid the password prompt.
-    if (Type==HEAD_MAIN || SilentOpen && Type==HEAD_CRYPT)
+    if (Type==HEAD_MAIN || (SilentOpen && Type==HEAD_CRYPT))
       break;
   }
 
diff --git a/third_party/unrar/src/arcmem.cpp b/third_party/unrar/src/arcmem.cpp
index a8497856a330..3001732413a3 100644
--- a/third_party/unrar/src/arcmem.cpp
+++ b/third_party/unrar/src/arcmem.cpp
@@ -39,7 +39,7 @@ bool ArcMemory::Seek(int64 Offset,int Method)
   if (!Loaded)
     return false;
   if (Method==SEEK_SET)
-    SeekPos=Min(Offset,ArcData.Size());
+    SeekPos=Min((uint64)Offset,ArcData.Size());
   else
     if (Method==SEEK_CUR || Method==SEEK_END)
     {
diff --git a/third_party/unrar/src/arcread.cpp b/third_party/unrar/src/arcread.cpp
index 6b3de71bcdb4..a9583148bc60 100644
--- a/third_party/unrar/src/arcread.cpp
+++ b/third_party/unrar/src/arcread.cpp
@@ -10,7 +10,7 @@ size_t Archive::ReadHeader()
 
   CurBlockPos=Tell();
 
-  size_t ReadSize;
+  size_t ReadSize = 0;
   switch(Format)
   {
 #ifndef SFX_MODULE
@@ -24,6 +24,9 @@ size_t Archive::ReadHeader()
     case RARFMT50:
       ReadSize=ReadHeader50();
       break;
+    case RARFMT_NONE:
+    case RARFMT_FUTURE:
+      break;
   }
 
   // It is important to check ReadSize>0 here, because it is normal
@@ -139,7 +142,8 @@ size_t Archive::ReadHeader15()
 
   if (Decrypt)
   {
-#ifdef RAR_NOCRYPT // For rarext.dll and unrar_nocrypt.dll.
+#if defined(RAR_NOCRYPT) || \
+    defined(CHROMIUM_UNRAR)  // For rarext.dll and unrar_nocrypt.dll.
     return 0;
 #else
     RequestArcPassword();
@@ -187,6 +191,7 @@ size_t Archive::ReadHeader15()
     case HEAD3_FILE:    ShortBlock.HeaderType=HEAD_FILE;     break;
     case HEAD3_SERVICE: ShortBlock.HeaderType=HEAD_SERVICE;  break;
     case HEAD3_ENDARC:  ShortBlock.HeaderType=HEAD_ENDARC;   break;
+    default:                                                 break;
   }
   CurHeaderType=ShortBlock.HeaderType;
 
@@ -201,7 +206,7 @@ size_t Archive::ReadHeader15()
     if (ShortBlock.HeaderType==HEAD_MAIN && (ShortBlock.Flags & MHD_COMMENT)!=0)
     {
       // Old style (up to RAR 2.9) main archive comment embedded into
-      // the main archive header found. While we can read the entire 
+      // the main archive header found. While we can read the entire
       // ShortBlock.HeadSize here and remove this part of "if", it would be
       // waste of memory, because we'll read and process this comment data
       // in other function anyway and we do not need them here now.
@@ -227,7 +232,7 @@ size_t Archive::ReadHeader15()
       Encrypted=(MainHead.Flags & MHD_PASSWORD)!=0;
       Signed=MainHead.PosAV!=0 || MainHead.HighPosAV!=0;
       MainHead.CommentInHeader=(MainHead.Flags & MHD_COMMENT)!=0;
-    
+
       // Only for encrypted 3.0+ archives. 2.x archives did not have this
       // flag, so for non-encrypted archives, we'll set it later based on
       // file attributes.
@@ -254,7 +259,7 @@ size_t Archive::ReadHeader15()
         hd->WinSize=hd->Dir ? 0:0x10000<<((hd->Flags & LHD_WINDOWMASK)>>5);
         hd->CommentInHeader=(hd->Flags & LHD_COMMENT)!=0;
         hd->Version=(hd->Flags & LHD_VERSION)!=0;
-        
+
         hd->DataSize=Raw.Get4();
         uint LowUnpSize=Raw.Get4();
         hd->HostOS=Raw.Get1();
@@ -274,7 +279,7 @@ size_t Archive::ReadHeader15()
           {
             case 13: hd->CryptMethod=CRYPT_RAR13; break;
             case 15: hd->CryptMethod=CRYPT_RAR15; break;
-            case 20: 
+            case 20:
             case 26: hd->CryptMethod=CRYPT_RAR20; break;
             default: hd->CryptMethod=CRYPT_RAR30; break;
           }
@@ -296,7 +301,7 @@ size_t Archive::ReadHeader15()
         }
 
         hd->Inherited=!FileBlock && (hd->SubFlags & SUBHEAD_FLAGS_INHERITED)!=0;
-        
+
         hd->LargeFile=(hd->Flags & LHD_LARGE)!=0;
 
         uint HighPackSize,HighUnpSize;
@@ -306,7 +311,7 @@ size_t Archive::ReadHeader15()
           HighUnpSize=Raw.Get4();
           hd->UnknownUnpSize=(LowUnpSize==0xffffffff && HighUnpSize==0xffffffff);
         }
-        else 
+        else
         {
           HighPackSize=HighUnpSize=0;
           // UnpSize equal to 0xffffffff without LHD_LARGE flag indicates
@@ -532,7 +537,7 @@ size_t Archive::ReadHeader15()
         NextBlockPos+=Raw.Get4();
       break;
   }
-  
+
   ushort HeaderCRC=Raw.GetCRC15(false);
 
   // Old AV header does not have header CRC properly set.
@@ -578,7 +583,7 @@ size_t Archive::ReadHeader50()
 
   if (Decrypt)
   {
-#if defined(RAR_NOCRYPT)
+#if defined(RAR_NOCRYPT) || defined(CHROMIUM_UNRAR)
     return 0;
 #else
 
@@ -642,7 +647,7 @@ size_t Archive::ReadHeader50()
     BrokenHeaderMsg();
     return 0;
   }
-  
+
   Raw.Read(SizeToRead);
 
   if (Raw.Size()<HeaderSize)
@@ -675,7 +680,7 @@ size_t Archive::ReadHeader50()
       return 0;
     }
   }
-  
+
   uint64 ExtraSize=0;
   if ((ShortBlock.Flags & HFL_EXTRA)!=0)
   {
@@ -764,7 +769,7 @@ size_t Archive::ReadHeader50()
           // to not break normal archive processing by calling function.
           int64 SaveCurBlockPos=CurBlockPos,SaveNextBlockPos=NextBlockPos;
           HEADER_TYPE SaveCurHeaderType=CurHeaderType;
-          
+
           QOpen.Init(this,false);
           QOpen.Load(MainHead.QOpenOffset);
 
@@ -789,7 +794,7 @@ size_t Archive::ReadHeader50()
         hd->PackSize=DataSize;
         hd->FileFlags=(uint)Raw.GetV();
         hd->UnpSize=Raw.GetV();
-        
+
         hd->UnknownUnpSize=(hd->FileFlags & FHFL_UNPUNKNOWN)!=0;
         if (hd->UnknownUnpSize)
           hd->UnpSize=INT64NDF;
@@ -874,7 +879,7 @@ size_t Archive::ReadHeader50()
           RecoverySize=Header.RecSectionSize*Header.RecCount;
         }
 #endif
-          
+
         if (BadCRC) // Add the file name to broken header message displayed above.
           uiMsg(UIERROR_FHEADERBROKEN,Archive::FileName,hd->FileName);
       }
@@ -889,6 +894,8 @@ size_t Archive::ReadHeader50()
         EndArcHead.RevSpace=false;
       }
       break;
+    default:
+      break;
   }
 
   return Raw.Size();
@@ -1054,20 +1061,26 @@ void Archive::ProcessExtra50(RawRead *Raw,size_t ExtraSize,BaseBlock *bb)
             byte Flags=(byte)Raw->GetV();
             bool UnixTime=(Flags & FHEXTRA_HTIME_UNIXTIME)!=0;
             if ((Flags & FHEXTRA_HTIME_MTIME)!=0)
+            {
               if (UnixTime)
                 hd->mtime.SetUnix(Raw->Get4());
               else
                 hd->mtime.SetWin(Raw->Get8());
+            }
             if ((Flags & FHEXTRA_HTIME_CTIME)!=0)
+            {
               if (UnixTime)
                 hd->ctime.SetUnix(Raw->Get4());
               else
                 hd->ctime.SetWin(Raw->Get8());
+            }
             if ((Flags & FHEXTRA_HTIME_ATIME)!=0)
+            {
               if (UnixTime)
                 hd->atime.SetUnix((time_t)Raw->Get4());
               else
                 hd->atime.SetWin(Raw->Get8());
+            }
             if (UnixTime && (Flags & FHEXTRA_HTIME_UNIX_NS)!=0) // Add nanoseconds.
             {
               uint ns;
@@ -1287,7 +1300,7 @@ void Archive::ConvertAttributes()
 
   if (mask == (mode_t) -1)
   {
-    // umask call returns the current umask value. Argument (022) is not 
+    // umask call returns the current umask value. Argument (022) is not
     // really important here.
     mask = umask(022);
 
@@ -1338,10 +1351,12 @@ void Archive::ConvertFileHeader(FileHeader *hd)
   if (Format==RARFMT15 && hd->UnpVer<20 && (hd->FileAttr & 0x10))
     hd->Dir=true;
   if (hd->HSType==HSYS_UNKNOWN)
+  {
     if (hd->Dir)
       hd->FileAttr=0x10;
     else
       hd->FileAttr=0x20;
+  }
 
 #ifdef _WIN_ALL
   if (hd->HSType==HSYS_UNIX) // Convert Unix, OS X and Android decomposed chracters to Windows precomposed.
@@ -1366,8 +1381,8 @@ void Archive::ConvertFileHeader(FileHeader *hd)
 
     // ':' in file names is allowed in Unix, but not in Windows.
     // Even worse, file data will be written to NTFS stream on NTFS,
-    // so automatic name correction on file create error in extraction 
-    // routine does not work. In Windows and DOS versions we better 
+    // so automatic name correction on file create error in extraction
+    // routine does not work. In Windows and DOS versions we better
     // replace ':' now.
     if (*s==':')
       *s='_';
@@ -1379,7 +1394,7 @@ void Archive::ConvertFileHeader(FileHeader *hd)
     // Still, RAR 4.x uses backslashes as path separator even in Unix.
     // Forward slash is not allowed in both systems. In RAR 5.0 we use
     // the forward slash as universal path separator.
-    if (*s=='/' || *s=='\\' && Format!=RARFMT50)
+    if (*s=='/' || (*s=='\\' && Format!=RARFMT50))
       *s=CPATHDIVIDER;
   }
 }
@@ -1434,12 +1449,14 @@ bool Archive::ReadSubData(Array<byte> *UnpData,File *DestFile)
     }
   }
   if (SubHead.Encrypted)
+  {
     if (Cmd->Password.IsSet())
       SubDataIO.SetEncryption(false,SubHead.CryptMethod,&Cmd->Password,
                 SubHead.SaltSet ? SubHead.Salt:NULL,SubHead.InitV,
                 SubHead.Lg2Count,SubHead.HashKey,SubHead.PswCheck);
     else
       return false;
+  }
   SubDataIO.UnpHash.Init(SubHead.FileHash.Type,1);
   SubDataIO.SetPackedSizeToRead(SubHead.PackSize);
   SubDataIO.EnableShowProgress(false);
diff --git a/third_party/unrar/src/cmddata.cpp b/third_party/unrar/src/cmddata.cpp
index baa3eb608692..c444597c9a3c 100644
--- a/third_party/unrar/src/cmddata.cpp
+++ b/third_party/unrar/src/cmddata.cpp
@@ -763,10 +763,11 @@ void CommandData::ProcessSwitch(const wchar *Switch)
                   AlreadyBad=true;
                   break;
               };
-              if (!AlreadyBad)
+              if (!AlreadyBad) {
                 if (Switch[3]==0)
                   CommentCharset=FilelistCharset=ErrlogCharset=RedirectCharset=rch;
                 else
+                {
                   for (uint I=3;Switch[I]!=0 && !AlreadyBad;I++)
                     switch(toupperw(Switch[I]))
                     {
@@ -784,6 +785,8 @@ void CommandData::ProcessSwitch(const wchar *Switch)
                         AlreadyBad=true;
                         break;
                     }
+                }
+              }
               // Set it immediately when parsing the command line, so it also
               // affects messages issued while parsing the command line.
               SetConsoleRedirectCharset(RedirectCharset);
@@ -1202,7 +1205,7 @@ int CommandData::IsProcessFile(FileHeader &FileHead,bool *ExactMatch,int MatchTy
 #ifndef SFX_MODULE
   if (TimeCheck(FileHead.mtime))
     return 0;
-  if ((FileHead.FileAttr & ExclFileAttr)!=0 || InclAttrSet && (FileHead.FileAttr & InclFileAttr)==0)
+  if ((FileHead.FileAttr & ExclFileAttr)!=0 || (InclAttrSet && (FileHead.FileAttr & InclFileAttr)==0))
     return 0;
   if (!Dir && SizeCheck(FileHead.UnpSize))
     return 0;
@@ -1227,7 +1230,7 @@ void CommandData::ProcessCommand()
 #ifndef SFX_MODULE
 
   const wchar *SingleCharCommands=L"FUADPXETK";
-  if (Command[0]!=0 && Command[1]!=0 && wcschr(SingleCharCommands,Command[0])!=NULL || *ArcName==0)
+  if ((Command[0]!=0 && Command[1]!=0 && wcschr(SingleCharCommands,Command[0])!=NULL) || *ArcName==0)
     OutHelp(*Command==0 ? RARX_SUCCESS:RARX_USERERROR); // Return 'success' for 'rar' without parameters.
 
   const wchar *ArcExt=GetExt(ArcName);
diff --git a/third_party/unrar/src/consio.cpp b/third_party/unrar/src/consio.cpp
index 196066ec9630..39c9014503ae 100644
--- a/third_party/unrar/src/consio.cpp
+++ b/third_party/unrar/src/consio.cpp
@@ -70,7 +70,7 @@ static void cvt_wprintf(FILE *dest,const wchar *fmt,va_list arglist)
   PrintfPrepareFmt(fmt,fmtw,ASIZE(fmtw));
 #ifdef _WIN_ALL
   safebuf wchar Msg[MaxMsgSize];
-  if (dest==stdout && StdoutRedirected || dest==stderr && StderrRedirected)
+  if ((dest==stdout && StdoutRedirected) || (dest==stderr && StderrRedirected))
   {
     HANDLE hOut=GetStdHandle(dest==stdout ? STD_OUTPUT_HANDLE:STD_ERROR_HANDLE);
     vswprintf(Msg,ASIZE(Msg),fmtw,arglist);
@@ -191,10 +191,16 @@ bool GetConsolePassword(UIPASSWORD_TYPE Type,const wchar *FileName,SecPassword *
   while (true)
   {
     if (!StdinRedirected)
+    {
       if (Type==UIPASSWORD_GLOBAL)
+      {
         eprintf(L"\n%s: ",St(MAskPsw));
+      }
       else
+      {
         eprintf(St(MAskPswFor),FileName);
+      }
+    }
 
     wchar PlainPsw[MAXPASSWORD];
     GetPasswordText(PlainPsw,ASIZE(PlainPsw));
diff --git a/third_party/unrar/src/crypt.cpp b/third_party/unrar/src/crypt.cpp
index fc2126d46c17..785b5faea53d 100644
--- a/third_party/unrar/src/crypt.cpp
+++ b/third_party/unrar/src/crypt.cpp
@@ -48,6 +48,8 @@ void CryptData::DecryptBlock(byte *Buf,size_t Size)
     case CRYPT_RAR50:
       rin.blockDecrypt(Buf,Size,Buf);
       break;
+    case CRYPT_NONE:
+      break;
   }
 }
 
@@ -85,6 +87,8 @@ bool CryptData::SetCryptKeys(bool Encrypt,CRYPT_METHOD Method,
     case CRYPT_RAR50:
       SetKey50(Encrypt,Password,PwdW,Salt,InitV,Lg2Cnt,HashKey,PswCheck);
       break;
+    case CRYPT_NONE:
+      break;
   }
   cleandata(PwdA,sizeof(PwdA));
   cleandata(PwdW,sizeof(PwdW));
diff --git a/third_party/unrar/src/crypt3.cpp b/third_party/unrar/src/crypt3.cpp
index 48406487e7bf..93467aa3b92d 100644
--- a/third_party/unrar/src/crypt3.cpp
+++ b/third_party/unrar/src/crypt3.cpp
@@ -5,8 +5,8 @@ void CryptData::SetKey30(bool Encrypt,SecPassword *Password,const wchar *PwdW,co
   bool Cached=false;
   for (uint I=0;I<ASIZE(KDF3Cache);I++)
     if (KDF3Cache[I].Pwd==*Password &&
-        (Salt==NULL && !KDF3Cache[I].SaltPresent || Salt!=NULL &&
-        KDF3Cache[I].SaltPresent && memcmp(KDF3Cache[I].Salt,Salt,SIZE_SALT30)==0))
+        ((Salt==NULL && !KDF3Cache[I].SaltPresent) || (Salt!=NULL &&
+        KDF3Cache[I].SaltPresent && memcmp(KDF3Cache[I].Salt,Salt,SIZE_SALT30)==0)))
     {
       memcpy(AESKey,KDF3Cache[I].Key,sizeof(AESKey));
       SecHideData(AESKey,sizeof(AESKey),false,false);
@@ -65,4 +65,3 @@ void CryptData::SetKey30(bool Encrypt,SecPassword *Password,const wchar *PwdW,co
   cleandata(AESKey,sizeof(AESKey));
   cleandata(AESInit,sizeof(AESInit));
 }
-
diff --git a/third_party/unrar/src/extract.cpp b/third_party/unrar/src/extract.cpp
index abdd928785c4..89a53c11d000 100644
--- a/third_party/unrar/src/extract.cpp
+++ b/third_party/unrar/src/extract.cpp
@@ -63,6 +63,7 @@ void CmdExtract::DoExtract()
   }
   else
     if (!Cmd->DisableDone)
+    {
       if (Cmd->Command[0]=='I')
         mprintf(St(MDone));
       else
@@ -70,6 +71,7 @@ void CmdExtract::DoExtract()
           mprintf(St(MExtrAllOk));
         else
           mprintf(St(MExtrTotalErr),ErrHandler.GetErrorCount());
+    }
 }
 
 
@@ -197,6 +199,7 @@ EXTRACT_ARC_CODE CmdExtract::ExtractArchive()
 
     bool Repeat=false;
     if (!ExtractCurrentFile(Arc,Size,Repeat))
+    {
       if (Repeat)
       {
         // If we started extraction from not first volume and need to
@@ -212,6 +215,7 @@ EXTRACT_ARC_CODE CmdExtract::ExtractArchive()
       }
       else
         break;
+    }
   }
 
 
@@ -228,6 +232,7 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
 {
   wchar Command=Cmd->Command[0];
   if (HeaderSize==0)
+  {
     if (DataIO.UnpVolume)
     {
 #ifdef NOVOLUME
@@ -244,6 +249,7 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
     }
     else
       return false;
+  }
 
   HEADER_TYPE HeaderType=Arc.GetHeaderType();
   if (HeaderType!=HEAD_FILE)
@@ -255,6 +261,7 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
     if (HeaderType==HEAD_SERVICE && PrevProcessed)
       SetExtraInfo(Cmd,Arc,DestFileName);
     if (HeaderType==HEAD_ENDARC)
+    {
       if (Arc.EndArcHead.NextVolume)
       {
 #ifndef NOVOLUME
@@ -269,6 +276,7 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
       }
       else
         return false;
+    }
     Arc.SeekToNext();
     return true;
   }
@@ -571,6 +579,7 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
       }
       FileCount++;
       if (Command!='I')
+      {
         if (SkipSolid)
           mprintf(St(MExtrSkipFile),ArcFileName);
         else
@@ -589,6 +598,7 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
               mprintf(St(MExtrFile),DestFileName);
               break;
           }
+      }
       if (!Cmd->DisablePercentage)
         mprintf(L"     ");
 
@@ -632,10 +642,12 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
           wchar NameExisting[NM];
           ExtrPrepareName(Arc,Arc.FileHead.RedirName,NameExisting,ASIZE(NameExisting));
           if (FileCreateMode && *NameExisting!=0) // *NameExisting can be 0 in case of excessive -ap switch.
+          {
             if (Type==FSREDIR_HARDLINK)
               LinkSuccess=ExtractHardlink(DestFileName,NameExisting,ASIZE(NameExisting));
             else
               LinkSuccess=ExtractFileCopy(CurFile,Arc.FileName,DestFileName,NameExisting,ASIZE(NameExisting));
+          }
         }
         else
           if (Type==FSREDIR_UNIXSYMLINK || Type==FSREDIR_WINSYMLINK || Type==FSREDIR_JUNCTION)
@@ -649,7 +661,7 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
             LinkSuccess=false;
           }
           
-          if (!LinkSuccess || Arc.Format==RARFMT15 && !FileCreateMode)
+          if (!LinkSuccess || (Arc.Format==RARFMT15 && !FileCreateMode))
           {
             // RAR 5.x links have a valid data checksum even in case of
             // failure, because they do not store any data.
@@ -662,6 +674,7 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
       }
       else
         if (!Arc.FileHead.SplitBefore)
+        {
           if (Arc.FileHead.Method==0)
             UnstoreFile(DataIO,Arc.FileHead.UnpSize);
           else
@@ -675,6 +688,7 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
 #endif
               Unp->DoUnpack(Arc.FileHead.UnpVer,Arc.FileHead.Solid);
           }
+        }
 
       Arc.SeekToNext();
 
@@ -729,7 +743,7 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
         mprintf(L"\b\b\b\b\b     ");
 
       if (!TestMode && (Command=='X' || Command=='E') &&
-          (!LinkEntry || Arc.FileHead.RedirType==FSREDIR_FILECOPY && LinkSuccess) && 
+          (!LinkEntry || (Arc.FileHead.RedirType==FSREDIR_FILECOPY && LinkSuccess)) && 
           (!BrokenFile || Cmd->KeepBroken))
       {
         // We could preallocate more space that really written to broken file.
@@ -772,11 +786,13 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
   if (DataIO.NextVolumeMissing)
     return false;
   if (!ExtrFile)
+  {
     if (!Arc.Solid)
       Arc.SeekToNext();
     else
       if (!SkipSolid)
         return false;
+  }
   return true;
 }
 
diff --git a/third_party/unrar/src/file.cpp b/third_party/unrar/src/file.cpp
index e2bb42a616ad..4ca83ad1ee6f 100644
--- a/third_party/unrar/src/file.cpp
+++ b/third_party/unrar/src/file.cpp
@@ -23,10 +23,12 @@ File::File()
 File::~File()
 {
   if (hFile!=FILE_BAD_HANDLE && !SkipClose)
+  {
     if (NewFile)
       Delete();
     else
       Close();
+  }
 }
 
 
@@ -367,6 +369,7 @@ int File::Read(void *Data,size_t Size)
     {
       ErrorType=FILE_READERROR;
       if (AllowExceptions)
+      {
         if (IgnoreReadErrors)
         {
           ReadSize=0;
@@ -384,6 +387,7 @@ int File::Read(void *Data,size_t Size)
             continue;
           ErrHandler.ReadError(FileName);
         }
+      }
     }
     break;
   }
@@ -499,18 +503,22 @@ bool File::RawSeek(int64 Offset,int Method)
 int64 File::Tell()
 {
   if (hFile==FILE_BAD_HANDLE)
+  {
     if (AllowExceptions)
       ErrHandler.SeekError(FileName);
     else
       return -1;
+  }
 #ifdef _WIN_ALL
   LONG HighDist=0;
   uint LowDist=SetFilePointer(hFile,0,&HighDist,FILE_CURRENT);
   if (LowDist==0xffffffff && GetLastError()!=NO_ERROR)
+  {
     if (AllowExceptions)
       ErrHandler.SeekError(FileName);
     else
       return -1;
+  }
   return INT32TO64(HighDist,LowDist);
 #else
 #ifdef FILE_USE_OPEN
diff --git a/third_party/unrar/src/filestr.cpp b/third_party/unrar/src/filestr.cpp
index a5d29d74bcfa..d25cf09b5f4f 100644
--- a/third_party/unrar/src/filestr.cpp
+++ b/third_party/unrar/src/filestr.cpp
@@ -14,10 +14,12 @@ bool ReadTextFile(
   *FileName=0;
 
   if (Name!=NULL)
+  {
     if (Config)
       GetConfigName(Name,FileName,ASIZE(FileName),true,false);
     else
       wcsncpyz(FileName,Name,ASIZE(FileName));
+  }
 
   File SrcFile;
   if (*FileName!=0)
diff --git a/third_party/unrar/src/hash.cpp b/third_party/unrar/src/hash.cpp
index 42791f4f437a..899b0ed1ab07 100644
--- a/third_party/unrar/src/hash.cpp
+++ b/third_party/unrar/src/hash.cpp
@@ -30,8 +30,8 @@ bool HashValue::operator == (const HashValue &cmp)
 {
   if (Type==HASH_NONE || cmp.Type==HASH_NONE)
     return true;
-  if (Type==HASH_RAR14 && cmp.Type==HASH_RAR14 || 
-      Type==HASH_CRC32 && cmp.Type==HASH_CRC32)
+  if ((Type==HASH_RAR14 && cmp.Type==HASH_RAR14) || 
+      (Type==HASH_CRC32 && cmp.Type==HASH_CRC32))
     return CRC32==cmp.CRC32;
   if (Type==HASH_BLAKE2 && cmp.Type==HASH_BLAKE2)
     return memcmp(Digest,cmp.Digest,sizeof(Digest))==0;
diff --git a/third_party/unrar/src/isnt.hpp b/third_party/unrar/src/isnt.hpp
index 85790da46290..877d8801257a 100644
--- a/third_party/unrar/src/isnt.hpp
+++ b/third_party/unrar/src/isnt.hpp
@@ -9,5 +9,4 @@ enum WINNT_VERSION {
 
 DWORD WinNT();
 
-
 #endif
diff --git a/third_party/unrar/src/list.cpp b/third_party/unrar/src/list.cpp
index 561122b450fe..b633db1b267e 100644
--- a/third_party/unrar/src/list.cpp
+++ b/third_party/unrar/src/list.cpp
@@ -1,10 +1,7 @@
 #include "rar.hpp"
 
 static void ListFileHeader(Archive &Arc,FileHeader &hd,bool &TitleShown,bool Verbose,bool Technical,bool Bare);
-static void ListSymLink(Archive &Arc);
 static void ListFileAttr(uint A,HOST_SYSTEM_TYPE HostType,wchar *AttrStr,size_t AttrSize);
-static void ListOldSubHeader(Archive &Arc);
-static void ListNewSubHeader(CommandData *Cmd,Archive &Arc);
 
 void ListArchive(CommandData *Cmd)
 {
@@ -48,6 +45,7 @@ void ListArchive(CommandData *Cmd)
           if (Arc.SFXSize>0)
             mprintf(L"%s%s", SetCount++ > 0 ? L", ":L"", St(MListSFX));
           if (Arc.Volume)
+          {
             if (Arc.Format==RARFMT50)
             {
               // RAR 5.0 archives store the volume number in main header,
@@ -58,6 +56,7 @@ void ListArchive(CommandData *Cmd)
             }
             else
               mprintf(L"%s%s", SetCount++ > 0 ? L", ":L"", St(MListVolume));
+          }
           if (Arc.Protected)
             mprintf(L"%s%s", SetCount++ > 0 ? L", ":L"", St(MListRR));
           if (Arc.Locked)
@@ -110,10 +109,13 @@ void ListArchive(CommandData *Cmd)
                   ListFileHeader(Arc,Arc.SubHead,TitleShown,Verbose,true,false);
               }
               break;
+            default:
+              break;
           }
           Arc.SeekToNext();
         }
         if (!Bare && !Technical)
+        {
           if (TitleShown)
           {
             wchar UnpSizeText[20];
@@ -142,12 +144,13 @@ void ListArchive(CommandData *Cmd)
           }
           else
             mprintf(St(MListNoFiles));
+        }
 
         ArcCount++;
 
 #ifndef NOVOLUME
         if (Cmd->VolSize!=0 && (Arc.FileHead.SplitAfter ||
-            Arc.GetHeaderType()==HEAD_ENDARC && Arc.EndArcHead.NextVolume) &&
+            (Arc.GetHeaderType()==HEAD_ENDARC && Arc.EndArcHead.NextVolume)) &&
             MergeArchive(Arc,NULL,false,Cmd->Command[0]))
           Arc.Seek(0,SEEK_SET);
         else
@@ -272,9 +275,12 @@ void ListFileHeader(Archive &Arc,FileHeader &hd,bool &TitleShown,bool Verbose,bo
             Type=St(MListHardlink); break;
           case FSREDIR_FILECOPY:
             Type=St(MListCopy);     break;
+          case FSREDIR_NONE:
+            break;
         }
       mprintf(L"\n%12ls: %ls",St(MListType),Type);
       if (hd.RedirType!=FSREDIR_NONE)
+      {
         if (Format==RARFMT15)
         {
           char LinkTargetA[NM];
@@ -296,6 +302,7 @@ void ListFileHeader(Archive &Arc,FileHeader &hd,bool &TitleShown,bool Verbose,bo
         }
         else
           mprintf(L"\n%12ls: %ls",St(MListTarget),hd.RedirName);
+      }
     }
     if (!hd.Dir)
     {
diff --git a/third_party/unrar/src/match.cpp b/third_party/unrar/src/match.cpp
index 4369a578c3ab..146a3b62a6fd 100644
--- a/third_party/unrar/src/match.cpp
+++ b/third_party/unrar/src/match.cpp
@@ -47,6 +47,7 @@ bool CmpName(const wchar *Wildcard,const wchar *Name,int CmpMode)
         mwcsicompc(Path1,Path2,ForceCase)!=0)
       return(false);
     if (CmpMode==MATCH_SUBPATH || CmpMode==MATCH_WILDSUBPATH)
+    {
       if (IsWildcard(Path1))
         return(match(Wildcard,Name,ForceCase));
       else
@@ -58,6 +59,7 @@ bool CmpName(const wchar *Wildcard,const wchar *Name,int CmpMode)
         else
           if (mwcsicompc(Path1,Path2,ForceCase)!=0)
             return(false);
+    }
   }
   wchar *Name1=PointToName(Wildcard);
   wchar *Name2=PointToName(Name);
diff --git a/third_party/unrar/src/pathfn.cpp b/third_party/unrar/src/pathfn.cpp
index 28680672efef..69d648e95871 100644
--- a/third_party/unrar/src/pathfn.cpp
+++ b/third_party/unrar/src/pathfn.cpp
@@ -346,7 +346,7 @@ void NextVolumeName(wchar *ArcName,uint MaxLength,bool OldNumbering)
     ChPtr=GetExt(ArcName);
   }
   else
-    if (ChPtr[1]==0 && wcslen(ArcName)<MaxLength-3 || wcsicomp(ChPtr+1,L"exe")==0 || wcsicomp(ChPtr+1,L"sfx")==0)
+    if ((ChPtr[1]==0 && wcslen(ArcName)<MaxLength-3) || wcsicomp(ChPtr+1,L"exe")==0 || wcsicomp(ChPtr+1,L"sfx")==0)
       wcscpy(ChPtr+1,L"rar");
   if (!OldNumbering)
   {
@@ -417,7 +417,7 @@ void MakeNameUsable(char *Name,bool Extended)
 #endif
   for (char *s=Name;*s!=0;s=charnext(s))
   {
-    if (strchr(Extended ? "?*<>|\"":"?*",*s)!=NULL || Extended && (byte)*s<32)
+    if (strchr(Extended ? "?*<>|\"":"?*",*s)!=NULL || (Extended && (byte)*s<32))
       *s='_';
 #ifdef _EMX
     if (*s=='=')
@@ -427,7 +427,7 @@ void MakeNameUsable(char *Name,bool Extended)
     if (s-Name>1 && *s==':')
       *s='_';
     // Remove ' ' and '.' before path separator, but allow .\ and ..\.
-    if ((*s==' ' || *s=='.' && s>Name && !IsPathDiv(s[-1]) && s[-1]!='.') && IsPathDiv(s[1]))
+    if ((*s==' ' || (*s=='.' && s>Name && !IsPathDiv(s[-1]) && s[-1]!='.')) && IsPathDiv(s[1]))
       *s='_';
 #endif
   }
@@ -438,7 +438,7 @@ void MakeNameUsable(wchar *Name,bool Extended)
 {
   for (wchar *s=Name;*s!=0;s++)
   {
-    if (wcschr(Extended ? L"?*<>|\"":L"?*",*s)!=NULL || Extended && (uint)*s<32)
+    if (wcschr(Extended ? L"?*<>|\"":L"?*",*s)!=NULL || (Extended && (uint)*s<32))
       *s='_';
 #ifndef _UNIX
     if (s-Name>1 && *s==':')
@@ -541,7 +541,7 @@ bool IsFullPath(const wchar *Path)
     return true;
 */
 #if defined(_WIN_ALL) || defined(_EMX)
-  return Path[0]=='\\' && Path[1]=='\\' || IsDriveLetter(Path) && IsPathDiv(Path[2]);
+  return (Path[0]=='\\' && Path[1]=='\\') || (IsDriveLetter(Path) && IsPathDiv(Path[2]));
 #else
   return IsPathDiv(Path[0]);
 #endif
@@ -722,11 +722,12 @@ static void GenArcName(wchar *ArcName,const wchar *GenerateMask,uint ArcNumber,b
 
   int WeekDay=rlt.wDay==0 ? 6:rlt.wDay-1;
   int StartWeekDay=rlt.yDay-WeekDay;
-  if (StartWeekDay<0)
+  if (StartWeekDay<0) {
     if (StartWeekDay<=-4)
       StartWeekDay+=IsLeapYear(rlt.Year-1) ? 366:365;
     else
       StartWeekDay=0;
+  }
   int CurWeek=StartWeekDay/7+1;
   if (StartWeekDay%7>=4)
     CurWeek++;
@@ -970,7 +971,7 @@ void MakeNameCompatible(wchar *Name)
       for (int I=Dest-1;I>0 && (Name[I]==' ' || Name[I]=='.');I--)
       {
         // Permit path1/./path2 and ../path1 paths.
-        if (Name[I]=='.' && (IsPathDiv(Name[I-1]) || Name[I-1]=='.' && I==1))
+        if (Name[I]=='.' && (IsPathDiv(Name[I-1]) || (Name[I-1]=='.' && I==1)))
           break;
         Dest--;
       }
diff --git a/third_party/unrar/src/rarvm.cpp b/third_party/unrar/src/rarvm.cpp
index 8d8675a39bd7..bcb0a0e68089 100644
--- a/third_party/unrar/src/rarvm.cpp
+++ b/third_party/unrar/src/rarvm.cpp
@@ -52,12 +52,12 @@ void RarVM::Prepare(byte *Code,uint CodeSize,VM_PreparedProgram *Prg)
     uint CRC;
     VM_StandardFilters Type;
   } static StdList[]={
-    53, 0xad576887, VMSF_E8,
-    57, 0x3cd7e57e, VMSF_E8E9,
-   120, 0x3769893f, VMSF_ITANIUM,
-    29, 0x0e06077d, VMSF_DELTA,
-   149, 0x1c2c5dc8, VMSF_RGB,
-   216, 0xbc85e701, VMSF_AUDIO
+    {53, 0xad576887, VMSF_E8},
+    {57, 0x3cd7e57e, VMSF_E8E9},
+   {120, 0x3769893f, VMSF_ITANIUM},
+    {29, 0x0e06077d, VMSF_DELTA},
+   {149, 0x1c2c5dc8, VMSF_RGB},
+   {216, 0xbc85e701, VMSF_AUDIO}
   };
   uint CodeCRC=CRC32(0xffffffff,Code,CodeSize)^0xffffffff;
   for (uint I=0;I<ASIZE(StdList);I++)
@@ -327,6 +327,8 @@ bool RarVM::ExecuteStandardFilter(VM_StandardFilters FilterType)
         }
       }
       break;
+    case VMSF_NONE:
+      break;
   }
   return true;
 }
diff --git a/third_party/unrar/src/rdwrfn.cpp b/third_party/unrar/src/rdwrfn.cpp
index f75f66450b2b..001363090bc3 100644
--- a/third_party/unrar/src/rdwrfn.cpp
+++ b/third_party/unrar/src/rdwrfn.cpp
@@ -118,7 +118,7 @@ int ComprDataIO::UnpRead(byte *Addr,size_t Count)
     // Since we adjust data size for decryption earlier above,
     // it does not hurt "Keep broken files" mode efficiency.
     if (UnpVolume && UnpPackedSize == 0 && 
-        (ReadSize==0 || Decryption && (TotalRead & CRYPT_BLOCK_MASK) != 0) )
+        (ReadSize==0 || (Decryption && (TotalRead & CRYPT_BLOCK_MASK) != 0)) )
     {
 #ifndef NOVOLUME
       if (!MergeArchive(*SrcArc,this,true,CurrentCommand))
diff --git a/third_party/unrar/src/recvol3.cpp b/third_party/unrar/src/recvol3.cpp
index 0d18f079b332..1b3b66caa99c 100644
--- a/third_party/unrar/src/recvol3.cpp
+++ b/third_party/unrar/src/recvol3.cpp
@@ -89,12 +89,16 @@ static bool IsNewStyleRev(const wchar *Name)
   if (Ext==NULL)
     return true;
   int DigitGroup=0;
-  for (Ext--;Ext>Name;Ext--)
-    if (!IsDigit(*Ext))
-      if (*Ext=='_' && IsDigit(*(Ext-1)))
+  for (Ext--;Ext>Name;Ext--) {
+    if (!IsDigit(*Ext)) {
+      if (*Ext=='_' && IsDigit(*(Ext-1))) {
         DigitGroup++;
-      else
+      }
+      else {
         break;
+      }
+    }
+  }
   return DigitGroup<2;
 }
 
@@ -228,7 +232,7 @@ bool RecVolumes3::Restore(RAROptions *Cmd,const wchar *Name,bool Silent)
     }
     if (P[1]+P[2]>255)
       continue;
-    if (RecVolNumber!=0 && RecVolNumber!=P[1] || FileNumber!=0 && FileNumber!=P[2])
+    if ((RecVolNumber!=0 && RecVolNumber!=P[1]) || (FileNumber!=0 && FileNumber!=P[2]))
     {
       uiMsg(UIERROR_RECVOLDIFFSETS,CurName,PrevName);
       return false;
diff --git a/third_party/unrar/src/rs16.cpp b/third_party/unrar/src/rs16.cpp
index f23cff8574db..335d342768a6 100644
--- a/third_party/unrar/src/rs16.cpp
+++ b/third_party/unrar/src/rs16.cpp
@@ -27,7 +27,7 @@ RSCoder16::~RSCoder16()
   delete[] MX;
   delete[] ValidFlags;
 }
-    
+
 
 // Initialize logarithms and exponents Galois field tables.
 void RSCoder16::gfInit()
@@ -41,7 +41,7 @@ void RSCoder16::gfInit()
     gfExp[L]=E;
     gfExp[L+gfSize]=E;  // Duplicate the table to avoid gfExp overflow check.
     E<<=1;
-    if (E>gfSize) 
+    if (E>gfSize)
       E^=0x1100B; // Irreducible field-generator polynomial.
   }
 
@@ -59,7 +59,7 @@ uint RSCoder16::gfAdd(uint a,uint b) // Addition in Galois field.
 }
 
 
-uint RSCoder16::gfMul(uint a,uint b) // Multiplication in Galois field. 
+uint RSCoder16::gfMul(uint a,uint b) // Multiplication in Galois field.
 {
   return gfExp[gfLog[a]+gfLog[b]];
 }
@@ -144,7 +144,7 @@ void RSCoder16::MakeDecoderMatrix()
 }
 
 
-// Apply Gauss–Jordan elimination to find inverse of decoder matrix.
+// Apply Gauss-Jordan elimination to find inverse of decoder matrix.
 // We have the square NDxND matrix, but we do not store its trivial
 // diagonal "1" rows matching valid data, so we work with NExND matrix.
 // Our original Cauchy matrix does not contain 0, so we skip search
@@ -156,7 +156,7 @@ void RSCoder16::InvertDecoderMatrix()
   for (uint Kr = 0, Kf = 0; Kr < NE; Kr++, Kf++)
   {
     while (ValidFlags[Kf]) // Skip trivial rows.
-      Kf++;                 
+      Kf++;
     MI[Kr * ND + Kf] = 1;  // Set diagonal 1.
   }
 
@@ -174,7 +174,7 @@ void RSCoder16::InvertDecoderMatrix()
       // after MI[..]^=, but we do not need it for matrix inversion.
       for (uint I = 0; I < NE; I++)
         MI[I * ND + Kf] ^= MX[I * ND + Kf];
-      Kf++;                 
+      Kf++;
     }
 
     if (Kf == ND)
@@ -186,14 +186,14 @@ void RSCoder16::InvertDecoderMatrix()
     uint PInv = gfInv( MXk[Kf] ); // Pivot inverse.
     // Divide the pivot row by pivot, so pivot cell contains 1.
     for (uint I = 0; I < ND; I++)
-    { 
+    {
       MXk[I] = gfMul( MXk[I], PInv );
       MIk[I] = gfMul( MIk[I], PInv );
     }
 
     for (uint I = 0; I < NE; I++)
       if (I != Kr) // For all rows except containing the pivot cell.
-      { 
+      {
         // Apply Gaussian elimination Mij -= Mkj * Mik / pivot.
         // Since pivot is already 1, it is reduced to Mij -= Mkj * Mik.
         uint *MXi = MX + I * ND; // i-th row of main matrix.
@@ -361,7 +361,7 @@ bool RSCoder16::SSE_UpdateECC(uint DataNum, uint ECCNum, const byte *Data, byte
     __m128i LowBytes1=_mm_and_si128(D[1],LowByteMask);
     __m128i HighBytes=_mm_packus_epi16(HighBytes0,HighBytes1);
     __m128i LowBytes=_mm_packus_epi16(LowBytes0,LowBytes1);
-    
+
     // Multiply bits 0..3 of low bytes. Store low and high product bytes
     // separately in cumulative sum variables.
     __m128i LowBytesLow4=_mm_and_si128(LowBytes,Low4Mask);
@@ -377,7 +377,7 @@ bool RSCoder16::SSE_UpdateECC(uint DataNum, uint ECCNum, const byte *Data, byte
     // Add new product to existing sum, low and high bytes separately.
     LowBytesMultSum=_mm_xor_si128(LowBytesMultSum,LowBytesHigh4MultLow);
     HighBytesMultSum=_mm_xor_si128(HighBytesMultSum,LowBytesHigh4MultHigh);
-    
+
     // Multiply bits 0..3 of high bytes. Store low and high product bytes separately.
     __m128i HighBytesLow4=_mm_and_si128(HighBytes,Low4Mask);
     __m128i HighBytesLow4MultLow=_mm_shuffle_epi8(T2L,HighBytesLow4);
@@ -413,7 +413,7 @@ bool RSCoder16::SSE_UpdateECC(uint DataNum, uint ECCNum, const byte *Data, byte
   // because Data and ECC can have different alignment offsets.
   for (; Pos<BlockSize; Pos+=2)
     *(ushort*)(ECC+Pos) ^= gfMul( M, *(ushort*)(Data+Pos) );
-  
+
   return true;
 }
 #endif
diff --git a/third_party/unrar/src/scantree.cpp b/third_party/unrar/src/scantree.cpp
index 841a1e924594..73e43aa7535b 100644
--- a/third_party/unrar/src/scantree.cpp
+++ b/third_party/unrar/src/scantree.cpp
@@ -218,7 +218,7 @@ bool ScanTree::GetNextMask()
   wchar *Name=PointToName(CurMask);
   if (*Name==0)
     wcsncatz(CurMask,MASKALL,ASIZE(CurMask));
-  if (Name[0]=='.' && (Name[1]==0 || Name[1]=='.' && Name[2]==0))
+  if (Name[0]=='.' && (Name[1]==0 || (Name[1]=='.' && Name[2]==0)))
   {
     AddEndSlash(CurMask,ASIZE(CurMask));
     wcsncatz(CurMask,MASKALL,ASIZE(CurMask));
@@ -257,9 +257,9 @@ SCAN_CODE ScanTree::FindProc(FindData *FD)
     // at top level in recursion mode. We always comrpess the entire directory
     // if folder wildcard is specified.
     bool SearchAll=!IsDir && (Depth>0 || Recurse==RECURSE_ALWAYS ||
-                   FolderWildcards && Recurse!=RECURSE_DISABLE || 
-                   Wildcards && Recurse==RECURSE_WILDCARDS || 
-                   ScanEntireDisk && Recurse!=RECURSE_DISABLE);
+                   (FolderWildcards && Recurse!=RECURSE_DISABLE) || 
+                   (Wildcards && Recurse==RECURSE_WILDCARDS) || 
+                   (ScanEntireDisk && Recurse!=RECURSE_DISABLE));
     if (Depth==0)
       SearchAllInRoot=SearchAll;
     if (SearchAll || Wildcards)
diff --git a/third_party/unrar/src/strfn.cpp b/third_party/unrar/src/strfn.cpp
index 283c67b484cf..b0c82216ad2b 100644
--- a/third_party/unrar/src/strfn.cpp
+++ b/third_party/unrar/src/strfn.cpp
@@ -121,7 +121,7 @@ unsigned char loctolower(unsigned char ch)
 {
 #if defined(_WIN_ALL)
   // Convert to LPARAM first to avoid a warning in 64 bit mode.
-  return (int)(LPARAM)CharLowerA((LPSTR)ch);
+  return (int)(LPARAM)CharLowerA((LPSTR)(uintptr_t)ch);
 #else
   return tolower(ch);
 #endif
@@ -132,7 +132,7 @@ unsigned char loctoupper(unsigned char ch)
 {
 #if defined(_WIN_ALL)
   // Convert to LPARAM first to avoid a warning in 64 bit mode.
-  return (int)(LPARAM)CharUpperA((LPSTR)ch);
+  return (int)(LPARAM)CharUpperA((LPSTR)(uintptr_t)ch);
 #else
   return toupper(ch);
 #endif
@@ -186,7 +186,7 @@ bool IsSpace(int ch)
 // values, resulting in undefined behavior in standard function.
 bool IsAlpha(int ch)
 {
-  return ch>='A' && ch<='Z' || ch>='a' && ch<='z';
+  return (ch>='A' && ch<='Z') || (ch>='a' && ch<='z');
 }
 
 
diff --git a/third_party/unrar/src/timefn.cpp b/third_party/unrar/src/timefn.cpp
index 63f466084d04..186ac4fd6f86 100644
--- a/third_party/unrar/src/timefn.cpp
+++ b/third_party/unrar/src/timefn.cpp
@@ -141,7 +141,7 @@ void RarTime::GetWinFT(FILETIME *ft)
 
 void RarTime::SetWinFT(FILETIME *ft)
 {
-  _ULARGE_INTEGER ul = {ft->dwLowDateTime, ft->dwHighDateTime};
+  _ULARGE_INTEGER ul = {{ft->dwLowDateTime, ft->dwHighDateTime}};
   SetWin(ul.QuadPart);
 }
 #endif
diff --git a/third_party/unrar/src/uiconsole.cpp b/third_party/unrar/src/uiconsole.cpp
index 281eade0278d..4e4f5a66320e 100644
--- a/third_party/unrar/src/uiconsole.cpp
+++ b/third_party/unrar/src/uiconsole.cpp
@@ -333,6 +333,8 @@ void uiMsgStore::Msg()
     case UIEVENT_RRTESTINGSTART:
       mprintf(L"%s      ",St(MTestingRR));
       break;
+    default:
+      break;
   }
 }
 
diff --git a/third_party/unrar/src/unicode.cpp b/third_party/unrar/src/unicode.cpp
index 9f002ac8dd1c..8d01e73eb1a0 100644
--- a/third_party/unrar/src/unicode.cpp
+++ b/third_party/unrar/src/unicode.cpp
@@ -70,7 +70,7 @@ bool WideToChar(const wchar *Src,char *Dest,size_t DestSize)
 #endif
   if (DestSize>0)
     Dest[DestSize-1]=0;
-  
+
   // We tried to return the empty string if conversion is failed,
   // but it does not work well. WideCharToMultiByte returns 'failed' code
   // and partially converted string even if we wanted to convert only a part
@@ -129,7 +129,7 @@ bool CharToWide(const char *Src,wchar *Dest,size_t DestSize)
 
 
 #if defined(_UNIX) && defined(MBFUNCTIONS)
-// Convert and restore mapped inconvertible Unicode characters. 
+// Convert and restore mapped inconvertible Unicode characters.
 // We use it for extended ASCII names in Unix.
 bool WideToCharMap(const wchar *Src,char *Dest,size_t DestSize,bool &Success)
 {
@@ -173,7 +173,7 @@ bool WideToCharMap(const wchar *Src,char *Dest,size_t DestSize,bool &Success)
 
 
 #if defined(_UNIX) && defined(MBFUNCTIONS)
-// Convert and map inconvertible Unicode characters. 
+// Convert and map inconvertible Unicode characters.
 // We use it for extended ASCII names in Unix.
 void CharToWideMap(const char *Src,wchar *Dest,size_t DestSize,bool &Success)
 {
@@ -299,7 +299,7 @@ size_t WideToUtfSize(const wchar *Src)
       if (*Src<0x800)
         Size+=2;
       else
-        if (*Src<0x10000)
+        if ((uint)*Src<0x10000)
         {
           if (Src[0]>=0xd800 && Src[0]<=0xdbff && Src[1]>=0xdc00 && Src[1]<=0xdfff)
           {
@@ -310,7 +310,7 @@ size_t WideToUtfSize(const wchar *Src)
             Size+=3;
         }
         else
-          if (*Src<0x200000)
+          if ((uint)*Src<0x200000)
             Size+=4;
   return Size+1; // Include terminating zero.
 }
diff --git a/third_party/unrar/src/unpack.cpp b/third_party/unrar/src/unpack.cpp
index 0163c49fed3a..1cda19c44501 100644
--- a/third_party/unrar/src/unpack.cpp
+++ b/third_party/unrar/src/unpack.cpp
@@ -94,6 +94,7 @@ void Unpack::Init(size_t WinSize,bool Solid)
   byte *NewWindow=Fragmented ? NULL : (byte *)malloc(WinSize);
 
   if (NewWindow==NULL)
+  {
     if (Grow || WinSize<0x1000000)
     {
       // We do not support growth for new fragmented window.
@@ -110,6 +111,7 @@ void Unpack::Init(size_t WinSize,bool Solid)
       FragWindow.Init(WinSize);
       Fragmented=true;
     }
+  }
 
   if (!Fragmented)
   {
diff --git a/third_party/unrar/src/unpack15.cpp b/third_party/unrar/src/unpack15.cpp
index 1e7cf76c2d77..78b0130d05b6 100644
--- a/third_party/unrar/src/unpack15.cpp
+++ b/third_party/unrar/src/unpack15.cpp
@@ -293,6 +293,7 @@ void Unpack::LongLZ()
 
   OldAvr3=AvrLn3;
   if (Length!=1 && Length!=4)
+  {
     if (Length==0 && Distance <= MaxDist3)
     {
       AvrLn3++;
@@ -301,12 +302,13 @@ void Unpack::LongLZ()
     else
       if (AvrLn3 > 0)
         AvrLn3--;
+  }
   Length+=3;
   if (Distance >= MaxDist3)
     Length++;
   if (Distance <= 256)
     Length+=8;
-  if (OldAvr3 > 0xb0 || AvrPlc >= 0x2a00 && OldAvr2 < 0x40)
+  if (OldAvr3 > 0xb0 || (AvrPlc >= 0x2a00 && OldAvr2 < 0x40))
     MaxDist3=0x7f00;
   else
     MaxDist3=0x2001;
diff --git a/third_party/unrar/src/unpack20.cpp b/third_party/unrar/src/unpack20.cpp
index a7a41c34afbf..fe0ec6aa0c07 100644
--- a/third_party/unrar/src/unpack20.cpp
+++ b/third_party/unrar/src/unpack20.cpp
@@ -256,6 +256,7 @@ bool Unpack::ReadTables20()
 void Unpack::ReadLastTables()
 {
   if (ReadTop>=Inp.InAddr+5)
+  {
     if (UnpAudioBlock)
     {
       if (DecodeNumber(Inp,&MD[UnpCurChannel])==256)
@@ -264,6 +265,7 @@ void Unpack::ReadLastTables()
     else
       if (DecodeNumber(Inp,&BlockTables.LD)==269)
         ReadTables20();
+  }
 }
 
 
diff --git a/third_party/unrar/src/unpack50.cpp b/third_party/unrar/src/unpack50.cpp
index dac1f6fd3180..1c96b1d5b1ed 100644
--- a/third_party/unrar/src/unpack50.cpp
+++ b/third_party/unrar/src/unpack50.cpp
@@ -11,7 +11,7 @@ void Unpack::Unpack5(bool Solid)
     // Check TablesRead5 to be sure that we read tables at least once
     // regardless of current block header TablePresent flag.
     // So we can safefly use these tables below.
-    if (!ReadBlockHeader(Inp,BlockHeader) || 
+    if (!ReadBlockHeader(Inp,BlockHeader) ||
         !ReadTables(Inp,BlockHeader,BlockTables) || !TablesRead5)
       return;
   }
@@ -26,9 +26,9 @@ void Unpack::Unpack5(bool Solid)
 
       // We use 'while', because for empty block containing only Huffman table,
       // we'll be on the block border once again just after reading the table.
-      while (Inp.InAddr>BlockHeader.BlockStart+BlockHeader.BlockSize-1 || 
-             Inp.InAddr==BlockHeader.BlockStart+BlockHeader.BlockSize-1 && 
-             Inp.InBit>=BlockHeader.BlockBitSize)
+      while (Inp.InAddr>BlockHeader.BlockStart+BlockHeader.BlockSize-1 ||
+             (Inp.InAddr==BlockHeader.BlockStart+BlockHeader.BlockSize-1 &&
+             Inp.InBit>=BlockHeader.BlockBitSize))
       {
         if (BlockHeader.LastBlockInFile)
         {
@@ -127,10 +127,12 @@ void Unpack::Unpack5(bool Solid)
     if (MainSlot==257)
     {
       if (LastLength!=0)
+      {
         if (Fragmented)
           FragWindow.CopyString(LastLength,OldDist[0],UnpPtr,MaxWinMask);
         else
           CopyString(LastLength,OldDist[0]);
+      }
       continue;
     }
     if (MainSlot<262)
@@ -389,8 +391,8 @@ void Unpack::UnpWriteBuf()
 
   // Choose the nearest among WriteBorder and WrPtr actual written border.
   // If border is equal to UnpPtr, it means that we have MaxWinSize data ahead.
-  if (WriteBorder==UnpPtr || 
-      WrPtr!=UnpPtr && ((WrPtr-UnpPtr)&MaxWinMask)<((WriteBorder-UnpPtr)&MaxWinMask))
+  if (WriteBorder==UnpPtr ||
+      (WrPtr!=UnpPtr && ((WrPtr-UnpPtr)&MaxWinMask)<((WriteBorder-UnpPtr)&MaxWinMask)))
     WriteBorder=WrPtr;
 }
 
@@ -536,11 +538,11 @@ bool Unpack::ReadBlockHeader(BitInput &Inp,UnpackBlockHeader &Header)
     if (!UnpReadBuf())
       return false;
   Inp.faddbits((8-Inp.InBit)&7);
-  
+
   byte BlockFlags=Inp.fgetbits()>>8;
   Inp.faddbits(8);
   uint ByteCount=((BlockFlags>>3)&3)+1; // Block size byte count.
-  
+
   if (ByteCount==4)
     return false;
 
diff --git a/third_party/unrar/src/unpack50frag.cpp b/third_party/unrar/src/unpack50frag.cpp
index 745b1b3083a3..3c008ff24539 100644
--- a/third_party/unrar/src/unpack50frag.cpp
+++ b/third_party/unrar/src/unpack50frag.cpp
@@ -48,7 +48,7 @@ void FragmentedWindow::Init(size_t WinSize)
     }
     if (NewMem==NULL)
       throw std::bad_alloc();
-    
+
     // Clean the window to generate the same output when unpacking corrupt
     // RAR files, which may access to unused areas of sliding dictionary.
     memset(NewMem,0,Size);
diff --git a/third_party/unrar/src/unpack50mt.cpp b/third_party/unrar/src/unpack50mt.cpp
index 59e111ba2ca7..e41da79b5ea1 100644
--- a/third_party/unrar/src/unpack50mt.cpp
+++ b/third_party/unrar/src/unpack50mt.cpp
@@ -134,7 +134,7 @@ void Unpack::Unpack5MT(bool Solid)
         {
           CurData->HeaderRead=true;
           if (!ReadBlockHeader(CurData->Inp,CurData->BlockHeader) ||
-              !CurData->BlockHeader.TablePresent && !TablesRead5)
+              (!CurData->BlockHeader.TablePresent && !TablesRead5))
           {
             Done=true;
             break;
@@ -165,7 +165,7 @@ void Unpack::Unpack5MT(bool Solid)
         if (DataLeft<TooSmallToProcess)
           break;
       }
-      
+
 //#undef USE_THREADS
       UnpackThreadDataList UTDArray[MaxPoolThreads];
       uint UTDArrayPos=0;
@@ -180,7 +180,7 @@ void Unpack::Unpack5MT(bool Solid)
         UnpackThreadDataList *UTD=UTDArray+UTDArrayPos++;
         UTD->D=UnpThreadData+CurBlock;
         UTD->BlockCount=Min(MaxBlockPerThread,BlockNumberMT-CurBlock);
-      
+
 #ifdef USE_THREADS
         if (BlockNumber==1)
           UnpackDecode(*UTD->D);
@@ -200,12 +200,12 @@ void Unpack::Unpack5MT(bool Solid)
 #endif
 
       bool IncompleteThread=false;
-      
+
       for (uint Block=0;Block<BlockNumber;Block++)
       {
         UnpackThreadData *CurData=UnpThreadData+Block;
-        if (!CurData->LargeBlock && !ProcessDecoded(*CurData) ||
-            CurData->LargeBlock && !UnpackLargeBlock(*CurData) ||
+        if ((!CurData->LargeBlock && !ProcessDecoded(*CurData)) ||
+            (CurData->LargeBlock && !UnpackLargeBlock(*CurData)) ||
             CurData->DamagedData)
         {
           Done=true;
@@ -251,7 +251,7 @@ void Unpack::Unpack5MT(bool Solid)
             break;
           }
       }
-      
+
       if (IncompleteThread || Done)
         break; // Current buffer is done, read more data or quit.
       else
@@ -303,7 +303,7 @@ void Unpack::UnpackDecode(UnpackThreadData &D)
     D.DamagedData=true;
     return;
   }
-  
+
   D.DecodedSize=0;
   int BlockBorder=D.BlockHeader.BlockStart+D.BlockHeader.BlockSize-1;
 
@@ -315,14 +315,14 @@ void Unpack::UnpackDecode(UnpackThreadData &D)
   {
     if (D.Inp.InAddr>=ReadBorder)
     {
-      if (D.Inp.InAddr>BlockBorder || D.Inp.InAddr==BlockBorder && 
-          D.Inp.InBit>=D.BlockHeader.BlockBitSize)
+      if (D.Inp.InAddr>BlockBorder || (D.Inp.InAddr==BlockBorder &&
+          D.Inp.InBit>=D.BlockHeader.BlockBitSize))
         break;
 
       // If we do not have any more data in file to read, we must process
       // what we have until last byte. Otherwise we can return and append
       // more data to unprocessed few bytes.
-      if ((D.Inp.InAddr>=DataBorder) && !D.NoDataLeft || D.Inp.InAddr>=D.DataSize)
+      if ((D.Inp.InAddr>=DataBorder && !D.NoDataLeft) || D.Inp.InAddr>=D.DataSize)
       {
         D.Incomplete=true;
         break;
@@ -413,7 +413,7 @@ void Unpack::UnpackDecode(UnpackThreadData &D)
     {
       UnpackFilter Filter;
       ReadFilter(D.Inp,Filter);
-      
+
       CurItem->Type=UNPDT_FILTER;
       CurItem->Length=Filter.Type;
       CurItem->Distance=Filter.BlockStart;
@@ -498,7 +498,7 @@ bool Unpack::ProcessDecoded(UnpackThreadData &D)
             if (Item->Type==UNPDT_FILTER)
             {
               UnpackFilter Filter;
-              
+
               Filter.Type=(byte)Item->Length;
               Filter.BlockStart=Item->Distance;
 
@@ -534,7 +534,7 @@ bool Unpack::UnpackLargeBlock(UnpackThreadData &D)
     D.DamagedData=true;
     return false;
   }
-  
+
   int BlockBorder=D.BlockHeader.BlockStart+D.BlockHeader.BlockSize-1;
 
   // Reserve enough space even for filter entry.
@@ -546,14 +546,14 @@ bool Unpack::UnpackLargeBlock(UnpackThreadData &D)
     UnpPtr&=MaxWinMask;
     if (D.Inp.InAddr>=ReadBorder)
     {
-      if (D.Inp.InAddr>BlockBorder || D.Inp.InAddr==BlockBorder && 
-          D.Inp.InBit>=D.BlockHeader.BlockBitSize)
+      if (D.Inp.InAddr>BlockBorder || (D.Inp.InAddr==BlockBorder &&
+          D.Inp.InBit>=D.BlockHeader.BlockBitSize))
         break;
 
       // If we do not have any more data in file to read, we must process
       // what we have until last byte. Otherwise we can return and append
       // more data to unprocessed few bytes.
-      if ((D.Inp.InAddr>=DataBorder) && !D.NoDataLeft || D.Inp.InAddr>=D.DataSize)
+      if ((D.Inp.InAddr>=DataBorder && !D.NoDataLeft) || D.Inp.InAddr>=D.DataSize)
       {
         D.Incomplete=true;
         break;
diff --git a/third_party/unrar/src/volume.cpp b/third_party/unrar/src/volume.cpp
index 5d9c4c50a7d0..c175b3b2281b 100644
--- a/third_party/unrar/src/volume.cpp
+++ b/third_party/unrar/src/volume.cpp
@@ -19,7 +19,7 @@ bool MergeArchive(Archive &Arc,ComprDataIO *DataIO,bool ShowFileName,wchar Comma
   if (DataIO!=NULL && SplitHeader)
   {
     bool PackedHashPresent=Arc.Format==RARFMT50 || 
-         hd->UnpVer>=20 && hd->FileHash.CRC32!=0xffffffff;
+         (hd->UnpVer>=20 && hd->FileHash.CRC32!=0xffffffff);
     if (PackedHashPresent && 
         !DataIO->PackedDataHash.Cmp(&hd->FileHash,hd->UseHashKey ? hd->HashKey:NULL))
       uiMsg(UIERROR_CHECKSUMPACKED, Arc.FileName, hd->FileName);
