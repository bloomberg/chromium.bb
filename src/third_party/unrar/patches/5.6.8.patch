diff --git a/third_party/unrar/src/arccmt.cpp b/third_party/unrar/src/arccmt.cpp
index ca98b10706f4..487e2fc5068a 100644
--- a/third_party/unrar/src/arccmt.cpp
+++ b/third_party/unrar/src/arccmt.cpp
@@ -1,5 +1,3 @@
-static bool IsAnsiEscComment(const wchar *Data,size_t Size);
-
 bool Archive::GetComment(Array<wchar> *CmtData)
 {
   if (!MainComment)
@@ -43,7 +41,7 @@ bool Archive::GetComment(Array<wchar> *CmtData)
 #endif
   }
 #ifndef SFX_MODULE
-  if (Format==RARFMT14 && MainHead.PackComment || Format!=RARFMT14 && CommHead.Method!=0x30)
+  if ((Format==RARFMT14 && MainHead.PackComment) || (Format!=RARFMT14 && CommHead.Method!=0x30))
   {
     if (Format!=RARFMT14 && (CommHead.UnpVer < 15 || CommHead.UnpVer > VER_UNPACK || CommHead.Method > 0x35))
       return false;
diff --git a/third_party/unrar/src/archive.cpp b/third_party/unrar/src/archive.cpp
index f07ed05c1666..bb71254d5ff3 100644
--- a/third_party/unrar/src/archive.cpp
+++ b/third_party/unrar/src/archive.cpp
@@ -100,6 +100,7 @@ RARFORMAT Archive::IsSignature(const byte *D,size_t Size)
 {
   RARFORMAT Type=RARFMT_NONE;
   if (Size>=1 && D[0]==0x52)
+  {
 #ifndef SFX_MODULE
     if (Size>=4 && D[1]==0x45 && D[2]==0x7e && D[3]==0x5e)
       Type=RARFMT14;
@@ -119,6 +120,7 @@ RARFORMAT Archive::IsSignature(const byte *D,size_t Size)
             if (D[6]>1 && D[6]<5)
               Type=RARFMT_FUTURE;
       }
+  }
   return Type;
 }
 
@@ -203,7 +205,7 @@ bool Archive::IsArchive(bool EnableBroken)
     HEADER_TYPE Type=GetHeaderType();
     // In RAR 5.0 we need to quit after reading HEAD_CRYPT if we wish to
     // avoid the password prompt.
-    StartFound=Type==HEAD_MAIN || SilentOpen && Type==HEAD_CRYPT;
+    StartFound=Type==HEAD_MAIN || (SilentOpen && Type==HEAD_CRYPT);
     if (StartFound)
       break;
   }
@@ -335,3 +337,12 @@ int64 Archive::Tell()
 }
 #endif
 
+#if defined(CHROMIUM_UNRAR)
+void Archive::SetTempFileHandle(FileHandle hF) {
+  hTempFile = hF;
+}
+
+FileHandle Archive::GetTempFileHandle() {
+  return hTempFile;
+}
+#endif
diff --git a/third_party/unrar/src/archive.hpp b/third_party/unrar/src/archive.hpp
index fd33ac359adb..a1f5e66569db 100644
--- a/third_party/unrar/src/archive.hpp
+++ b/third_party/unrar/src/archive.hpp
@@ -58,6 +58,14 @@ class Archive:public File
     QuickOpen QOpen;
     bool ProhibitQOpen;
 #endif
+#ifdef USE_ARCMEM
+    ArcMemory ArcMem;
+#endif
+
+#if defined(CHROMIUM_UNRAR)
+    FileHandle hTempFile;
+#endif
+
   public:
     Archive(RAROptions *InitCmd=NULL);
     ~Archive();
@@ -99,6 +107,10 @@ class Archive:public File
     void QOpenUnload() {QOpen.Unload();}
     void SetProhibitQOpen(bool Mode) {ProhibitQOpen=Mode;}
 #endif
+#if defined(CHROMIUM_UNRAR)
+    void SetTempFileHandle(FileHandle hF);
+    FileHandle GetTempFileHandle();
+#endif
 
     BaseBlock ShortBlock;
     MarkHeader MarkHead;
diff --git a/third_party/unrar/src/arcread.cpp b/third_party/unrar/src/arcread.cpp
index c8cb1ee53aba..7eec01d7eb0f 100644
--- a/third_party/unrar/src/arcread.cpp
+++ b/third_party/unrar/src/arcread.cpp
@@ -10,7 +10,7 @@ size_t Archive::ReadHeader()
 
   CurBlockPos=Tell();
 
-  size_t ReadSize;
+  size_t ReadSize = 0;
   switch(Format)
   {
 #ifndef SFX_MODULE
@@ -24,6 +24,9 @@ size_t Archive::ReadHeader()
     case RARFMT50:
       ReadSize=ReadHeader50();
       break;
+    case RARFMT_NONE:
+    case RARFMT_FUTURE:
+      break;
   }
 
   // It is important to check ReadSize>0 here, because it is normal
@@ -139,7 +142,8 @@ size_t Archive::ReadHeader15()
 
   if (Decrypt)
   {
-#ifdef RAR_NOCRYPT // For rarext.dll and unrar_nocrypt.dll.
+#if defined(RAR_NOCRYPT) || \
+    defined(CHROMIUM_UNRAR)  // For rarext.dll and unrar_nocrypt.dll.
     return 0;
 #else
     RequestArcPassword();
@@ -187,6 +191,7 @@ size_t Archive::ReadHeader15()
     case HEAD3_FILE:    ShortBlock.HeaderType=HEAD_FILE;     break;
     case HEAD3_SERVICE: ShortBlock.HeaderType=HEAD_SERVICE;  break;
     case HEAD3_ENDARC:  ShortBlock.HeaderType=HEAD_ENDARC;   break;
+    default:                                                 break;
   }
   CurHeaderType=ShortBlock.HeaderType;
 
@@ -201,7 +206,7 @@ size_t Archive::ReadHeader15()
     if (ShortBlock.HeaderType==HEAD_MAIN && (ShortBlock.Flags & MHD_COMMENT)!=0)
     {
       // Old style (up to RAR 2.9) main archive comment embedded into
-      // the main archive header found. While we can read the entire 
+      // the main archive header found. While we can read the entire
       // ShortBlock.HeadSize here and remove this part of "if", it would be
       // waste of memory, because we'll read and process this comment data
       // in other function anyway and we do not need them here now.
@@ -227,7 +232,7 @@ size_t Archive::ReadHeader15()
       Encrypted=(MainHead.Flags & MHD_PASSWORD)!=0;
       Signed=MainHead.PosAV!=0 || MainHead.HighPosAV!=0;
       MainHead.CommentInHeader=(MainHead.Flags & MHD_COMMENT)!=0;
-    
+
       // Only for encrypted 3.0+ archives. 2.x archives did not have this
       // flag, so for non-encrypted archives, we'll set it later based on
       // file attributes.
@@ -254,7 +259,7 @@ size_t Archive::ReadHeader15()
         hd->WinSize=hd->Dir ? 0:0x10000<<((hd->Flags & LHD_WINDOWMASK)>>5);
         hd->CommentInHeader=(hd->Flags & LHD_COMMENT)!=0;
         hd->Version=(hd->Flags & LHD_VERSION)!=0;
-        
+
         hd->DataSize=Raw.Get4();
         uint LowUnpSize=Raw.Get4();
         hd->HostOS=Raw.Get1();
@@ -279,7 +284,7 @@ size_t Archive::ReadHeader15()
           {
             case 13: hd->CryptMethod=CRYPT_RAR13; break;
             case 15: hd->CryptMethod=CRYPT_RAR15; break;
-            case 20: 
+            case 20:
             case 26: hd->CryptMethod=CRYPT_RAR20; break;
             default: hd->CryptMethod=CRYPT_RAR30; break;
           }
@@ -301,7 +306,7 @@ size_t Archive::ReadHeader15()
         }
 
         hd->Inherited=!FileBlock && (hd->SubFlags & SUBHEAD_FLAGS_INHERITED)!=0;
-        
+
         hd->LargeFile=(hd->Flags & LHD_LARGE)!=0;
 
         uint HighPackSize,HighUnpSize;
@@ -311,7 +316,7 @@ size_t Archive::ReadHeader15()
           HighUnpSize=Raw.Get4();
           hd->UnknownUnpSize=(LowUnpSize==0xffffffff && HighUnpSize==0xffffffff);
         }
-        else 
+        else
         {
           HighPackSize=HighUnpSize=0;
           // UnpSize equal to 0xffffffff without LHD_LARGE flag indicates
@@ -506,7 +511,7 @@ size_t Archive::ReadHeader15()
         NextBlockPos+=Raw.Get4();
       break;
   }
-  
+
   ushort HeaderCRC=Raw.GetCRC15(false);
 
   // Old AV header does not have header CRC properly set.
@@ -552,7 +557,7 @@ size_t Archive::ReadHeader50()
 
   if (Decrypt)
   {
-#if defined(RAR_NOCRYPT)
+#if defined(RAR_NOCRYPT) || defined(CHROMIUM_UNRAR)
     return 0;
 #else
 
@@ -641,7 +646,7 @@ size_t Archive::ReadHeader50()
     BrokenHeaderMsg();
     return 0;
   }
-  
+
   Raw.Read(SizeToRead);
 
   if (Raw.Size()<HeaderSize)
@@ -674,7 +679,7 @@ size_t Archive::ReadHeader50()
       return 0;
     }
   }
-  
+
   uint64 ExtraSize=0;
   if ((ShortBlock.Flags & HFL_EXTRA)!=0)
   {
@@ -763,7 +768,7 @@ size_t Archive::ReadHeader50()
           // to not break normal archive processing by calling function.
           int64 SaveCurBlockPos=CurBlockPos,SaveNextBlockPos=NextBlockPos;
           HEADER_TYPE SaveCurHeaderType=CurHeaderType;
-          
+
           QOpen.Init(this,false);
           QOpen.Load(MainHead.QOpenOffset);
 
@@ -788,7 +793,7 @@ size_t Archive::ReadHeader50()
         hd->PackSize=DataSize;
         hd->FileFlags=(uint)Raw.GetV();
         hd->UnpSize=Raw.GetV();
-        
+
         hd->UnknownUnpSize=(hd->FileFlags & FHFL_UNPUNKNOWN)!=0;
         if (hd->UnknownUnpSize)
           hd->UnpSize=INT64NDF;
@@ -875,7 +880,7 @@ size_t Archive::ReadHeader50()
           RecoverySize=Header.RecSectionSize*Header.RecCount;
         }
 #endif
-          
+
         if (BadCRC) // Add the file name to broken header message displayed above.
           uiMsg(UIERROR_FHEADERBROKEN,Archive::FileName,hd->FileName);
       }
@@ -890,6 +895,8 @@ size_t Archive::ReadHeader50()
         EndArcHead.RevSpace=false;
       }
       break;
+    default:
+      break;
   }
 
   return Raw.Size();
@@ -1054,20 +1061,26 @@ void Archive::ProcessExtra50(RawRead *Raw,size_t ExtraSize,BaseBlock *bb)
             byte Flags=(byte)Raw->GetV();
             bool UnixTime=(Flags & FHEXTRA_HTIME_UNIXTIME)!=0;
             if ((Flags & FHEXTRA_HTIME_MTIME)!=0)
+            {
               if (UnixTime)
                 hd->mtime.SetUnix(Raw->Get4());
               else
                 hd->mtime.SetWin(Raw->Get8());
+            }
             if ((Flags & FHEXTRA_HTIME_CTIME)!=0)
+            {
               if (UnixTime)
                 hd->ctime.SetUnix(Raw->Get4());
               else
                 hd->ctime.SetWin(Raw->Get8());
+            }
             if ((Flags & FHEXTRA_HTIME_ATIME)!=0)
+            {
               if (UnixTime)
                 hd->atime.SetUnix((time_t)Raw->Get4());
               else
                 hd->atime.SetWin(Raw->Get8());
+            }
             if (UnixTime && (Flags & FHEXTRA_HTIME_UNIX_NS)!=0) // Add nanoseconds.
             {
               uint ns;
@@ -1292,7 +1305,7 @@ void Archive::ConvertAttributes()
 
   if (mask == (mode_t) -1)
   {
-    // umask call returns the current umask value. Argument (022) is not 
+    // umask call returns the current umask value. Argument (022) is not
     // really important here.
     mask = umask(022);
 
@@ -1341,10 +1354,12 @@ void Archive::ConvertAttributes()
 void Archive::ConvertFileHeader(FileHeader *hd)
 {
   if (hd->HSType==HSYS_UNKNOWN)
+  {
     if (hd->Dir)
       hd->FileAttr=0x10;
     else
       hd->FileAttr=0x20;
+  }
 
 #ifdef _WIN_ALL
   if (hd->HSType==HSYS_UNIX) // Convert Unix, OS X and Android decomposed chracters to Windows precomposed.
@@ -1369,8 +1384,8 @@ void Archive::ConvertFileHeader(FileHeader *hd)
 
     // ':' in file names is allowed in Unix, but not in Windows.
     // Even worse, file data will be written to NTFS stream on NTFS,
-    // so automatic name correction on file create error in extraction 
-    // routine does not work. In Windows and DOS versions we better 
+    // so automatic name correction on file create error in extraction
+    // routine does not work. In Windows and DOS versions we better
     // replace ':' now.
     if (*s==':')
       *s='_';
@@ -1382,7 +1397,7 @@ void Archive::ConvertFileHeader(FileHeader *hd)
     // Still, RAR 4.x uses backslashes as path separator even in Unix.
     // Forward slash is not allowed in both systems. In RAR 5.0 we use
     // the forward slash as universal path separator.
-    if (*s=='/' || *s=='\\' && Format!=RARFMT50)
+    if (*s=='/' || (*s=='\\' && Format!=RARFMT50))
       *s=CPATHDIVIDER;
   }
 }
@@ -1437,12 +1452,14 @@ bool Archive::ReadSubData(Array<byte> *UnpData,File *DestFile)
     }
   }
   if (SubHead.Encrypted)
+  {
     if (Cmd->Password.IsSet())
       SubDataIO.SetEncryption(false,SubHead.CryptMethod,&Cmd->Password,
                 SubHead.SaltSet ? SubHead.Salt:NULL,SubHead.InitV,
                 SubHead.Lg2Count,SubHead.HashKey,SubHead.PswCheck);
     else
       return false;
+  }
   SubDataIO.UnpHash.Init(SubHead.FileHash.Type,1);
   SubDataIO.SetPackedSizeToRead(SubHead.PackSize);
   SubDataIO.EnableShowProgress(false);
diff --git a/third_party/unrar/src/cmddata.cpp b/third_party/unrar/src/cmddata.cpp
index 32b841241e1d..e0c286df6ed4 100644
--- a/third_party/unrar/src/cmddata.cpp
+++ b/third_party/unrar/src/cmddata.cpp
@@ -766,10 +766,11 @@ void CommandData::ProcessSwitch(const wchar *Switch)
                   AlreadyBad=true;
                   break;
               };
-              if (!AlreadyBad)
+              if (!AlreadyBad) {
                 if (Switch[3]==0)
                   CommentCharset=FilelistCharset=ErrlogCharset=RedirectCharset=rch;
                 else
+                {
                   for (uint I=3;Switch[I]!=0 && !AlreadyBad;I++)
                     switch(toupperw(Switch[I]))
                     {
@@ -787,6 +788,8 @@ void CommandData::ProcessSwitch(const wchar *Switch)
                         AlreadyBad=true;
                         break;
                     }
+                }
+              }
               // Set it immediately when parsing the command line, so it also
               // affects messages issued while parsing the command line.
               SetConsoleRedirectCharset(RedirectCharset);
@@ -1205,7 +1208,7 @@ int CommandData::IsProcessFile(FileHeader &FileHead,bool *ExactMatch,int MatchTy
 #ifndef SFX_MODULE
   if (TimeCheck(FileHead.mtime))
     return 0;
-  if ((FileHead.FileAttr & ExclFileAttr)!=0 || InclAttrSet && (FileHead.FileAttr & InclFileAttr)==0)
+  if ((FileHead.FileAttr & ExclFileAttr)!=0 || (InclAttrSet && (FileHead.FileAttr & InclFileAttr)==0))
     return 0;
   if (!Dir && SizeCheck(FileHead.UnpSize))
     return 0;
@@ -1230,7 +1233,7 @@ void CommandData::ProcessCommand()
 #ifndef SFX_MODULE
 
   const wchar *SingleCharCommands=L"FUADPXETK";
-  if (Command[0]!=0 && Command[1]!=0 && wcschr(SingleCharCommands,Command[0])!=NULL || *ArcName==0)
+  if ((Command[0]!=0 && Command[1]!=0 && wcschr(SingleCharCommands,Command[0])!=NULL) || *ArcName==0)
     OutHelp(*Command==0 ? RARX_SUCCESS:RARX_USERERROR); // Return 'success' for 'rar' without parameters.
 
   const wchar *ArcExt=GetExt(ArcName);
diff --git a/third_party/unrar/src/consio.cpp b/third_party/unrar/src/consio.cpp
index 196066ec9630..39c9014503ae 100644
--- a/third_party/unrar/src/consio.cpp
+++ b/third_party/unrar/src/consio.cpp
@@ -70,7 +70,7 @@ static void cvt_wprintf(FILE *dest,const wchar *fmt,va_list arglist)
   PrintfPrepareFmt(fmt,fmtw,ASIZE(fmtw));
 #ifdef _WIN_ALL
   safebuf wchar Msg[MaxMsgSize];
-  if (dest==stdout && StdoutRedirected || dest==stderr && StderrRedirected)
+  if ((dest==stdout && StdoutRedirected) || (dest==stderr && StderrRedirected))
   {
     HANDLE hOut=GetStdHandle(dest==stdout ? STD_OUTPUT_HANDLE:STD_ERROR_HANDLE);
     vswprintf(Msg,ASIZE(Msg),fmtw,arglist);
@@ -191,10 +191,16 @@ bool GetConsolePassword(UIPASSWORD_TYPE Type,const wchar *FileName,SecPassword *
   while (true)
   {
     if (!StdinRedirected)
+    {
       if (Type==UIPASSWORD_GLOBAL)
+      {
         eprintf(L"\n%s: ",St(MAskPsw));
+      }
       else
+      {
         eprintf(St(MAskPswFor),FileName);
+      }
+    }
 
     wchar PlainPsw[MAXPASSWORD];
     GetPasswordText(PlainPsw,ASIZE(PlainPsw));
diff --git a/third_party/unrar/src/crc.cpp b/third_party/unrar/src/crc.cpp
index 1097f4cd00d1..8488e102c28e 100644
--- a/third_party/unrar/src/crc.cpp
+++ b/third_party/unrar/src/crc.cpp
@@ -15,6 +15,7 @@
 #include "rar.hpp"
 
 static uint crc_tables[8][256]; // Tables for Slicing-by-8.
+static bool is_initialized = false;
 
 
 // Build the classic CRC32 lookup table.
@@ -49,10 +50,13 @@ static void InitTables()
 }
 
 
-struct CallInitCRC {CallInitCRC() {InitTables();}} static CallInit32;
-
 uint CRC32(uint StartCRC,const void *Addr,size_t Size)
 {
+  if (!is_initialized) {
+    is_initialized = true;
+    InitTables();
+  }
+
   byte *Data=(byte *)Addr;
 
   // Align Data to 8 for better performance.
diff --git a/third_party/unrar/src/crypt.cpp b/third_party/unrar/src/crypt.cpp
index fc2126d46c17..785b5faea53d 100644
--- a/third_party/unrar/src/crypt.cpp
+++ b/third_party/unrar/src/crypt.cpp
@@ -48,6 +48,8 @@ void CryptData::DecryptBlock(byte *Buf,size_t Size)
     case CRYPT_RAR50:
       rin.blockDecrypt(Buf,Size,Buf);
       break;
+    case CRYPT_NONE:
+      break;
   }
 }
 
@@ -85,6 +87,8 @@ bool CryptData::SetCryptKeys(bool Encrypt,CRYPT_METHOD Method,
     case CRYPT_RAR50:
       SetKey50(Encrypt,Password,PwdW,Salt,InitV,Lg2Cnt,HashKey,PswCheck);
       break;
+    case CRYPT_NONE:
+      break;
   }
   cleandata(PwdA,sizeof(PwdA));
   cleandata(PwdW,sizeof(PwdW));
diff --git a/third_party/unrar/src/crypt3.cpp b/third_party/unrar/src/crypt3.cpp
index 48406487e7bf..93467aa3b92d 100644
--- a/third_party/unrar/src/crypt3.cpp
+++ b/third_party/unrar/src/crypt3.cpp
@@ -5,8 +5,8 @@ void CryptData::SetKey30(bool Encrypt,SecPassword *Password,const wchar *PwdW,co
   bool Cached=false;
   for (uint I=0;I<ASIZE(KDF3Cache);I++)
     if (KDF3Cache[I].Pwd==*Password &&
-        (Salt==NULL && !KDF3Cache[I].SaltPresent || Salt!=NULL &&
-        KDF3Cache[I].SaltPresent && memcmp(KDF3Cache[I].Salt,Salt,SIZE_SALT30)==0))
+        ((Salt==NULL && !KDF3Cache[I].SaltPresent) || (Salt!=NULL &&
+        KDF3Cache[I].SaltPresent && memcmp(KDF3Cache[I].Salt,Salt,SIZE_SALT30)==0)))
     {
       memcpy(AESKey,KDF3Cache[I].Key,sizeof(AESKey));
       SecHideData(AESKey,sizeof(AESKey),false,false);
@@ -65,4 +65,3 @@ void CryptData::SetKey30(bool Encrypt,SecPassword *Password,const wchar *PwdW,co
   cleandata(AESKey,sizeof(AESKey));
   cleandata(AESInit,sizeof(AESInit));
 }
-
diff --git a/third_party/unrar/src/errhnd.cpp b/third_party/unrar/src/errhnd.cpp
index c867f1fca194..acd2d510384d 100644
--- a/third_party/unrar/src/errhnd.cpp
+++ b/third_party/unrar/src/errhnd.cpp
@@ -1,10 +1,11 @@
-#include "rar.hpp"
-
-ErrorHandler::ErrorHandler()
-{
-  Clean();
-}
+// NOTE(vakh): The process.h file needs to be included first because "rar.hpp"
+// defines certain macros that cause symbol redefinition errors
+#if defined(UNRAR_NO_EXCEPTIONS)
+#include "base/logging.h"
+#include "base/process/process.h"
+#endif  // defined(UNRAR_NO_EXCEPTIONS)
 
+#include "rar.hpp"
 
 void ErrorHandler::Clean()
 {
@@ -322,7 +323,11 @@ void ErrorHandler::Throw(RAR_EXIT Code)
     mprintf(L"\n%s\n",St(MProgAborted));
 #endif
   SetErrorCode(Code);
+#if defined(UNRAR_NO_EXCEPTIONS)
+  CHECK(false) << "Failed with RAR_EXIT code: " << Code;
+#else
   throw Code;
+#endif  // defined(UNRAR_NO_EXCEPTIONS)
 }
 
 
diff --git a/third_party/unrar/src/errhnd.hpp b/third_party/unrar/src/errhnd.hpp
index eae591406ac2..24f7962159f9 100644
--- a/third_party/unrar/src/errhnd.hpp
+++ b/third_party/unrar/src/errhnd.hpp
@@ -21,13 +21,12 @@ enum RAR_EXIT // RAR exit code.
 class ErrorHandler
 {
   private:
-    RAR_EXIT ExitCode;
-    uint ErrCount;
-    bool EnableBreak;
-    bool Silent;
-    bool DisableShutdown; // Shutdown is not suitable after last error.
+    RAR_EXIT ExitCode = RARX_SUCCESS;
+    uint ErrCount = 0;
+    bool EnableBreak = true;
+    bool Silent = false;
+    bool DisableShutdown = false; // Shutdown is not suitable after last error.
   public:
-    ErrorHandler();
     void Clean();
     void MemoryError();
     void OpenError(const wchar *FileName);
@@ -64,8 +63,8 @@ class ErrorHandler
     void SetDisableShutdown() {DisableShutdown=true;}
     bool IsShutdownEnabled() {return !DisableShutdown;}
 
-    bool UserBreak; // Ctrl+Break is pressed.
-    bool MainExit; // main() is completed.
+    bool UserBreak = false; // Ctrl+Break is pressed.
+    bool MainExit = false; // main() is completed.
 };
 
 
diff --git a/third_party/unrar/src/extract.cpp b/third_party/unrar/src/extract.cpp
index 4540bd398452..3f4a2d442a7d 100644
--- a/third_party/unrar/src/extract.cpp
+++ b/third_party/unrar/src/extract.cpp
@@ -67,6 +67,7 @@ void CmdExtract::DoExtract()
   }
   else
     if (!Cmd->DisableDone)
+    {
       if (Cmd->Command[0]=='I')
         mprintf(St(MDone));
       else
@@ -74,6 +75,7 @@ void CmdExtract::DoExtract()
           mprintf(St(MExtrAllOk));
         else
           mprintf(St(MExtrTotalErr),ErrHandler.GetErrorCount());
+    }
 }
 
 
@@ -201,6 +203,7 @@ EXTRACT_ARC_CODE CmdExtract::ExtractArchive()
 
     bool Repeat=false;
     if (!ExtractCurrentFile(Arc,Size,Repeat))
+    {
       if (Repeat)
       {
         // If we started extraction from not first volume and need to
@@ -216,6 +219,7 @@ EXTRACT_ARC_CODE CmdExtract::ExtractArchive()
       }
       else
         break;
+    }
   }
 
 
@@ -232,6 +236,7 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
 {
   wchar Command=Cmd->Command[0];
   if (HeaderSize==0)
+  {
     if (DataIO.UnpVolume)
     {
 #ifdef NOVOLUME
@@ -248,6 +253,7 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
     }
     else
       return false;
+  }
 
   HEADER_TYPE HeaderType=Arc.GetHeaderType();
   if (HeaderType!=HEAD_FILE)
@@ -259,6 +265,7 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
     if (HeaderType==HEAD_SERVICE && PrevProcessed)
       SetExtraInfo(Cmd,Arc,DestFileName);
     if (HeaderType==HEAD_ENDARC)
+    {
       if (Arc.EndArcHead.NextVolume)
       {
 #ifndef NOVOLUME
@@ -273,6 +280,7 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
       }
       else
         return false;
+    }
     Arc.SeekToNext();
     return true;
   }
@@ -510,6 +518,9 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
 #endif
 
     File CurFile;
+#if defined(CHROMIUM_UNRAR)
+    CurFile.SetFileHandle(Arc.GetTempFileHandle());
+#endif
 
     bool LinkEntry=Arc.FileHead.RedirType!=FSREDIR_NONE;
     if (LinkEntry && Arc.FileHead.RedirType!=FSREDIR_FILECOPY)
@@ -573,6 +584,7 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
       }
       FileCount++;
       if (Command!='I')
+      {
         if (SkipSolid)
           mprintf(St(MExtrSkipFile),ArcFileName);
         else
@@ -591,6 +603,7 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
               mprintf(St(MExtrFile),DestFileName);
               break;
           }
+      }
       if (!Cmd->DisablePercentage)
         mprintf(L"     ");
 
@@ -634,10 +647,12 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
           wchar NameExisting[NM];
           ExtrPrepareName(Arc,Arc.FileHead.RedirName,NameExisting,ASIZE(NameExisting));
           if (FileCreateMode && *NameExisting!=0) // *NameExisting can be 0 in case of excessive -ap switch.
+          {
             if (Type==FSREDIR_HARDLINK)
               LinkSuccess=ExtractHardlink(DestFileName,NameExisting,ASIZE(NameExisting));
             else
               LinkSuccess=ExtractFileCopy(CurFile,Arc.FileName,DestFileName,NameExisting,ASIZE(NameExisting));
+          }
         }
         else
           if (Type==FSREDIR_UNIXSYMLINK || Type==FSREDIR_WINSYMLINK || Type==FSREDIR_JUNCTION)
@@ -651,7 +666,7 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
             LinkSuccess=false;
           }
           
-          if (!LinkSuccess || Arc.Format==RARFMT15 && !FileCreateMode)
+          if (!LinkSuccess || (Arc.Format==RARFMT15 && !FileCreateMode))
           {
             // RAR 5.x links have a valid data checksum even in case of
             // failure, because they do not store any data.
@@ -664,6 +679,7 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
       }
       else
         if (!Arc.FileHead.SplitBefore)
+        {
           if (Arc.FileHead.Method==0)
             UnstoreFile(DataIO,Arc.FileHead.UnpSize);
           else
@@ -677,6 +693,7 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
 #endif
               Unp->DoUnpack(Arc.FileHead.UnpVer,Arc.FileHead.Solid);
           }
+        }
 
       Arc.SeekToNext();
 
@@ -731,7 +748,7 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
         mprintf(L"\b\b\b\b\b     ");
 
       if (!TestMode && (Command=='X' || Command=='E') &&
-          (!LinkEntry || Arc.FileHead.RedirType==FSREDIR_FILECOPY && LinkSuccess) && 
+          (!LinkEntry || (Arc.FileHead.RedirType==FSREDIR_FILECOPY && LinkSuccess)) && 
           (!BrokenFile || Cmd->KeepBroken))
       {
         // We could preallocate more space that really written to broken file.
@@ -774,11 +791,13 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
   if (DataIO.NextVolumeMissing)
     return false;
   if (!ExtrFile)
+  {
     if (!Arc.Solid)
       Arc.SeekToNext();
     else
       if (!SkipSolid)
         return false;
+  }
   return true;
 }
 
diff --git a/third_party/unrar/src/file.cpp b/third_party/unrar/src/file.cpp
index e2bb42a616ad..b69a3122427b 100644
--- a/third_party/unrar/src/file.cpp
+++ b/third_party/unrar/src/file.cpp
@@ -23,10 +23,12 @@ File::File()
 File::~File()
 {
   if (hFile!=FILE_BAD_HANDLE && !SkipClose)
+  {
     if (NewFile)
       Delete();
     else
       Close();
+  }
 }
 
 
@@ -49,6 +51,11 @@ bool File::Open(const wchar *Name,uint Mode)
   bool UpdateMode=(Mode & FMF_UPDATE)!=0;
   bool WriteMode=(Mode & FMF_WRITE)!=0;
 #ifdef _WIN_ALL
+#if defined(CHROMIUM_UNRAR)
+  // Do not open a file handle since the sandbox doesn't allow it. Use the
+  // handle provided by the caller.
+  hNewFile = hOpenFile;
+#else
   uint Access=WriteMode ? GENERIC_WRITE:GENERIC_READ;
   if (UpdateMode)
     Access|=GENERIC_WRITE;
@@ -87,6 +94,14 @@ bool File::Open(const wchar *Name,uint Mode)
   if (hNewFile==FILE_BAD_HANDLE && LastError==ERROR_FILE_NOT_FOUND)
     ErrorType=FILE_NOTFOUND;
 
+#endif  // defined(CHROMIUM_UNRAR)
+
+#else
+
+#if defined(CHROMIUM_UNRAR)
+  // Do not open a file handle since the sandbox doesn't allow it. Use the
+  // handle provided by the caller.
+  int handle = hOpenFile;
 #else
   int flags=UpdateMode ? O_RDWR:(WriteMode ? O_WRONLY:O_RDONLY);
 #ifdef O_BINARY
@@ -97,8 +112,9 @@ bool File::Open(const wchar *Name,uint Mode)
 #endif
   char NameA[NM];
   WideToChar(Name,NameA,ASIZE(NameA));
-
   int handle=open(NameA,flags);
+#endif  // defined(CHROMIUM_UNRAR)
+
 #ifdef LOCK_EX
 
 #ifdef _OSF_SOURCE
@@ -157,6 +173,11 @@ bool File::WOpen(const wchar *Name)
 
 bool File::Create(const wchar *Name,uint Mode)
 {
+#if defined(CHROMIUM_UNRAR)
+  // Since the Chromium sandbox does not allow the creation of files, use the
+  // provided file.
+  hFile = hOpenFile;
+#else
   // OpenIndiana based NAS and CIFS shares fail to set the file time if file
   // was created in read+write mode and some data was written and not flushed
   // before SetFileTime call. So we should use the write only mode if we plan
@@ -193,6 +214,7 @@ bool File::Create(const wchar *Name,uint Mode)
 #else
   hFile=fopen(NameA,WriteMode ? WRITEBINARY:CREATEBINARY);
 #endif
+#endif
 #endif
   NewFile=true;
   HandleType=FILE_HANDLENORMAL;
@@ -228,6 +250,8 @@ bool File::Close()
   {
     if (!SkipClose)
     {
+#if !defined(CHROMIUM_UNRAR)
+// unrar should not close the file handle since it wasn't opened by unrar.
 #ifdef _WIN_ALL
       // We use the standard system handle for stdout in Windows
       // and it must not  be closed here.
@@ -240,6 +264,7 @@ bool File::Close()
       Success=fclose(hFile)!=EOF;
 #endif
 #endif
+#endif  // defined(CHROMIUM_UNRAR)
     }
     hFile=FILE_BAD_HANDLE;
   }
@@ -367,6 +392,7 @@ int File::Read(void *Data,size_t Size)
     {
       ErrorType=FILE_READERROR;
       if (AllowExceptions)
+      {
         if (IgnoreReadErrors)
         {
           ReadSize=0;
@@ -384,6 +410,7 @@ int File::Read(void *Data,size_t Size)
             continue;
           ErrHandler.ReadError(FileName);
         }
+      }
     }
     break;
   }
@@ -499,18 +526,22 @@ bool File::RawSeek(int64 Offset,int Method)
 int64 File::Tell()
 {
   if (hFile==FILE_BAD_HANDLE)
+  {
     if (AllowExceptions)
       ErrHandler.SeekError(FileName);
     else
       return -1;
+  }
 #ifdef _WIN_ALL
   LONG HighDist=0;
   uint LowDist=SetFilePointer(hFile,0,&HighDist,FILE_CURRENT);
   if (LowDist==0xffffffff && GetLastError()!=NO_ERROR)
+  {
     if (AllowExceptions)
       ErrHandler.SeekError(FileName);
     else
       return -1;
+  }
   return INT32TO64(HighDist,LowDist);
 #else
 #ifdef FILE_USE_OPEN
@@ -727,3 +758,9 @@ int64 File::Copy(File &Dest,int64 Length)
   return CopySize;
 }
 #endif
+
+#if defined(CHROMIUM_UNRAR)
+void File::SetFileHandle(FileHandle hF) {
+  hOpenFile = hF;
+}
+#endif  // defined(CHROMIUM_UNRAR)
diff --git a/third_party/unrar/src/file.hpp b/third_party/unrar/src/file.hpp
index f99336a7d0e2..a1d42a05b6cc 100644
--- a/third_party/unrar/src/file.hpp
+++ b/third_party/unrar/src/file.hpp
@@ -68,6 +68,10 @@ class File
     wchar FileName[NM];
 
     FILE_ERRORTYPE ErrorType;
+
+#if defined(CHROMIUM_UNRAR)
+    FileHandle hOpenFile;
+#endif  // defined(CHROMIUM_UNRAR)
   public:
     File();
     virtual ~File();
@@ -114,6 +118,14 @@ class File
 #ifdef _WIN_ALL
     void RemoveSequentialFlag() {NoSequentialRead=true;}
 #endif
+
+#if defined(CHROMIUM_UNRAR)
+    // Since unrar runs in a sandbox, it doesn't have the permission to open
+    // files on the filesystem. Instead, the caller opens the file and passes
+    // the file handle to unrar. This handle is then used to read the file.
+    void SetFileHandle(FileHandle file);
+#endif  // defined(CHROMIUM_UNRAR)
+
 #ifdef _UNIX
     int GetFD()
     {
diff --git a/third_party/unrar/src/filestr.cpp b/third_party/unrar/src/filestr.cpp
index a5d29d74bcfa..d25cf09b5f4f 100644
--- a/third_party/unrar/src/filestr.cpp
+++ b/third_party/unrar/src/filestr.cpp
@@ -14,10 +14,12 @@ bool ReadTextFile(
   *FileName=0;
 
   if (Name!=NULL)
+  {
     if (Config)
       GetConfigName(Name,FileName,ASIZE(FileName),true,false);
     else
       wcsncpyz(FileName,Name,ASIZE(FileName));
+  }
 
   File SrcFile;
   if (*FileName!=0)
diff --git a/third_party/unrar/src/hash.cpp b/third_party/unrar/src/hash.cpp
index 42791f4f437a..899b0ed1ab07 100644
--- a/third_party/unrar/src/hash.cpp
+++ b/third_party/unrar/src/hash.cpp
@@ -30,8 +30,8 @@ bool HashValue::operator == (const HashValue &cmp)
 {
   if (Type==HASH_NONE || cmp.Type==HASH_NONE)
     return true;
-  if (Type==HASH_RAR14 && cmp.Type==HASH_RAR14 || 
-      Type==HASH_CRC32 && cmp.Type==HASH_CRC32)
+  if ((Type==HASH_RAR14 && cmp.Type==HASH_RAR14) || 
+      (Type==HASH_CRC32 && cmp.Type==HASH_CRC32))
     return CRC32==cmp.CRC32;
   if (Type==HASH_BLAKE2 && cmp.Type==HASH_BLAKE2)
     return memcmp(Digest,cmp.Digest,sizeof(Digest))==0;
diff --git a/third_party/unrar/src/isnt.cpp b/third_party/unrar/src/isnt.cpp
index 6fadec049fe4..d30adf550925 100644
--- a/third_party/unrar/src/isnt.cpp
+++ b/third_party/unrar/src/isnt.cpp
@@ -1,24 +1,18 @@
 #include "rar.hpp"
 
 #ifdef _WIN_ALL
+#include "versionhelpers.h"
+
 DWORD WinNT()
 {
-  static int dwPlatformId=-1;
-  static DWORD dwMajorVersion,dwMinorVersion;
-  if (dwPlatformId==-1)
-  {
-    OSVERSIONINFO WinVer;
-    WinVer.dwOSVersionInfoSize=sizeof(WinVer);
-    GetVersionEx(&WinVer);
-    dwPlatformId=WinVer.dwPlatformId;
-    dwMajorVersion=WinVer.dwMajorVersion;
-    dwMinorVersion=WinVer.dwMinorVersion;
-  }
-  DWORD Result=0;
-  if (dwPlatformId==VER_PLATFORM_WIN32_NT)
-    Result=dwMajorVersion*0x100+dwMinorVersion;
-
-
-  return Result;
+  if (!IsWindowsXPOrGreater())
+    return WNT_NONE;
+  if (!IsWindowsVistaOrGreater())
+    return WNT_WXP;
+  if (!IsWindows7OrGreater()) return WNT_VISTA;
+  if (!IsWindows8OrGreater()) return WNT_W7;
+  if (!IsWindows8Point1OrGreater()) return WNT_W8;
+  if (!IsWindows10OrGreater()) return WNT_W81;
+  return WNT_W10;
 }
 #endif
diff --git a/third_party/unrar/src/isnt.hpp b/third_party/unrar/src/isnt.hpp
index 85790da46290..a02174447e29 100644
--- a/third_party/unrar/src/isnt.hpp
+++ b/third_party/unrar/src/isnt.hpp
@@ -1,6 +1,8 @@
 #ifndef _RAR_ISNT_
 #define _RAR_ISNT_
 
+#include "windows.h"
+
 enum WINNT_VERSION {
   WNT_NONE=0,WNT_NT351=0x0333,WNT_NT4=0x0400,WNT_W2000=0x0500,
   WNT_WXP=0x0501,WNT_W2003=0x0502,WNT_VISTA=0x0600,WNT_W7=0x0601,
@@ -9,5 +11,4 @@ enum WINNT_VERSION {
 
 DWORD WinNT();
 
-
 #endif
diff --git a/third_party/unrar/src/list.cpp b/third_party/unrar/src/list.cpp
index b957f161bfad..3a17b6cbfa9d 100644
--- a/third_party/unrar/src/list.cpp
+++ b/third_party/unrar/src/list.cpp
@@ -1,10 +1,7 @@
 #include "rar.hpp"
 
 static void ListFileHeader(Archive &Arc,FileHeader &hd,bool &TitleShown,bool Verbose,bool Technical,bool Bare);
-static void ListSymLink(Archive &Arc);
 static void ListFileAttr(uint A,HOST_SYSTEM_TYPE HostType,wchar *AttrStr,size_t AttrSize);
-static void ListOldSubHeader(Archive &Arc);
-static void ListNewSubHeader(CommandData *Cmd,Archive &Arc);
 
 void ListArchive(CommandData *Cmd)
 {
@@ -48,6 +45,7 @@ void ListArchive(CommandData *Cmd)
           if (Arc.SFXSize>0)
             mprintf(L"%s%s", SetCount++ > 0 ? L", ":L"", St(MListSFX));
           if (Arc.Volume)
+          {
             if (Arc.Format==RARFMT50)
             {
               // RAR 5.0 archives store the volume number in main header,
@@ -58,6 +56,7 @@ void ListArchive(CommandData *Cmd)
             }
             else
               mprintf(L"%s%s", SetCount++ > 0 ? L", ":L"", St(MListVolume));
+          }
           if (Arc.Protected)
             mprintf(L"%s%s", SetCount++ > 0 ? L", ":L"", St(MListRR));
           if (Arc.Locked)
@@ -110,10 +109,13 @@ void ListArchive(CommandData *Cmd)
                   ListFileHeader(Arc,Arc.SubHead,TitleShown,Verbose,true,false);
               }
               break;
+            default:
+              break;
           }
           Arc.SeekToNext();
         }
         if (!Bare && !Technical)
+        {
           if (TitleShown)
           {
             wchar UnpSizeText[20];
@@ -142,12 +144,13 @@ void ListArchive(CommandData *Cmd)
           }
           else
             mprintf(St(MListNoFiles));
+        }
 
         ArcCount++;
 
 #ifndef NOVOLUME
         if (Cmd->VolSize!=0 && (Arc.FileHead.SplitAfter ||
-            Arc.GetHeaderType()==HEAD_ENDARC && Arc.EndArcHead.NextVolume) &&
+            (Arc.GetHeaderType()==HEAD_ENDARC && Arc.EndArcHead.NextVolume)) &&
             MergeArchive(Arc,NULL,false,Cmd->Command[0]))
           Arc.Seek(0,SEEK_SET);
         else
@@ -272,9 +275,12 @@ void ListFileHeader(Archive &Arc,FileHeader &hd,bool &TitleShown,bool Verbose,bo
             Type=St(MListHardlink); break;
           case FSREDIR_FILECOPY:
             Type=St(MListCopy);     break;
+          case FSREDIR_NONE:
+            break;
         }
       mprintf(L"\n%12ls: %ls",St(MListType),Type);
       if (hd.RedirType!=FSREDIR_NONE)
+      {
         if (Format==RARFMT15)
         {
           char LinkTargetA[NM];
@@ -296,6 +302,7 @@ void ListFileHeader(Archive &Arc,FileHeader &hd,bool &TitleShown,bool Verbose,bo
         }
         else
           mprintf(L"\n%12ls: %ls",St(MListTarget),hd.RedirName);
+      }
     }
     if (!hd.Dir)
     {
diff --git a/third_party/unrar/src/match.cpp b/third_party/unrar/src/match.cpp
index 4369a578c3ab..146a3b62a6fd 100644
--- a/third_party/unrar/src/match.cpp
+++ b/third_party/unrar/src/match.cpp
@@ -47,6 +47,7 @@ bool CmpName(const wchar *Wildcard,const wchar *Name,int CmpMode)
         mwcsicompc(Path1,Path2,ForceCase)!=0)
       return(false);
     if (CmpMode==MATCH_SUBPATH || CmpMode==MATCH_WILDSUBPATH)
+    {
       if (IsWildcard(Path1))
         return(match(Wildcard,Name,ForceCase));
       else
@@ -58,6 +59,7 @@ bool CmpName(const wchar *Wildcard,const wchar *Name,int CmpMode)
         else
           if (mwcsicompc(Path1,Path2,ForceCase)!=0)
             return(false);
+    }
   }
   wchar *Name1=PointToName(Wildcard);
   wchar *Name2=PointToName(Name);
diff --git a/third_party/unrar/src/model.cpp b/third_party/unrar/src/model.cpp
index 83391c5a4510..1ca9f03e9bcc 100644
--- a/third_party/unrar/src/model.cpp
+++ b/third_party/unrar/src/model.cpp
@@ -43,13 +43,27 @@ void ModelPPM::RestartModelRare()
   InitRL=-(MaxOrder < 12 ? MaxOrder:12)-1;
   MinContext = MaxContext = (RARPPM_CONTEXT*) SubAlloc.AllocContext();
   if (MinContext == NULL)
+  {
+#if defined(UNRAR_NO_EXCEPTIONS)
+    base::TerminateBecauseOutOfMemory(0);
+#else
     throw std::bad_alloc();
+#endif  // defined(UNRAR_NO_EXCEPTIONS)
+  }
+
   MinContext->Suffix=NULL;
   OrderFall=MaxOrder;
   MinContext->U.SummFreq=(MinContext->NumStats=256)+1;
   FoundState=MinContext->U.Stats=(RARPPM_STATE*)SubAlloc.AllocUnits(256/2);
   if (FoundState == NULL)
+  {
+#if defined(UNRAR_NO_EXCEPTIONS)
+    base::TerminateBecauseOutOfMemory(0);
+#else
     throw std::bad_alloc();
+#endif  // defined(UNRAR_NO_EXCEPTIONS)
+  }
+
   for (RunLength=InitRL, PrevSuccess=i=0;i < 256;i++) 
   {
     MinContext->U.Stats[i].Symbol=i;      
diff --git a/third_party/unrar/src/os.hpp b/third_party/unrar/src/os.hpp
index d4a7426d9ec4..bc1112633f7d 100644
--- a/third_party/unrar/src/os.hpp
+++ b/third_party/unrar/src/os.hpp
@@ -32,17 +32,21 @@
 #define STRICT 1
 #endif
 
+#if !defined(CHROMIUM_UNRAR)
 #define UNICODE
 #undef WINVER
 #undef _WIN32_WINNT
 #define WINVER 0x0501
 #define _WIN32_WINNT 0x0501
+#endif  // CHROMIUM_UNRAR
 
-#if !defined(ZIPSFX)
+#if !defined(ZIPSFX) && !defined(CHROMIUM_UNRAR)
 #define RAR_SMP
 #endif
 
+#if !defined(CHROMIUM_UNRAR)
 #define WIN32_LEAN_AND_MEAN
+#endif  // CHROMIUM_UNRAR
 
 #include <windows.h>
 #include <prsht.h>
@@ -74,8 +78,11 @@
   #include <direct.h>
   #include <intrin.h>
 
+#if !defined(CHROMIUM_UNRAR)
   #define USE_SSE
   #define SSE_ALIGNMENT 16
+#endif  // CHROMIUM_UNRAR
+
 #else
   #include <dirent.h>
 #endif // _MSC_VER
diff --git a/third_party/unrar/src/pathfn.cpp b/third_party/unrar/src/pathfn.cpp
index 28680672efef..69d648e95871 100644
--- a/third_party/unrar/src/pathfn.cpp
+++ b/third_party/unrar/src/pathfn.cpp
@@ -346,7 +346,7 @@ void NextVolumeName(wchar *ArcName,uint MaxLength,bool OldNumbering)
     ChPtr=GetExt(ArcName);
   }
   else
-    if (ChPtr[1]==0 && wcslen(ArcName)<MaxLength-3 || wcsicomp(ChPtr+1,L"exe")==0 || wcsicomp(ChPtr+1,L"sfx")==0)
+    if ((ChPtr[1]==0 && wcslen(ArcName)<MaxLength-3) || wcsicomp(ChPtr+1,L"exe")==0 || wcsicomp(ChPtr+1,L"sfx")==0)
       wcscpy(ChPtr+1,L"rar");
   if (!OldNumbering)
   {
@@ -417,7 +417,7 @@ void MakeNameUsable(char *Name,bool Extended)
 #endif
   for (char *s=Name;*s!=0;s=charnext(s))
   {
-    if (strchr(Extended ? "?*<>|\"":"?*",*s)!=NULL || Extended && (byte)*s<32)
+    if (strchr(Extended ? "?*<>|\"":"?*",*s)!=NULL || (Extended && (byte)*s<32))
       *s='_';
 #ifdef _EMX
     if (*s=='=')
@@ -427,7 +427,7 @@ void MakeNameUsable(char *Name,bool Extended)
     if (s-Name>1 && *s==':')
       *s='_';
     // Remove ' ' and '.' before path separator, but allow .\ and ..\.
-    if ((*s==' ' || *s=='.' && s>Name && !IsPathDiv(s[-1]) && s[-1]!='.') && IsPathDiv(s[1]))
+    if ((*s==' ' || (*s=='.' && s>Name && !IsPathDiv(s[-1]) && s[-1]!='.')) && IsPathDiv(s[1]))
       *s='_';
 #endif
   }
@@ -438,7 +438,7 @@ void MakeNameUsable(wchar *Name,bool Extended)
 {
   for (wchar *s=Name;*s!=0;s++)
   {
-    if (wcschr(Extended ? L"?*<>|\"":L"?*",*s)!=NULL || Extended && (uint)*s<32)
+    if (wcschr(Extended ? L"?*<>|\"":L"?*",*s)!=NULL || (Extended && (uint)*s<32))
       *s='_';
 #ifndef _UNIX
     if (s-Name>1 && *s==':')
@@ -541,7 +541,7 @@ bool IsFullPath(const wchar *Path)
     return true;
 */
 #if defined(_WIN_ALL) || defined(_EMX)
-  return Path[0]=='\\' && Path[1]=='\\' || IsDriveLetter(Path) && IsPathDiv(Path[2]);
+  return (Path[0]=='\\' && Path[1]=='\\') || (IsDriveLetter(Path) && IsPathDiv(Path[2]));
 #else
   return IsPathDiv(Path[0]);
 #endif
@@ -722,11 +722,12 @@ static void GenArcName(wchar *ArcName,const wchar *GenerateMask,uint ArcNumber,b
 
   int WeekDay=rlt.wDay==0 ? 6:rlt.wDay-1;
   int StartWeekDay=rlt.yDay-WeekDay;
-  if (StartWeekDay<0)
+  if (StartWeekDay<0) {
     if (StartWeekDay<=-4)
       StartWeekDay+=IsLeapYear(rlt.Year-1) ? 366:365;
     else
       StartWeekDay=0;
+  }
   int CurWeek=StartWeekDay/7+1;
   if (StartWeekDay%7>=4)
     CurWeek++;
@@ -970,7 +971,7 @@ void MakeNameCompatible(wchar *Name)
       for (int I=Dest-1;I>0 && (Name[I]==' ' || Name[I]=='.');I--)
       {
         // Permit path1/./path2 and ../path1 paths.
-        if (Name[I]=='.' && (IsPathDiv(Name[I-1]) || Name[I-1]=='.' && I==1))
+        if (Name[I]=='.' && (IsPathDiv(Name[I-1]) || (Name[I-1]=='.' && I==1)))
           break;
         Dest--;
       }
diff --git a/third_party/unrar/src/rarvm.cpp b/third_party/unrar/src/rarvm.cpp
index 8d8675a39bd7..bcb0a0e68089 100644
--- a/third_party/unrar/src/rarvm.cpp
+++ b/third_party/unrar/src/rarvm.cpp
@@ -52,12 +52,12 @@ void RarVM::Prepare(byte *Code,uint CodeSize,VM_PreparedProgram *Prg)
     uint CRC;
     VM_StandardFilters Type;
   } static StdList[]={
-    53, 0xad576887, VMSF_E8,
-    57, 0x3cd7e57e, VMSF_E8E9,
-   120, 0x3769893f, VMSF_ITANIUM,
-    29, 0x0e06077d, VMSF_DELTA,
-   149, 0x1c2c5dc8, VMSF_RGB,
-   216, 0xbc85e701, VMSF_AUDIO
+    {53, 0xad576887, VMSF_E8},
+    {57, 0x3cd7e57e, VMSF_E8E9},
+   {120, 0x3769893f, VMSF_ITANIUM},
+    {29, 0x0e06077d, VMSF_DELTA},
+   {149, 0x1c2c5dc8, VMSF_RGB},
+   {216, 0xbc85e701, VMSF_AUDIO}
   };
   uint CodeCRC=CRC32(0xffffffff,Code,CodeSize)^0xffffffff;
   for (uint I=0;I<ASIZE(StdList);I++)
@@ -327,6 +327,8 @@ bool RarVM::ExecuteStandardFilter(VM_StandardFilters FilterType)
         }
       }
       break;
+    case VMSF_NONE:
+      break;
   }
   return true;
 }
diff --git a/third_party/unrar/src/rdwrfn.cpp b/third_party/unrar/src/rdwrfn.cpp
index f75f66450b2b..001363090bc3 100644
--- a/third_party/unrar/src/rdwrfn.cpp
+++ b/third_party/unrar/src/rdwrfn.cpp
@@ -118,7 +118,7 @@ int ComprDataIO::UnpRead(byte *Addr,size_t Count)
     // Since we adjust data size for decryption earlier above,
     // it does not hurt "Keep broken files" mode efficiency.
     if (UnpVolume && UnpPackedSize == 0 && 
-        (ReadSize==0 || Decryption && (TotalRead & CRYPT_BLOCK_MASK) != 0) )
+        (ReadSize==0 || (Decryption && (TotalRead & CRYPT_BLOCK_MASK) != 0)) )
     {
 #ifndef NOVOLUME
       if (!MergeArchive(*SrcArc,this,true,CurrentCommand))
diff --git a/third_party/unrar/src/recvol3.cpp b/third_party/unrar/src/recvol3.cpp
index 0d18f079b332..1b3b66caa99c 100644
--- a/third_party/unrar/src/recvol3.cpp
+++ b/third_party/unrar/src/recvol3.cpp
@@ -89,12 +89,16 @@ static bool IsNewStyleRev(const wchar *Name)
   if (Ext==NULL)
     return true;
   int DigitGroup=0;
-  for (Ext--;Ext>Name;Ext--)
-    if (!IsDigit(*Ext))
-      if (*Ext=='_' && IsDigit(*(Ext-1)))
+  for (Ext--;Ext>Name;Ext--) {
+    if (!IsDigit(*Ext)) {
+      if (*Ext=='_' && IsDigit(*(Ext-1))) {
         DigitGroup++;
-      else
+      }
+      else {
         break;
+      }
+    }
+  }
   return DigitGroup<2;
 }
 
@@ -228,7 +232,7 @@ bool RecVolumes3::Restore(RAROptions *Cmd,const wchar *Name,bool Silent)
     }
     if (P[1]+P[2]>255)
       continue;
-    if (RecVolNumber!=0 && RecVolNumber!=P[1] || FileNumber!=0 && FileNumber!=P[2])
+    if ((RecVolNumber!=0 && RecVolNumber!=P[1]) || (FileNumber!=0 && FileNumber!=P[2]))
     {
       uiMsg(UIERROR_RECVOLDIFFSETS,CurName,PrevName);
       return false;
diff --git a/third_party/unrar/src/rs16.cpp b/third_party/unrar/src/rs16.cpp
index f23cff8574db..335d342768a6 100644
--- a/third_party/unrar/src/rs16.cpp
+++ b/third_party/unrar/src/rs16.cpp
@@ -27,7 +27,7 @@ RSCoder16::~RSCoder16()
   delete[] MX;
   delete[] ValidFlags;
 }
-    
+
 
 // Initialize logarithms and exponents Galois field tables.
 void RSCoder16::gfInit()
@@ -41,7 +41,7 @@ void RSCoder16::gfInit()
     gfExp[L]=E;
     gfExp[L+gfSize]=E;  // Duplicate the table to avoid gfExp overflow check.
     E<<=1;
-    if (E>gfSize) 
+    if (E>gfSize)
       E^=0x1100B; // Irreducible field-generator polynomial.
   }
 
@@ -59,7 +59,7 @@ uint RSCoder16::gfAdd(uint a,uint b) // Addition in Galois field.
 }
 
 
-uint RSCoder16::gfMul(uint a,uint b) // Multiplication in Galois field. 
+uint RSCoder16::gfMul(uint a,uint b) // Multiplication in Galois field.
 {
   return gfExp[gfLog[a]+gfLog[b]];
 }
@@ -144,7 +144,7 @@ void RSCoder16::MakeDecoderMatrix()
 }
 
 
-// Apply Gauss–Jordan elimination to find inverse of decoder matrix.
+// Apply Gauss-Jordan elimination to find inverse of decoder matrix.
 // We have the square NDxND matrix, but we do not store its trivial
 // diagonal "1" rows matching valid data, so we work with NExND matrix.
 // Our original Cauchy matrix does not contain 0, so we skip search
@@ -156,7 +156,7 @@ void RSCoder16::InvertDecoderMatrix()
   for (uint Kr = 0, Kf = 0; Kr < NE; Kr++, Kf++)
   {
     while (ValidFlags[Kf]) // Skip trivial rows.
-      Kf++;                 
+      Kf++;
     MI[Kr * ND + Kf] = 1;  // Set diagonal 1.
   }
 
@@ -174,7 +174,7 @@ void RSCoder16::InvertDecoderMatrix()
       // after MI[..]^=, but we do not need it for matrix inversion.
       for (uint I = 0; I < NE; I++)
         MI[I * ND + Kf] ^= MX[I * ND + Kf];
-      Kf++;                 
+      Kf++;
     }
 
     if (Kf == ND)
@@ -186,14 +186,14 @@ void RSCoder16::InvertDecoderMatrix()
     uint PInv = gfInv( MXk[Kf] ); // Pivot inverse.
     // Divide the pivot row by pivot, so pivot cell contains 1.
     for (uint I = 0; I < ND; I++)
-    { 
+    {
       MXk[I] = gfMul( MXk[I], PInv );
       MIk[I] = gfMul( MIk[I], PInv );
     }
 
     for (uint I = 0; I < NE; I++)
       if (I != Kr) // For all rows except containing the pivot cell.
-      { 
+      {
         // Apply Gaussian elimination Mij -= Mkj * Mik / pivot.
         // Since pivot is already 1, it is reduced to Mij -= Mkj * Mik.
         uint *MXi = MX + I * ND; // i-th row of main matrix.
@@ -361,7 +361,7 @@ bool RSCoder16::SSE_UpdateECC(uint DataNum, uint ECCNum, const byte *Data, byte
     __m128i LowBytes1=_mm_and_si128(D[1],LowByteMask);
     __m128i HighBytes=_mm_packus_epi16(HighBytes0,HighBytes1);
     __m128i LowBytes=_mm_packus_epi16(LowBytes0,LowBytes1);
-    
+
     // Multiply bits 0..3 of low bytes. Store low and high product bytes
     // separately in cumulative sum variables.
     __m128i LowBytesLow4=_mm_and_si128(LowBytes,Low4Mask);
@@ -377,7 +377,7 @@ bool RSCoder16::SSE_UpdateECC(uint DataNum, uint ECCNum, const byte *Data, byte
     // Add new product to existing sum, low and high bytes separately.
     LowBytesMultSum=_mm_xor_si128(LowBytesMultSum,LowBytesHigh4MultLow);
     HighBytesMultSum=_mm_xor_si128(HighBytesMultSum,LowBytesHigh4MultHigh);
-    
+
     // Multiply bits 0..3 of high bytes. Store low and high product bytes separately.
     __m128i HighBytesLow4=_mm_and_si128(HighBytes,Low4Mask);
     __m128i HighBytesLow4MultLow=_mm_shuffle_epi8(T2L,HighBytesLow4);
@@ -413,7 +413,7 @@ bool RSCoder16::SSE_UpdateECC(uint DataNum, uint ECCNum, const byte *Data, byte
   // because Data and ECC can have different alignment offsets.
   for (; Pos<BlockSize; Pos+=2)
     *(ushort*)(ECC+Pos) ^= gfMul( M, *(ushort*)(Data+Pos) );
-  
+
   return true;
 }
 #endif
diff --git a/third_party/unrar/src/scantree.cpp b/third_party/unrar/src/scantree.cpp
index 8b89412415f3..d7233daf99d7 100644
--- a/third_party/unrar/src/scantree.cpp
+++ b/third_party/unrar/src/scantree.cpp
@@ -218,7 +218,7 @@ bool ScanTree::GetNextMask()
   wchar *Name=PointToName(CurMask);
   if (*Name==0)
     wcsncatz(CurMask,MASKALL,ASIZE(CurMask));
-  if (Name[0]=='.' && (Name[1]==0 || Name[1]=='.' && Name[2]==0))
+  if (Name[0]=='.' && (Name[1]==0 || (Name[1]=='.' && Name[2]==0)))
   {
     AddEndSlash(CurMask,ASIZE(CurMask));
     wcsncatz(CurMask,MASKALL,ASIZE(CurMask));
@@ -257,9 +257,9 @@ SCAN_CODE ScanTree::FindProc(FindData *FD)
     // at top level in recursion mode. We always comrpess the entire directory
     // if folder wildcard is specified.
     bool SearchAll=!IsDir && (Depth>0 || Recurse==RECURSE_ALWAYS ||
-                   FolderWildcards && Recurse!=RECURSE_DISABLE || 
-                   Wildcards && Recurse==RECURSE_WILDCARDS || 
-                   ScanEntireDisk && Recurse!=RECURSE_DISABLE);
+                   (FolderWildcards && Recurse!=RECURSE_DISABLE) || 
+                   (Wildcards && Recurse==RECURSE_WILDCARDS) || 
+                   (ScanEntireDisk && Recurse!=RECURSE_DISABLE));
     if (Depth==0)
       SearchAllInRoot=SearchAll;
     if (SearchAll || Wildcards)
diff --git a/third_party/unrar/src/strfn.cpp b/third_party/unrar/src/strfn.cpp
index 2cf3ab972b4e..09730b6bff08 100644
--- a/third_party/unrar/src/strfn.cpp
+++ b/third_party/unrar/src/strfn.cpp
@@ -192,7 +192,7 @@ bool IsSpace(int ch)
 // values, resulting in undefined behavior in standard function.
 bool IsAlpha(int ch)
 {
-  return ch>='A' && ch<='Z' || ch>='a' && ch<='z';
+  return (ch>='A' && ch<='Z') || (ch>='a' && ch<='z');
 }
 
 
diff --git a/third_party/unrar/src/threadmisc.cpp b/third_party/unrar/src/threadmisc.cpp
index 4ad5af2e5681..9dfd2b9bc301 100644
--- a/third_party/unrar/src/threadmisc.cpp
+++ b/third_party/unrar/src/threadmisc.cpp
@@ -43,17 +43,22 @@ static inline void CriticalSectionEnd(CRITSECT_HANDLE *CritSection)
 }
 
 
-static struct GlobalPoolCreateSync
+struct GlobalPoolCreateSync
 {
   CRITSECT_HANDLE CritSection;
   GlobalPoolCreateSync()  { CriticalSectionCreate(&CritSection); }
   ~GlobalPoolCreateSync() { CriticalSectionDelete(&CritSection); }
-} PoolCreateSync;
+};
+
+static GlobalPoolCreateSync& GetPoolCreateSync() {
+  static GlobalPoolCreateSync PoolCreateSync;
+  return PoolCreateSync;
+}
 
 
 ThreadPool* CreateThreadPool()
 {
-  CriticalSectionStart(&PoolCreateSync.CritSection); 
+  CriticalSectionStart(&(GetPoolCreateSync().CritSection));
 
   if (GlobalPoolUseCount++ == 0)
     GlobalPool=new ThreadPool(MaxPoolThreads);
@@ -66,11 +71,11 @@ ThreadPool* CreateThreadPool()
   if (GlobalPoolUseCount > 1)
   {
     ThreadPool *Pool = new ThreadPool(MaxPoolThreads);
-    CriticalSectionEnd(&PoolCreateSync.CritSection); 
+    CriticalSectionEnd(&(GetPoolCreateSync().CritSection));
     return Pool;
   }
 
-  CriticalSectionEnd(&PoolCreateSync.CritSection); 
+  CriticalSectionEnd(&(GetPoolCreateSync().CritSection));
   return GlobalPool;
 }
 
@@ -79,7 +84,7 @@ void DestroyThreadPool(ThreadPool *Pool)
 {
   if (Pool!=NULL)
   {
-    CriticalSectionStart(&PoolCreateSync.CritSection); 
+    CriticalSectionStart(&(GetPoolCreateSync().CritSection));
 
     if (Pool==GlobalPool && GlobalPoolUseCount > 0 && --GlobalPoolUseCount == 0)
       delete GlobalPool;
@@ -89,7 +94,7 @@ void DestroyThreadPool(ThreadPool *Pool)
     if (Pool!=GlobalPool)
       delete Pool;
 
-    CriticalSectionEnd(&PoolCreateSync.CritSection); 
+    CriticalSectionEnd(&(GetPoolCreateSync().CritSection));
   }
 }
 
diff --git a/third_party/unrar/src/timefn.cpp b/third_party/unrar/src/timefn.cpp
index 63f466084d04..186ac4fd6f86 100644
--- a/third_party/unrar/src/timefn.cpp
+++ b/third_party/unrar/src/timefn.cpp
@@ -141,7 +141,7 @@ void RarTime::GetWinFT(FILETIME *ft)
 
 void RarTime::SetWinFT(FILETIME *ft)
 {
-  _ULARGE_INTEGER ul = {ft->dwLowDateTime, ft->dwHighDateTime};
+  _ULARGE_INTEGER ul = {{ft->dwLowDateTime, ft->dwHighDateTime}};
   SetWin(ul.QuadPart);
 }
 #endif
diff --git a/third_party/unrar/src/uiconsole.cpp b/third_party/unrar/src/uiconsole.cpp
index a37e1610a2fd..023e0917a934 100644
--- a/third_party/unrar/src/uiconsole.cpp
+++ b/third_party/unrar/src/uiconsole.cpp
@@ -342,6 +342,8 @@ void uiMsgStore::Msg()
     case UIEVENT_RRTESTINGSTART:
       mprintf(L"%s      ",St(MTestingRR));
       break;
+    default:
+      break;
   }
 }
 
diff --git a/third_party/unrar/src/unicode.cpp b/third_party/unrar/src/unicode.cpp
index ffba8c11fa4b..e84d9c1de02e 100644
--- a/third_party/unrar/src/unicode.cpp
+++ b/third_party/unrar/src/unicode.cpp
@@ -1,7 +1,7 @@
 #include "rar.hpp"
 #define MBFUNCTIONS
 
-#if defined(_UNIX) && defined(MBFUNCTIONS)
+#if !defined(_WIN_ALL) && !defined(_APPLE) && defined(_UNIX) && defined(MBFUNCTIONS)
 
 static bool WideToCharMap(const wchar *Src,char *Dest,size_t DestSize,bool &Success);
 static void CharToWideMap(const char *Src,wchar *Dest,size_t DestSize,bool &Success);
@@ -30,7 +30,7 @@ bool WideToChar(const wchar *Src,char *Dest,size_t DestSize)
 #elif defined(_APPLE)
   WideToUtf(Src,Dest,DestSize);
 
-#elif defined(MBFUNCTIONS)
+#elif defined(_UNIX) && defined(MBFUNCTIONS)
   if (!WideToCharMap(Src,Dest,DestSize,RetCode))
   {
     mbstate_t ps; // Use thread safe external state based functions.
@@ -70,7 +70,7 @@ bool WideToChar(const wchar *Src,char *Dest,size_t DestSize)
 #endif
   if (DestSize>0)
     Dest[DestSize-1]=0;
-  
+
   // We tried to return the empty string if conversion is failed,
   // but it does not work well. WideCharToMultiByte returns 'failed' code
   // and partially converted string even if we wanted to convert only a part
@@ -95,7 +95,7 @@ bool CharToWide(const char *Src,wchar *Dest,size_t DestSize)
 #elif defined(_APPLE)
   UtfToWide(Src,Dest,DestSize);
 
-#elif defined(MBFUNCTIONS)
+#elif defined(_UNIX) && defined(MBFUNCTIONS)
   mbstate_t ps;
   memset (&ps, 0, sizeof(ps));
   const char *SrcParam=Src; // mbsrtowcs can change the pointer.
@@ -128,8 +128,8 @@ bool CharToWide(const char *Src,wchar *Dest,size_t DestSize)
 }
 
 
-#if defined(_UNIX) && defined(MBFUNCTIONS)
-// Convert and restore mapped inconvertible Unicode characters. 
+#if !defined(_WIN_ALL) && !defined(_APPLE) && defined(_UNIX) && defined(MBFUNCTIONS)
+// Convert and restore mapped inconvertible Unicode characters.
 // We use it for extended ASCII names in Unix.
 bool WideToCharMap(const wchar *Src,char *Dest,size_t DestSize,bool &Success)
 {
@@ -142,7 +142,7 @@ bool WideToCharMap(const wchar *Src,char *Dest,size_t DestSize,bool &Success)
   // can produce uninitilized output while reporting success on garbage input.
   // So we clean the destination to calm analyzers.
   memset(Dest,0,DestSize);
-  
+
   Success=true;
   uint SrcPos=0,DestPos=0;
   while (Src[SrcPos]!=0 && DestPos<DestSize-MB_CUR_MAX)
@@ -177,8 +177,8 @@ bool WideToCharMap(const wchar *Src,char *Dest,size_t DestSize,bool &Success)
 #endif
 
 
-#if defined(_UNIX) && defined(MBFUNCTIONS)
-// Convert and map inconvertible Unicode characters. 
+#if !defined(_WIN_ALL) && !defined(_APPLE) && defined(_UNIX) && defined(MBFUNCTIONS)
+// Convert and map inconvertible Unicode characters.
 // We use it for extended ASCII names in Unix.
 void CharToWideMap(const char *Src,wchar *Dest,size_t DestSize,bool &Success)
 {
diff --git a/third_party/unrar/src/unpack.cpp b/third_party/unrar/src/unpack.cpp
index 0163c49fed3a..ca3c52ea792b 100644
--- a/third_party/unrar/src/unpack.cpp
+++ b/third_party/unrar/src/unpack.cpp
@@ -1,3 +1,9 @@
+// NOTE(vakh): The process.h file needs to be included first because "rar.hpp"
+// defines certain macros that cause symbol redefinition errors
+#if defined(UNRAR_NO_EXCEPTIONS)
+#include "base/process/memory.h"
+#endif  // defined(UNRAR_NO_EXCEPTIONS)
+
 #include "rar.hpp"
 
 #include "coder.cpp"
@@ -89,16 +95,27 @@ void Unpack::Init(size_t WinSize,bool Solid)
 
   // We do not handle growth for existing fragmented window.
   if (Grow && Fragmented)
+  {
+#if defined(UNRAR_NO_EXCEPTIONS)
+    base::TerminateBecauseOutOfMemory(0);
+#else
     throw std::bad_alloc();
+#endif  // defined(UNRAR_NO_EXCEPTIONS)
+  }
 
   byte *NewWindow=Fragmented ? NULL : (byte *)malloc(WinSize);
 
   if (NewWindow==NULL)
+  {
     if (Grow || WinSize<0x1000000)
     {
       // We do not support growth for new fragmented window.
       // Also exclude RAR4 and small dictionaries.
+#if defined(UNRAR_NO_EXCEPTIONS)
+      base::TerminateBecauseOutOfMemory(WinSize);
+#else
       throw std::bad_alloc();
+#endif  // defined(UNRAR_NO_EXCEPTIONS)
     }
     else
     {
@@ -110,6 +127,7 @@ void Unpack::Init(size_t WinSize,bool Solid)
       FragWindow.Init(WinSize);
       Fragmented=true;
     }
+  }
 
   if (!Fragmented)
   {
diff --git a/third_party/unrar/src/unpack15.cpp b/third_party/unrar/src/unpack15.cpp
index 1e7cf76c2d77..78b0130d05b6 100644
--- a/third_party/unrar/src/unpack15.cpp
+++ b/third_party/unrar/src/unpack15.cpp
@@ -293,6 +293,7 @@ void Unpack::LongLZ()
 
   OldAvr3=AvrLn3;
   if (Length!=1 && Length!=4)
+  {
     if (Length==0 && Distance <= MaxDist3)
     {
       AvrLn3++;
@@ -301,12 +302,13 @@ void Unpack::LongLZ()
     else
       if (AvrLn3 > 0)
         AvrLn3--;
+  }
   Length+=3;
   if (Distance >= MaxDist3)
     Length++;
   if (Distance <= 256)
     Length+=8;
-  if (OldAvr3 > 0xb0 || AvrPlc >= 0x2a00 && OldAvr2 < 0x40)
+  if (OldAvr3 > 0xb0 || (AvrPlc >= 0x2a00 && OldAvr2 < 0x40))
     MaxDist3=0x7f00;
   else
     MaxDist3=0x2001;
diff --git a/third_party/unrar/src/unpack20.cpp b/third_party/unrar/src/unpack20.cpp
index 93c8ba05a20e..441b7478ca4a 100644
--- a/third_party/unrar/src/unpack20.cpp
+++ b/third_party/unrar/src/unpack20.cpp
@@ -257,6 +257,7 @@ bool Unpack::ReadTables20()
 void Unpack::ReadLastTables()
 {
   if (ReadTop>=Inp.InAddr+5)
+  {
     if (UnpAudioBlock)
     {
       if (DecodeNumber(Inp,&MD[UnpCurChannel])==256)
@@ -265,6 +266,7 @@ void Unpack::ReadLastTables()
     else
       if (DecodeNumber(Inp,&BlockTables.LD)==269)
         ReadTables20();
+  }
 }
 
 
diff --git a/third_party/unrar/src/unpack50.cpp b/third_party/unrar/src/unpack50.cpp
index dac1f6fd3180..1c96b1d5b1ed 100644
--- a/third_party/unrar/src/unpack50.cpp
+++ b/third_party/unrar/src/unpack50.cpp
@@ -11,7 +11,7 @@ void Unpack::Unpack5(bool Solid)
     // Check TablesRead5 to be sure that we read tables at least once
     // regardless of current block header TablePresent flag.
     // So we can safefly use these tables below.
-    if (!ReadBlockHeader(Inp,BlockHeader) || 
+    if (!ReadBlockHeader(Inp,BlockHeader) ||
         !ReadTables(Inp,BlockHeader,BlockTables) || !TablesRead5)
       return;
   }
@@ -26,9 +26,9 @@ void Unpack::Unpack5(bool Solid)
 
       // We use 'while', because for empty block containing only Huffman table,
       // we'll be on the block border once again just after reading the table.
-      while (Inp.InAddr>BlockHeader.BlockStart+BlockHeader.BlockSize-1 || 
-             Inp.InAddr==BlockHeader.BlockStart+BlockHeader.BlockSize-1 && 
-             Inp.InBit>=BlockHeader.BlockBitSize)
+      while (Inp.InAddr>BlockHeader.BlockStart+BlockHeader.BlockSize-1 ||
+             (Inp.InAddr==BlockHeader.BlockStart+BlockHeader.BlockSize-1 &&
+             Inp.InBit>=BlockHeader.BlockBitSize))
       {
         if (BlockHeader.LastBlockInFile)
         {
@@ -127,10 +127,12 @@ void Unpack::Unpack5(bool Solid)
     if (MainSlot==257)
     {
       if (LastLength!=0)
+      {
         if (Fragmented)
           FragWindow.CopyString(LastLength,OldDist[0],UnpPtr,MaxWinMask);
         else
           CopyString(LastLength,OldDist[0]);
+      }
       continue;
     }
     if (MainSlot<262)
@@ -389,8 +391,8 @@ void Unpack::UnpWriteBuf()
 
   // Choose the nearest among WriteBorder and WrPtr actual written border.
   // If border is equal to UnpPtr, it means that we have MaxWinSize data ahead.
-  if (WriteBorder==UnpPtr || 
-      WrPtr!=UnpPtr && ((WrPtr-UnpPtr)&MaxWinMask)<((WriteBorder-UnpPtr)&MaxWinMask))
+  if (WriteBorder==UnpPtr ||
+      (WrPtr!=UnpPtr && ((WrPtr-UnpPtr)&MaxWinMask)<((WriteBorder-UnpPtr)&MaxWinMask)))
     WriteBorder=WrPtr;
 }
 
@@ -536,11 +538,11 @@ bool Unpack::ReadBlockHeader(BitInput &Inp,UnpackBlockHeader &Header)
     if (!UnpReadBuf())
       return false;
   Inp.faddbits((8-Inp.InBit)&7);
-  
+
   byte BlockFlags=Inp.fgetbits()>>8;
   Inp.faddbits(8);
   uint ByteCount=((BlockFlags>>3)&3)+1; // Block size byte count.
-  
+
   if (ByteCount==4)
     return false;
 
diff --git a/third_party/unrar/src/unpack50frag.cpp b/third_party/unrar/src/unpack50frag.cpp
index 745b1b3083a3..16d5b1c3d5ef 100644
--- a/third_party/unrar/src/unpack50frag.cpp
+++ b/third_party/unrar/src/unpack50frag.cpp
@@ -46,9 +46,15 @@ void FragmentedWindow::Init(size_t WinSize)
         break;
       Size-=Size/32;
     }
-    if (NewMem==NULL)
+    if (NewMem == NULL)
+    {
+#if defined(UNRAR_NO_EXCEPTIONS)
+      base::TerminateBecauseOutOfMemory(Size);
+#else
       throw std::bad_alloc();
-    
+#endif  // defined(UNRAR_NO_EXCEPTIONS)
+    }
+
     // Clean the window to generate the same output when unpacking corrupt
     // RAR files, which may access to unused areas of sliding dictionary.
     memset(NewMem,0,Size);
@@ -58,8 +64,14 @@ void FragmentedWindow::Init(size_t WinSize)
     MemSize[BlockNum]=TotalSize;
     BlockNum++;
   }
-  if (TotalSize<WinSize) // Not found enough free blocks.
+  if (TotalSize < WinSize)  // Not found enough free blocks.
+  {
+#if defined(UNRAR_NO_EXCEPTIONS)
+    base::TerminateBecauseOutOfMemory(WinSize);
+#else
     throw std::bad_alloc();
+#endif  // defined(UNRAR_NO_EXCEPTIONS)
+  }
 }
 
 
diff --git a/third_party/unrar/src/unpack50mt.cpp b/third_party/unrar/src/unpack50mt.cpp
index 59e111ba2ca7..e41da79b5ea1 100644
--- a/third_party/unrar/src/unpack50mt.cpp
+++ b/third_party/unrar/src/unpack50mt.cpp
@@ -134,7 +134,7 @@ void Unpack::Unpack5MT(bool Solid)
         {
           CurData->HeaderRead=true;
           if (!ReadBlockHeader(CurData->Inp,CurData->BlockHeader) ||
-              !CurData->BlockHeader.TablePresent && !TablesRead5)
+              (!CurData->BlockHeader.TablePresent && !TablesRead5))
           {
             Done=true;
             break;
@@ -165,7 +165,7 @@ void Unpack::Unpack5MT(bool Solid)
         if (DataLeft<TooSmallToProcess)
           break;
       }
-      
+
 //#undef USE_THREADS
       UnpackThreadDataList UTDArray[MaxPoolThreads];
       uint UTDArrayPos=0;
@@ -180,7 +180,7 @@ void Unpack::Unpack5MT(bool Solid)
         UnpackThreadDataList *UTD=UTDArray+UTDArrayPos++;
         UTD->D=UnpThreadData+CurBlock;
         UTD->BlockCount=Min(MaxBlockPerThread,BlockNumberMT-CurBlock);
-      
+
 #ifdef USE_THREADS
         if (BlockNumber==1)
           UnpackDecode(*UTD->D);
@@ -200,12 +200,12 @@ void Unpack::Unpack5MT(bool Solid)
 #endif
 
       bool IncompleteThread=false;
-      
+
       for (uint Block=0;Block<BlockNumber;Block++)
       {
         UnpackThreadData *CurData=UnpThreadData+Block;
-        if (!CurData->LargeBlock && !ProcessDecoded(*CurData) ||
-            CurData->LargeBlock && !UnpackLargeBlock(*CurData) ||
+        if ((!CurData->LargeBlock && !ProcessDecoded(*CurData)) ||
+            (CurData->LargeBlock && !UnpackLargeBlock(*CurData)) ||
             CurData->DamagedData)
         {
           Done=true;
@@ -251,7 +251,7 @@ void Unpack::Unpack5MT(bool Solid)
             break;
           }
       }
-      
+
       if (IncompleteThread || Done)
         break; // Current buffer is done, read more data or quit.
       else
@@ -303,7 +303,7 @@ void Unpack::UnpackDecode(UnpackThreadData &D)
     D.DamagedData=true;
     return;
   }
-  
+
   D.DecodedSize=0;
   int BlockBorder=D.BlockHeader.BlockStart+D.BlockHeader.BlockSize-1;
 
@@ -315,14 +315,14 @@ void Unpack::UnpackDecode(UnpackThreadData &D)
   {
     if (D.Inp.InAddr>=ReadBorder)
     {
-      if (D.Inp.InAddr>BlockBorder || D.Inp.InAddr==BlockBorder && 
-          D.Inp.InBit>=D.BlockHeader.BlockBitSize)
+      if (D.Inp.InAddr>BlockBorder || (D.Inp.InAddr==BlockBorder &&
+          D.Inp.InBit>=D.BlockHeader.BlockBitSize))
         break;
 
       // If we do not have any more data in file to read, we must process
       // what we have until last byte. Otherwise we can return and append
       // more data to unprocessed few bytes.
-      if ((D.Inp.InAddr>=DataBorder) && !D.NoDataLeft || D.Inp.InAddr>=D.DataSize)
+      if ((D.Inp.InAddr>=DataBorder && !D.NoDataLeft) || D.Inp.InAddr>=D.DataSize)
       {
         D.Incomplete=true;
         break;
@@ -413,7 +413,7 @@ void Unpack::UnpackDecode(UnpackThreadData &D)
     {
       UnpackFilter Filter;
       ReadFilter(D.Inp,Filter);
-      
+
       CurItem->Type=UNPDT_FILTER;
       CurItem->Length=Filter.Type;
       CurItem->Distance=Filter.BlockStart;
@@ -498,7 +498,7 @@ bool Unpack::ProcessDecoded(UnpackThreadData &D)
             if (Item->Type==UNPDT_FILTER)
             {
               UnpackFilter Filter;
-              
+
               Filter.Type=(byte)Item->Length;
               Filter.BlockStart=Item->Distance;
 
@@ -534,7 +534,7 @@ bool Unpack::UnpackLargeBlock(UnpackThreadData &D)
     D.DamagedData=true;
     return false;
   }
-  
+
   int BlockBorder=D.BlockHeader.BlockStart+D.BlockHeader.BlockSize-1;
 
   // Reserve enough space even for filter entry.
@@ -546,14 +546,14 @@ bool Unpack::UnpackLargeBlock(UnpackThreadData &D)
     UnpPtr&=MaxWinMask;
     if (D.Inp.InAddr>=ReadBorder)
     {
-      if (D.Inp.InAddr>BlockBorder || D.Inp.InAddr==BlockBorder && 
-          D.Inp.InBit>=D.BlockHeader.BlockBitSize)
+      if (D.Inp.InAddr>BlockBorder || (D.Inp.InAddr==BlockBorder &&
+          D.Inp.InBit>=D.BlockHeader.BlockBitSize))
         break;
 
       // If we do not have any more data in file to read, we must process
       // what we have until last byte. Otherwise we can return and append
       // more data to unprocessed few bytes.
-      if ((D.Inp.InAddr>=DataBorder) && !D.NoDataLeft || D.Inp.InAddr>=D.DataSize)
+      if ((D.Inp.InAddr>=DataBorder && !D.NoDataLeft) || D.Inp.InAddr>=D.DataSize)
       {
         D.Incomplete=true;
         break;
diff --git a/third_party/unrar/src/unrar_wrapper.h b/third_party/unrar/src/unrar_wrapper.h
new file mode 100644
index 000000000000..0b92964fa08e
--- /dev/null
+++ b/third_party/unrar/src/unrar_wrapper.h
@@ -0,0 +1,20 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_UNRAR_SRC_UNRAR_WRAPPER_H_
+#define THIRD_PARTY_UNRAR_SRC_UNRAR_WRAPPER_H_
+
+#include "rar.hpp"
+
+namespace third_party_unrar {
+
+using ::Archive;
+using ::CmdExtract;
+using ::CommandData;
+
+static const int kUnrarEndarcHead = HEAD_ENDARC;
+static const int kUnrarFileHead = HEAD_FILE;
+}  // namespace third_party_unrar
+
+#endif  // THIRD_PARTY_UNRAR_SRC_UNRAR_WRAPPER_H_
diff --git a/third_party/unrar/src/volume.cpp b/third_party/unrar/src/volume.cpp
index 5d9c4c50a7d0..c175b3b2281b 100644
--- a/third_party/unrar/src/volume.cpp
+++ b/third_party/unrar/src/volume.cpp
@@ -19,7 +19,7 @@ bool MergeArchive(Archive &Arc,ComprDataIO *DataIO,bool ShowFileName,wchar Comma
   if (DataIO!=NULL && SplitHeader)
   {
     bool PackedHashPresent=Arc.Format==RARFMT50 || 
-         hd->UnpVer>=20 && hd->FileHash.CRC32!=0xffffffff;
+         (hd->UnpVer>=20 && hd->FileHash.CRC32!=0xffffffff);
     if (PackedHashPresent && 
         !DataIO->PackedDataHash.Cmp(&hd->FileHash,hd->UseHashKey ? hd->HashKey:NULL))
       uiMsg(UIERROR_CHECKSUMPACKED, Arc.FileName, hd->FileName);
