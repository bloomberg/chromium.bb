<!DOCTYPE html>
<!--
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/category_util.html">
<link rel="import" href="/tracing/base/math/statistics.html">
<link rel="import" href="/tracing/extras/chrome/event_finder_utils.html">
<link rel="import" href="/tracing/extras/chrome/time_to_interactive.html">
<link rel="import" href="/tracing/metrics/metric_registry.html">
<link rel="import" href="/tracing/metrics/system_health/breakdown_tree_helpers.html">
<link rel="import" href="/tracing/metrics/system_health/utils.html">
<link rel="import" href="/tracing/model/helpers/chrome_model_helper.html">
<link rel="import" href="/tracing/model/helpers/chrome_thread_helper.html">
<link rel="import" href="/tracing/model/timed_event.html">
<link rel="import" href="/tracing/value/diagnostics/diagnostic_map.html">
<link rel="import" href="/tracing/value/histogram.html">

<script>
'use strict';

tr.exportTo('tr.metrics.sh', function() {
  const LONG_TASK_THRESHOLD_MS = 50;
  const timeDurationInMs_smallerIsBetter =
      tr.b.Unit.byName.timeDurationInMs_smallerIsBetter;
  const RelatedEventSet = tr.v.d.RelatedEventSet;
  const hasCategoryAndName = tr.metrics.sh.hasCategoryAndName;
  const EventFinderUtils = tr.e.chrome.EventFinderUtils;

  /**
   * @param  {!tr.model.Process} process
   * @param  {!tr.b.math.Range} range
   * @return {Array.<tr.model.Event>} An array of network events of a process
   * and that are intersecting a range.
   */
  function getNetworkEventsInRange(process, range) {
    const networkEvents = [];
    for (const thread of Object.values(process.threads)) {
      const threadHelper = new tr.model.helpers.ChromeThreadHelper(thread);
      const events = threadHelper.getNetworkEvents();
      for (const event of events) {
        if (range.intersectsExplicitRangeInclusive(event.start, event.end)) {
          networkEvents.push(event);
        }
      }
    }
    return networkEvents;
  }

  /**
   * @param {!Object.<string, Object>} breakdownTree
   * @return {tr.v.d.Breakdown} A breakdown with categories and the total time
   * (ms) spent under each category.
   */
  function createBreakdownDiagnostic(breakdownTree) {
    const breakdownDiagnostic = new tr.v.d.Breakdown();
    breakdownDiagnostic.colorScheme =
        tr.v.d.COLOR_SCHEME_CHROME_USER_FRIENDLY_CATEGORY_DRIVER;

    for (const label in breakdownTree) {
      breakdownDiagnostic.set(label, breakdownTree[label].total);
    }
    return breakdownDiagnostic;
  }

  const LOADING_METRIC_BOUNDARIES = tr.v.HistogramBinBoundaries
      .createLinear(0, 1e3, 20)  // 50ms step to 1s
      .addLinearBins(3e3, 20) // 100ms step to 3s
      .addExponentialBins(20e3, 20);

  const TIME_TO_INTERACTIVE_BOUNDARIES = tr.v.HistogramBinBoundaries
  // 90-th percentiile of TTI is around 40 seconds, across warm and cold
  // loads. Data obtained through Cluster Telemetry analysis.
      .createExponential(1, 40e3, 35)
      .addExponentialBins(80e3, 15);

  const SUMMARY_OPTIONS = {
    avg: true,
    count: false,
    max: true,
    min: true,
    std: true,
    sum: false,
  };

  function findFrameLoaderSnapshotAt(rendererHelper, frameIdRef, ts) {
    const objects = rendererHelper.process.objects;
    const frameLoaderInstances = objects.instancesByTypeName_.FrameLoader;
    if (frameLoaderInstances === undefined) return undefined;

    let snapshot;
    for (const instance of frameLoaderInstances) {
      if (!instance.isAliveAt(ts)) continue;
      const maybeSnapshot = instance.getSnapshotAt(ts);
      if (frameIdRef !== maybeSnapshot.args.frame.id_ref) continue;
      snapshot = maybeSnapshot;
    }

    return snapshot;
  }

  function findAllEvents(rendererHelper, category, title) {
    const targetEvents = [];

    for (const ev of rendererHelper.process.getDescendantEvents()) {
      if (!hasCategoryAndName(ev, category, title)) continue;
      targetEvents.push(ev);
    }

    return targetEvents;
  }

  function collectTimeToEvent(
      category, eventName, rendererHelper, frameToNavStartEvents,
      navIdToNavStartEvents) {
    const targetEvents = findAllEvents(rendererHelper, category, eventName);
    const samples = [];
    for (const ev of targetEvents) {
      if (rendererHelper.isTelemetryInternalEvent(ev)) continue;
      const frameIdRef = ev.args.frame;
      const snapshot =
        findFrameLoaderSnapshotAt(rendererHelper, frameIdRef, ev.start);
      if (snapshot === undefined || !snapshot.args.isLoadingMainFrame) continue;
      const url = snapshot.args.documentLoaderURL;
      if (tr.e.chrome.CHROME_INTERNAL_URLS.includes(url)) continue;
      let navigationStartEvent;
      if (ev.args.data === undefined ||
          ev.args.data.navigationId === undefined) {
        navigationStartEvent =
            EventFinderUtils.findLastEventStartingOnOrBeforeTimestamp(
                frameToNavStartEvents.get(frameIdRef) || [], ev.start);
      } else {
        navigationStartEvent = navIdToNavStartEvents.get(
            ev.args.data.navigationId);
      }

      // Ignore layout w/o preceding navigationStart, as they are not
      // attributed to any time-to-X metric.
      if (navigationStartEvent === undefined) continue;

      const navStartToEventRange = tr.b.math.Range.fromExplicitRange(
          navigationStartEvent.start, ev.start);
      const networkEvents = getNetworkEventsInRange(
          rendererHelper.process, navStartToEventRange);
      const breakdownTree = tr.metrics.sh.generateWallClockTimeBreakdownTree(
          rendererHelper.mainThread, networkEvents, navStartToEventRange);
      samples.push({
        value: navStartToEventRange.duration,
        breakdownTree,
        diagnostics: {
          breakdown: createBreakdownDiagnostic(breakdownTree),
          url: new tr.v.d.GenericSet([url]),
          Start: new RelatedEventSet(navigationStartEvent),
          End: new RelatedEventSet(ev)
        }
      });
    }
    return samples;
  }

  function addFirstMeaningfulPaintSample(samples, rendererHelper,
      navigationStart, fmpMarkerEvent, url) {
    const navStartToFMPRange = tr.b.math.Range.fromExplicitRange(
        navigationStart.start, fmpMarkerEvent.start);
    const networkEvents = getNetworkEventsInRange(
        rendererHelper.process, navStartToFMPRange);
    const timeToFirstMeaningfulPaint = navStartToFMPRange.duration;
    const breakdownTree = tr.metrics.sh.generateWallClockTimeBreakdownTree(
        rendererHelper.mainThread, networkEvents, navStartToFMPRange);
    samples.push({
      value: timeToFirstMeaningfulPaint,
      breakdownTree,
      diagnostics: {
        breakdown: createBreakdownDiagnostic(breakdownTree),
        start: new RelatedEventSet(navigationStart),
        end: new RelatedEventSet(fmpMarkerEvent),
        infos: new tr.v.d.GenericSet([{
          url,
          pid: rendererHelper.pid,
          start: navigationStart.start,
          fmp: fmpMarkerEvent.start,
        }]),
      }
    });
  }

  function addFirstMeaningfulPaintCpuTimeSample(samples, rendererHelper,
      navigationStart, fmpMarkerEvent, url) {
    const navStartToFMPRange = tr.b.math.Range.fromExplicitRange(
        navigationStart.start, fmpMarkerEvent.start);

    const mainThreadCpuTime =
        rendererHelper.mainThread.getCpuTimeForRange(navStartToFMPRange);

    const breakdownTree = tr.metrics.sh.generateCpuTimeBreakdownTree(
        rendererHelper.mainThread, navStartToFMPRange);
    samples.push({
      value: mainThreadCpuTime,
      breakdownTree,
      diagnostics: {
        breakdown: createBreakdownDiagnostic(breakdownTree),
        start: new RelatedEventSet(navigationStart),
        end: new RelatedEventSet(fmpMarkerEvent),
        infos: new tr.v.d.GenericSet([{
          url,
          pid: rendererHelper.pid,
          start: navigationStart.start,
          fmp: fmpMarkerEvent.start,
        }]),
      }
    });
  }

  /**
   * Object containing one value and associated diagnostics info for that value
   * for a metric.
   * @typedef {{value: number, diagnostics: !tr.v.d.DiagnosticMap}} MetricSample
   */

  /**
   * Returns a MetricSample for interactivity metrics - First CPU Idle and Time
   * to Interactive.
   *
   * @param {tr.model.helpers.ChromeRendererHelper} rendererHelper
   * @param {?number} eventTimestamp - Timestamp of the event for which the
   *     sample is being generated.
   * @param {tr.model.ThreadSlice} navigationStartEvent
   * @param {number} firstMeaningfulPaintTime
   * @param {number} domContentLoadedEndTime
   * @param {string} url - URL of the current main frame document.
   * @returns {MetricSample|undefined}
   */
  function decorateInteractivitySampleWithDiagnostics_(rendererHelper,
      eventTimestamp, navigationStartEvent, firstMeaningfulPaintTime,
      domContentLoadedEndTime, url) {
    if (eventTimestamp === undefined) return undefined;
    const navigationStartTime = navigationStartEvent.start;
    const navStartToEventTimeRange =
        tr.b.math.Range.fromExplicitRange(
            navigationStartTime, eventTimestamp);
    const networkEvents = getNetworkEventsInRange(
        rendererHelper.process, navStartToEventTimeRange);
    const breakdownTree = tr.metrics.sh.generateWallClockTimeBreakdownTree(
        rendererHelper.mainThread, networkEvents,
        navStartToEventTimeRange);
    const breakdownDiagnostic = createBreakdownDiagnostic(breakdownTree);
    return {
      value: navStartToEventTimeRange.duration,
      diagnostics: tr.v.d.DiagnosticMap.fromObject({
        'Start': new RelatedEventSet(navigationStartEvent),
        'Navigation infos': new tr.v.d.GenericSet([{
          url,
          pid: rendererHelper.pid,
          navigationStartTime,
          firstMeaningfulPaintTime,
          domContentLoadedEndTime,
          // eventTimestamp can be derived from value and navigationStartEvent,
          // but it's useful to directly see the value in the UI.
          eventTimestamp,
        }]),
        'Breakdown of [navStart, eventTimestamp]': breakdownDiagnostic,
      }),
    };
  }

  function collectLoadingMetricsForRenderer(rendererHelper) {
    const frameToNavStartEvents =
        EventFinderUtils.getSortedMainThreadEventsByFrame(
            rendererHelper, 'navigationStart', 'blink.user_timing');
    const navIdToNavStartEvents =
        EventFinderUtils.getSortedMainThreadEventsByNavId(
            rendererHelper, 'navigationStart', 'blink.user_timing');
    const firstPaintSamples = collectTimeToEvent(
        'loading', 'firstPaint',
        rendererHelper, frameToNavStartEvents, navIdToNavStartEvents);
    const firstContentfulPaintSamples = collectTimeToEvent(
        'loading', 'firstContentfulPaint',
        rendererHelper, frameToNavStartEvents, navIdToNavStartEvents);
    const onLoadSamples = collectTimeToEvent(
        'blink.user_timing', 'loadEventStart',
        rendererHelper, frameToNavStartEvents, navIdToNavStartEvents);

    return {
      frameToNavStartEvents,
      firstPaintSamples,
      firstContentfulPaintSamples,
      onLoadSamples,
    };
  }

  function collectMetricsFromLoadExpectations(model, chromeHelper) {
    // Add FMP, firstCpuIdle and interactive samples from load UE
    const interactiveSamples = [];
    const firstCpuIdleSamples = [];
    const firstMeaningfulPaintSamples = [];
    const firstMeaningfulPaintCpuTimeSamples = [];
    for (const expectation of model.userModel.expectations) {
      if (!(expectation instanceof tr.model.um.LoadExpectation)) continue;
      if (tr.e.chrome.CHROME_INTERNAL_URLS.includes(expectation.url)) {
        continue;
      }
      const rendererHelper = chromeHelper.rendererHelpers[
          expectation.renderProcess.pid];
      if (expectation.fmpEvent !== undefined) {
        addFirstMeaningfulPaintSample(firstMeaningfulPaintSamples,
            rendererHelper, expectation.navigationStart, expectation.fmpEvent,
            expectation.url);
        addFirstMeaningfulPaintCpuTimeSample(firstMeaningfulPaintCpuTimeSamples,
            rendererHelper, expectation.navigationStart, expectation.fmpEvent,
            expectation.url);
      }
      if (expectation.firstCpuIdleTime !== undefined) {
        firstCpuIdleSamples.push(decorateInteractivitySampleWithDiagnostics_(
            rendererHelper, expectation.firstCpuIdleTime,
            expectation.navigationStart,
            expectation.fmpEvent.start,
            expectation.domContentLoadedEndEvent.start, expectation.url));
      }
      if (expectation.timeToInteractive !== undefined) {
        interactiveSamples.push(decorateInteractivitySampleWithDiagnostics_(
            rendererHelper, expectation.timeToInteractive,
            expectation.navigationStart,
            expectation.fmpEvent.start,
            expectation.domContentLoadedEndEvent.start, expectation.url));
      }
    }

    return {
      firstMeaningfulPaintSamples,
      firstMeaningfulPaintCpuTimeSamples,
      firstCpuIdleSamples,
      interactiveSamples,
    };
  }

  function addSamplesToHistogram(samples, histogram, histograms) {
    for (const sample of samples) {
      histogram.addSample(sample.value, sample.diagnostics);

      // Only add breakdown histograms for FCP.
      // http://crbug.com/771610
      if (histogram.name !== 'timeToFirstContentfulPaint') continue;

      if (!sample.breakdownTree) continue;
      for (const [category, breakdown] of Object.entries(
          sample.breakdownTree)) {
        const relatedName = `${histogram.name}:${category}`;
        let relatedHist = histograms.getHistogramsNamed(relatedName)[0];
        if (!relatedHist) {
          relatedHist = histograms.createHistogram(
              relatedName, histogram.unit, [], {
                binBoundaries: LOADING_METRIC_BOUNDARIES,
                summaryOptions: {
                  count: false,
                  max: false,
                  min: false,
                  sum: false,
                },
              });

          let relatedNames = histogram.diagnostics.get('breakdown');
          if (!relatedNames) {
            relatedNames = new tr.v.d.RelatedNameMap();
            histogram.diagnostics.set('breakdown', relatedNames);
          }
          relatedNames.set(category, relatedName);
        }
        relatedHist.addSample(breakdown.total, {
          breakdown: tr.v.d.Breakdown.fromEntries(
              Object.entries(breakdown.events)),
        });
      }
    }
  }

  function loadingMetric(histograms, model) {
    const firstPaintHistogram = histograms.createHistogram(
        'timeToFirstPaint', timeDurationInMs_smallerIsBetter, [], {
          binBoundaries: LOADING_METRIC_BOUNDARIES,
          description: 'time to first paint',
          summaryOptions: SUMMARY_OPTIONS,
        });
    const firstContentfulPaintHistogram = histograms.createHistogram(
        'timeToFirstContentfulPaint', timeDurationInMs_smallerIsBetter, [], {
          binBoundaries: LOADING_METRIC_BOUNDARIES,
          description: 'time to first contentful paint',
          summaryOptions: SUMMARY_OPTIONS,
        });
    const onLoadHistogram = histograms.createHistogram(
        'timeToOnload', timeDurationInMs_smallerIsBetter, [], {
          binBoundaries: LOADING_METRIC_BOUNDARIES,
          description: 'time to onload. ' +
            'This is temporary metric used for PCv1/v2 sanity checking',
          summaryOptions: SUMMARY_OPTIONS,
        });
    const firstMeaningfulPaintHistogram = histograms.createHistogram(
        'timeToFirstMeaningfulPaint', timeDurationInMs_smallerIsBetter, [], {
          binBoundaries: LOADING_METRIC_BOUNDARIES,
          description: 'time to first meaningful paint',
          summaryOptions: SUMMARY_OPTIONS,
        });
    const firstMeaningfulPaintCpuTimeHistogram = histograms.createHistogram(
        'cpuTimeToFirstMeaningfulPaint', timeDurationInMs_smallerIsBetter, [], {
          binBoundaries: LOADING_METRIC_BOUNDARIES,
          description: 'CPU time to first meaningful paint',
          summaryOptions: SUMMARY_OPTIONS,
        });
    const timeToInteractiveHistogram = histograms.createHistogram(
        'timeToInteractive', timeDurationInMs_smallerIsBetter, [], {
          binBoundaries: TIME_TO_INTERACTIVE_BOUNDARIES,
          description: 'Time to Interactive',
          summaryOptions: SUMMARY_OPTIONS,
        });
    const timeToFirstCpuIdleHistogram = histograms.createHistogram(
        'timeToFirstCpuIdle', timeDurationInMs_smallerIsBetter, [], {
          binBoundaries: TIME_TO_INTERACTIVE_BOUNDARIES,
          description: 'Time to First CPU Idle',
          summaryOptions: SUMMARY_OPTIONS,
        });

    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    for (const pid in chromeHelper.rendererHelpers) {
      const rendererHelper = chromeHelper.rendererHelpers[pid];
      if (rendererHelper.isChromeTracingUI) continue;

      const samplesSet =
          collectLoadingMetricsForRenderer(rendererHelper);

      addSamplesToHistogram(
          samplesSet.firstPaintSamples, firstPaintHistogram, histograms);
      addSamplesToHistogram(
          samplesSet.firstContentfulPaintSamples,
          firstContentfulPaintHistogram,
          histograms);
      addSamplesToHistogram(
          samplesSet.onLoadSamples, onLoadHistogram, histograms);
    }

    const samplesSet = collectMetricsFromLoadExpectations(model, chromeHelper);
    addSamplesToHistogram(
        samplesSet.firstMeaningfulPaintSamples,
        firstMeaningfulPaintHistogram,
        histograms);
    addSamplesToHistogram(
        samplesSet.firstMeaningfulPaintCpuTimeSamples,
        firstMeaningfulPaintCpuTimeHistogram,
        histograms);
    addSamplesToHistogram(
        samplesSet.interactiveSamples,
        timeToInteractiveHistogram,
        histograms);
    addSamplesToHistogram(
        samplesSet.firstCpuIdleSamples,
        timeToFirstCpuIdleHistogram,
        histograms);
  }

  tr.metrics.MetricRegistry.register(loadingMetric);

  return {
    loadingMetric,
    getNetworkEventsInRange,
  };
});
</script>
