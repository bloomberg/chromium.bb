{"version":3,"file":"index.js","sources":["../src/support/supports-intl-list-format.ts","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","../src/type/type.ts","../src/style/style.ts","../src/locale-matcher/locale-matcher.ts","../node_modules/@babel/runtime/helpers/esm/typeof.js","../src/util/to-object.ts","../src/default-locale/get-default-locale.ts","../src/internal-slot/internal-slot.ts","../src/unicode-extension/unicode-extension.ts","../src/matcher/best-available-locale/best-available-locale.ts","../src/supported-locales/lookup-supported-locales.ts","../src/supported-locales/best-fit-supported-locales.ts","../src/util/is-property-key.ts","../src/util/get.ts","../src/util/to-boolean.ts","../src/util/to-string.ts","../src/util/get-option.ts","../src/supported-locales/supported-locales.ts","../src/matcher/lookup-matcher/lookup-matcher.ts","../src/matcher/best-fit-matcher/best-fit-matcher.ts","../src/resolve-locale/resolve-locale.ts","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../src/string-list-from-iterable.ts","../src/assert/is-record.ts","../src/assert/is-list.ts","../src/deconstruct-pattern/deconstruct-pattern.ts","../src/create-parts-from-list/create-parts-from-list.ts","../src/format-list/format-list.ts","../src/format-list-to-parts/format-list-to-parts.ts","../src/list-format/list-format.ts","../src/patch/patch.ts","../src/index.ts"],"sourcesContent":["export const SUPPORTS_LIST_FORMAT = \"ListFormat\" in Intl;\n","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","import {ElementOf} from \"../util/element-of\";\n\nexport const TYPE = [\"conjunction\", \"disjunction\", \"unit\"] as const;\n\nexport type Type = ElementOf<typeof TYPE>;\n","import {ElementOf} from \"../util/element-of\";\n\nexport const STYLE = [\"long\", \"short\", \"narrow\"] as const;\n\nexport type Style = ElementOf<typeof STYLE>;\n","import {ElementOf} from \"../util/element-of\";\n\nexport const LOCALE_MATCHER = [\"lookup\", \"best fit\"] as const;\n\nexport type LocaleMatcher = ElementOf<typeof LOCALE_MATCHER>;\n","function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nexport default function _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}","/* tslint:disable:use-primitive-type no-construct no-any */\n\n/**\n * The abstract operation ToObject converts argument to a value of type Object.\n *\n * https://tc39.github.io/ecma262/#sec-toobject\n * @param {T} argument\n * @returns{T extends boolean ? Boolean : T extends number ? Number : T extends string ? String : T extends symbol ? symbol : T}\n */\nexport function toObject<T>(argument: T): T extends boolean ? Boolean : T extends number ? Number : T extends string ? String : T extends symbol ? Symbol : T {\n\tif (argument == null) {\n\t\tthrow new TypeError(`Argument ${argument} cannot be converted to an Object`);\n\t}\n\n\tif (typeof argument === \"boolean\") {\n\t\treturn new Boolean(argument) as any;\n\t}\n\n\tif (typeof argument === \"number\") {\n\t\treturn new Number(argument) as any;\n\t}\n\n\tif (typeof argument === \"string\") {\n\t\treturn new String(argument) as any;\n\t}\n\n\tif (typeof argument === \"symbol\") {\n\t\treturn new Object(argument) as any;\n\t}\n\n\treturn argument as any;\n}\n","import {Locale} from \"../locale/locale\";\n\n/**\n * Must represent the structurally valid (6.2.2) and canonicalized (6.2.3) BCP 47 language tag for the host environment's current locale.\n *\n * https://tc39.github.io/ecma402/#sec-defaultlocale\n * @type {Locale?}\n */\nlet _defaultLocale: Locale | undefined;\n\n/**\n * Sets the default locale\n * @param {Locale} locale\n */\nexport function setDefaultLocale(locale: Locale): void {\n\t_defaultLocale = locale;\n}\n\n/**\n * The DefaultLocale abstract operation returns a String value representing the structurally valid (6.2.2) and canonicalized (6.2.3) BCP 47 language tag for the host environment's current locale.\n * https://tc39.github.io/ecma402/#sec-defaultlocale\n * @returns{Locale | undefined}\n */\nexport function getDefaultLocale(): Locale | undefined {\n\treturn _defaultLocale;\n}\n\n/**\n * Retrieves the default locale if it is set, and throws otherwise\n * @returns{Locale}\n */\nexport function ensureDefaultLocale(): Locale {\n\tif (_defaultLocale == null) {\n\t\tthrow new ReferenceError(`Could not determine locale: No default locale has been configured`);\n\t}\n\treturn _defaultLocale;\n}\n","import {ListFormatInstanceInternals} from \"./list-format-instance-internals\";\nimport {ListFormatStaticInternals} from \"./list-format-static-internals\";\nimport {ListFormat} from \"../list-format/list-format\";\n\n/**\n * A WeakMap between ListFormat instances and their internal slot members\n * @type {WeakMap<ListFormat, ListFormatInstanceInternals>}\n */\nexport const LIST_FORMAT_INSTANCE_INTERNAL_MAP: WeakMap<ListFormat, ListFormatInstanceInternals> = new WeakMap();\n\n/**\n * Contains the internal static for ListFormat\n * @type {ListFormatStaticInternals}\n */\nexport const LIST_FORMAT_STATIC_INTERNALS: ListFormatStaticInternals = {\n\t/**\n\t * The value of the [[RelevantExtensionKeys]] internal slot is « ».\n\t * http://tc39.github.io/proposal-intl-list-format/#sec-Intl.ListFormat-internal-slots\n\t */\n\trelevantExtensionKeys: [],\n\n\t/**\n\t * The value of the [[LocaleData]] internal slot is implementation defined within the constraints described in 9.1\n\t * http://tc39.github.io/proposal-intl-list-format/#sec-Intl.ListFormat-internal-slots\n\t */\n\tlocaleData: {},\n\n\t/**\n\t * The value of the [[AvailableLocales]] internal slot is implementation defined within the constraints described in 9.1.\n\t * http://tc39.github.io/proposal-intl-list-format/#sec-Intl.ListFormat-internal-slots\n\t */\n\tavailableLocales: []\n};\n\n/**\n * Sets the value for a property in an internal slot for an instance of ListFormat\n * @param {ListFormat} instance\n * @param {T} property\n * @param {ListFormatInstanceInternals[T]} value\n */\nexport function setInternalSlot<T extends keyof ListFormatInstanceInternals>(\n\tinstance: ListFormat,\n\tproperty: T,\n\tvalue: ListFormatInstanceInternals[T]\n): void {\n\tlet record = LIST_FORMAT_INSTANCE_INTERNAL_MAP.get(instance);\n\tif (record == null) {\n\t\trecord = Object.create(null) as ListFormatInstanceInternals;\n\t\tLIST_FORMAT_INSTANCE_INTERNAL_MAP.set(instance, record);\n\t}\n\n\t// Update the property with the given value\n\trecord[property] = value;\n}\n\n/**\n * Gets the value associated with the given property on the internal slots of the given instance of ListFormat\n * @param {ListFormat} instance\n * @param {T} property\n * @returns{ListFormatInstanceInternals[T]}\n */\nexport function getInternalSlot<T extends keyof ListFormatInstanceInternals>(instance: ListFormat, property: T): ListFormatInstanceInternals[T] {\n\tconst record = LIST_FORMAT_INSTANCE_INTERNAL_MAP.get(instance);\n\tif (record == null) {\n\t\tthrow new ReferenceError(`No internal slots has been allocated for the given instance of ListFormat`);\n\t}\n\n\treturn record[property];\n}\n\n/**\n * Returns true if the given property on the internal slots of the given instance of ListFormat exists\n * @param {ListFormat} instance\n * @param {T} property\n * @returns{ListFormatInstanceInternals[T]}\n */\nexport function hasInternalSlot<T extends keyof ListFormatInstanceInternals>(instance: ListFormat, property: T): boolean {\n\tconst record = LIST_FORMAT_INSTANCE_INTERNAL_MAP.get(instance);\n\treturn record != null && property in record;\n}\n","/**\n * A Regular Expression that matches Unicode extension sequences\n * @type {RegExp}\n */\nexport const UNICODE_EXTENSION_SEQUENCE_REGEXP = /-u(?:-[0-9a-z]{2,8})+/gi;\n\n/**\n * Removes all Unicode characters from the given string\n * @param {string} str\n * @returns{string}\n */\nexport function removeUnicodeExtensionSequences(str: string): string {\n\treturn str.replace(UNICODE_EXTENSION_SEQUENCE_REGEXP, \"\");\n}\n","import {Locales} from \"../../locale/locales\";\nimport {Locale} from \"../../locale/locale\";\n\n/**\n * The BestAvailableLocale abstract operation compares the provided argument locale,\n * which must be a String value with a structurally valid and canonicalized BCP 47 language tag,\n * against the locales in availableLocales and returns either the longest non-empty prefix of locale\n * that is an element of availableLocales, or undefined if there is no such element. It uses the fallback\n * mechanism of RFC 4647, section 3.4.\n *\n * https://tc39.github.io/ecma402/#sec-bestavailablelocale\n * @param {Locales} availableLocales\n * @param {Locale} locale\n * @returns{string}\n */\nexport function bestAvailableLocale(availableLocales: Locales, locale: Locale): string | undefined {\n\t// Let candidate be locale.\n\tlet candidate = locale;\n\t// Repeat\n\twhile (true) {\n\t\t// If availableLocales contains an element equal to candidate, return candidate.\n\t\tif (availableLocales.includes(candidate)) {\n\t\t\treturn candidate;\n\t\t}\n\n\t\t// Let pos be the character index of the last occurrence of \"-\" (U+002D) within candidate.\n\t\tlet pos = candidate.lastIndexOf(\"-\");\n\t\t// If that character does not occur, return undefined.\n\t\tif (pos === -1) return undefined;\n\n\t\t// If pos ≥ 2 and the character \"-\" occurs at index pos-2 of candidate, decrease pos by 2.\n\t\tif (pos >= 2 && candidate.charAt(pos - 2) === \"-\") {\n\t\t\tpos -= 2;\n\t\t}\n\n\t\t// Let candidate be the substring of candidate from position 0, inclusive, to position pos, exclusive.\n\t\tcandidate = candidate.slice(0, pos);\n\t}\n}\n","import {Locales} from \"../locale/locales\";\nimport {removeUnicodeExtensionSequences} from \"../unicode-extension/unicode-extension\";\nimport {bestAvailableLocale} from \"../matcher/best-available-locale/best-available-locale\";\n\n/**\n * The LookupSupportedLocales abstract operation returns the subset of the provided BCP 47 language priority list\n * requestedLocales for which availableLocales has a matching locale when using the BCP 47 Lookup algorithm.\n * Locales appear in the same order in the returned list as in requestedLocales.\n *\n * https://tc39.github.io/ecma402/#sec-bestfitsupportedlocales\n * @param {Locales} availableLocales\n * @param {Locales} requestedLocales\n * @returns{Locales}\n */\nexport function lookupSupportedLocales(availableLocales: Locales, requestedLocales: Locales): Locales {\n\t// Let subset be a new empty List.\n\tconst subset: Locales = [];\n\t// For each element locale of requestedLocales in List order, do\n\tfor (const locale of requestedLocales) {\n\t\t// Let noExtensionsLocale be the String value that is locale with all Unicode locale extension sequences removed.\n\t\tconst noExtensionsLocale = removeUnicodeExtensionSequences(locale);\n\n\t\t// Let availableLocale be BestAvailableLocale(availableLocales, noExtensionsLocale).\n\t\tconst availableLocale = bestAvailableLocale(availableLocales, noExtensionsLocale);\n\n\t\t// If availableLocale is not undefined, append locale to the end of subset.\n\t\tif (availableLocale !== undefined) {\n\t\t\tsubset.push(locale);\n\t\t}\n\t}\n\treturn subset;\n}\n","import {lookupSupportedLocales} from \"./lookup-supported-locales\";\nimport {Locales} from \"../locale/locales\";\n\n/**\n * The BestFitSupportedLocales abstract operation returns the subset of the provided BCP 47 language priority list\n * requestedLocales for which availableLocales has a matching locale when using the Best Fit Matcher algorithm.\n * Locales appear in the same order in the returned list as in requestedLocales.\n *\n * https://tc39.github.io/ecma402/#sec-bestfitsupportedlocales\n * @param {Locales} availableLocales\n * @param {Locales} requestedLocales\n * @returns{Locales}\n */\nexport function bestFitSupportedLocales(availableLocales: Locales, requestedLocales: Locales): Locales {\n\treturn lookupSupportedLocales(availableLocales, requestedLocales);\n}\n","/**\n * The abstract operation IsPropertyKey determines if argument, which must be an ECMAScript language value, is a value that may be used as a property key.\n * https://tc39.es/ecma262/#sec-ispropertykey\n * @param {*} argument\n * @returns {boolean}\n */\nexport function isPropertyKey(argument: unknown): argument is PropertyKey {\n\t// If Type(argument) is String, return true.\n\tif (typeof argument === \"string\") return true;\n\t// If Type(argument) is Symbol, return true.\n\tif (typeof argument === \"symbol\") return true;\n\t// Return false.\n\treturn false;\n}\n","import {isPropertyKey} from \"./is-property-key\";\n\n/**\n * The abstract operation Get is used to retrieve the value of a specific property of an object. The operation is called with arguments O and P where O is the object and P is the property key.\n * https://tc39.es/ecma262/#sec-get-o-p\n * @param {O} o\n * @param {P} p\n * @returns {O[P]}\n */\nexport function get<O extends object, P extends keyof O>(o: O, p: P): O[P] {\n\t// Assert: Type(O) is Object.\n\tif (typeof o !== \"object\") {\n\t\tthrow new TypeError(`Given argument ${o} must be of type Object`);\n\t}\n\n\t// Assert: IsPropertyKey(P) is true.\n\tif (!isPropertyKey(p)) {\n\t\tthrow new TypeError(`Given argument ${p} must be a PropertyKey`);\n\t}\n\treturn o[p];\n}\n","/**\n * The abstract operation ToBoolean converts argument to a value of type Boolean\n * https://tc39.es/ecma262/#sec-toboolean\n * @param {*} argument\n * @returns {boolean}\n */\nexport function toBoolean(argument: unknown): boolean {\n\treturn Boolean(argument);\n}\n","/**\n * The abstract operation ToString converts argument to a value of type String\n * https://tc39.es/ecma262/#sec-tostring\n * @param {*} argument\n * @returns {boolean}\n */\nexport function toString(argument: unknown): string {\n\treturn argument + \"\";\n}\n","import {get} from \"./get\";\nimport {toBoolean} from \"./to-boolean\";\nimport {toString} from \"./to-string\";\nimport {ElementOf} from \"./element-of\";\n\n/**\n * https://tc39.es/ecma402/#sec-getoption\n * @param {Options} options\n * @param {Property} property\n * @param {Type} type\n * @param {Values} values\n * @param {Fallback} fallback\n * @returns {Return}\n */\nexport function getOption<\n\tOptions extends object,\n\tProperty extends keyof Options,\n\tType extends Options[Property] extends (string | (string | undefined)) ? \"string\" : \"boolean\",\n\tValues extends Options[Property] extends (string | (string | undefined)) ? readonly string[] : readonly boolean[],\n\tFallback extends ElementOf<Values>,\n\tReturn extends ElementOf<Values>\n>(options: Options, property: Property, type: Type, values: Values, fallback: Fallback): Return {\n\t// Let value be ? Get(options, property).\n\tlet value = get(options, property);\n\t// If value is not undefined, then\n\tif (value !== undefined) {\n\t\t// Assert: type is \"boolean\" or \"string\".\n\t\tif (type !== \"boolean\" && type !== \"string\") {\n\t\t\tthrow new TypeError(`Expected type ${type} to be 'boolean' or 'string`);\n\t\t}\n\n\t\t// If type is \"boolean\", then\n\t\tif (type === \"boolean\") {\n\t\t\t// Let value be ToBoolean(value).\n\t\t\tvalue = (toBoolean(value) as unknown) as Options[Property];\n\t\t}\n\n\t\t// If type is \"string\", then\n\t\tif (type === \"string\") {\n\t\t\t// Let value be ? ToString(value).\n\t\t\tvalue = (toString(value) as unknown) as Options[Property];\n\t\t}\n\n\t\t// If values is not undefined, then\n\t\tif (values !== undefined) {\n\t\t\t// If values does not contain an element equal to value, throw a RangeError exception.\n\t\t\t// tslint:disable-next-line:no-collapsible-if\n\t\t\tif (!values.includes(value as never)) {\n\t\t\t\tthrow new RangeError(`Value ${value} out of range for options property ${property}`);\n\t\t\t}\n\t\t}\n\n\t\t// Return value.\n\t\treturn (value as unknown) as Return;\n\t}\n\n\t// Else, return fallback.\n\telse {\n\t\treturn (fallback as unknown) as Return;\n\t}\n}\n","import {bestFitSupportedLocales} from \"./best-fit-supported-locales\";\nimport {lookupSupportedLocales} from \"./lookup-supported-locales\";\nimport {SupportedLocalesOptions} from \"./supported-locales-options\";\nimport {Locales} from \"../locale/locales\";\nimport {toObject} from \"../util/to-object\";\nimport {LOCALE_MATCHER, LocaleMatcher} from \"../locale-matcher/locale-matcher\";\nimport {getOption} from \"../util/get-option\";\n\n/**\n * The SupportedLocales abstract operation returns the subset of the provided BCP 47 language priority list\n * requestedLocales for which availableLocales has a matching locale. Two algorithms are available to match\n * the locales: the Lookup algorithm described in RFC 4647 section 3.4, and an implementation dependent\n * best-fit algorithm. Locales appear in the same order in the returned list as in requestedLocales.\n *\n * https://tc39.github.io/ecma402/#sec-supportedlocales\n * @param {Locales} availableLocales\n * @param {Locales} requestedLocales\n * @param {SupportedLocalesOptions} [options]\n * @returns{Locales}\n */\nexport function supportedLocales(availableLocales: Locales, requestedLocales: Locales, options?: SupportedLocalesOptions): Locales {\n\tlet matcher: LocaleMatcher;\n\n\t// If options is not undefined, then\n\tif (options !== undefined) {\n\t\t// Let options be ? ToObject(options).\n\t\toptions = toObject(options);\n\n\t\t// Let matcher be ? GetOption(options, \"localeMatcher\", \"string\", « \"lookup\", \"best fit\" », \"best fit\").\n\t\tmatcher = getOption(options, \"localeMatcher\", \"string\", LOCALE_MATCHER, \"best fit\");\n\t}\n\n\t// Else, let matcher be \"best fit\".\n\telse {\n\t\tmatcher = \"best fit\";\n\t}\n\n\t// If matcher is \"best fit\", then let supportedLocales be BestFitSupportedLocales(availableLocales, requestedLocales).\n\t// Else let supportedLocales be LookupSupportedLocales(availableLocales, requestedLocales).\n\t// Return CreateArrayFromList(supportedLocales).\n\treturn matcher === \"best fit\"\n\t\t? bestFitSupportedLocales(availableLocales, requestedLocales)\n\t\t: lookupSupportedLocales(availableLocales, requestedLocales);\n}\n","import {MatcherOptions} from \"../matcher-options\";\nimport {removeUnicodeExtensionSequences, UNICODE_EXTENSION_SEQUENCE_REGEXP} from \"../../unicode-extension/unicode-extension\";\nimport {bestAvailableLocale} from \"../best-available-locale/best-available-locale\";\nimport {MatcherResult} from \"../matcher-result\";\nimport {ensureDefaultLocale} from \"../../default-locale/get-default-locale\";\n\n/**\n * The LookupMatcher abstract operation compares requestedLocales, which must be a List as returned by CanonicalizeLocaleList,\n * against the locales in availableLocales and determines the best available language to meet the request.\n *\n * https://tc39.github.io/ecma402/#sec-lookupmatcher\n * @param {MatcherOptions} options\n * @returns{MatcherResult}\n */\nexport function lookupMatcher({availableLocales, requestedLocales}: MatcherOptions): MatcherResult {\n\t// Let result be a new Record.\n\tconst result = Object.create(null) as MatcherResult;\n\t// For each element locale of requestedLocales in List order, do\n\tfor (const locale of requestedLocales) {\n\t\t// Let noExtensionsLocale be the String value that is locale with all Unicode locale extension sequences removed.\n\t\tconst noExtensionsLocale = removeUnicodeExtensionSequences(locale);\n\n\t\t// Let availableLocale be BestAvailableLocale(availableLocales, noExtensionsLocale).\n\t\tconst availableLocale = bestAvailableLocale(availableLocales, noExtensionsLocale);\n\n\t\t// If availableLocale is not undefined, then\n\t\tif (availableLocale !== undefined) {\n\t\t\t// Set result.[[locale]] to availableLocale.\n\t\t\tresult.locale = availableLocale;\n\n\t\t\t// If locale and noExtensionsLocale are not the same String value, then\n\t\t\tif (locale !== noExtensionsLocale) {\n\t\t\t\t// Let extension be the String value consisting of the first substring of local\n\t\t\t\t// that is a Unicode locale extension sequence.\n\t\t\t\tconst extensionMatch = locale.match(UNICODE_EXTENSION_SEQUENCE_REGEXP);\n\t\t\t\t// Set result.[[extension]] to extension.\n\t\t\t\tresult.extension = extensionMatch == null ? \"\" : extensionMatch[0];\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\t// Let defLocale be DefaultLocale().\n\tconst defLocale = ensureDefaultLocale();\n\n\t// Set result.[[locale]] to defLocale.\n\tresult.locale = defLocale;\n\n\t// Return result.\n\treturn result;\n}\n","import {MatcherOptions} from \"../matcher-options\";\nimport {MatcherResult} from \"../matcher-result\";\nimport {lookupMatcher} from \"../lookup-matcher/lookup-matcher\";\n\n/**\n * The BestFitMatcher abstract operation compares requestedLocales,\n * which must be a List as returned by CanonicalizeLocaleList,\n * against the locales in availableLocales and determines the best available language to meet the request.\n * The algorithm is implementation dependent, but should produce results that a typical user of the requested\n * locales would perceive as at least as good as those produced by the LookupMatcher abstract operation.\n * ListFormatOptions specified through Unicode locale extension sequences must be ignored by the algorithm.\n * Information about such subsequences is returned separately. The abstract operation returns a record\n * with a [[locale]] field, whose value is the language tag of the selected locale,\n * which must be an element of availableLocales.\n * If the language tag of the request locale that led to the selected locale contained a Unicode locale extension sequence,\n * then the returned record also contains an [[extension]] field whose value is the first Unicode locale extension sequence\n * within the request locale language tag.\n *\n * https://tc39.github.io/ecma402/#sec-bestfitmatcher\n * @param {MatcherOptions} options\n * @returns{MatcherResult}\n */\nexport function bestFitMatcher(options: MatcherOptions): MatcherResult {\n\treturn lookupMatcher(options);\n}\n","import {ResolveLocaleOptions} from \"./resolve-locale-options\";\nimport {lookupMatcher} from \"../matcher/lookup-matcher/lookup-matcher\";\nimport {bestFitMatcher} from \"../matcher/best-fit-matcher/best-fit-matcher\";\nimport {ResolveLocaleResult} from \"./resolve-locale-result\";\nimport {Locales} from \"../locale/locales\";\nimport {RelevantExtensionKey} from \"../relevant-extension-key/relevant-extension-key\";\nimport {LocaleData} from \"../locale/locale-data\";\n\n/**\n * The ResolveLocale abstract operation compares a BCP 47 language priority list\n * requestedLocales against the locales in availableLocales and determines the best available language to meet the request.\n * availableLocales, requestedLocales, and relevantExtensionKeys must be provided as List values,\n * options and localeData as Records.\n *\n * https://tc39.github.io/ecma402/#sec-resolvelocale\n * @param {Locales} availableLocales\n * @param {Locales} requestedLocales\n * @param {ResolveLocaleOptions} options\n * @param {RelevantExtensionKey[]} _relevantExtensionKeys\n * @param {LocaleData} _localeData\n * @returns {ResolveLocaleResult}\n */\nexport function resolveLocale(\n\tavailableLocales: Locales,\n\trequestedLocales: Locales,\n\toptions: ResolveLocaleOptions,\n\t_relevantExtensionKeys: RelevantExtensionKey[],\n\t_localeData: LocaleData\n): ResolveLocaleResult {\n\t// Let matcher be options.[[localeMatcher]].\n\tconst matcher = options.localeMatcher;\n\n\t// If matcher is \"lookup\", then\n\t// (a) Let r be LookupMatcher(availableLocales, requestedLocales).\n\t// (b) Let r be BestFitMatcher(availableLocales, requestedLocales).\n\tconst r = matcher === \"lookup\" ? lookupMatcher({availableLocales, requestedLocales}) : bestFitMatcher({availableLocales, requestedLocales});\n\n\t// Let foundLocale be r.[[locale]].\n\tlet foundLocale = r.locale;\n\n\t// Let result be a new Record.\n\tconst result = Object.create(null) as ResolveLocaleResult;\n\n\t// Set result.[[dataLocale]] to foundLocale.\n\tresult.dataLocale = foundLocale;\n\n\t// Let supportedExtension be \"-u\"\n\tconst supportedExtension = \"-u\";\n\n\t// For each element key of relevantExtensionKeys in List order, do\n\t// CORRECTION: According to the spec, there _are_ no relevant extension keys, so there's no point in walking through them\n\n\t// If the number of elements in supportedExtension is greater than 2, then\n\tif (supportedExtension.length > 2) {\n\t\t// Let privateIndex be Call(%StringProto_indexOf%, foundLocale, « \"-x-\" »).\n\t\tconst privateIndex = String.prototype.indexOf.call(foundLocale, \"-x-\");\n\n\t\t// If privateIndex = -1, then\n\t\tif (privateIndex === -1) {\n\t\t\t// Let foundLocale be the concatenation of foundLocale and supportedExtension.\n\t\t\tfoundLocale = `${foundLocale}${supportedExtension}`;\n\t\t}\n\n\t\t// Else,\n\t\telse {\n\t\t\t// Let preExtension be the substring of foundLocale from position 0, inclusive, to position privateIndex, exclusive.\n\t\t\tconst preExtension = foundLocale.slice(0, privateIndex);\n\n\t\t\t// Let postExtension be the substring of foundLocale from position privateIndex to the end of the string.\n\t\t\tconst postExtension = foundLocale.slice(privateIndex);\n\n\t\t\t// Let foundLocale be the concatenation of preExtension, supportedExtension, and postExtension.\n\t\t\tfoundLocale = `${preExtension}${supportedExtension}${postExtension}`;\n\t\t}\n\n\t\t// Assert: IsStructurallyValidLanguageTag(foundLocale) is true.\n\t\t// Let foundLocale be CanonicalizeLanguageTag(foundLocale).\n\t\t// Intl.getCanonicalLocales will throw a TypeError if the locale isn't structurally valid\n\t\tfoundLocale = Intl.getCanonicalLocales(foundLocale)[0];\n\t}\n\n\t// Set result.[[locale]] to foundLocale.\n\tresult.locale = foundLocale;\n\n\t// Return result.\n\treturn result;\n}\n","export default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}","export default function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}","/**\n * Creates a String list from an iterable.\n * Algorithm: http://tc39.github.io/proposal-intl-list-format/#sec-createstringlistfromiterable\n * \"This algorithm raises exceptions when it encounters values that are not Strings\n * because there is no obvious locale-aware coercion for arbitrary values.\"\n * @param {Iterable<string>} iterable\n * @return {string[]}\n */\nexport function stringListFromIterable(iterable?: Iterable<string>): string[] {\n\t// If iterable is undefined, then\n\tif (iterable === undefined) {\n\t\t// Return a new empty List.\n\t\treturn [];\n\t}\n\n\t// Spread into an array\n\tconst arr = [...iterable];\n\n\t// If any of the elements isn't a string, throw a TypeError\n\tif (arr.some(element => typeof element !== \"string\")) {\n\t\tthrow new TypeError(`All List items must be strings`);\n\t}\n\n\treturn arr;\n}\n","/**\n * Returns true if the given item is a record\n * @param {T} item\n * @return {item is T}\n */\nexport function isRecord<T>(item: T): item is Exclude<T, undefined> {\n\treturn Object.prototype.toString.call(item) === \"[object Object]\";\n}\n","import {isRecord} from \"./is-record\";\nimport {List} from \"../list/list\";\n\n/**\n * Returns true if the given item is a List\n * @param {T} item\n * @return {item is T}\n */\nexport function isList<T>(item: unknown): item is List<T> {\n\treturn Array.isArray(item) || isRecord(item);\n}\n","import {Placeables} from \"../placeables/placeables\";\nimport {ListPartition} from \"../list-partition/list-partition\";\nimport {isList} from \"../assert/is-list\";\n\n/**\n * The DeconstructPattern abstract operation is called with arguments pattern\n * (which must be a String) and placeables (which must be a Record),\n * and deconstructs the pattern string into a list of parts.\n * The placeables record is a record whose keys are placeables tokens used in the pattern string,\n * and values are parts records which will be used in the result List to represent the token part.\n *\n * http://tc39.github.io/proposal-intl-list-format/#sec-deconstructpattern\n * @param {string} pattern\n * @param {Placeables} placeables\n * @return {ListPartition[]}\n */\nexport function deconstructPattern(pattern: string, placeables: Placeables): ListPartition[] {\n\t// Let result be a new empty List.\n\tconst result: ListPartition[] = [];\n\n\t// Let beginIndex be ! Call(%StringProto_indexOf%, pattern, « \"{\", 0 »).\n\tlet beginIndex = String.prototype.indexOf.call(pattern, \"{\", 0);\n\n\t// Let nextIndex be 0.\n\tlet nextIndex = 0;\n\n\t// Let length be the number of code units in pattern.\n\tconst length = pattern.length;\n\n\t// Repeat, while beginIndex is an integer index into pattern\n\twhile (pattern[beginIndex] !== undefined) {\n\t\t// Let endIndex to ! Call(%StringProto_indexOf%, pattern, « \"}\", beginIndex »).\n\t\tconst endIndex = String.prototype.indexOf.call(pattern, \"}\", beginIndex);\n\n\t\t// Assert: endIndex is greater than beginIndex.\n\t\tif (endIndex <= beginIndex) {\n\t\t\tthrow new TypeError(`Expected endIndex: ${endIndex} to be greater than beginIndex: ${beginIndex}`);\n\t\t}\n\n\t\t// If beginIndex is greater than nextIndex, then\n\t\tif (beginIndex > nextIndex) {\n\t\t\t// Let literal be a substring of pattern from position nextIndex, inclusive, to position beginIndex, exclusive.\n\t\t\tconst literal = pattern.slice(nextIndex, beginIndex);\n\n\t\t\t// Append a new Record { [[Type]]: \"literal\", [[Value]]: literal } as the last element of result\n\t\t\tresult.push({\n\t\t\t\ttype: \"literal\",\n\t\t\t\tvalue: literal\n\t\t\t});\n\t\t}\n\n\t\t// Let part be the substring of pattern from position beginIndex, exclusive, to position endIndex, exclusive.\n\t\tconst part = pattern.slice(beginIndex + 1, endIndex);\n\n\t\t// Assert: placeables has a field [[<part>]].\n\t\tif (placeables[Number(part) as 0 | 1] == null) {\n\t\t\tthrow new TypeError(`Expected placeables to have a part for PropertyKey: ${part}`);\n\t\t}\n\n\t\t// Let subst be placeables.[[<part>]].\n\t\tconst subst = placeables[Number(part) as 0 | 1];\n\n\t\t// If Type(subst) is List, then\n\t\tif (isList(subst.value)) {\n\t\t\t// For each element s of subst in List order, do\n\t\t\tfor (const s of subst.value) {\n\t\t\t\t// Append s as the last element of result.\n\t\t\t\tresult.push(s);\n\t\t\t}\n\t\t}\n\n\t\t// Else,\n\t\telse {\n\t\t\t// Append subst as the last element of result.\n\t\t\tresult.push(subst);\n\t\t}\n\n\t\t// Set nextIndex to endIndex + 1.\n\t\tnextIndex = endIndex + 1;\n\n\t\t// Set beginIndex to ! Call(%StringProto_indexOf%, pattern, « \"{\", nextIndex »).\n\t\tbeginIndex = String.prototype.indexOf.call(pattern, \"{\", nextIndex);\n\t}\n\n\t// If nextIndex is less than length, then\n\tif (nextIndex < length) {\n\t\t// Let literal be the substring of pattern from position nextIndex, inclusive, to position length, exclusive.\n\t\tconst literal = pattern.slice(nextIndex, length);\n\n\t\t// Append a new Record { [[Type]]: \"literal\", [[Value]]: literal } as the last element of result.\n\t\tresult.push({\n\t\t\ttype: \"literal\",\n\t\t\tvalue: literal\n\t\t});\n\t}\n\n\t// Return result\n\treturn result;\n}\n","import {ListFormat} from \"../list-format/list-format\";\nimport {ElementPartition, ListPartition, ListPartitions} from \"../list-partition/list-partition\";\nimport {getInternalSlot} from \"../internal-slot/internal-slot\";\nimport {deconstructPattern} from \"../deconstruct-pattern/deconstruct-pattern\";\nimport {Placeables} from \"../placeables/placeables\";\n\n/**\n * The CreatePartsFromList abstract operation is called with arguments listFormat\n * (which must be an object initialized as a ListFormat) and list (which must be a List of String values),\n * and creates the corresponding list of parts according to the effective locale and the formatting options of listFormat.\n * Each part is a Record with two fields: [[Type]], which must be a string with values \"element\" or \"literal\",\n * and [[Value]] which must be a string or a number.\n * @param {ListFormat} listFormat\n * @param {string[]} list\n * @return {ListPartitions}\n */\nexport function createPartsFromList(listFormat: ListFormat, list: string[]): ListPartitions {\n\tlet pattern: string;\n\n\t// Let size be the number of elements of list.\n\tconst size = list.length;\n\n\t// If size is 0, then\n\tif (size === 0) {\n\t\t// Return a new empty List.\n\t\treturn [];\n\t}\n\n\t// If size is 2, then\n\tif (size === 2) {\n\t\t// Let pattern be listFormat.[[TemplatePair]].\n\t\tpattern = getInternalSlot(listFormat, \"templatePair\");\n\n\t\t// Let first be a new Record { [[Type]]: \"element\", [[Value]]: list[0] }.\n\t\tconst first: ElementPartition = {\n\t\t\ttype: \"element\",\n\t\t\tvalue: list[0]\n\t\t};\n\n\t\t// Let second be a new Record { [[Type]]: \"element\", [[Value]]: list[1] }.\n\t\tconst second: ElementPartition = {\n\t\t\ttype: \"element\",\n\t\t\tvalue: list[1]\n\t\t};\n\n\t\t// Let placeables be a new Record { [[0]]: first, [[1]]: second }.\n\t\tconst placeables: Placeables = {\n\t\t\t0: first,\n\t\t\t1: second\n\t\t};\n\n\t\t// Return DeconstructPattern(pattern, placeables).\n\t\treturn deconstructPattern(pattern, placeables);\n\t}\n\n\t// Let last be a new Record { [[Type]]: \"element\", [[Value]]: list[size - 1] }.\n\tconst last: ElementPartition = {\n\t\ttype: \"element\",\n\t\tvalue: list[size - 1]\n\t};\n\n\t// Let parts be « last ».\n\tlet parts: ListPartition[] = [last];\n\n\t// Let i be size - 2.\n\tlet i = size - 2;\n\n\t// Repeat, while i ≥ 0\n\twhile (i >= 0) {\n\t\t// If i is 0, then\n\t\tif (i === 0) {\n\t\t\t// Let pattern be listFormat.[[TemplateStart]].\n\t\t\tpattern = getInternalSlot(listFormat, \"templateStart\");\n\t\t}\n\n\t\t// Else, if i is less than size - 2, then\n\t\telse if (i < size - 2) {\n\t\t\t// Let pattern be listFormat.[[TemplateMiddle]].\n\t\t\tpattern = getInternalSlot(listFormat, \"templateMiddle\");\n\t\t}\n\n\t\t// Else,\n\t\telse {\n\t\t\t// Let pattern be listFormat.[[TemplateEnd]].\n\t\t\tpattern = getInternalSlot(listFormat, \"templateEnd\");\n\t\t}\n\n\t\t// Let head be a new Record { [[Type]]: \"element\", [[Value]]: list[i] }.\n\t\tconst head: ElementPartition = {\n\t\t\ttype: \"element\",\n\t\t\tvalue: list[i]\n\t\t};\n\n\t\t// Let tail be a new Record { [[Type]]: \"element\", [[Value]]: parts }.\n\t\tconst tail: ElementPartition = {\n\t\t\ttype: \"element\",\n\t\t\tvalue: parts\n\t\t};\n\n\t\t// Let placeables be a new Record { [[0]]: head, [[1]]: tail }.\n\t\tconst placeables: Placeables = {\n\t\t\t0: head,\n\t\t\t1: tail\n\t\t};\n\n\t\t// Set parts to DeconstructPattern(pattern, placeables).\n\t\tparts = deconstructPattern(pattern, placeables);\n\n\t\t// Decrement i by 1.\n\t\ti--;\n\t}\n\n\t// Return parts.\n\treturn parts;\n}\n","import {ListFormat} from \"../list-format/list-format\";\nimport {createPartsFromList} from \"../create-parts-from-list/create-parts-from-list\";\n\n/**\n * The FormatList abstract operation is called with arguments listFormat\n * (which must be an object initialized as a ListFormat) and list (which must be a List of String values)\n *\n * http://tc39.github.io/proposal-intl-list-format/#sec-formatlist\n * @param {ListFormat} listFormat\n * @param {string[]} list\n * @returns {string}\n */\nexport function formatList(listFormat: ListFormat, list: string[]): string {\n\t// Let parts be CreatePartsFromList(listFormat, list).\n\tconst parts = createPartsFromList(listFormat, list);\n\n\t// Let result be an empty String.\n\tlet result = \"\";\n\n\t// For each part in parts, do\n\tfor (const part of parts) {\n\t\t// Set result to a String value produced by concatenating result and part.[[Value]].\n\t\tresult += part.value;\n\t}\n\n\treturn result;\n}\n","import {ListFormat} from \"../list-format/list-format\";\nimport {ListPartitions} from \"../list-partition/list-partition\";\nimport {createPartsFromList} from \"../create-parts-from-list/create-parts-from-list\";\n\n/**\n * The FormatListToParts abstract operation is called with arguments listFormat\n * (which must be an object initialized as a ListFormat) and list (which must be a List of String values)\n *\n * http://tc39.github.io/proposal-intl-list-format/#sec-formatlisttoparts\n * @param {ListFormat} listFormat\n * @param {string[]} list\n * @returns {ListPartitions}\n */\nexport function formatListToParts(listFormat: ListFormat, list: string[]): ListPartitions {\n\treturn createPartsFromList(listFormat, list);\n}\n","import {Locale} from \"../locale/locale\";\nimport {Locales} from \"../locale/locales\";\nimport {ListFormatOptions} from \"../list-format-options/list-format-options\";\nimport {SupportedLocalesOptions} from \"../supported-locales-options/supported-locales-options\";\nimport {ListPartitions} from \"../list-partition/list-partition\";\nimport {ResolvedListFormatOptions} from \"../resolved-list-format-options/resolved-list-format-options\";\nimport {toObject} from \"../util/to-object\";\nimport {InputLocaleDataEntry} from \"../locale/locale-data\";\nimport {getDefaultLocale, setDefaultLocale} from \"../default-locale/get-default-locale\";\nimport {getInternalSlot, hasInternalSlot, LIST_FORMAT_STATIC_INTERNALS, setInternalSlot} from \"../internal-slot/internal-slot\";\nimport {supportedLocales} from \"../supported-locales/supported-locales\";\nimport {resolveLocale} from \"../resolve-locale/resolve-locale\";\nimport {stringListFromIterable} from \"../string-list-from-iterable\";\nimport {formatList} from \"../format-list/format-list\";\nimport {formatListToParts} from \"../format-list-to-parts/format-list-to-parts\";\nimport {getOption} from \"../util/get-option\";\nimport {TYPE} from \"../type/type\";\nimport {STYLE} from \"../style/style\";\nimport {LOCALE_MATCHER} from \"../locale-matcher/locale-matcher\";\n\n/**\n * The ListFormat constructor is the %ListFormat% intrinsic object and a standard built-in property of the Intl object.\n * Behaviour common to all service constructor properties of the Intl object is specified in 9.1.\n *\n * http://tc39.github.io/proposal-intl-list-format/#sec-intl-listformat-constructor\n */\nexport class ListFormat {\n\t// The spec states that the constructor must have a length of 0 and therefore be parameter-less\n\tconstructor() {\n\t\tconst locales = arguments[0] as Locale | Locales | undefined;\n\t\tlet options = arguments[1] as Partial<ListFormatOptions>;\n\n\t\t// If NewTarget is undefined, throw a TypeError exception.\n\t\tif (new.target === undefined) {\n\t\t\tthrow new TypeError(`Constructor Intl.ListFormat requires 'new'`);\n\t\t}\n\n\t\t// Let requestedLocales be ? CanonicalizeLocaleList(locales).\n\t\tconst requestedLocales = Intl.getCanonicalLocales(locales);\n\n\t\t// If options is undefined, then (a) Let options be ObjectCreate(null).\n\t\t// Else (b) Let options be ? ToObject(options).\n\t\toptions = options === undefined ? (Object.create(null) as Partial<ListFormatOptions>) : toObject(options);\n\n\t\t// Let opt be a new Record.\n\t\tconst opt = Object.create(null) as ListFormatOptions;\n\n\t\t// Let matcher be ? GetOption(options, \"localeMatcher\", \"string\", « \"lookup\", \"best fit\" »,  \"best fit\").\n\t\tconst matcher = getOption(options, \"localeMatcher\", \"string\", LOCALE_MATCHER, \"best fit\");\n\n\t\t// Set opt.[[localeMatcher]] to matcher.\n\t\topt.localeMatcher = matcher;\n\n\t\t// Let type be GetOption(options, \"type\", \"string\", « \"conjunction\", \"disjunction\", \"unit\" »,  \"conjunction\").\n\t\tconst type = getOption(options, \"type\", \"string\", TYPE, \"conjunction\");\n\n\t\t// Set listFormat.[[Type]] to type.\n\t\tsetInternalSlot(this, \"type\", type);\n\n\t\t// Let style be GetOption(options, \"style\", \"string\", « \"long\", \"short\", \"narrow\" », \"long\").\n\t\tconst style = getOption(options, \"style\", \"string\", STYLE, \"long\");\n\n\t\t// Set listFormat.[[Style]] to style.\n\t\tsetInternalSlot(this, \"style\", style);\n\n\t\t// Let localeData be %ListFormat%.[[LocaleData]].\n\t\tconst localeData = LIST_FORMAT_STATIC_INTERNALS.localeData;\n\n\t\t// Let r be ResolveLocale(%ListFormat%.[[AvailableLocales]], requestedLocales, opt, %ListFormat%.[[RelevantExtensionKeys]], localeData).\n\t\tconst r = resolveLocale(\n\t\t\tLIST_FORMAT_STATIC_INTERNALS.availableLocales,\n\t\t\trequestedLocales,\n\t\t\topt,\n\t\t\tLIST_FORMAT_STATIC_INTERNALS.relevantExtensionKeys,\n\t\t\tlocaleData\n\t\t);\n\n\t\t// Let dataLocale be r.[[dataLocale]].\n\t\tconst dataLocale = r.dataLocale;\n\n\t\t// Let dataLocaleData be localeData.[[<dataLocale>]].\n\t\tconst dataLocaleData = localeData[dataLocale]!;\n\n\t\t// Let dataLocaleTypes be dataLocaleData.[[<type>]].\n\t\tconst dataLocaleTypes = dataLocaleData.formats[type];\n\n\t\t// Let templates be dataLocaleTypes.[[<style>]].\n\t\tconst templates = dataLocaleTypes[style];\n\n\t\t// Set listFormat.[[TemplatePair]] to templates.[[Pair]].\n\t\tsetInternalSlot(this, \"templatePair\", templates.Pair);\n\n\t\t// Set listFormat.[[TemplateStart]] to templates.[[Start]].\n\t\tsetInternalSlot(this, \"templateStart\", templates.Start);\n\n\t\t// Set listFormat.[[TemplateMiddle]] to templates.[[Middle]].\n\t\tsetInternalSlot(this, \"templateMiddle\", templates.Middle);\n\n\t\t// Set listFormat.[[TemplateEnd]] to templates.[[End]].\n\t\tsetInternalSlot(this, \"templateEnd\", templates.End);\n\n\t\t// Set listFormat.[[Locale]] to r.[[locale]].\n\t\tsetInternalSlot(this, \"locale\", r.locale);\n\n\t\t// Intl.ListFormat instances have an [[InitializedListFormat]] internal slot.\n\t\tsetInternalSlot(this, \"initializedListFormat\", this);\n\t}\n\n\t/**\n\t * Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.\n\t * @param {Locale | Locales} locales\n\t * @returns{Locales}\n\t */\n\tpublic static supportedLocalesOf(locales: Locale | Locales): Locales {\n\t\t// The spec states that the 'length' value of supportedLocalesOf must be equal to 1,\n\t\t// so we have to pull the options argument out of the method signature\n\t\tconst options = arguments[1] as SupportedLocalesOptions | undefined;\n\n\t\t// Let availableLocales be %ListFormat%.[[AvailableLocales]].\n\t\tconst availableLocales = LIST_FORMAT_STATIC_INTERNALS.availableLocales;\n\n\t\t// Let requestedLocales be ? CanonicalizeLocaleList(locales).\n\t\tconst requestedLocales = Intl.getCanonicalLocales(locales);\n\t\treturn supportedLocales(availableLocales, requestedLocales, options);\n\t}\n\n\t/**\n\t * Adds locale data to the internal slot.\n\t * This API exactly mimics that of the Intl polyfill (https://github.com/andyearnshaw/Intl.js)\n\t * @private\n\t * @internal\n\t * @param {InputLocaleDataEntry} data\n\t * @param {Locale} locale\n\t */\n\tprotected static __addLocaleData({data, locale}: InputLocaleDataEntry): void {\n\t\t// Use the locale as the default one if none is configured\n\t\tconst defaultLocale = getDefaultLocale();\n\t\tif (defaultLocale == null) {\n\t\t\tsetDefaultLocale(locale);\n\t\t}\n\n\t\tLIST_FORMAT_STATIC_INTERNALS.localeData[locale] = data;\n\t\tif (!LIST_FORMAT_STATIC_INTERNALS.availableLocales.includes(locale)) {\n\t\t\tLIST_FORMAT_STATIC_INTERNALS.availableLocales.push(locale);\n\t\t}\n\t}\n\n\t/**\n\t * Formats the given list into a locale-sensitive string representation\n\t * @param {Iterable<string>} [list]\n\t * @returns{string}\n\t */\n\tpublic format(list?: Iterable<string>): string {\n\t\t// Let lf be the this value.\n\t\tconst lf = this;\n\n\t\t// If Type(lf) is not Object, throw a TypeError exception.\n\t\tif (!(lf instanceof Object)) {\n\t\t\tthrow new TypeError(`Method Intl.ListFormat.prototype.format called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// If ListFormat does not have an [[InitializedListFormat]] internal slot, throw a TypeError exception.\n\t\tif (!hasInternalSlot(lf, \"initializedListFormat\")) {\n\t\t\tthrow new TypeError(`Method Intl.ListFormat.prototype.format called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// Let stringList be ? StringListFromIterable(list).\n\t\tconst stringList = stringListFromIterable(list);\n\n\t\t// Return FormatList(lf, stringList).\n\t\treturn formatList(lf, stringList);\n\t}\n\n\t/**\n\t * Formats the given list into locale-sensitive partitions\n\t * @param {Iterable<string>} [list]\n\t * @returns{ListPartitions}\n\t */\n\tpublic formatToParts(list?: Iterable<string>): ListPartitions {\n\t\t// Let lf be the this value.\n\t\tconst lf = this;\n\n\t\t// If Type(lf) is not Object, throw a TypeError exception.\n\t\tif (!(lf instanceof Object)) {\n\t\t\tthrow new TypeError(`Method Intl.ListFormat.prototype.formatToParts called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// If listFormat does not have an [[InitializedListFormat]] internal slot, throw a TypeError exception.\n\t\tif (!hasInternalSlot(lf, \"initializedListFormat\")) {\n\t\t\tthrow new TypeError(`Method Intl.ListFormat.prototype.formatToParts called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// Let stringList be ? StringListFromIterable(list).\n\t\tconst stringList = stringListFromIterable(list);\n\n\t\t// Return FormatListToParts(lf, stringList).\n\t\treturn formatListToParts(lf, stringList);\n\t}\n\n\t/**\n\t * This method provides access to the locale and options computed during initialization of the object.\n\t * @returns {ResolvedListFormatOptions}\n\t */\n\tpublic resolvedOptions(): ResolvedListFormatOptions {\n\t\t// Let lf be the this value.\n\t\tconst lf = this;\n\n\t\t// If Type(lf) is not Object, throw a TypeError exception.\n\t\tif (!(lf instanceof Object)) {\n\t\t\tthrow new TypeError(`Method Intl.ListFormat.prototype.resolvedOptions called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// If listFormat does not have an [[InitializedListFormat]] internal slot, throw a TypeError exception.\n\t\tif (!hasInternalSlot(lf, \"initializedListFormat\")) {\n\t\t\tthrow new TypeError(`Method Intl.ListFormat.prototype.resolvedOptions called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\tconst locale = getInternalSlot(this, \"locale\");\n\t\tconst type = getInternalSlot(this, \"type\");\n\t\tconst style = getInternalSlot(this, \"style\");\n\n\t\treturn {\n\t\t\tlocale,\n\t\t\ttype,\n\t\t\tstyle\n\t\t};\n\t}\n}\n\n/**\n * The initial value of the @@toStringTag property is the string value \"Intl.ListFormat\".\n * This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.\n * @type {string}\n */\nObject.defineProperty(ListFormat.prototype, Symbol.toStringTag, {\n\twritable: false,\n\tenumerable: false,\n\tvalue: \"Intl.ListFormat\",\n\tconfigurable: true\n});\n","import {ListFormat} from \"../list-format/list-format\";\n\n/**\n * Patches Intl with Intl.ListFormat\n */\nexport function patch(): void {\n\tif (typeof Intl === \"undefined\") {\n\t\tthrow new TypeError(`Could not define Intl.ListFormat: Expected 'Intl' to exist. Remember to include polyfill for Intl.getCanonicalLocales before applying this polyfill`);\n\t}\n\tIntl.ListFormat = ListFormat;\n}\n","import {SUPPORTS_LIST_FORMAT} from \"./support/supports-intl-list-format\";\nimport {patch} from \"./patch/patch\";\n\nif (!SUPPORTS_LIST_FORMAT) {\n\tpatch();\n}\n"],"names":["arrayWithoutHoles","iterableToArray","nonIterableSpread"],"mappings":"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"}