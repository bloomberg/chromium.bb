{"version":3,"file":"index.min.js","sources":["../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","../node_modules/@babel/runtime/helpers/esm/typeof.js","../src/util/to-object.ts","../src/default-locale/get-default-locale.ts","../src/internal-slot/internal-slot.ts","../src/unicode-extension/unicode-extension.ts","../src/matcher/best-available-locale/best-available-locale.ts","../src/supported-locales/lookup-supported-locales.ts","../src/supported-locales/best-fit-supported-locales.ts","../src/util/is-property-key.ts","../src/util/get.ts","../src/util/to-boolean.ts","../src/util/to-string.ts","../src/util/get-option.ts","../src/supported-locales/supported-locales.ts","../src/matcher/lookup-matcher/lookup-matcher.ts","../src/matcher/best-fit-matcher/best-fit-matcher.ts","../src/resolve-locale/resolve-locale.ts","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../src/string-list-from-iterable.ts","../src/assert/is-record.ts","../src/assert/is-list.ts","../src/deconstruct-pattern/deconstruct-pattern.ts","../src/create-parts-from-list/create-parts-from-list.ts","../src/format-list/format-list.ts","../src/format-list-to-parts/format-list-to-parts.ts","../src/support/supports-intl-list-format.ts","../src/type/type.ts","../src/style/style.ts","../src/locale-matcher/locale-matcher.ts","../src/list-format/list-format.ts","../src/index.ts","../src/patch/patch.ts"],"sourcesContent":["export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nexport default function _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}","/* tslint:disable:use-primitive-type no-construct no-any */\n\n/**\n * The abstract operation ToObject converts argument to a value of type Object.\n *\n * https://tc39.github.io/ecma262/#sec-toobject\n * @param {T} argument\n * @returns{T extends boolean ? Boolean : T extends number ? Number : T extends string ? String : T extends symbol ? symbol : T}\n */\nexport function toObject<T>(argument: T): T extends boolean ? Boolean : T extends number ? Number : T extends string ? String : T extends symbol ? Symbol : T {\n\tif (argument == null) {\n\t\tthrow new TypeError(`Argument ${argument} cannot be converted to an Object`);\n\t}\n\n\tif (typeof argument === \"boolean\") {\n\t\treturn new Boolean(argument) as any;\n\t}\n\n\tif (typeof argument === \"number\") {\n\t\treturn new Number(argument) as any;\n\t}\n\n\tif (typeof argument === \"string\") {\n\t\treturn new String(argument) as any;\n\t}\n\n\tif (typeof argument === \"symbol\") {\n\t\treturn new Object(argument) as any;\n\t}\n\n\treturn argument as any;\n}\n","import {Locale} from \"../locale/locale\";\n\n/**\n * Must represent the structurally valid (6.2.2) and canonicalized (6.2.3) BCP 47 language tag for the host environment's current locale.\n *\n * https://tc39.github.io/ecma402/#sec-defaultlocale\n * @type {Locale?}\n */\nlet _defaultLocale: Locale | undefined;\n\n/**\n * Sets the default locale\n * @param {Locale} locale\n */\nexport function setDefaultLocale(locale: Locale): void {\n\t_defaultLocale = locale;\n}\n\n/**\n * The DefaultLocale abstract operation returns a String value representing the structurally valid (6.2.2) and canonicalized (6.2.3) BCP 47 language tag for the host environment's current locale.\n * https://tc39.github.io/ecma402/#sec-defaultlocale\n * @returns{Locale | undefined}\n */\nexport function getDefaultLocale(): Locale | undefined {\n\treturn _defaultLocale;\n}\n\n/**\n * Retrieves the default locale if it is set, and throws otherwise\n * @returns{Locale}\n */\nexport function ensureDefaultLocale(): Locale {\n\tif (_defaultLocale == null) {\n\t\tthrow new ReferenceError(`Could not determine locale: No default locale has been configured`);\n\t}\n\treturn _defaultLocale;\n}\n","import {ListFormatInstanceInternals} from \"./list-format-instance-internals\";\nimport {ListFormatStaticInternals} from \"./list-format-static-internals\";\nimport {ListFormat} from \"../list-format/list-format\";\n\n/**\n * A WeakMap between ListFormat instances and their internal slot members\n * @type {WeakMap<ListFormat, ListFormatInstanceInternals>}\n */\nexport const LIST_FORMAT_INSTANCE_INTERNAL_MAP: WeakMap<ListFormat, ListFormatInstanceInternals> = new WeakMap();\n\n/**\n * Contains the internal static for ListFormat\n * @type {ListFormatStaticInternals}\n */\nexport const LIST_FORMAT_STATIC_INTERNALS: ListFormatStaticInternals = {\n\t/**\n\t * The value of the [[RelevantExtensionKeys]] internal slot is « ».\n\t * http://tc39.github.io/proposal-intl-list-format/#sec-Intl.ListFormat-internal-slots\n\t */\n\trelevantExtensionKeys: [],\n\n\t/**\n\t * The value of the [[LocaleData]] internal slot is implementation defined within the constraints described in 9.1\n\t * http://tc39.github.io/proposal-intl-list-format/#sec-Intl.ListFormat-internal-slots\n\t */\n\tlocaleData: {},\n\n\t/**\n\t * The value of the [[AvailableLocales]] internal slot is implementation defined within the constraints described in 9.1.\n\t * http://tc39.github.io/proposal-intl-list-format/#sec-Intl.ListFormat-internal-slots\n\t */\n\tavailableLocales: []\n};\n\n/**\n * Sets the value for a property in an internal slot for an instance of ListFormat\n * @param {ListFormat} instance\n * @param {T} property\n * @param {ListFormatInstanceInternals[T]} value\n */\nexport function setInternalSlot<T extends keyof ListFormatInstanceInternals>(\n\tinstance: ListFormat,\n\tproperty: T,\n\tvalue: ListFormatInstanceInternals[T]\n): void {\n\tlet record = LIST_FORMAT_INSTANCE_INTERNAL_MAP.get(instance);\n\tif (record == null) {\n\t\trecord = Object.create(null) as ListFormatInstanceInternals;\n\t\tLIST_FORMAT_INSTANCE_INTERNAL_MAP.set(instance, record);\n\t}\n\n\t// Update the property with the given value\n\trecord[property] = value;\n}\n\n/**\n * Gets the value associated with the given property on the internal slots of the given instance of ListFormat\n * @param {ListFormat} instance\n * @param {T} property\n * @returns{ListFormatInstanceInternals[T]}\n */\nexport function getInternalSlot<T extends keyof ListFormatInstanceInternals>(instance: ListFormat, property: T): ListFormatInstanceInternals[T] {\n\tconst record = LIST_FORMAT_INSTANCE_INTERNAL_MAP.get(instance);\n\tif (record == null) {\n\t\tthrow new ReferenceError(`No internal slots has been allocated for the given instance of ListFormat`);\n\t}\n\n\treturn record[property];\n}\n\n/**\n * Returns true if the given property on the internal slots of the given instance of ListFormat exists\n * @param {ListFormat} instance\n * @param {T} property\n * @returns{ListFormatInstanceInternals[T]}\n */\nexport function hasInternalSlot<T extends keyof ListFormatInstanceInternals>(instance: ListFormat, property: T): boolean {\n\tconst record = LIST_FORMAT_INSTANCE_INTERNAL_MAP.get(instance);\n\treturn record != null && property in record;\n}\n","/**\n * A Regular Expression that matches Unicode extension sequences\n * @type {RegExp}\n */\nexport const UNICODE_EXTENSION_SEQUENCE_REGEXP = /-u(?:-[0-9a-z]{2,8})+/gi;\n\n/**\n * Removes all Unicode characters from the given string\n * @param {string} str\n * @returns{string}\n */\nexport function removeUnicodeExtensionSequences(str: string): string {\n\treturn str.replace(UNICODE_EXTENSION_SEQUENCE_REGEXP, \"\");\n}\n","import {Locales} from \"../../locale/locales\";\nimport {Locale} from \"../../locale/locale\";\n\n/**\n * The BestAvailableLocale abstract operation compares the provided argument locale,\n * which must be a String value with a structurally valid and canonicalized BCP 47 language tag,\n * against the locales in availableLocales and returns either the longest non-empty prefix of locale\n * that is an element of availableLocales, or undefined if there is no such element. It uses the fallback\n * mechanism of RFC 4647, section 3.4.\n *\n * https://tc39.github.io/ecma402/#sec-bestavailablelocale\n * @param {Locales} availableLocales\n * @param {Locale} locale\n * @returns{string}\n */\nexport function bestAvailableLocale(availableLocales: Locales, locale: Locale): string | undefined {\n\t// Let candidate be locale.\n\tlet candidate = locale;\n\t// Repeat\n\twhile (true) {\n\t\t// If availableLocales contains an element equal to candidate, return candidate.\n\t\tif (availableLocales.includes(candidate)) {\n\t\t\treturn candidate;\n\t\t}\n\n\t\t// Let pos be the character index of the last occurrence of \"-\" (U+002D) within candidate.\n\t\tlet pos = candidate.lastIndexOf(\"-\");\n\t\t// If that character does not occur, return undefined.\n\t\tif (pos === -1) return undefined;\n\n\t\t// If pos ≥ 2 and the character \"-\" occurs at index pos-2 of candidate, decrease pos by 2.\n\t\tif (pos >= 2 && candidate.charAt(pos - 2) === \"-\") {\n\t\t\tpos -= 2;\n\t\t}\n\n\t\t// Let candidate be the substring of candidate from position 0, inclusive, to position pos, exclusive.\n\t\tcandidate = candidate.slice(0, pos);\n\t}\n}\n","import {Locales} from \"../locale/locales\";\nimport {removeUnicodeExtensionSequences} from \"../unicode-extension/unicode-extension\";\nimport {bestAvailableLocale} from \"../matcher/best-available-locale/best-available-locale\";\n\n/**\n * The LookupSupportedLocales abstract operation returns the subset of the provided BCP 47 language priority list\n * requestedLocales for which availableLocales has a matching locale when using the BCP 47 Lookup algorithm.\n * Locales appear in the same order in the returned list as in requestedLocales.\n *\n * https://tc39.github.io/ecma402/#sec-bestfitsupportedlocales\n * @param {Locales} availableLocales\n * @param {Locales} requestedLocales\n * @returns{Locales}\n */\nexport function lookupSupportedLocales(availableLocales: Locales, requestedLocales: Locales): Locales {\n\t// Let subset be a new empty List.\n\tconst subset: Locales = [];\n\t// For each element locale of requestedLocales in List order, do\n\tfor (const locale of requestedLocales) {\n\t\t// Let noExtensionsLocale be the String value that is locale with all Unicode locale extension sequences removed.\n\t\tconst noExtensionsLocale = removeUnicodeExtensionSequences(locale);\n\n\t\t// Let availableLocale be BestAvailableLocale(availableLocales, noExtensionsLocale).\n\t\tconst availableLocale = bestAvailableLocale(availableLocales, noExtensionsLocale);\n\n\t\t// If availableLocale is not undefined, append locale to the end of subset.\n\t\tif (availableLocale !== undefined) {\n\t\t\tsubset.push(locale);\n\t\t}\n\t}\n\treturn subset;\n}\n","import {lookupSupportedLocales} from \"./lookup-supported-locales\";\nimport {Locales} from \"../locale/locales\";\n\n/**\n * The BestFitSupportedLocales abstract operation returns the subset of the provided BCP 47 language priority list\n * requestedLocales for which availableLocales has a matching locale when using the Best Fit Matcher algorithm.\n * Locales appear in the same order in the returned list as in requestedLocales.\n *\n * https://tc39.github.io/ecma402/#sec-bestfitsupportedlocales\n * @param {Locales} availableLocales\n * @param {Locales} requestedLocales\n * @returns{Locales}\n */\nexport function bestFitSupportedLocales(availableLocales: Locales, requestedLocales: Locales): Locales {\n\treturn lookupSupportedLocales(availableLocales, requestedLocales);\n}\n","/**\n * The abstract operation IsPropertyKey determines if argument, which must be an ECMAScript language value, is a value that may be used as a property key.\n * https://tc39.es/ecma262/#sec-ispropertykey\n * @param {*} argument\n * @returns {boolean}\n */\nexport function isPropertyKey(argument: unknown): argument is PropertyKey {\n\t// If Type(argument) is String, return true.\n\tif (typeof argument === \"string\") return true;\n\t// If Type(argument) is Symbol, return true.\n\tif (typeof argument === \"symbol\") return true;\n\t// Return false.\n\treturn false;\n}\n","import {isPropertyKey} from \"./is-property-key\";\n\n/**\n * The abstract operation Get is used to retrieve the value of a specific property of an object. The operation is called with arguments O and P where O is the object and P is the property key.\n * https://tc39.es/ecma262/#sec-get-o-p\n * @param {O} o\n * @param {P} p\n * @returns {O[P]}\n */\nexport function get<O extends object, P extends keyof O>(o: O, p: P): O[P] {\n\t// Assert: Type(O) is Object.\n\tif (typeof o !== \"object\") {\n\t\tthrow new TypeError(`Given argument ${o} must be of type Object`);\n\t}\n\n\t// Assert: IsPropertyKey(P) is true.\n\tif (!isPropertyKey(p)) {\n\t\tthrow new TypeError(`Given argument ${p} must be a PropertyKey`);\n\t}\n\treturn o[p];\n}\n","/**\n * The abstract operation ToBoolean converts argument to a value of type Boolean\n * https://tc39.es/ecma262/#sec-toboolean\n * @param {*} argument\n * @returns {boolean}\n */\nexport function toBoolean(argument: unknown): boolean {\n\treturn Boolean(argument);\n}\n","/**\n * The abstract operation ToString converts argument to a value of type String\n * https://tc39.es/ecma262/#sec-tostring\n * @param {*} argument\n * @returns {boolean}\n */\nexport function toString(argument: unknown): string {\n\treturn argument + \"\";\n}\n","import {get} from \"./get\";\nimport {toBoolean} from \"./to-boolean\";\nimport {toString} from \"./to-string\";\nimport {ElementOf} from \"./element-of\";\n\n/**\n * https://tc39.es/ecma402/#sec-getoption\n * @param {Options} options\n * @param {Property} property\n * @param {Type} type\n * @param {Values} values\n * @param {Fallback} fallback\n * @returns {Return}\n */\nexport function getOption<\n\tOptions extends object,\n\tProperty extends keyof Options,\n\tType extends Options[Property] extends (string | (string | undefined)) ? \"string\" : \"boolean\",\n\tValues extends Options[Property] extends (string | (string | undefined)) ? readonly string[] : readonly boolean[],\n\tFallback extends ElementOf<Values>,\n\tReturn extends ElementOf<Values>\n>(options: Options, property: Property, type: Type, values: Values, fallback: Fallback): Return {\n\t// Let value be ? Get(options, property).\n\tlet value = get(options, property);\n\t// If value is not undefined, then\n\tif (value !== undefined) {\n\t\t// Assert: type is \"boolean\" or \"string\".\n\t\tif (type !== \"boolean\" && type !== \"string\") {\n\t\t\tthrow new TypeError(`Expected type ${type} to be 'boolean' or 'string`);\n\t\t}\n\n\t\t// If type is \"boolean\", then\n\t\tif (type === \"boolean\") {\n\t\t\t// Let value be ToBoolean(value).\n\t\t\tvalue = (toBoolean(value) as unknown) as Options[Property];\n\t\t}\n\n\t\t// If type is \"string\", then\n\t\tif (type === \"string\") {\n\t\t\t// Let value be ? ToString(value).\n\t\t\tvalue = (toString(value) as unknown) as Options[Property];\n\t\t}\n\n\t\t// If values is not undefined, then\n\t\tif (values !== undefined) {\n\t\t\t// If values does not contain an element equal to value, throw a RangeError exception.\n\t\t\t// tslint:disable-next-line:no-collapsible-if\n\t\t\tif (!values.includes(value as never)) {\n\t\t\t\tthrow new RangeError(`Value ${value} out of range for options property ${property}`);\n\t\t\t}\n\t\t}\n\n\t\t// Return value.\n\t\treturn (value as unknown) as Return;\n\t}\n\n\t// Else, return fallback.\n\telse {\n\t\treturn (fallback as unknown) as Return;\n\t}\n}\n","import {bestFitSupportedLocales} from \"./best-fit-supported-locales\";\nimport {lookupSupportedLocales} from \"./lookup-supported-locales\";\nimport {SupportedLocalesOptions} from \"./supported-locales-options\";\nimport {Locales} from \"../locale/locales\";\nimport {toObject} from \"../util/to-object\";\nimport {LOCALE_MATCHER, LocaleMatcher} from \"../locale-matcher/locale-matcher\";\nimport {getOption} from \"../util/get-option\";\n\n/**\n * The SupportedLocales abstract operation returns the subset of the provided BCP 47 language priority list\n * requestedLocales for which availableLocales has a matching locale. Two algorithms are available to match\n * the locales: the Lookup algorithm described in RFC 4647 section 3.4, and an implementation dependent\n * best-fit algorithm. Locales appear in the same order in the returned list as in requestedLocales.\n *\n * https://tc39.github.io/ecma402/#sec-supportedlocales\n * @param {Locales} availableLocales\n * @param {Locales} requestedLocales\n * @param {SupportedLocalesOptions} [options]\n * @returns{Locales}\n */\nexport function supportedLocales(availableLocales: Locales, requestedLocales: Locales, options?: SupportedLocalesOptions): Locales {\n\tlet matcher: LocaleMatcher;\n\n\t// If options is not undefined, then\n\tif (options !== undefined) {\n\t\t// Let options be ? ToObject(options).\n\t\toptions = toObject(options);\n\n\t\t// Let matcher be ? GetOption(options, \"localeMatcher\", \"string\", « \"lookup\", \"best fit\" », \"best fit\").\n\t\tmatcher = getOption(options, \"localeMatcher\", \"string\", LOCALE_MATCHER, \"best fit\");\n\t}\n\n\t// Else, let matcher be \"best fit\".\n\telse {\n\t\tmatcher = \"best fit\";\n\t}\n\n\t// If matcher is \"best fit\", then let supportedLocales be BestFitSupportedLocales(availableLocales, requestedLocales).\n\t// Else let supportedLocales be LookupSupportedLocales(availableLocales, requestedLocales).\n\t// Return CreateArrayFromList(supportedLocales).\n\treturn matcher === \"best fit\"\n\t\t? bestFitSupportedLocales(availableLocales, requestedLocales)\n\t\t: lookupSupportedLocales(availableLocales, requestedLocales);\n}\n","import {MatcherOptions} from \"../matcher-options\";\nimport {removeUnicodeExtensionSequences, UNICODE_EXTENSION_SEQUENCE_REGEXP} from \"../../unicode-extension/unicode-extension\";\nimport {bestAvailableLocale} from \"../best-available-locale/best-available-locale\";\nimport {MatcherResult} from \"../matcher-result\";\nimport {ensureDefaultLocale} from \"../../default-locale/get-default-locale\";\n\n/**\n * The LookupMatcher abstract operation compares requestedLocales, which must be a List as returned by CanonicalizeLocaleList,\n * against the locales in availableLocales and determines the best available language to meet the request.\n *\n * https://tc39.github.io/ecma402/#sec-lookupmatcher\n * @param {MatcherOptions} options\n * @returns{MatcherResult}\n */\nexport function lookupMatcher({availableLocales, requestedLocales}: MatcherOptions): MatcherResult {\n\t// Let result be a new Record.\n\tconst result = Object.create(null) as MatcherResult;\n\t// For each element locale of requestedLocales in List order, do\n\tfor (const locale of requestedLocales) {\n\t\t// Let noExtensionsLocale be the String value that is locale with all Unicode locale extension sequences removed.\n\t\tconst noExtensionsLocale = removeUnicodeExtensionSequences(locale);\n\n\t\t// Let availableLocale be BestAvailableLocale(availableLocales, noExtensionsLocale).\n\t\tconst availableLocale = bestAvailableLocale(availableLocales, noExtensionsLocale);\n\n\t\t// If availableLocale is not undefined, then\n\t\tif (availableLocale !== undefined) {\n\t\t\t// Set result.[[locale]] to availableLocale.\n\t\t\tresult.locale = availableLocale;\n\n\t\t\t// If locale and noExtensionsLocale are not the same String value, then\n\t\t\tif (locale !== noExtensionsLocale) {\n\t\t\t\t// Let extension be the String value consisting of the first substring of local\n\t\t\t\t// that is a Unicode locale extension sequence.\n\t\t\t\tconst extensionMatch = locale.match(UNICODE_EXTENSION_SEQUENCE_REGEXP);\n\t\t\t\t// Set result.[[extension]] to extension.\n\t\t\t\tresult.extension = extensionMatch == null ? \"\" : extensionMatch[0];\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\t// Let defLocale be DefaultLocale().\n\tconst defLocale = ensureDefaultLocale();\n\n\t// Set result.[[locale]] to defLocale.\n\tresult.locale = defLocale;\n\n\t// Return result.\n\treturn result;\n}\n","import {MatcherOptions} from \"../matcher-options\";\nimport {MatcherResult} from \"../matcher-result\";\nimport {lookupMatcher} from \"../lookup-matcher/lookup-matcher\";\n\n/**\n * The BestFitMatcher abstract operation compares requestedLocales,\n * which must be a List as returned by CanonicalizeLocaleList,\n * against the locales in availableLocales and determines the best available language to meet the request.\n * The algorithm is implementation dependent, but should produce results that a typical user of the requested\n * locales would perceive as at least as good as those produced by the LookupMatcher abstract operation.\n * ListFormatOptions specified through Unicode locale extension sequences must be ignored by the algorithm.\n * Information about such subsequences is returned separately. The abstract operation returns a record\n * with a [[locale]] field, whose value is the language tag of the selected locale,\n * which must be an element of availableLocales.\n * If the language tag of the request locale that led to the selected locale contained a Unicode locale extension sequence,\n * then the returned record also contains an [[extension]] field whose value is the first Unicode locale extension sequence\n * within the request locale language tag.\n *\n * https://tc39.github.io/ecma402/#sec-bestfitmatcher\n * @param {MatcherOptions} options\n * @returns{MatcherResult}\n */\nexport function bestFitMatcher(options: MatcherOptions): MatcherResult {\n\treturn lookupMatcher(options);\n}\n","import {ResolveLocaleOptions} from \"./resolve-locale-options\";\nimport {lookupMatcher} from \"../matcher/lookup-matcher/lookup-matcher\";\nimport {bestFitMatcher} from \"../matcher/best-fit-matcher/best-fit-matcher\";\nimport {ResolveLocaleResult} from \"./resolve-locale-result\";\nimport {Locales} from \"../locale/locales\";\nimport {RelevantExtensionKey} from \"../relevant-extension-key/relevant-extension-key\";\nimport {LocaleData} from \"../locale/locale-data\";\n\n/**\n * The ResolveLocale abstract operation compares a BCP 47 language priority list\n * requestedLocales against the locales in availableLocales and determines the best available language to meet the request.\n * availableLocales, requestedLocales, and relevantExtensionKeys must be provided as List values,\n * options and localeData as Records.\n *\n * https://tc39.github.io/ecma402/#sec-resolvelocale\n * @param {Locales} availableLocales\n * @param {Locales} requestedLocales\n * @param {ResolveLocaleOptions} options\n * @param {RelevantExtensionKey[]} _relevantExtensionKeys\n * @param {LocaleData} _localeData\n * @returns {ResolveLocaleResult}\n */\nexport function resolveLocale(\n\tavailableLocales: Locales,\n\trequestedLocales: Locales,\n\toptions: ResolveLocaleOptions,\n\t_relevantExtensionKeys: RelevantExtensionKey[],\n\t_localeData: LocaleData\n): ResolveLocaleResult {\n\t// Let matcher be options.[[localeMatcher]].\n\tconst matcher = options.localeMatcher;\n\n\t// If matcher is \"lookup\", then\n\t// (a) Let r be LookupMatcher(availableLocales, requestedLocales).\n\t// (b) Let r be BestFitMatcher(availableLocales, requestedLocales).\n\tconst r = matcher === \"lookup\" ? lookupMatcher({availableLocales, requestedLocales}) : bestFitMatcher({availableLocales, requestedLocales});\n\n\t// Let foundLocale be r.[[locale]].\n\tlet foundLocale = r.locale;\n\n\t// Let result be a new Record.\n\tconst result = Object.create(null) as ResolveLocaleResult;\n\n\t// Set result.[[dataLocale]] to foundLocale.\n\tresult.dataLocale = foundLocale;\n\n\t// Let supportedExtension be \"-u\"\n\tconst supportedExtension = \"-u\";\n\n\t// For each element key of relevantExtensionKeys in List order, do\n\t// CORRECTION: According to the spec, there _are_ no relevant extension keys, so there's no point in walking through them\n\n\t// If the number of elements in supportedExtension is greater than 2, then\n\tif (supportedExtension.length > 2) {\n\t\t// Let privateIndex be Call(%StringProto_indexOf%, foundLocale, « \"-x-\" »).\n\t\tconst privateIndex = String.prototype.indexOf.call(foundLocale, \"-x-\");\n\n\t\t// If privateIndex = -1, then\n\t\tif (privateIndex === -1) {\n\t\t\t// Let foundLocale be the concatenation of foundLocale and supportedExtension.\n\t\t\tfoundLocale = `${foundLocale}${supportedExtension}`;\n\t\t}\n\n\t\t// Else,\n\t\telse {\n\t\t\t// Let preExtension be the substring of foundLocale from position 0, inclusive, to position privateIndex, exclusive.\n\t\t\tconst preExtension = foundLocale.slice(0, privateIndex);\n\n\t\t\t// Let postExtension be the substring of foundLocale from position privateIndex to the end of the string.\n\t\t\tconst postExtension = foundLocale.slice(privateIndex);\n\n\t\t\t// Let foundLocale be the concatenation of preExtension, supportedExtension, and postExtension.\n\t\t\tfoundLocale = `${preExtension}${supportedExtension}${postExtension}`;\n\t\t}\n\n\t\t// Assert: IsStructurallyValidLanguageTag(foundLocale) is true.\n\t\t// Let foundLocale be CanonicalizeLanguageTag(foundLocale).\n\t\t// Intl.getCanonicalLocales will throw a TypeError if the locale isn't structurally valid\n\t\tfoundLocale = Intl.getCanonicalLocales(foundLocale)[0];\n\t}\n\n\t// Set result.[[locale]] to foundLocale.\n\tresult.locale = foundLocale;\n\n\t// Return result.\n\treturn result;\n}\n","export default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}","export default function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}","/**\n * Creates a String list from an iterable.\n * Algorithm: http://tc39.github.io/proposal-intl-list-format/#sec-createstringlistfromiterable\n * \"This algorithm raises exceptions when it encounters values that are not Strings\n * because there is no obvious locale-aware coercion for arbitrary values.\"\n * @param {Iterable<string>} iterable\n * @return {string[]}\n */\nexport function stringListFromIterable(iterable?: Iterable<string>): string[] {\n\t// If iterable is undefined, then\n\tif (iterable === undefined) {\n\t\t// Return a new empty List.\n\t\treturn [];\n\t}\n\n\t// Spread into an array\n\tconst arr = [...iterable];\n\n\t// If any of the elements isn't a string, throw a TypeError\n\tif (arr.some(element => typeof element !== \"string\")) {\n\t\tthrow new TypeError(`All List items must be strings`);\n\t}\n\n\treturn arr;\n}\n","/**\n * Returns true if the given item is a record\n * @param {T} item\n * @return {item is T}\n */\nexport function isRecord<T>(item: T): item is Exclude<T, undefined> {\n\treturn Object.prototype.toString.call(item) === \"[object Object]\";\n}\n","import {isRecord} from \"./is-record\";\nimport {List} from \"../list/list\";\n\n/**\n * Returns true if the given item is a List\n * @param {T} item\n * @return {item is T}\n */\nexport function isList<T>(item: unknown): item is List<T> {\n\treturn Array.isArray(item) || isRecord(item);\n}\n","import {Placeables} from \"../placeables/placeables\";\nimport {ListPartition} from \"../list-partition/list-partition\";\nimport {isList} from \"../assert/is-list\";\n\n/**\n * The DeconstructPattern abstract operation is called with arguments pattern\n * (which must be a String) and placeables (which must be a Record),\n * and deconstructs the pattern string into a list of parts.\n * The placeables record is a record whose keys are placeables tokens used in the pattern string,\n * and values are parts records which will be used in the result List to represent the token part.\n *\n * http://tc39.github.io/proposal-intl-list-format/#sec-deconstructpattern\n * @param {string} pattern\n * @param {Placeables} placeables\n * @return {ListPartition[]}\n */\nexport function deconstructPattern(pattern: string, placeables: Placeables): ListPartition[] {\n\t// Let result be a new empty List.\n\tconst result: ListPartition[] = [];\n\n\t// Let beginIndex be ! Call(%StringProto_indexOf%, pattern, « \"{\", 0 »).\n\tlet beginIndex = String.prototype.indexOf.call(pattern, \"{\", 0);\n\n\t// Let nextIndex be 0.\n\tlet nextIndex = 0;\n\n\t// Let length be the number of code units in pattern.\n\tconst length = pattern.length;\n\n\t// Repeat, while beginIndex is an integer index into pattern\n\twhile (pattern[beginIndex] !== undefined) {\n\t\t// Let endIndex to ! Call(%StringProto_indexOf%, pattern, « \"}\", beginIndex »).\n\t\tconst endIndex = String.prototype.indexOf.call(pattern, \"}\", beginIndex);\n\n\t\t// Assert: endIndex is greater than beginIndex.\n\t\tif (endIndex <= beginIndex) {\n\t\t\tthrow new TypeError(`Expected endIndex: ${endIndex} to be greater than beginIndex: ${beginIndex}`);\n\t\t}\n\n\t\t// If beginIndex is greater than nextIndex, then\n\t\tif (beginIndex > nextIndex) {\n\t\t\t// Let literal be a substring of pattern from position nextIndex, inclusive, to position beginIndex, exclusive.\n\t\t\tconst literal = pattern.slice(nextIndex, beginIndex);\n\n\t\t\t// Append a new Record { [[Type]]: \"literal\", [[Value]]: literal } as the last element of result\n\t\t\tresult.push({\n\t\t\t\ttype: \"literal\",\n\t\t\t\tvalue: literal\n\t\t\t});\n\t\t}\n\n\t\t// Let part be the substring of pattern from position beginIndex, exclusive, to position endIndex, exclusive.\n\t\tconst part = pattern.slice(beginIndex + 1, endIndex);\n\n\t\t// Assert: placeables has a field [[<part>]].\n\t\tif (placeables[Number(part) as 0 | 1] == null) {\n\t\t\tthrow new TypeError(`Expected placeables to have a part for PropertyKey: ${part}`);\n\t\t}\n\n\t\t// Let subst be placeables.[[<part>]].\n\t\tconst subst = placeables[Number(part) as 0 | 1];\n\n\t\t// If Type(subst) is List, then\n\t\tif (isList(subst.value)) {\n\t\t\t// For each element s of subst in List order, do\n\t\t\tfor (const s of subst.value) {\n\t\t\t\t// Append s as the last element of result.\n\t\t\t\tresult.push(s);\n\t\t\t}\n\t\t}\n\n\t\t// Else,\n\t\telse {\n\t\t\t// Append subst as the last element of result.\n\t\t\tresult.push(subst);\n\t\t}\n\n\t\t// Set nextIndex to endIndex + 1.\n\t\tnextIndex = endIndex + 1;\n\n\t\t// Set beginIndex to ! Call(%StringProto_indexOf%, pattern, « \"{\", nextIndex »).\n\t\tbeginIndex = String.prototype.indexOf.call(pattern, \"{\", nextIndex);\n\t}\n\n\t// If nextIndex is less than length, then\n\tif (nextIndex < length) {\n\t\t// Let literal be the substring of pattern from position nextIndex, inclusive, to position length, exclusive.\n\t\tconst literal = pattern.slice(nextIndex, length);\n\n\t\t// Append a new Record { [[Type]]: \"literal\", [[Value]]: literal } as the last element of result.\n\t\tresult.push({\n\t\t\ttype: \"literal\",\n\t\t\tvalue: literal\n\t\t});\n\t}\n\n\t// Return result\n\treturn result;\n}\n","import {ListFormat} from \"../list-format/list-format\";\nimport {ElementPartition, ListPartition, ListPartitions} from \"../list-partition/list-partition\";\nimport {getInternalSlot} from \"../internal-slot/internal-slot\";\nimport {deconstructPattern} from \"../deconstruct-pattern/deconstruct-pattern\";\nimport {Placeables} from \"../placeables/placeables\";\n\n/**\n * The CreatePartsFromList abstract operation is called with arguments listFormat\n * (which must be an object initialized as a ListFormat) and list (which must be a List of String values),\n * and creates the corresponding list of parts according to the effective locale and the formatting options of listFormat.\n * Each part is a Record with two fields: [[Type]], which must be a string with values \"element\" or \"literal\",\n * and [[Value]] which must be a string or a number.\n * @param {ListFormat} listFormat\n * @param {string[]} list\n * @return {ListPartitions}\n */\nexport function createPartsFromList(listFormat: ListFormat, list: string[]): ListPartitions {\n\tlet pattern: string;\n\n\t// Let size be the number of elements of list.\n\tconst size = list.length;\n\n\t// If size is 0, then\n\tif (size === 0) {\n\t\t// Return a new empty List.\n\t\treturn [];\n\t}\n\n\t// If size is 2, then\n\tif (size === 2) {\n\t\t// Let pattern be listFormat.[[TemplatePair]].\n\t\tpattern = getInternalSlot(listFormat, \"templatePair\");\n\n\t\t// Let first be a new Record { [[Type]]: \"element\", [[Value]]: list[0] }.\n\t\tconst first: ElementPartition = {\n\t\t\ttype: \"element\",\n\t\t\tvalue: list[0]\n\t\t};\n\n\t\t// Let second be a new Record { [[Type]]: \"element\", [[Value]]: list[1] }.\n\t\tconst second: ElementPartition = {\n\t\t\ttype: \"element\",\n\t\t\tvalue: list[1]\n\t\t};\n\n\t\t// Let placeables be a new Record { [[0]]: first, [[1]]: second }.\n\t\tconst placeables: Placeables = {\n\t\t\t0: first,\n\t\t\t1: second\n\t\t};\n\n\t\t// Return DeconstructPattern(pattern, placeables).\n\t\treturn deconstructPattern(pattern, placeables);\n\t}\n\n\t// Let last be a new Record { [[Type]]: \"element\", [[Value]]: list[size - 1] }.\n\tconst last: ElementPartition = {\n\t\ttype: \"element\",\n\t\tvalue: list[size - 1]\n\t};\n\n\t// Let parts be « last ».\n\tlet parts: ListPartition[] = [last];\n\n\t// Let i be size - 2.\n\tlet i = size - 2;\n\n\t// Repeat, while i ≥ 0\n\twhile (i >= 0) {\n\t\t// If i is 0, then\n\t\tif (i === 0) {\n\t\t\t// Let pattern be listFormat.[[TemplateStart]].\n\t\t\tpattern = getInternalSlot(listFormat, \"templateStart\");\n\t\t}\n\n\t\t// Else, if i is less than size - 2, then\n\t\telse if (i < size - 2) {\n\t\t\t// Let pattern be listFormat.[[TemplateMiddle]].\n\t\t\tpattern = getInternalSlot(listFormat, \"templateMiddle\");\n\t\t}\n\n\t\t// Else,\n\t\telse {\n\t\t\t// Let pattern be listFormat.[[TemplateEnd]].\n\t\t\tpattern = getInternalSlot(listFormat, \"templateEnd\");\n\t\t}\n\n\t\t// Let head be a new Record { [[Type]]: \"element\", [[Value]]: list[i] }.\n\t\tconst head: ElementPartition = {\n\t\t\ttype: \"element\",\n\t\t\tvalue: list[i]\n\t\t};\n\n\t\t// Let tail be a new Record { [[Type]]: \"element\", [[Value]]: parts }.\n\t\tconst tail: ElementPartition = {\n\t\t\ttype: \"element\",\n\t\t\tvalue: parts\n\t\t};\n\n\t\t// Let placeables be a new Record { [[0]]: head, [[1]]: tail }.\n\t\tconst placeables: Placeables = {\n\t\t\t0: head,\n\t\t\t1: tail\n\t\t};\n\n\t\t// Set parts to DeconstructPattern(pattern, placeables).\n\t\tparts = deconstructPattern(pattern, placeables);\n\n\t\t// Decrement i by 1.\n\t\ti--;\n\t}\n\n\t// Return parts.\n\treturn parts;\n}\n","import {ListFormat} from \"../list-format/list-format\";\nimport {createPartsFromList} from \"../create-parts-from-list/create-parts-from-list\";\n\n/**\n * The FormatList abstract operation is called with arguments listFormat\n * (which must be an object initialized as a ListFormat) and list (which must be a List of String values)\n *\n * http://tc39.github.io/proposal-intl-list-format/#sec-formatlist\n * @param {ListFormat} listFormat\n * @param {string[]} list\n * @returns {string}\n */\nexport function formatList(listFormat: ListFormat, list: string[]): string {\n\t// Let parts be CreatePartsFromList(listFormat, list).\n\tconst parts = createPartsFromList(listFormat, list);\n\n\t// Let result be an empty String.\n\tlet result = \"\";\n\n\t// For each part in parts, do\n\tfor (const part of parts) {\n\t\t// Set result to a String value produced by concatenating result and part.[[Value]].\n\t\tresult += part.value;\n\t}\n\n\treturn result;\n}\n","import {ListFormat} from \"../list-format/list-format\";\nimport {ListPartitions} from \"../list-partition/list-partition\";\nimport {createPartsFromList} from \"../create-parts-from-list/create-parts-from-list\";\n\n/**\n * The FormatListToParts abstract operation is called with arguments listFormat\n * (which must be an object initialized as a ListFormat) and list (which must be a List of String values)\n *\n * http://tc39.github.io/proposal-intl-list-format/#sec-formatlisttoparts\n * @param {ListFormat} listFormat\n * @param {string[]} list\n * @returns {ListPartitions}\n */\nexport function formatListToParts(listFormat: ListFormat, list: string[]): ListPartitions {\n\treturn createPartsFromList(listFormat, list);\n}\n","export const SUPPORTS_LIST_FORMAT = \"ListFormat\" in Intl;\n","import {ElementOf} from \"../util/element-of\";\n\nexport const TYPE = [\"conjunction\", \"disjunction\", \"unit\"] as const;\n\nexport type Type = ElementOf<typeof TYPE>;\n","import {ElementOf} from \"../util/element-of\";\n\nexport const STYLE = [\"long\", \"short\", \"narrow\"] as const;\n\nexport type Style = ElementOf<typeof STYLE>;\n","import {ElementOf} from \"../util/element-of\";\n\nexport const LOCALE_MATCHER = [\"lookup\", \"best fit\"] as const;\n\nexport type LocaleMatcher = ElementOf<typeof LOCALE_MATCHER>;\n","import {Locale} from \"../locale/locale\";\nimport {Locales} from \"../locale/locales\";\nimport {ListFormatOptions} from \"../list-format-options/list-format-options\";\nimport {SupportedLocalesOptions} from \"../supported-locales-options/supported-locales-options\";\nimport {ListPartitions} from \"../list-partition/list-partition\";\nimport {ResolvedListFormatOptions} from \"../resolved-list-format-options/resolved-list-format-options\";\nimport {toObject} from \"../util/to-object\";\nimport {InputLocaleDataEntry} from \"../locale/locale-data\";\nimport {getDefaultLocale, setDefaultLocale} from \"../default-locale/get-default-locale\";\nimport {getInternalSlot, hasInternalSlot, LIST_FORMAT_STATIC_INTERNALS, setInternalSlot} from \"../internal-slot/internal-slot\";\nimport {supportedLocales} from \"../supported-locales/supported-locales\";\nimport {resolveLocale} from \"../resolve-locale/resolve-locale\";\nimport {stringListFromIterable} from \"../string-list-from-iterable\";\nimport {formatList} from \"../format-list/format-list\";\nimport {formatListToParts} from \"../format-list-to-parts/format-list-to-parts\";\nimport {getOption} from \"../util/get-option\";\nimport {TYPE} from \"../type/type\";\nimport {STYLE} from \"../style/style\";\nimport {LOCALE_MATCHER} from \"../locale-matcher/locale-matcher\";\n\n/**\n * The ListFormat constructor is the %ListFormat% intrinsic object and a standard built-in property of the Intl object.\n * Behaviour common to all service constructor properties of the Intl object is specified in 9.1.\n *\n * http://tc39.github.io/proposal-intl-list-format/#sec-intl-listformat-constructor\n */\nexport class ListFormat {\n\t// The spec states that the constructor must have a length of 0 and therefore be parameter-less\n\tconstructor() {\n\t\tconst locales = arguments[0] as Locale | Locales | undefined;\n\t\tlet options = arguments[1] as Partial<ListFormatOptions>;\n\n\t\t// If NewTarget is undefined, throw a TypeError exception.\n\t\tif (new.target === undefined) {\n\t\t\tthrow new TypeError(`Constructor Intl.ListFormat requires 'new'`);\n\t\t}\n\n\t\t// Let requestedLocales be ? CanonicalizeLocaleList(locales).\n\t\tconst requestedLocales = Intl.getCanonicalLocales(locales);\n\n\t\t// If options is undefined, then (a) Let options be ObjectCreate(null).\n\t\t// Else (b) Let options be ? ToObject(options).\n\t\toptions = options === undefined ? (Object.create(null) as Partial<ListFormatOptions>) : toObject(options);\n\n\t\t// Let opt be a new Record.\n\t\tconst opt = Object.create(null) as ListFormatOptions;\n\n\t\t// Let matcher be ? GetOption(options, \"localeMatcher\", \"string\", « \"lookup\", \"best fit\" »,  \"best fit\").\n\t\tconst matcher = getOption(options, \"localeMatcher\", \"string\", LOCALE_MATCHER, \"best fit\");\n\n\t\t// Set opt.[[localeMatcher]] to matcher.\n\t\topt.localeMatcher = matcher;\n\n\t\t// Let type be GetOption(options, \"type\", \"string\", « \"conjunction\", \"disjunction\", \"unit\" »,  \"conjunction\").\n\t\tconst type = getOption(options, \"type\", \"string\", TYPE, \"conjunction\");\n\n\t\t// Set listFormat.[[Type]] to type.\n\t\tsetInternalSlot(this, \"type\", type);\n\n\t\t// Let style be GetOption(options, \"style\", \"string\", « \"long\", \"short\", \"narrow\" », \"long\").\n\t\tconst style = getOption(options, \"style\", \"string\", STYLE, \"long\");\n\n\t\t// Set listFormat.[[Style]] to style.\n\t\tsetInternalSlot(this, \"style\", style);\n\n\t\t// Let localeData be %ListFormat%.[[LocaleData]].\n\t\tconst localeData = LIST_FORMAT_STATIC_INTERNALS.localeData;\n\n\t\t// Let r be ResolveLocale(%ListFormat%.[[AvailableLocales]], requestedLocales, opt, %ListFormat%.[[RelevantExtensionKeys]], localeData).\n\t\tconst r = resolveLocale(\n\t\t\tLIST_FORMAT_STATIC_INTERNALS.availableLocales,\n\t\t\trequestedLocales,\n\t\t\topt,\n\t\t\tLIST_FORMAT_STATIC_INTERNALS.relevantExtensionKeys,\n\t\t\tlocaleData\n\t\t);\n\n\t\t// Let dataLocale be r.[[dataLocale]].\n\t\tconst dataLocale = r.dataLocale;\n\n\t\t// Let dataLocaleData be localeData.[[<dataLocale>]].\n\t\tconst dataLocaleData = localeData[dataLocale]!;\n\n\t\t// Let dataLocaleTypes be dataLocaleData.[[<type>]].\n\t\tconst dataLocaleTypes = dataLocaleData.formats[type];\n\n\t\t// Let templates be dataLocaleTypes.[[<style>]].\n\t\tconst templates = dataLocaleTypes[style];\n\n\t\t// Set listFormat.[[TemplatePair]] to templates.[[Pair]].\n\t\tsetInternalSlot(this, \"templatePair\", templates.Pair);\n\n\t\t// Set listFormat.[[TemplateStart]] to templates.[[Start]].\n\t\tsetInternalSlot(this, \"templateStart\", templates.Start);\n\n\t\t// Set listFormat.[[TemplateMiddle]] to templates.[[Middle]].\n\t\tsetInternalSlot(this, \"templateMiddle\", templates.Middle);\n\n\t\t// Set listFormat.[[TemplateEnd]] to templates.[[End]].\n\t\tsetInternalSlot(this, \"templateEnd\", templates.End);\n\n\t\t// Set listFormat.[[Locale]] to r.[[locale]].\n\t\tsetInternalSlot(this, \"locale\", r.locale);\n\n\t\t// Intl.ListFormat instances have an [[InitializedListFormat]] internal slot.\n\t\tsetInternalSlot(this, \"initializedListFormat\", this);\n\t}\n\n\t/**\n\t * Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.\n\t * @param {Locale | Locales} locales\n\t * @returns{Locales}\n\t */\n\tpublic static supportedLocalesOf(locales: Locale | Locales): Locales {\n\t\t// The spec states that the 'length' value of supportedLocalesOf must be equal to 1,\n\t\t// so we have to pull the options argument out of the method signature\n\t\tconst options = arguments[1] as SupportedLocalesOptions | undefined;\n\n\t\t// Let availableLocales be %ListFormat%.[[AvailableLocales]].\n\t\tconst availableLocales = LIST_FORMAT_STATIC_INTERNALS.availableLocales;\n\n\t\t// Let requestedLocales be ? CanonicalizeLocaleList(locales).\n\t\tconst requestedLocales = Intl.getCanonicalLocales(locales);\n\t\treturn supportedLocales(availableLocales, requestedLocales, options);\n\t}\n\n\t/**\n\t * Adds locale data to the internal slot.\n\t * This API exactly mimics that of the Intl polyfill (https://github.com/andyearnshaw/Intl.js)\n\t * @private\n\t * @internal\n\t * @param {InputLocaleDataEntry} data\n\t * @param {Locale} locale\n\t */\n\tprotected static __addLocaleData({data, locale}: InputLocaleDataEntry): void {\n\t\t// Use the locale as the default one if none is configured\n\t\tconst defaultLocale = getDefaultLocale();\n\t\tif (defaultLocale == null) {\n\t\t\tsetDefaultLocale(locale);\n\t\t}\n\n\t\tLIST_FORMAT_STATIC_INTERNALS.localeData[locale] = data;\n\t\tif (!LIST_FORMAT_STATIC_INTERNALS.availableLocales.includes(locale)) {\n\t\t\tLIST_FORMAT_STATIC_INTERNALS.availableLocales.push(locale);\n\t\t}\n\t}\n\n\t/**\n\t * Formats the given list into a locale-sensitive string representation\n\t * @param {Iterable<string>} [list]\n\t * @returns{string}\n\t */\n\tpublic format(list?: Iterable<string>): string {\n\t\t// Let lf be the this value.\n\t\tconst lf = this;\n\n\t\t// If Type(lf) is not Object, throw a TypeError exception.\n\t\tif (!(lf instanceof Object)) {\n\t\t\tthrow new TypeError(`Method Intl.ListFormat.prototype.format called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// If ListFormat does not have an [[InitializedListFormat]] internal slot, throw a TypeError exception.\n\t\tif (!hasInternalSlot(lf, \"initializedListFormat\")) {\n\t\t\tthrow new TypeError(`Method Intl.ListFormat.prototype.format called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// Let stringList be ? StringListFromIterable(list).\n\t\tconst stringList = stringListFromIterable(list);\n\n\t\t// Return FormatList(lf, stringList).\n\t\treturn formatList(lf, stringList);\n\t}\n\n\t/**\n\t * Formats the given list into locale-sensitive partitions\n\t * @param {Iterable<string>} [list]\n\t * @returns{ListPartitions}\n\t */\n\tpublic formatToParts(list?: Iterable<string>): ListPartitions {\n\t\t// Let lf be the this value.\n\t\tconst lf = this;\n\n\t\t// If Type(lf) is not Object, throw a TypeError exception.\n\t\tif (!(lf instanceof Object)) {\n\t\t\tthrow new TypeError(`Method Intl.ListFormat.prototype.formatToParts called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// If listFormat does not have an [[InitializedListFormat]] internal slot, throw a TypeError exception.\n\t\tif (!hasInternalSlot(lf, \"initializedListFormat\")) {\n\t\t\tthrow new TypeError(`Method Intl.ListFormat.prototype.formatToParts called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// Let stringList be ? StringListFromIterable(list).\n\t\tconst stringList = stringListFromIterable(list);\n\n\t\t// Return FormatListToParts(lf, stringList).\n\t\treturn formatListToParts(lf, stringList);\n\t}\n\n\t/**\n\t * This method provides access to the locale and options computed during initialization of the object.\n\t * @returns {ResolvedListFormatOptions}\n\t */\n\tpublic resolvedOptions(): ResolvedListFormatOptions {\n\t\t// Let lf be the this value.\n\t\tconst lf = this;\n\n\t\t// If Type(lf) is not Object, throw a TypeError exception.\n\t\tif (!(lf instanceof Object)) {\n\t\t\tthrow new TypeError(`Method Intl.ListFormat.prototype.resolvedOptions called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// If listFormat does not have an [[InitializedListFormat]] internal slot, throw a TypeError exception.\n\t\tif (!hasInternalSlot(lf, \"initializedListFormat\")) {\n\t\t\tthrow new TypeError(`Method Intl.ListFormat.prototype.resolvedOptions called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\tconst locale = getInternalSlot(this, \"locale\");\n\t\tconst type = getInternalSlot(this, \"type\");\n\t\tconst style = getInternalSlot(this, \"style\");\n\n\t\treturn {\n\t\t\tlocale,\n\t\t\ttype,\n\t\t\tstyle\n\t\t};\n\t}\n}\n\n/**\n * The initial value of the @@toStringTag property is the string value \"Intl.ListFormat\".\n * This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.\n * @type {string}\n */\nObject.defineProperty(ListFormat.prototype, Symbol.toStringTag, {\n\twritable: false,\n\tenumerable: false,\n\tvalue: \"Intl.ListFormat\",\n\tconfigurable: true\n});\n","import {SUPPORTS_LIST_FORMAT} from \"./support/supports-intl-list-format\";\nimport {patch} from \"./patch/patch\";\n\nif (!SUPPORTS_LIST_FORMAT) {\n\tpatch();\n}\n","import {ListFormat} from \"../list-format/list-format\";\n\n/**\n * Patches Intl with Intl.ListFormat\n */\nexport function patch(): void {\n\tif (typeof Intl === \"undefined\") {\n\t\tthrow new TypeError(`Could not define Intl.ListFormat: Expected 'Intl' to exist. Remember to include polyfill for Intl.getCanonicalLocales before applying this polyfill`);\n\t}\n\tIntl.ListFormat = ListFormat;\n}\n"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","descriptor","i","length","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","_typeof2","obj","Symbol","iterator","constructor","_typeof","toObject","argument","Boolean","Number","String","setDefaultLocale","locale","_defaultLocale","getDefaultLocale","ensureDefaultLocale","ReferenceError","setInternalSlot","property","value","record","LIST_FORMAT_INSTANCE_INTERNAL_MAP","get","create","set","getInternalSlot","hasInternalSlot","removeUnicodeExtensionSequences","str","replace","UNICODE_EXTENSION_SEQUENCE_REGEXP","bestAvailableLocale","availableLocales","candidate","includes","pos","lastIndexOf","charAt","slice","lookupSupportedLocales","requestedLocales","subset","noExtensionsLocale","availableLocale","push","bestFitSupportedLocales","isPropertyKey","o","p","toBoolean","toString","getOption","options","type","values","fallback","RangeError","supportedLocales","matcher","LOCALE_MATCHER","lookupMatcher","result","extensionMatch","match","extension","defLocale","bestFitMatcher","resolveLocale","localeMatcher","r","foundLocale","dataLocale","_arrayWithoutHoles","arr","Array","isArray","arr2","_iterableToArray","iter","call","from","_nonIterableSpread","_toConsumableArray","arrayWithoutHoles","iterableToArray","nonIterableSpread","stringListFromIterable","iterable","some","element","isRecord","item","isList","deconstructPattern","pattern","placeables","beginIndex","indexOf","nextIndex","endIndex","literal","part","subst","s","_literal","createPartsFromList","listFormat","list","size","first","second","last","parts","head","tail","formatList","formatListToParts","SUPPORTS_LIST_FORMAT","Intl","TYPE","STYLE","WeakMap","LIST_FORMAT_STATIC_INTERNALS","relevantExtensionKeys","localeData","ListFormat","locales","arguments","getCanonicalLocales","opt","style","dataLocaleData","dataLocaleTypes","formats","templates","Pair","Start","Middle","End","lf","stringList","data","defaultLocale","toStringTag"],"mappings":"oRAAe,QAASA,CAAAA,CAAT,CAAyBC,CAAzB,CAAmCC,CAAnC,CAAgD,CAC7D,GAAI,EAAED,CAAQ,WAAYC,CAAAA,CAAtB,CAAJ,CACE,KAAM,IAAIC,CAAAA,SAAJ,CAAc,mCAAd,ECFV,QAASC,CAAAA,CAAT,CAA2BC,CAA3B,CAAmCC,CAAnC,CAA0C,CACxC,IAAK,GACCC,CAAAA,CADD,CAAIC,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGF,CAAK,CAACG,MAA1B,CAAkCD,CAAC,EAAnC,CACMD,CADN,CACmBD,CAAK,CAACE,CAAD,CADxB,CAEED,CAAU,CAACG,UAAX,CAAwBH,CAAU,CAACG,UAAX,IAF1B,CAGEH,CAAU,CAACI,YAAX,GAHF,CAIM,SAAWJ,CAAAA,CAJjB,GAI6BA,CAAU,CAACK,QAAX,GAJ7B,EAKEC,MAAM,CAACC,cAAP,CAAsBT,CAAtB,CAA8BE,CAAU,CAACQ,GAAzC,CAA8CR,CAA9C,CAEH,CAEc,QAASS,CAAAA,CAAT,CAAsBd,CAAtB,CAAmCe,CAAnC,CAA+CC,CAA/C,CAA4D,CAGzE,MAFID,CAAAA,CAEJ,EAFgBb,CAAiB,CAACF,CAAW,CAACiB,SAAb,CAAwBF,CAAxB,CAEjC,CADIC,CACJ,EADiBd,CAAiB,CAACF,CAAD,CAAcgB,CAAd,CAClC,CAAOhB,ECbT,QAASkB,CAAAA,CAAT,CAAkBC,CAAlB,CAAuB,CAAuT,MAA1OD,CAAAA,CAA0O,CAA/R,UAAlB,QAAOE,CAAAA,MAAP,EAA2D,QAA3B,YAAOA,MAAM,CAACC,QAAd,CAAiR,CAA/N,SAAkBF,CAAlB,CAAuB,CAAE,gBAAcA,CAAd,CAAoB,CAAkL,CAA5J,SAAkBA,CAAlB,CAAuB,CAAE,MAAOA,CAAAA,CAAG,EAAsB,UAAlB,QAAOC,CAAAA,MAAd,EAAuCD,CAAG,CAACG,WAAJ,GAAoBF,MAA3D,EAAqED,CAAG,GAAKC,MAAM,CAACH,SAApF,CAAgG,QAAhG,UAAkHE,CAAlH,CAAwH,CAAI,CAAOD,CAAQ,CAACC,CAAD,CAAQ,CAEtV,QAASI,CAAAA,CAAT,CAAiBJ,CAAjB,CAAsB,CAWnC,MATEI,CAAAA,CASF,CAVsB,UAAlB,QAAOH,CAAAA,MAAP,EAA8D,QAA9B,GAAAF,CAAQ,CAACE,MAAM,CAACC,QAAR,CAU5C,CATY,SAAiBF,CAAjB,CAAsB,CAC9B,MAAOD,CAAAA,CAAQ,CAACC,CAAD,CAChB,CAOH,CALY,SAAiBA,CAAjB,CAAsB,CAC9B,MAAOA,CAAAA,CAAG,EAAsB,UAAlB,QAAOC,CAAAA,MAAd,EAAuCD,CAAG,CAACG,WAAJ,GAAoBF,MAA3D,EAAqED,CAAG,GAAKC,MAAM,CAACH,SAApF,CAAgG,QAAhG,CAA2GC,CAAQ,CAACC,CAAD,CAC3H,CAGH,CAAOI,CAAO,CAACJ,CAAD,UCJAK,CAAAA,EAAYC,EAAW,CACtC,GAAgB,IAAZ,EAAAA,CAAJ,CACC,SAAUxB,CAAAA,6BAAsBwB,uCAAhC,CAFqC,MAKd,SAApB,QAAOA,CAAAA,CAL2B,IAM1BC,CAAAA,QAAQD,EANkB,CASd,QAApB,QAAOA,CAAAA,CAT2B,IAU1BE,CAAAA,OAAOF,EAVmB,CAad,QAApB,QAAOA,CAAAA,CAb2B,IAc1BG,CAAAA,OAAOH,EAdmB,CAiBd,QAApB,GAAAF,EAAOE,EAjB2B,CAkB1Bd,MAlB0B,CAkBnBc,CAlBmB,EAqB/BA,EChBR,QAAgBI,CAAAA,CAAhB,CAAiCC,CAAjC,CAA+C,CAC9CC,CAAc,CAAGD,CAQlB,SAAgBE,CAAAA,CAAhB,EAAgC,CAC/B,MAAOD,CAAAA,CAOR,SAAgBE,CAAAA,CAAhB,EAAmC,CAClC,GAAsB,IAAlB,EAAAF,CAAJ,CACC,SAAUG,CAAAA,mFAAV,CAED,MAAOH,CAAAA,UCKQI,CAAAA,EACfpC,EACAqC,EACAC,EAAqC,CAErC,GAAIC,CAAAA,CAAM,CAAGC,CAAiC,CAACC,GAAlC,CAAsCzC,CAAtC,CAAb,CACc,IAAV,EAAAuC,CAHiC,GAIpCA,CAAM,CAAG3B,MAAM,CAAC8B,MAAP,CAAc,IAAd,CAJ2B,CAKpCF,CAAiC,CAACG,GAAlC,CAAsC3C,CAAtC,CAAgDuC,CAAhD,CALoC,EASrCA,CAAM,CAACF,CAAD,CAAN,CAAmBC,CASpB,SAAgBM,CAAAA,CAAhB,CAA6E5C,CAA7E,CAAmGqC,CAAnG,CAA8G,CAC7G,GAAME,CAAAA,CAAM,CAAGC,CAAiC,CAACC,GAAlC,CAAsCzC,CAAtC,CAAf,CACA,GAAc,IAAV,EAAAuC,CAAJ,CACC,SAAUJ,CAAAA,2FAAV,CAGD,MAAOI,CAAAA,CAAM,CAACF,CAAD,UASEQ,CAAAA,EAA6D7C,EAAsBqC,EAAW,CAC7G,GAAME,CAAAA,CAAM,CAAGC,CAAiC,CAACC,GAAlC,CAAsCzC,CAAtC,CAAf,CACA,MAAiB,KAAV,EAAAuC,CAAM,EAAYF,CAAQ,GAAIE,CAAAA,ECnEtC,QAAgBO,CAAAA,CAAhB,CAAgDC,CAAhD,CAA2D,CAC1D,MAAOA,CAAAA,CAAG,CAACC,OAAJ,CAAYC,CAAZ,CAA+C,EAA/C,UCGQC,CAAAA,EAAoBC,EAA2BpB,EAAc,KAE5E,GAAIqB,CAAAA,CAAS,CAAGrB,CAF4D,GAI/D,CAEZ,GAAIoB,CAAgB,CAACE,QAAjB,CAA0BD,CAA1B,CAAJ,CACC,MAAOA,CAAAA,CAAP,CAID,GAAIE,CAAAA,CAAG,CAAGF,CAAS,CAACG,WAAV,CAAsB,GAAtB,CAAV,CAEA,GAAY,CAAC,CAAT,GAAAD,CAAJ,CAAgB,OAGL,CAAP,EAAAA,CAAG,EAAuC,GAA9B,GAAAF,CAAS,CAACI,MAAV,CAAiBF,CAAG,CAAG,CAAvB,CAZJ,GAaXA,CAAG,EAAI,CAbI,EAiBZF,CAAS,CAAGA,CAAS,CAACK,KAAV,CAAgB,CAAhB,CAAmBH,CAAnB,CAEb,UCxBeI,CAAAA,EAAuBP,EAA2BQ,EAAyB,IAEpFC,CAAAA,CAAM,CAAY,EAFkE,KAAA,KAAA,SAAA,KAI1F,YAAqBD,CAArB,gBAAA,CAAqB,EAArB,uBAAA,KAAA,CAAuC,IAA5B5B,CAAAA,CAA4B,QAAA,CAEhC8B,CAAkB,CAAGf,CAA+B,CAACf,CAAD,CAFpB,CAKhC+B,CAAe,CAAGZ,CAAmB,CAACC,CAAD,CAAmBU,CAAnB,CALL,CAQlCC,CAAe,SARmB,EASrCF,CAAM,CAACG,IAAP,CAAYhC,CAAZ,CAbwF,mFAgB1F,OAAO6B,CAAAA,UCjBQI,CAAAA,EAAwBb,EAA2BQ,EAAyB,CAC3F,MAAOD,CAAAA,CAAsB,CAACP,CAAD,CAAmBQ,CAAnB,UCRdM,CAAAA,EAAcvC,EAAiB,SAEtB,QAApB,QAAOA,CAAAA,CAFmC,KAItB,QAApB,GAAAF,EAAOE,EAJmC,UCG/Be,CAAAA,EAAyCyB,EAAMC,EAAI,CAElE,GAAiB,QAAb,GAAA3C,EAAO0C,EAAX,CACC,SAAUhE,CAAAA,mCAA4BgE,6BAAtC,CAID,GAAI,CAACD,CAAa,CAACE,CAAD,CAAlB,CACC,SAAUjE,CAAAA,mCAA4BiE,4BAAtC,CAED,MAAOD,CAAAA,CAAC,CAACC,CAAD,UCbOC,CAAAA,EAAU1C,EAAiB,CAC1C,QAAeA,UCDA2C,CAAAA,EAAS3C,EAAiB,CACzC,MAAOA,CAAAA,CAAQ,CAAG,WCOH4C,CAAAA,EAOdC,EAAkBlC,EAAoBmC,EAAYC,EAAgBC,EAAkB,CAErF,GAAIpC,CAAAA,CAAK,CAAGG,CAAG,CAAC8B,CAAD,CAAUlC,CAAV,CAAf,CAEA,GAAI,SAAAC,CAAJ,CAAyB,CAExB,GAAa,SAAT,GAAAkC,CAAI,EAA2B,QAAT,GAAAA,CAA1B,CACC,SAAUtE,CAAAA,kCAA2BsE,iCAArC,CAgBD,GAZa,SAAT,GAAAA,CAYJ,GAVClC,CAAK,CAAI8B,CAAS,CAAC9B,CAAD,CAUnB,EANa,QAAT,GAAAkC,CAMJ,GAJClC,CAAK,CAAI+B,CAAQ,CAAC/B,CAAD,CAIlB,EAAI,SAAAmC,CAAJ,EAGK,CAACA,CAAM,CAACpB,QAAP,CAAgBf,CAAhB,CAHN,CAIE,SAAUqC,CAAAA,2BAAoBrC,gDAA2CD,GAAzE,CAKF,MAAQC,CAAAA,CA5BT,CAiCC,MAAQoC,CAAAA,UCtCME,CAAAA,EAAiBzB,EAA2BQ,EAA2BY,EAAiC,CACvH,GAAIM,CAAAA,CAAJ,CAmBA,MAhBI,UAAAN,CAgBJ,CANCM,CAAO,CAAG,UAMX,EAdCN,CAAO,CAAG9C,CAAQ,CAAC8C,CAAD,CAcnB,CAXCM,CAAO,CAAGP,CAAS,CAACC,CAAD,CAAU,eAAV,CAA2B,QAA3B,CAAqCO,CAArC,CAAqD,UAArD,CAWpB,EAAmB,UAAZ,GAAAD,CAAO,CACXb,CAAuB,CAACb,CAAD,CAAmBQ,CAAnB,CADZ,CAEXD,CAAsB,CAACP,CAAD,CAAmBQ,CAAnB,UC5BVoB,CAAAA,IAAkE,IAAnD5B,CAAAA,CAAmD,GAAnDA,gBAAmD,CAAjCQ,CAAiC,GAAjCA,gBAAiC,CAE3EqB,CAAM,CAAGpE,MAAM,CAAC8B,MAAP,CAAc,IAAd,CAFkE,KAAA,KAAA,SAAA,KAIjF,YAAqBiB,CAArB,gBAAA,CAAqB,EAArB,uBAAA,KAAA,CAAuC,IAA5B5B,CAAAA,CAA4B,QAAA,CAEhC8B,CAAkB,CAAGf,CAA+B,CAACf,CAAD,CAFpB,CAKhC+B,CAAe,CAAGZ,CAAmB,CAACC,CAAD,CAAmBU,CAAnB,CALL,CAQtC,GAAI,SAAAC,CAAJ,CAAmC,CAKlC,GAHAkB,CAAM,CAACjD,MAAP,CAAgB+B,CAGhB,CAAI/B,CAAM,GAAK8B,CAAf,CAAmC,CAGlC,GAAMoB,CAAAA,CAAc,CAAGlD,CAAM,CAACmD,KAAP,CAAajC,CAAb,CAAvB,CAEA+B,CAAM,CAACG,SAAP,CAAqC,IAAlB,EAAAF,CAAc,CAAW,EAAX,CAAgBA,CAAc,CAAC,CAAD,CAEhE,OAAOD,CAAAA,CAER,CA1BgF,mFA4BjF,IAAMI,CAAAA,CAAS,CAAGlD,CAAmB,EAArC,CAMA,MAHA8C,CAAAA,CAAM,CAACjD,MAAP,CAAgBqD,CAGhB,CAAOJ,UC1BQK,CAAAA,EAAed,EAAuB,CACrD,MAAOQ,CAAAA,CAAa,CAACR,CAAD,UCDLe,CAAAA,EACfnC,EACAQ,EACAY,EAEuB,IAGjBM,CAAAA,CAAO,CAAGN,CAAO,CAACgB,aAHD,CAQjBC,CAAC,CAAe,QAAZ,GAAAX,CAAO,CAAgBE,CAAa,CAAC,CAAC5B,gBAAgB,CAAhBA,CAAD,CAAmBQ,gBAAgB,CAAhBA,CAAnB,CAAD,CAA7B,CAAsE0B,CAAc,CAAC,CAAClC,gBAAgB,CAAhBA,CAAD,CAAmBQ,gBAAgB,CAAhBA,CAAnB,CAAD,CAR9E,CAWnB8B,CAAW,CAAGD,CAAC,CAACzD,MAXG,CAcjBiD,CAAM,CAAGpE,MAAM,CAAC8B,MAAP,CAAc,IAAd,CAdQ,CAiBvBsC,CAAM,CAACU,UAAP,CAAoBD,CAjBG,CA0DvB,MAHAT,CAAAA,CAAM,CAACjD,MAAP,CAAgB0D,CAGhB,CAAOT,ECrFO,QAASW,CAAAA,CAAT,CAA4BC,CAA5B,CAAiC,CAC9C,GAAIC,KAAK,CAACC,OAAN,CAAcF,CAAd,CAAJ,CAAwB,CACtB,IAAK,GAAIrF,CAAAA,CAAC,CAAG,CAAR,CAAWwF,CAAI,CAAOF,KAAP,CAAaD,CAAG,CAACpF,MAAjB,CAApB,CAA8CD,CAAC,CAAGqF,CAAG,CAACpF,MAAtD,CAA8DD,CAAC,EAA/D,CACEwF,CAAI,CAACxF,CAAD,CAAJ,CAAUqF,CAAG,CAACrF,CAAD,CAAb,CAGF,MAAOwF,CAAAA,CACR,ECPY,QAASC,CAAAA,CAAT,CAA0BC,CAA1B,CAAgC,CAC7C,GAAI5E,MAAM,CAACC,QAAP,GAAmBV,CAAAA,MAAM,CAACqF,CAAD,CAAzB,EAA4E,oBAAzC,GAAArF,MAAM,CAACM,SAAP,CAAiBmD,QAAjB,CAA0B6B,IAA1B,CAA+BD,CAA/B,CAAvC,CAAsG,MAAOJ,CAAAA,KAAK,CAACM,IAAN,CAAWF,CAAX,UCDvFG,CAAAA,GAAqB,CAC3C,KAAM,IAAIlG,CAAAA,SAAJ,CAAc,iDAAd,ECEO,QAASmG,CAAAA,CAAT,CAA4BT,CAA5B,CAAiC,CAC9C,MAAOU,CAAAA,CAAiB,CAACV,CAAD,CAAjBU,EAA0BC,CAAe,CAACX,CAAD,CAAzCU,EAAkDE,CAAiB,WCI5DC,CAAAA,EAAuBC,EAA2B,CAEjE,GAAIA,CAAQ,SAAZ,CAEC,MAAO,EAAP,CAID,GAAMd,CAAAA,CAAG,GAAOc,EAAhB,CAGA,GAAId,CAAG,CAACe,IAAJ,CAAS,SAAAC,CAAA,QAA8B,gBAAZA,CAAAA,CAA3B,CAAA,CAAJ,CACC,SAAU1G,CAAAA,2CAAV,CAGD,MAAO0F,CAAAA,UClBQiB,CAAAA,EAAYC,EAAO,CAClC,MAAgD,iBAAzC,GAAAlG,MAAM,CAACM,SAAP,CAAiBmD,QAAjB,CAA0B6B,IAA1B,CAA+BY,CAA/B,UCEQC,CAAAA,EAAUD,EAAa,CACtC,MAAOjB,CAAAA,KAAK,CAACC,OAAN,CAAcgB,CAAd,GAAuBD,CAAQ,CAACC,CAAD,UCOvBE,CAAAA,EAAmBC,EAAiBC,EAAsB,QAEnElC,CAAAA,CAAM,CAAoB,EAFyC,CAKrEmC,CAAU,CAAGtF,MAAM,CAACX,SAAP,CAAiBkG,OAAjB,CAAyBlB,IAAzB,CAA8Be,CAA9B,CAAuC,GAAvC,CAA4C,CAA5C,CALwD,CAQrEI,CAAS,CAAG,CARyD,CAWnE7G,CAAM,CAAGyG,CAAO,CAACzG,MAXkD,CAclEyG,CAAO,CAACE,CAAD,CAAP,SAdkE,EAc/B,CAEzC,GAAMG,CAAAA,CAAQ,CAAGzF,MAAM,CAACX,SAAP,CAAiBkG,OAAjB,CAAyBlB,IAAzB,CAA8Be,CAA9B,CAAuC,GAAvC,CAA4CE,CAA5C,CAAjB,CAGA,GAAIG,CAAQ,EAAIH,CAAhB,CACC,SAAUjH,CAAAA,uCAAgCoH,6CAA2CH,GAArF,CAID,GAAIA,CAAU,CAAGE,CAAjB,CAA4B,CAE3B,GAAME,CAAAA,CAAO,CAAGN,CAAO,CAACxD,KAAR,CAAc4D,CAAd,CAAyBF,CAAzB,CAAhB,CAGAnC,CAAM,CAACjB,IAAP,CAAY,CACXS,IAAI,CAAE,SADK,CAEXlC,KAAK,CAAEiF,CAFI,CAAZ,CAOD,IAAMC,CAAAA,CAAI,CAAGP,CAAO,CAACxD,KAAR,CAAc0D,CAAU,CAAG,CAA3B,CAA8BG,CAA9B,CAAb,CAGA,GAAyC,IAArC,EAAAJ,CAAU,EAAQM,CAAR,CAAd,CACC,SAAUtH,CAAAA,wEAAiEsH,GAA3E,CAID,GAAMC,CAAAA,CAAK,CAAGP,CAAU,EAAQM,CAAR,CAAxB,CAGA,GAAIT,CAAM,CAACU,CAAK,CAACnF,KAAP,CAAV,CAAyB,SAAA,KAAA,SAAA,KAExB,UAAWoF,IAAKD,CAAK,CAACnF,KAAN,gBAAA,GAAhB,uBAAA,KAAA,CAAWoF,CAAX,QAAA,CAEC1C,CAAM,CAACjB,IAAP,CAAY2D,CAAZ,mFAED,CAND,CAAA,IAWC1C,CAAAA,CAAM,CAACjB,IAAP,CAAY0D,CAAZ,CAXD,CAeAJ,CAAS,CAAGC,CAAQ,CAAG,CAhDkB,CAmDzCH,CAAU,CAAGtF,MAAM,CAACX,SAAP,CAAiBkG,OAAjB,CAAyBlB,IAAzB,CAA8Be,CAA9B,CAAuC,GAAvC,CAA4CI,CAA5C,CAId,IAAIA,CAAS,CAAG7G,CAAhB,CAAwB,CAEvB,GAAMmH,CAAAA,CAAO,CAAGV,CAAO,CAACxD,KAAR,CAAc4D,CAAd,CAAyB7G,CAAzB,CAAhB,CAGAwE,CAAM,CAACjB,IAAP,CAAY,CACXS,IAAI,CAAE,SADK,CAEXlC,KAAK,CAAEqF,CAFI,CAAZ,CAOD,OAAO3C,CAAAA,UCjFQ4C,CAAAA,EAAoBC,EAAwBC,EAAc,IACrEb,CAAAA,CADqE,CAInEc,CAAI,CAAGD,CAAI,CAACtH,MAJuD,CAOzE,GAAa,CAAT,GAAAuH,CAAJ,CAEC,MAAO,EAAP,CAID,GAAa,CAAT,GAAAA,CAAJ,CAAgB,CAEfd,CAAO,CAAGrE,CAAe,CAACiF,CAAD,CAAa,cAAb,CAFV,IAKTG,CAAAA,CAAK,CAAqB,CAC/BxD,IAAI,CAAE,SADyB,CAE/BlC,KAAK,CAAEwF,CAAI,CAAC,CAAD,CAFoB,CALjB,CAWTG,CAAM,CAAqB,CAChCzD,IAAI,CAAE,SAD0B,CAEhClC,KAAK,CAAEwF,CAAI,CAAC,CAAD,CAFqB,CAXlB,CAuBf,MAAOd,CAAAA,CAAkB,CAACC,CAAD,CANM,CAC9B,EAAGe,CAD2B,CAE9B,EAAGC,CAF2B,CAMN,CAI1B,CAxCyE,OAwCnEC,CAAAA,CAAI,CAAqB,CAC9B1D,IAAI,CAAE,SADwB,CAE9BlC,KAAK,CAAEwF,CAAI,CAACC,CAAI,CAAG,CAAR,CAFmB,CAxC0C,CA8CrEI,CAAK,CAAoB,CAACD,CAAD,CA9C4C,CAiDrE3H,CAAC,CAAGwH,CAAI,CAAG,CAjD0D,CAoD7D,CAAL,EAAAxH,CApDkE,EAoD1D,CAIb0G,CAJa,CAEJ,CAAN,GAAA1G,CAFU,CAIHqC,CAAe,CAACiF,CAAD,CAAa,eAAb,CAJZ,CAQLtH,CAAC,CAAGwH,CAAI,CAAG,CARN,CAUHnF,CAAe,CAACiF,CAAD,CAAa,gBAAb,CAVZ,CAgBHjF,CAAe,CAACiF,CAAD,CAAa,aAAb,CAhBZ,IAoBRO,CAAAA,CAAI,CAAqB,CAC9B5D,IAAI,CAAE,SADwB,CAE9BlC,KAAK,CAAEwF,CAAI,CAACvH,CAAD,CAFmB,CApBjB,CA0BR8H,CAAI,CAAqB,CAC9B7D,IAAI,CAAE,SADwB,CAE9BlC,KAAK,CAAE6F,CAFuB,CA1BjB,CAsCdA,CAAK,CAAGnB,CAAkB,CAACC,CAAD,CANK,CAC9B,EAAGmB,CAD2B,CAE9B,EAAGC,CAF2B,CAML,CAtCZ,CAyCd9H,CAAC,EAIF,OAAO4H,CAAAA,UCrGQG,CAAAA,EAAWT,EAAwBC,EAAc,IAE1DK,CAAAA,CAAK,CAAGP,CAAmB,CAACC,CAAD,CAAaC,CAAb,CAF+B,CAK5D9C,CAAM,CAAG,EALmD,KAAA,KAAA,SAAA,KAQhE,UAAWwC,IAAQW,CAAnB,gBAAA,CAAmB,EAAnB,uBAAA,KAAA,CAAWX,CAAX,QAAA,CAECxC,CAAM,EAAIwC,CAAI,CAAClF,uFAGhB,OAAO0C,CAAAA,UCZQuD,CAAAA,EAAkBV,EAAwBC,EAAc,CACvE,MAAOF,CAAAA,CAAmB,CAACC,CAAD,CAAaC,CAAb,KzBNvB9F,CAAAA,E0BRSwG,CAAoB,CAAG,cAAgBC,CAAAA,KCEvCC,CAAI,CAAG,CAAC,aAAD,CAAgB,aAAhB,CAA+B,MAA/B,ECAPC,CAAK,CAAG,CAAC,MAAD,CAAS,OAAT,CAAkB,QAAlB,ECAR7D,CAAc,CAAG,CAAC,QAAD,CAAW,UAAX,E5BMjBtC,CAAiC,CAAqD,GAAIoG,CAAAA,QAM1FC,CAA4B,CAA8B,CAKtEC,qBAAqB,CAAE,EAL+C,CAWtEC,UAAU,CAAE,EAX0D,CAiBtE5F,gBAAgB,CAAE,EAjBoD,ECV1DF,CAAiC,CAAG,0B4BsBpC+F,CAAb,YAEC,UAAA,EAAA,UAAA,IACOC,CAAAA,CAAO,CAAGC,SAAS,CAAC,CAAD,CAD1B,CAEK3E,CAAO,CAAG2E,SAAS,CAAC,CAAD,CAFxB,CAKC,GAAI,mDAAA,CAAJ,CACC,SAAUhJ,CAAAA,uDAAV,CAID,GAAMyD,CAAAA,CAAgB,CAAG8E,IAAI,CAACU,mBAAL,CAAyBF,CAAzB,CAAzB,CAIA1E,CAAO,CAAG,SAAAA,CAAO,CAAkB3D,MAAM,CAAC8B,MAAP,CAAc,IAAd,CAAlB,CAAuEjB,CAAQ,CAAC8C,CAAD,CAdjG,IAiBO6E,CAAAA,CAAG,CAAGxI,MAAM,CAAC8B,MAAP,CAAc,IAAd,CAjBb,CAoBOmC,CAAO,CAAGP,CAAS,CAACC,CAAD,CAAU,eAAV,CAA2B,QAA3B,CAAqCO,CAArC,CAAqD,UAArD,CApB1B,CAuBCsE,CAAG,CAAC7D,aAAJ,CAAoBV,CAvBrB,CA0BC,GAAML,CAAAA,CAAI,CAAGF,CAAS,CAACC,CAAD,CAAU,MAAV,CAAkB,QAAlB,CAA4BmE,CAA5B,CAAkC,aAAlC,CAAtB,CAGAtG,CAAe,CAAC,IAAD,CAAO,MAAP,CAAeoC,CAAf,CA7BhB,CAgCC,GAAM6E,CAAAA,CAAK,CAAG/E,CAAS,CAACC,CAAD,CAAU,OAAV,CAAmB,QAAnB,CAA6BoE,CAA7B,CAAoC,MAApC,CAAvB,CAGAvG,CAAe,CAAC,IAAD,CAAO,OAAP,CAAgBiH,CAAhB,CAnChB,IAsCON,CAAAA,CAAU,CAAGF,CAA4B,CAACE,UAtCjD,CAyCOvD,CAAC,CAAGF,CAAa,CACtBuD,CAA4B,CAAC1F,gBADP,CAEtBQ,CAFsB,CAGtByF,CAHsB,CAzCxB,CAkDO1D,CAAU,CAAGF,CAAC,CAACE,UAlDtB,CAqDO4D,CAAc,CAAGP,CAAU,CAACrD,CAAD,CArDlC,CAwDO6D,CAAe,CAAGD,CAAc,CAACE,OAAf,CAAuBhF,CAAvB,CAxDzB,CA2DOiF,CAAS,CAAGF,CAAe,CAACF,CAAD,CA3DlC,CA8DCjH,CAAe,CAAC,IAAD,CAAO,cAAP,CAAuBqH,CAAS,CAACC,IAAjC,CA9DhB,CAiECtH,CAAe,CAAC,IAAD,CAAO,eAAP,CAAwBqH,CAAS,CAACE,KAAlC,CAjEhB,CAoECvH,CAAe,CAAC,IAAD,CAAO,gBAAP,CAAyBqH,CAAS,CAACG,MAAnC,CApEhB,CAuECxH,CAAe,CAAC,IAAD,CAAO,aAAP,CAAsBqH,CAAS,CAACI,GAAhC,CAvEhB,CA0ECzH,CAAe,CAAC,IAAD,CAAO,QAAP,CAAiBoD,CAAC,CAACzD,MAAnB,CA1EhB,CA6ECK,CAAe,CAAC,IAAD,CAAO,uBAAP,CAAgC,IAAhC,CA/EjB,OAAArB,CAAAA,kCA8He+G,EAAuB,CAEpC,GAAMgC,CAAAA,CAAE,CAAG,IAAX,CAGA,GAAI,EAAEA,CAAE,WAAYlJ,CAAAA,MAAhB,CAAJ,CACC,SAAUV,CAAAA,4FAAqF,KAAKmE,QAAL,IAA/F,CAID,GAAI,CAACxB,CAAe,CAACiH,CAAD,CAAK,uBAAL,CAApB,CACC,SAAU5J,CAAAA,4FAAqF,KAAKmE,QAAL,IAA/F,CAID,GAAM0F,CAAAA,CAAU,CAAGtD,CAAsB,CAACqB,CAAD,CAAzC,CAGA,MAAOQ,CAAAA,CAAU,CAACwB,CAAD,CAAKC,CAAL,CAhJnB,uCAwJsBjC,EAAuB,CAE3C,GAAMgC,CAAAA,CAAE,CAAG,IAAX,CAGA,GAAI,EAAEA,CAAE,WAAYlJ,CAAAA,MAAhB,CAAJ,CACC,SAAUV,CAAAA,mGAA4F,KAAKmE,QAAL,IAAtG,CAID,GAAI,CAACxB,CAAe,CAACiH,CAAD,CAAK,uBAAL,CAApB,CACC,SAAU5J,CAAAA,mGAA4F,KAAKmE,QAAL,IAAtG,CAID,GAAM0F,CAAAA,CAAU,CAAGtD,CAAsB,CAACqB,CAAD,CAAzC,CAGA,MAAOS,CAAAA,CAAiB,CAACuB,CAAD,CAAKC,CAAL,CA1K1B,0CAiLuB,CAErB,GAAMD,CAAAA,CAAE,CAAG,IAAX,CAGA,GAAI,EAAEA,CAAE,WAAYlJ,CAAAA,MAAhB,CAAJ,CACC,SAAUV,CAAAA,qGAA8F,KAAKmE,QAAL,IAAxG,CAID,GAAI,CAACxB,CAAe,CAACiH,CAAD,CAAK,uBAAL,CAApB,CACC,SAAU5J,CAAAA,qGAA8F,KAAKmE,QAAL,IAAxG,CAXoB,GAcftC,CAAAA,CAAM,CAAGa,CAAe,CAAC,IAAD,CAAO,QAAP,CAdT,CAef4B,CAAI,CAAG5B,CAAe,CAAC,IAAD,CAAO,MAAP,CAfP,CAgBfyG,CAAK,CAAGzG,CAAe,CAAC,IAAD,CAAO,OAAP,CAhBR,CAkBrB,MAAO,CACNb,MAAM,CAANA,CADM,CAENyC,IAAI,CAAJA,CAFM,CAGN6E,KAAK,CAALA,CAHM,CAnMT,8CAuFkCJ,EAAyB,IAGnD1E,CAAAA,CAAO,CAAG2E,SAAS,CAAC,CAAD,CAHgC,CAMnD/F,CAAgB,CAAG0F,CAA4B,CAAC1F,gBANG,CASnDQ,CAAgB,CAAG8E,IAAI,CAACU,mBAAL,CAAyBF,CAAzB,CATgC,CAUzD,MAAOrE,CAAAA,CAAgB,CAACzB,CAAD,CAAmBQ,CAAnB,CAAqCY,CAArC,CAjGzB,2CA4GsE,IAAnCyF,CAAAA,CAAmC,GAAnCA,IAAmC,CAA7BjI,CAA6B,GAA7BA,MAA6B,CAE9DkI,CAAa,CAAGhI,CAAgB,EAF8B,CAG/C,IAAjB,EAAAgI,CAHgE,EAInEnI,CAAgB,CAACC,CAAD,CAJmD,CAOpE8G,CAA4B,CAACE,UAA7B,CAAwChH,CAAxC,EAAkDiI,CAPkB,CAQ/DnB,CAA4B,CAAC1F,gBAA7B,CAA8CE,QAA9C,CAAuDtB,CAAvD,CAR+D,EASnE8G,CAA4B,CAAC1F,gBAA7B,CAA8CY,IAA9C,CAAmDhC,CAAnD,CArHH,UAgNAnB,MAAM,CAACC,cAAP,CAAsBmI,CAAU,CAAC9H,SAAjC,CAA4CG,MAAM,CAAC6I,WAAnD,CAAgE,CAC/DvJ,QAAQ,GADuD,CAE/DF,UAAU,GAFqD,CAG/D6B,KAAK,CAAE,iBAHwD,CAI/D5B,YAAY,GAJmD,CAAhE,ECvOK8H,aCEgB,CACpB,GAAoB,WAAhB,QAAOC,CAAAA,IAAX,CACC,SAAUvI,CAAAA,gKAAV,CAEDuI,IAAI,CAACO,UAAL,CAAkBA,EDLlB"}