"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.templateExpressionToHtml = exports.isExpressionPlaceholder = exports.getExpressionPlaceholder = exports.getPropertyMap = exports.extractPropertyEntry = exports.getIdentifierName = void 0;
/**
 * Get the name of a node
 *
 * @param {ESTree.Node} node Node to retrieve name of
 * @return {?string}
 */
function getIdentifierName(node) {
    if (node.type === 'Identifier') {
        return node.name;
    }
    if (node.type === 'Literal') {
        return node.raw;
    }
    return undefined;
}
exports.getIdentifierName = getIdentifierName;
/**
 * Extracts property metadata from a given property object
 * @param {ESTree.ObjectExpression} node Node to extract from
 * @return {object}
 */
function extractPropertyEntry(node) {
    let state = false;
    let attribute = true;
    for (const prop of node.properties) {
        if (prop.type === 'Property' &&
            prop.key.type === 'Identifier' &&
            prop.value.type === 'Literal') {
            if (prop.key.name === 'state' && prop.value.value === true) {
                state = true;
            }
            else if (prop.key.name === 'attribute' && prop.value.value === false) {
                attribute = false;
            }
        }
    }
    return {
        expr: node,
        state,
        attribute
    };
}
exports.extractPropertyEntry = extractPropertyEntry;
/**
 * Get the properties object of an element class
 *
 * @param {ESTree.Class} node Class to retrieve map from
 * @return {ReadonlyMap<string, ESTreeObjectExpression>}
 */
function getPropertyMap(node) {
    const result = new Map();
    const propertyDecorators = ['state', 'property', 'internalProperty'];
    const internalDecorators = ['state', 'internalProperty'];
    for (const member of node.body.body) {
        if (member.static &&
            member.kind === 'get' &&
            member.key.type === 'Identifier' &&
            member.key.name === 'properties' &&
            member.value.body) {
            const ret = member.value.body.body.find((m) => {
                var _a;
                return m.type === 'ReturnStatement' &&
                    ((_a = m.argument) === null || _a === void 0 ? void 0 : _a.type) === 'ObjectExpression';
            });
            if (ret) {
                const arg = ret.argument;
                for (const prop of arg.properties) {
                    if (prop.type === 'Property') {
                        const name = getIdentifierName(prop.key);
                        if (name && prop.value.type === 'ObjectExpression') {
                            result.set(name, extractPropertyEntry(prop.value));
                        }
                    }
                }
            }
        }
        const babelProp = member;
        const memberName = getIdentifierName(member.key);
        if (memberName && babelProp.decorators) {
            for (const decorator of babelProp.decorators) {
                if (decorator.expression.type === 'CallExpression' &&
                    decorator.expression.callee.type === 'Identifier' &&
                    propertyDecorators.includes(decorator.expression.callee.name)) {
                    const dArg = decorator.expression.arguments[0];
                    if ((dArg === null || dArg === void 0 ? void 0 : dArg.type) === 'ObjectExpression') {
                        const state = internalDecorators.includes(decorator.expression.callee.name);
                        const entry = extractPropertyEntry(dArg);
                        if (state) {
                            entry.state = true;
                        }
                        result.set(memberName, entry);
                    }
                    else {
                        const state = internalDecorators.includes(decorator.expression.callee.name);
                        result.set(memberName, { expr: null, state, attribute: true });
                    }
                }
            }
        }
    }
    return result;
}
exports.getPropertyMap = getPropertyMap;
/**
 * Generates a placeholder string for a given quasi
 *
 * @param {ESTree.TaggedTemplateExpression} node Root node
 * @param {ESTree.TemplateElement} quasi Quasi to generate placeholder
 * for
 * @return {string}
 */
function getExpressionPlaceholder(node, quasi) {
    const i = node.quasi.quasis.indexOf(quasi);
    if (/=$/.test(quasi.value.raw)) {
        return `"{{__Q:${i}__}}"`;
    }
    return `{{__Q:${i}__}}`;
}
exports.getExpressionPlaceholder = getExpressionPlaceholder;
/**
 * Tests whether a string is a placeholder or not
 *
 * @param {string} value Value to test
 * @return {boolean}
 */
function isExpressionPlaceholder(value) {
    return /^\{\{__Q:\d+__\}\}$/.test(value);
}
exports.isExpressionPlaceholder = isExpressionPlaceholder;
/**
 * Converts a template expression into HTML
 *
 * @param {ESTree.TaggedTemplateExpression} node Node to convert
 * @return {string}
 */
function templateExpressionToHtml(node) {
    let html = '';
    for (let i = 0; i < node.quasi.quasis.length; i++) {
        const quasi = node.quasi.quasis[i];
        const expr = node.quasi.expressions[i];
        html += quasi.value.raw;
        if (expr) {
            html += getExpressionPlaceholder(node, quasi);
        }
    }
    return html;
}
exports.templateExpressionToHtml = templateExpressionToHtml;
