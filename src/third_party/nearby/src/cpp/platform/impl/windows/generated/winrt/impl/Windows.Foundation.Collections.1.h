// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.210505.3

#ifndef WINRT_Windows_Foundation_Collections_1_H
#define WINRT_Windows_Foundation_Collections_1_H
#include "winrt/impl/Windows.Foundation.Collections.0.h"
WINRT_EXPORT namespace winrt::Windows::Foundation::Collections
{
    template <typename T>
    struct __declspec(empty_bases) IIterable :
        winrt::Windows::Foundation::IInspectable,
        impl::consume_t<winrt::Windows::Foundation::Collections::IIterable<T>>
    {
        static_assert(impl::has_category_v<T>, "T must be WinRT type.");
        IIterable(std::nullptr_t = nullptr) noexcept {}
        IIterable(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IInspectable(ptr, take_ownership_from_abi) {}
        IIterable(IIterable const&) noexcept = default;
        IIterable(IIterable&&) noexcept = default;
        IIterable& operator=(IIterable const&) & noexcept = default;
        IIterable& operator=(IIterable&&) & noexcept = default;
    };
    template <typename T>
    struct __declspec(empty_bases) IIterator :
        winrt::Windows::Foundation::IInspectable,
        impl::consume_t<winrt::Windows::Foundation::Collections::IIterator<T>>
    {
        static_assert(impl::has_category_v<T>, "T must be WinRT type.");
        IIterator(std::nullptr_t = nullptr) noexcept {}
        IIterator(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IInspectable(ptr, take_ownership_from_abi) {}
        IIterator(IIterator const&) noexcept = default;
        IIterator(IIterator&&) noexcept = default;
        IIterator& operator=(IIterator const&) & noexcept = default;
        IIterator& operator=(IIterator&&) & noexcept = default;

        using iterator_concept = std::input_iterator_tag;
        using iterator_category = std::input_iterator_tag;
        using value_type = T;
        using difference_type = ptrdiff_t;
        using pointer = void;
        using reference = T;
    };
    template <typename K, typename V>
    struct __declspec(empty_bases) IKeyValuePair :
        winrt::Windows::Foundation::IInspectable,
        impl::consume_t<winrt::Windows::Foundation::Collections::IKeyValuePair<K, V>>
    {
        static_assert(impl::has_category_v<K>, "K must be WinRT type.");
        static_assert(impl::has_category_v<V>, "V must be WinRT type.");
        IKeyValuePair(std::nullptr_t = nullptr) noexcept {}
        IKeyValuePair(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IInspectable(ptr, take_ownership_from_abi) {}
        IKeyValuePair(IKeyValuePair const&) noexcept = default;
        IKeyValuePair(IKeyValuePair&&) noexcept = default;
        IKeyValuePair& operator=(IKeyValuePair const&) & noexcept = default;
        IKeyValuePair& operator=(IKeyValuePair&&) & noexcept = default;
    };
    template <typename K>
    struct __declspec(empty_bases) IMapChangedEventArgs :
        winrt::Windows::Foundation::IInspectable,
        impl::consume_t<winrt::Windows::Foundation::Collections::IMapChangedEventArgs<K>>
    {
        static_assert(impl::has_category_v<K>, "K must be WinRT type.");
        IMapChangedEventArgs(std::nullptr_t = nullptr) noexcept {}
        IMapChangedEventArgs(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IInspectable(ptr, take_ownership_from_abi) {}
        IMapChangedEventArgs(IMapChangedEventArgs const&) noexcept = default;
        IMapChangedEventArgs(IMapChangedEventArgs&&) noexcept = default;
        IMapChangedEventArgs& operator=(IMapChangedEventArgs const&) & noexcept = default;
        IMapChangedEventArgs& operator=(IMapChangedEventArgs&&) & noexcept = default;
    };
    template <typename K, typename V>
    struct __declspec(empty_bases) IMapView :
        winrt::Windows::Foundation::IInspectable,
        impl::consume_t<winrt::Windows::Foundation::Collections::IMapView<K, V>>,
        impl::require<winrt::Windows::Foundation::Collections::IMapView<K, V>, winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<K, V>>>
    {
        static_assert(impl::has_category_v<K>, "K must be WinRT type.");
        static_assert(impl::has_category_v<V>, "V must be WinRT type.");
        IMapView(std::nullptr_t = nullptr) noexcept {}
        IMapView(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IInspectable(ptr, take_ownership_from_abi) {}
        IMapView(IMapView const&) noexcept = default;
        IMapView(IMapView&&) noexcept = default;
        IMapView& operator=(IMapView const&) & noexcept = default;
        IMapView& operator=(IMapView&&) & noexcept = default;
    };
    template <typename K, typename V>
    struct __declspec(empty_bases) IMap :
        winrt::Windows::Foundation::IInspectable,
        impl::consume_t<winrt::Windows::Foundation::Collections::IMap<K, V>>,
        impl::require<winrt::Windows::Foundation::Collections::IMap<K, V>, winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<K, V>>>
    {
        static_assert(impl::has_category_v<K>, "K must be WinRT type.");
        static_assert(impl::has_category_v<V>, "V must be WinRT type.");
        IMap(std::nullptr_t = nullptr) noexcept {}
        IMap(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IInspectable(ptr, take_ownership_from_abi) {}
        IMap(IMap const&) noexcept = default;
        IMap(IMap&&) noexcept = default;
        IMap& operator=(IMap const&) & noexcept = default;
        IMap& operator=(IMap&&) & noexcept = default;
    };
    template <typename K, typename V>
    struct __declspec(empty_bases) IObservableMap :
        winrt::Windows::Foundation::IInspectable,
        impl::consume_t<winrt::Windows::Foundation::Collections::IObservableMap<K, V>>,
        impl::require<winrt::Windows::Foundation::Collections::IObservableMap<K, V>, winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<K, V>>, winrt::Windows::Foundation::Collections::IMap<K, V>>
    {
        static_assert(impl::has_category_v<K>, "K must be WinRT type.");
        static_assert(impl::has_category_v<V>, "V must be WinRT type.");
        IObservableMap(std::nullptr_t = nullptr) noexcept {}
        IObservableMap(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IInspectable(ptr, take_ownership_from_abi) {}
        IObservableMap(IObservableMap const&) noexcept = default;
        IObservableMap(IObservableMap&&) noexcept = default;
        IObservableMap& operator=(IObservableMap const&) & noexcept = default;
        IObservableMap& operator=(IObservableMap&&) & noexcept = default;
    };
    template <typename T>
    struct __declspec(empty_bases) IObservableVector :
        winrt::Windows::Foundation::IInspectable,
        impl::consume_t<winrt::Windows::Foundation::Collections::IObservableVector<T>>,
        impl::require<winrt::Windows::Foundation::Collections::IObservableVector<T>, winrt::Windows::Foundation::Collections::IIterable<T>, winrt::Windows::Foundation::Collections::IVector<T>>
    {
        static_assert(impl::has_category_v<T>, "T must be WinRT type.");
        IObservableVector(std::nullptr_t = nullptr) noexcept {}
        IObservableVector(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IInspectable(ptr, take_ownership_from_abi) {}
        IObservableVector(IObservableVector const&) noexcept = default;
        IObservableVector(IObservableVector&&) noexcept = default;
        IObservableVector& operator=(IObservableVector const&) & noexcept = default;
        IObservableVector& operator=(IObservableVector&&) & noexcept = default;
    };
    struct __declspec(empty_bases) IPropertySet :
        winrt::Windows::Foundation::IInspectable,
        impl::consume_t<IPropertySet>,
        impl::require<winrt::Windows::Foundation::Collections::IPropertySet, winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, winrt::Windows::Foundation::IInspectable>>, winrt::Windows::Foundation::Collections::IMap<hstring, winrt::Windows::Foundation::IInspectable>, winrt::Windows::Foundation::Collections::IObservableMap<hstring, winrt::Windows::Foundation::IInspectable>>
    {
        IPropertySet(std::nullptr_t = nullptr) noexcept {}
        IPropertySet(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IInspectable(ptr, take_ownership_from_abi) {}
        IPropertySet(IPropertySet const&) noexcept = default;
        IPropertySet(IPropertySet&&) noexcept = default;
        IPropertySet& operator=(IPropertySet const&) & noexcept = default;
        IPropertySet& operator=(IPropertySet&&) & noexcept = default;
    };
    struct __declspec(empty_bases) IVectorChangedEventArgs :
        winrt::Windows::Foundation::IInspectable,
        impl::consume_t<IVectorChangedEventArgs>
    {
        IVectorChangedEventArgs(std::nullptr_t = nullptr) noexcept {}
        IVectorChangedEventArgs(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IInspectable(ptr, take_ownership_from_abi) {}
        IVectorChangedEventArgs(IVectorChangedEventArgs const&) noexcept = default;
        IVectorChangedEventArgs(IVectorChangedEventArgs&&) noexcept = default;
        IVectorChangedEventArgs& operator=(IVectorChangedEventArgs const&) & noexcept = default;
        IVectorChangedEventArgs& operator=(IVectorChangedEventArgs&&) & noexcept = default;
    };
    template <typename T>
    struct __declspec(empty_bases) IVectorView :
        winrt::Windows::Foundation::IInspectable,
        impl::consume_t<winrt::Windows::Foundation::Collections::IVectorView<T>>,
        impl::require<winrt::Windows::Foundation::Collections::IVectorView<T>, winrt::Windows::Foundation::Collections::IIterable<T>>
    {
        static_assert(impl::has_category_v<T>, "T must be WinRT type.");
        IVectorView(std::nullptr_t = nullptr) noexcept {}
        IVectorView(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IInspectable(ptr, take_ownership_from_abi) {}
        IVectorView(IVectorView const&) noexcept = default;
        IVectorView(IVectorView&&) noexcept = default;
        IVectorView& operator=(IVectorView const&) & noexcept = default;
        IVectorView& operator=(IVectorView&&) & noexcept = default;
    };
    template <typename T>
    struct __declspec(empty_bases) IVector :
        winrt::Windows::Foundation::IInspectable,
        impl::consume_t<winrt::Windows::Foundation::Collections::IVector<T>>,
        impl::require<winrt::Windows::Foundation::Collections::IVector<T>, winrt::Windows::Foundation::Collections::IIterable<T>>
    {
        static_assert(impl::has_category_v<T>, "T must be WinRT type.");
        IVector(std::nullptr_t = nullptr) noexcept {}
        IVector(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IInspectable(ptr, take_ownership_from_abi) {}
        IVector(IVector const&) noexcept = default;
        IVector(IVector&&) noexcept = default;
        IVector& operator=(IVector const&) & noexcept = default;
        IVector& operator=(IVector&&) & noexcept = default;
    };
}
#endif
