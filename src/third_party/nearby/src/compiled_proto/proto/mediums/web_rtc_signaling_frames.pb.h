// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/mediums/web_rtc_signaling_frames.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2fmediums_2fweb_5frtc_5fsignaling_5fframes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proto_2fmediums_2fweb_5frtc_5fsignaling_5fframes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2fmediums_2fweb_5frtc_5fsignaling_5fframes_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fmediums_2fweb_5frtc_5fsignaling_5fframes_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
namespace location {
namespace nearby {
namespace mediums {
class Answer;
struct AnswerDefaultTypeInternal;
extern AnswerDefaultTypeInternal _Answer_default_instance_;
class IceCandidate;
struct IceCandidateDefaultTypeInternal;
extern IceCandidateDefaultTypeInternal _IceCandidate_default_instance_;
class IceCandidates;
struct IceCandidatesDefaultTypeInternal;
extern IceCandidatesDefaultTypeInternal _IceCandidates_default_instance_;
class Offer;
struct OfferDefaultTypeInternal;
extern OfferDefaultTypeInternal _Offer_default_instance_;
class PeerId;
struct PeerIdDefaultTypeInternal;
extern PeerIdDefaultTypeInternal _PeerId_default_instance_;
class ReadyForSignalingPoke;
struct ReadyForSignalingPokeDefaultTypeInternal;
extern ReadyForSignalingPokeDefaultTypeInternal _ReadyForSignalingPoke_default_instance_;
class SessionDescription;
struct SessionDescriptionDefaultTypeInternal;
extern SessionDescriptionDefaultTypeInternal _SessionDescription_default_instance_;
class WebRtcSignalingFrame;
struct WebRtcSignalingFrameDefaultTypeInternal;
extern WebRtcSignalingFrameDefaultTypeInternal _WebRtcSignalingFrame_default_instance_;
}  // namespace mediums
}  // namespace nearby
}  // namespace location
PROTOBUF_NAMESPACE_OPEN
template<> ::location::nearby::mediums::Answer* Arena::CreateMaybeMessage<::location::nearby::mediums::Answer>(Arena*);
template<> ::location::nearby::mediums::IceCandidate* Arena::CreateMaybeMessage<::location::nearby::mediums::IceCandidate>(Arena*);
template<> ::location::nearby::mediums::IceCandidates* Arena::CreateMaybeMessage<::location::nearby::mediums::IceCandidates>(Arena*);
template<> ::location::nearby::mediums::Offer* Arena::CreateMaybeMessage<::location::nearby::mediums::Offer>(Arena*);
template<> ::location::nearby::mediums::PeerId* Arena::CreateMaybeMessage<::location::nearby::mediums::PeerId>(Arena*);
template<> ::location::nearby::mediums::ReadyForSignalingPoke* Arena::CreateMaybeMessage<::location::nearby::mediums::ReadyForSignalingPoke>(Arena*);
template<> ::location::nearby::mediums::SessionDescription* Arena::CreateMaybeMessage<::location::nearby::mediums::SessionDescription>(Arena*);
template<> ::location::nearby::mediums::WebRtcSignalingFrame* Arena::CreateMaybeMessage<::location::nearby::mediums::WebRtcSignalingFrame>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace location {
namespace nearby {
namespace mediums {

enum WebRtcSignalingFrame_FrameType : int {
  WebRtcSignalingFrame_FrameType_UNKNOWN_FRAME_TYPE = 0,
  WebRtcSignalingFrame_FrameType_OFFER_TYPE = 1,
  WebRtcSignalingFrame_FrameType_ANSWER_TYPE = 2,
  WebRtcSignalingFrame_FrameType_ICE_CANDIDATES_TYPE = 3,
  WebRtcSignalingFrame_FrameType_READY_FOR_SIGNALING_POKE_TYPE = 4
};
bool WebRtcSignalingFrame_FrameType_IsValid(int value);
constexpr WebRtcSignalingFrame_FrameType WebRtcSignalingFrame_FrameType_FrameType_MIN = WebRtcSignalingFrame_FrameType_UNKNOWN_FRAME_TYPE;
constexpr WebRtcSignalingFrame_FrameType WebRtcSignalingFrame_FrameType_FrameType_MAX = WebRtcSignalingFrame_FrameType_READY_FOR_SIGNALING_POKE_TYPE;
constexpr int WebRtcSignalingFrame_FrameType_FrameType_ARRAYSIZE = WebRtcSignalingFrame_FrameType_FrameType_MAX + 1;

const std::string& WebRtcSignalingFrame_FrameType_Name(WebRtcSignalingFrame_FrameType value);
template<typename T>
inline const std::string& WebRtcSignalingFrame_FrameType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WebRtcSignalingFrame_FrameType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WebRtcSignalingFrame_FrameType_Name.");
  return WebRtcSignalingFrame_FrameType_Name(static_cast<WebRtcSignalingFrame_FrameType>(enum_t_value));
}
bool WebRtcSignalingFrame_FrameType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WebRtcSignalingFrame_FrameType* value);
// ===================================================================

class WebRtcSignalingFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.mediums.WebRtcSignalingFrame) */ {
 public:
  inline WebRtcSignalingFrame() : WebRtcSignalingFrame(nullptr) {}
  ~WebRtcSignalingFrame() override;
  explicit constexpr WebRtcSignalingFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WebRtcSignalingFrame(const WebRtcSignalingFrame& from);
  WebRtcSignalingFrame(WebRtcSignalingFrame&& from) noexcept
    : WebRtcSignalingFrame() {
    *this = ::std::move(from);
  }

  inline WebRtcSignalingFrame& operator=(const WebRtcSignalingFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline WebRtcSignalingFrame& operator=(WebRtcSignalingFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const WebRtcSignalingFrame& default_instance() {
    return *internal_default_instance();
  }
  enum FrameCase {
    kOffer = 3,
    kAnswer = 4,
    kIceCandidates = 5,
    kReadyForSignalingPoke = 6,
    FRAME_NOT_SET = 0,
  };

  static inline const WebRtcSignalingFrame* internal_default_instance() {
    return reinterpret_cast<const WebRtcSignalingFrame*>(
               &_WebRtcSignalingFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(WebRtcSignalingFrame& a, WebRtcSignalingFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(WebRtcSignalingFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WebRtcSignalingFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WebRtcSignalingFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WebRtcSignalingFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WebRtcSignalingFrame& from);
  void MergeFrom(const WebRtcSignalingFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WebRtcSignalingFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.mediums.WebRtcSignalingFrame";
  }
  protected:
  explicit WebRtcSignalingFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef WebRtcSignalingFrame_FrameType FrameType;
  static constexpr FrameType UNKNOWN_FRAME_TYPE =
    WebRtcSignalingFrame_FrameType_UNKNOWN_FRAME_TYPE;
  static constexpr FrameType OFFER_TYPE =
    WebRtcSignalingFrame_FrameType_OFFER_TYPE;
  static constexpr FrameType ANSWER_TYPE =
    WebRtcSignalingFrame_FrameType_ANSWER_TYPE;
  static constexpr FrameType ICE_CANDIDATES_TYPE =
    WebRtcSignalingFrame_FrameType_ICE_CANDIDATES_TYPE;
  static constexpr FrameType READY_FOR_SIGNALING_POKE_TYPE =
    WebRtcSignalingFrame_FrameType_READY_FOR_SIGNALING_POKE_TYPE;
  static inline bool FrameType_IsValid(int value) {
    return WebRtcSignalingFrame_FrameType_IsValid(value);
  }
  static constexpr FrameType FrameType_MIN =
    WebRtcSignalingFrame_FrameType_FrameType_MIN;
  static constexpr FrameType FrameType_MAX =
    WebRtcSignalingFrame_FrameType_FrameType_MAX;
  static constexpr int FrameType_ARRAYSIZE =
    WebRtcSignalingFrame_FrameType_FrameType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& FrameType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FrameType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FrameType_Name.");
    return WebRtcSignalingFrame_FrameType_Name(enum_t_value);
  }
  static inline bool FrameType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FrameType* value) {
    return WebRtcSignalingFrame_FrameType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSenderIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kOfferFieldNumber = 3,
    kAnswerFieldNumber = 4,
    kIceCandidatesFieldNumber = 5,
    kReadyForSignalingPokeFieldNumber = 6,
  };
  // optional .location.nearby.mediums.PeerId sender_id = 1;
  bool has_sender_id() const;
  private:
  bool _internal_has_sender_id() const;
  public:
  void clear_sender_id();
  const ::location::nearby::mediums::PeerId& sender_id() const;
  PROTOBUF_NODISCARD ::location::nearby::mediums::PeerId* release_sender_id();
  ::location::nearby::mediums::PeerId* mutable_sender_id();
  void set_allocated_sender_id(::location::nearby::mediums::PeerId* sender_id);
  private:
  const ::location::nearby::mediums::PeerId& _internal_sender_id() const;
  ::location::nearby::mediums::PeerId* _internal_mutable_sender_id();
  public:
  void unsafe_arena_set_allocated_sender_id(
      ::location::nearby::mediums::PeerId* sender_id);
  ::location::nearby::mediums::PeerId* unsafe_arena_release_sender_id();

  // optional .location.nearby.mediums.WebRtcSignalingFrame.FrameType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::location::nearby::mediums::WebRtcSignalingFrame_FrameType type() const;
  void set_type(::location::nearby::mediums::WebRtcSignalingFrame_FrameType value);
  private:
  ::location::nearby::mediums::WebRtcSignalingFrame_FrameType _internal_type() const;
  void _internal_set_type(::location::nearby::mediums::WebRtcSignalingFrame_FrameType value);
  public:

  // .location.nearby.mediums.Offer offer = 3;
  bool has_offer() const;
  private:
  bool _internal_has_offer() const;
  public:
  void clear_offer();
  const ::location::nearby::mediums::Offer& offer() const;
  PROTOBUF_NODISCARD ::location::nearby::mediums::Offer* release_offer();
  ::location::nearby::mediums::Offer* mutable_offer();
  void set_allocated_offer(::location::nearby::mediums::Offer* offer);
  private:
  const ::location::nearby::mediums::Offer& _internal_offer() const;
  ::location::nearby::mediums::Offer* _internal_mutable_offer();
  public:
  void unsafe_arena_set_allocated_offer(
      ::location::nearby::mediums::Offer* offer);
  ::location::nearby::mediums::Offer* unsafe_arena_release_offer();

  // .location.nearby.mediums.Answer answer = 4;
  bool has_answer() const;
  private:
  bool _internal_has_answer() const;
  public:
  void clear_answer();
  const ::location::nearby::mediums::Answer& answer() const;
  PROTOBUF_NODISCARD ::location::nearby::mediums::Answer* release_answer();
  ::location::nearby::mediums::Answer* mutable_answer();
  void set_allocated_answer(::location::nearby::mediums::Answer* answer);
  private:
  const ::location::nearby::mediums::Answer& _internal_answer() const;
  ::location::nearby::mediums::Answer* _internal_mutable_answer();
  public:
  void unsafe_arena_set_allocated_answer(
      ::location::nearby::mediums::Answer* answer);
  ::location::nearby::mediums::Answer* unsafe_arena_release_answer();

  // .location.nearby.mediums.IceCandidates ice_candidates = 5;
  bool has_ice_candidates() const;
  private:
  bool _internal_has_ice_candidates() const;
  public:
  void clear_ice_candidates();
  const ::location::nearby::mediums::IceCandidates& ice_candidates() const;
  PROTOBUF_NODISCARD ::location::nearby::mediums::IceCandidates* release_ice_candidates();
  ::location::nearby::mediums::IceCandidates* mutable_ice_candidates();
  void set_allocated_ice_candidates(::location::nearby::mediums::IceCandidates* ice_candidates);
  private:
  const ::location::nearby::mediums::IceCandidates& _internal_ice_candidates() const;
  ::location::nearby::mediums::IceCandidates* _internal_mutable_ice_candidates();
  public:
  void unsafe_arena_set_allocated_ice_candidates(
      ::location::nearby::mediums::IceCandidates* ice_candidates);
  ::location::nearby::mediums::IceCandidates* unsafe_arena_release_ice_candidates();

  // .location.nearby.mediums.ReadyForSignalingPoke ready_for_signaling_poke = 6;
  bool has_ready_for_signaling_poke() const;
  private:
  bool _internal_has_ready_for_signaling_poke() const;
  public:
  void clear_ready_for_signaling_poke();
  const ::location::nearby::mediums::ReadyForSignalingPoke& ready_for_signaling_poke() const;
  PROTOBUF_NODISCARD ::location::nearby::mediums::ReadyForSignalingPoke* release_ready_for_signaling_poke();
  ::location::nearby::mediums::ReadyForSignalingPoke* mutable_ready_for_signaling_poke();
  void set_allocated_ready_for_signaling_poke(::location::nearby::mediums::ReadyForSignalingPoke* ready_for_signaling_poke);
  private:
  const ::location::nearby::mediums::ReadyForSignalingPoke& _internal_ready_for_signaling_poke() const;
  ::location::nearby::mediums::ReadyForSignalingPoke* _internal_mutable_ready_for_signaling_poke();
  public:
  void unsafe_arena_set_allocated_ready_for_signaling_poke(
      ::location::nearby::mediums::ReadyForSignalingPoke* ready_for_signaling_poke);
  ::location::nearby::mediums::ReadyForSignalingPoke* unsafe_arena_release_ready_for_signaling_poke();

  void clear_Frame();
  FrameCase Frame_case() const;
  // @@protoc_insertion_point(class_scope:location.nearby.mediums.WebRtcSignalingFrame)
 private:
  class _Internal;
  void set_has_offer();
  void set_has_answer();
  void set_has_ice_candidates();
  void set_has_ready_for_signaling_poke();

  inline bool has_Frame() const;
  inline void clear_has_Frame();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::location::nearby::mediums::PeerId* sender_id_;
  int type_;
  union FrameUnion {
    constexpr FrameUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::location::nearby::mediums::Offer* offer_;
    ::location::nearby::mediums::Answer* answer_;
    ::location::nearby::mediums::IceCandidates* ice_candidates_;
    ::location::nearby::mediums::ReadyForSignalingPoke* ready_for_signaling_poke_;
  } Frame_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_proto_2fmediums_2fweb_5frtc_5fsignaling_5fframes_2eproto;
};
// -------------------------------------------------------------------

class PeerId final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.mediums.PeerId) */ {
 public:
  inline PeerId() : PeerId(nullptr) {}
  ~PeerId() override;
  explicit constexpr PeerId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeerId(const PeerId& from);
  PeerId(PeerId&& from) noexcept
    : PeerId() {
    *this = ::std::move(from);
  }

  inline PeerId& operator=(const PeerId& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerId& operator=(PeerId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PeerId& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeerId* internal_default_instance() {
    return reinterpret_cast<const PeerId*>(
               &_PeerId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PeerId& a, PeerId& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeerId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeerId>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PeerId& from);
  void MergeFrom(const PeerId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PeerId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.mediums.PeerId";
  }
  protected:
  explicit PeerId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // optional string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.mediums.PeerId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  friend struct ::TableStruct_proto_2fmediums_2fweb_5frtc_5fsignaling_5fframes_2eproto;
};
// -------------------------------------------------------------------

class SessionDescription final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.mediums.SessionDescription) */ {
 public:
  inline SessionDescription() : SessionDescription(nullptr) {}
  ~SessionDescription() override;
  explicit constexpr SessionDescription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionDescription(const SessionDescription& from);
  SessionDescription(SessionDescription&& from) noexcept
    : SessionDescription() {
    *this = ::std::move(from);
  }

  inline SessionDescription& operator=(const SessionDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionDescription& operator=(SessionDescription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SessionDescription& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionDescription* internal_default_instance() {
    return reinterpret_cast<const SessionDescription*>(
               &_SessionDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SessionDescription& a, SessionDescription& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionDescription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionDescription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionDescription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionDescription>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SessionDescription& from);
  void MergeFrom(const SessionDescription& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SessionDescription* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.mediums.SessionDescription";
  }
  protected:
  explicit SessionDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 1,
  };
  // optional string description = 1;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.mediums.SessionDescription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  friend struct ::TableStruct_proto_2fmediums_2fweb_5frtc_5fsignaling_5fframes_2eproto;
};
// -------------------------------------------------------------------

class IceCandidate final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.mediums.IceCandidate) */ {
 public:
  inline IceCandidate() : IceCandidate(nullptr) {}
  ~IceCandidate() override;
  explicit constexpr IceCandidate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IceCandidate(const IceCandidate& from);
  IceCandidate(IceCandidate&& from) noexcept
    : IceCandidate() {
    *this = ::std::move(from);
  }

  inline IceCandidate& operator=(const IceCandidate& from) {
    CopyFrom(from);
    return *this;
  }
  inline IceCandidate& operator=(IceCandidate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const IceCandidate& default_instance() {
    return *internal_default_instance();
  }
  static inline const IceCandidate* internal_default_instance() {
    return reinterpret_cast<const IceCandidate*>(
               &_IceCandidate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(IceCandidate& a, IceCandidate& b) {
    a.Swap(&b);
  }
  inline void Swap(IceCandidate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IceCandidate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IceCandidate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IceCandidate>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const IceCandidate& from);
  void MergeFrom(const IceCandidate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IceCandidate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.mediums.IceCandidate";
  }
  protected:
  explicit IceCandidate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSdpFieldNumber = 1,
    kSdpMidFieldNumber = 2,
    kSdpMLineIndexFieldNumber = 3,
  };
  // optional string sdp = 1;
  bool has_sdp() const;
  private:
  bool _internal_has_sdp() const;
  public:
  void clear_sdp();
  const std::string& sdp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdp();
  PROTOBUF_NODISCARD std::string* release_sdp();
  void set_allocated_sdp(std::string* sdp);
  private:
  const std::string& _internal_sdp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdp(const std::string& value);
  std::string* _internal_mutable_sdp();
  public:

  // optional string sdp_mid = 2;
  bool has_sdp_mid() const;
  private:
  bool _internal_has_sdp_mid() const;
  public:
  void clear_sdp_mid();
  const std::string& sdp_mid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdp_mid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdp_mid();
  PROTOBUF_NODISCARD std::string* release_sdp_mid();
  void set_allocated_sdp_mid(std::string* sdp_mid);
  private:
  const std::string& _internal_sdp_mid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdp_mid(const std::string& value);
  std::string* _internal_mutable_sdp_mid();
  public:

  // optional int32 sdp_m_line_index = 3;
  bool has_sdp_m_line_index() const;
  private:
  bool _internal_has_sdp_m_line_index() const;
  public:
  void clear_sdp_m_line_index();
  int32_t sdp_m_line_index() const;
  void set_sdp_m_line_index(int32_t value);
  private:
  int32_t _internal_sdp_m_line_index() const;
  void _internal_set_sdp_m_line_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:location.nearby.mediums.IceCandidate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdp_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdp_mid_;
  int32_t sdp_m_line_index_;
  friend struct ::TableStruct_proto_2fmediums_2fweb_5frtc_5fsignaling_5fframes_2eproto;
};
// -------------------------------------------------------------------

class IceCandidates final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.mediums.IceCandidates) */ {
 public:
  inline IceCandidates() : IceCandidates(nullptr) {}
  ~IceCandidates() override;
  explicit constexpr IceCandidates(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IceCandidates(const IceCandidates& from);
  IceCandidates(IceCandidates&& from) noexcept
    : IceCandidates() {
    *this = ::std::move(from);
  }

  inline IceCandidates& operator=(const IceCandidates& from) {
    CopyFrom(from);
    return *this;
  }
  inline IceCandidates& operator=(IceCandidates&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const IceCandidates& default_instance() {
    return *internal_default_instance();
  }
  static inline const IceCandidates* internal_default_instance() {
    return reinterpret_cast<const IceCandidates*>(
               &_IceCandidates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(IceCandidates& a, IceCandidates& b) {
    a.Swap(&b);
  }
  inline void Swap(IceCandidates* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IceCandidates* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IceCandidates* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IceCandidates>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const IceCandidates& from);
  void MergeFrom(const IceCandidates& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IceCandidates* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.mediums.IceCandidates";
  }
  protected:
  explicit IceCandidates(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIceCandidatesFieldNumber = 1,
  };
  // repeated .location.nearby.mediums.IceCandidate ice_candidates = 1;
  int ice_candidates_size() const;
  private:
  int _internal_ice_candidates_size() const;
  public:
  void clear_ice_candidates();
  ::location::nearby::mediums::IceCandidate* mutable_ice_candidates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::location::nearby::mediums::IceCandidate >*
      mutable_ice_candidates();
  private:
  const ::location::nearby::mediums::IceCandidate& _internal_ice_candidates(int index) const;
  ::location::nearby::mediums::IceCandidate* _internal_add_ice_candidates();
  public:
  const ::location::nearby::mediums::IceCandidate& ice_candidates(int index) const;
  ::location::nearby::mediums::IceCandidate* add_ice_candidates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::location::nearby::mediums::IceCandidate >&
      ice_candidates() const;

  // @@protoc_insertion_point(class_scope:location.nearby.mediums.IceCandidates)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::location::nearby::mediums::IceCandidate > ice_candidates_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fmediums_2fweb_5frtc_5fsignaling_5fframes_2eproto;
};
// -------------------------------------------------------------------

class Offer final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.mediums.Offer) */ {
 public:
  inline Offer() : Offer(nullptr) {}
  ~Offer() override;
  explicit constexpr Offer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Offer(const Offer& from);
  Offer(Offer&& from) noexcept
    : Offer() {
    *this = ::std::move(from);
  }

  inline Offer& operator=(const Offer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Offer& operator=(Offer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Offer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Offer* internal_default_instance() {
    return reinterpret_cast<const Offer*>(
               &_Offer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Offer& a, Offer& b) {
    a.Swap(&b);
  }
  inline void Swap(Offer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Offer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Offer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Offer>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Offer& from);
  void MergeFrom(const Offer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Offer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.mediums.Offer";
  }
  protected:
  explicit Offer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionDescriptionFieldNumber = 1,
  };
  // optional .location.nearby.mediums.SessionDescription session_description = 1;
  bool has_session_description() const;
  private:
  bool _internal_has_session_description() const;
  public:
  void clear_session_description();
  const ::location::nearby::mediums::SessionDescription& session_description() const;
  PROTOBUF_NODISCARD ::location::nearby::mediums::SessionDescription* release_session_description();
  ::location::nearby::mediums::SessionDescription* mutable_session_description();
  void set_allocated_session_description(::location::nearby::mediums::SessionDescription* session_description);
  private:
  const ::location::nearby::mediums::SessionDescription& _internal_session_description() const;
  ::location::nearby::mediums::SessionDescription* _internal_mutable_session_description();
  public:
  void unsafe_arena_set_allocated_session_description(
      ::location::nearby::mediums::SessionDescription* session_description);
  ::location::nearby::mediums::SessionDescription* unsafe_arena_release_session_description();

  // @@protoc_insertion_point(class_scope:location.nearby.mediums.Offer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::location::nearby::mediums::SessionDescription* session_description_;
  friend struct ::TableStruct_proto_2fmediums_2fweb_5frtc_5fsignaling_5fframes_2eproto;
};
// -------------------------------------------------------------------

class Answer final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.mediums.Answer) */ {
 public:
  inline Answer() : Answer(nullptr) {}
  ~Answer() override;
  explicit constexpr Answer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Answer(const Answer& from);
  Answer(Answer&& from) noexcept
    : Answer() {
    *this = ::std::move(from);
  }

  inline Answer& operator=(const Answer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Answer& operator=(Answer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Answer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Answer* internal_default_instance() {
    return reinterpret_cast<const Answer*>(
               &_Answer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Answer& a, Answer& b) {
    a.Swap(&b);
  }
  inline void Swap(Answer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Answer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Answer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Answer>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Answer& from);
  void MergeFrom(const Answer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Answer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.mediums.Answer";
  }
  protected:
  explicit Answer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionDescriptionFieldNumber = 1,
  };
  // optional .location.nearby.mediums.SessionDescription session_description = 1;
  bool has_session_description() const;
  private:
  bool _internal_has_session_description() const;
  public:
  void clear_session_description();
  const ::location::nearby::mediums::SessionDescription& session_description() const;
  PROTOBUF_NODISCARD ::location::nearby::mediums::SessionDescription* release_session_description();
  ::location::nearby::mediums::SessionDescription* mutable_session_description();
  void set_allocated_session_description(::location::nearby::mediums::SessionDescription* session_description);
  private:
  const ::location::nearby::mediums::SessionDescription& _internal_session_description() const;
  ::location::nearby::mediums::SessionDescription* _internal_mutable_session_description();
  public:
  void unsafe_arena_set_allocated_session_description(
      ::location::nearby::mediums::SessionDescription* session_description);
  ::location::nearby::mediums::SessionDescription* unsafe_arena_release_session_description();

  // @@protoc_insertion_point(class_scope:location.nearby.mediums.Answer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::location::nearby::mediums::SessionDescription* session_description_;
  friend struct ::TableStruct_proto_2fmediums_2fweb_5frtc_5fsignaling_5fframes_2eproto;
};
// -------------------------------------------------------------------

class ReadyForSignalingPoke final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.mediums.ReadyForSignalingPoke) */ {
 public:
  inline ReadyForSignalingPoke() : ReadyForSignalingPoke(nullptr) {}
  ~ReadyForSignalingPoke() override;
  explicit constexpr ReadyForSignalingPoke(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadyForSignalingPoke(const ReadyForSignalingPoke& from);
  ReadyForSignalingPoke(ReadyForSignalingPoke&& from) noexcept
    : ReadyForSignalingPoke() {
    *this = ::std::move(from);
  }

  inline ReadyForSignalingPoke& operator=(const ReadyForSignalingPoke& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadyForSignalingPoke& operator=(ReadyForSignalingPoke&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ReadyForSignalingPoke& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadyForSignalingPoke* internal_default_instance() {
    return reinterpret_cast<const ReadyForSignalingPoke*>(
               &_ReadyForSignalingPoke_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ReadyForSignalingPoke& a, ReadyForSignalingPoke& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadyForSignalingPoke* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadyForSignalingPoke* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadyForSignalingPoke* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadyForSignalingPoke>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ReadyForSignalingPoke& from);
  void MergeFrom(const ReadyForSignalingPoke& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReadyForSignalingPoke* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "location.nearby.mediums.ReadyForSignalingPoke";
  }
  protected:
  explicit ReadyForSignalingPoke(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:location.nearby.mediums.ReadyForSignalingPoke)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fmediums_2fweb_5frtc_5fsignaling_5fframes_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// WebRtcSignalingFrame

// optional .location.nearby.mediums.PeerId sender_id = 1;
inline bool WebRtcSignalingFrame::_internal_has_sender_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || sender_id_ != nullptr);
  return value;
}
inline bool WebRtcSignalingFrame::has_sender_id() const {
  return _internal_has_sender_id();
}
inline void WebRtcSignalingFrame::clear_sender_id() {
  if (sender_id_ != nullptr) sender_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::location::nearby::mediums::PeerId& WebRtcSignalingFrame::_internal_sender_id() const {
  const ::location::nearby::mediums::PeerId* p = sender_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::mediums::PeerId&>(
      ::location::nearby::mediums::_PeerId_default_instance_);
}
inline const ::location::nearby::mediums::PeerId& WebRtcSignalingFrame::sender_id() const {
  // @@protoc_insertion_point(field_get:location.nearby.mediums.WebRtcSignalingFrame.sender_id)
  return _internal_sender_id();
}
inline void WebRtcSignalingFrame::unsafe_arena_set_allocated_sender_id(
    ::location::nearby::mediums::PeerId* sender_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sender_id_);
  }
  sender_id_ = sender_id;
  if (sender_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.mediums.WebRtcSignalingFrame.sender_id)
}
inline ::location::nearby::mediums::PeerId* WebRtcSignalingFrame::release_sender_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::location::nearby::mediums::PeerId* temp = sender_id_;
  sender_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::mediums::PeerId* WebRtcSignalingFrame::unsafe_arena_release_sender_id() {
  // @@protoc_insertion_point(field_release:location.nearby.mediums.WebRtcSignalingFrame.sender_id)
  _has_bits_[0] &= ~0x00000001u;
  ::location::nearby::mediums::PeerId* temp = sender_id_;
  sender_id_ = nullptr;
  return temp;
}
inline ::location::nearby::mediums::PeerId* WebRtcSignalingFrame::_internal_mutable_sender_id() {
  _has_bits_[0] |= 0x00000001u;
  if (sender_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::mediums::PeerId>(GetArenaForAllocation());
    sender_id_ = p;
  }
  return sender_id_;
}
inline ::location::nearby::mediums::PeerId* WebRtcSignalingFrame::mutable_sender_id() {
  ::location::nearby::mediums::PeerId* _msg = _internal_mutable_sender_id();
  // @@protoc_insertion_point(field_mutable:location.nearby.mediums.WebRtcSignalingFrame.sender_id)
  return _msg;
}
inline void WebRtcSignalingFrame::set_allocated_sender_id(::location::nearby::mediums::PeerId* sender_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sender_id_;
  }
  if (sender_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::mediums::PeerId>::GetOwningArena(sender_id);
    if (message_arena != submessage_arena) {
      sender_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sender_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sender_id_ = sender_id;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.mediums.WebRtcSignalingFrame.sender_id)
}

// optional .location.nearby.mediums.WebRtcSignalingFrame.FrameType type = 2;
inline bool WebRtcSignalingFrame::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WebRtcSignalingFrame::has_type() const {
  return _internal_has_type();
}
inline void WebRtcSignalingFrame::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::location::nearby::mediums::WebRtcSignalingFrame_FrameType WebRtcSignalingFrame::_internal_type() const {
  return static_cast< ::location::nearby::mediums::WebRtcSignalingFrame_FrameType >(type_);
}
inline ::location::nearby::mediums::WebRtcSignalingFrame_FrameType WebRtcSignalingFrame::type() const {
  // @@protoc_insertion_point(field_get:location.nearby.mediums.WebRtcSignalingFrame.type)
  return _internal_type();
}
inline void WebRtcSignalingFrame::_internal_set_type(::location::nearby::mediums::WebRtcSignalingFrame_FrameType value) {
  assert(::location::nearby::mediums::WebRtcSignalingFrame_FrameType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void WebRtcSignalingFrame::set_type(::location::nearby::mediums::WebRtcSignalingFrame_FrameType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:location.nearby.mediums.WebRtcSignalingFrame.type)
}

// .location.nearby.mediums.Offer offer = 3;
inline bool WebRtcSignalingFrame::_internal_has_offer() const {
  return Frame_case() == kOffer;
}
inline bool WebRtcSignalingFrame::has_offer() const {
  return _internal_has_offer();
}
inline void WebRtcSignalingFrame::set_has_offer() {
  _oneof_case_[0] = kOffer;
}
inline void WebRtcSignalingFrame::clear_offer() {
  if (_internal_has_offer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Frame_.offer_;
    }
    clear_has_Frame();
  }
}
inline ::location::nearby::mediums::Offer* WebRtcSignalingFrame::release_offer() {
  // @@protoc_insertion_point(field_release:location.nearby.mediums.WebRtcSignalingFrame.offer)
  if (_internal_has_offer()) {
    clear_has_Frame();
      ::location::nearby::mediums::Offer* temp = Frame_.offer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Frame_.offer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::location::nearby::mediums::Offer& WebRtcSignalingFrame::_internal_offer() const {
  return _internal_has_offer()
      ? *Frame_.offer_
      : reinterpret_cast< ::location::nearby::mediums::Offer&>(::location::nearby::mediums::_Offer_default_instance_);
}
inline const ::location::nearby::mediums::Offer& WebRtcSignalingFrame::offer() const {
  // @@protoc_insertion_point(field_get:location.nearby.mediums.WebRtcSignalingFrame.offer)
  return _internal_offer();
}
inline ::location::nearby::mediums::Offer* WebRtcSignalingFrame::unsafe_arena_release_offer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:location.nearby.mediums.WebRtcSignalingFrame.offer)
  if (_internal_has_offer()) {
    clear_has_Frame();
    ::location::nearby::mediums::Offer* temp = Frame_.offer_;
    Frame_.offer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WebRtcSignalingFrame::unsafe_arena_set_allocated_offer(::location::nearby::mediums::Offer* offer) {
  clear_Frame();
  if (offer) {
    set_has_offer();
    Frame_.offer_ = offer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.mediums.WebRtcSignalingFrame.offer)
}
inline ::location::nearby::mediums::Offer* WebRtcSignalingFrame::_internal_mutable_offer() {
  if (!_internal_has_offer()) {
    clear_Frame();
    set_has_offer();
    Frame_.offer_ = CreateMaybeMessage< ::location::nearby::mediums::Offer >(GetArenaForAllocation());
  }
  return Frame_.offer_;
}
inline ::location::nearby::mediums::Offer* WebRtcSignalingFrame::mutable_offer() {
  ::location::nearby::mediums::Offer* _msg = _internal_mutable_offer();
  // @@protoc_insertion_point(field_mutable:location.nearby.mediums.WebRtcSignalingFrame.offer)
  return _msg;
}

// .location.nearby.mediums.Answer answer = 4;
inline bool WebRtcSignalingFrame::_internal_has_answer() const {
  return Frame_case() == kAnswer;
}
inline bool WebRtcSignalingFrame::has_answer() const {
  return _internal_has_answer();
}
inline void WebRtcSignalingFrame::set_has_answer() {
  _oneof_case_[0] = kAnswer;
}
inline void WebRtcSignalingFrame::clear_answer() {
  if (_internal_has_answer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Frame_.answer_;
    }
    clear_has_Frame();
  }
}
inline ::location::nearby::mediums::Answer* WebRtcSignalingFrame::release_answer() {
  // @@protoc_insertion_point(field_release:location.nearby.mediums.WebRtcSignalingFrame.answer)
  if (_internal_has_answer()) {
    clear_has_Frame();
      ::location::nearby::mediums::Answer* temp = Frame_.answer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Frame_.answer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::location::nearby::mediums::Answer& WebRtcSignalingFrame::_internal_answer() const {
  return _internal_has_answer()
      ? *Frame_.answer_
      : reinterpret_cast< ::location::nearby::mediums::Answer&>(::location::nearby::mediums::_Answer_default_instance_);
}
inline const ::location::nearby::mediums::Answer& WebRtcSignalingFrame::answer() const {
  // @@protoc_insertion_point(field_get:location.nearby.mediums.WebRtcSignalingFrame.answer)
  return _internal_answer();
}
inline ::location::nearby::mediums::Answer* WebRtcSignalingFrame::unsafe_arena_release_answer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:location.nearby.mediums.WebRtcSignalingFrame.answer)
  if (_internal_has_answer()) {
    clear_has_Frame();
    ::location::nearby::mediums::Answer* temp = Frame_.answer_;
    Frame_.answer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WebRtcSignalingFrame::unsafe_arena_set_allocated_answer(::location::nearby::mediums::Answer* answer) {
  clear_Frame();
  if (answer) {
    set_has_answer();
    Frame_.answer_ = answer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.mediums.WebRtcSignalingFrame.answer)
}
inline ::location::nearby::mediums::Answer* WebRtcSignalingFrame::_internal_mutable_answer() {
  if (!_internal_has_answer()) {
    clear_Frame();
    set_has_answer();
    Frame_.answer_ = CreateMaybeMessage< ::location::nearby::mediums::Answer >(GetArenaForAllocation());
  }
  return Frame_.answer_;
}
inline ::location::nearby::mediums::Answer* WebRtcSignalingFrame::mutable_answer() {
  ::location::nearby::mediums::Answer* _msg = _internal_mutable_answer();
  // @@protoc_insertion_point(field_mutable:location.nearby.mediums.WebRtcSignalingFrame.answer)
  return _msg;
}

// .location.nearby.mediums.IceCandidates ice_candidates = 5;
inline bool WebRtcSignalingFrame::_internal_has_ice_candidates() const {
  return Frame_case() == kIceCandidates;
}
inline bool WebRtcSignalingFrame::has_ice_candidates() const {
  return _internal_has_ice_candidates();
}
inline void WebRtcSignalingFrame::set_has_ice_candidates() {
  _oneof_case_[0] = kIceCandidates;
}
inline void WebRtcSignalingFrame::clear_ice_candidates() {
  if (_internal_has_ice_candidates()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Frame_.ice_candidates_;
    }
    clear_has_Frame();
  }
}
inline ::location::nearby::mediums::IceCandidates* WebRtcSignalingFrame::release_ice_candidates() {
  // @@protoc_insertion_point(field_release:location.nearby.mediums.WebRtcSignalingFrame.ice_candidates)
  if (_internal_has_ice_candidates()) {
    clear_has_Frame();
      ::location::nearby::mediums::IceCandidates* temp = Frame_.ice_candidates_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Frame_.ice_candidates_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::location::nearby::mediums::IceCandidates& WebRtcSignalingFrame::_internal_ice_candidates() const {
  return _internal_has_ice_candidates()
      ? *Frame_.ice_candidates_
      : reinterpret_cast< ::location::nearby::mediums::IceCandidates&>(::location::nearby::mediums::_IceCandidates_default_instance_);
}
inline const ::location::nearby::mediums::IceCandidates& WebRtcSignalingFrame::ice_candidates() const {
  // @@protoc_insertion_point(field_get:location.nearby.mediums.WebRtcSignalingFrame.ice_candidates)
  return _internal_ice_candidates();
}
inline ::location::nearby::mediums::IceCandidates* WebRtcSignalingFrame::unsafe_arena_release_ice_candidates() {
  // @@protoc_insertion_point(field_unsafe_arena_release:location.nearby.mediums.WebRtcSignalingFrame.ice_candidates)
  if (_internal_has_ice_candidates()) {
    clear_has_Frame();
    ::location::nearby::mediums::IceCandidates* temp = Frame_.ice_candidates_;
    Frame_.ice_candidates_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WebRtcSignalingFrame::unsafe_arena_set_allocated_ice_candidates(::location::nearby::mediums::IceCandidates* ice_candidates) {
  clear_Frame();
  if (ice_candidates) {
    set_has_ice_candidates();
    Frame_.ice_candidates_ = ice_candidates;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.mediums.WebRtcSignalingFrame.ice_candidates)
}
inline ::location::nearby::mediums::IceCandidates* WebRtcSignalingFrame::_internal_mutable_ice_candidates() {
  if (!_internal_has_ice_candidates()) {
    clear_Frame();
    set_has_ice_candidates();
    Frame_.ice_candidates_ = CreateMaybeMessage< ::location::nearby::mediums::IceCandidates >(GetArenaForAllocation());
  }
  return Frame_.ice_candidates_;
}
inline ::location::nearby::mediums::IceCandidates* WebRtcSignalingFrame::mutable_ice_candidates() {
  ::location::nearby::mediums::IceCandidates* _msg = _internal_mutable_ice_candidates();
  // @@protoc_insertion_point(field_mutable:location.nearby.mediums.WebRtcSignalingFrame.ice_candidates)
  return _msg;
}

// .location.nearby.mediums.ReadyForSignalingPoke ready_for_signaling_poke = 6;
inline bool WebRtcSignalingFrame::_internal_has_ready_for_signaling_poke() const {
  return Frame_case() == kReadyForSignalingPoke;
}
inline bool WebRtcSignalingFrame::has_ready_for_signaling_poke() const {
  return _internal_has_ready_for_signaling_poke();
}
inline void WebRtcSignalingFrame::set_has_ready_for_signaling_poke() {
  _oneof_case_[0] = kReadyForSignalingPoke;
}
inline void WebRtcSignalingFrame::clear_ready_for_signaling_poke() {
  if (_internal_has_ready_for_signaling_poke()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Frame_.ready_for_signaling_poke_;
    }
    clear_has_Frame();
  }
}
inline ::location::nearby::mediums::ReadyForSignalingPoke* WebRtcSignalingFrame::release_ready_for_signaling_poke() {
  // @@protoc_insertion_point(field_release:location.nearby.mediums.WebRtcSignalingFrame.ready_for_signaling_poke)
  if (_internal_has_ready_for_signaling_poke()) {
    clear_has_Frame();
      ::location::nearby::mediums::ReadyForSignalingPoke* temp = Frame_.ready_for_signaling_poke_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Frame_.ready_for_signaling_poke_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::location::nearby::mediums::ReadyForSignalingPoke& WebRtcSignalingFrame::_internal_ready_for_signaling_poke() const {
  return _internal_has_ready_for_signaling_poke()
      ? *Frame_.ready_for_signaling_poke_
      : reinterpret_cast< ::location::nearby::mediums::ReadyForSignalingPoke&>(::location::nearby::mediums::_ReadyForSignalingPoke_default_instance_);
}
inline const ::location::nearby::mediums::ReadyForSignalingPoke& WebRtcSignalingFrame::ready_for_signaling_poke() const {
  // @@protoc_insertion_point(field_get:location.nearby.mediums.WebRtcSignalingFrame.ready_for_signaling_poke)
  return _internal_ready_for_signaling_poke();
}
inline ::location::nearby::mediums::ReadyForSignalingPoke* WebRtcSignalingFrame::unsafe_arena_release_ready_for_signaling_poke() {
  // @@protoc_insertion_point(field_unsafe_arena_release:location.nearby.mediums.WebRtcSignalingFrame.ready_for_signaling_poke)
  if (_internal_has_ready_for_signaling_poke()) {
    clear_has_Frame();
    ::location::nearby::mediums::ReadyForSignalingPoke* temp = Frame_.ready_for_signaling_poke_;
    Frame_.ready_for_signaling_poke_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WebRtcSignalingFrame::unsafe_arena_set_allocated_ready_for_signaling_poke(::location::nearby::mediums::ReadyForSignalingPoke* ready_for_signaling_poke) {
  clear_Frame();
  if (ready_for_signaling_poke) {
    set_has_ready_for_signaling_poke();
    Frame_.ready_for_signaling_poke_ = ready_for_signaling_poke;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.mediums.WebRtcSignalingFrame.ready_for_signaling_poke)
}
inline ::location::nearby::mediums::ReadyForSignalingPoke* WebRtcSignalingFrame::_internal_mutable_ready_for_signaling_poke() {
  if (!_internal_has_ready_for_signaling_poke()) {
    clear_Frame();
    set_has_ready_for_signaling_poke();
    Frame_.ready_for_signaling_poke_ = CreateMaybeMessage< ::location::nearby::mediums::ReadyForSignalingPoke >(GetArenaForAllocation());
  }
  return Frame_.ready_for_signaling_poke_;
}
inline ::location::nearby::mediums::ReadyForSignalingPoke* WebRtcSignalingFrame::mutable_ready_for_signaling_poke() {
  ::location::nearby::mediums::ReadyForSignalingPoke* _msg = _internal_mutable_ready_for_signaling_poke();
  // @@protoc_insertion_point(field_mutable:location.nearby.mediums.WebRtcSignalingFrame.ready_for_signaling_poke)
  return _msg;
}

inline bool WebRtcSignalingFrame::has_Frame() const {
  return Frame_case() != FRAME_NOT_SET;
}
inline void WebRtcSignalingFrame::clear_has_Frame() {
  _oneof_case_[0] = FRAME_NOT_SET;
}
inline WebRtcSignalingFrame::FrameCase WebRtcSignalingFrame::Frame_case() const {
  return WebRtcSignalingFrame::FrameCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PeerId

// optional string id = 1;
inline bool PeerId::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PeerId::has_id() const {
  return _internal_has_id();
}
inline void PeerId::clear_id() {
  id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PeerId::id() const {
  // @@protoc_insertion_point(field_get:location.nearby.mediums.PeerId.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PeerId::set_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.mediums.PeerId.id)
}
inline std::string* PeerId::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:location.nearby.mediums.PeerId.id)
  return _s;
}
inline const std::string& PeerId::_internal_id() const {
  return id_.Get();
}
inline void PeerId::_internal_set_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PeerId::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PeerId::release_id() {
  // @@protoc_insertion_point(field_release:location.nearby.mediums.PeerId.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PeerId::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.mediums.PeerId.id)
}

// -------------------------------------------------------------------

// SessionDescription

// optional string description = 1;
inline bool SessionDescription::_internal_has_description() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SessionDescription::has_description() const {
  return _internal_has_description();
}
inline void SessionDescription::clear_description() {
  description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SessionDescription::description() const {
  // @@protoc_insertion_point(field_get:location.nearby.mediums.SessionDescription.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionDescription::set_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.mediums.SessionDescription.description)
}
inline std::string* SessionDescription::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:location.nearby.mediums.SessionDescription.description)
  return _s;
}
inline const std::string& SessionDescription::_internal_description() const {
  return description_.Get();
}
inline void SessionDescription::_internal_set_description(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SessionDescription::_internal_mutable_description() {
  _has_bits_[0] |= 0x00000001u;
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SessionDescription::release_description() {
  // @@protoc_insertion_point(field_release:location.nearby.mediums.SessionDescription.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = description_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SessionDescription::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.mediums.SessionDescription.description)
}

// -------------------------------------------------------------------

// IceCandidate

// optional string sdp = 1;
inline bool IceCandidate::_internal_has_sdp() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IceCandidate::has_sdp() const {
  return _internal_has_sdp();
}
inline void IceCandidate::clear_sdp() {
  sdp_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IceCandidate::sdp() const {
  // @@protoc_insertion_point(field_get:location.nearby.mediums.IceCandidate.sdp)
  return _internal_sdp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IceCandidate::set_sdp(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 sdp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.mediums.IceCandidate.sdp)
}
inline std::string* IceCandidate::mutable_sdp() {
  std::string* _s = _internal_mutable_sdp();
  // @@protoc_insertion_point(field_mutable:location.nearby.mediums.IceCandidate.sdp)
  return _s;
}
inline const std::string& IceCandidate::_internal_sdp() const {
  return sdp_.Get();
}
inline void IceCandidate::_internal_set_sdp(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  sdp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IceCandidate::_internal_mutable_sdp() {
  _has_bits_[0] |= 0x00000001u;
  return sdp_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IceCandidate::release_sdp() {
  // @@protoc_insertion_point(field_release:location.nearby.mediums.IceCandidate.sdp)
  if (!_internal_has_sdp()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = sdp_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sdp_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sdp_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void IceCandidate::set_allocated_sdp(std::string* sdp) {
  if (sdp != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sdp_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sdp,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sdp_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sdp_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.mediums.IceCandidate.sdp)
}

// optional string sdp_mid = 2;
inline bool IceCandidate::_internal_has_sdp_mid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool IceCandidate::has_sdp_mid() const {
  return _internal_has_sdp_mid();
}
inline void IceCandidate::clear_sdp_mid() {
  sdp_mid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& IceCandidate::sdp_mid() const {
  // @@protoc_insertion_point(field_get:location.nearby.mediums.IceCandidate.sdp_mid)
  return _internal_sdp_mid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IceCandidate::set_sdp_mid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 sdp_mid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.mediums.IceCandidate.sdp_mid)
}
inline std::string* IceCandidate::mutable_sdp_mid() {
  std::string* _s = _internal_mutable_sdp_mid();
  // @@protoc_insertion_point(field_mutable:location.nearby.mediums.IceCandidate.sdp_mid)
  return _s;
}
inline const std::string& IceCandidate::_internal_sdp_mid() const {
  return sdp_mid_.Get();
}
inline void IceCandidate::_internal_set_sdp_mid(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  sdp_mid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IceCandidate::_internal_mutable_sdp_mid() {
  _has_bits_[0] |= 0x00000002u;
  return sdp_mid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IceCandidate::release_sdp_mid() {
  // @@protoc_insertion_point(field_release:location.nearby.mediums.IceCandidate.sdp_mid)
  if (!_internal_has_sdp_mid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = sdp_mid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sdp_mid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sdp_mid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void IceCandidate::set_allocated_sdp_mid(std::string* sdp_mid) {
  if (sdp_mid != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sdp_mid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sdp_mid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sdp_mid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sdp_mid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.mediums.IceCandidate.sdp_mid)
}

// optional int32 sdp_m_line_index = 3;
inline bool IceCandidate::_internal_has_sdp_m_line_index() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool IceCandidate::has_sdp_m_line_index() const {
  return _internal_has_sdp_m_line_index();
}
inline void IceCandidate::clear_sdp_m_line_index() {
  sdp_m_line_index_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t IceCandidate::_internal_sdp_m_line_index() const {
  return sdp_m_line_index_;
}
inline int32_t IceCandidate::sdp_m_line_index() const {
  // @@protoc_insertion_point(field_get:location.nearby.mediums.IceCandidate.sdp_m_line_index)
  return _internal_sdp_m_line_index();
}
inline void IceCandidate::_internal_set_sdp_m_line_index(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  sdp_m_line_index_ = value;
}
inline void IceCandidate::set_sdp_m_line_index(int32_t value) {
  _internal_set_sdp_m_line_index(value);
  // @@protoc_insertion_point(field_set:location.nearby.mediums.IceCandidate.sdp_m_line_index)
}

// -------------------------------------------------------------------

// IceCandidates

// repeated .location.nearby.mediums.IceCandidate ice_candidates = 1;
inline int IceCandidates::_internal_ice_candidates_size() const {
  return ice_candidates_.size();
}
inline int IceCandidates::ice_candidates_size() const {
  return _internal_ice_candidates_size();
}
inline void IceCandidates::clear_ice_candidates() {
  ice_candidates_.Clear();
}
inline ::location::nearby::mediums::IceCandidate* IceCandidates::mutable_ice_candidates(int index) {
  // @@protoc_insertion_point(field_mutable:location.nearby.mediums.IceCandidates.ice_candidates)
  return ice_candidates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::location::nearby::mediums::IceCandidate >*
IceCandidates::mutable_ice_candidates() {
  // @@protoc_insertion_point(field_mutable_list:location.nearby.mediums.IceCandidates.ice_candidates)
  return &ice_candidates_;
}
inline const ::location::nearby::mediums::IceCandidate& IceCandidates::_internal_ice_candidates(int index) const {
  return ice_candidates_.Get(index);
}
inline const ::location::nearby::mediums::IceCandidate& IceCandidates::ice_candidates(int index) const {
  // @@protoc_insertion_point(field_get:location.nearby.mediums.IceCandidates.ice_candidates)
  return _internal_ice_candidates(index);
}
inline ::location::nearby::mediums::IceCandidate* IceCandidates::_internal_add_ice_candidates() {
  return ice_candidates_.Add();
}
inline ::location::nearby::mediums::IceCandidate* IceCandidates::add_ice_candidates() {
  ::location::nearby::mediums::IceCandidate* _add = _internal_add_ice_candidates();
  // @@protoc_insertion_point(field_add:location.nearby.mediums.IceCandidates.ice_candidates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::location::nearby::mediums::IceCandidate >&
IceCandidates::ice_candidates() const {
  // @@protoc_insertion_point(field_list:location.nearby.mediums.IceCandidates.ice_candidates)
  return ice_candidates_;
}

// -------------------------------------------------------------------

// Offer

// optional .location.nearby.mediums.SessionDescription session_description = 1;
inline bool Offer::_internal_has_session_description() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || session_description_ != nullptr);
  return value;
}
inline bool Offer::has_session_description() const {
  return _internal_has_session_description();
}
inline void Offer::clear_session_description() {
  if (session_description_ != nullptr) session_description_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::location::nearby::mediums::SessionDescription& Offer::_internal_session_description() const {
  const ::location::nearby::mediums::SessionDescription* p = session_description_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::mediums::SessionDescription&>(
      ::location::nearby::mediums::_SessionDescription_default_instance_);
}
inline const ::location::nearby::mediums::SessionDescription& Offer::session_description() const {
  // @@protoc_insertion_point(field_get:location.nearby.mediums.Offer.session_description)
  return _internal_session_description();
}
inline void Offer::unsafe_arena_set_allocated_session_description(
    ::location::nearby::mediums::SessionDescription* session_description) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(session_description_);
  }
  session_description_ = session_description;
  if (session_description) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.mediums.Offer.session_description)
}
inline ::location::nearby::mediums::SessionDescription* Offer::release_session_description() {
  _has_bits_[0] &= ~0x00000001u;
  ::location::nearby::mediums::SessionDescription* temp = session_description_;
  session_description_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::mediums::SessionDescription* Offer::unsafe_arena_release_session_description() {
  // @@protoc_insertion_point(field_release:location.nearby.mediums.Offer.session_description)
  _has_bits_[0] &= ~0x00000001u;
  ::location::nearby::mediums::SessionDescription* temp = session_description_;
  session_description_ = nullptr;
  return temp;
}
inline ::location::nearby::mediums::SessionDescription* Offer::_internal_mutable_session_description() {
  _has_bits_[0] |= 0x00000001u;
  if (session_description_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::mediums::SessionDescription>(GetArenaForAllocation());
    session_description_ = p;
  }
  return session_description_;
}
inline ::location::nearby::mediums::SessionDescription* Offer::mutable_session_description() {
  ::location::nearby::mediums::SessionDescription* _msg = _internal_mutable_session_description();
  // @@protoc_insertion_point(field_mutable:location.nearby.mediums.Offer.session_description)
  return _msg;
}
inline void Offer::set_allocated_session_description(::location::nearby::mediums::SessionDescription* session_description) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete session_description_;
  }
  if (session_description) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::mediums::SessionDescription>::GetOwningArena(session_description);
    if (message_arena != submessage_arena) {
      session_description = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, session_description, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  session_description_ = session_description;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.mediums.Offer.session_description)
}

// -------------------------------------------------------------------

// Answer

// optional .location.nearby.mediums.SessionDescription session_description = 1;
inline bool Answer::_internal_has_session_description() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || session_description_ != nullptr);
  return value;
}
inline bool Answer::has_session_description() const {
  return _internal_has_session_description();
}
inline void Answer::clear_session_description() {
  if (session_description_ != nullptr) session_description_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::location::nearby::mediums::SessionDescription& Answer::_internal_session_description() const {
  const ::location::nearby::mediums::SessionDescription* p = session_description_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::mediums::SessionDescription&>(
      ::location::nearby::mediums::_SessionDescription_default_instance_);
}
inline const ::location::nearby::mediums::SessionDescription& Answer::session_description() const {
  // @@protoc_insertion_point(field_get:location.nearby.mediums.Answer.session_description)
  return _internal_session_description();
}
inline void Answer::unsafe_arena_set_allocated_session_description(
    ::location::nearby::mediums::SessionDescription* session_description) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(session_description_);
  }
  session_description_ = session_description;
  if (session_description) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.mediums.Answer.session_description)
}
inline ::location::nearby::mediums::SessionDescription* Answer::release_session_description() {
  _has_bits_[0] &= ~0x00000001u;
  ::location::nearby::mediums::SessionDescription* temp = session_description_;
  session_description_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::mediums::SessionDescription* Answer::unsafe_arena_release_session_description() {
  // @@protoc_insertion_point(field_release:location.nearby.mediums.Answer.session_description)
  _has_bits_[0] &= ~0x00000001u;
  ::location::nearby::mediums::SessionDescription* temp = session_description_;
  session_description_ = nullptr;
  return temp;
}
inline ::location::nearby::mediums::SessionDescription* Answer::_internal_mutable_session_description() {
  _has_bits_[0] |= 0x00000001u;
  if (session_description_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::mediums::SessionDescription>(GetArenaForAllocation());
    session_description_ = p;
  }
  return session_description_;
}
inline ::location::nearby::mediums::SessionDescription* Answer::mutable_session_description() {
  ::location::nearby::mediums::SessionDescription* _msg = _internal_mutable_session_description();
  // @@protoc_insertion_point(field_mutable:location.nearby.mediums.Answer.session_description)
  return _msg;
}
inline void Answer::set_allocated_session_description(::location::nearby::mediums::SessionDescription* session_description) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete session_description_;
  }
  if (session_description) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::location::nearby::mediums::SessionDescription>::GetOwningArena(session_description);
    if (message_arena != submessage_arena) {
      session_description = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, session_description, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  session_description_ = session_description;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.mediums.Answer.session_description)
}

// -------------------------------------------------------------------

// ReadyForSignalingPoke

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mediums
}  // namespace nearby
}  // namespace location

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::location::nearby::mediums::WebRtcSignalingFrame_FrameType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proto_2fmediums_2fweb_5frtc_5fsignaling_5fframes_2eproto
