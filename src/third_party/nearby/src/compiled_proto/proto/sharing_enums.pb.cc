// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/sharing_enums.proto

#include "proto/sharing_enums.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace location {
namespace nearby {
namespace proto {
namespace sharing {
}  // namespace sharing
}  // namespace proto
}  // namespace nearby
}  // namespace location
namespace location {
namespace nearby {
namespace proto {
namespace sharing {
bool EventType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EventType_strings[50] = {};

static const char EventType_names[] =
  "ACCEPT_AGREEMENTS"
  "ACCEPT_FAST_INITIALIZATION"
  "ADD_CONTACT"
  "ADD_QUICK_SETTINGS_TILE"
  "ADVERTISE_DEVICE_PRESENCE_END"
  "ADVERTISE_DEVICE_PRESENCE_START"
  "CANCEL_CONNECTION"
  "CANCEL_RECEIVING_ATTACHMENTS"
  "CANCEL_SENDING_ATTACHMENTS"
  "DECLINE_AGREEMENTS"
  "DESCRIBE_ATTACHMENTS"
  "DEVICE_SETTINGS"
  "DISCOVER_SHARE_TARGET"
  "DISMISS_FAST_INITIALIZATION"
  "DISMISS_PRIVACY_NOTIFICATION"
  "ENABLE_NEARBY_SHARING"
  "ESTABLISH_CONNECTION"
  "FAST_SHARE_SERVER_RESPONSE"
  "INSTALL_APK"
  "LAUNCH_ACTIVITY"
  "LAUNCH_CONSENT"
  "LAUNCH_PHONE_CONSENT"
  "LAUNCH_SETUP_ACTIVITY"
  "OPEN_RECEIVED_ATTACHMENTS"
  "PROCESS_RECEIVED_ATTACHMENTS_END"
  "RECEIVE_ATTACHMENTS_END"
  "RECEIVE_ATTACHMENTS_START"
  "RECEIVE_FAST_INITIALIZATION"
  "RECEIVE_INTRODUCTION"
  "REMOVE_CONTACT"
  "REMOVE_QUICK_SETTINGS_TILE"
  "REQUEST_SETTING_PERMISSIONS"
  "RESPOND_TO_INTRODUCTION"
  "SCAN_FOR_SHARE_TARGETS_END"
  "SCAN_FOR_SHARE_TARGETS_START"
  "SEND_ATTACHMENTS_END"
  "SEND_ATTACHMENTS_START"
  "SEND_FAST_INITIALIZATION"
  "SEND_INTRODUCTION"
  "SEND_START"
  "SET_DATA_USAGE"
  "SET_DEVICE_NAME"
  "SET_VISIBILITY"
  "TAP_FEEDBACK"
  "TAP_HELP"
  "TAP_PRIVACY_NOTIFICATION"
  "TAP_QUICK_SETTINGS_TILE"
  "TOGGLE_SHOW_NOTIFICATION"
  "UNKNOWN_EVENT_TYPE"
  "VERIFY_APK";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EventType_entries[] = {
  { {EventType_names + 0, 17}, 1 },
  { {EventType_names + 17, 26}, 27 },
  { {EventType_names + 43, 11}, 23 },
  { {EventType_names + 54, 23}, 36 },
  { {EventType_names + 77, 29}, 8 },
  { {EventType_names + 106, 31}, 7 },
  { {EventType_names + 137, 17}, 30 },
  { {EventType_names + 154, 28}, 20 },
  { {EventType_names + 182, 26}, 19 },
  { {EventType_names + 208, 18}, 46 },
  { {EventType_names + 226, 20}, 4 },
  { {EventType_names + 246, 15}, 49 },
  { {EventType_names + 261, 21}, 11 },
  { {EventType_names + 282, 27}, 29 },
  { {EventType_names + 309, 28}, 32 },
  { {EventType_names + 337, 21}, 2 },
  { {EventType_names + 358, 20}, 48 },
  { {EventType_names + 378, 26}, 25 },
  { {EventType_names + 404, 11}, 40 },
  { {EventType_names + 415, 15}, 31 },
  { {EventType_names + 430, 14}, 42 },
  { {EventType_names + 444, 20}, 38 },
  { {EventType_names + 464, 21}, 22 },
  { {EventType_names + 485, 25}, 21 },
  { {EventType_names + 510, 32}, 43 },
  { {EventType_names + 542, 23}, 18 },
  { {EventType_names + 565, 25}, 17 },
  { {EventType_names + 590, 27}, 10 },
  { {EventType_names + 617, 20}, 13 },
  { {EventType_names + 637, 14}, 24 },
  { {EventType_names + 651, 26}, 37 },
  { {EventType_names + 677, 27}, 47 },
  { {EventType_names + 704, 23}, 14 },
  { {EventType_names + 727, 26}, 6 },
  { {EventType_names + 753, 28}, 5 },
  { {EventType_names + 781, 20}, 16 },
  { {EventType_names + 801, 22}, 15 },
  { {EventType_names + 823, 24}, 9 },
  { {EventType_names + 847, 17}, 12 },
  { {EventType_names + 864, 10}, 26 },
  { {EventType_names + 874, 14}, 28 },
  { {EventType_names + 888, 15}, 45 },
  { {EventType_names + 903, 14}, 3 },
  { {EventType_names + 917, 12}, 35 },
  { {EventType_names + 929, 8}, 34 },
  { {EventType_names + 937, 24}, 33 },
  { {EventType_names + 961, 23}, 39 },
  { {EventType_names + 984, 24}, 44 },
  { {EventType_names + 1008, 18}, 0 },
  { {EventType_names + 1026, 10}, 41 },
};

static const int EventType_entries_by_number[] = {
  48, // 0 -> UNKNOWN_EVENT_TYPE
  0, // 1 -> ACCEPT_AGREEMENTS
  15, // 2 -> ENABLE_NEARBY_SHARING
  42, // 3 -> SET_VISIBILITY
  10, // 4 -> DESCRIBE_ATTACHMENTS
  34, // 5 -> SCAN_FOR_SHARE_TARGETS_START
  33, // 6 -> SCAN_FOR_SHARE_TARGETS_END
  5, // 7 -> ADVERTISE_DEVICE_PRESENCE_START
  4, // 8 -> ADVERTISE_DEVICE_PRESENCE_END
  37, // 9 -> SEND_FAST_INITIALIZATION
  27, // 10 -> RECEIVE_FAST_INITIALIZATION
  12, // 11 -> DISCOVER_SHARE_TARGET
  38, // 12 -> SEND_INTRODUCTION
  28, // 13 -> RECEIVE_INTRODUCTION
  32, // 14 -> RESPOND_TO_INTRODUCTION
  36, // 15 -> SEND_ATTACHMENTS_START
  35, // 16 -> SEND_ATTACHMENTS_END
  26, // 17 -> RECEIVE_ATTACHMENTS_START
  25, // 18 -> RECEIVE_ATTACHMENTS_END
  8, // 19 -> CANCEL_SENDING_ATTACHMENTS
  7, // 20 -> CANCEL_RECEIVING_ATTACHMENTS
  23, // 21 -> OPEN_RECEIVED_ATTACHMENTS
  22, // 22 -> LAUNCH_SETUP_ACTIVITY
  2, // 23 -> ADD_CONTACT
  29, // 24 -> REMOVE_CONTACT
  17, // 25 -> FAST_SHARE_SERVER_RESPONSE
  39, // 26 -> SEND_START
  1, // 27 -> ACCEPT_FAST_INITIALIZATION
  40, // 28 -> SET_DATA_USAGE
  13, // 29 -> DISMISS_FAST_INITIALIZATION
  6, // 30 -> CANCEL_CONNECTION
  19, // 31 -> LAUNCH_ACTIVITY
  14, // 32 -> DISMISS_PRIVACY_NOTIFICATION
  45, // 33 -> TAP_PRIVACY_NOTIFICATION
  44, // 34 -> TAP_HELP
  43, // 35 -> TAP_FEEDBACK
  3, // 36 -> ADD_QUICK_SETTINGS_TILE
  30, // 37 -> REMOVE_QUICK_SETTINGS_TILE
  21, // 38 -> LAUNCH_PHONE_CONSENT
  46, // 39 -> TAP_QUICK_SETTINGS_TILE
  18, // 40 -> INSTALL_APK
  49, // 41 -> VERIFY_APK
  20, // 42 -> LAUNCH_CONSENT
  24, // 43 -> PROCESS_RECEIVED_ATTACHMENTS_END
  47, // 44 -> TOGGLE_SHOW_NOTIFICATION
  41, // 45 -> SET_DEVICE_NAME
  9, // 46 -> DECLINE_AGREEMENTS
  31, // 47 -> REQUEST_SETTING_PERMISSIONS
  16, // 48 -> ESTABLISH_CONNECTION
  11, // 49 -> DEVICE_SETTINGS
};

const std::string& EventType_Name(
    EventType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EventType_entries,
          EventType_entries_by_number,
          50, EventType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EventType_entries,
      EventType_entries_by_number,
      50, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EventType_strings[idx].get();
}
bool EventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EventType_entries, 50, name, &int_value);
  if (success) {
    *value = static_cast<EventType>(int_value);
  }
  return success;
}
bool EventCategory_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EventCategory_strings[4] = {};

static const char EventCategory_names[] =
  "RECEIVING_EVENT"
  "SENDING_EVENT"
  "SETTINGS_EVENT"
  "UNKNOWN_EVENT_CATEGORY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EventCategory_entries[] = {
  { {EventCategory_names + 0, 15}, 2 },
  { {EventCategory_names + 15, 13}, 1 },
  { {EventCategory_names + 28, 14}, 3 },
  { {EventCategory_names + 42, 22}, 0 },
};

static const int EventCategory_entries_by_number[] = {
  3, // 0 -> UNKNOWN_EVENT_CATEGORY
  1, // 1 -> SENDING_EVENT
  0, // 2 -> RECEIVING_EVENT
  2, // 3 -> SETTINGS_EVENT
};

const std::string& EventCategory_Name(
    EventCategory value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EventCategory_entries,
          EventCategory_entries_by_number,
          4, EventCategory_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EventCategory_entries,
      EventCategory_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EventCategory_strings[idx].get();
}
bool EventCategory_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventCategory* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EventCategory_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<EventCategory>(int_value);
  }
  return success;
}
bool NearbySharingStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NearbySharingStatus_strings[3] = {};

static const char NearbySharingStatus_names[] =
  "OFF"
  "ON"
  "UNKNOWN_NEARBY_SHARING_STATUS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NearbySharingStatus_entries[] = {
  { {NearbySharingStatus_names + 0, 3}, 2 },
  { {NearbySharingStatus_names + 3, 2}, 1 },
  { {NearbySharingStatus_names + 5, 29}, 0 },
};

static const int NearbySharingStatus_entries_by_number[] = {
  2, // 0 -> UNKNOWN_NEARBY_SHARING_STATUS
  1, // 1 -> ON
  0, // 2 -> OFF
};

const std::string& NearbySharingStatus_Name(
    NearbySharingStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NearbySharingStatus_entries,
          NearbySharingStatus_entries_by_number,
          3, NearbySharingStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NearbySharingStatus_entries,
      NearbySharingStatus_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NearbySharingStatus_strings[idx].get();
}
bool NearbySharingStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NearbySharingStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NearbySharingStatus_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<NearbySharingStatus>(int_value);
  }
  return success;
}
bool Visibility_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Visibility_strings[6] = {};

static const char Visibility_names[] =
  "CONTACTS_ONLY"
  "EVERYONE"
  "HIDDEN"
  "SELECTED_CONTACTS_ONLY"
  "SELF_SHARE"
  "UNKNOWN_VISIBILITY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Visibility_entries[] = {
  { {Visibility_names + 0, 13}, 1 },
  { {Visibility_names + 13, 8}, 2 },
  { {Visibility_names + 21, 6}, 4 },
  { {Visibility_names + 27, 22}, 3 },
  { {Visibility_names + 49, 10}, 5 },
  { {Visibility_names + 59, 18}, 0 },
};

static const int Visibility_entries_by_number[] = {
  5, // 0 -> UNKNOWN_VISIBILITY
  0, // 1 -> CONTACTS_ONLY
  1, // 2 -> EVERYONE
  3, // 3 -> SELECTED_CONTACTS_ONLY
  2, // 4 -> HIDDEN
  4, // 5 -> SELF_SHARE
};

const std::string& Visibility_Name(
    Visibility value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Visibility_entries,
          Visibility_entries_by_number,
          6, Visibility_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Visibility_entries,
      Visibility_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Visibility_strings[idx].get();
}
bool Visibility_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Visibility* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Visibility_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<Visibility>(int_value);
  }
  return success;
}
bool DataUsage_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DataUsage_strings[4] = {};

static const char DataUsage_names[] =
  "OFFLINE"
  "ONLINE"
  "UNKNOWN_DATA_USAGE"
  "WIFI_ONLY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DataUsage_entries[] = {
  { {DataUsage_names + 0, 7}, 3 },
  { {DataUsage_names + 7, 6}, 1 },
  { {DataUsage_names + 13, 18}, 0 },
  { {DataUsage_names + 31, 9}, 2 },
};

static const int DataUsage_entries_by_number[] = {
  2, // 0 -> UNKNOWN_DATA_USAGE
  1, // 1 -> ONLINE
  3, // 2 -> WIFI_ONLY
  0, // 3 -> OFFLINE
};

const std::string& DataUsage_Name(
    DataUsage value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DataUsage_entries,
          DataUsage_entries_by_number,
          4, DataUsage_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DataUsage_entries,
      DataUsage_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DataUsage_strings[idx].get();
}
bool DataUsage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataUsage* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DataUsage_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DataUsage>(int_value);
  }
  return success;
}
bool EstablishConnectionStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EstablishConnectionStatus_strings[4] = {};

static const char EstablishConnectionStatus_names[] =
  "CONNECTION_STATUS_CANCELLATION"
  "CONNECTION_STATUS_FAILURE"
  "CONNECTION_STATUS_SUCCESS"
  "CONNECTION_STATUS_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EstablishConnectionStatus_entries[] = {
  { {EstablishConnectionStatus_names + 0, 30}, 3 },
  { {EstablishConnectionStatus_names + 30, 25}, 2 },
  { {EstablishConnectionStatus_names + 55, 25}, 1 },
  { {EstablishConnectionStatus_names + 80, 25}, 0 },
};

static const int EstablishConnectionStatus_entries_by_number[] = {
  3, // 0 -> CONNECTION_STATUS_UNKNOWN
  2, // 1 -> CONNECTION_STATUS_SUCCESS
  1, // 2 -> CONNECTION_STATUS_FAILURE
  0, // 3 -> CONNECTION_STATUS_CANCELLATION
};

const std::string& EstablishConnectionStatus_Name(
    EstablishConnectionStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EstablishConnectionStatus_entries,
          EstablishConnectionStatus_entries_by_number,
          4, EstablishConnectionStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EstablishConnectionStatus_entries,
      EstablishConnectionStatus_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EstablishConnectionStatus_strings[idx].get();
}
bool EstablishConnectionStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EstablishConnectionStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EstablishConnectionStatus_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<EstablishConnectionStatus>(int_value);
  }
  return success;
}
bool AttachmentTransmissionStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AttachmentTransmissionStatus_strings[18] = {};

static const char AttachmentTransmissionStatus_names[] =
  "AWAITING_REMOTE_ACCEPTANCE_FAILED_ATTACHMENT"
  "CANCELED_ATTACHMENT_TRANSMISSION_STATUS"
  "COMPLETE_ATTACHMENT_TRANSMISSION_STATUS"
  "FAILED_ATTACHMENT_TRANSMISSION_STATUS"
  "FAILED_NO_PAYLOAD"
  "FAILED_NO_SHARE_TARGET_ENDPOINT"
  "FAILED_NO_TRANSFER_UPDATE_CALLBACK"
  "FAILED_NULL_CONNECTION"
  "FAILED_PAIRED_KEYHANDSHAKE"
  "FAILED_UNKNOWN_REMOTE_RESPONSE"
  "FAILED_WRITE_INTRODUCTION"
  "MEDIA_UNAVAILABLE_ATTACHMENT"
  "NOT_ENOUGH_SPACE_ATTACHMENT"
  "NO_ATTACHMENT_FOUND"
  "REJECTED_ATTACHMENT"
  "TIMED_OUT_ATTACHMENT"
  "UNKNOWN_ATTACHMENT_TRANSMISSION_STATUS"
  "UNSUPPORTED_ATTACHMENT_TYPE_ATTACHMENT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AttachmentTransmissionStatus_entries[] = {
  { {AttachmentTransmissionStatus_names + 0, 44}, 6 },
  { {AttachmentTransmissionStatus_names + 44, 39}, 2 },
  { {AttachmentTransmissionStatus_names + 83, 39}, 1 },
  { {AttachmentTransmissionStatus_names + 122, 37}, 3 },
  { {AttachmentTransmissionStatus_names + 159, 17}, 15 },
  { {AttachmentTransmissionStatus_names + 176, 31}, 12 },
  { {AttachmentTransmissionStatus_names + 207, 34}, 8 },
  { {AttachmentTransmissionStatus_names + 241, 22}, 14 },
  { {AttachmentTransmissionStatus_names + 263, 26}, 13 },
  { {AttachmentTransmissionStatus_names + 289, 30}, 17 },
  { {AttachmentTransmissionStatus_names + 319, 25}, 16 },
  { {AttachmentTransmissionStatus_names + 344, 28}, 9 },
  { {AttachmentTransmissionStatus_names + 372, 27}, 7 },
  { {AttachmentTransmissionStatus_names + 399, 19}, 11 },
  { {AttachmentTransmissionStatus_names + 418, 19}, 4 },
  { {AttachmentTransmissionStatus_names + 437, 20}, 5 },
  { {AttachmentTransmissionStatus_names + 457, 38}, 0 },
  { {AttachmentTransmissionStatus_names + 495, 38}, 10 },
};

static const int AttachmentTransmissionStatus_entries_by_number[] = {
  16, // 0 -> UNKNOWN_ATTACHMENT_TRANSMISSION_STATUS
  2, // 1 -> COMPLETE_ATTACHMENT_TRANSMISSION_STATUS
  1, // 2 -> CANCELED_ATTACHMENT_TRANSMISSION_STATUS
  3, // 3 -> FAILED_ATTACHMENT_TRANSMISSION_STATUS
  14, // 4 -> REJECTED_ATTACHMENT
  15, // 5 -> TIMED_OUT_ATTACHMENT
  0, // 6 -> AWAITING_REMOTE_ACCEPTANCE_FAILED_ATTACHMENT
  12, // 7 -> NOT_ENOUGH_SPACE_ATTACHMENT
  6, // 8 -> FAILED_NO_TRANSFER_UPDATE_CALLBACK
  11, // 9 -> MEDIA_UNAVAILABLE_ATTACHMENT
  17, // 10 -> UNSUPPORTED_ATTACHMENT_TYPE_ATTACHMENT
  13, // 11 -> NO_ATTACHMENT_FOUND
  5, // 12 -> FAILED_NO_SHARE_TARGET_ENDPOINT
  8, // 13 -> FAILED_PAIRED_KEYHANDSHAKE
  7, // 14 -> FAILED_NULL_CONNECTION
  4, // 15 -> FAILED_NO_PAYLOAD
  10, // 16 -> FAILED_WRITE_INTRODUCTION
  9, // 17 -> FAILED_UNKNOWN_REMOTE_RESPONSE
};

const std::string& AttachmentTransmissionStatus_Name(
    AttachmentTransmissionStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AttachmentTransmissionStatus_entries,
          AttachmentTransmissionStatus_entries_by_number,
          18, AttachmentTransmissionStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AttachmentTransmissionStatus_entries,
      AttachmentTransmissionStatus_entries_by_number,
      18, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AttachmentTransmissionStatus_strings[idx].get();
}
bool AttachmentTransmissionStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AttachmentTransmissionStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AttachmentTransmissionStatus_entries, 18, name, &int_value);
  if (success) {
    *value = static_cast<AttachmentTransmissionStatus>(int_value);
  }
  return success;
}
bool ProcessReceivedAttachmentsStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ProcessReceivedAttachmentsStatus_strings[6] = {};

static const char ProcessReceivedAttachmentsStatus_names[] =
  "PROCESSING_STATUS_COMPLETE_PROCESSING_ATTACHMENTS"
  "PROCESSING_STATUS_FAILED_MOVING_FILES"
  "PROCESSING_STATUS_FAILED_RECEIVING_APK"
  "PROCESSING_STATUS_FAILED_RECEIVING_TEXT"
  "PROCESSING_STATUS_FAILED_RECEIVING_WIFI_CREDENTIALS"
  "PROCESSING_STATUS_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ProcessReceivedAttachmentsStatus_entries[] = {
  { {ProcessReceivedAttachmentsStatus_names + 0, 49}, 1 },
  { {ProcessReceivedAttachmentsStatus_names + 49, 37}, 2 },
  { {ProcessReceivedAttachmentsStatus_names + 86, 38}, 3 },
  { {ProcessReceivedAttachmentsStatus_names + 124, 39}, 4 },
  { {ProcessReceivedAttachmentsStatus_names + 163, 51}, 5 },
  { {ProcessReceivedAttachmentsStatus_names + 214, 25}, 0 },
};

static const int ProcessReceivedAttachmentsStatus_entries_by_number[] = {
  5, // 0 -> PROCESSING_STATUS_UNKNOWN
  0, // 1 -> PROCESSING_STATUS_COMPLETE_PROCESSING_ATTACHMENTS
  1, // 2 -> PROCESSING_STATUS_FAILED_MOVING_FILES
  2, // 3 -> PROCESSING_STATUS_FAILED_RECEIVING_APK
  3, // 4 -> PROCESSING_STATUS_FAILED_RECEIVING_TEXT
  4, // 5 -> PROCESSING_STATUS_FAILED_RECEIVING_WIFI_CREDENTIALS
};

const std::string& ProcessReceivedAttachmentsStatus_Name(
    ProcessReceivedAttachmentsStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ProcessReceivedAttachmentsStatus_entries,
          ProcessReceivedAttachmentsStatus_entries_by_number,
          6, ProcessReceivedAttachmentsStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ProcessReceivedAttachmentsStatus_entries,
      ProcessReceivedAttachmentsStatus_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ProcessReceivedAttachmentsStatus_strings[idx].get();
}
bool ProcessReceivedAttachmentsStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProcessReceivedAttachmentsStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ProcessReceivedAttachmentsStatus_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<ProcessReceivedAttachmentsStatus>(int_value);
  }
  return success;
}
bool SessionStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SessionStatus_strings[3] = {};

static const char SessionStatus_names[] =
  "FAILED_SESSION_STATUS"
  "SUCCEEDED_SESSION_STATUS"
  "UNKNOWN_SESSION_STATUS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SessionStatus_entries[] = {
  { {SessionStatus_names + 0, 21}, 2 },
  { {SessionStatus_names + 21, 24}, 1 },
  { {SessionStatus_names + 45, 22}, 0 },
};

static const int SessionStatus_entries_by_number[] = {
  2, // 0 -> UNKNOWN_SESSION_STATUS
  1, // 1 -> SUCCEEDED_SESSION_STATUS
  0, // 2 -> FAILED_SESSION_STATUS
};

const std::string& SessionStatus_Name(
    SessionStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SessionStatus_entries,
          SessionStatus_entries_by_number,
          3, SessionStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SessionStatus_entries,
      SessionStatus_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SessionStatus_strings[idx].get();
}
bool SessionStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SessionStatus_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<SessionStatus>(int_value);
  }
  return success;
}
bool ResponseToIntroduction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ResponseToIntroduction_strings[4] = {};

static const char ResponseToIntroduction_names[] =
  "ACCEPT_INTRODUCTION"
  "FAIL_INTRODUCTION"
  "REJECT_INTRODUCTION"
  "UNKNOWN_RESPONSE_TO_INTRODUCTION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ResponseToIntroduction_entries[] = {
  { {ResponseToIntroduction_names + 0, 19}, 1 },
  { {ResponseToIntroduction_names + 19, 17}, 3 },
  { {ResponseToIntroduction_names + 36, 19}, 2 },
  { {ResponseToIntroduction_names + 55, 32}, 0 },
};

static const int ResponseToIntroduction_entries_by_number[] = {
  3, // 0 -> UNKNOWN_RESPONSE_TO_INTRODUCTION
  0, // 1 -> ACCEPT_INTRODUCTION
  2, // 2 -> REJECT_INTRODUCTION
  1, // 3 -> FAIL_INTRODUCTION
};

const std::string& ResponseToIntroduction_Name(
    ResponseToIntroduction value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ResponseToIntroduction_entries,
          ResponseToIntroduction_entries_by_number,
          4, ResponseToIntroduction_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ResponseToIntroduction_entries,
      ResponseToIntroduction_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ResponseToIntroduction_strings[idx].get();
}
bool ResponseToIntroduction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResponseToIntroduction* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ResponseToIntroduction_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ResponseToIntroduction>(int_value);
  }
  return success;
}
bool DeviceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceType_strings[4] = {};

static const char DeviceType_names[] =
  "LAPTOP"
  "PHONE"
  "TABLET"
  "UNKNOWN_DEVICE_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceType_entries[] = {
  { {DeviceType_names + 0, 6}, 3 },
  { {DeviceType_names + 6, 5}, 1 },
  { {DeviceType_names + 11, 6}, 2 },
  { {DeviceType_names + 17, 19}, 0 },
};

static const int DeviceType_entries_by_number[] = {
  3, // 0 -> UNKNOWN_DEVICE_TYPE
  1, // 1 -> PHONE
  2, // 2 -> TABLET
  0, // 3 -> LAPTOP
};

const std::string& DeviceType_Name(
    DeviceType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceType_entries,
          DeviceType_entries_by_number,
          4, DeviceType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceType_entries,
      DeviceType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceType_strings[idx].get();
}
bool DeviceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DeviceType>(int_value);
  }
  return success;
}
bool OSType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> OSType_strings[4] = {};

static const char OSType_names[] =
  "ANDROID"
  "CHROME_OS"
  "IOS"
  "UNKNOWN_OS_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry OSType_entries[] = {
  { {OSType_names + 0, 7}, 1 },
  { {OSType_names + 7, 9}, 2 },
  { {OSType_names + 16, 3}, 3 },
  { {OSType_names + 19, 15}, 0 },
};

static const int OSType_entries_by_number[] = {
  3, // 0 -> UNKNOWN_OS_TYPE
  0, // 1 -> ANDROID
  1, // 2 -> CHROME_OS
  2, // 3 -> IOS
};

const std::string& OSType_Name(
    OSType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          OSType_entries,
          OSType_entries_by_number,
          4, OSType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      OSType_entries,
      OSType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     OSType_strings[idx].get();
}
bool OSType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OSType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      OSType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<OSType>(int_value);
  }
  return success;
}
bool DeviceRelationship_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceRelationship_strings[4] = {};

static const char DeviceRelationship_names[] =
  "IS_CONTACT"
  "IS_SELF"
  "IS_STRANGER"
  "UNKNOWN_DEVICE_RELATIONSHIP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceRelationship_entries[] = {
  { {DeviceRelationship_names + 0, 10}, 2 },
  { {DeviceRelationship_names + 10, 7}, 1 },
  { {DeviceRelationship_names + 17, 11}, 3 },
  { {DeviceRelationship_names + 28, 27}, 0 },
};

static const int DeviceRelationship_entries_by_number[] = {
  3, // 0 -> UNKNOWN_DEVICE_RELATIONSHIP
  1, // 1 -> IS_SELF
  0, // 2 -> IS_CONTACT
  2, // 3 -> IS_STRANGER
};

const std::string& DeviceRelationship_Name(
    DeviceRelationship value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceRelationship_entries,
          DeviceRelationship_entries_by_number,
          4, DeviceRelationship_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceRelationship_entries,
      DeviceRelationship_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceRelationship_strings[idx].get();
}
bool DeviceRelationship_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceRelationship* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceRelationship_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DeviceRelationship>(int_value);
  }
  return success;
}
bool LogSource_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LogSource_strings[6] = {};

static const char LogSource_names[] =
  "BETA_TESTER_DEVICES"
  "DEBUG_DEVICES"
  "INTERNAL_DEVICES"
  "LAB_DEVICES"
  "OEM_DEVICES"
  "UNSPECIFIED_SOURCE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LogSource_entries[] = {
  { {LogSource_names + 0, 19}, 3 },
  { {LogSource_names + 19, 13}, 5 },
  { {LogSource_names + 32, 16}, 2 },
  { {LogSource_names + 48, 11}, 1 },
  { {LogSource_names + 59, 11}, 4 },
  { {LogSource_names + 70, 18}, 0 },
};

static const int LogSource_entries_by_number[] = {
  5, // 0 -> UNSPECIFIED_SOURCE
  3, // 1 -> LAB_DEVICES
  2, // 2 -> INTERNAL_DEVICES
  0, // 3 -> BETA_TESTER_DEVICES
  4, // 4 -> OEM_DEVICES
  1, // 5 -> DEBUG_DEVICES
};

const std::string& LogSource_Name(
    LogSource value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LogSource_entries,
          LogSource_entries_by_number,
          6, LogSource_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LogSource_entries,
      LogSource_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LogSource_strings[idx].get();
}
bool LogSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LogSource* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LogSource_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<LogSource>(int_value);
  }
  return success;
}
bool ServerActionName_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ServerActionName_strings[8] = {};

static const char ServerActionName_names[] =
  "CHECK_REACHABILITY"
  "DOWNLOAD_CERTIFICATES"
  "DOWNLOAD_SENDER_CERTIFICATES"
  "UNKNOWN_SERVER_ACTION"
  "UPDATE_DEVICE_NAME"
  "UPLOAD_CERTIFICATES"
  "UPLOAD_CONTACTS"
  "UPLOAD_SENDER_CERTIFICATES";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServerActionName_entries[] = {
  { {ServerActionName_names + 0, 18}, 3 },
  { {ServerActionName_names + 18, 21}, 2 },
  { {ServerActionName_names + 39, 28}, 7 },
  { {ServerActionName_names + 67, 21}, 0 },
  { {ServerActionName_names + 88, 18}, 5 },
  { {ServerActionName_names + 106, 19}, 1 },
  { {ServerActionName_names + 125, 15}, 4 },
  { {ServerActionName_names + 140, 26}, 6 },
};

static const int ServerActionName_entries_by_number[] = {
  3, // 0 -> UNKNOWN_SERVER_ACTION
  5, // 1 -> UPLOAD_CERTIFICATES
  1, // 2 -> DOWNLOAD_CERTIFICATES
  0, // 3 -> CHECK_REACHABILITY
  6, // 4 -> UPLOAD_CONTACTS
  4, // 5 -> UPDATE_DEVICE_NAME
  7, // 6 -> UPLOAD_SENDER_CERTIFICATES
  2, // 7 -> DOWNLOAD_SENDER_CERTIFICATES
};

const std::string& ServerActionName_Name(
    ServerActionName value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ServerActionName_entries,
          ServerActionName_entries_by_number,
          8, ServerActionName_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ServerActionName_entries,
      ServerActionName_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ServerActionName_strings[idx].get();
}
bool ServerActionName_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServerActionName* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ServerActionName_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<ServerActionName>(int_value);
  }
  return success;
}
bool ServerResponseState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ServerResponseState_strings[10] = {};

static const char ServerResponseState_names[] =
  "SERVER_RESPONSE_GOOGLE_AUTH_FAILURE"
  "SERVER_RESPONSE_STATUS_DEADLINE_EXCEEDED"
  "SERVER_RESPONSE_STATUS_INVALID_ARGUMENT"
  "SERVER_RESPONSE_STATUS_OTHER_FAILURE"
  "SERVER_RESPONSE_STATUS_PERMISSION_DENIED"
  "SERVER_RESPONSE_STATUS_UNAUTHENTICATED"
  "SERVER_RESPONSE_STATUS_UNAVAILABLE"
  "SERVER_RESPONSE_SUCCESS"
  "SERVER_RESPONSE_UNKNOWN_FAILURE"
  "UNKNOWN_SERVER_RESPONSE_STATE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServerResponseState_entries[] = {
  { {ServerResponseState_names + 0, 35}, 8 },
  { {ServerResponseState_names + 35, 40}, 4 },
  { {ServerResponseState_names + 75, 39}, 9 },
  { {ServerResponseState_names + 114, 36}, 3 },
  { {ServerResponseState_names + 150, 40}, 5 },
  { {ServerResponseState_names + 190, 38}, 7 },
  { {ServerResponseState_names + 228, 34}, 6 },
  { {ServerResponseState_names + 262, 23}, 1 },
  { {ServerResponseState_names + 285, 31}, 2 },
  { {ServerResponseState_names + 316, 29}, 0 },
};

static const int ServerResponseState_entries_by_number[] = {
  9, // 0 -> UNKNOWN_SERVER_RESPONSE_STATE
  7, // 1 -> SERVER_RESPONSE_SUCCESS
  8, // 2 -> SERVER_RESPONSE_UNKNOWN_FAILURE
  3, // 3 -> SERVER_RESPONSE_STATUS_OTHER_FAILURE
  1, // 4 -> SERVER_RESPONSE_STATUS_DEADLINE_EXCEEDED
  4, // 5 -> SERVER_RESPONSE_STATUS_PERMISSION_DENIED
  6, // 6 -> SERVER_RESPONSE_STATUS_UNAVAILABLE
  5, // 7 -> SERVER_RESPONSE_STATUS_UNAUTHENTICATED
  0, // 8 -> SERVER_RESPONSE_GOOGLE_AUTH_FAILURE
  2, // 9 -> SERVER_RESPONSE_STATUS_INVALID_ARGUMENT
};

const std::string& ServerResponseState_Name(
    ServerResponseState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ServerResponseState_entries,
          ServerResponseState_entries_by_number,
          10, ServerResponseState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ServerResponseState_entries,
      ServerResponseState_entries_by_number,
      10, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ServerResponseState_strings[idx].get();
}
bool ServerResponseState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServerResponseState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ServerResponseState_entries, 10, name, &int_value);
  if (success) {
    *value = static_cast<ServerResponseState>(int_value);
  }
  return success;
}
bool ScanType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ScanType_strings[4] = {};

static const char ScanType_names[] =
  "DIRECT_SHARE_SCAN"
  "FOREGROUND_RETRY_SCAN"
  "FOREGROUND_SCAN"
  "UNKNOWN_SCAN_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ScanType_entries[] = {
  { {ScanType_names + 0, 17}, 3 },
  { {ScanType_names + 17, 21}, 2 },
  { {ScanType_names + 38, 15}, 1 },
  { {ScanType_names + 53, 17}, 0 },
};

static const int ScanType_entries_by_number[] = {
  3, // 0 -> UNKNOWN_SCAN_TYPE
  2, // 1 -> FOREGROUND_SCAN
  1, // 2 -> FOREGROUND_RETRY_SCAN
  0, // 3 -> DIRECT_SHARE_SCAN
};

const std::string& ScanType_Name(
    ScanType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ScanType_entries,
          ScanType_entries_by_number,
          4, ScanType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ScanType_entries,
      ScanType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ScanType_strings[idx].get();
}
bool ScanType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ScanType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ScanType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ScanType>(int_value);
  }
  return success;
}
bool ActivityName_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ActivityName_strings[9] = {};

static const char ActivityName_names[] =
  "CONSENTS_ACTIVITY"
  "DEVICE_VISIBILITY_ACTIVITY"
  "RECEIVE_SURFACE_ACTIVITY"
  "SETTINGS_ACTIVITY"
  "SETUP_ACTIVITY"
  "SET_DATA_USAGE_DIALOG"
  "SET_DEVICE_NAME_DIALOG"
  "SHARE_SHEET_ACTIVITY"
  "UNKNOWN_ACTIVITY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ActivityName_entries[] = {
  { {ActivityName_names + 0, 17}, 6 },
  { {ActivityName_names + 17, 26}, 5 },
  { {ActivityName_names + 43, 24}, 3 },
  { {ActivityName_names + 67, 17}, 2 },
  { {ActivityName_names + 84, 14}, 4 },
  { {ActivityName_names + 98, 21}, 8 },
  { {ActivityName_names + 119, 22}, 7 },
  { {ActivityName_names + 141, 20}, 1 },
  { {ActivityName_names + 161, 16}, 0 },
};

static const int ActivityName_entries_by_number[] = {
  8, // 0 -> UNKNOWN_ACTIVITY
  7, // 1 -> SHARE_SHEET_ACTIVITY
  3, // 2 -> SETTINGS_ACTIVITY
  2, // 3 -> RECEIVE_SURFACE_ACTIVITY
  4, // 4 -> SETUP_ACTIVITY
  1, // 5 -> DEVICE_VISIBILITY_ACTIVITY
  0, // 6 -> CONSENTS_ACTIVITY
  6, // 7 -> SET_DEVICE_NAME_DIALOG
  5, // 8 -> SET_DATA_USAGE_DIALOG
};

const std::string& ActivityName_Name(
    ActivityName value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ActivityName_entries,
          ActivityName_entries_by_number,
          9, ActivityName_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ActivityName_entries,
      ActivityName_entries_by_number,
      9, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ActivityName_strings[idx].get();
}
bool ActivityName_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActivityName* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ActivityName_entries, 9, name, &int_value);
  if (success) {
    *value = static_cast<ActivityName>(int_value);
  }
  return success;
}
bool ConsentType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ConsentType_strings[3] = {};

static const char ConsentType_names[] =
  "CONSENT_TYPE_C11N"
  "CONSENT_TYPE_DEVICE_CONTACT"
  "CONSENT_TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ConsentType_entries[] = {
  { {ConsentType_names + 0, 17}, 1 },
  { {ConsentType_names + 17, 27}, 2 },
  { {ConsentType_names + 44, 20}, 0 },
};

static const int ConsentType_entries_by_number[] = {
  2, // 0 -> CONSENT_TYPE_UNKNOWN
  0, // 1 -> CONSENT_TYPE_C11N
  1, // 2 -> CONSENT_TYPE_DEVICE_CONTACT
};

const std::string& ConsentType_Name(
    ConsentType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ConsentType_entries,
          ConsentType_entries_by_number,
          3, ConsentType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ConsentType_entries,
      ConsentType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ConsentType_strings[idx].get();
}
bool ConsentType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConsentType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ConsentType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ConsentType>(int_value);
  }
  return success;
}
bool ConsentAcceptanceStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ConsentAcceptanceStatus_strings[4] = {};

static const char ConsentAcceptanceStatus_names[] =
  "CONSENT_ACCEPTED"
  "CONSENT_DECLINED"
  "CONSENT_UNABLE_TO_ENABLE"
  "CONSENT_UNKNOWN_ACCEPT_STATUS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ConsentAcceptanceStatus_entries[] = {
  { {ConsentAcceptanceStatus_names + 0, 16}, 1 },
  { {ConsentAcceptanceStatus_names + 16, 16}, 2 },
  { {ConsentAcceptanceStatus_names + 32, 24}, 3 },
  { {ConsentAcceptanceStatus_names + 56, 29}, 0 },
};

static const int ConsentAcceptanceStatus_entries_by_number[] = {
  3, // 0 -> CONSENT_UNKNOWN_ACCEPT_STATUS
  0, // 1 -> CONSENT_ACCEPTED
  1, // 2 -> CONSENT_DECLINED
  2, // 3 -> CONSENT_UNABLE_TO_ENABLE
};

const std::string& ConsentAcceptanceStatus_Name(
    ConsentAcceptanceStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ConsentAcceptanceStatus_entries,
          ConsentAcceptanceStatus_entries_by_number,
          4, ConsentAcceptanceStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ConsentAcceptanceStatus_entries,
      ConsentAcceptanceStatus_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ConsentAcceptanceStatus_strings[idx].get();
}
bool ConsentAcceptanceStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConsentAcceptanceStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ConsentAcceptanceStatus_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ConsentAcceptanceStatus>(int_value);
  }
  return success;
}
bool ApkSource_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ApkSource_strings[3] = {};

static const char ApkSource_names[] =
  "APK_FROM_SD_CARD"
  "INSTALLED_APP"
  "UNKNOWN_APK_SOURCE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ApkSource_entries[] = {
  { {ApkSource_names + 0, 16}, 1 },
  { {ApkSource_names + 16, 13}, 2 },
  { {ApkSource_names + 29, 18}, 0 },
};

static const int ApkSource_entries_by_number[] = {
  2, // 0 -> UNKNOWN_APK_SOURCE
  0, // 1 -> APK_FROM_SD_CARD
  1, // 2 -> INSTALLED_APP
};

const std::string& ApkSource_Name(
    ApkSource value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ApkSource_entries,
          ApkSource_entries_by_number,
          3, ApkSource_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ApkSource_entries,
      ApkSource_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ApkSource_strings[idx].get();
}
bool ApkSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ApkSource* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ApkSource_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ApkSource>(int_value);
  }
  return success;
}
bool InstallAPKStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> InstallAPKStatus_strings[3] = {};

static const char InstallAPKStatus_names[] =
  "FAIL_INSTALLATION"
  "SUCCESS_INSTALLATION"
  "UNKNOWN_INSTALL_APK_STATUS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry InstallAPKStatus_entries[] = {
  { {InstallAPKStatus_names + 0, 17}, 1 },
  { {InstallAPKStatus_names + 17, 20}, 2 },
  { {InstallAPKStatus_names + 37, 26}, 0 },
};

static const int InstallAPKStatus_entries_by_number[] = {
  2, // 0 -> UNKNOWN_INSTALL_APK_STATUS
  0, // 1 -> FAIL_INSTALLATION
  1, // 2 -> SUCCESS_INSTALLATION
};

const std::string& InstallAPKStatus_Name(
    InstallAPKStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          InstallAPKStatus_entries,
          InstallAPKStatus_entries_by_number,
          3, InstallAPKStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      InstallAPKStatus_entries,
      InstallAPKStatus_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     InstallAPKStatus_strings[idx].get();
}
bool InstallAPKStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InstallAPKStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      InstallAPKStatus_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<InstallAPKStatus>(int_value);
  }
  return success;
}
bool VerifyAPKStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> VerifyAPKStatus_strings[4] = {};

static const char VerifyAPKStatus_names[] =
  "ALREADY_INSTALLED"
  "INSTALLABLE"
  "NOT_INSTALLABLE"
  "UNKNOWN_VERIFY_APK_STATUS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry VerifyAPKStatus_entries[] = {
  { {VerifyAPKStatus_names + 0, 17}, 3 },
  { {VerifyAPKStatus_names + 17, 11}, 2 },
  { {VerifyAPKStatus_names + 28, 15}, 1 },
  { {VerifyAPKStatus_names + 43, 25}, 0 },
};

static const int VerifyAPKStatus_entries_by_number[] = {
  3, // 0 -> UNKNOWN_VERIFY_APK_STATUS
  2, // 1 -> NOT_INSTALLABLE
  1, // 2 -> INSTALLABLE
  0, // 3 -> ALREADY_INSTALLED
};

const std::string& VerifyAPKStatus_Name(
    VerifyAPKStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          VerifyAPKStatus_entries,
          VerifyAPKStatus_entries_by_number,
          4, VerifyAPKStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      VerifyAPKStatus_entries,
      VerifyAPKStatus_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     VerifyAPKStatus_strings[idx].get();
}
bool VerifyAPKStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VerifyAPKStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      VerifyAPKStatus_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<VerifyAPKStatus>(int_value);
  }
  return success;
}
bool ShowNotificationStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ShowNotificationStatus_strings[3] = {};

static const char ShowNotificationStatus_names[] =
  "NOT_SHOW"
  "SHOW"
  "UNKNOWN_SHOW_NOTIFICATION_STATUS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ShowNotificationStatus_entries[] = {
  { {ShowNotificationStatus_names + 0, 8}, 2 },
  { {ShowNotificationStatus_names + 8, 4}, 1 },
  { {ShowNotificationStatus_names + 12, 32}, 0 },
};

static const int ShowNotificationStatus_entries_by_number[] = {
  2, // 0 -> UNKNOWN_SHOW_NOTIFICATION_STATUS
  1, // 1 -> SHOW
  0, // 2 -> NOT_SHOW
};

const std::string& ShowNotificationStatus_Name(
    ShowNotificationStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ShowNotificationStatus_entries,
          ShowNotificationStatus_entries_by_number,
          3, ShowNotificationStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ShowNotificationStatus_entries,
      ShowNotificationStatus_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ShowNotificationStatus_strings[idx].get();
}
bool ShowNotificationStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShowNotificationStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ShowNotificationStatus_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ShowNotificationStatus>(int_value);
  }
  return success;
}
bool PermissionRequestResult_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PermissionRequestResult_strings[4] = {};

static const char PermissionRequestResult_names[] =
  "PERMISSION_GRANTED"
  "PERMISSION_REJECTED"
  "PERMISSION_UNABLE_TO_GRANT"
  "PERMISSION_UNKNOWN_REQUEST_RESULT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PermissionRequestResult_entries[] = {
  { {PermissionRequestResult_names + 0, 18}, 1 },
  { {PermissionRequestResult_names + 18, 19}, 2 },
  { {PermissionRequestResult_names + 37, 26}, 3 },
  { {PermissionRequestResult_names + 63, 33}, 0 },
};

static const int PermissionRequestResult_entries_by_number[] = {
  3, // 0 -> PERMISSION_UNKNOWN_REQUEST_RESULT
  0, // 1 -> PERMISSION_GRANTED
  1, // 2 -> PERMISSION_REJECTED
  2, // 3 -> PERMISSION_UNABLE_TO_GRANT
};

const std::string& PermissionRequestResult_Name(
    PermissionRequestResult value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PermissionRequestResult_entries,
          PermissionRequestResult_entries_by_number,
          4, PermissionRequestResult_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PermissionRequestResult_entries,
      PermissionRequestResult_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PermissionRequestResult_strings[idx].get();
}
bool PermissionRequestResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PermissionRequestResult* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PermissionRequestResult_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<PermissionRequestResult>(int_value);
  }
  return success;
}
bool PermissionRequestType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PermissionRequestType_strings[5] = {};

static const char PermissionRequestType_names[] =
  "PERMISSION_AIRPLANE_MODE_OFF"
  "PERMISSION_BLUETOOTH"
  "PERMISSION_LOCATION"
  "PERMISSION_UNKNOWN_TYPE"
  "PERMISSION_WIFI";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PermissionRequestType_entries[] = {
  { {PermissionRequestType_names + 0, 28}, 1 },
  { {PermissionRequestType_names + 28, 20}, 3 },
  { {PermissionRequestType_names + 48, 19}, 4 },
  { {PermissionRequestType_names + 67, 23}, 0 },
  { {PermissionRequestType_names + 90, 15}, 2 },
};

static const int PermissionRequestType_entries_by_number[] = {
  3, // 0 -> PERMISSION_UNKNOWN_TYPE
  0, // 1 -> PERMISSION_AIRPLANE_MODE_OFF
  4, // 2 -> PERMISSION_WIFI
  1, // 3 -> PERMISSION_BLUETOOTH
  2, // 4 -> PERMISSION_LOCATION
};

const std::string& PermissionRequestType_Name(
    PermissionRequestType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PermissionRequestType_entries,
          PermissionRequestType_entries_by_number,
          5, PermissionRequestType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PermissionRequestType_entries,
      PermissionRequestType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PermissionRequestType_strings[idx].get();
}
bool PermissionRequestType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PermissionRequestType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PermissionRequestType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<PermissionRequestType>(int_value);
  }
  return success;
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace sharing
}  // namespace proto
}  // namespace nearby
}  // namespace location
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
