// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/connections_enums.proto

#include "proto/connections_enums.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace location {
namespace nearby {
namespace proto {
namespace connections {
}  // namespace connections
}  // namespace proto
}  // namespace nearby
}  // namespace location
namespace location {
namespace nearby {
namespace proto {
namespace connections {
bool EventType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EventType_strings[7] = {};

static const char EventType_names[] =
  "CLIENT_SESSION"
  "ERROR_CODE"
  "START_CLIENT_SESSION"
  "START_STRATEGY_SESSION"
  "STOP_CLIENT_SESSION"
  "STOP_STRATEGY_SESSION"
  "UNKNOWN_EVENT_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EventType_entries[] = {
  { {EventType_names + 0, 14}, 1 },
  { {EventType_names + 14, 10}, 6 },
  { {EventType_names + 24, 20}, 2 },
  { {EventType_names + 44, 22}, 4 },
  { {EventType_names + 66, 19}, 3 },
  { {EventType_names + 85, 21}, 5 },
  { {EventType_names + 106, 18}, 0 },
};

static const int EventType_entries_by_number[] = {
  6, // 0 -> UNKNOWN_EVENT_TYPE
  0, // 1 -> CLIENT_SESSION
  2, // 2 -> START_CLIENT_SESSION
  4, // 3 -> STOP_CLIENT_SESSION
  3, // 4 -> START_STRATEGY_SESSION
  5, // 5 -> STOP_STRATEGY_SESSION
  1, // 6 -> ERROR_CODE
};

const std::string& EventType_Name(
    EventType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EventType_entries,
          EventType_entries_by_number,
          7, EventType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EventType_entries,
      EventType_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EventType_strings[idx].get();
}
bool EventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EventType_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<EventType>(int_value);
  }
  return success;
}
bool ConnectionsStrategy_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ConnectionsStrategy_strings[6] = {};

static const char ConnectionsStrategy_names[] =
  "MDNS_LOCAL_WIFI"
  "P2P_CLUSTER"
  "P2P_POINT_TO_POINT"
  "P2P_STAR"
  "RADIO_P2P"
  "UNKNOWN_STRATEGY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ConnectionsStrategy_entries[] = {
  { {ConnectionsStrategy_names + 0, 15}, 1 },
  { {ConnectionsStrategy_names + 15, 11}, 3 },
  { {ConnectionsStrategy_names + 26, 18}, 5 },
  { {ConnectionsStrategy_names + 44, 8}, 4 },
  { {ConnectionsStrategy_names + 52, 9}, 2 },
  { {ConnectionsStrategy_names + 61, 16}, 0 },
};

static const int ConnectionsStrategy_entries_by_number[] = {
  5, // 0 -> UNKNOWN_STRATEGY
  0, // 1 -> MDNS_LOCAL_WIFI
  4, // 2 -> RADIO_P2P
  1, // 3 -> P2P_CLUSTER
  3, // 4 -> P2P_STAR
  2, // 5 -> P2P_POINT_TO_POINT
};

const std::string& ConnectionsStrategy_Name(
    ConnectionsStrategy value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ConnectionsStrategy_entries,
          ConnectionsStrategy_entries_by_number,
          6, ConnectionsStrategy_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ConnectionsStrategy_entries,
      ConnectionsStrategy_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ConnectionsStrategy_strings[idx].get();
}
bool ConnectionsStrategy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionsStrategy* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ConnectionsStrategy_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<ConnectionsStrategy>(int_value);
  }
  return success;
}
bool SessionRole_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SessionRole_strings[3] = {};

static const char SessionRole_names[] =
  "ADVERTISER"
  "DISCOVERER"
  "UNKNOWN_SESSION_ROLE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SessionRole_entries[] = {
  { {SessionRole_names + 0, 10}, 1 },
  { {SessionRole_names + 10, 10}, 2 },
  { {SessionRole_names + 20, 20}, 0 },
};

static const int SessionRole_entries_by_number[] = {
  2, // 0 -> UNKNOWN_SESSION_ROLE
  0, // 1 -> ADVERTISER
  1, // 2 -> DISCOVERER
};

const std::string& SessionRole_Name(
    SessionRole value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SessionRole_entries,
          SessionRole_entries_by_number,
          3, SessionRole_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SessionRole_entries,
      SessionRole_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SessionRole_strings[idx].get();
}
bool SessionRole_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionRole* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SessionRole_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<SessionRole>(int_value);
  }
  return success;
}
bool Medium_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Medium_strings[11] = {};

static const char Medium_names[] =
  "BLE"
  "BLE_L2CAP"
  "BLUETOOTH"
  "MDNS"
  "NFC"
  "UNKNOWN_MEDIUM"
  "WEB_RTC"
  "WIFI_AWARE"
  "WIFI_DIRECT"
  "WIFI_HOTSPOT"
  "WIFI_LAN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Medium_entries[] = {
  { {Medium_names + 0, 3}, 4 },
  { {Medium_names + 3, 9}, 10 },
  { {Medium_names + 12, 9}, 2 },
  { {Medium_names + 21, 4}, 1 },
  { {Medium_names + 25, 3}, 7 },
  { {Medium_names + 28, 14}, 0 },
  { {Medium_names + 42, 7}, 9 },
  { {Medium_names + 49, 10}, 6 },
  { {Medium_names + 59, 11}, 8 },
  { {Medium_names + 70, 12}, 3 },
  { {Medium_names + 82, 8}, 5 },
};

static const int Medium_entries_by_number[] = {
  5, // 0 -> UNKNOWN_MEDIUM
  3, // 1 -> MDNS
  2, // 2 -> BLUETOOTH
  9, // 3 -> WIFI_HOTSPOT
  0, // 4 -> BLE
  10, // 5 -> WIFI_LAN
  7, // 6 -> WIFI_AWARE
  4, // 7 -> NFC
  8, // 8 -> WIFI_DIRECT
  6, // 9 -> WEB_RTC
  1, // 10 -> BLE_L2CAP
};

const std::string& Medium_Name(
    Medium value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Medium_entries,
          Medium_entries_by_number,
          11, Medium_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Medium_entries,
      Medium_entries_by_number,
      11, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Medium_strings[idx].get();
}
bool Medium_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Medium* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Medium_entries, 11, name, &int_value);
  if (success) {
    *value = static_cast<Medium>(int_value);
  }
  return success;
}
bool ConnectionTechnology_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ConnectionTechnology_strings[12] = {};

static const char ConnectionTechnology_names[] =
  "CONNECTION_TECHNOLOGY_BLE_GATT"
  "CONNECTION_TECHNOLOGY_BLE_L2CAP"
  "CONNECTION_TECHNOLOGY_HOTSPOT_DIRECT"
  "CONNECTION_TECHNOLOGY_HOTSPOT_LOCALONLY"
  "CONNECTION_TECHNOLOGY_HOTSPOT_SOFTAP"
  "CONNECTION_TECHNOLOGY_UNKNOWN_TECHNOLOGY"
  "CONNECTION_TECHNOLOGY_WEBRTC_ADAPTER_TYPE_ANY"
  "CONNECTION_TECHNOLOGY_WEBRTC_ETHERNET"
  "CONNECTION_TECHNOLOGY_WEBRTC_LOOPBACK"
  "CONNECTION_TECHNOLOGY_WEBRTC_MOBILE"
  "CONNECTION_TECHNOLOGY_WEBRTC_VPN"
  "CONNECTION_TECHNOLOGY_WEBRTC_WIFI";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ConnectionTechnology_entries[] = {
  { {ConnectionTechnology_names + 0, 30}, 1 },
  { {ConnectionTechnology_names + 30, 31}, 2 },
  { {ConnectionTechnology_names + 61, 36}, 3 },
  { {ConnectionTechnology_names + 97, 39}, 4 },
  { {ConnectionTechnology_names + 136, 36}, 5 },
  { {ConnectionTechnology_names + 172, 40}, 0 },
  { {ConnectionTechnology_names + 212, 45}, 11 },
  { {ConnectionTechnology_names + 257, 37}, 8 },
  { {ConnectionTechnology_names + 294, 37}, 10 },
  { {ConnectionTechnology_names + 331, 35}, 7 },
  { {ConnectionTechnology_names + 366, 32}, 9 },
  { {ConnectionTechnology_names + 398, 33}, 6 },
};

static const int ConnectionTechnology_entries_by_number[] = {
  5, // 0 -> CONNECTION_TECHNOLOGY_UNKNOWN_TECHNOLOGY
  0, // 1 -> CONNECTION_TECHNOLOGY_BLE_GATT
  1, // 2 -> CONNECTION_TECHNOLOGY_BLE_L2CAP
  2, // 3 -> CONNECTION_TECHNOLOGY_HOTSPOT_DIRECT
  3, // 4 -> CONNECTION_TECHNOLOGY_HOTSPOT_LOCALONLY
  4, // 5 -> CONNECTION_TECHNOLOGY_HOTSPOT_SOFTAP
  11, // 6 -> CONNECTION_TECHNOLOGY_WEBRTC_WIFI
  9, // 7 -> CONNECTION_TECHNOLOGY_WEBRTC_MOBILE
  7, // 8 -> CONNECTION_TECHNOLOGY_WEBRTC_ETHERNET
  10, // 9 -> CONNECTION_TECHNOLOGY_WEBRTC_VPN
  8, // 10 -> CONNECTION_TECHNOLOGY_WEBRTC_LOOPBACK
  6, // 11 -> CONNECTION_TECHNOLOGY_WEBRTC_ADAPTER_TYPE_ANY
};

const std::string& ConnectionTechnology_Name(
    ConnectionTechnology value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ConnectionTechnology_entries,
          ConnectionTechnology_entries_by_number,
          12, ConnectionTechnology_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ConnectionTechnology_entries,
      ConnectionTechnology_entries_by_number,
      12, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ConnectionTechnology_strings[idx].get();
}
bool ConnectionTechnology_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionTechnology* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ConnectionTechnology_entries, 12, name, &int_value);
  if (success) {
    *value = static_cast<ConnectionTechnology>(int_value);
  }
  return success;
}
bool ConnectionBand_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ConnectionBand_strings[8] = {};

static const char ConnectionBand_names[] =
  "CONNECTION_BAND_CELLULAR_BAND_2G"
  "CONNECTION_BAND_CELLULAR_BAND_3G"
  "CONNECTION_BAND_CELLULAR_BAND_4G"
  "CONNECTION_BAND_CELLULAR_BAND_5G"
  "CONNECTION_BAND_UNKNOWN_BAND"
  "CONNECTION_BAND_WIFI_BAND_2GHZ"
  "CONNECTION_BAND_WIFI_BAND_5GHZ"
  "CONNECTION_BAND_WIFI_BAND_6GHZ";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ConnectionBand_entries[] = {
  { {ConnectionBand_names + 0, 32}, 4 },
  { {ConnectionBand_names + 32, 32}, 5 },
  { {ConnectionBand_names + 64, 32}, 6 },
  { {ConnectionBand_names + 96, 32}, 7 },
  { {ConnectionBand_names + 128, 28}, 0 },
  { {ConnectionBand_names + 156, 30}, 1 },
  { {ConnectionBand_names + 186, 30}, 2 },
  { {ConnectionBand_names + 216, 30}, 3 },
};

static const int ConnectionBand_entries_by_number[] = {
  4, // 0 -> CONNECTION_BAND_UNKNOWN_BAND
  5, // 1 -> CONNECTION_BAND_WIFI_BAND_2GHZ
  6, // 2 -> CONNECTION_BAND_WIFI_BAND_5GHZ
  7, // 3 -> CONNECTION_BAND_WIFI_BAND_6GHZ
  0, // 4 -> CONNECTION_BAND_CELLULAR_BAND_2G
  1, // 5 -> CONNECTION_BAND_CELLULAR_BAND_3G
  2, // 6 -> CONNECTION_BAND_CELLULAR_BAND_4G
  3, // 7 -> CONNECTION_BAND_CELLULAR_BAND_5G
};

const std::string& ConnectionBand_Name(
    ConnectionBand value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ConnectionBand_entries,
          ConnectionBand_entries_by_number,
          8, ConnectionBand_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ConnectionBand_entries,
      ConnectionBand_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ConnectionBand_strings[idx].get();
}
bool ConnectionBand_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionBand* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ConnectionBand_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<ConnectionBand>(int_value);
  }
  return success;
}
bool ConnectionRequestResponse_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ConnectionRequestResponse_strings[5] = {};

static const char ConnectionRequestResponse_names[] =
  "ACCEPTED"
  "IGNORED"
  "NOT_SENT"
  "REJECTED"
  "UNKNOWN_CONNECTION_REQUEST_RESPONSE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ConnectionRequestResponse_entries[] = {
  { {ConnectionRequestResponse_names + 0, 8}, 1 },
  { {ConnectionRequestResponse_names + 8, 7}, 3 },
  { {ConnectionRequestResponse_names + 15, 8}, 4 },
  { {ConnectionRequestResponse_names + 23, 8}, 2 },
  { {ConnectionRequestResponse_names + 31, 35}, 0 },
};

static const int ConnectionRequestResponse_entries_by_number[] = {
  4, // 0 -> UNKNOWN_CONNECTION_REQUEST_RESPONSE
  0, // 1 -> ACCEPTED
  3, // 2 -> REJECTED
  1, // 3 -> IGNORED
  2, // 4 -> NOT_SENT
};

const std::string& ConnectionRequestResponse_Name(
    ConnectionRequestResponse value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ConnectionRequestResponse_entries,
          ConnectionRequestResponse_entries_by_number,
          5, ConnectionRequestResponse_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ConnectionRequestResponse_entries,
      ConnectionRequestResponse_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ConnectionRequestResponse_strings[idx].get();
}
bool ConnectionRequestResponse_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionRequestResponse* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ConnectionRequestResponse_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<ConnectionRequestResponse>(int_value);
  }
  return success;
}
bool ConnectionAttemptResult_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ConnectionAttemptResult_strings[4] = {};

static const char ConnectionAttemptResult_names[] =
  "RESULT_CANCELLED"
  "RESULT_ERROR"
  "RESULT_SUCCESS"
  "UNKNOWN_CONNECTION_ATTEMPT_RESULT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ConnectionAttemptResult_entries[] = {
  { {ConnectionAttemptResult_names + 0, 16}, 3 },
  { {ConnectionAttemptResult_names + 16, 12}, 2 },
  { {ConnectionAttemptResult_names + 28, 14}, 1 },
  { {ConnectionAttemptResult_names + 42, 33}, 0 },
};

static const int ConnectionAttemptResult_entries_by_number[] = {
  3, // 0 -> UNKNOWN_CONNECTION_ATTEMPT_RESULT
  2, // 1 -> RESULT_SUCCESS
  1, // 2 -> RESULT_ERROR
  0, // 3 -> RESULT_CANCELLED
};

const std::string& ConnectionAttemptResult_Name(
    ConnectionAttemptResult value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ConnectionAttemptResult_entries,
          ConnectionAttemptResult_entries_by_number,
          4, ConnectionAttemptResult_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ConnectionAttemptResult_entries,
      ConnectionAttemptResult_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ConnectionAttemptResult_strings[idx].get();
}
bool ConnectionAttemptResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionAttemptResult* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ConnectionAttemptResult_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ConnectionAttemptResult>(int_value);
  }
  return success;
}
bool ConnectionAttemptDirection_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ConnectionAttemptDirection_strings[3] = {};

static const char ConnectionAttemptDirection_names[] =
  "INCOMING"
  "OUTGOING"
  "UNKNOWN_CONNECTION_ATTEMPT_DIRECTION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ConnectionAttemptDirection_entries[] = {
  { {ConnectionAttemptDirection_names + 0, 8}, 1 },
  { {ConnectionAttemptDirection_names + 8, 8}, 2 },
  { {ConnectionAttemptDirection_names + 16, 36}, 0 },
};

static const int ConnectionAttemptDirection_entries_by_number[] = {
  2, // 0 -> UNKNOWN_CONNECTION_ATTEMPT_DIRECTION
  0, // 1 -> INCOMING
  1, // 2 -> OUTGOING
};

const std::string& ConnectionAttemptDirection_Name(
    ConnectionAttemptDirection value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ConnectionAttemptDirection_entries,
          ConnectionAttemptDirection_entries_by_number,
          3, ConnectionAttemptDirection_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ConnectionAttemptDirection_entries,
      ConnectionAttemptDirection_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ConnectionAttemptDirection_strings[idx].get();
}
bool ConnectionAttemptDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionAttemptDirection* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ConnectionAttemptDirection_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ConnectionAttemptDirection>(int_value);
  }
  return success;
}
bool ConnectionAttemptType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ConnectionAttemptType_strings[3] = {};

static const char ConnectionAttemptType_names[] =
  "INITIAL"
  "UNKNOWN_CONNECTION_ATTEMPT_TYPE"
  "UPGRADE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ConnectionAttemptType_entries[] = {
  { {ConnectionAttemptType_names + 0, 7}, 1 },
  { {ConnectionAttemptType_names + 7, 31}, 0 },
  { {ConnectionAttemptType_names + 38, 7}, 2 },
};

static const int ConnectionAttemptType_entries_by_number[] = {
  1, // 0 -> UNKNOWN_CONNECTION_ATTEMPT_TYPE
  0, // 1 -> INITIAL
  2, // 2 -> UPGRADE
};

const std::string& ConnectionAttemptType_Name(
    ConnectionAttemptType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ConnectionAttemptType_entries,
          ConnectionAttemptType_entries_by_number,
          3, ConnectionAttemptType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ConnectionAttemptType_entries,
      ConnectionAttemptType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ConnectionAttemptType_strings[idx].get();
}
bool ConnectionAttemptType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionAttemptType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ConnectionAttemptType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ConnectionAttemptType>(int_value);
  }
  return success;
}
bool DisconnectionReason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DisconnectionReason_strings[7] = {};

static const char DisconnectionReason_names[] =
  "IO_ERROR"
  "LOCAL_DISCONNECTION"
  "REMOTE_DISCONNECTION"
  "SHUTDOWN"
  "UNFINISHED"
  "UNKNOWN_DISCONNECTION_REASON"
  "UPGRADED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DisconnectionReason_entries[] = {
  { {DisconnectionReason_names + 0, 8}, 3 },
  { {DisconnectionReason_names + 8, 19}, 1 },
  { {DisconnectionReason_names + 27, 20}, 2 },
  { {DisconnectionReason_names + 47, 8}, 5 },
  { {DisconnectionReason_names + 55, 10}, 6 },
  { {DisconnectionReason_names + 65, 28}, 0 },
  { {DisconnectionReason_names + 93, 8}, 4 },
};

static const int DisconnectionReason_entries_by_number[] = {
  5, // 0 -> UNKNOWN_DISCONNECTION_REASON
  1, // 1 -> LOCAL_DISCONNECTION
  2, // 2 -> REMOTE_DISCONNECTION
  0, // 3 -> IO_ERROR
  6, // 4 -> UPGRADED
  3, // 5 -> SHUTDOWN
  4, // 6 -> UNFINISHED
};

const std::string& DisconnectionReason_Name(
    DisconnectionReason value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DisconnectionReason_entries,
          DisconnectionReason_entries_by_number,
          7, DisconnectionReason_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DisconnectionReason_entries,
      DisconnectionReason_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DisconnectionReason_strings[idx].get();
}
bool DisconnectionReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DisconnectionReason* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DisconnectionReason_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<DisconnectionReason>(int_value);
  }
  return success;
}
bool PayloadType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PayloadType_strings[4] = {};

static const char PayloadType_names[] =
  "BYTES"
  "FILE"
  "STREAM"
  "UNKNOWN_PAYLOAD_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PayloadType_entries[] = {
  { {PayloadType_names + 0, 5}, 1 },
  { {PayloadType_names + 5, 4}, 2 },
  { {PayloadType_names + 9, 6}, 3 },
  { {PayloadType_names + 15, 20}, 0 },
};

static const int PayloadType_entries_by_number[] = {
  3, // 0 -> UNKNOWN_PAYLOAD_TYPE
  0, // 1 -> BYTES
  1, // 2 -> FILE
  2, // 3 -> STREAM
};

const std::string& PayloadType_Name(
    PayloadType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PayloadType_entries,
          PayloadType_entries_by_number,
          4, PayloadType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PayloadType_entries,
      PayloadType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PayloadType_strings[idx].get();
}
bool PayloadType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PayloadType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PayloadType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<PayloadType>(int_value);
  }
  return success;
}
bool PayloadStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PayloadStatus_strings[10] = {};

static const char PayloadStatus_names[] =
  "CONNECTION_CLOSED"
  "ENDPOINT_IO_ERROR"
  "ENDPOINT_UNENCRYPTED"
  "LOCAL_CANCELLATION"
  "LOCAL_ERROR"
  "MOVED_TO_NEW_MEDIUM"
  "REMOTE_CANCELLATION"
  "REMOTE_ERROR"
  "SUCCESS"
  "UNKNOWN_PAYLOAD_STATUS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PayloadStatus_entries[] = {
  { {PayloadStatus_names + 0, 17}, 6 },
  { {PayloadStatus_names + 17, 17}, 4 },
  { {PayloadStatus_names + 34, 20}, 9 },
  { {PayloadStatus_names + 54, 18}, 7 },
  { {PayloadStatus_names + 72, 11}, 2 },
  { {PayloadStatus_names + 83, 19}, 5 },
  { {PayloadStatus_names + 102, 19}, 8 },
  { {PayloadStatus_names + 121, 12}, 3 },
  { {PayloadStatus_names + 133, 7}, 1 },
  { {PayloadStatus_names + 140, 22}, 0 },
};

static const int PayloadStatus_entries_by_number[] = {
  9, // 0 -> UNKNOWN_PAYLOAD_STATUS
  8, // 1 -> SUCCESS
  4, // 2 -> LOCAL_ERROR
  7, // 3 -> REMOTE_ERROR
  1, // 4 -> ENDPOINT_IO_ERROR
  5, // 5 -> MOVED_TO_NEW_MEDIUM
  0, // 6 -> CONNECTION_CLOSED
  3, // 7 -> LOCAL_CANCELLATION
  6, // 8 -> REMOTE_CANCELLATION
  2, // 9 -> ENDPOINT_UNENCRYPTED
};

const std::string& PayloadStatus_Name(
    PayloadStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PayloadStatus_entries,
          PayloadStatus_entries_by_number,
          10, PayloadStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PayloadStatus_entries,
      PayloadStatus_entries_by_number,
      10, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PayloadStatus_strings[idx].get();
}
bool PayloadStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PayloadStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PayloadStatus_entries, 10, name, &int_value);
  if (success) {
    *value = static_cast<PayloadStatus>(int_value);
  }
  return success;
}
bool Bandwidth_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Bandwidth_strings[4] = {};

static const char Bandwidth_names[] =
  "BANDWIDTH_24_GHZ"
  "BANDWIDTH_5_GHZ"
  "BANDWIDTH_6_GHZ"
  "BANDWIDTH_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Bandwidth_entries[] = {
  { {Bandwidth_names + 0, 16}, 1 },
  { {Bandwidth_names + 16, 15}, 2 },
  { {Bandwidth_names + 31, 15}, 3 },
  { {Bandwidth_names + 46, 17}, 0 },
};

static const int Bandwidth_entries_by_number[] = {
  3, // 0 -> BANDWIDTH_UNKNOWN
  0, // 1 -> BANDWIDTH_24_GHZ
  1, // 2 -> BANDWIDTH_5_GHZ
  2, // 3 -> BANDWIDTH_6_GHZ
};

const std::string& Bandwidth_Name(
    Bandwidth value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Bandwidth_entries,
          Bandwidth_entries_by_number,
          4, Bandwidth_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Bandwidth_entries,
      Bandwidth_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Bandwidth_strings[idx].get();
}
bool Bandwidth_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Bandwidth* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Bandwidth_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<Bandwidth>(int_value);
  }
  return success;
}
bool BandwidthUpgradeResult_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BandwidthUpgradeResult_strings[17] = {};

static const char BandwidthUpgradeResult_names[] =
  "ALREADY_ON_MEDIUM_ERROR"
  "ATTEMPT_SKIPPED"
  "BLUETOOTH_MEDIUM_ERROR"
  "CHANNEL_ERROR"
  "MEDIUM_ERROR"
  "PROTOCOL_ERROR"
  "RESULT_IO_ERROR"
  "RESULT_REMOTE_ERROR"
  "UNFINISHED_ERROR"
  "UNKNOWN_BANDWIDTH_UPGRADE_RESULT"
  "UPGRADE_RESULT_ERROR"
  "UPGRADE_RESULT_SUCCESS"
  "WEB_RTC_MEDIUM_ERROR"
  "WIFI_AWARE_MEDIUM_ERROR"
  "WIFI_DIRECT_MEDIUM_ERROR"
  "WIFI_HOTSPOT_MEDIUM_ERROR"
  "WIFI_LAN_MEDIUM_ERROR";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BandwidthUpgradeResult_entries[] = {
  { {BandwidthUpgradeResult_names + 0, 23}, 7 },
  { {BandwidthUpgradeResult_names + 23, 15}, 18 },
  { {BandwidthUpgradeResult_names + 38, 22}, 11 },
  { {BandwidthUpgradeResult_names + 60, 13}, 6 },
  { {BandwidthUpgradeResult_names + 73, 12}, 3 },
  { {BandwidthUpgradeResult_names + 85, 14}, 4 },
  { {BandwidthUpgradeResult_names + 99, 15}, 5 },
  { {BandwidthUpgradeResult_names + 114, 19}, 17 },
  { {BandwidthUpgradeResult_names + 133, 16}, 10 },
  { {BandwidthUpgradeResult_names + 149, 32}, 0 },
  { {BandwidthUpgradeResult_names + 181, 20}, 2 },
  { {BandwidthUpgradeResult_names + 201, 22}, 1 },
  { {BandwidthUpgradeResult_names + 223, 20}, 16 },
  { {BandwidthUpgradeResult_names + 243, 23}, 12 },
  { {BandwidthUpgradeResult_names + 266, 24}, 15 },
  { {BandwidthUpgradeResult_names + 290, 25}, 14 },
  { {BandwidthUpgradeResult_names + 315, 21}, 13 },
};

static const int BandwidthUpgradeResult_entries_by_number[] = {
  9, // 0 -> UNKNOWN_BANDWIDTH_UPGRADE_RESULT
  11, // 1 -> UPGRADE_RESULT_SUCCESS
  10, // 2 -> UPGRADE_RESULT_ERROR
  4, // 3 -> MEDIUM_ERROR
  5, // 4 -> PROTOCOL_ERROR
  6, // 5 -> RESULT_IO_ERROR
  3, // 6 -> CHANNEL_ERROR
  0, // 7 -> ALREADY_ON_MEDIUM_ERROR
  8, // 10 -> UNFINISHED_ERROR
  2, // 11 -> BLUETOOTH_MEDIUM_ERROR
  13, // 12 -> WIFI_AWARE_MEDIUM_ERROR
  16, // 13 -> WIFI_LAN_MEDIUM_ERROR
  15, // 14 -> WIFI_HOTSPOT_MEDIUM_ERROR
  14, // 15 -> WIFI_DIRECT_MEDIUM_ERROR
  12, // 16 -> WEB_RTC_MEDIUM_ERROR
  7, // 17 -> RESULT_REMOTE_ERROR
  1, // 18 -> ATTEMPT_SKIPPED
};

const std::string& BandwidthUpgradeResult_Name(
    BandwidthUpgradeResult value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BandwidthUpgradeResult_entries,
          BandwidthUpgradeResult_entries_by_number,
          17, BandwidthUpgradeResult_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BandwidthUpgradeResult_entries,
      BandwidthUpgradeResult_entries_by_number,
      17, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BandwidthUpgradeResult_strings[idx].get();
}
bool BandwidthUpgradeResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BandwidthUpgradeResult* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BandwidthUpgradeResult_entries, 17, name, &int_value);
  if (success) {
    *value = static_cast<BandwidthUpgradeResult>(int_value);
  }
  return success;
}
bool BandwidthUpgradeErrorStage_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BandwidthUpgradeErrorStage_strings[35] = {};

static const char BandwidthUpgradeErrorStage_names[] =
  "BLUETOOTH_CONNECT_OUTGOING"
  "BLUETOOTH_LISTEN_INCOMING"
  "BLUETOOTH_OBTAIN_MAC_ADDRESS"
  "BLUETOOTH_PARSE_MAC_ADDRESS"
  "BLUETOOTH_SOCKET_CREATION"
  "CLIENT_INTRODUCTION"
  "LAST_WRITE_TO_PRIOR_CHANNEL"
  "NETWORK_AVAILABLE"
  "PRIOR_ENDPOINT_CHANNEL"
  "SAFE_TO_CLOSE_PRIOR_CHANNEL"
  "SOCKET_CREATION"
  "UNKNOWN_BANDWIDTH_UPGRADE_ERROR_STAGE"
  "UPGRADE_CANCEL"
  "UPGRADE_SUCCESS"
  "UPGRADE_UNFINISHED"
  "WEB_RTC_LISTEN_INCOMING"
  "WEB_RTC_SOCKET_CREATION"
  "WIFI_AWARE_CONNECT_TO_NETWORK"
  "WIFI_AWARE_LISTEN_INCOMING"
  "WIFI_AWARE_PUBLISH"
  "WIFI_AWARE_SOCKET_CREATION"
  "WIFI_AWARE_SUBSCRIBE"
  "WIFI_CONNECT_TO_HOTSPOT"
  "WIFI_DIRECT_CONNECT_OUTGOING"
  "WIFI_DIRECT_CREATE_GROUP"
  "WIFI_DIRECT_LISTEN_INCOMING"
  "WIFI_DIRECT_PARSE_DEVICE_ADDRESS"
  "WIFI_DIRECT_SOCKET_CREATION"
  "WIFI_HOTSPOT_SOCKET_CREATION"
  "WIFI_LAN_IP_ADDRESS"
  "WIFI_LAN_LISTEN_INCOMING"
  "WIFI_LAN_SOCKET_CONNECTION"
  "WIFI_LAN_SOCKET_CREATION"
  "WIFI_LISTEN_INCOMING"
  "WIFI_START_HOTSPOT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BandwidthUpgradeErrorStage_entries[] = {
  { {BandwidthUpgradeErrorStage_names + 0, 26}, 18 },
  { {BandwidthUpgradeErrorStage_names + 26, 25}, 16 },
  { {BandwidthUpgradeErrorStage_names + 51, 28}, 17 },
  { {BandwidthUpgradeErrorStage_names + 79, 27}, 19 },
  { {BandwidthUpgradeErrorStage_names + 106, 25}, 30 },
  { {BandwidthUpgradeErrorStage_names + 131, 19}, 1 },
  { {BandwidthUpgradeErrorStage_names + 150, 27}, 3 },
  { {BandwidthUpgradeErrorStage_names + 177, 17}, 2 },
  { {BandwidthUpgradeErrorStage_names + 194, 22}, 6 },
  { {BandwidthUpgradeErrorStage_names + 216, 27}, 4 },
  { {BandwidthUpgradeErrorStage_names + 243, 15}, 5 },
  { {BandwidthUpgradeErrorStage_names + 258, 37}, 0 },
  { {BandwidthUpgradeErrorStage_names + 295, 14}, 9 },
  { {BandwidthUpgradeErrorStage_names + 309, 15}, 8 },
  { {BandwidthUpgradeErrorStage_names + 324, 18}, 7 },
  { {BandwidthUpgradeErrorStage_names + 342, 23}, 34 },
  { {BandwidthUpgradeErrorStage_names + 365, 23}, 33 },
  { {BandwidthUpgradeErrorStage_names + 388, 29}, 23 },
  { {BandwidthUpgradeErrorStage_names + 417, 26}, 20 },
  { {BandwidthUpgradeErrorStage_names + 443, 18}, 21 },
  { {BandwidthUpgradeErrorStage_names + 461, 26}, 31 },
  { {BandwidthUpgradeErrorStage_names + 487, 20}, 22 },
  { {BandwidthUpgradeErrorStage_names + 507, 23}, 12 },
  { {BandwidthUpgradeErrorStage_names + 530, 28}, 26 },
  { {BandwidthUpgradeErrorStage_names + 558, 24}, 25 },
  { {BandwidthUpgradeErrorStage_names + 582, 27}, 24 },
  { {BandwidthUpgradeErrorStage_names + 609, 32}, 27 },
  { {BandwidthUpgradeErrorStage_names + 641, 27}, 32 },
  { {BandwidthUpgradeErrorStage_names + 668, 28}, 28 },
  { {BandwidthUpgradeErrorStage_names + 696, 19}, 14 },
  { {BandwidthUpgradeErrorStage_names + 715, 24}, 13 },
  { {BandwidthUpgradeErrorStage_names + 739, 26}, 15 },
  { {BandwidthUpgradeErrorStage_names + 765, 24}, 29 },
  { {BandwidthUpgradeErrorStage_names + 789, 20}, 11 },
  { {BandwidthUpgradeErrorStage_names + 809, 18}, 10 },
};

static const int BandwidthUpgradeErrorStage_entries_by_number[] = {
  11, // 0 -> UNKNOWN_BANDWIDTH_UPGRADE_ERROR_STAGE
  5, // 1 -> CLIENT_INTRODUCTION
  7, // 2 -> NETWORK_AVAILABLE
  6, // 3 -> LAST_WRITE_TO_PRIOR_CHANNEL
  9, // 4 -> SAFE_TO_CLOSE_PRIOR_CHANNEL
  10, // 5 -> SOCKET_CREATION
  8, // 6 -> PRIOR_ENDPOINT_CHANNEL
  14, // 7 -> UPGRADE_UNFINISHED
  13, // 8 -> UPGRADE_SUCCESS
  12, // 9 -> UPGRADE_CANCEL
  34, // 10 -> WIFI_START_HOTSPOT
  33, // 11 -> WIFI_LISTEN_INCOMING
  22, // 12 -> WIFI_CONNECT_TO_HOTSPOT
  30, // 13 -> WIFI_LAN_LISTEN_INCOMING
  29, // 14 -> WIFI_LAN_IP_ADDRESS
  31, // 15 -> WIFI_LAN_SOCKET_CONNECTION
  1, // 16 -> BLUETOOTH_LISTEN_INCOMING
  2, // 17 -> BLUETOOTH_OBTAIN_MAC_ADDRESS
  0, // 18 -> BLUETOOTH_CONNECT_OUTGOING
  3, // 19 -> BLUETOOTH_PARSE_MAC_ADDRESS
  18, // 20 -> WIFI_AWARE_LISTEN_INCOMING
  19, // 21 -> WIFI_AWARE_PUBLISH
  21, // 22 -> WIFI_AWARE_SUBSCRIBE
  17, // 23 -> WIFI_AWARE_CONNECT_TO_NETWORK
  25, // 24 -> WIFI_DIRECT_LISTEN_INCOMING
  24, // 25 -> WIFI_DIRECT_CREATE_GROUP
  23, // 26 -> WIFI_DIRECT_CONNECT_OUTGOING
  26, // 27 -> WIFI_DIRECT_PARSE_DEVICE_ADDRESS
  28, // 28 -> WIFI_HOTSPOT_SOCKET_CREATION
  32, // 29 -> WIFI_LAN_SOCKET_CREATION
  4, // 30 -> BLUETOOTH_SOCKET_CREATION
  20, // 31 -> WIFI_AWARE_SOCKET_CREATION
  27, // 32 -> WIFI_DIRECT_SOCKET_CREATION
  16, // 33 -> WEB_RTC_SOCKET_CREATION
  15, // 34 -> WEB_RTC_LISTEN_INCOMING
};

const std::string& BandwidthUpgradeErrorStage_Name(
    BandwidthUpgradeErrorStage value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BandwidthUpgradeErrorStage_entries,
          BandwidthUpgradeErrorStage_entries_by_number,
          35, BandwidthUpgradeErrorStage_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BandwidthUpgradeErrorStage_entries,
      BandwidthUpgradeErrorStage_entries_by_number,
      35, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BandwidthUpgradeErrorStage_strings[idx].get();
}
bool BandwidthUpgradeErrorStage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BandwidthUpgradeErrorStage* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BandwidthUpgradeErrorStage_entries, 35, name, &int_value);
  if (success) {
    *value = static_cast<BandwidthUpgradeErrorStage>(int_value);
  }
  return success;
}
bool LogSource_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LogSource_strings[6] = {};

static const char LogSource_names[] =
  "BETA_TESTER_DEVICES"
  "DEBUG_DEVICES"
  "INTERNAL_DEVICES"
  "LAB_DEVICES"
  "OEM_DEVICES"
  "UNSPECIFIED_SOURCE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LogSource_entries[] = {
  { {LogSource_names + 0, 19}, 3 },
  { {LogSource_names + 19, 13}, 5 },
  { {LogSource_names + 32, 16}, 2 },
  { {LogSource_names + 48, 11}, 1 },
  { {LogSource_names + 59, 11}, 4 },
  { {LogSource_names + 70, 18}, 0 },
};

static const int LogSource_entries_by_number[] = {
  5, // 0 -> UNSPECIFIED_SOURCE
  3, // 1 -> LAB_DEVICES
  2, // 2 -> INTERNAL_DEVICES
  0, // 3 -> BETA_TESTER_DEVICES
  4, // 4 -> OEM_DEVICES
  1, // 5 -> DEBUG_DEVICES
};

const std::string& LogSource_Name(
    LogSource value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LogSource_entries,
          LogSource_entries_by_number,
          6, LogSource_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LogSource_entries,
      LogSource_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LogSource_strings[idx].get();
}
bool LogSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LogSource* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LogSource_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<LogSource>(int_value);
  }
  return success;
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace connections
}  // namespace proto
}  // namespace nearby
}  // namespace location
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
