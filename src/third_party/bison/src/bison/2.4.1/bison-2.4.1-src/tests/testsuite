#! /bin/sh
# Generated from ../../bison-2.4.1-src/tests/local.at by GNU Autoconf 2.63.
#
# Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
# Free Software Foundation, Inc.
# This test suite is free software; the Free Software Foundation gives
# unlimited permission to copy, distribute and modify it.
## --------------------- ##
## M4sh Initialization.  ##
## --------------------- ##

# Be more Bourne compatible
DUALCASE=1; export DUALCASE # for MKS sh
if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
  emulate sh
  NULLCMD=:
  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '${1+"$@"}'='"$@"'
  setopt NO_GLOB_SUBST
else
  case `(set -o) 2>/dev/null` in
  *posix*) set -o posix ;;
esac

fi




# PATH needs CR
# Avoid depending upon Character Ranges.
as_cr_letters='abcdefghijklmnopqrstuvwxyz'
as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
as_cr_Letters=$as_cr_letters$as_cr_LETTERS
as_cr_digits='0123456789'
as_cr_alnum=$as_cr_Letters$as_cr_digits

as_nl='
'
export as_nl
# Printing a long string crashes Solaris 7 /usr/bin/printf.
as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
if (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
  as_echo='printf %s\n'
  as_echo_n='printf %s'
else
  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
    as_echo_n='/usr/ucb/echo -n'
  else
    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
    as_echo_n_body='eval
      arg=$1;
      case $arg in
      *"$as_nl"*)
	expr "X$arg" : "X\\(.*\\)$as_nl";
	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
      esac;
      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
    '
    export as_echo_n_body
    as_echo_n='sh -c $as_echo_n_body as_echo'
  fi
  export as_echo_body
  as_echo='sh -c $as_echo_body as_echo'
fi

# The user is always right.
if test "${PATH_SEPARATOR+set}" != set; then
  PATH_SEPARATOR=:
  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
      PATH_SEPARATOR=';'
  }
fi

# Support unset when possible.
if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
  as_unset=unset
else
  as_unset=false
fi


# IFS
# We need space, tab and new line, in precisely that order.  Quoting is
# there to prevent editors from complaining about space-tab.
# (If _AS_PATH_WALK were called with IFS unset, it would disable word
# splitting by setting IFS to empty value.)
IFS=" ""	$as_nl"

# Find who we are.  Look in the path if we contain no directory separator.
case $0 in
  *[\\/]* ) as_myself=$0 ;;
  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
done
IFS=$as_save_IFS

     ;;
esac
# We did not find ourselves, most probably we were run as `sh COMMAND'
# in which case we are not to be found in the path.
if test "x$as_myself" = x; then
  as_myself=$0
fi
if test ! -f "$as_myself"; then
  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
  { (exit 1); exit 1; }
fi

# Work around bugs in pre-3.0 UWIN ksh.
for as_var in ENV MAIL MAILPATH
do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
done
PS1='$ '
PS2='> '
PS4='+ '

# NLS nuisances.
LC_ALL=C
export LC_ALL
LANGUAGE=C
export LANGUAGE

# Required to use basename.
if expr a : '\(a\)' >/dev/null 2>&1 &&
   test "X`expr 00001 : '.*\(...\)'`" = X001; then
  as_expr=expr
else
  as_expr=false
fi

if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
  as_basename=basename
else
  as_basename=false
fi


# Name of the executable.
as_me=`$as_basename -- "$0" ||
$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
	 X"$0" : 'X\(//\)$' \| \
	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X/"$0" |
    sed '/^.*\/\([^/][^/]*\)\/*$/{
	    s//\1/
	    q
	  }
	  /^X\/\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\/\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`

# CDPATH.
$as_unset CDPATH


if test "x$CONFIG_SHELL" = x; then
  if (eval ":") 2>/dev/null; then
  as_have_required=yes
else
  as_have_required=no
fi

  if test $as_have_required = yes &&	 (eval ":
(as_func_return () {
  (exit \$1)
}
as_func_success () {
  as_func_return 0
}
as_func_failure () {
  as_func_return 1
}
as_func_ret_success () {
  return 0
}
as_func_ret_failure () {
  return 1
}

exitcode=0
if as_func_success; then
  :
else
  exitcode=1
  echo as_func_success failed.
fi

if as_func_failure; then
  exitcode=1
  echo as_func_failure succeeded.
fi

if as_func_ret_success; then
  :
else
  exitcode=1
  echo as_func_ret_success failed.
fi

if as_func_ret_failure; then
  exitcode=1
  echo as_func_ret_failure succeeded.
fi

if ( set x; as_func_ret_success y && test x = \"\$1\" ); then
  :
else
  exitcode=1
  echo positional parameters were not saved.
fi

test \$exitcode = 0) || { (exit 1); exit 1; }

(
  as_lineno_1=\$LINENO
  as_lineno_2=\$LINENO
  test \"x\$as_lineno_1\" != \"x\$as_lineno_2\" &&
  test \"x\`expr \$as_lineno_1 + 1\`\" = \"x\$as_lineno_2\") || { (exit 1); exit 1; }
") 2> /dev/null; then
  :
else
  as_candidate_shells=
    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  case $as_dir in
	 /*)
	   for as_base in sh bash ksh sh5; do
	     as_candidate_shells="$as_candidate_shells $as_dir/$as_base"
	   done;;
       esac
done
IFS=$as_save_IFS


      for as_shell in $as_candidate_shells $SHELL; do
	 # Try only shells that exist, to save several forks.
	 if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
		{ ("$as_shell") 2> /dev/null <<\_ASEOF
if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
  emulate sh
  NULLCMD=:
  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '${1+"$@"}'='"$@"'
  setopt NO_GLOB_SUBST
else
  case `(set -o) 2>/dev/null` in
  *posix*) set -o posix ;;
esac

fi


:
_ASEOF
}; then
  CONFIG_SHELL=$as_shell
	       as_have_required=yes
	       if { "$as_shell" 2> /dev/null <<\_ASEOF
if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
  emulate sh
  NULLCMD=:
  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '${1+"$@"}'='"$@"'
  setopt NO_GLOB_SUBST
else
  case `(set -o) 2>/dev/null` in
  *posix*) set -o posix ;;
esac

fi


:
(as_func_return () {
  (exit $1)
}
as_func_success () {
  as_func_return 0
}
as_func_failure () {
  as_func_return 1
}
as_func_ret_success () {
  return 0
}
as_func_ret_failure () {
  return 1
}

exitcode=0
if as_func_success; then
  :
else
  exitcode=1
  echo as_func_success failed.
fi

if as_func_failure; then
  exitcode=1
  echo as_func_failure succeeded.
fi

if as_func_ret_success; then
  :
else
  exitcode=1
  echo as_func_ret_success failed.
fi

if as_func_ret_failure; then
  exitcode=1
  echo as_func_ret_failure succeeded.
fi

if ( set x; as_func_ret_success y && test x = "$1" ); then
  :
else
  exitcode=1
  echo positional parameters were not saved.
fi

test $exitcode = 0) || { (exit 1); exit 1; }

(
  as_lineno_1=$LINENO
  as_lineno_2=$LINENO
  test "x$as_lineno_1" != "x$as_lineno_2" &&
  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2") || { (exit 1); exit 1; }

_ASEOF
}; then
  break
fi

fi

      done

      if test "x$CONFIG_SHELL" != x; then
  for as_var in BASH_ENV ENV
	do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
	done
	export CONFIG_SHELL
	exec "$CONFIG_SHELL" "$as_myself" ${1+"$@"}
fi


    if test $as_have_required = no; then
  echo This script requires a shell more modern than all the
      echo shells that I found on your system.  Please install a
      echo modern shell, or manually run the script under such a
      echo shell if you do have one.
      { (exit 1); exit 1; }
fi


fi

fi



(eval "as_func_return () {
  (exit \$1)
}
as_func_success () {
  as_func_return 0
}
as_func_failure () {
  as_func_return 1
}
as_func_ret_success () {
  return 0
}
as_func_ret_failure () {
  return 1
}

exitcode=0
if as_func_success; then
  :
else
  exitcode=1
  echo as_func_success failed.
fi

if as_func_failure; then
  exitcode=1
  echo as_func_failure succeeded.
fi

if as_func_ret_success; then
  :
else
  exitcode=1
  echo as_func_ret_success failed.
fi

if as_func_ret_failure; then
  exitcode=1
  echo as_func_ret_failure succeeded.
fi

if ( set x; as_func_ret_success y && test x = \"\$1\" ); then
  :
else
  exitcode=1
  echo positional parameters were not saved.
fi

test \$exitcode = 0") || {
  echo No shell found that supports shell functions.
  echo Please tell bug-autoconf@gnu.org about your system,
  echo including any error possibly output before this message.
  echo This can help us improve future autoconf versions.
  echo Configuration will now proceed without shell functions.
}



  as_lineno_1=$LINENO
  as_lineno_2=$LINENO
  test "x$as_lineno_1" != "x$as_lineno_2" &&
  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2" || {

  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
  # uniformly replaced by the line number.  The first 'sed' inserts a
  # line-number line after each line using $LINENO; the second 'sed'
  # does the real work.  The second script uses 'N' to pair each
  # line-number line with the line containing $LINENO, and appends
  # trailing '-' during substitution so that $LINENO is not a special
  # case at line end.
  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
  # scripts with optimization help from Paolo Bonzini.  Blame Lee
  # E. McMahon (1931-1989) for sed's syntax.  :-)
  sed -n '
    p
    /[$]LINENO/=
  ' <$as_myself |
    sed '
      s/[$]LINENO.*/&-/
      t lineno
      b
      :lineno
      N
      :loop
      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
      t loop
      s/-\n.*//
    ' >$as_me.lineno &&
  chmod +x "$as_me.lineno" ||
    { { $as_echo "$as_me:$LINENO: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&5
$as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2;}
   { (exit 1); exit 1; }; }

  # Don't try to exec as it changes $[0], causing all sort of problems
  # (the dirname of $[0] is not the place where we might find the
  # original and so on.  Autoconf is especially sensitive to this).
  . "./$as_me.lineno"
  # Exit status is that of the last command.
  exit
}


if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
  as_dirname=dirname
else
  as_dirname=false
fi

ECHO_C= ECHO_N= ECHO_T=
case `echo -n x` in
-n*)
  case `echo 'x\c'` in
  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
  *)   ECHO_C='\c';;
  esac;;
*)
  ECHO_N='-n';;
esac
if expr a : '\(a\)' >/dev/null 2>&1 &&
   test "X`expr 00001 : '.*\(...\)'`" = X001; then
  as_expr=expr
else
  as_expr=false
fi

rm -f conf$$ conf$$.exe conf$$.file
if test -d conf$$.dir; then
  rm -f conf$$.dir/conf$$.file
else
  rm -f conf$$.dir
  mkdir conf$$.dir 2>/dev/null
fi
if (echo >conf$$.file) 2>/dev/null; then
  if ln -s conf$$.file conf$$ 2>/dev/null; then
    as_ln_s='ln -s'
    # ... but there are two gotchas:
    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
    # In both cases, we have to default to `cp -p'.
    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
      as_ln_s='cp -p'
  elif ln conf$$.file conf$$ 2>/dev/null; then
    as_ln_s=ln
  else
    as_ln_s='cp -p'
  fi
else
  as_ln_s='cp -p'
fi
rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
rmdir conf$$.dir 2>/dev/null

if mkdir -p . 2>/dev/null; then
  as_mkdir_p=:
else
  test -d ./-p && rmdir ./-p
  as_mkdir_p=false
fi

if test -x / >/dev/null 2>&1; then
  as_test_x='test -x'
else
  if ls -dL / >/dev/null 2>&1; then
    as_ls_L_option=L
  else
    as_ls_L_option=
  fi
  as_test_x='
    eval sh -c '\''
      if test -d "$1"; then
	test -d "$1/.";
      else
	case $1 in
	-*)set "./$1";;
	esac;
	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in
	???[sx]*):;;*)false;;esac;fi
    '\'' sh
  '
fi
as_executable_p=$as_test_x

# Sed expression to map a string onto a valid CPP name.
as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"

# Sed expression to map a string onto a valid variable name.
as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"





SHELL=${CONFIG_SHELL-/bin/sh}

# How were we run?
at_cli_args="$@"


# Not all shells have the 'times' builtin; the subshell is needed to make
# sure we discard the 'times: not found' message from the shell.
at_times_p=false
(times) >/dev/null 2>&1 && at_times_p=:

# CLI Arguments to pass to the debugging scripts.
at_debug_args=
# -e sets to true
at_errexit_p=false
# Shall we be verbose?  ':' means no, empty means yes.
at_verbose=:
at_quiet=

# Shall we keep the debug scripts?  Must be `:' when the suite is
# run by a debug script, so that the script doesn't remove itself.
at_debug_p=false
# Display help message?
at_help_p=false
# Display the version message?
at_version_p=false
# List test groups?
at_list_p=false
# --clean
at_clean=false
# Test groups to run
at_groups=
# Whether a write failure occurred
at_write_fail=0

# The directory we run the suite in.  Default to . if no -C option.
at_dir=`pwd`
# An absolute reference to this testsuite script.
case $as_myself in
  [\\/]* | ?:[\\/]* ) at_myself=$as_myself ;;
  * ) at_myself=$at_dir/$as_myself ;;
esac
# Whether -C is in effect.
at_change_dir=false

# List of the tested programs.
at_tested='bison'
# List of the all the test groups.
at_groups_all=' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240'
# As many question marks as there are digits in the last test group number.
# Used to normalize the test group numbers so that `ls' lists them in
# numerical order.
at_format='???'
# Description of all the test groups.
at_help_all="1;input.at:27;Invalid \$n and @n;;
2;input.at:47;Type Clashes;;
3;input.at:161;Unused values;;
4;input.at:171;Unused values before symbol declarations;;
5;input.at:181;Default %printer and %destructor redeclared;;
6;input.at:241;Per-type %printer and %destructor redeclared;;
7;input.at:284;Unused values with default %destructor;;
8;input.at:326;Unused values with per-type %destructor;;
9;input.at:351;Incompatible Aliases;;
10;input.at:392;Torturing the Scanner;;
11;input.at:555;Typed symbol aliases;;
12;input.at:591;Require 1.0;;
13;input.at:592;Require 2.4.1;;
14;input.at:594;Require 100.0;;
15;input.at:601;String aliases for character tokens;;
16;input.at:622;Unclosed constructs;;
17;input.at:667;%start after first rule;;
18;input.at:688;%prec takes a token;;
19;input.at:709;Reject unused %code qualifiers;;
20;input.at:798;%define errors;;
21;input.at:828;%define Boolean variables;;
22;input.at:848;%define enum variables;;
23;input.at:866;Unused %define api.pure;;
24;input.at:899;C++ namespace reference errors;;
25;output.at:43;Output files:  -dv ;;
26;output.at:45;Output files:  -dv >&-;;
27;output.at:48;Output files:  -dv -o foo.c ;;
28;output.at:50;Output files:  -dv -o foo.tab.c ;;
29;output.at:52;Output files:  -dv -y ;;
30;output.at:54;Output files:  -dv -b bar ;;
31;output.at:56;Output files:  -dv -g -o foo.c ;;
32;output.at:60;Output files: %defines %verbose  ;;
33;output.at:62;Output files: %defines %verbose %yacc  ;;
34;output.at:65;Output files: %defines %verbose %yacc  ;;
35;output.at:69;Output files: %file-prefix \"bar\" %defines %verbose  ;;
36;output.at:71;Output files: %output=\"bar.c\" %defines %verbose %yacc  ;;
37;output.at:73;Output files: %file-prefix=\"baz\" %output \"bar.c\" %defines %verbose %yacc  ;;
38;output.at:80;Output files: %defines %verbose  ;;
39;output.at:83;Output files: %defines %verbose  -o foo.c ;;
40;output.at:86;Output files:  --defines=foo.hpp -o foo.c++ ;;
41;output.at:90;Output files: %defines \"foo.hpp\" -o foo.c++ ;;
42;output.at:94;Output files:  -o foo.c++ --graph=foo.gph ;;
43;output.at:109;Output files: %skeleton \"lalr1.cc\" %defines %verbose  ;;
44;output.at:112;Output files: %skeleton \"lalr1.cc\" %defines %verbose  ;;
45;output.at:116;Output files: %skeleton \"lalr1.cc\" %defines %verbose -o subdir/foo.cc ;;
46;output.at:121;Output files: %skeleton \"lalr1.cc\" %defines %verbose %file-prefix \"output_dir/foo\"  ;;
47;output.at:145;Conflicting output files:  --graph=\"foo.tab.c\";;
48;output.at:150;Conflicting output files: %defines \"foo.output\" -v;;
49;output.at:155;Conflicting output files: %skeleton \"lalr1.cc\" %defines --graph=\"location.hh\";;
50;output.at:160;Conflicting output files:  -o foo.y;;
51;output.at:200;Output file name: \`~!@#\$%^&*()-=_+{}[]|\\:;<>, .';c++;
52;output.at:207;Output file name: (;c++;
53;output.at:208;Output file name: );c++;
54;output.at:209;Output file name: #;c++;
55;output.at:210;Output file name: @@;c++;
56;output.at:211;Output file name: @{;c++;
57;output.at:212;Output file name: @};c++;
58;output.at:213;Output file name: [;c++;
59;output.at:214;Output file name: ];c++;
60;skeletons.at:23;Relative skeleton file names;;
61;skeletons.at:83;Installed skeleton file names;;
62;skeletons.at:148;%define Boolean variables: invalid skeleton defaults;;
63;skeletons.at:172;Complaining during macro argument expansion;;
64;skeletons.at:254;Fatal errors make M4 exit immediately;;
65;sets.at:64;Nullable;;
66;sets.at:149;Broken Closure;;
67;sets.at:191;Firsts;;
68;sets.at:267;Accept;;
69;reduce.at:24;Useless Terminals;;
70;reduce.at:68;Useless Nonterminals;;
71;reduce.at:123;Useless Rules;report;
72;reduce.at:211;Reduced Automaton;report;
73;reduce.at:301;Underivable Rules;report;
74;reduce.at:343;Empty Language;;
75;synclines.at:83;Prologue synch line;;
76;synclines.at:100;%union synch line;;
77;synclines.at:120;Postprologue synch line;;
78;synclines.at:143;Action synch line;;
79;synclines.at:162;Epilogue synch line;;
80;headers.at:25;%union and --defines;;
81;headers.at:75;Invalid CPP guards: input/input;;
82;headers.at:76;Invalid CPP guards: 9foo;;
83;headers.at:85;export YYLTYPE;;
84;actions.at:24;Mid-rule actions;;
85;actions.at:93;Exotic Dollars;;
86;actions.at:574;Printers and Destructors : ;;
87;actions.at:575;Printers and Destructors with union: ;;
88;actions.at:577;Printers and Destructors : %defines %skeleton \"lalr1.cc\";c++;
89;actions.at:578;Printers and Destructors with union: %defines %skeleton \"lalr1.cc\";c++;
90;actions.at:580;Printers and Destructors : %glr-parser;;
91;actions.at:581;Printers and Destructors with union: %glr-parser;;
92;actions.at:592;Default tagless %printer and %destructor;;
93;actions.at:710;Default tagged and per-type %printer and %destructor;;
94;actions.at:847;Default %printer and %destructor for user-defined end token;;
95;actions.at:961;Default %printer and %destructor are not for error or \$undefined;;
96;actions.at:1071;Default %printer and %destructor are not for \$accept;;
97;actions.at:1148;Default %printer and %destructor for mid-rule values;;
98;actions.at:1304;@\$ in %initial-action implies %locations;;
99;actions.at:1305;@\$ in %destructor implies %locations;;
100;actions.at:1306;@\$ in %printer implies %locations;;
101;conflicts.at:30;S/R in initial;;
102;conflicts.at:50;%nonassoc and eof;;
103;conflicts.at:125;Unresolved SR Conflicts;report;
104;conflicts.at:232;Resolved SR Conflicts;report;
105;conflicts.at:354;Defaulted Conflicted Reduction;report;
106;conflicts.at:473;%expect not enough;;
107;conflicts.at:493;%expect right;;
108;conflicts.at:510;%expect too much;;
109;conflicts.at:530;%expect with reduce conflicts;;
110;conflicts.at:550;%no-default-prec without %prec;;
111;conflicts.at:576;%no-default-prec with %prec;;
112;conflicts.at:600;%default-prec;;
113;conflicts.at:624;Unreachable States After Conflict Resolution;;
114;conflicts.at:835;Solved conflicts report for multiple reductions in a state;;
115;conflicts.at:915;%nonassoc error actions for multiple reductions in a state;;
116;calc.at:569;Calculator ;;
117;calc.at:571;Calculator %defines;;
118;calc.at:572;Calculator %locations;;
119;calc.at:573;Calculator %name-prefix=\"calc\";;
120;calc.at:574;Calculator %verbose;;
121;calc.at:575;Calculator %yacc;;
122;calc.at:576;Calculator %error-verbose;;
123;calc.at:578;Calculator %define api.pure %locations;;
124;calc.at:579;Calculator %define api.push_pull \"both\" %define api.pure %locations;;
125;calc.at:580;Calculator %error-verbose %locations;;
126;calc.at:582;Calculator %error-verbose %locations %defines %name-prefix \"calc\" %verbose %yacc;;
127;calc.at:584;Calculator %debug;;
128;calc.at:585;Calculator %error-verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc;;
129;calc.at:587;Calculator %define api.pure %error-verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc;;
130;calc.at:588;Calculator %define api.push_pull \"both\" %define api.pure %error-verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc;;
131;calc.at:590;Calculator %define api.pure %error-verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count};;
132;calc.at:607;Calculator %glr-parser ;;
133;calc.at:609;Calculator %glr-parser %defines;;
134;calc.at:610;Calculator %glr-parser %locations;;
135;calc.at:611;Calculator %glr-parser %name-prefix \"calc\";;
136;calc.at:612;Calculator %glr-parser %verbose;;
137;calc.at:613;Calculator %glr-parser %yacc;;
138;calc.at:614;Calculator %glr-parser %error-verbose;;
139;calc.at:616;Calculator %glr-parser %define api.pure %locations;;
140;calc.at:617;Calculator %glr-parser %error-verbose %locations;;
141;calc.at:619;Calculator %glr-parser %error-verbose %locations %defines %name-prefix \"calc\" %verbose %yacc;;
142;calc.at:621;Calculator %glr-parser %debug;;
143;calc.at:622;Calculator %glr-parser %error-verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc;;
144;calc.at:624;Calculator %glr-parser %define api.pure %error-verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc;;
145;calc.at:626;Calculator %glr-parser %define api.pure %error-verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count};;
146;calc.at:636;Calculator %skeleton \"lalr1.cc\" %defines %locations;c++;
147;calc.at:645;Calculator %language \"C++\" %defines %locations ;c++;
148;calc.at:646;Calculator %language \"C++\" %defines %locations %error-verbose %name-prefix \"calc\" %verbose %yacc;c++;
149;calc.at:648;Calculator %language \"C++\" %defines %locations %error-verbose %debug %name-prefix \"calc\" %verbose %yacc;c++;
150;calc.at:650;Calculator %language \"C++\" %defines %locations %pure-parser %error-verbose %debug %name-prefix \"calc\" %verbose %yacc;c++;
151;calc.at:652;Calculator %language \"C++\" %defines %locations %pure-parser %error-verbose %debug %name-prefix \"calc\" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count};c++;
152;calc.at:663;Calculator %skeleton \"glr.cc\" %defines %locations;c++;
153;calc.at:672;Calculator %language \"C++\" %glr-parser %defines %locations ;c++;
154;calc.at:673;Calculator %language \"C++\" %glr-parser %defines %locations %error-verbose %name-prefix \"calc\" %verbose %yacc;c++;
155;calc.at:675;Calculator %language \"C++\" %glr-parser %defines %locations %debug;c++;
156;calc.at:676;Calculator %language \"C++\" %glr-parser %defines %locations %error-verbose %debug %name-prefix \"calc\" %verbose %yacc;c++;
157;calc.at:678;Calculator %language \"C++\" %glr-parser %defines %locations %pure-parser %error-verbose %debug %name-prefix \"calc\" %verbose %yacc;c++;
158;calc.at:680;Calculator %language \"C++\" %glr-parser %defines %locations %pure-parser %error-verbose %debug %name-prefix \"calc\" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count};c++;
159;torture.at:139;Big triangle;;
160;torture.at:232;Big horizontal;;
161;torture.at:372;Many lookahead tokens;;
162;torture.at:473;Exploding the Stack Size with Alloca;;
163;torture.at:519;Exploding the Stack Size with Malloc;;
164;existing.at:24;GNU AWK Grammar;;
165;existing.at:362;GNU Cim Grammar;;
166;existing.at:978;GNU pic Grammar;;
167;regression.at:26;Trivial grammars;;
168;regression.at:54;YYSTYPE typedef;;
169;regression.at:82;Early token definitions with --yacc;;
170;regression.at:120;Early token definitions without --yacc;;
171;regression.at:163;Braces parsing;;
172;regression.at:185;Duplicate string;;
173;regression.at:211;Rule Line Numbers;report;
174;regression.at:355;Mixing %token styles;;
175;regression.at:378;Invalid inputs;;
176;regression.at:405;Invalid inputs with {};;
177;regression.at:430;Token definitions;;
178;regression.at:500;Characters Escapes;;
179;regression.at:531;Web2c Report;report;
180;regression.at:708;Web2c Actions;report;
181;regression.at:954;Dancer ;;
182;regression.at:955;Dancer %glr-parser;;
183;regression.at:956;Dancer %skeleton \"lalr1.cc\";c++;
184;regression.at:1054;Expecting two tokens ;;
185;regression.at:1055;Expecting two tokens %glr-parser;;
186;regression.at:1056;Expecting two tokens %skeleton \"lalr1.cc\";c++;
187;regression.at:1064;Braced code in declaration in rules section;;
188;regression.at:1140;String alias declared after use;;
189;regression.at:1163;Extra lookahead sets in report;;
190;regression.at:1204;Token number in precedence declaration;;
191;regression.at:1265;Fix user actions without a trailing semicolon;;
192;c++.at:100;Doxygen Public Documentation;;
193;c++.at:101;Doxygen Private Documentation;;
194;c++.at:159;Relative namespace references;c++;
195;c++.at:165;Absolute namespace references;c++;
196;c++.at:174;Syntactically invalid namespace references;;
197;java.at:385;Calculator ;;
198;java.at:385;Calculator %error-verbose ;;
199;java.at:385;Calculator %locations ;;
200;java.at:385;Calculator %error-verbose %locations ;;
201;java.at:394;Calculator %lex-param { InputStream is } ;;
202;java.at:394;Calculator %error-verbose %lex-param { InputStream is } ;;
203;java.at:394;Calculator %locations %lex-param { InputStream is } ;;
204;java.at:394;Calculator %error-verbose %locations %lex-param { InputStream is } ;;
205;java.at:480;Java parser class and package names;;
206;java.at:501;Java parser class modifiers;;
207;java.at:559;Java parser class extends and implements;;
208;java.at:579;Java %parse-param and %lex-param;;
209;java.at:653;Java throws specifications;;
210;java.at:742;Java stype, position_class and location_class;;
211;cxx-type.at:413;GLR: Resolve ambiguity, impure, no locations;;
212;cxx-type.at:420;GLR: Resolve ambiguity, impure, locations;;
213;cxx-type.at:426;GLR: Resolve ambiguity, pure, no locations;;
214;cxx-type.at:433;GLR: Resolve ambiguity, pure, locations;;
215;cxx-type.at:440;GLR: Merge conflicting parses, impure, no locations;;
216;cxx-type.at:447;GLR: Merge conflicting parses, impure, locations;;
217;cxx-type.at:454;GLR: Merge conflicting parses, pure, no locations;;
218;cxx-type.at:460;GLR: Merge conflicting parses, pure, locations;;
219;cxx-type.at:467;GLR: Verbose messages, resolve ambiguity, impure, no locations;;
220;glr-regression.at:23;Badly Collapsed GLR States;;
221;glr-regression.at:118;Improper handling of embedded actions and dollar(-N) in GLR parsers;;
222;glr-regression.at:237;Improper merging of GLR delayed action sets;;
223;glr-regression.at:346;Duplicate representation of merged trees;;
224;glr-regression.at:449;User destructor for unresolved GLR semantic value;;
225;glr-regression.at:522;User destructor after an error during a split parse;;
226;glr-regression.at:589;Duplicated user destructor for lookahead;;
227;glr-regression.at:681;Incorrectly initialized location for empty right-hand side in GLR;;
228;glr-regression.at:779;No users destructors if stack 0 deleted;;
229;glr-regression.at:859;Corrupted semantic options if user action cuts parse;;
230;glr-regression.at:924;Undesirable destructors if user action cuts parse;;
231;glr-regression.at:993;Leaked semantic values if user action cuts parse;;
232;glr-regression.at:1126;Incorrect lookahead during deterministic GLR;;
233;glr-regression.at:1262;Incorrect lookahead during nondeterministic GLR;;
234;glr-regression.at:1482;Leaked semantic values when reporting ambiguity;;
235;glr-regression.at:1575;Leaked lookahead after nondeterministic parse syntax error;;
236;glr-regression.at:1644;Uninitialized location when reporting ambiguity;;
237;glr-regression.at:1731;Missed %merge type warnings when LHS type is declared later;;
238;push.at:23;Push Parsing: Memory Leak for Early Deletion;;
239;push.at:84;Push Parsing: Multiple impure instances;;
240;push.at:155;Push Parsing: Unsupported Skeletons;;
"

# at_func_validate_ranges [NAME...]
# ---------------------------------
# Validate and normalize the test group number contained in each
# variable NAME.  Leading zeroes are treated as decimal.
at_func_validate_ranges ()
{
  for at_grp
  do
    eval at_value=\$$at_grp
    if test $at_value -lt 1 || test $at_value -gt 240; then
      $as_echo "invalid test group: $at_value" >&2
      exit 1
    fi
    case $at_value in
      0*) # We want to treat leading 0 as decimal, like expr and test, but
	  # at_func_arith treats it as octal if it uses $(( )).
	  # With XSI shells, ${at_value#${at_value%%[1-9]*}} avoids the
	  # expr fork, but it is not worth the effort to determine if the
	  # shell supports XSI when the user can just avoid leading 0.
	  eval $at_grp='`expr $at_value + 0`' ;;
    esac
  done
}

at_prev=
for at_option
do
  # If the previous option needs an argument, assign it.
  if test -n "$at_prev"; then
    at_option=$at_prev=$at_option
    at_prev=
  fi

  case $at_option in
  *=*) at_optarg=`expr "x$at_option" : 'x[^=]*=\(.*\)'` ;;
  *)   at_optarg= ;;
  esac

  # Accept the important Cygnus configure options, so we can diagnose typos.

  case $at_option in
    --help | -h )
	at_help_p=:
	;;

    --list | -l )
	at_list_p=:
	;;

    --version | -V )
	at_version_p=:
	;;

    --clean | -c )
	at_clean=:
	;;

    --debug | -d )
	at_debug_p=:
	;;

    --errexit | -e )
	at_debug_p=:
	at_errexit_p=:
	;;

    --verbose | -v )
	at_verbose=; at_quiet=:
	;;

    --trace | -x )
	at_traceon='set -x'; at_traceoff='set +x'
	;;

    [0-9] | [0-9][0-9] | [0-9][0-9][0-9] | [0-9][0-9][0-9][0-9])
	at_func_validate_ranges at_option
	at_groups="$at_groups$at_option "
	;;

    # Ranges
    [0-9]- | [0-9][0-9]- | [0-9][0-9][0-9]- | [0-9][0-9][0-9][0-9]-)
	at_range_start=`echo $at_option |tr -d X-`
	at_func_validate_ranges at_range_start
	at_range=`$as_echo " $at_groups_all " | \
	  sed -e 's/^.* \('$at_range_start' \)/\1/'`
	at_groups="$at_groups$at_range "
	;;

    -[0-9] | -[0-9][0-9] | -[0-9][0-9][0-9] | -[0-9][0-9][0-9][0-9])
	at_range_end=`echo $at_option |tr -d X-`
	at_func_validate_ranges at_range_end
	at_range=`$as_echo " $at_groups_all " | \
	  sed -e 's/\( '$at_range_end'\) .*$/\1/'`
	at_groups="$at_groups$at_range "
	;;

    [0-9]-[0-9] | [0-9]-[0-9][0-9] | [0-9]-[0-9][0-9][0-9] | \
    [0-9]-[0-9][0-9][0-9][0-9] | [0-9][0-9]-[0-9][0-9] | \
    [0-9][0-9]-[0-9][0-9][0-9] | [0-9][0-9]-[0-9][0-9][0-9][0-9] | \
    [0-9][0-9][0-9]-[0-9][0-9][0-9] | \
    [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] | \
    [0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] )
	at_range_start=`expr $at_option : '\(.*\)-'`
	at_range_end=`expr $at_option : '.*-\(.*\)'`
	if test $at_range_start -gt $at_range_end; then
	  at_tmp=$at_range_end
	  at_range_end=$at_range_start
	  at_range_start=$at_tmp
	fi
	at_func_validate_ranges at_range_start at_range_end
	at_range=`$as_echo " $at_groups_all " | \
	  sed -e 's/^.*\( '$at_range_start' \)/\1/' \
	      -e 's/\( '$at_range_end'\) .*$/\1/'`
	at_groups="$at_groups$at_range "
	;;

    # Directory selection.
    --directory | -C )
	at_prev=--directory
	;;
    --directory=* )
	at_change_dir=:
	at_dir=$at_optarg
	;;

    # Keywords.
    --keywords | -k )
	at_prev=--keywords
	;;
    --keywords=* )
	at_groups_selected=$at_help_all
	at_save_IFS=$IFS
	IFS=,
	set X $at_optarg
	shift
	IFS=$at_save_IFS
	for at_keyword
	do
	  at_invert=
	  case $at_keyword in
	  '!'*)
	    at_invert="-v"
	    at_keyword=`expr "X$at_keyword" : 'X!\(.*\)'`
	    ;;
	  esac
	  # It is on purpose that we match the test group titles too.
	  at_groups_selected=`$as_echo "$at_groups_selected" |
	      grep -i $at_invert "^[1-9][^;]*;.*[; ]$at_keyword[ ;]"`
	done
	# Smash the newlines.
	at_groups_selected=`$as_echo "$at_groups_selected" | sed 's/;.*//' |
	  tr "$as_nl" ' '
	`
	at_groups="$at_groups$at_groups_selected "
	;;

    *=*)
	at_envvar=`expr "x$at_option" : 'x\([^=]*\)='`
	# Reject names that are not valid shell variable names.
	case $at_envvar in
	  '' | [0-9]* | *[!_$as_cr_alnum]* )
	    { { $as_echo "$as_me:$LINENO: error: invalid variable name: $at_envvar" >&5
$as_echo "$as_me: error: invalid variable name: $at_envvar" >&2;}
   { (exit 1); exit 1; }; } ;;
	esac
	at_value=`$as_echo "$at_optarg" | sed "s/'/'\\\\\\\\''/g"`
	# Export now, but save eval for later and for debug scripts.
	export $at_envvar
	at_debug_args="$at_debug_args $at_envvar='$at_value'"
	;;

     *) $as_echo "$as_me: invalid option: $at_option" >&2
	$as_echo "Try \`$0 --help' for more information." >&2
	exit 1
	;;
  esac
done

# Verify our last option didn't require an argument
if test -n "$at_prev"; then
  { { $as_echo "$as_me:$LINENO: error: \`$at_prev' requires an argument." >&5
$as_echo "$as_me: error: \`$at_prev' requires an argument." >&2;}
   { (exit 1); exit 1; }; }
fi


# Selected test groups.
if test -z "$at_groups"; then
  at_groups=$at_groups_all
else
  # Sort the tests, removing duplicates.
  at_groups=`$as_echo "$at_groups" | tr ' ' "$as_nl" | sort -nu`
fi

# Help message.
if $at_help_p; then
  cat <<_ATEOF || at_write_fail=1
Usage: $0 [OPTION]... [VARIABLE=VALUE]... [TESTS]

Run all the tests, or the selected TESTS, given by numeric ranges, and
save a detailed log file.  Upon failure, create debugging scripts.

You should not change environment variables unless explicitly passed
as command line arguments.  Set \`AUTOTEST_PATH' to select the executables
to exercise.  Each relative directory is expanded as build and source
directories relatively to the top level of this distribution.  E.g.,

  $ $0 AUTOTEST_PATH=bin

possibly amounts into

  PATH=/tmp/foo-1.0/bin:/src/foo-1.0/bin:\$PATH
_ATEOF
cat <<_ATEOF || at_write_fail=1

Operation modes:
  -h, --help     print the help message, then exit
  -V, --version  print version number, then exit
  -c, --clean    remove all the files this test suite might create and exit
  -l, --list     describes all the tests, or the selected TESTS
_ATEOF
cat <<_ATEOF || at_write_fail=1

Execution tuning:
  -C, --directory=DIR
                 change to directory DIR before starting
  -k, --keywords=KEYWORDS
                 select the tests matching all the comma-separated KEYWORDS
                 multiple \`-k' accumulate; prefixed \`!' negates a KEYWORD
  -e, --errexit  abort as soon as a test fails; implies --debug
  -v, --verbose  force more detailed output
                 default for debugging scripts
  -d, --debug    inhibit clean up and top-level logging
                 default for debugging scripts
  -x, --trace    enable tests shell tracing
_ATEOF
cat <<_ATEOF || at_write_fail=1

Report bugs to <bug-bison@gnu.org>.
_ATEOF
  exit $at_write_fail
fi

# List of tests.
if $at_list_p; then
  cat <<_ATEOF || at_write_fail=1
GNU Bison 2.4.1 test suite test groups:

 NUM: FILE-NAME:LINE     TEST-GROUP-NAME
      KEYWORDS

_ATEOF
  # Passing at_groups is tricky.  We cannot use it to form a literal string
  # or regexp because of the limitation of AIX awk.  And Solaris' awk
  # doesn't grok more than 99 fields in a record, so we have to use `split'.
  # at_groups needs to be space-separated for this script to work.
  case $at_groups in
    *"$as_nl"* )
      at_groups=`$as_echo "$at_groups" | tr "$as_nl" ' '` ;;
  esac
  $as_echo "$at_groups$as_nl$at_help_all" |
    awk 'BEGIN { FS = ";" }
	 NR == 1 {
	   for (n = split($ 0, a, " "); n; n--) selected[a[n]] = 1
	   next
	 }
	 {
	   if (selected[$ 1]) {
	     printf " %3d: %-18s %s\n", $ 1, $ 2, $ 3
	     if ($ 4) printf "      %s\n", $ 4
	   }
	 }' || at_write_fail=1
  exit $at_write_fail
fi
if $at_version_p; then
  $as_echo "$as_me (GNU Bison 2.4.1)" &&
  cat <<\_ACEOF || at_write_fail=1

Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
Free Software Foundation, Inc.
This test suite is free software; the Free Software Foundation gives
unlimited permission to copy, distribute and modify it.
_ACEOF
  exit $at_write_fail
fi

# Should we print banners?  at_groups is space-separated for entire test,
# newline-separated if only a subset of the testsuite is run.
case $at_groups in
  *' '*' '* | *"$as_nl"*"$as_nl"* )
      at_print_banners=: ;;
  * ) at_print_banners=false ;;
esac
# Text for banner N, set to empty once printed.
# Banner 1. input.at:18
# Category starts at test group 1.
at_banner_text_1="Input Processing."
# Banner 2. output.at:18
# Category starts at test group 25.
at_banner_text_2="Output file names."
# Banner 3. skeletons.at:17
# Category starts at test group 60.
at_banner_text_3="Skeleton Support."
# Banner 4. sets.at:57
# Category starts at test group 65.
at_banner_text_4="Grammar Sets (Firsts etc.)."
# Banner 5. reduce.at:17
# Category starts at test group 69.
at_banner_text_5="Grammar Reduction."
# Banner 6. synclines.at:17
# Category starts at test group 75.
at_banner_text_6="User Actions."
# Banner 7. headers.at:17
# Category starts at test group 80.
at_banner_text_7="Parser Headers."
# Banner 8. actions.at:18
# Category starts at test group 84.
at_banner_text_8="User Actions."
# Banner 9. conflicts.at:18
# Category starts at test group 101.
at_banner_text_9="Conflicts."
# Banner 10. calc.at:560
# Category starts at test group 116.
at_banner_text_10="Simple LALR(1) Calculator."
# Banner 11. calc.at:597
# Category starts at test group 132.
at_banner_text_11="Simple GLR Calculator."
# Banner 12. calc.at:633
# Category starts at test group 146.
at_banner_text_12="Simple LALR(1) C++ Calculator."
# Banner 13. calc.at:660
# Category starts at test group 152.
at_banner_text_13="Simple GLR C++ Calculator."
# Banner 14. torture.at:18
# Category starts at test group 159.
at_banner_text_14="Torture Tests."
# Banner 15. existing.at:19
# Category starts at test group 164.
at_banner_text_15="Existing Grammars."
# Banner 16. regression.at:19
# Category starts at test group 167.
at_banner_text_16="Regression tests."
# Banner 17. c++.at:17
# Category starts at test group 192.
at_banner_text_17="C++ Features."
# Banner 18. java.at:18
# Category starts at test group 197.
at_banner_text_18="Java Calculator."
# Banner 19. java.at:407
# Category starts at test group 205.
at_banner_text_19="Java Parameters."
# Banner 20. cxx-type.at:18
# Category starts at test group 211.
at_banner_text_20="C++ Type Syntax (GLR)."
# Banner 21. glr-regression.at:17
# Category starts at test group 220.
at_banner_text_21="GLR Regression Tests"
# Banner 22. push.at:17
# Category starts at test group 238.
at_banner_text_22="Push Parsing Tests"

# Take any -C into account.
if $at_change_dir ; then
  if test x- = "x$at_dir" ; then
    at_dir=./-
  fi
  test x != "x$at_dir" && cd "$at_dir" \
    || { { $as_echo "$as_me:$LINENO: error: unable to change directory" >&5
$as_echo "$as_me: error: unable to change directory" >&2;}
   { (exit 1); exit 1; }; }
  at_dir=`pwd`
fi

# Load the config files for any default variable assignments.
for at_file in atconfig atlocal
do
  test -r $at_file || continue
  . ./$at_file || { { $as_echo "$as_me:$LINENO: error: invalid content: $at_file" >&5
$as_echo "$as_me: error: invalid content: $at_file" >&2;}
   { (exit 1); exit 1; }; }
done

# Autoconf <=2.59b set at_top_builddir instead of at_top_build_prefix:
: ${at_top_build_prefix=$at_top_builddir}

# Perform any assignments requested during argument parsing.
eval "$at_debug_args"

# atconfig delivers names relative to the directory the test suite is
# in, but the groups themselves are run in testsuite-dir/group-dir.
if test -n "$at_top_srcdir"; then
  builddir=../..
  for at_dir_var in srcdir top_srcdir top_build_prefix
  do
    at_val=`eval 'as_val=${'at_$at_dir_var'}
		 $as_echo "$as_val"'`
    case $at_val in
      [\\/$]* | ?:[\\/]* ) at_prefix= ;;
      *) at_prefix=../../ ;;
    esac
    eval "$at_dir_var=\$at_prefix\$at_val"
  done
fi

## ------------------- ##
## Directory structure ##
## ------------------- ##

# This is the set of directories and files used by this script
# (non-literals are capitalized):
#
# TESTSUITE         - the testsuite
# TESTSUITE.log     - summarizes the complete testsuite run
# TESTSUITE.dir/    - created during a run, remains after -d or failed test
# + at-groups/      - during a run: status of all groups in run
# | + NNN/          - during a run: meta-data about test group NNN
# | | + check-line  - location (source file and line) of current AT_CHECK
# | | + status      - exit status of current AT_CHECK
# | | + stdout      - stdout of current AT_CHECK
# | | + stder1      - stderr, including trace
# | | + stderr      - stderr, with trace filtered out
# | | + test-source - portion of testsuite that defines group
# | | + times       - timestamps for computing duration
# | | + pass        - created if group passed
# | | + xpass       - created if group xpassed
# | | + fail        - created if group failed
# | | + xfail       - created if group xfailed
# | | + skip        - created if group skipped
# + at-stop         - during a run: end the run if this file exists
# + at-source-lines - during a run: cache of TESTSUITE line numbers for extraction
# + 0..NNN/         - created for each group NNN, remains after -d or failed test
# | + TESTSUITE.log - summarizes the group results
# | + ...           - files created during the group

# The directory the whole suite works in.
# Should be absolute to let the user `cd' at will.
at_suite_dir=$at_dir/$as_me.dir
# The file containing the suite.
at_suite_log=$at_dir/$as_me.log
# The directory containing helper files per test group.
at_helper_dir=$at_suite_dir/at-groups
# Stop file: if it exists, do not start new jobs.
at_stop_file=$at_suite_dir/at-stop

if $at_clean; then
  test -d "$at_suite_dir" &&
    find "$at_suite_dir" -type d ! -perm -700 -exec chmod u+rwx \{\} \;
  rm -f -r "$at_suite_dir" "$at_suite_log"
  exit $?
fi

# Don't take risks: use only absolute directories in PATH.
#
# For stand-alone test suites (ie. atconfig was not found),
# AUTOTEST_PATH is relative to `.'.
#
# For embedded test suites, AUTOTEST_PATH is relative to the top level
# of the package.  Then expand it into build/src parts, since users
# may create executables in both places.
AUTOTEST_PATH=`$as_echo "$AUTOTEST_PATH" | sed "s|:|$PATH_SEPARATOR|g"`
at_path=
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $AUTOTEST_PATH $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  test -n "$at_path" && at_path=$at_path$PATH_SEPARATOR
case $as_dir in
  [\\/]* | ?:[\\/]* )
    at_path=$at_path$as_dir
    ;;
  * )
    if test -z "$at_top_build_prefix"; then
      # Stand-alone test suite.
      at_path=$at_path$as_dir
    else
      # Embedded test suite.
      at_path=$at_path$at_top_build_prefix$as_dir$PATH_SEPARATOR
      at_path=$at_path$at_top_srcdir/$as_dir
    fi
    ;;
esac
done
IFS=$as_save_IFS


# Now build and simplify PATH.
#
# There might be directories that don't exist, but don't redirect
# builtins' (eg., cd) stderr directly: Ultrix's sh hates that.
at_new_path=
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $at_path
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  test -d "$as_dir" || continue
case $as_dir in
  [\\/]* | ?:[\\/]* ) ;;
  * ) as_dir=`(cd "$as_dir" && pwd) 2>/dev/null` ;;
esac
case $PATH_SEPARATOR$at_new_path$PATH_SEPARATOR in
  *$PATH_SEPARATOR$as_dir$PATH_SEPARATOR*) ;;
  $PATH_SEPARATOR$PATH_SEPARATOR) at_new_path=$as_dir ;;
  *) at_new_path=$at_new_path$PATH_SEPARATOR$as_dir ;;
esac
done
IFS=$as_save_IFS

PATH=$at_new_path
export PATH

# Setting up the FDs.
# 5 is the log file.  Not to be overwritten if `-d'.
if $at_debug_p; then
  at_suite_log=/dev/null
else
  : >"$at_suite_log"
fi
exec 5>>"$at_suite_log"

# Banners and logs.
cat <<\_ASBOX
## --------------------------- ##
## GNU Bison 2.4.1 test suite. ##
## --------------------------- ##
_ASBOX
{
  cat <<\_ASBOX
## --------------------------- ##
## GNU Bison 2.4.1 test suite. ##
## --------------------------- ##
_ASBOX
  echo

  $as_echo "$as_me: command line was:"
  $as_echo "  \$ $0 $at_cli_args"
  echo

  # Try to find a few ChangeLogs in case it might help determining the
  # exact version.  Use the relative dir: if the top dir is a symlink,
  # find will not follow it (and options to follow the links are not
  # portable), which would result in no output here.  Prune directories
  # matching the package tarname, since they tend to be leftovers from
  # `make dist' or `make distcheck' and contain redundant or stale logs.
  if test -n "$at_top_srcdir"; then
    cat <<\_ASBOX
## ----------- ##
## ChangeLogs. ##
## ----------- ##
_ASBOX
    echo
    for at_file in `find "$at_top_srcdir" -name "bison-*" -prune -o -name ChangeLog -print`
    do
      $as_echo "$as_me: $at_file:"
      sed 's/^/| /;10q' $at_file
      echo
    done

  fi

  {
cat <<_ASUNAME
## --------- ##
## Platform. ##
## --------- ##

hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
uname -m = `(uname -m) 2>/dev/null || echo unknown`
uname -r = `(uname -r) 2>/dev/null || echo unknown`
uname -s = `(uname -s) 2>/dev/null || echo unknown`
uname -v = `(uname -v) 2>/dev/null || echo unknown`

/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`

/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`

_ASUNAME

as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  $as_echo "PATH: $as_dir"
done
IFS=$as_save_IFS

}
  echo

  # Contents of the config files.
  for at_file in atconfig atlocal
  do
    test -r $at_file || continue
    $as_echo "$as_me: $at_file:"
    sed 's/^/| /' $at_file
    echo
  done
} >&5


## --------------- ##
## Shell functions ##
## --------------- ##

# at_func_banner NUMBER
# ---------------------
# Output banner NUMBER, provided the testsuite is running multiple groups
# and this particular banner has not yet been printed.
at_func_banner ()
{
  $at_print_banners || return 0
  eval at_banner_text=\$at_banner_text_$1
  test "x$at_banner_text" = x && return 0
  eval at_banner_text_$1=
  $as_echo "$as_nl$at_banner_text$as_nl"
} # at_func_banner

# at_func_check_newline COMMAND
# -----------------------------
# Test if COMMAND includes a newline and, if so, print a message and return
# exit code 1
at_func_check_newline ()
{
  case "$1" in
 *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)'
    return 1 ;;
 *) return 0 ;;
  esac
}

# at_func_filter_trace EXIT-CODE
# ------------------------------
# Split the contents of file "$at_stder1" into the "set -x" trace (on stderr)
# and the other lines (on file "$at_stderr").  Return the exit code EXIT-CODE.
at_func_filter_trace ()
{
  grep '^ *+' "$at_stder1" >&2
  grep -v '^ *+' "$at_stder1" >"$at_stderr"
  return $1
}

# at_func_log_failure FILE-LIST
# -----------------------------
# Copy the files in the list on stdout with a "> " prefix, and exit the shell
# with a failure exit code.
at_func_log_failure ()
{
  for file
    do $as_echo "$file:"; sed 's/^/> /' "$file"; done
  echo 1 > "$at_status_file"
  exit 1
}

# at_func_check_skip EXIT-CODE
# ----------------------------
# Check whether EXIT-CODE is the special exit code 77, and if so exit the shell
# with that same exit code.
at_func_check_skip ()
{
  case $1 in
    77) echo 77 > "$at_status_file"; exit 77;;
  esac
}

# at_func_check_status EXPECTED EXIT-CODE LINE
# --------------------------------------------
# Check whether EXIT-CODE is the expected exit code, and if so do nothing.
# Otherwise, if it is 77 exit the shell with that same exit code; if it is
# anything else print an error message and fail the test.
at_func_check_status ()
{
  case $2 in
    $1 ) ;;
    77) echo 77 > "$at_status_file"; exit 77;;
    *) $as_echo "$3: exit code was $2, expected $1"
      at_failed=:;;
  esac
}

# at_func_diff_devnull FILE
# -------------------------
# Emit a diff between /dev/null and FILE.  Uses "test -s" to avoid useless
# diff invocations.
at_func_diff_devnull ()
{
  test -s "$1" || return 0
  $at_diff "$at_devnull" "$1"
}

# at_func_test NUMBER
# -------------------
# Parse out test NUMBER from the tail of this file.
at_func_test ()
{
  eval at_sed=\$at_sed$1
  sed "$at_sed" "$at_myself" > "$at_test_source"
}

# at_func_create_debugging_script
# -------------------------------
# Create the debugging script $at_group_dir/run which will reproduce the
# current test group.
at_func_create_debugging_script ()
{
  {
    echo "#! /bin/sh" &&
    echo 'test "${ZSH_VERSION+set}" = set && alias -g '\''${1+"$@"}'\''='\''"$@"'\''' &&
    $as_echo "cd '$at_dir'" &&
    $as_echo "exec \${CONFIG_SHELL-$SHELL} \"$at_myself\" -v -d $at_debug_args $at_group \${1+\"\$@\"}" &&
    echo 'exit 1'
  } >"$at_group_dir/run" &&
  chmod +x "$at_group_dir/run"
}

# at_func_arith
# -------------
# Arithmetic evaluation, avoids expr if the shell is sane.  The
# interpretation of leading zeroes is unspecified.
#
# subshell and eval are needed to keep Solaris sh from bailing out:
if ( eval 'test $(( 1 + 1 )) = 2' ) 2>/dev/null; then
  # With "$@", bash does not split positional parameters:
  eval 'at_func_arith ()
  {
    at_func_arith_result=$(( $* ))
  }'
else
  at_func_arith ()
  {
    at_func_arith_result=`expr "$@"`
  }
fi

## ---------------------- ##
## End of shell functions ##
## ---------------------- ##
{
  cat <<\_ASBOX
## ---------------- ##
## Tested programs. ##
## ---------------- ##
_ASBOX
  echo
} >&5

# Report what programs are being tested.
for at_program in : $at_tested
do
  test "$at_program" = : && continue
  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  test -f "$as_dir/$at_program" && break
done
IFS=$as_save_IFS

  if test -f "$as_dir/$at_program"; then
    {
      $as_echo "$at_srcdir/local.at:323: $as_dir/$at_program --version"
      "$as_dir/$at_program" --version </dev/null
      echo
    } >&5 2>&1
  else
    { { $as_echo "$as_me:$LINENO: error: cannot find $at_program" >&5
$as_echo "$as_me: error: cannot find $at_program" >&2;}
   { (exit 1); exit 1; }; }
  fi
done

{
  cat <<\_ASBOX
## ------------------ ##
## Running the tests. ##
## ------------------ ##
_ASBOX
} >&5

at_start_date=`date`
at_start_time=`date +%s 2>/dev/null`
$as_echo "$as_me: starting at: $at_start_date" >&5

# Create the master directory if it doesn't already exist.
test -d "$at_suite_dir" ||
  mkdir "$at_suite_dir" ||
  { { $as_echo "$as_me:$LINENO: error: cannot create '$at_suite_dir'" >&5
$as_echo "$as_me: error: cannot create '$at_suite_dir'" >&2;}
   { (exit 1); exit 1; }; }

# Can we diff with `/dev/null'?  DU 5.0 refuses.
if diff /dev/null /dev/null >/dev/null 2>&1; then
  at_devnull=/dev/null
else
  at_devnull=$at_suite_dir/devnull
  >"$at_devnull"
fi

# Use `diff -u --strip-trailing-cr' when possible.
if at_diff=`diff -u --strip-trailing-cr "$at_devnull" "$at_devnull" 2>&1` && test -z "$at_diff"
then
  at_diff='diff -u --strip-trailing-cr'
else
  at_diff=diff
fi

# Get the last needed group.
for at_group in : $at_groups; do :; done

# Extract the start and end lines of each test group at the tail
# of this file
awk '
BEGIN { FS="" }
/^#AT_START_/ {
  start = NR
}
/^#AT_STOP_/ {
  test = substr ($ 0, 10)
  print "at_sed" test "=\"1," start "d;" (NR-1) "q\""
  if (test == "'"$at_group"'") exit
}' "$at_myself" > "$at_suite_dir/at-source-lines" &&
. "$at_suite_dir/at-source-lines" ||
  { { $as_echo "$as_me:$LINENO: error: cannot create test line number cache" >&5
$as_echo "$as_me: error: cannot create test line number cache" >&2;}
   { (exit 1); exit 1; }; }
rm -f "$at_suite_dir/at-source-lines"

# Set up helper dirs.
rm -rf "$at_helper_dir" &&
mkdir "$at_helper_dir" &&
cd "$at_helper_dir" &&
{ test -z "$at_groups" || mkdir $at_groups; } ||
{ { $as_echo "$as_me:$LINENO: error: testsuite directory setup failed" >&5
$as_echo "$as_me: error: testsuite directory setup failed" >&2;}
   { (exit 1); exit 1; }; }

# Functions for running a test group.  We leave the actual
# test group execution outside of a shell function in order
# to avoid hitting zsh 4.x exit status bugs.

# at_func_group_prepare
# ---------------------
# Prepare running a test group
at_func_group_prepare ()
{
  # The directory for additional per-group helper files.
  at_job_dir=$at_helper_dir/$at_group
  # The file containing the location of the last AT_CHECK.
  at_check_line_file=$at_job_dir/check-line
  # The file containing the exit status of the last command.
  at_status_file=$at_job_dir/status
  # The files containing the output of the tested commands.
  at_stdout=$at_job_dir/stdout
  at_stder1=$at_job_dir/stder1
  at_stderr=$at_job_dir/stderr
  # The file containing the code for a test group.
  at_test_source=$at_job_dir/test-source
  # The file containing dates.
  at_times_file=$at_job_dir/times

  # Be sure to come back to the top test directory.
  cd "$at_suite_dir"

  # Clearly separate the test groups when verbose.
  $at_first || $at_verbose echo

  at_group_normalized=$at_group

  eval 'while :; do
    case $at_group_normalized in #(
    '"$at_format"'*) break;;
    esac
    at_group_normalized=0$at_group_normalized
  done'


  # Create a fresh directory for the next test group, and enter.
  at_group_dir=$at_suite_dir/$at_group_normalized
  at_group_log=$at_group_dir/$as_me.log
  if test -d "$at_group_dir"; then
    find "$at_group_dir" -type d ! -perm -700 -exec chmod u+rwx \{\} \;
    rm -fr "$at_group_dir" ||
    { $as_echo "$as_me:$LINENO: WARNING: test directory for $at_group_normalized could not be cleaned." >&5
$as_echo "$as_me: WARNING: test directory for $at_group_normalized could not be cleaned." >&2;}
  fi
  # Be tolerant if the above `rm' was not able to remove the directory.
  { as_dir="$at_group_dir"
  case $as_dir in #(
  -*) as_dir=./$as_dir;;
  esac
  test -d "$as_dir" || { $as_mkdir_p && mkdir -p "$as_dir"; } || {
    as_dirs=
    while :; do
      case $as_dir in #(
      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
      *) as_qdir=$as_dir;;
      esac
      as_dirs="'$as_qdir' $as_dirs"
      as_dir=`$as_dirname -- "$as_dir" ||
$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 X"$as_dir" : 'X\(//\)[^/]' \| \
	 X"$as_dir" : 'X\(//\)$' \| \
	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X"$as_dir" |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)[^/].*/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`
      test -d "$as_dir" && break
    done
    test -z "$as_dirs" || eval "mkdir $as_dirs"
  } || test -d "$as_dir" || { { $as_echo "$as_me:$LINENO: error: cannot create directory $as_dir" >&5
$as_echo "$as_me: error: cannot create directory $as_dir" >&2;}
   { (exit 1); exit 1; }; }; }

  echo 0 > "$at_status_file"

  # In verbose mode, append to the log file *and* show on
  # the standard output; in quiet mode only write to the log.
  if test -z "$at_verbose"; then
    at_tee_pipe='tee -a "$at_group_log"'
  else
    at_tee_pipe='cat >> "$at_group_log"'
  fi
}

# at_func_group_postprocess
# -------------------------
at_func_group_postprocess ()
{
  # Be sure to come back to the suite directory, in particular
  # since below we might `rm' the group directory we are in currently.
  cd "$at_suite_dir"

  if test ! -f "$at_check_line_file"; then
    sed "s/^ */$as_me: WARNING: /" <<_ATEOF
      A failure happened in a test group before any test could be
      run. This means that test suite is improperly designed.  Please
      report this failure to <bug-bison@gnu.org>.
_ATEOF
    $as_echo "$at_setup_line" >"$at_check_line_file"
  fi
  $at_verbose $as_echo_n "$at_group. $at_setup_line: "
  $as_echo_n "$at_group. $at_setup_line: " >> "$at_group_log"
  case $at_xfail:$at_status in
    yes:0)
	at_msg="UNEXPECTED PASS"
	at_res=xpass
	at_errexit=$at_errexit_p
	;;
    no:0)
	at_msg="ok"
	at_res=pass
	at_errexit=false
	;;
    *:77)
	at_msg='skipped ('`cat "$at_check_line_file"`')'
	at_res=skip
	at_errexit=false
	;;
    yes:*)
	at_msg='expected failure ('`cat "$at_check_line_file"`')'
	at_res=xfail
	at_errexit=false
	;;
    no:*)
	at_msg='FAILED ('`cat "$at_check_line_file"`')'
	at_res=fail
	at_errexit=$at_errexit_p
	;;
  esac
  echo "$at_res" > "$at_job_dir/$at_res"
  # Make sure there is a separator even with long titles.
  $as_echo " $at_msg"
  at_log_msg="$at_group. $at_desc ($at_setup_line): $at_msg"
  case $at_status in
    0|77)
      # $at_times_file is only available if the group succeeded.
      # We're not including the group log, so the success message
      # is written in the global log separately.  But we also
      # write to the group log in case they're using -d.
      if test -f "$at_times_file"; then
	at_log_msg="$at_log_msg     ("`sed 1d "$at_times_file"`')'
	rm -f "$at_times_file"
      fi
      $as_echo "$at_log_msg" >> "$at_group_log"
      $as_echo "$at_log_msg" >&5

      # Cleanup the group directory, unless the user wants the files.
      if $at_debug_p; then
	at_func_create_debugging_script
      else
	if test -d "$at_group_dir"; then
	  find "$at_group_dir" -type d ! -perm -700 -exec chmod u+rwx \{\} \;
	  rm -fr "$at_group_dir"
	fi
	rm -f "$at_test_source"
      fi
      ;;
    *)
      # Upon failure, include the log into the testsuite's global
      # log.  The failure message is written in the group log.  It
      # is later included in the global log.
      $as_echo "$at_log_msg" >> "$at_group_log"

      # Upon failure, keep the group directory for autopsy, and create
      # the debugging script.  With -e, do not start any further tests.
      at_func_create_debugging_script
      if $at_errexit; then
	echo stop > "$at_stop_file"
      fi
      ;;
  esac
}


## ------------ ##
## Driver loop. ##
## ------------ ##

rm -f "$at_stop_file"
at_first=:

for at_group in $at_groups; do
  at_func_group_prepare
  if cd "$at_group_dir" &&
     at_func_test $at_group &&
     . "$at_test_source"; then :; else
    { $as_echo "$as_me:$LINENO: WARNING: unable to parse test group: $at_group" >&5
$as_echo "$as_me: WARNING: unable to parse test group: $at_group" >&2;}
    at_failed=:
  fi
  at_func_group_postprocess
  test -f "$at_stop_file" && break
  at_first=false
done

# Wrap up the test suite with summary statistics.
cd "$at_helper_dir"

# Use ?..???? when the list must remain sorted, the faster * otherwise.
at_pass_list=`for f in */pass; do echo $f; done | sed '/\*/d; s,/pass,,'`
at_skip_list=`for f in */skip; do echo $f; done | sed '/\*/d; s,/skip,,'`
at_xfail_list=`for f in */xfail; do echo $f; done | sed '/\*/d; s,/xfail,,'`
at_xpass_list=`for f in ?/xpass ??/xpass ???/xpass ????/xpass; do
		 echo $f; done | sed '/?/d; s,/xpass,,'`
at_fail_list=`for f in ?/fail ??/fail ???/fail ????/fail; do
		echo $f; done | sed '/?/d; s,/fail,,'`

set X $at_pass_list $at_xpass_list $at_xfail_list $at_fail_list $at_skip_list
shift; at_group_count=$#
set X $at_xpass_list; shift; at_xpass_count=$#; at_xpass_list=$*
set X $at_xfail_list; shift; at_xfail_count=$#
set X $at_fail_list; shift; at_fail_count=$#; at_fail_list=$*
set X $at_skip_list; shift; at_skip_count=$#

at_func_arith $at_group_count - $at_skip_count
at_run_count=$at_func_arith_result
at_func_arith $at_xpass_count + $at_fail_count
at_unexpected_count=$at_func_arith_result
at_func_arith $at_xfail_count + $at_fail_count
at_total_fail_count=$at_func_arith_result

# Back to the top directory.
cd "$at_dir"
rm -rf "$at_helper_dir"

# Compute the duration of the suite.
at_stop_date=`date`
at_stop_time=`date +%s 2>/dev/null`
$as_echo "$as_me: ending at: $at_stop_date" >&5
case $at_start_time,$at_stop_time in
  [0-9]*,[0-9]*)
    at_func_arith $at_stop_time - $at_start_time
    at_duration_s=$at_func_arith_result
    at_func_arith $at_duration_s / 60
    at_duration_m=$at_func_arith_result
    at_func_arith $at_duration_m / 60
    at_duration_h=$at_func_arith_result
    at_func_arith $at_duration_s % 60
    at_duration_s=$at_func_arith_result
    at_func_arith $at_duration_m % 60
    at_duration_m=$at_func_arith_result
    at_duration="${at_duration_h}h ${at_duration_m}m ${at_duration_s}s"
    $as_echo "$as_me: test suite duration: $at_duration" >&5
    ;;
esac

echo
cat <<\_ASBOX
## ------------- ##
## Test results. ##
## ------------- ##
_ASBOX
echo
{
  echo
  cat <<\_ASBOX
## ------------- ##
## Test results. ##
## ------------- ##
_ASBOX
  echo
} >&5

if test $at_run_count = 1; then
  at_result="1 test"
  at_were=was
else
  at_result="$at_run_count tests"
  at_were=were
fi
if $at_errexit_p && test $at_unexpected_count != 0; then
  if test $at_xpass_count = 1; then
    at_result="$at_result $at_were run, one passed"
  else
    at_result="$at_result $at_were run, one failed"
  fi
  at_result="$at_result unexpectedly and inhibited subsequent tests."
else
  # Don't you just love exponential explosion of the number of cases?
  case $at_xpass_count:$at_fail_count:$at_xfail_count in
    # So far, so good.
    0:0:0) at_result="$at_result $at_were successful." ;;
    0:0:*) at_result="$at_result behaved as expected." ;;

    # Some unexpected failures
    0:*:0) at_result="$at_result $at_were run,
$at_fail_count failed unexpectedly." ;;

    # Some failures, both expected and unexpected
    0:*:1) at_result="$at_result $at_were run,
$at_total_fail_count failed ($at_xfail_count expected failure)." ;;
    0:*:*) at_result="$at_result $at_were run,
$at_total_fail_count failed ($at_xfail_count expected failures)." ;;

    # No unexpected failures, but some xpasses
    *:0:*) at_result="$at_result $at_were run,
$at_xpass_count passed unexpectedly." ;;

    # No expected failures, but failures and xpasses
    *:1:0) at_result="$at_result $at_were run,
$at_unexpected_count did not behave as expected ($at_fail_count unexpected failure)." ;;
    *:*:0) at_result="$at_result $at_were run,
$at_unexpected_count did not behave as expected ($at_fail_count unexpected failures)." ;;

    # All of them.
    *:*:1) at_result="$at_result $at_were run,
$at_xpass_count passed unexpectedly,
$at_total_fail_count failed ($at_xfail_count expected failure)." ;;
    *:*:*) at_result="$at_result $at_were run,
$at_xpass_count passed unexpectedly,
$at_total_fail_count failed ($at_xfail_count expected failures)." ;;
  esac

  if test $at_skip_count = 0 && test $at_run_count -gt 1; then
    at_result="All $at_result"
  fi
fi

# Now put skips in the mix.
case $at_skip_count in
  0) ;;
  1) at_result="$at_result
1 test was skipped." ;;
  *) at_result="$at_result
$at_skip_count tests were skipped." ;;
esac

if test $at_unexpected_count = 0; then
  echo "$at_result"
  echo "$at_result" >&5
else
  echo "ERROR: $at_result" >&2
  echo "ERROR: $at_result" >&5
  {
    echo
    cat <<\_ASBOX
## ------------------------ ##
## Summary of the failures. ##
## ------------------------ ##
_ASBOX

    # Summary of failed and skipped tests.
    if test $at_fail_count != 0; then
      echo "Failed tests:"
      $SHELL "$at_myself" $at_fail_list --list
      echo
    fi
    if test $at_skip_count != 0; then
      echo "Skipped tests:"
      $SHELL "$at_myself" $at_skip_list --list
      echo
    fi
    if test $at_xpass_count != 0; then
      echo "Unexpected passes:"
      $SHELL "$at_myself" $at_xpass_list --list
      echo
    fi
    if test $at_fail_count != 0; then
      cat <<\_ASBOX
## ---------------------- ##
## Detailed failed tests. ##
## ---------------------- ##
_ASBOX
      echo
      for at_group in $at_fail_list
      do
	at_group_normalized=$at_group

  eval 'while :; do
    case $at_group_normalized in #(
    '"$at_format"'*) break;;
    esac
    at_group_normalized=0$at_group_normalized
  done'

	cat "$at_suite_dir/$at_group_normalized/$as_me.log"
	echo
      done
      echo
    fi
    if test -n "$at_top_srcdir"; then
      sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## ${at_top_build_prefix}config.log ##
_ASBOX
      sed 's/^/| /' ${at_top_build_prefix}config.log
      echo
    fi
  } >&5

  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $as_me.log was created. ##
_ASBOX

  echo
  $as_echo "Please send \`${at_testdir+${at_testdir}/}$as_me.log' and all information you think might help:

   To: <bug-bison@gnu.org>
   Subject: [GNU Bison 2.4.1] $as_me: $at_fail_list${at_fail_list:+ failed${at_xpass_list:+, }}$at_xpass_list${at_xpass_list:+ passed unexpectedly}
"
  if test $at_debug_p = false; then
    echo
    echo 'You may investigate any problem if you feel able to do so, in which'
    echo 'case the test suite provides a good starting point.  Its output may'
    $as_echo "be found below \`${at_testdir+${at_testdir}/}$as_me.dir'."
    echo
  fi
    exit 1
fi

exit 0

## ------------- ##
## Actual tests. ##
## ------------- ##
#AT_START_1
# 1. input.at:27: Invalid $n and @n
at_setup_line='input.at:27'
at_func_banner 1
at_desc="Invalid \$n and @n"
$at_quiet $as_echo_n "  1: $at_desc                              "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "1. input.at:27: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%%
exp: { $$ = $1 ; };
exp: { @$ = @1 ; };
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/input.at:35: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
echo input.at:35 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:2.13-14: integer out of range: \`\$1'
input.y:3.13-14: integer out of range: \`@1'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/input.at:35"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_1
#AT_START_2
# 2. input.at:47: Type Clashes
at_setup_line='input.at:47'
at_func_banner 1
at_desc="Type Clashes"
$at_quiet $as_echo_n "  2: $at_desc                                   "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "2. input.at:47: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%union { int bar; }
%token foo
%type <bar> exp
%%
exp: foo { $$; } foo { $2; } foo
   | foo
   | /* Empty. */
   ;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/input.at:60: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
echo input.at:60 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:5.12-13: \$\$ for the midrule at \$2 of \`exp' has no declared type
input.y:5.24-25: \$2 of \`exp' has no declared type
input.y:5.6-32: warning: type clash on default action: <bar> != <>
input.y:6.6-8: warning: type clash on default action: <bar> != <>
input.y:7.5: warning: empty rule for typed nonterminal, and no action
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/input.at:60"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_2
#AT_START_3
# 3. input.at:161: Unused values
at_setup_line='input.at:161'
at_func_banner 1
at_desc="Unused values"
$at_quiet $as_echo_n "  3: $at_desc                                  "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "3. input.at:161: testing ..."
  $at_traceon

cat >input.y <<'_ATEOF'
%token <integer> INT;
%type <integer> a b c d e f g h i j k l;
%destructor { destroy ($$); } INT a b c d e f g h i j k l;
%%
start:
  'a' a { $2 } | 'b' b { $2 } | 'c' c { $2 } | 'd' d { $2 } | 'e' e { $2 }
| 'f' f { $2 } | 'g' g { $2 } | 'h' h { $2 } | 'i' i { $2 } | 'j' j { $2 }
| 'k' k { $2 } | 'l' l { $2 }
;

a: INT | INT { } INT { } INT { };
b: INT | /* empty */;
c: INT | INT { $1 } INT { $<integer>2 } INT { $<integer>4 };
d: INT | INT { } INT { $1 } INT { $<integer>2 };
e: INT | INT { } INT {  } INT { $1 };
f: INT | INT { } INT {  } INT { $$ = $1 + $3 + $5; };
g: INT | INT { $<integer>$; } INT { $<integer>$; } INT { };
h: INT | INT { $<integer>$; } INT { $<integer>$ = $<integer>2; } INT { };
i: INT | INT INT { } { $$ = $1 + $2; };
j: INT | INT INT { $<integer>$ = 1; } { $$ = $1 + $2; };
k: INT | INT INT { $<integer>$; } { $<integer>$ = $<integer>3; } { };
l: INT | INT { $<integer>$ = $<integer>1; } INT { $<integer>$ = $<integer>2 + $<integer>3; } INT { $<integer>$ = $<integer>4 + $<integer>5; };
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/input.at:162: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  input.y"
echo input.at:162 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:162"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/input.at:162: bison --xml=xml-tests/test.xml  input.y"
echo input.at:162 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml  input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml  input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:162"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:162: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo input.at:162 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:162"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:162: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo input.at:162 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:162"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/input.at:162: bison  input.y"
echo input.at:162 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison  input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison  input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:11.10-32: warning: unset value: \$\$
input.y:11.10-32: warning: unused value: \$1
input.y:11.10-32: warning: unused value: \$3
input.y:11.10-32: warning: unused value: \$5
input.y:12.9: warning: empty rule for typed nonterminal, and no action
input.y:13.10-59: warning: unset value: \$\$
input.y:13.10-59: warning: unused value: \$3
input.y:13.10-59: warning: unused value: \$5
input.y:14.10-47: warning: unset value: \$\$
input.y:14.10-47: warning: unused value: \$3
input.y:14.10-47: warning: unused value: \$5
input.y:15.10-36: warning: unset value: \$\$
input.y:15.10-36: warning: unused value: \$3
input.y:15.10-36: warning: unused value: \$5
input.y:17.10-58: warning: unset value: \$\$
input.y:17.10-58: warning: unused value: \$1
input.y:17.10-58: warning: unused value: \$3
input.y:17.10-58: warning: unused value: \$5
input.y:18.10-72: warning: unset value: \$\$
input.y:18.10-72: warning: unused value: \$1
input.y:18.10-72: warning: unused value: \$3
input.y:18.10-72: warning: unused value: \$5
input.y:21.10-68: warning: unset value: \$\$
input.y:21.10-68: warning: unused value: \$1
input.y:21.10-68: warning: unused value: \$2
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:162"

$at_failed && at_func_log_failure
$at_traceon; }

cat >input.y <<'_ATEOF'
%token <integer> INT;
%type <integer> a b c d e f g h i j k l;
%destructor { destroy ($$); } INT a b c d e f g h i j k l;
%%
start:
  'a' a { $2 } | 'b' b { $2 } | 'c' c { $2 } | 'd' d { $2 } | 'e' e { $2 }
| 'f' f { $2 } | 'g' g { $2 } | 'h' h { $2 } | 'i' i { $2 } | 'j' j { $2 }
| 'k' k { $2 } | 'l' l { $2 }
;

a: INT | INT { } INT { } INT { };
b: INT | /* empty */;
c: INT | INT { $1 } INT { $<integer>2 } INT { $<integer>4 };
d: INT | INT { } INT { $1 } INT { $<integer>2 };
e: INT | INT { } INT {  } INT { $1 };
f: INT | INT { } INT {  } INT { $$ = $1 + $3 + $5; };
g: INT | INT { $<integer>$; } INT { $<integer>$; } INT { };
h: INT | INT { $<integer>$; } INT { $<integer>$ = $<integer>2; } INT { };
i: INT | INT INT { } { $$ = $1 + $2; };
j: INT | INT INT { $<integer>$ = 1; } { $$ = $1 + $2; };
k: INT | INT INT { $<integer>$; } { $<integer>$ = $<integer>3; } { };
l: INT | INT { $<integer>$ = $<integer>1; } INT { $<integer>$ = $<integer>2 + $<integer>3; } INT { $<integer>$ = $<integer>4 + $<integer>5; };
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/input.at:163: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  --warnings=midrule-values  input.y"
echo input.at:163 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  --warnings=midrule-values  input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  --warnings=midrule-values  input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:163"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/input.at:163: bison --xml=xml-tests/test.xml  --warnings=midrule-values  input.y"
echo input.at:163 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml  --warnings=midrule-values  input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml  --warnings=midrule-values  input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:163"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:163: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo input.at:163 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:163"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:163: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo input.at:163 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:163"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/input.at:163: bison  --warnings=midrule-values  input.y"
echo input.at:163 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison  --warnings=midrule-values  input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison  --warnings=midrule-values  input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:11.10-32: warning: unset value: \$\$
input.y:11.10-32: warning: unused value: \$1
input.y:11.10-32: warning: unused value: \$3
input.y:11.10-32: warning: unused value: \$5
input.y:12.9: warning: empty rule for typed nonterminal, and no action
input.y:13.14-19: warning: unset value: \$\$
input.y:13.25-39: warning: unset value: \$\$
input.y:13.10-59: warning: unset value: \$\$
input.y:13.10-59: warning: unused value: \$3
input.y:13.10-59: warning: unused value: \$5
input.y:14.14-16: warning: unset value: \$\$
input.y:14.10-47: warning: unset value: \$\$
input.y:14.10-47: warning: unused value: \$3
input.y:14.10-47: warning: unused value: \$5
input.y:15.10-36: warning: unset value: \$\$
input.y:15.10-36: warning: unused value: \$3
input.y:15.10-36: warning: unused value: \$5
input.y:17.10-58: warning: unset value: \$\$
input.y:17.10-58: warning: unused value: \$1
input.y:17.10-58: warning: unused value: \$2
input.y:17.10-58: warning: unused value: \$3
input.y:17.10-58: warning: unused value: \$4
input.y:17.10-58: warning: unused value: \$5
input.y:18.10-72: warning: unset value: \$\$
input.y:18.10-72: warning: unused value: \$1
input.y:18.10-72: warning: unused value: \$3
input.y:18.10-72: warning: unused value: \$4
input.y:18.10-72: warning: unused value: \$5
input.y:20.10-55: warning: unused value: \$3
input.y:21.10-68: warning: unset value: \$\$
input.y:21.10-68: warning: unused value: \$1
input.y:21.10-68: warning: unused value: \$2
input.y:21.10-68: warning: unused value: \$4
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:163"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_3
#AT_START_4
# 4. input.at:171: Unused values before symbol declarations
at_setup_line='input.at:171'
at_func_banner 1
at_desc="Unused values before symbol declarations"
$at_quiet $as_echo_n "  4: $at_desc       "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "4. input.at:171: testing ..."
  $at_traceon

cat >input.y <<'_ATEOF'



%%
start:
  'a' a { $2 } | 'b' b { $2 } | 'c' c { $2 } | 'd' d { $2 } | 'e' e { $2 }
| 'f' f { $2 } | 'g' g { $2 } | 'h' h { $2 } | 'i' i { $2 } | 'j' j { $2 }
| 'k' k { $2 } | 'l' l { $2 }
;

a: INT | INT { } INT { } INT { };
b: INT | /* empty */;
c: INT | INT { $1 } INT { $<integer>2 } INT { $<integer>4 };
d: INT | INT { } INT { $1 } INT { $<integer>2 };
e: INT | INT { } INT {  } INT { $1 };
f: INT | INT { } INT {  } INT { $$ = $1 + $3 + $5; };
g: INT | INT { $<integer>$; } INT { $<integer>$; } INT { };
h: INT | INT { $<integer>$; } INT { $<integer>$ = $<integer>2; } INT { };
i: INT | INT INT { } { $$ = $1 + $2; };
j: INT | INT INT { $<integer>$ = 1; } { $$ = $1 + $2; };
k: INT | INT INT { $<integer>$; } { $<integer>$ = $<integer>3; } { };
l: INT | INT { $<integer>$ = $<integer>1; } INT { $<integer>$ = $<integer>2 + $<integer>3; } INT { $<integer>$ = $<integer>4 + $<integer>5; };
%token <integer> INT;
%type <integer> a b c d e f g h i j k l;
%destructor { destroy ($$); } INT a b c d e f g h i j k l;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/input.at:172: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  input.y"
echo input.at:172 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:172"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/input.at:172: bison --xml=xml-tests/test.xml  input.y"
echo input.at:172 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml  input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml  input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:172"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:172: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo input.at:172 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:172"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:172: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo input.at:172 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:172"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/input.at:172: bison  input.y"
echo input.at:172 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison  input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison  input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:11.10-32: warning: unset value: \$\$
input.y:11.10-32: warning: unused value: \$1
input.y:11.10-32: warning: unused value: \$3
input.y:11.10-32: warning: unused value: \$5
input.y:12.9: warning: empty rule for typed nonterminal, and no action
input.y:13.10-59: warning: unset value: \$\$
input.y:13.10-59: warning: unused value: \$3
input.y:13.10-59: warning: unused value: \$5
input.y:14.10-47: warning: unset value: \$\$
input.y:14.10-47: warning: unused value: \$3
input.y:14.10-47: warning: unused value: \$5
input.y:15.10-36: warning: unset value: \$\$
input.y:15.10-36: warning: unused value: \$3
input.y:15.10-36: warning: unused value: \$5
input.y:17.10-58: warning: unset value: \$\$
input.y:17.10-58: warning: unused value: \$1
input.y:17.10-58: warning: unused value: \$3
input.y:17.10-58: warning: unused value: \$5
input.y:18.10-72: warning: unset value: \$\$
input.y:18.10-72: warning: unused value: \$1
input.y:18.10-72: warning: unused value: \$3
input.y:18.10-72: warning: unused value: \$5
input.y:21.10-68: warning: unset value: \$\$
input.y:21.10-68: warning: unused value: \$1
input.y:21.10-68: warning: unused value: \$2
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:172"

$at_failed && at_func_log_failure
$at_traceon; }

cat >input.y <<'_ATEOF'



%%
start:
  'a' a { $2 } | 'b' b { $2 } | 'c' c { $2 } | 'd' d { $2 } | 'e' e { $2 }
| 'f' f { $2 } | 'g' g { $2 } | 'h' h { $2 } | 'i' i { $2 } | 'j' j { $2 }
| 'k' k { $2 } | 'l' l { $2 }
;

a: INT | INT { } INT { } INT { };
b: INT | /* empty */;
c: INT | INT { $1 } INT { $<integer>2 } INT { $<integer>4 };
d: INT | INT { } INT { $1 } INT { $<integer>2 };
e: INT | INT { } INT {  } INT { $1 };
f: INT | INT { } INT {  } INT { $$ = $1 + $3 + $5; };
g: INT | INT { $<integer>$; } INT { $<integer>$; } INT { };
h: INT | INT { $<integer>$; } INT { $<integer>$ = $<integer>2; } INT { };
i: INT | INT INT { } { $$ = $1 + $2; };
j: INT | INT INT { $<integer>$ = 1; } { $$ = $1 + $2; };
k: INT | INT INT { $<integer>$; } { $<integer>$ = $<integer>3; } { };
l: INT | INT { $<integer>$ = $<integer>1; } INT { $<integer>$ = $<integer>2 + $<integer>3; } INT { $<integer>$ = $<integer>4 + $<integer>5; };
%token <integer> INT;
%type <integer> a b c d e f g h i j k l;
%destructor { destroy ($$); } INT a b c d e f g h i j k l;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/input.at:173: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  --warnings=midrule-values  input.y"
echo input.at:173 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  --warnings=midrule-values  input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  --warnings=midrule-values  input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:173"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/input.at:173: bison --xml=xml-tests/test.xml  --warnings=midrule-values  input.y"
echo input.at:173 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml  --warnings=midrule-values  input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml  --warnings=midrule-values  input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:173"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:173: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo input.at:173 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:173"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:173: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo input.at:173 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:173"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/input.at:173: bison  --warnings=midrule-values  input.y"
echo input.at:173 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison  --warnings=midrule-values  input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison  --warnings=midrule-values  input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:11.10-32: warning: unset value: \$\$
input.y:11.10-32: warning: unused value: \$1
input.y:11.10-32: warning: unused value: \$3
input.y:11.10-32: warning: unused value: \$5
input.y:12.9: warning: empty rule for typed nonterminal, and no action
input.y:13.14-19: warning: unset value: \$\$
input.y:13.25-39: warning: unset value: \$\$
input.y:13.10-59: warning: unset value: \$\$
input.y:13.10-59: warning: unused value: \$3
input.y:13.10-59: warning: unused value: \$5
input.y:14.14-16: warning: unset value: \$\$
input.y:14.10-47: warning: unset value: \$\$
input.y:14.10-47: warning: unused value: \$3
input.y:14.10-47: warning: unused value: \$5
input.y:15.10-36: warning: unset value: \$\$
input.y:15.10-36: warning: unused value: \$3
input.y:15.10-36: warning: unused value: \$5
input.y:17.10-58: warning: unset value: \$\$
input.y:17.10-58: warning: unused value: \$1
input.y:17.10-58: warning: unused value: \$2
input.y:17.10-58: warning: unused value: \$3
input.y:17.10-58: warning: unused value: \$4
input.y:17.10-58: warning: unused value: \$5
input.y:18.10-72: warning: unset value: \$\$
input.y:18.10-72: warning: unused value: \$1
input.y:18.10-72: warning: unused value: \$3
input.y:18.10-72: warning: unused value: \$4
input.y:18.10-72: warning: unused value: \$5
input.y:20.10-55: warning: unused value: \$3
input.y:21.10-68: warning: unset value: \$\$
input.y:21.10-68: warning: unused value: \$1
input.y:21.10-68: warning: unused value: \$2
input.y:21.10-68: warning: unused value: \$4
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:173"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_4
#AT_START_5
# 5. input.at:181: Default %printer and %destructor redeclared
at_setup_line='input.at:181'
at_func_banner 1
at_desc="Default %printer and %destructor redeclared"
$at_quiet $as_echo_n "  5: $at_desc    "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "5. input.at:181: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%destructor { destroy ($$); } <*> <*>
%printer { destroy ($$); } <*> <*>

%destructor { destroy ($$); } <*>
%printer { destroy ($$); } <*>

%destructor { destroy ($$); } <> <>
%printer { destroy ($$); } <> <>

%destructor { destroy ($$); } <>
%printer { destroy ($$); } <>

%%

start: ;

%destructor { destroy ($$); } <*>;
%printer { destroy ($$); } <*>;

%destructor { destroy ($$); } <>;
%printer { destroy ($$); } <>;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/input.at:207: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
echo input.at:207 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:1.13-29: redeclaration for default tagged %destructor
input.y:1.13-29: previous declaration
input.y:2.10-26: redeclaration for default tagged %printer
input.y:2.10-26: previous declaration
input.y:4.13-29: redeclaration for default tagged %destructor
input.y:1.13-29: previous declaration
input.y:5.10-26: redeclaration for default tagged %printer
input.y:2.10-26: previous declaration
input.y:7.13-29: redeclaration for default tagless %destructor
input.y:7.13-29: previous declaration
input.y:8.10-26: redeclaration for default tagless %printer
input.y:8.10-26: previous declaration
input.y:10.13-29: redeclaration for default tagless %destructor
input.y:7.13-29: previous declaration
input.y:11.10-26: redeclaration for default tagless %printer
input.y:8.10-26: previous declaration
input.y:17.13-29: redeclaration for default tagged %destructor
input.y:4.13-29: previous declaration
input.y:18.10-26: redeclaration for default tagged %printer
input.y:5.10-26: previous declaration
input.y:20.13-29: redeclaration for default tagless %destructor
input.y:10.13-29: previous declaration
input.y:21.10-26: redeclaration for default tagless %printer
input.y:11.10-26: previous declaration
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/input.at:207"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_5
#AT_START_6
# 6. input.at:241: Per-type %printer and %destructor redeclared
at_setup_line='input.at:241'
at_func_banner 1
at_desc="Per-type %printer and %destructor redeclared"
$at_quiet $as_echo_n "  6: $at_desc   "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "6. input.at:241: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%destructor { destroy ($$); } <field1> <field2>
%printer { destroy ($$); } <field1> <field2>

%destructor { destroy ($$); } <field1> <field1>
%printer { destroy ($$); } <field2> <field2>

%%

start: ;

%destructor { destroy ($$); } <field2> <field1>;
%printer { destroy ($$); } <field2> <field1>;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/input.at:258: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
echo input.at:258 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:4.13-29: %destructor redeclaration for <field1>
input.y:1.13-29: previous declaration
input.y:4.13-29: %destructor redeclaration for <field1>
input.y:4.13-29: previous declaration
input.y:5.10-26: %printer redeclaration for <field2>
input.y:2.10-26: previous declaration
input.y:5.10-26: %printer redeclaration for <field2>
input.y:5.10-26: previous declaration
input.y:11.13-29: %destructor redeclaration for <field1>
input.y:4.13-29: previous declaration
input.y:11.13-29: %destructor redeclaration for <field2>
input.y:1.13-29: previous declaration
input.y:12.10-26: %printer redeclaration for <field1>
input.y:2.10-26: previous declaration
input.y:12.10-26: %printer redeclaration for <field2>
input.y:5.10-26: previous declaration
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/input.at:258"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_6
#AT_START_7
# 7. input.at:284: Unused values with default %destructor
at_setup_line='input.at:284'
at_func_banner 1
at_desc="Unused values with default %destructor"
$at_quiet $as_echo_n "  7: $at_desc         "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "7. input.at:284: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%destructor { destroy ($$); } <>
%type <tag> tagged

%%

start: end end tagged tagged { $<tag>1; $3; } ;
end: { } ;
tagged: { } ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/input.at:297: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input.y"
echo input.at:297 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:297"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/input.at:297: bison --xml=xml-tests/test.xml input.y"
echo input.at:297 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:297"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:297: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo input.at:297 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:297"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:297: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo input.at:297 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:297"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/input.at:297: bison input.y"
echo input.at:297 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:6.8-45: warning: unset value: \$\$
input.y:6.8-45: warning: unused value: \$2
input.y:7.6-8: warning: unset value: \$\$
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:297"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input.y <<'_ATEOF'
%destructor { destroy ($$); } <*>
%type <tag> tagged

%%

start: end end tagged tagged { $<tag>1; $3; } ;
end: { } ;
tagged: { } ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/input.at:314: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input.y"
echo input.at:314 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:314"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/input.at:314: bison --xml=xml-tests/test.xml input.y"
echo input.at:314 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:314"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:314: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo input.at:314 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:314"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:314: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo input.at:314 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:314"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/input.at:314: bison input.y"
echo input.at:314 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:6.8-45: warning: unused value: \$4
input.y:8.9-11: warning: unset value: \$\$
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:314"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_7
#AT_START_8
# 8. input.at:326: Unused values with per-type %destructor
at_setup_line='input.at:326'
at_func_banner 1
at_desc="Unused values with per-type %destructor"
$at_quiet $as_echo_n "  8: $at_desc        "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "8. input.at:326: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%destructor { destroy ($$); } <field1>
%type <field1> start end

%%

start: end end { $1; } ;
end: { }  ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/input.at:338: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input.y"
echo input.at:338 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:338"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/input.at:338: bison --xml=xml-tests/test.xml input.y"
echo input.at:338 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:338"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:338: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo input.at:338 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:338"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:338: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo input.at:338 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:338"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/input.at:338: bison input.y"
echo input.at:338 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:6.8-22: warning: unset value: \$\$
input.y:6.8-22: warning: unused value: \$2
input.y:7.6-8: warning: unset value: \$\$
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:338"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_8
#AT_START_9
# 9. input.at:351: Incompatible Aliases
at_setup_line='input.at:351'
at_func_banner 1
at_desc="Incompatible Aliases"
$at_quiet $as_echo_n "  9: $at_desc                           "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "9. input.at:351: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%token foo "foo"

%type <bar>       foo
%printer {bar}    foo
%destructor {bar} foo
%left             foo

%type <baz>       "foo"
%printer {baz}    "foo"
%destructor {baz} "foo"
%left             "foo"

%%
exp: foo;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/input.at:370: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
echo input.at:370 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:8.7-11: %type redeclaration for foo
input.y:3.7-11: previous declaration
input.y:10.13-17: %destructor redeclaration for foo
input.y:5.13-17: previous declaration
input.y:9.10-14: %printer redeclaration for foo
input.y:4.10-14: previous declaration
input.y:11.1-5: %left redeclaration for foo
input.y:6.1-5: previous declaration
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/input.at:370"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_9
#AT_START_10
# 10. input.at:392: Torturing the Scanner
at_setup_line='input.at:392'
at_func_banner 1
at_desc="Torturing the Scanner"
$at_quiet $as_echo_n " 10: $at_desc                          "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "10. input.at:392: testing ..."
  $at_traceon



cat >input.y <<'_ATEOF'
_ATEOF


{ $at_traceoff
$as_echo "$at_srcdir/input.at:396: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
echo input.at:396 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:1.1: syntax error, unexpected end of file
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/input.at:396"

$at_failed && at_func_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
{}
_ATEOF


{ $at_traceoff
$as_echo "$at_srcdir/input.at:404: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
echo input.at:404 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:1.1-2: syntax error, unexpected {...}
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/input.at:404"

$at_failed && at_func_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
/* This is seen in GCC: a %{ and %} in middle of a comment. */
const char *foo = "So %{ and %} can be here too.";

#if 0
/* These examples test Bison while not stressing C compilers too much.
   Many C compilers mishandle backslash-newlines, so this part of the
   test is inside "#if 0".  The comment and string are written so that
   the "#endif" will be seen regardless of the C compiler bugs that we
   know about, namely:

     HP C (as of late 2002) mishandles *\[newline]\[newline]/ within a
     comment.

     The Apple Darwin compiler (as of late 2002) mishandles
     \\[newline]' within a character constant.

   */

/\
* A comment with backslash-newlines in it. %} *\
\
/
/* { Close the above comment, if the C compiler mishandled it.  */

char str[] = "\\
" A string with backslash-newlines in it %{ %} \\
\
"";

char apostrophe = '\'';
#endif

#include <stdio.h>
#include <stdlib.h>
%}
/* %{ and %} can be here too. */

%{
/* Exercise pre-prologue dependency to %union.  */
typedef int value;
%}

/* Exercise M4 quoting: ']]', 0.  */

/* Also exercise %union. */
%union
{
  value ival; /* A comment to exercise an old bug. */
};


/* Exercise post-prologue dependency to %union.  */
%{
static YYSTYPE value_as_yystype (value val);

/* Exercise quotes in declarations.  */
char quote[] = "]],";
%}

%{
static void yyerror (const char *s);
static int yylex (void);
%}

%type <ival> '['

/* Exercise quotes in strings.  */
%token FAKE "fake [] \a\b\f\n\r\t\v\"\'\?\\\u005B\U0000005c ??!??'??(??)??-??/??<??=??> \x1\1"

%%
/* Exercise M4 quoting: ']]', [, 1.  */
exp: '[' '\1' two '$' '@' '{' oline output.or.oline.opt
  {
    /* Exercise quotes in braces.  */
    char tmp[] = "[%c],\n";
    printf (tmp, $1);
  }
;

two: '\x000000000000000000000000000000000000000000000000000000000000000000002';
oline: '@' 'o' 'l' 'i' 'n' 'e' '@' '_' '_' 'o' 'l' 'i' 'n' 'e' '_' '_';
output.or.oline.opt: ;|oline;;|output;;;
output: '#' 'o' 'u' 't' 'p' 'u' 't' ' ';
%%
/* Exercise M4 quoting: ']]', [, 2.  */

static YYSTYPE
value_as_yystype (value val)
{
  YYSTYPE res;
  res.ival = val;
  return res;
}

static int
yylex (void)
{
  static char const input[] = "[\1\2$@{@oline@__oline__\
#output "; /* "
  */
  static size_t toknum;
  if (! (toknum < sizeof input))
    abort ();
  yylval = value_as_yystype (input[toknum]);
  return input[toknum++];
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}
_ATEOF



# Pacify Emacs'font-lock-mode: "

cat >main.c <<'_ATEOF'
typedef int value;
#include "input.h"

int yyparse (void);

int
main (void)
{
  return yyparse ();
}
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/input.at:540: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -d -v -o input.c input.y"
echo input.at:540 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -d -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -d -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:540"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/input.at:540: bison --xml=xml-tests/test.xml -d -v -o input.c input.y"
echo input.at:540 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -d -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -d -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:540"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:540: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo input.at:540 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:540"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:540: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo input.at:540 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:540"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/input.at:540: bison -d -v -o input.c input.y"
echo input.at:540 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -d -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -d -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:540"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/input.at:541: \$CC \$CFLAGS \$CPPFLAGS -o input.o -c input.c"
echo input.at:541 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -o input.o -c input.c"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -o input.o -c input.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -o input.o -c input.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:541"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/input.at:542: \$CC \$CFLAGS \$CPPFLAGS -o main.o -c main.c"
echo input.at:542 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -o main.o -c main.c"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -o main.o -c main.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -o main.o -c main.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:542"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/input.at:543: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.o main.o \$LIBS"
echo input.at:543 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.o main.o $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.o main.o $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.o main.o $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:543"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/input.at:544:  \$PREPARSER ./input"
echo input.at:544 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input"; then
  ( $at_traceon;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "[[],
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:544"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_10
#AT_START_11
# 11. input.at:555: Typed symbol aliases
at_setup_line='input.at:555'
at_func_banner 1
at_desc="Typed symbol aliases"
$at_quiet $as_echo_n " 11: $at_desc                           "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "11. input.at:555: testing ..."
  $at_traceon


# Bison 2.0 broke typed symbol aliases - ensure they work.

cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%union
{
  int val;
};
%token <val> MY_TOKEN "MY TOKEN"
%type <val> exp
%%
exp: "MY TOKEN";
%%
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/input.at:571: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo input.at:571 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:571"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/input.at:571: bison --xml=xml-tests/test.xml -o input.c input.y"
echo input.at:571 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:571"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:571: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo input.at:571 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:571"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:571: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo input.at:571 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:571"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/input.at:571: bison -o input.c input.y"
echo input.at:571 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:571"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_11
#AT_START_12
# 12. input.at:591: Require 1.0
at_setup_line='input.at:591'
at_func_banner 1
at_desc="Require 1.0"
$at_quiet $as_echo_n " 12: $at_desc                                    "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "12. input.at:591: testing ..."
  $at_traceon

cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%require "1.0";
%%
empty_file:;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/input.at:591: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo input.at:591 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:591"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/input.at:591: bison --xml=xml-tests/test.xml -o input.c input.y"
echo input.at:591 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:591"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:591: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo input.at:591 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:591"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:591: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo input.at:591 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:591"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/input.at:591: bison -o input.c input.y"
echo input.at:591 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:591"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_12
#AT_START_13
# 13. input.at:592: Require 2.4.1
at_setup_line='input.at:592'
at_func_banner 1
at_desc="Require 2.4.1"
$at_quiet $as_echo_n " 13: $at_desc                                  "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "13. input.at:592: testing ..."
  $at_traceon

cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%require "2.4.1";
%%
empty_file:;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/input.at:592: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo input.at:592 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:592"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/input.at:592: bison --xml=xml-tests/test.xml -o input.c input.y"
echo input.at:592 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:592"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:592: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo input.at:592 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:592"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:592: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo input.at:592 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:592"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/input.at:592: bison -o input.c input.y"
echo input.at:592 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:592"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_13
#AT_START_14
# 14. input.at:594: Require 100.0
at_setup_line='input.at:594'
at_func_banner 1
at_desc="Require 100.0"
$at_quiet $as_echo_n " 14: $at_desc                                  "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "14. input.at:594: testing ..."
  $at_traceon

cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%require "100.0";
%%
empty_file:;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/input.at:594: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o input.c input.y"
echo input.at:594 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o input.c input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 63 $at_status "$at_srcdir/input.at:594"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_14
#AT_START_15
# 15. input.at:601: String aliases for character tokens
at_setup_line='input.at:601'
at_func_banner 1
at_desc="String aliases for character tokens"
$at_quiet $as_echo_n " 15: $at_desc            "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "15. input.at:601: testing ..."
  $at_traceon


# Bison once thought a character token and its alias were different symbols
# with the same user token number.

cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%token 'a' "a"
%%
start: 'a';
%%
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/input.at:613: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo input.at:613 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:613"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/input.at:613: bison --xml=xml-tests/test.xml -o input.c input.y"
echo input.at:613 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:613"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:613: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo input.at:613 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:613"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:613: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo input.at:613 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:613"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/input.at:613: bison -o input.c input.y"
echo input.at:613 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:613"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_15
#AT_START_16
# 16. input.at:622: Unclosed constructs
at_setup_line='input.at:622'
at_func_banner 1
at_desc="Unclosed constructs"
$at_quiet $as_echo_n " 16: $at_desc                            "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "16. input.at:622: testing ..."
  $at_traceon


# Bison's scan-gram.l once forgot to STRING_FINISH some unclosed constructs, so
# they were prepended to whatever it STRING_GROW'ed next.  It also threw them
# away rather than returning them to the parser.  The effect was confusing
# subsequent error messages.

cat >input.y <<'_ATEOF'
%token A "a
%token B "b"
%token AB "ab" // Used to complain that "ab" was already used.
%token C '1
%token TWO "2"
%token TICK_TWELVE "'12" // Used to complain that "'12" was already used.

%%

start: ;

// Used to report a syntax error because it didn't see any kind of symbol
// identifier.
%type <f> 'a
;
%type <f> "a
;
// Used to report a syntax error because it didn't see braced code.
%destructor { free ($$)
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/input.at:651: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o input.c input.y"
echo input.at:651 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o input.c input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:1.10-2.0: missing \`\"' at end of line
input.y:4.10-5.0: missing \`'' at end of line
input.y:14.11-15.0: missing \`'' at end of line
input.y:16.11-17.0: missing \`\"' at end of line
input.y:19.13-20.0: missing \`}' at end of file
input.y:20.1: syntax error, unexpected end of file
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/input.at:651"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_16
#AT_START_17
# 17. input.at:667: %start after first rule
at_setup_line='input.at:667'
at_func_banner 1
at_desc="%start after first rule"
$at_quiet $as_echo_n " 17: $at_desc                        "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "17. input.at:667: testing ..."
  $at_traceon


# Bison once complained that a %start after the first rule was a redeclaration
# of the start symbol.

cat >input.y <<'_ATEOF'
%%
false_start: ;
start: false_start ;
%start start;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/input.at:679: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo input.at:679 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:679"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/input.at:679: bison --xml=xml-tests/test.xml -o input.c input.y"
echo input.at:679 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:679"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:679: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo input.at:679 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:679"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:679: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo input.at:679 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:679"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/input.at:679: bison -o input.c input.y"
echo input.at:679 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:679"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_17
#AT_START_18
# 18. input.at:688: %prec takes a token
at_setup_line='input.at:688'
at_func_banner 1
at_desc="%prec takes a token"
$at_quiet $as_echo_n " 18: $at_desc                            "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "18. input.at:688: testing ..."
  $at_traceon


# Bison once allowed %prec sym where sym was a nonterminal.

cat >input.y <<'_ATEOF'
%%
start: PREC %prec PREC ;
PREC: ;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/input.at:698: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
echo input.at:698 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:3.1-4: rule given for PREC, which is a token
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/input.at:698"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_18
#AT_START_19
# 19. input.at:709: Reject unused %code qualifiers
at_setup_line='input.at:709'
at_func_banner 1
at_desc="Reject unused %code qualifiers"
$at_quiet $as_echo_n " 19: $at_desc                 "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "19. input.at:709: testing ..."
  $at_traceon


cat >input-c.y <<'_ATEOF'
%code q {}
%code bad {}
%code bad {}
%code format {}
%%
start: ;
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/input.at:719: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input-c.y"
echo input.at:719 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input-c.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input-c.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:719"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/input.at:719: bison --xml=xml-tests/test.xml input-c.y"
echo input.at:719 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml input-c.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml input-c.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:719"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:719: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo input.at:719 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:719"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:719: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo input.at:719 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:719"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/input.at:719: bison input-c.y"
echo input.at:719 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison input-c.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison input-c.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input-c.y:1.7: warning: %code qualifier \`q' is not used
input-c.y:2.7-9: warning: %code qualifier \`bad' is not used
input-c.y:3.7-9: warning: %code qualifier \`bad' is not used
input-c.y:4.7-12: warning: %code qualifier \`format' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:719"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input-c-glr.y <<'_ATEOF'
%code q {}
%code bad {}
 %code bad {}
%%
start: ;
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/input.at:733: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input-c-glr.y"
echo input.at:733 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input-c-glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input-c-glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:733"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/input.at:733: bison --xml=xml-tests/test.xml input-c-glr.y"
echo input.at:733 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml input-c-glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml input-c-glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:733"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:733: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo input.at:733 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:733"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:733: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo input.at:733 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:733"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/input.at:733: bison input-c-glr.y"
echo input.at:733 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison input-c-glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison input-c-glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input-c-glr.y:1.7: warning: %code qualifier \`q' is not used
input-c-glr.y:2.7-9: warning: %code qualifier \`bad' is not used
input-c-glr.y:3.8-10: warning: %code qualifier \`bad' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:733"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input-c++.y <<'_ATEOF'
%code q {}
%code bad {}
 %code q {}
%%
start: ;
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/input.at:746: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input-c++.y"
echo input.at:746 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input-c++.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input-c++.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:746"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/input.at:746: bison --xml=xml-tests/test.xml input-c++.y"
echo input.at:746 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml input-c++.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml input-c++.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:746"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:746: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo input.at:746 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:746"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:746: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo input.at:746 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:746"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/input.at:746: bison input-c++.y"
echo input.at:746 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison input-c++.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison input-c++.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input-c++.y:1.7: warning: %code qualifier \`q' is not used
input-c++.y:2.7-9: warning: %code qualifier \`bad' is not used
input-c++.y:3.8: warning: %code qualifier \`q' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:746"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input-c++-glr.y <<'_ATEOF'
%code bad {}
%code q {}
%code q {}
%%
start: ;
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/input.at:759: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input-c++-glr.y"
echo input.at:759 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input-c++-glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input-c++-glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:759"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/input.at:759: bison --xml=xml-tests/test.xml input-c++-glr.y"
echo input.at:759 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml input-c++-glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml input-c++-glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:759"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:759: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo input.at:759 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:759"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:759: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo input.at:759 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:759"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/input.at:759: bison input-c++-glr.y"
echo input.at:759 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison input-c++-glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison input-c++-glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input-c++-glr.y:1.7-9: warning: %code qualifier \`bad' is not used
input-c++-glr.y:2.7: warning: %code qualifier \`q' is not used
input-c++-glr.y:3.7: warning: %code qualifier \`q' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:759"

$at_failed && at_func_log_failure
$at_traceon; }


cat >special-char-@@.y <<'_ATEOF'
%code bad {}
%code q {}
%code q {}
%%
start: ;
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/input.at:772: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot special-char-@@.y"
echo input.at:772 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot special-char-@@.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot special-char-@@.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:772"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/input.at:772: bison --xml=xml-tests/test.xml special-char-@@.y"
echo input.at:772 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml special-char-@@.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml special-char-@@.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:772"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:772: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo input.at:772 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:772"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:772: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo input.at:772 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:772"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/input.at:772: bison special-char-@@.y"
echo input.at:772 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison special-char-@@.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison special-char-@@.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "special-char-@@.y:1.7-9: warning: %code qualifier \`bad' is not used
special-char-@@.y:2.7: warning: %code qualifier \`q' is not used
special-char-@@.y:3.7: warning: %code qualifier \`q' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:772"

$at_failed && at_func_log_failure
$at_traceon; }


cat >special-char-].y <<'_ATEOF'
%code bad {}
%code q {}
%code q {}
%%
start: ;
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/input.at:785: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot special-char-].y"
echo input.at:785 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot special-char-].y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot special-char-].y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:785"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/input.at:785: bison --xml=xml-tests/test.xml special-char-].y"
echo input.at:785 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml special-char-].y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml special-char-].y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:785"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:785: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo input.at:785 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:785"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:785: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo input.at:785 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:785"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/input.at:785: bison special-char-].y"
echo input.at:785 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison special-char-].y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison special-char-].y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "special-char-].y:1.7-9: warning: %code qualifier \`bad' is not used
special-char-].y:2.7: warning: %code qualifier \`q' is not used
special-char-].y:3.7: warning: %code qualifier \`q' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:785"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_19
#AT_START_20
# 20. input.at:798: %define errors
at_setup_line='input.at:798'
at_func_banner 1
at_desc="%define errors"
$at_quiet $as_echo_n " 20: $at_desc                                 "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "20. input.at:798: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%define var "value1"
%define var "value1"
 %define var "value2"
%define special1 "]"
%define special2 "["
%%
start: ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/input.at:810: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input.y"
echo input.at:810 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:810"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/input.at:810: bison --xml=xml-tests/test.xml input.y"
echo input.at:810 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:810"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:810: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo input.at:810 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:810"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:810: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo input.at:810 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:810"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/input.at:810: bison input.y"
echo input.at:810 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:2.9-11: warning: %define variable \`var' redefined
input.y:1.9-11: warning: previous definition
input.y:3.10-12: warning: %define variable \`var' redefined
input.y:2.9-11: warning: previous definition
input.y:1.9-11: warning: %define variable \`var' is not used
input.y:2.9-11: warning: %define variable \`var' is not used
input.y:3.10-12: warning: %define variable \`var' is not used
input.y:4.9-16: warning: %define variable \`special1' is not used
input.y:5.9-16: warning: %define variable \`special2' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:810"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_20
#AT_START_21
# 21. input.at:828: %define Boolean variables
at_setup_line='input.at:828'
at_func_banner 1
at_desc="%define Boolean variables"
$at_quiet $as_echo_n " 21: $at_desc                      "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "21. input.at:828: testing ..."
  $at_traceon


cat >Input.y <<'_ATEOF'
%language "Java"
%define public "maybe"
%define parser_class_name "Input"
%%
start: ;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/input.at:838: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison Input.y"
echo input.at:838 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison Input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison Input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison Input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "Input.y:2.9-14: invalid value for %define Boolean variable \`public'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/input.at:838"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_21
#AT_START_22
# 22. input.at:848: %define enum variables
at_setup_line='input.at:848'
at_func_banner 1
at_desc="%define enum variables"
$at_quiet $as_echo_n " 22: $at_desc                         "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "22. input.at:848: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%define api.push_pull "neither"
%%
start: ;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/input.at:856: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
echo input.at:856 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:1.9-21: invalid value for %define variable \`api.push_pull': \`neither'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/input.at:856"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_22
#AT_START_23
# 23. input.at:866: Unused %define api.pure
at_setup_line='input.at:866'
at_func_banner 1
at_desc="Unused %define api.pure"
$at_quiet $as_echo_n " 23: $at_desc                        "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "23. input.at:866: testing ..."
  $at_traceon


# AT_CHECK_API_PURE(DECLS, VALUE)
# -------------------------------
# Make sure Bison reports that `%define api.pure VALUE' is unused when DECLS
# are specified.



cat >input.y <<'_ATEOF'
%define api.pure
%language "c++" %defines
%%
start: ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/input.at:886: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input.y"
echo input.at:886 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:886"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/input.at:886: bison --xml=xml-tests/test.xml input.y"
echo input.at:886 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:886"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:886: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo input.at:886 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:886"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:886: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo input.at:886 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:886"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/input.at:886: bison input.y"
echo input.at:886 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:1.9-16: warning: %define variable \`api.pure' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:886"

$at_failed && at_func_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%define api.pure "false"
%language "c++" %defines
%%
start: ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/input.at:887: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input.y"
echo input.at:887 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:887"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/input.at:887: bison --xml=xml-tests/test.xml input.y"
echo input.at:887 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:887"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:887: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo input.at:887 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:887"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:887: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo input.at:887 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:887"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/input.at:887: bison input.y"
echo input.at:887 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:1.9-16: warning: %define variable \`api.pure' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:887"

$at_failed && at_func_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%define api.pure ""
%language "c++" %defines %glr-parser
%%
start: ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/input.at:888: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input.y"
echo input.at:888 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:888"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/input.at:888: bison --xml=xml-tests/test.xml input.y"
echo input.at:888 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:888"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:888: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo input.at:888 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:888"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:888: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo input.at:888 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:888"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/input.at:888: bison input.y"
echo input.at:888 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:1.9-16: warning: %define variable \`api.pure' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:888"

$at_failed && at_func_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%define api.pure "false"
%language "c++" %defines %glr-parser
%%
start: ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/input.at:889: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input.y"
echo input.at:889 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:889"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/input.at:889: bison --xml=xml-tests/test.xml input.y"
echo input.at:889 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:889"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:889: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo input.at:889 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:889"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:889: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo input.at:889 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:889"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/input.at:889: bison input.y"
echo input.at:889 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:1.9-16: warning: %define variable \`api.pure' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:889"

$at_failed && at_func_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%define api.pure "true"
%language "java"
%%
start: ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/input.at:890: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input.y"
echo input.at:890 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:890"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/input.at:890: bison --xml=xml-tests/test.xml input.y"
echo input.at:890 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:890"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:890: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo input.at:890 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:890"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:890: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo input.at:890 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:890"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/input.at:890: bison input.y"
echo input.at:890 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:1.9-16: warning: %define variable \`api.pure' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:890"

$at_failed && at_func_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%define api.pure "false"
%language "java"
%%
start: ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/input.at:891: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input.y"
echo input.at:891 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:891"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/input.at:891: bison --xml=xml-tests/test.xml input.y"
echo input.at:891 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/input.at:891"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:891: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo input.at:891 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:891"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/input.at:891: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo input.at:891 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:891"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/input.at:891: bison input.y"
echo input.at:891 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:1.9-16: warning: %define variable \`api.pure' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/input.at:891"

$at_failed && at_func_log_failure
$at_traceon; }



  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_23
#AT_START_24
# 24. input.at:899: C++ namespace reference errors
at_setup_line='input.at:899'
at_func_banner 1
at_desc="C++ namespace reference errors"
$at_quiet $as_echo_n " 24: $at_desc                 "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "24. input.at:899: testing ..."
  $at_traceon


# AT_CHECK_NAMESPACE_ERROR(NAMESPACE-DECL, ERROR, [ERROR], ...)
# -------------------------------------------------------------
# Make sure Bison reports all ERROR's for %define namespace "NAMESPACE-DECL".



cat >input.y <<'_ATEOF'
%language "C++"
%defines
%define namespace ""
%%
start: ;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/input.at:920: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
echo input.at:920 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:3.9-17: namespace reference is empty
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/input.at:920"

$at_failed && at_func_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%language "C++"
%defines
%define namespace " 		  	 	"
%%
start: ;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/input.at:922: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
echo input.at:922 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:3.9-17: namespace reference is empty
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/input.at:922"

$at_failed && at_func_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%language "C++"
%defines
%define namespace "foo::::bar"
%%
start: ;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/input.at:924: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
echo input.at:924 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:3.9-17: namespace reference has consecutive \"::\"
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/input.at:924"

$at_failed && at_func_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%language "C++"
%defines
%define namespace "foo:: 	::bar"
%%
start: ;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/input.at:926: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
echo input.at:926 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:3.9-17: namespace reference has consecutive \"::\"
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/input.at:926"

$at_failed && at_func_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%language "C++"
%defines
%define namespace "::::bar"
%%
start: ;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/input.at:928: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
echo input.at:928 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:3.9-17: namespace reference has consecutive \"::\"
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/input.at:928"

$at_failed && at_func_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%language "C++"
%defines
%define namespace ":: ::bar"
%%
start: ;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/input.at:930: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
echo input.at:930 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:3.9-17: namespace reference has consecutive \"::\"
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/input.at:930"

$at_failed && at_func_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%language "C++"
%defines
%define namespace "foo::bar::	::"
%%
start: ;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/input.at:932: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
echo input.at:932 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:3.9-17: namespace reference has consecutive \"::\"
input.y:3.9-17: namespace reference has a trailing \"::\"
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/input.at:932"

$at_failed && at_func_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%language "C++"
%defines
%define namespace "foo::bar::"
%%
start: ;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/input.at:935: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
echo input.at:935 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:3.9-17: namespace reference has a trailing \"::\"
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/input.at:935"

$at_failed && at_func_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%language "C++"
%defines
%define namespace "foo::bar:: 	"
%%
start: ;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/input.at:937: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
echo input.at:937 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:3.9-17: namespace reference has a trailing \"::\"
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/input.at:937"

$at_failed && at_func_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%language "C++"
%defines
%define namespace "::"
%%
start: ;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/input.at:939: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
echo input.at:939 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:3.9-17: namespace reference has a trailing \"::\"
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/input.at:939"

$at_failed && at_func_log_failure
$at_traceon; }



  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_24
#AT_START_25
# 25. output.at:43: Output files:  -dv
at_setup_line='output.at:43'
at_func_banner 2
at_desc="Output files:  -dv "
$at_quiet $as_echo_n " 25: $at_desc                            "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "25. output.at:43: testing ..."
  $at_traceon

for file in foo.y foo.output foo.tab.c foo.tab.h; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:43: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -dv foo.y "
echo output.at:43 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -dv foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -dv foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:43"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:43: bison --xml=xml-tests/test.xml -dv foo.y "
echo output.at:43 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -dv foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -dv foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:43"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:43: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:43 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:43"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:43: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:43 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:43"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:43: bison -dv foo.y "
echo output.at:43 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -dv foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -dv foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:43"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:43: ls foo.output foo.tab.c foo.tab.h"
echo output.at:43 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls foo.output foo.tab.c foo.tab.h ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls foo.output foo.tab.c foo.tab.h ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:43"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_25
#AT_START_26
# 26. output.at:45: Output files:  -dv >&-
at_setup_line='output.at:45'
at_func_banner 2
at_desc="Output files:  -dv >&-"
$at_quiet $as_echo_n " 26: $at_desc                         "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "26. output.at:45: testing ..."
  $at_traceon

for file in foo.y foo.output foo.tab.c foo.tab.h; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:45: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -dv foo.y >&-"
echo output.at:45 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -dv foo.y >&- ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -dv foo.y >&- ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:45"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:45: bison --xml=xml-tests/test.xml -dv foo.y >&-"
echo output.at:45 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -dv foo.y >&- ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -dv foo.y >&- ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:45"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:45: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:45 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:45"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:45: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:45 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:45"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:45: bison -dv foo.y >&-"
echo output.at:45 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -dv foo.y >&- ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -dv foo.y >&- ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:45"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:45: ls foo.output foo.tab.c foo.tab.h"
echo output.at:45 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls foo.output foo.tab.c foo.tab.h ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls foo.output foo.tab.c foo.tab.h ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:45"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_26
#AT_START_27
# 27. output.at:48: Output files:  -dv -o foo.c
at_setup_line='output.at:48'
at_func_banner 2
at_desc="Output files:  -dv -o foo.c "
$at_quiet $as_echo_n " 27: $at_desc                   "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "27. output.at:48: testing ..."
  $at_traceon

for file in foo.y foo.c foo.h foo.output; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:48: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -dv -o foo.c foo.y "
echo output.at:48 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -dv -o foo.c foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -dv -o foo.c foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:48"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:48: bison --xml=xml-tests/test.xml -dv -o foo.c foo.y "
echo output.at:48 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -dv -o foo.c foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -dv -o foo.c foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:48"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:48: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:48 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:48"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:48: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:48 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:48"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:48: bison -dv -o foo.c foo.y "
echo output.at:48 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -dv -o foo.c foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -dv -o foo.c foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:48"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:48: ls foo.c foo.h foo.output"
echo output.at:48 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls foo.c foo.h foo.output ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls foo.c foo.h foo.output ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:48"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_27
#AT_START_28
# 28. output.at:50: Output files:  -dv -o foo.tab.c
at_setup_line='output.at:50'
at_func_banner 2
at_desc="Output files:  -dv -o foo.tab.c "
$at_quiet $as_echo_n " 28: $at_desc               "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "28. output.at:50: testing ..."
  $at_traceon

for file in foo.y foo.output foo.tab.c foo.tab.h; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:50: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -dv -o foo.tab.c foo.y "
echo output.at:50 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -dv -o foo.tab.c foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -dv -o foo.tab.c foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:50"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:50: bison --xml=xml-tests/test.xml -dv -o foo.tab.c foo.y "
echo output.at:50 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -dv -o foo.tab.c foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -dv -o foo.tab.c foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:50"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:50: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:50 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:50"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:50: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:50 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:50"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:50: bison -dv -o foo.tab.c foo.y "
echo output.at:50 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -dv -o foo.tab.c foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -dv -o foo.tab.c foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:50"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:50: ls foo.output foo.tab.c foo.tab.h"
echo output.at:50 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls foo.output foo.tab.c foo.tab.h ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls foo.output foo.tab.c foo.tab.h ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:50"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_28
#AT_START_29
# 29. output.at:52: Output files:  -dv -y
at_setup_line='output.at:52'
at_func_banner 2
at_desc="Output files:  -dv -y "
$at_quiet $as_echo_n " 29: $at_desc                         "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "29. output.at:52: testing ..."
  $at_traceon

for file in foo.y y.output y.tab.c y.tab.h; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:52: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -dv -y foo.y "
echo output.at:52 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -dv -y foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -dv -y foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:52"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:52: bison --xml=xml-tests/test.xml -dv -y foo.y "
echo output.at:52 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -dv -y foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -dv -y foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:52"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:52: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:52 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:52"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:52: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:52 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:52"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:52: bison -dv -y foo.y "
echo output.at:52 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -dv -y foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -dv -y foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:52"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:52: ls y.output y.tab.c y.tab.h"
echo output.at:52 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls y.output y.tab.c y.tab.h ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls y.output y.tab.c y.tab.h ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:52"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_29
#AT_START_30
# 30. output.at:54: Output files:  -dv -b bar
at_setup_line='output.at:54'
at_func_banner 2
at_desc="Output files:  -dv -b bar "
$at_quiet $as_echo_n " 30: $at_desc                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "30. output.at:54: testing ..."
  $at_traceon

for file in foo.y bar.output bar.tab.c bar.tab.h; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:54: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -dv -b bar foo.y "
echo output.at:54 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -dv -b bar foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -dv -b bar foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:54"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:54: bison --xml=xml-tests/test.xml -dv -b bar foo.y "
echo output.at:54 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -dv -b bar foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -dv -b bar foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:54"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:54: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:54 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:54"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:54: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:54 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:54"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:54: bison -dv -b bar foo.y "
echo output.at:54 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -dv -b bar foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -dv -b bar foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:54"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:54: ls bar.output bar.tab.c bar.tab.h"
echo output.at:54 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls bar.output bar.tab.c bar.tab.h ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls bar.output bar.tab.c bar.tab.h ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:54"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_30
#AT_START_31
# 31. output.at:56: Output files:  -dv -g -o foo.c
at_setup_line='output.at:56'
at_func_banner 2
at_desc="Output files:  -dv -g -o foo.c "
$at_quiet $as_echo_n " 31: $at_desc                "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "31. output.at:56: testing ..."
  $at_traceon

for file in foo.y foo.c foo.dot foo.h foo.output; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:56: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -dv -g -o foo.c foo.y "
echo output.at:56 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -dv -g -o foo.c foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -dv -g -o foo.c foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:56"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:56: bison --xml=xml-tests/test.xml -dv -g -o foo.c foo.y "
echo output.at:56 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -dv -g -o foo.c foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -dv -g -o foo.c foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:56"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:56: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:56 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:56"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:56: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:56 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:56"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:56: bison -dv -g -o foo.c foo.y "
echo output.at:56 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -dv -g -o foo.c foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -dv -g -o foo.c foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:56"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:56: ls foo.c foo.dot foo.h foo.output"
echo output.at:56 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls foo.c foo.dot foo.h foo.output ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls foo.c foo.dot foo.h foo.output ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:56"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_31
#AT_START_32
# 32. output.at:60: Output files: %defines %verbose
at_setup_line='output.at:60'
at_func_banner 2
at_desc="Output files: %defines %verbose  "
$at_quiet $as_echo_n " 32: $at_desc              "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "32. output.at:60: testing ..."
  $at_traceon

for file in foo.y foo.output foo.tab.c foo.tab.h; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.y <<'_ATEOF'
%defines %verbose
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:60: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  foo.y "
echo output.at:60 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:60"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:60: bison --xml=xml-tests/test.xml  foo.y "
echo output.at:60 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml  foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml  foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:60"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:60: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:60 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:60"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:60: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:60 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:60"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:60: bison  foo.y "
echo output.at:60 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison  foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison  foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:60"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:60: ls foo.output foo.tab.c foo.tab.h"
echo output.at:60 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls foo.output foo.tab.c foo.tab.h ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls foo.output foo.tab.c foo.tab.h ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:60"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_32
#AT_START_33
# 33. output.at:62: Output files: %defines %verbose %yacc
at_setup_line='output.at:62'
at_func_banner 2
at_desc="Output files: %defines %verbose %yacc  "
$at_quiet $as_echo_n " 33: $at_desc        "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "33. output.at:62: testing ..."
  $at_traceon

for file in foo.y y.output y.tab.c y.tab.h; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.y <<'_ATEOF'
%defines %verbose %yacc
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:62: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  foo.y "
echo output.at:62 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:62"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:62: bison --xml=xml-tests/test.xml  foo.y "
echo output.at:62 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml  foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml  foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:62"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:62: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:62 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:62"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:62: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:62 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:62"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:62: bison  foo.y "
echo output.at:62 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison  foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison  foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:62"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:62: ls y.output y.tab.c y.tab.h"
echo output.at:62 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls y.output y.tab.c y.tab.h ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls y.output y.tab.c y.tab.h ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:62"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_33
#AT_START_34
# 34. output.at:65: Output files: %defines %verbose %yacc
at_setup_line='output.at:65'
at_func_banner 2
at_desc="Output files: %defines %verbose %yacc  "
$at_quiet $as_echo_n " 34: $at_desc        "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "34. output.at:65: testing ..."
  $at_traceon

for file in foo.yy y.output y.tab.c y.tab.h; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.yy <<'_ATEOF'
%defines %verbose %yacc
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:65: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  foo.yy "
echo output.at:65 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:65"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:65: bison --xml=xml-tests/test.xml  foo.yy "
echo output.at:65 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml  foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml  foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:65"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:65: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:65 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:65"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:65: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:65 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:65"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:65: bison  foo.yy "
echo output.at:65 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison  foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison  foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:65"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:65: ls y.output y.tab.c y.tab.h"
echo output.at:65 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls y.output y.tab.c y.tab.h ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls y.output y.tab.c y.tab.h ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:65"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_34
#AT_START_35
# 35. output.at:69: Output files: %file-prefix "bar" %defines %verbose
at_setup_line='output.at:69'
at_func_banner 2
at_desc="Output files: %file-prefix \"bar\" %defines %verbose  "
$at_quiet $as_echo_n " 35: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "35. output.at:69: testing ..."
  $at_traceon

for file in foo.y bar.output bar.tab.c bar.tab.h; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.y <<'_ATEOF'
%file-prefix "bar" %defines %verbose
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:69: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  foo.y "
echo output.at:69 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:69"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:69: bison --xml=xml-tests/test.xml  foo.y "
echo output.at:69 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml  foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml  foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:69"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:69: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:69 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:69"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:69: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:69 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:69"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:69: bison  foo.y "
echo output.at:69 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison  foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison  foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:69"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:69: ls bar.output bar.tab.c bar.tab.h"
echo output.at:69 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls bar.output bar.tab.c bar.tab.h ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls bar.output bar.tab.c bar.tab.h ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:69"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_35
#AT_START_36
# 36. output.at:71: Output files: %output="bar.c" %defines %verbose %yacc
at_setup_line='output.at:71'
at_func_banner 2
at_desc="Output files: %output=\"bar.c\" %defines %verbose %yacc  "
$at_quiet $as_echo_n " 36: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "36. output.at:71: testing ..."
  $at_traceon

for file in foo.y bar.output bar.c bar.h; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.y <<'_ATEOF'
%output="bar.c" %defines %verbose %yacc
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:71: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  foo.y "
echo output.at:71 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:71"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:71: bison --xml=xml-tests/test.xml  foo.y "
echo output.at:71 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml  foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml  foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:71"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:71: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:71 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:71"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:71: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:71 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:71"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:71: bison  foo.y "
echo output.at:71 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison  foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison  foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:71"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:71: ls bar.output bar.c bar.h"
echo output.at:71 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls bar.output bar.c bar.h ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls bar.output bar.c bar.h ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:71"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_36
#AT_START_37
# 37. output.at:73: Output files: %file-prefix="baz" %output "bar.c" %defines %verbose %yacc
at_setup_line='output.at:73'
at_func_banner 2
at_desc="Output files: %file-prefix=\"baz\" %output \"bar.c\" %defines %verbose %yacc  "
$at_quiet $as_echo_n " 37: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "37. output.at:73: testing ..."
  $at_traceon

for file in foo.y bar.output bar.c bar.h; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.y <<'_ATEOF'
%file-prefix="baz" %output "bar.c" %defines %verbose %yacc
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:73: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  foo.y "
echo output.at:73 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:73"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:73: bison --xml=xml-tests/test.xml  foo.y "
echo output.at:73 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml  foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml  foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:73"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:73: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:73 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:73"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:73: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:73 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:73"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:73: bison  foo.y "
echo output.at:73 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison  foo.y  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison  foo.y  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:73"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:73: ls bar.output bar.c bar.h"
echo output.at:73 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls bar.output bar.c bar.h ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls bar.output bar.c bar.h ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:73"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_37
#AT_START_38
# 38. output.at:80: Output files: %defines %verbose
at_setup_line='output.at:80'
at_func_banner 2
at_desc="Output files: %defines %verbose  "
$at_quiet $as_echo_n " 38: $at_desc              "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "38. output.at:80: testing ..."
  $at_traceon

for file in foo.yy foo.output foo.tab.cc foo.tab.hh; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.yy <<'_ATEOF'
%defines %verbose
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:80: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  foo.yy "
echo output.at:80 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:80"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:80: bison --xml=xml-tests/test.xml  foo.yy "
echo output.at:80 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml  foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml  foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:80"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:80: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:80 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:80"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:80: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:80 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:80"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:80: bison  foo.yy "
echo output.at:80 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison  foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison  foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:80"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:80: ls foo.output foo.tab.cc foo.tab.hh"
echo output.at:80 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls foo.output foo.tab.cc foo.tab.hh ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls foo.output foo.tab.cc foo.tab.hh ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:80"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_38
#AT_START_39
# 39. output.at:83: Output files: %defines %verbose  -o foo.c
at_setup_line='output.at:83'
at_func_banner 2
at_desc="Output files: %defines %verbose  -o foo.c "
$at_quiet $as_echo_n " 39: $at_desc     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "39. output.at:83: testing ..."
  $at_traceon

for file in foo.yy foo.c foo.h foo.output; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.yy <<'_ATEOF'
%defines %verbose
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:83: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o foo.c foo.yy "
echo output.at:83 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o foo.c foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o foo.c foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:83"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:83: bison --xml=xml-tests/test.xml -o foo.c foo.yy "
echo output.at:83 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o foo.c foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o foo.c foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:83"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:83: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:83 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:83"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:83: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:83 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:83"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:83: bison -o foo.c foo.yy "
echo output.at:83 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o foo.c foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o foo.c foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:83"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:83: ls foo.c foo.h foo.output"
echo output.at:83 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls foo.c foo.h foo.output ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls foo.c foo.h foo.output ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:83"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_39
#AT_START_40
# 40. output.at:86: Output files:  --defines=foo.hpp -o foo.c++
at_setup_line='output.at:86'
at_func_banner 2
at_desc="Output files:  --defines=foo.hpp -o foo.c++ "
$at_quiet $as_echo_n " 40: $at_desc   "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "40. output.at:86: testing ..."
  $at_traceon

for file in foo.yy foo.c++ foo.hpp; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.yy <<'_ATEOF'

%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:86: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --defines=foo.hpp -o foo.c++ foo.yy "
echo output.at:86 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --defines=foo.hpp -o foo.c++ foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --defines=foo.hpp -o foo.c++ foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:86"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:86: bison --xml=xml-tests/test.xml --defines=foo.hpp -o foo.c++ foo.yy "
echo output.at:86 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml --defines=foo.hpp -o foo.c++ foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml --defines=foo.hpp -o foo.c++ foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:86"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:86: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:86 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:86"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:86: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:86 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:86"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:86: bison --defines=foo.hpp -o foo.c++ foo.yy "
echo output.at:86 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --defines=foo.hpp -o foo.c++ foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --defines=foo.hpp -o foo.c++ foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:86"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:86: ls foo.c++ foo.hpp"
echo output.at:86 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls foo.c++ foo.hpp ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls foo.c++ foo.hpp ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:86"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_40
#AT_START_41
# 41. output.at:90: Output files: %defines "foo.hpp" -o foo.c++
at_setup_line='output.at:90'
at_func_banner 2
at_desc="Output files: %defines \"foo.hpp\" -o foo.c++ "
$at_quiet $as_echo_n " 41: $at_desc   "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "41. output.at:90: testing ..."
  $at_traceon

for file in foo.yy foo.c++ foo.hpp; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.yy <<'_ATEOF'
%defines "foo.hpp"
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:90: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o foo.c++ foo.yy "
echo output.at:90 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o foo.c++ foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o foo.c++ foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:90"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:90: bison --xml=xml-tests/test.xml -o foo.c++ foo.yy "
echo output.at:90 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o foo.c++ foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o foo.c++ foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:90"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:90: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:90 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:90"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:90: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:90 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:90"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:90: bison -o foo.c++ foo.yy "
echo output.at:90 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o foo.c++ foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o foo.c++ foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:90"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:90: ls foo.c++ foo.hpp"
echo output.at:90 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls foo.c++ foo.hpp ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls foo.c++ foo.hpp ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:90"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_41
#AT_START_42
# 42. output.at:94: Output files:  -o foo.c++ --graph=foo.gph
at_setup_line='output.at:94'
at_func_banner 2
at_desc="Output files:  -o foo.c++ --graph=foo.gph "
$at_quiet $as_echo_n " 42: $at_desc     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "42. output.at:94: testing ..."
  $at_traceon

for file in foo.yy foo.c++ foo.gph; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.yy <<'_ATEOF'

%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:94: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o foo.c++  foo.yy "
echo output.at:94 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o foo.c++  foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o foo.c++  foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:94"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:94: bison --xml=xml-tests/test.xml -o foo.c++  foo.yy "
echo output.at:94 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o foo.c++  foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o foo.c++  foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:94"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:94: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:94 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:94"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:94: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:94 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:94"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:94: bison -o foo.c++ --graph=foo.gph foo.yy "
echo output.at:94 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o foo.c++ --graph=foo.gph foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o foo.c++ --graph=foo.gph foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:94"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:94: ls foo.c++ foo.gph"
echo output.at:94 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls foo.c++ foo.gph ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls foo.c++ foo.gph ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:94"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_42
#AT_START_43
# 43. output.at:109: Output files: %skeleton "lalr1.cc" %defines %verbose
at_setup_line='output.at:109'
at_func_banner 2
at_desc="Output files: %skeleton \"lalr1.cc\" %defines %verbose  "
$at_quiet $as_echo_n " 43: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "43. output.at:109: testing ..."
  $at_traceon

for file in foo.yy foo.tab.cc foo.tab.hh foo.output location.hh stack.hh position.hh; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >foo.yy <<'_ATEOF'
%skeleton "lalr1.cc" %defines %verbose
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:109: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  foo.yy "
echo output.at:109 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:109"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:109: bison --xml=xml-tests/test.xml  foo.yy "
echo output.at:109 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml  foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml  foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:109"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:109: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:109 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:109"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:109: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:109 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:109"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:109: bison  foo.yy "
echo output.at:109 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison  foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison  foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:109"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:109: ls foo.tab.cc foo.tab.hh foo.output location.hh stack.hh position.hh"
echo output.at:109 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls foo.tab.cc foo.tab.hh foo.output location.hh stack.hh position.hh ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls foo.tab.cc foo.tab.hh foo.output location.hh stack.hh position.hh ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:109"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_43
#AT_START_44
# 44. output.at:112: Output files: %skeleton "lalr1.cc" %defines %verbose
at_setup_line='output.at:112'
at_func_banner 2
at_desc="Output files: %skeleton \"lalr1.cc\" %defines %verbose  "
$at_quiet $as_echo_n " 44: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "44. output.at:112: testing ..."
  $at_traceon

for file in subdir/foo.yy foo.tab.cc foo.tab.hh foo.output location.hh stack.hh position.hh; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >subdir/foo.yy <<'_ATEOF'
%skeleton "lalr1.cc" %defines %verbose
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:112: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  subdir/foo.yy "
echo output.at:112 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  subdir/foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  subdir/foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:112"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:112: bison --xml=xml-tests/test.xml  subdir/foo.yy "
echo output.at:112 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml  subdir/foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml  subdir/foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:112"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:112: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:112 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:112"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:112: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:112 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:112"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:112: bison  subdir/foo.yy "
echo output.at:112 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison  subdir/foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison  subdir/foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:112"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:112: ls foo.tab.cc foo.tab.hh foo.output location.hh stack.hh position.hh"
echo output.at:112 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls foo.tab.cc foo.tab.hh foo.output location.hh stack.hh position.hh ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls foo.tab.cc foo.tab.hh foo.output location.hh stack.hh position.hh ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:112"

$at_failed && at_func_log_failure
$at_traceon; }

# Also make sure that the includes do not refer to the subdirectory.
{ $at_traceoff
$as_echo "$at_srcdir/output.at:112: grep 'include .subdir/' foo.tab.cc"
echo output.at:112 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep 'include .subdir/' foo.tab.cc ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep 'include .subdir/' foo.tab.cc ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/output.at:112"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:112: grep 'include .subdir/' foo.tab.hh"
echo output.at:112 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep 'include .subdir/' foo.tab.hh ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep 'include .subdir/' foo.tab.hh ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/output.at:112"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_44
#AT_START_45
# 45. output.at:116: Output files: %skeleton "lalr1.cc" %defines %verbose -o subdir/foo.cc
at_setup_line='output.at:116'
at_func_banner 2
at_desc="Output files: %skeleton \"lalr1.cc\" %defines %verbose -o subdir/foo.cc "
$at_quiet $as_echo_n " 45: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "45. output.at:116: testing ..."
  $at_traceon

for file in subdir/foo.yy subdir/foo.cc subdir/foo.hh subdir/foo.output subdir/location.hh subdir/stack.hh subdir/position.hh; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >subdir/foo.yy <<'_ATEOF'
%skeleton "lalr1.cc" %defines %verbose
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:116: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o subdir/foo.cc subdir/foo.yy "
echo output.at:116 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o subdir/foo.cc subdir/foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o subdir/foo.cc subdir/foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:116"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:116: bison --xml=xml-tests/test.xml -o subdir/foo.cc subdir/foo.yy "
echo output.at:116 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o subdir/foo.cc subdir/foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o subdir/foo.cc subdir/foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:116"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:116: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:116 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:116"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:116: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:116 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:116"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:116: bison -o subdir/foo.cc subdir/foo.yy "
echo output.at:116 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o subdir/foo.cc subdir/foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o subdir/foo.cc subdir/foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:116"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:116: ls subdir/foo.cc subdir/foo.hh subdir/foo.output subdir/location.hh subdir/stack.hh subdir/position.hh"
echo output.at:116 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls subdir/foo.cc subdir/foo.hh subdir/foo.output subdir/location.hh subdir/stack.hh subdir/position.hh ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls subdir/foo.cc subdir/foo.hh subdir/foo.output subdir/location.hh subdir/stack.hh subdir/position.hh ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:116"

$at_failed && at_func_log_failure
$at_traceon; }

# Also make sure that the includes do not refer to the subdirectory.
{ $at_traceoff
$as_echo "$at_srcdir/output.at:116: grep 'include .subdir/' subdir/foo.cc"
echo output.at:116 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep 'include .subdir/' subdir/foo.cc ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep 'include .subdir/' subdir/foo.cc ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/output.at:116"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:116: grep 'include .subdir/' subdir/foo.hh"
echo output.at:116 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep 'include .subdir/' subdir/foo.hh ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep 'include .subdir/' subdir/foo.hh ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/output.at:116"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_45
#AT_START_46
# 46. output.at:121: Output files: %skeleton "lalr1.cc" %defines %verbose %file-prefix "output_dir/foo"
at_setup_line='output.at:121'
at_func_banner 2
at_desc="Output files: %skeleton \"lalr1.cc\" %defines %verbose %file-prefix \"output_dir/foo\"  "
$at_quiet $as_echo_n " 46: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "46. output.at:121: testing ..."
  $at_traceon

for file in gram_dir/foo.yy output_dir/foo.tab.cc output_dir/foo.tab.hh output_dir/foo.output output_dir/location.hh output_dir/stack.hh output_dir/position.hh; do
  case "$file" in
    */*) mkdir -p `echo "$file" | sed 's,/.*,,'`;;
  esac
done
cat >gram_dir/foo.yy <<'_ATEOF'
%skeleton "lalr1.cc" %defines %verbose %file-prefix "output_dir/foo"
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:121: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  gram_dir/foo.yy "
echo output.at:121 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  gram_dir/foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  gram_dir/foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:121"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:121: bison --xml=xml-tests/test.xml  gram_dir/foo.yy "
echo output.at:121 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml  gram_dir/foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml  gram_dir/foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:121"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:121: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:121 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:121"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:121: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:121 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:121"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:121: bison  gram_dir/foo.yy "
echo output.at:121 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison  gram_dir/foo.yy  ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison  gram_dir/foo.yy  ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:121"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:121: ls output_dir/foo.tab.cc output_dir/foo.tab.hh output_dir/foo.output output_dir/location.hh output_dir/stack.hh output_dir/position.hh"
echo output.at:121 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls output_dir/foo.tab.cc output_dir/foo.tab.hh output_dir/foo.output output_dir/location.hh output_dir/stack.hh output_dir/position.hh ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls output_dir/foo.tab.cc output_dir/foo.tab.hh output_dir/foo.output output_dir/location.hh output_dir/stack.hh output_dir/position.hh ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:121"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_46
#AT_START_47
# 47. output.at:145: Conflicting output files:  --graph="foo.tab.c"
at_setup_line='output.at:145'
at_func_banner 2
at_desc="Conflicting output files:  --graph=\"foo.tab.c\""
$at_quiet $as_echo_n " 47: $at_desc "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "47. output.at:145: testing ..."
  $at_traceon

case "foo.y" in
  */*) mkdir `echo "foo.y" | sed 's,/.*,,'`;;
esac
cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:145: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  foo.y"
echo output.at:145 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:145"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:145: bison --xml=xml-tests/test.xml  foo.y"
echo output.at:145 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml  foo.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml  foo.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:145"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:145: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:145 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:145"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:145: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:145 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:145"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:145: bison --graph=\"foo.tab.c\" foo.y"
echo output.at:145 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --graph="foo.tab.c" foo.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --graph="foo.tab.c" foo.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "foo.y: warning: conflicting outputs to file \`foo.tab.c'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:145"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_47
#AT_START_48
# 48. output.at:150: Conflicting output files: %defines "foo.output" -v
at_setup_line='output.at:150'
at_func_banner 2
at_desc="Conflicting output files: %defines \"foo.output\" -v"
$at_quiet $as_echo_n " 48: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "48. output.at:150: testing ..."
  $at_traceon

case "foo.y" in
  */*) mkdir `echo "foo.y" | sed 's,/.*,,'`;;
esac
cat >foo.y <<'_ATEOF'
%defines "foo.output"
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:150: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -v foo.y"
echo output.at:150 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -v foo.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -v foo.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:150"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:150: bison --xml=xml-tests/test.xml -v foo.y"
echo output.at:150 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -v foo.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -v foo.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:150"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:150: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:150 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:150"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:150: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:150 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:150"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:150: bison -v foo.y"
echo output.at:150 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -v foo.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -v foo.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "foo.y: warning: conflicting outputs to file \`foo.output'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:150"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_48
#AT_START_49
# 49. output.at:155: Conflicting output files: %skeleton "lalr1.cc" %defines --graph="location.hh"
at_setup_line='output.at:155'
at_func_banner 2
at_desc="Conflicting output files: %skeleton \"lalr1.cc\" %defines --graph=\"location.hh\""
$at_quiet $as_echo_n " 49: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "49. output.at:155: testing ..."
  $at_traceon

case "foo.y" in
  */*) mkdir `echo "foo.y" | sed 's,/.*,,'`;;
esac
cat >foo.y <<'_ATEOF'
%skeleton "lalr1.cc" %defines
%%
foo: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:155: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot  foo.y"
echo output.at:155 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot  foo.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:155"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:155: bison --xml=xml-tests/test.xml  foo.y"
echo output.at:155 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml  foo.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml  foo.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:155"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:155: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:155 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:155"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:155: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:155 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:155"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:155: bison --graph=\"location.hh\" foo.y"
echo output.at:155 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --graph="location.hh" foo.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --graph="location.hh" foo.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "foo.y: warning: conflicting outputs to file \`location.hh'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:155"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_49
#AT_START_50
# 50. output.at:160: Conflicting output files:  -o foo.y
at_setup_line='output.at:160'
at_func_banner 2
at_desc="Conflicting output files:  -o foo.y"
$at_quiet $as_echo_n " 50: $at_desc            "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "50. output.at:160: testing ..."
  $at_traceon

case "foo.y" in
  */*) mkdir `echo "foo.y" | sed 's,/.*,,'`;;
esac
cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/output.at:160: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o foo.y foo.y"
echo output.at:160 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o foo.y foo.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o foo.y foo.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o foo.y foo.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "foo.y: fatal error: refusing to overwrite the input file \`foo.y'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/output.at:160"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_50
#AT_START_51
# 51. output.at:200: Output file name: `~!@#$%^&*()-=_+{}[]|\:;<>, .'
at_setup_line='output.at:200'
at_func_banner 2
at_desc="Output file name: \`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'"
$at_quiet $as_echo_n " 51: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "51. output.at:200: testing ..."
  $at_traceon


cat >glr.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%glr-parser
%code {
  int yylex (void);
  void yyerror (const char *);
}
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:200: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.c\" --defines=\"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.h\" glr.y"
echo output.at:200 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" --defines="\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.h" glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" --defines="\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.h" glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:200"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:200: bison --xml=xml-tests/test.xml -o \"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.c\" --defines=\"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.h\" glr.y"
echo output.at:200 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" --defines="\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.h" glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" --defines="\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.h" glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:200"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:200: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:200 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:200"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:200: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:200 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:200"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:200: bison -o \"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.c\" --defines=\"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.h\" glr.y"
echo output.at:200 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; bison -o "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" --defines="\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.h" glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" --defines="\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.h" glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:200"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:200: ls \"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.c\" \"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.h\""
echo output.at:200 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; ls "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.h" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.h" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:200"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:200: \$CC \$CFLAGS \$CPPFLAGS -o glr.o -c \"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.c\""
echo output.at:200 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -o glr.o -c "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -o glr.o -c "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:200"

$at_failed && at_func_log_failure
$at_traceon; }



cat >cxx.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%skeleton "lalr1.cc"
%code { int yylex (yy::parser::semantic_type*); }
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:200: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.c\" --defines=\"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.h\" cxx.y"
echo output.at:200 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" --defines="\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.h" cxx.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" --defines="\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.h" cxx.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:200"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:200: bison --xml=xml-tests/test.xml -o \"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.c\" --defines=\"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.h\" cxx.y"
echo output.at:200 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" --defines="\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.h" cxx.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" --defines="\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.h" cxx.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:200"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:200: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:200 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:200"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:200: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:200 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:200"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:200: bison -o \"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.c\" --defines=\"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.h\" cxx.y"
echo output.at:200 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; bison -o "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" --defines="\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.h" cxx.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" --defines="\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.h" cxx.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:200"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:200: ls \"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.c\" \"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.h\""
echo output.at:200 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; ls "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.h" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.h" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:200"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/output.at:200: \$BISON_CXX_WORKS"
echo output.at:200 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:200"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:200: \$CXX \$CXXFLAGS \$CPPFLAGS -o cxx.o -c \"\\\`~!@#\\\$%^&*()-=_+{}[]|\\\\:;<>, .'.c\""
echo output.at:200 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c "\`~!@#\$%^&*()-=_+{}[]|\\:;<>, .'.c" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:200"

$at_failed && at_func_log_failure
$at_traceon; }



  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_51
#AT_START_52
# 52. output.at:207: Output file name: (
at_setup_line='output.at:207'
at_func_banner 2
at_desc="Output file name: ("
$at_quiet $as_echo_n " 52: $at_desc                            "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "52. output.at:207: testing ..."
  $at_traceon


cat >glr.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%glr-parser
%code {
  int yylex (void);
  void yyerror (const char *);
}
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:207: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"(.c\" --defines=\"(.h\" glr.y"
echo output.at:207 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "(.c" --defines="(.h" glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "(.c" --defines="(.h" glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:207"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:207: bison --xml=xml-tests/test.xml -o \"(.c\" --defines=\"(.h\" glr.y"
echo output.at:207 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o "(.c" --defines="(.h" glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o "(.c" --defines="(.h" glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:207"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:207: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:207 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:207"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:207: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:207 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:207"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:207: bison -o \"(.c\" --defines=\"(.h\" glr.y"
echo output.at:207 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o "(.c" --defines="(.h" glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o "(.c" --defines="(.h" glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:207"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:207: ls \"(.c\" \"(.h\""
echo output.at:207 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls "(.c" "(.h" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls "(.c" "(.h" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:207"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:207: \$CC \$CFLAGS \$CPPFLAGS -o glr.o -c \"(.c\""
echo output.at:207 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -o glr.o -c \"(.c\""; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -o glr.o -c "(.c" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -o glr.o -c "(.c" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:207"

$at_failed && at_func_log_failure
$at_traceon; }



cat >cxx.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%skeleton "lalr1.cc"
%code { int yylex (yy::parser::semantic_type*); }
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:207: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"(.c\" --defines=\"(.h\" cxx.y"
echo output.at:207 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "(.c" --defines="(.h" cxx.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "(.c" --defines="(.h" cxx.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:207"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:207: bison --xml=xml-tests/test.xml -o \"(.c\" --defines=\"(.h\" cxx.y"
echo output.at:207 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o "(.c" --defines="(.h" cxx.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o "(.c" --defines="(.h" cxx.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:207"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:207: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:207 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:207"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:207: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:207 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:207"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:207: bison -o \"(.c\" --defines=\"(.h\" cxx.y"
echo output.at:207 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o "(.c" --defines="(.h" cxx.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o "(.c" --defines="(.h" cxx.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:207"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:207: ls \"(.c\" \"(.h\""
echo output.at:207 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls "(.c" "(.h" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls "(.c" "(.h" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:207"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/output.at:207: \$BISON_CXX_WORKS"
echo output.at:207 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:207"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:207: \$CXX \$CXXFLAGS \$CPPFLAGS -o cxx.o -c \"(.c\""
echo output.at:207 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c \"(.c\""; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c "(.c" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c "(.c" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:207"

$at_failed && at_func_log_failure
$at_traceon; }



  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_52
#AT_START_53
# 53. output.at:208: Output file name: )
at_setup_line='output.at:208'
at_func_banner 2
at_desc="Output file name: )"
$at_quiet $as_echo_n " 53: $at_desc                            "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "53. output.at:208: testing ..."
  $at_traceon


cat >glr.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%glr-parser
%code {
  int yylex (void);
  void yyerror (const char *);
}
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:208: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \").c\" --defines=\").h\" glr.y"
echo output.at:208 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o ").c" --defines=").h" glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o ").c" --defines=").h" glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:208"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:208: bison --xml=xml-tests/test.xml -o \").c\" --defines=\").h\" glr.y"
echo output.at:208 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o ").c" --defines=").h" glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o ").c" --defines=").h" glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:208"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:208: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:208 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:208"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:208: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:208 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:208"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:208: bison -o \").c\" --defines=\").h\" glr.y"
echo output.at:208 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o ").c" --defines=").h" glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o ").c" --defines=").h" glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:208"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:208: ls \").c\" \").h\""
echo output.at:208 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls ").c" ").h" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls ").c" ").h" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:208"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:208: \$CC \$CFLAGS \$CPPFLAGS -o glr.o -c \").c\""
echo output.at:208 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -o glr.o -c \").c\""; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -o glr.o -c ").c" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -o glr.o -c ").c" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:208"

$at_failed && at_func_log_failure
$at_traceon; }



cat >cxx.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%skeleton "lalr1.cc"
%code { int yylex (yy::parser::semantic_type*); }
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:208: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \").c\" --defines=\").h\" cxx.y"
echo output.at:208 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o ").c" --defines=").h" cxx.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o ").c" --defines=").h" cxx.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:208"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:208: bison --xml=xml-tests/test.xml -o \").c\" --defines=\").h\" cxx.y"
echo output.at:208 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o ").c" --defines=").h" cxx.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o ").c" --defines=").h" cxx.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:208"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:208: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:208 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:208"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:208: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:208 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:208"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:208: bison -o \").c\" --defines=\").h\" cxx.y"
echo output.at:208 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o ").c" --defines=").h" cxx.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o ").c" --defines=").h" cxx.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:208"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:208: ls \").c\" \").h\""
echo output.at:208 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls ").c" ").h" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls ").c" ").h" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:208"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/output.at:208: \$BISON_CXX_WORKS"
echo output.at:208 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:208"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:208: \$CXX \$CXXFLAGS \$CPPFLAGS -o cxx.o -c \").c\""
echo output.at:208 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c \").c\""; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c ").c" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c ").c" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:208"

$at_failed && at_func_log_failure
$at_traceon; }



  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_53
#AT_START_54
# 54. output.at:209: Output file name: #
at_setup_line='output.at:209'
at_func_banner 2
at_desc="Output file name: #"
$at_quiet $as_echo_n " 54: $at_desc                            "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "54. output.at:209: testing ..."
  $at_traceon


cat >glr.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%glr-parser
%code {
  int yylex (void);
  void yyerror (const char *);
}
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:209: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"#.c\" --defines=\"#.h\" glr.y"
echo output.at:209 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "#.c" --defines="#.h" glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "#.c" --defines="#.h" glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:209"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:209: bison --xml=xml-tests/test.xml -o \"#.c\" --defines=\"#.h\" glr.y"
echo output.at:209 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o "#.c" --defines="#.h" glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o "#.c" --defines="#.h" glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:209"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:209: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:209 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:209"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:209: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:209 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:209"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:209: bison -o \"#.c\" --defines=\"#.h\" glr.y"
echo output.at:209 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o "#.c" --defines="#.h" glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o "#.c" --defines="#.h" glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:209"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:209: ls \"#.c\" \"#.h\""
echo output.at:209 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls "#.c" "#.h" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls "#.c" "#.h" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:209"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:209: \$CC \$CFLAGS \$CPPFLAGS -o glr.o -c \"#.c\""
echo output.at:209 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -o glr.o -c \"#.c\""; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -o glr.o -c "#.c" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -o glr.o -c "#.c" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:209"

$at_failed && at_func_log_failure
$at_traceon; }



cat >cxx.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%skeleton "lalr1.cc"
%code { int yylex (yy::parser::semantic_type*); }
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:209: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"#.c\" --defines=\"#.h\" cxx.y"
echo output.at:209 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "#.c" --defines="#.h" cxx.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "#.c" --defines="#.h" cxx.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:209"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:209: bison --xml=xml-tests/test.xml -o \"#.c\" --defines=\"#.h\" cxx.y"
echo output.at:209 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o "#.c" --defines="#.h" cxx.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o "#.c" --defines="#.h" cxx.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:209"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:209: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:209 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:209"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:209: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:209 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:209"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:209: bison -o \"#.c\" --defines=\"#.h\" cxx.y"
echo output.at:209 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o "#.c" --defines="#.h" cxx.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o "#.c" --defines="#.h" cxx.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:209"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:209: ls \"#.c\" \"#.h\""
echo output.at:209 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls "#.c" "#.h" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls "#.c" "#.h" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:209"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/output.at:209: \$BISON_CXX_WORKS"
echo output.at:209 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:209"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:209: \$CXX \$CXXFLAGS \$CPPFLAGS -o cxx.o -c \"#.c\""
echo output.at:209 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c \"#.c\""; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c "#.c" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c "#.c" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:209"

$at_failed && at_func_log_failure
$at_traceon; }



  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_54
#AT_START_55
# 55. output.at:210: Output file name: @@
at_setup_line='output.at:210'
at_func_banner 2
at_desc="Output file name: @@"
$at_quiet $as_echo_n " 55: $at_desc                           "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "55. output.at:210: testing ..."
  $at_traceon


cat >glr.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%glr-parser
%code {
  int yylex (void);
  void yyerror (const char *);
}
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:210: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"@@.c\" --defines=\"@@.h\" glr.y"
echo output.at:210 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "@@.c" --defines="@@.h" glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "@@.c" --defines="@@.h" glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:210"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:210: bison --xml=xml-tests/test.xml -o \"@@.c\" --defines=\"@@.h\" glr.y"
echo output.at:210 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o "@@.c" --defines="@@.h" glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o "@@.c" --defines="@@.h" glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:210"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:210: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:210 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:210"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:210: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:210 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:210"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:210: bison -o \"@@.c\" --defines=\"@@.h\" glr.y"
echo output.at:210 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o "@@.c" --defines="@@.h" glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o "@@.c" --defines="@@.h" glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:210"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:210: ls \"@@.c\" \"@@.h\""
echo output.at:210 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls "@@.c" "@@.h" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls "@@.c" "@@.h" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:210"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:210: \$CC \$CFLAGS \$CPPFLAGS -o glr.o -c \"@@.c\""
echo output.at:210 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -o glr.o -c \"@@.c\""; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -o glr.o -c "@@.c" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -o glr.o -c "@@.c" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:210"

$at_failed && at_func_log_failure
$at_traceon; }



cat >cxx.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%skeleton "lalr1.cc"
%code { int yylex (yy::parser::semantic_type*); }
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:210: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"@@.c\" --defines=\"@@.h\" cxx.y"
echo output.at:210 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "@@.c" --defines="@@.h" cxx.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "@@.c" --defines="@@.h" cxx.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:210"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:210: bison --xml=xml-tests/test.xml -o \"@@.c\" --defines=\"@@.h\" cxx.y"
echo output.at:210 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o "@@.c" --defines="@@.h" cxx.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o "@@.c" --defines="@@.h" cxx.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:210"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:210: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:210 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:210"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:210: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:210 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:210"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:210: bison -o \"@@.c\" --defines=\"@@.h\" cxx.y"
echo output.at:210 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o "@@.c" --defines="@@.h" cxx.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o "@@.c" --defines="@@.h" cxx.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:210"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:210: ls \"@@.c\" \"@@.h\""
echo output.at:210 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls "@@.c" "@@.h" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls "@@.c" "@@.h" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:210"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/output.at:210: \$BISON_CXX_WORKS"
echo output.at:210 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:210"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:210: \$CXX \$CXXFLAGS \$CPPFLAGS -o cxx.o -c \"@@.c\""
echo output.at:210 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c \"@@.c\""; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c "@@.c" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c "@@.c" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:210"

$at_failed && at_func_log_failure
$at_traceon; }



  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_55
#AT_START_56
# 56. output.at:211: Output file name: @{
at_setup_line='output.at:211'
at_func_banner 2
at_desc="Output file name: @{"
$at_quiet $as_echo_n " 56: $at_desc                           "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "56. output.at:211: testing ..."
  $at_traceon


cat >glr.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%glr-parser
%code {
  int yylex (void);
  void yyerror (const char *);
}
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:211: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"@{.c\" --defines=\"@{.h\" glr.y"
echo output.at:211 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "@{.c" --defines="@{.h" glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "@{.c" --defines="@{.h" glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:211"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:211: bison --xml=xml-tests/test.xml -o \"@{.c\" --defines=\"@{.h\" glr.y"
echo output.at:211 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o "@{.c" --defines="@{.h" glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o "@{.c" --defines="@{.h" glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:211"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:211: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:211 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:211"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:211: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:211 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:211"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:211: bison -o \"@{.c\" --defines=\"@{.h\" glr.y"
echo output.at:211 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o "@{.c" --defines="@{.h" glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o "@{.c" --defines="@{.h" glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:211"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:211: ls \"@{.c\" \"@{.h\""
echo output.at:211 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls "@{.c" "@{.h" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls "@{.c" "@{.h" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:211"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:211: \$CC \$CFLAGS \$CPPFLAGS -o glr.o -c \"@{.c\""
echo output.at:211 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -o glr.o -c \"@{.c\""; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -o glr.o -c "@{.c" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -o glr.o -c "@{.c" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:211"

$at_failed && at_func_log_failure
$at_traceon; }



cat >cxx.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%skeleton "lalr1.cc"
%code { int yylex (yy::parser::semantic_type*); }
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:211: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"@{.c\" --defines=\"@{.h\" cxx.y"
echo output.at:211 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "@{.c" --defines="@{.h" cxx.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "@{.c" --defines="@{.h" cxx.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:211"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:211: bison --xml=xml-tests/test.xml -o \"@{.c\" --defines=\"@{.h\" cxx.y"
echo output.at:211 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o "@{.c" --defines="@{.h" cxx.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o "@{.c" --defines="@{.h" cxx.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:211"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:211: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:211 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:211"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:211: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:211 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:211"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:211: bison -o \"@{.c\" --defines=\"@{.h\" cxx.y"
echo output.at:211 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o "@{.c" --defines="@{.h" cxx.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o "@{.c" --defines="@{.h" cxx.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:211"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:211: ls \"@{.c\" \"@{.h\""
echo output.at:211 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls "@{.c" "@{.h" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls "@{.c" "@{.h" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:211"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/output.at:211: \$BISON_CXX_WORKS"
echo output.at:211 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:211"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:211: \$CXX \$CXXFLAGS \$CPPFLAGS -o cxx.o -c \"@{.c\""
echo output.at:211 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c \"@{.c\""; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c "@{.c" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c "@{.c" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:211"

$at_failed && at_func_log_failure
$at_traceon; }



  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_56
#AT_START_57
# 57. output.at:212: Output file name: @}
at_setup_line='output.at:212'
at_func_banner 2
at_desc="Output file name: @}"
$at_quiet $as_echo_n " 57: $at_desc                           "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "57. output.at:212: testing ..."
  $at_traceon


cat >glr.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%glr-parser
%code {
  int yylex (void);
  void yyerror (const char *);
}
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:212: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"@}.c\" --defines=\"@}.h\" glr.y"
echo output.at:212 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "@}.c" --defines="@}.h" glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "@}.c" --defines="@}.h" glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:212"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:212: bison --xml=xml-tests/test.xml -o \"@}.c\" --defines=\"@}.h\" glr.y"
echo output.at:212 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o "@}.c" --defines="@}.h" glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o "@}.c" --defines="@}.h" glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:212"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:212: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:212 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:212"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:212: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:212 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:212"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:212: bison -o \"@}.c\" --defines=\"@}.h\" glr.y"
echo output.at:212 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o "@}.c" --defines="@}.h" glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o "@}.c" --defines="@}.h" glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:212"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:212: ls \"@}.c\" \"@}.h\""
echo output.at:212 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls "@}.c" "@}.h" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls "@}.c" "@}.h" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:212"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:212: \$CC \$CFLAGS \$CPPFLAGS -o glr.o -c \"@}.c\""
echo output.at:212 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -o glr.o -c \"@}.c\""; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -o glr.o -c "@}.c" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -o glr.o -c "@}.c" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:212"

$at_failed && at_func_log_failure
$at_traceon; }



cat >cxx.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%skeleton "lalr1.cc"
%code { int yylex (yy::parser::semantic_type*); }
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:212: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"@}.c\" --defines=\"@}.h\" cxx.y"
echo output.at:212 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "@}.c" --defines="@}.h" cxx.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "@}.c" --defines="@}.h" cxx.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:212"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:212: bison --xml=xml-tests/test.xml -o \"@}.c\" --defines=\"@}.h\" cxx.y"
echo output.at:212 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o "@}.c" --defines="@}.h" cxx.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o "@}.c" --defines="@}.h" cxx.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:212"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:212: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:212 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:212"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:212: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:212 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:212"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:212: bison -o \"@}.c\" --defines=\"@}.h\" cxx.y"
echo output.at:212 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o "@}.c" --defines="@}.h" cxx.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o "@}.c" --defines="@}.h" cxx.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:212"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:212: ls \"@}.c\" \"@}.h\""
echo output.at:212 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls "@}.c" "@}.h" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls "@}.c" "@}.h" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:212"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/output.at:212: \$BISON_CXX_WORKS"
echo output.at:212 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:212"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:212: \$CXX \$CXXFLAGS \$CPPFLAGS -o cxx.o -c \"@}.c\""
echo output.at:212 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c \"@}.c\""; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c "@}.c" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c "@}.c" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:212"

$at_failed && at_func_log_failure
$at_traceon; }



  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_57
#AT_START_58
# 58. output.at:213: Output file name: [
at_setup_line='output.at:213'
at_func_banner 2
at_desc="Output file name: ["
$at_quiet $as_echo_n " 58: $at_desc                            "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "58. output.at:213: testing ..."
  $at_traceon


cat >glr.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%glr-parser
%code {
  int yylex (void);
  void yyerror (const char *);
}
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:213: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"[.c\" --defines=\"[.h\" glr.y"
echo output.at:213 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "[.c" --defines="[.h" glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "[.c" --defines="[.h" glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:213"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:213: bison --xml=xml-tests/test.xml -o \"[.c\" --defines=\"[.h\" glr.y"
echo output.at:213 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o "[.c" --defines="[.h" glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o "[.c" --defines="[.h" glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:213"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:213: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:213 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:213"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:213: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:213 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:213"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:213: bison -o \"[.c\" --defines=\"[.h\" glr.y"
echo output.at:213 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o "[.c" --defines="[.h" glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o "[.c" --defines="[.h" glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:213"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:213: ls \"[.c\" \"[.h\""
echo output.at:213 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls "[.c" "[.h" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls "[.c" "[.h" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:213"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:213: \$CC \$CFLAGS \$CPPFLAGS -o glr.o -c \"[.c\""
echo output.at:213 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -o glr.o -c \"[.c\""; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -o glr.o -c "[.c" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -o glr.o -c "[.c" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:213"

$at_failed && at_func_log_failure
$at_traceon; }



cat >cxx.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%skeleton "lalr1.cc"
%code { int yylex (yy::parser::semantic_type*); }
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:213: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"[.c\" --defines=\"[.h\" cxx.y"
echo output.at:213 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "[.c" --defines="[.h" cxx.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "[.c" --defines="[.h" cxx.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:213"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:213: bison --xml=xml-tests/test.xml -o \"[.c\" --defines=\"[.h\" cxx.y"
echo output.at:213 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o "[.c" --defines="[.h" cxx.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o "[.c" --defines="[.h" cxx.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:213"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:213: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:213 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:213"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:213: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:213 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:213"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:213: bison -o \"[.c\" --defines=\"[.h\" cxx.y"
echo output.at:213 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o "[.c" --defines="[.h" cxx.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o "[.c" --defines="[.h" cxx.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:213"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:213: ls \"[.c\" \"[.h\""
echo output.at:213 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls "[.c" "[.h" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls "[.c" "[.h" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:213"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/output.at:213: \$BISON_CXX_WORKS"
echo output.at:213 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:213"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:213: \$CXX \$CXXFLAGS \$CPPFLAGS -o cxx.o -c \"[.c\""
echo output.at:213 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c \"[.c\""; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c "[.c" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c "[.c" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:213"

$at_failed && at_func_log_failure
$at_traceon; }



  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_58
#AT_START_59
# 59. output.at:214: Output file name: ]
at_setup_line='output.at:214'
at_func_banner 2
at_desc="Output file name: ]"
$at_quiet $as_echo_n " 59: $at_desc                            "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "59. output.at:214: testing ..."
  $at_traceon


cat >glr.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%glr-parser
%code {
  int yylex (void);
  void yyerror (const char *);
}
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:214: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"].c\" --defines=\"].h\" glr.y"
echo output.at:214 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "].c" --defines="].h" glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "].c" --defines="].h" glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:214"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:214: bison --xml=xml-tests/test.xml -o \"].c\" --defines=\"].h\" glr.y"
echo output.at:214 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o "].c" --defines="].h" glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o "].c" --defines="].h" glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:214"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:214: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:214 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:214"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:214: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:214 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:214"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:214: bison -o \"].c\" --defines=\"].h\" glr.y"
echo output.at:214 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o "].c" --defines="].h" glr.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o "].c" --defines="].h" glr.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:214"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:214: ls \"].c\" \"].h\""
echo output.at:214 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls "].c" "].h" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls "].c" "].h" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:214"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:214: \$CC \$CFLAGS \$CPPFLAGS -o glr.o -c \"].c\""
echo output.at:214 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -o glr.o -c \"].c\""; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -o glr.o -c "].c" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -o glr.o -c "].c" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:214"

$at_failed && at_func_log_failure
$at_traceon; }



cat >cxx.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%skeleton "lalr1.cc"
%code { int yylex (yy::parser::semantic_type*); }
%%
start: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/output.at:214: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o \"].c\" --defines=\"].h\" cxx.y"
echo output.at:214 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "].c" --defines="].h" cxx.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o "].c" --defines="].h" cxx.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:214"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/output.at:214: bison --xml=xml-tests/test.xml -o \"].c\" --defines=\"].h\" cxx.y"
echo output.at:214 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o "].c" --defines="].h" cxx.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o "].c" --defines="].h" cxx.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:214"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:214: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo output.at:214 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:214"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/output.at:214: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo output.at:214 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:214"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/output.at:214: bison -o \"].c\" --defines=\"].h\" cxx.y"
echo output.at:214 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o "].c" --defines="].h" cxx.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o "].c" --defines="].h" cxx.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/output.at:214"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:214: ls \"].c\" \"].h\""
echo output.at:214 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls "].c" "].h" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls "].c" "].h" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:214"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/output.at:214: \$BISON_CXX_WORKS"
echo output.at:214 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:214"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/output.at:214: \$CXX \$CXXFLAGS \$CPPFLAGS -o cxx.o -c \"].c\""
echo output.at:214 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c \"].c\""; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c "].c" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS -o cxx.o -c "].c" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/output.at:214"

$at_failed && at_func_log_failure
$at_traceon; }



  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_59
#AT_START_60
# 60. skeletons.at:23: Relative skeleton file names
at_setup_line='skeletons.at:23'
at_func_banner 3
at_desc="Relative skeleton file names"
$at_quiet $as_echo_n " 60: $at_desc                   "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "60. skeletons.at:23: testing ..."
  $at_traceon


{ $at_traceoff
$as_echo "$at_srcdir/skeletons.at:25: mkdir tmp"
echo skeletons.at:25 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; mkdir tmp ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; mkdir tmp ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:25"

$at_failed && at_func_log_failure
$at_traceon; }


cat >tmp/skel.c <<'_ATEOF'
m4_divert_push(0)dnl
@output(b4_parser_file_name@)dnl
b4_percent_define_get([[test]])
m4_divert_pop(0)
_ATEOF


cat >skel.c <<'_ATEOF'
m4_divert_push(0)dnl
@output(b4_parser_file_name@)dnl
b4_percent_define_get([[test]]) -- Local
m4_divert_pop(0)
_ATEOF


cat >tmp/input-gram.y <<'_ATEOF'
%skeleton "./skel.c"
%define test "Hello World"
%%
start: ;
_ATEOF


cat >input-gram.y <<'_ATEOF'
%skeleton "./skel.c"
%define test "Hello World"
%%
start: ;
_ATEOF


cat >tmp/input-cmd-line.y <<'_ATEOF'
%define test "Hello World"
%%
start: ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/skeletons.at:61: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot tmp/input-gram.y"
echo skeletons.at:61 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot tmp/input-gram.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot tmp/input-gram.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:61"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/skeletons.at:61: bison --xml=xml-tests/test.xml tmp/input-gram.y"
echo skeletons.at:61 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml tmp/input-gram.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml tmp/input-gram.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:61"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/skeletons.at:61: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo skeletons.at:61 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:61"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/skeletons.at:61: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo skeletons.at:61 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:61"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/skeletons.at:61: bison tmp/input-gram.y"
echo skeletons.at:61 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison tmp/input-gram.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison tmp/input-gram.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:61"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/skeletons.at:62: cat input-gram.tab.c"
echo skeletons.at:62 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat input-gram.tab.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat input-gram.tab.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Hello World
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:62"

$at_failed && at_func_log_failure
$at_traceon; }


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/skeletons.at:66: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input-gram.y"
echo skeletons.at:66 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input-gram.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input-gram.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:66"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/skeletons.at:66: bison --xml=xml-tests/test.xml input-gram.y"
echo skeletons.at:66 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml input-gram.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml input-gram.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:66"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/skeletons.at:66: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo skeletons.at:66 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:66"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/skeletons.at:66: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo skeletons.at:66 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:66"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/skeletons.at:66: bison input-gram.y"
echo skeletons.at:66 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison input-gram.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison input-gram.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:66"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/skeletons.at:67: cat input-gram.tab.c"
echo skeletons.at:67 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat input-gram.tab.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat input-gram.tab.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Hello World -- Local
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:67"

$at_failed && at_func_log_failure
$at_traceon; }


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/skeletons.at:71: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --skeleton=tmp/skel.c tmp/input-cmd-line.y"
echo skeletons.at:71 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --skeleton=tmp/skel.c tmp/input-cmd-line.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --skeleton=tmp/skel.c tmp/input-cmd-line.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:71"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/skeletons.at:71: bison --xml=xml-tests/test.xml --skeleton=tmp/skel.c tmp/input-cmd-line.y"
echo skeletons.at:71 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml --skeleton=tmp/skel.c tmp/input-cmd-line.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml --skeleton=tmp/skel.c tmp/input-cmd-line.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:71"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/skeletons.at:71: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo skeletons.at:71 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:71"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/skeletons.at:71: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo skeletons.at:71 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:71"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/skeletons.at:71: bison --skeleton=tmp/skel.c tmp/input-cmd-line.y"
echo skeletons.at:71 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --skeleton=tmp/skel.c tmp/input-cmd-line.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --skeleton=tmp/skel.c tmp/input-cmd-line.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:71"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/skeletons.at:72: cat input-cmd-line.tab.c"
echo skeletons.at:72 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat input-cmd-line.tab.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat input-cmd-line.tab.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Hello World
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:72"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_60
#AT_START_61
# 61. skeletons.at:83: Installed skeleton file names
at_setup_line='skeletons.at:83'
at_func_banner 3
at_desc="Installed skeleton file names"
$at_quiet $as_echo_n " 61: $at_desc                  "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "61. skeletons.at:83: testing ..."
  $at_traceon




cat >input-cmd-line.y <<'_ATEOF'
%{
  #include <stdio.h>
  void yyerror (char const *msg);
  int yylex (void);
%}

%error-verbose
%token 'a'

%%

start: ;

%%

void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
yylex (void)
{
  return 'a';
}

int
main (void)
{
  return yyparse ();
}
_ATEOF


cat >input-gram.y <<'_ATEOF'
%skeleton "yacc.c"
%{
  #include <stdio.h>
  void yyerror (char const *msg);
  int yylex (void);
%}

%error-verbose
%token 'a'

%%

start: ;

%%

void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
yylex (void)
{
  return 'a';
}

int
main (void)
{
  return yyparse ();
}
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/skeletons.at:127: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --skeleton=yacc.c -o input-cmd-line.c input-cmd-line.y"
echo skeletons.at:127 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --skeleton=yacc.c -o input-cmd-line.c input-cmd-line.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --skeleton=yacc.c -o input-cmd-line.c input-cmd-line.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:127"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/skeletons.at:127: bison --xml=xml-tests/test.xml --skeleton=yacc.c -o input-cmd-line.c input-cmd-line.y"
echo skeletons.at:127 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml --skeleton=yacc.c -o input-cmd-line.c input-cmd-line.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml --skeleton=yacc.c -o input-cmd-line.c input-cmd-line.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:127"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/skeletons.at:127: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo skeletons.at:127 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:127"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/skeletons.at:127: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo skeletons.at:127 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:127"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/skeletons.at:127: bison --skeleton=yacc.c -o input-cmd-line.c input-cmd-line.y"
echo skeletons.at:127 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --skeleton=yacc.c -o input-cmd-line.c input-cmd-line.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --skeleton=yacc.c -o input-cmd-line.c input-cmd-line.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:127"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/skeletons.at:128: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input-cmd-line input-cmd-line.c \$LIBS"
echo skeletons.at:128 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input-cmd-line input-cmd-line.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input-cmd-line input-cmd-line.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input-cmd-line input-cmd-line.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:128"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/skeletons.at:129:  \$PREPARSER ./input-cmd-line"
echo skeletons.at:129 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input-cmd-line"; then
  ( $at_traceon;  $PREPARSER ./input-cmd-line ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input-cmd-line ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "syntax error, unexpected 'a', expecting \$end
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/skeletons.at:129"

$at_failed && at_func_log_failure
$at_traceon; }


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/skeletons.at:133: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input-gram.c input-gram.y"
echo skeletons.at:133 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input-gram.c input-gram.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input-gram.c input-gram.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:133"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/skeletons.at:133: bison --xml=xml-tests/test.xml -o input-gram.c input-gram.y"
echo skeletons.at:133 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input-gram.c input-gram.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input-gram.c input-gram.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:133"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/skeletons.at:133: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo skeletons.at:133 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:133"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/skeletons.at:133: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo skeletons.at:133 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:133"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/skeletons.at:133: bison -o input-gram.c input-gram.y"
echo skeletons.at:133 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input-gram.c input-gram.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input-gram.c input-gram.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:133"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/skeletons.at:134: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input-gram input-gram.c \$LIBS"
echo skeletons.at:134 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input-gram input-gram.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input-gram input-gram.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input-gram input-gram.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/skeletons.at:134"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/skeletons.at:135:  \$PREPARSER ./input-gram"
echo skeletons.at:135 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input-gram"; then
  ( $at_traceon;  $PREPARSER ./input-gram ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input-gram ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "syntax error, unexpected 'a', expecting \$end
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/skeletons.at:135"

$at_failed && at_func_log_failure
$at_traceon; }




  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_61
#AT_START_62
# 62. skeletons.at:148: %define Boolean variables: invalid skeleton defaults
at_setup_line='skeletons.at:148'
at_func_banner 3
at_desc="%define Boolean variables: invalid skeleton defaults"
$at_quiet $as_echo_n " 62: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "62. skeletons.at:148: testing ..."
  $at_traceon


cat >skel.c <<'_ATEOF'
b4_percent_define_default([[foo]], [[bogus value]])
b4_percent_define_flag_if([[foo]])
_ATEOF


cat >input.y <<'_ATEOF'
%skeleton "./skel.c"
%%
start: ;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/skeletons.at:161: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
echo skeletons.at:161 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "[Bison:b4_percent_define_default]:1.0: invalid value for %define Boolean variable \`foo'
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/skeletons.at:161"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_62
#AT_START_63
# 63. skeletons.at:172: Complaining during macro argument expansion
at_setup_line='skeletons.at:172'
at_func_banner 3
at_desc="Complaining during macro argument expansion"
$at_quiet $as_echo_n " 63: $at_desc    "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "63. skeletons.at:172: testing ..."
  $at_traceon


cat >skel1.c <<'_ATEOF'
m4_define([foow], [b4_warn([[foow fubar]])])
m4_define([foowat], [b4_warn_at([[foow.y:2.3]],
                                    [[foow.y:5.4]], [[foowat fubar]])])
m4_define([fooc], [b4_complain([[fooc fubar]])])
m4_define([foocat], [b4_complain_at([[fooc.y:1.1]],
                                        [[fooc.y:10.6]], [[foocat fubar]])])
m4_define([foof], [b4_fatal([[foof fubar]])])
m4_if(foow, [1], [yes])
m4_if(foowat, [1], [yes])
m4_if(fooc, [1], [yes])
m4_if(foocat, [1], [yes])
m4_if(foof, [1], [yes])
_ATEOF


cat >input1.y <<'_ATEOF'
%skeleton "./skel1.c"
%%
start: ;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/skeletons.at:195: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input1.y"
echo skeletons.at:195 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input1.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input1.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input1.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input1.y: warning: foow fubar
foow.y:2.3-5.3: warning: foowat fubar
input1.y: fooc fubar
fooc.y:1.1-10.5: foocat fubar
input1.y: fatal error: foof fubar
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/skeletons.at:195"

$at_failed && at_func_log_failure
$at_traceon; }


cat >skel2.c <<'_ATEOF'
m4_define([foofat], [b4_fatal_at([[foof.y:12.11]],
                                       [[foof.y:100.123]], [[foofat fubar]])])
m4_if(foofat, [1], [yes])
_ATEOF


cat >input2.y <<'_ATEOF'
%skeleton "./skel2.c"
%%
start: ;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/skeletons.at:215: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input2.y"
echo skeletons.at:215 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input2.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input2.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input2.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "foof.y:12.11-100.122: fatal error: foofat fubar
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/skeletons.at:215"

$at_failed && at_func_log_failure
$at_traceon; }


cat >skel3.c <<'_ATEOF'
b4_complain_at(b4_percent_define_get_loc([[bogus]]), [[bad value]])
_ATEOF


cat >input3.y <<'_ATEOF'
%skeleton "./skel3.c"
%%
start: ;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/skeletons.at:229: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input3.y"
echo skeletons.at:229 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input3.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input3.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input3.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input3.y: fatal error: undefined %define variable \`bogus' passed to b4_percent_define_get_loc
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/skeletons.at:229"

$at_failed && at_func_log_failure
$at_traceon; }


cat >skel4.c <<'_ATEOF'
b4_warn_at(b4_percent_define_get_syncline([[bogus]]), [[bad value]])
_ATEOF


cat >input4.y <<'_ATEOF'
%skeleton "./skel4.c"
%%
start: ;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/skeletons.at:243: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input4.y"
echo skeletons.at:243 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input4.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input4.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input4.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input4.y: fatal error: undefined %define variable \`bogus' passed to b4_percent_define_get_syncline
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/skeletons.at:243"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_63
#AT_START_64
# 64. skeletons.at:254: Fatal errors make M4 exit immediately
at_setup_line='skeletons.at:254'
at_func_banner 3
at_desc="Fatal errors make M4 exit immediately"
$at_quiet $as_echo_n " 64: $at_desc          "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "64. skeletons.at:254: testing ..."
  $at_traceon


cat >skel1.c <<'_ATEOF'
b4_complain([[non-fatal error]])
b4_fatal([[M4 should exit immediately here]])
m4_fatal([this should never be evaluated])
_ATEOF


cat >input1.y <<'_ATEOF'
%skeleton "./skel1.c"
%%
start: ;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/skeletons.at:268: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input1.y"
echo skeletons.at:268 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input1.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input1.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input1.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input1.y: non-fatal error
input1.y: fatal error: M4 should exit immediately here
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/skeletons.at:268"

$at_failed && at_func_log_failure
$at_traceon; }


cat >skel2.c <<'_ATEOF'
b4_warn([[morning]])
b4_fatal_at([[foo.y:1.5]], [[foo.y:1.7]], [[M4 should exit immediately here]])
m4_fatal([this should never be evaluated])
_ATEOF


cat >input2.y <<'_ATEOF'
%skeleton "./skel2.c"
%%
start: ;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/skeletons.at:285: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input2.y"
echo skeletons.at:285 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input2.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input2.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input2.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input2.y: warning: morning
foo.y:1.5-6: fatal error: M4 should exit immediately here
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/skeletons.at:285"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_64
#AT_START_65
# 65. sets.at:64: Nullable
at_setup_line='sets.at:64'
at_func_banner 4
at_desc="Nullable"
$at_quiet $as_echo_n " 65: $at_desc                                       "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "65. sets.at:64: testing ..."
  $at_traceon


# At some point, nullable had been smoking grass, and managed to say:
#
# Entering set_nullable
# NULLABLE
#         'e': yes
#         (null): no
# ...

cat >input.y <<'_ATEOF'
%%
e: 'e' | /* Nothing */;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/sets.at:79: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --trace=sets input.y"
echo sets.at:79 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --trace=sets input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --trace=sets input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/sets.at:79"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/sets.at:79: bison --xml=xml-tests/test.xml --trace=sets input.y"
echo sets.at:79 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml --trace=sets input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml --trace=sets input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/sets.at:79"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/sets.at:79: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo sets.at:79 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/sets.at:79"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/sets.at:79: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo sets.at:79 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/sets.at:79"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/sets.at:79: bison --trace=sets input.y"
echo sets.at:79 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --trace=sets input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --trace=sets input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/sets.at:79"

$at_failed && at_func_log_failure
$at_traceon; }

cat >extract.sed <<'_ATEOF'
#n
/^NULLABLE$/ {
   :null
   p
   n
   /^[	 ]*$/ !b null
}
/^FIRSTS$/ {
   :firsts
   p
   n
   /^[	 ]*$/ !b firsts
}
/^FDERIVES$/ {
   :fderiv
   p
   n
   /^[	 ]*$/ !b fderiv
}
/^DERIVES$/ {
   :deriv
   p
   n
   /^[	 ]*$/ !b deriv
}
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/sets.at:80: sed -f extract.sed stderr"
echo sets.at:80 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; sed -f extract.sed stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed -f extract.sed stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/sets.at:80"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/sets.at:80: mv stdout sets"
echo sets.at:80 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; mv stdout sets ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; mv stdout sets ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/sets.at:80"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/sets.at:81: cat sets"
echo sets.at:81 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat sets ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat sets ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "DERIVES
	\$accept derives
		  0  e \$end
	e derives
		  1  'e'
		  2  /* empty */
NULLABLE
	\$accept: no
	e: yes
FIRSTS
	\$accept firsts
		\$accept
		e
	e firsts
		e
FDERIVES
	\$accept derives
		  0  e \$end
		  1  'e'
		  2  /* empty */
	e derives
		  1  'e'
		  2  /* empty */
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/sets.at:81"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_65
#AT_START_66
# 66. sets.at:149: Broken Closure
at_setup_line='sets.at:149'
at_func_banner 4
at_desc="Broken Closure"
$at_quiet $as_echo_n " 66: $at_desc                                 "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "66. sets.at:149: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%%
a: b;
b: c;
c: d;
d: e;
e: f;
f: g;
g: h;
h: 'h';
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/sets.at:163: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --trace=sets input.y"
echo sets.at:163 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --trace=sets input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --trace=sets input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/sets.at:163"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/sets.at:163: bison --xml=xml-tests/test.xml --trace=sets input.y"
echo sets.at:163 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml --trace=sets input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml --trace=sets input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/sets.at:163"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/sets.at:163: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo sets.at:163 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/sets.at:163"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/sets.at:163: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo sets.at:163 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/sets.at:163"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/sets.at:163: bison --trace=sets input.y"
echo sets.at:163 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --trace=sets input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --trace=sets input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/sets.at:163"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/sets.at:165: sed -n 's/[	 ]*\$//;/^RTC: Firsts Output BEGIN/,/^RTC: Firsts Output END/p' stderr"
echo sets.at:165 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "sed -n 's/[	 ]*$//;/^RTC: Firsts Output BEGIN/,/^RTC: Firsts Output END/p' stderr"; then
  ( $at_traceon; sed -n 's/[	 ]*$//;/^RTC: Firsts Output BEGIN/,/^RTC: Firsts Output END/p' stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed -n 's/[	 ]*$//;/^RTC: Firsts Output BEGIN/,/^RTC: Firsts Output END/p' stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "RTC: Firsts Output BEGIN

   012345678
  .---------.
 0|111111111|
 1| 11111111|
 2|  1111111|
 3|   111111|
 4|    11111|
 5|     1111|
 6|      111|
 7|       11|
 8|        1|
  \`---------'
RTC: Firsts Output END
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/sets.at:165"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_66
#AT_START_67
# 67. sets.at:191: Firsts
at_setup_line='sets.at:191'
at_func_banner 4
at_desc="Firsts"
$at_quiet $as_echo_n " 67: $at_desc                                         "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "67. sets.at:191: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%nonassoc '<' '>'
%left '+' '-'
%right '^' '='
%%
exp:
   exp '<' exp
 | exp '>' exp
 | exp '+' exp
 | exp '-' exp
 | exp '^' exp
 | exp '=' exp
 | "exp"
 ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/sets.at:209: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --trace=sets input.y"
echo sets.at:209 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --trace=sets input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --trace=sets input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/sets.at:209"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/sets.at:209: bison --xml=xml-tests/test.xml --trace=sets input.y"
echo sets.at:209 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml --trace=sets input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml --trace=sets input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/sets.at:209"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/sets.at:209: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo sets.at:209 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/sets.at:209"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/sets.at:209: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo sets.at:209 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/sets.at:209"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/sets.at:209: bison --trace=sets input.y"
echo sets.at:209 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --trace=sets input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --trace=sets input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/sets.at:209"

$at_failed && at_func_log_failure
$at_traceon; }

cat >extract.sed <<'_ATEOF'
#n
/^NULLABLE$/ {
   :null
   p
   n
   /^[	 ]*$/ !b null
}
/^FIRSTS$/ {
   :firsts
   p
   n
   /^[	 ]*$/ !b firsts
}
/^FDERIVES$/ {
   :fderiv
   p
   n
   /^[	 ]*$/ !b fderiv
}
/^DERIVES$/ {
   :deriv
   p
   n
   /^[	 ]*$/ !b deriv
}
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/sets.at:210: sed -f extract.sed stderr"
echo sets.at:210 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; sed -f extract.sed stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed -f extract.sed stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/sets.at:210"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/sets.at:210: mv stdout sets"
echo sets.at:210 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; mv stdout sets ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; mv stdout sets ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/sets.at:210"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/sets.at:211: cat sets"
echo sets.at:211 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat sets ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat sets ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "DERIVES
	\$accept derives
		  0  exp \$end
	exp derives
		  1  exp '<' exp
		  2  exp '>' exp
		  3  exp '+' exp
		  4  exp '-' exp
		  5  exp '^' exp
		  6  exp '=' exp
		  7  \"exp\"
NULLABLE
	\$accept: no
	exp: no
FIRSTS
	\$accept firsts
		\$accept
		exp
	exp firsts
		exp
FDERIVES
	\$accept derives
		  0  exp \$end
		  1  exp '<' exp
		  2  exp '>' exp
		  3  exp '+' exp
		  4  exp '-' exp
		  5  exp '^' exp
		  6  exp '=' exp
		  7  \"exp\"
	exp derives
		  1  exp '<' exp
		  2  exp '>' exp
		  3  exp '+' exp
		  4  exp '-' exp
		  5  exp '^' exp
		  6  exp '=' exp
		  7  \"exp\"
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/sets.at:211"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_67
#AT_START_68
# 68. sets.at:267: Accept
at_setup_line='sets.at:267'
at_func_banner 4
at_desc="Accept"
$at_quiet $as_echo_n " 68: $at_desc                                         "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "68. sets.at:267: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%token END 0
%%
input:
  'a'
| '(' input ')'
| '(' error END
;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/sets.at:279: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -v -o input.c input.y"
echo sets.at:279 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/sets.at:279"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/sets.at:279: bison --xml=xml-tests/test.xml -v -o input.c input.y"
echo sets.at:279 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/sets.at:279"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/sets.at:279: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo sets.at:279 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/sets.at:279"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/sets.at:279: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo sets.at:279 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/sets.at:279"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/sets.at:279: bison -v -o input.c input.y"
echo sets.at:279 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/sets.at:279"

$at_failed && at_func_log_failure
$at_traceon; }


# Get the final state in the parser.
{ $at_traceoff
$as_echo "$at_srcdir/sets.at:282: sed -n 's/.*define YYFINAL *\\([0-9][0-9]*\\)/final state \\1/p' input.c"
echo sets.at:282 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; sed -n 's/.*define YYFINAL *\([0-9][0-9]*\)/final state \1/p' input.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed -n 's/.*define YYFINAL *\([0-9][0-9]*\)/final state \1/p' input.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/sets.at:282"

$at_failed && at_func_log_failure
$at_traceon; }

mv stdout expout

# Get the final state in the report, from the "accept" action..
{ $at_traceoff
$as_echo "$at_srcdir/sets.at:287: sed -n '
           /^state \\(.*\\)/{
	     s//final state \\1/
	     x
	   }
	   / accept/{
	     x
	     p
	     q
	   }
	' input.output"
echo sets.at:287 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; sed -n '
           /^state \(.*\)/{
	     s//final state \1/
	     x
	   }
	   / accept/{
	     x
	     p
	     q
	   }
	' input.output ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed -n '
           /^state \(.*\)/{
	     s//final state \1/
	     x
	   }
	   / accept/{
	     x
	     p
	     q
	   }
	' input.output ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/sets.at:287"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_68
#AT_START_69
# 69. reduce.at:24: Useless Terminals
at_setup_line='reduce.at:24'
at_func_banner 5
at_desc="Useless Terminals"
$at_quiet $as_echo_n " 69: $at_desc                              "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "69. reduce.at:24: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%verbose
%output "input.c"

%token useless1
%token useless2
%token useless3
%token useless4
%token useless5
%token useless6
%token useless7
%token useless8
%token useless9

%token useful
%%
exp: useful;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/reduce.at:45: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input.y"
echo reduce.at:45 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:45"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/reduce.at:45: bison --xml=xml-tests/test.xml input.y"
echo reduce.at:45 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:45"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/reduce.at:45: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo reduce.at:45 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:45"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/reduce.at:45: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo reduce.at:45 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:45"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/reduce.at:45: bison input.y"
echo reduce.at:45 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:45"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/reduce.at:47: sed -n '/^Grammar/q;/^\$/!p' input.output"
echo reduce.at:47 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "sed -n '/^Grammar/q;/^$/!p' input.output"; then
  ( $at_traceon; sed -n '/^Grammar/q;/^$/!p' input.output ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed -n '/^Grammar/q;/^$/!p' input.output ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Terminals unused in grammar
   useless1
   useless2
   useless3
   useless4
   useless5
   useless6
   useless7
   useless8
   useless9
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:47"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_69
#AT_START_70
# 70. reduce.at:68: Useless Nonterminals
at_setup_line='reduce.at:68'
at_func_banner 5
at_desc="Useless Nonterminals"
$at_quiet $as_echo_n " 70: $at_desc                           "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "70. reduce.at:68: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%verbose
%output "input.c"

%nterm useless1
%nterm useless2
%nterm useless3
%nterm useless4
%nterm useless5
%nterm useless6
%nterm useless7
%nterm useless8
%nterm useless9

%token useful
%%
exp: useful;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/reduce.at:89: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input.y"
echo reduce.at:89 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:89"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/reduce.at:89: bison --xml=xml-tests/test.xml input.y"
echo reduce.at:89 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:89"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/reduce.at:89: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo reduce.at:89 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:89"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/reduce.at:89: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo reduce.at:89 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:89"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/reduce.at:89: bison input.y"
echo reduce.at:89 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y: warning: 9 nonterminals useless in grammar
input.y:4.8-15: warning: nonterminal useless in grammar: useless1
input.y:5.8-15: warning: nonterminal useless in grammar: useless2
input.y:6.8-15: warning: nonterminal useless in grammar: useless3
input.y:7.8-15: warning: nonterminal useless in grammar: useless4
input.y:8.8-15: warning: nonterminal useless in grammar: useless5
input.y:9.8-15: warning: nonterminal useless in grammar: useless6
input.y:10.8-15: warning: nonterminal useless in grammar: useless7
input.y:11.8-15: warning: nonterminal useless in grammar: useless8
input.y:12.8-15: warning: nonterminal useless in grammar: useless9
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:89"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/reduce.at:102: sed -n '/^Grammar/q;/^\$/!p' input.output"
echo reduce.at:102 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "sed -n '/^Grammar/q;/^$/!p' input.output"; then
  ( $at_traceon; sed -n '/^Grammar/q;/^$/!p' input.output ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed -n '/^Grammar/q;/^$/!p' input.output ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Nonterminals useless in grammar
   useless1
   useless2
   useless3
   useless4
   useless5
   useless6
   useless7
   useless8
   useless9
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:102"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_70
#AT_START_71
# 71. reduce.at:123: Useless Rules
at_setup_line='reduce.at:123'
at_func_banner 5
at_desc="Useless Rules"
$at_quiet $as_echo_n " 71: $at_desc                                  "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "71. reduce.at:123: testing ..."
  $at_traceon




cat >input.y <<'_ATEOF'
%verbose
%output "input.c"
%token useful
%%
exp: useful;
useless1: '1';
useless2: '2';
useless3: '3';
useless4: '4';
useless5: '5';
useless6: '6';
useless7: '7';
useless8: '8';
useless9: '9';
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/reduce.at:144: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input.y"
echo reduce.at:144 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:144"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/reduce.at:144: bison --xml=xml-tests/test.xml input.y"
echo reduce.at:144 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:144"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/reduce.at:144: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo reduce.at:144 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:144"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/reduce.at:144: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo reduce.at:144 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:144"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/reduce.at:144: bison input.y"
echo reduce.at:144 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y: warning: 9 nonterminals useless in grammar
input.y: warning: 9 rules useless in grammar
input.y:6.1-8: warning: nonterminal useless in grammar: useless1
input.y:7.1-8: warning: nonterminal useless in grammar: useless2
input.y:8.1-8: warning: nonterminal useless in grammar: useless3
input.y:9.1-8: warning: nonterminal useless in grammar: useless4
input.y:10.1-8: warning: nonterminal useless in grammar: useless5
input.y:11.1-8: warning: nonterminal useless in grammar: useless6
input.y:12.1-8: warning: nonterminal useless in grammar: useless7
input.y:13.1-8: warning: nonterminal useless in grammar: useless8
input.y:14.1-8: warning: nonterminal useless in grammar: useless9
input.y:6.11-13: warning: rule useless in grammar: useless1: '1'
input.y:7.11-13: warning: rule useless in grammar: useless2: '2'
input.y:8.11-13: warning: rule useless in grammar: useless3: '3'
input.y:9.11-13: warning: rule useless in grammar: useless4: '4'
input.y:10.11-13: warning: rule useless in grammar: useless5: '5'
input.y:11.11-13: warning: rule useless in grammar: useless6: '6'
input.y:12.11-13: warning: rule useless in grammar: useless7: '7'
input.y:13.11-13: warning: rule useless in grammar: useless8: '8'
input.y:14.11-13: warning: rule useless in grammar: useless9: '9'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:144"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/reduce.at:167: sed -n '/^Grammar/q;/^\$/!p' input.output"
echo reduce.at:167 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "sed -n '/^Grammar/q;/^$/!p' input.output"; then
  ( $at_traceon; sed -n '/^Grammar/q;/^$/!p' input.output ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed -n '/^Grammar/q;/^$/!p' input.output ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Nonterminals useless in grammar
   useless1
   useless2
   useless3
   useless4
   useless5
   useless6
   useless7
   useless8
   useless9
Terminals unused in grammar
   '1'
   '2'
   '3'
   '4'
   '5'
   '6'
   '7'
   '8'
   '9'
Rules useless in grammar
    2 useless1: '1'
    3 useless2: '2'
    4 useless3: '3'
    5 useless4: '4'
    6 useless5: '5'
    7 useless6: '6'
    8 useless7: '7'
    9 useless8: '8'
   10 useless9: '9'
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:167"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_71
#AT_START_72
# 72. reduce.at:211: Reduced Automaton
at_setup_line='reduce.at:211'
at_func_banner 5
at_desc="Reduced Automaton"
$at_quiet $as_echo_n " 72: $at_desc                              "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "72. reduce.at:211: testing ..."
  $at_traceon




# The non reduced grammar.
# ------------------------
cat >not-reduced.y <<'_ATEOF'
/* A useless token. */
%token useless_token
/* A useful one. */
%token useful
%verbose
%output "not-reduced.c"

%%

exp: useful            { /* A useful action. */ }
   | non_productive    { /* A non productive action. */ }
   ;

not_reachable: useful  { /* A not reachable action. */ }
             ;

non_productive: non_productive useless_token
                       { /* Another non productive action. */ }
              ;
%%
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/reduce.at:240: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot not-reduced.y"
echo reduce.at:240 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot not-reduced.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot not-reduced.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:240"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/reduce.at:240: bison --xml=xml-tests/test.xml not-reduced.y"
echo reduce.at:240 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml not-reduced.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml not-reduced.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:240"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/reduce.at:240: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo reduce.at:240 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:240"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/reduce.at:240: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo reduce.at:240 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:240"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/reduce.at:240: bison not-reduced.y"
echo reduce.at:240 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison not-reduced.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison not-reduced.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "not-reduced.y: warning: 2 nonterminals useless in grammar
not-reduced.y: warning: 3 rules useless in grammar
not-reduced.y:14.1-13: warning: nonterminal useless in grammar: not_reachable
not-reduced.y:11.6-19: warning: nonterminal useless in grammar: non_productive
not-reduced.y:11.6-57: warning: rule useless in grammar: exp: non_productive
not-reduced.y:14.16-56: warning: rule useless in grammar: not_reachable: useful
not-reduced.y:17.17-18.63: warning: rule useless in grammar: non_productive: non_productive useless_token
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:240"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/reduce.at:250: sed -n '/^Grammar/q;/^\$/!p' not-reduced.output"
echo reduce.at:250 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "sed -n '/^Grammar/q;/^$/!p' not-reduced.output"; then
  ( $at_traceon; sed -n '/^Grammar/q;/^$/!p' not-reduced.output ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed -n '/^Grammar/q;/^$/!p' not-reduced.output ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Nonterminals useless in grammar
   not_reachable
   non_productive
Terminals unused in grammar
   useless_token
Rules useless in grammar
    2 exp: non_productive
    3 not_reachable: useful
    4 non_productive: non_productive useless_token
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:250"

$at_failed && at_func_log_failure
$at_traceon; }


# The reduced grammar.
# --------------------
cat >reduced.y <<'_ATEOF'
/* A useless token. */
%token useless_token
/* A useful one. */
%token useful
%verbose
%output "reduced.c"

%%

exp: useful            { /* A useful action. */ }
//   | non_productive    { /* A non productive action. */ } */
   ;

//not_reachable: useful  { /* A not reachable action. */ }
//             ;

//non_productive: non_productive useless_token
//                       { /* Another non productive action. */ }
//              ;
%%
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/reduce.at:287: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot reduced.y"
echo reduce.at:287 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot reduced.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot reduced.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:287"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/reduce.at:287: bison --xml=xml-tests/test.xml reduced.y"
echo reduce.at:287 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml reduced.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml reduced.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:287"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/reduce.at:287: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo reduce.at:287 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:287"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/reduce.at:287: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo reduce.at:287 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:287"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/reduce.at:287: bison reduced.y"
echo reduce.at:287 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison reduced.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison reduced.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:287"

$at_failed && at_func_log_failure
$at_traceon; }


# Comparing the parsers.
cp reduced.c expout
{ $at_traceoff
$as_echo "$at_srcdir/reduce.at:291: sed 's/not-reduced/reduced/g' not-reduced.c"
echo reduce.at:291 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; sed 's/not-reduced/reduced/g' not-reduced.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed 's/not-reduced/reduced/g' not-reduced.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:291"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_72
#AT_START_73
# 73. reduce.at:301: Underivable Rules
at_setup_line='reduce.at:301'
at_func_banner 5
at_desc="Underivable Rules"
$at_quiet $as_echo_n " 73: $at_desc                              "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "73. reduce.at:301: testing ..."
  $at_traceon




cat >input.y <<'_ATEOF'
%verbose
%output "input.c"
%token useful
%%
exp: useful | underivable;
underivable: indirection;
indirection: underivable;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/reduce.at:315: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input.y"
echo reduce.at:315 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:315"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/reduce.at:315: bison --xml=xml-tests/test.xml input.y"
echo reduce.at:315 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:315"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/reduce.at:315: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo reduce.at:315 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:315"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/reduce.at:315: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo reduce.at:315 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:315"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/reduce.at:315: bison input.y"
echo reduce.at:315 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y: warning: 2 nonterminals useless in grammar
input.y: warning: 3 rules useless in grammar
input.y:5.15-25: warning: nonterminal useless in grammar: underivable
input.y:6.14-24: warning: nonterminal useless in grammar: indirection
input.y:5.15-25: warning: rule useless in grammar: exp: underivable
input.y:6.14-24: warning: rule useless in grammar: underivable: indirection
input.y:7.14-24: warning: rule useless in grammar: indirection: underivable
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:315"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/reduce.at:325: sed -n '/^Grammar/q;/^\$/!p' input.output"
echo reduce.at:325 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "sed -n '/^Grammar/q;/^$/!p' input.output"; then
  ( $at_traceon; sed -n '/^Grammar/q;/^$/!p' input.output ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed -n '/^Grammar/q;/^$/!p' input.output ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Nonterminals useless in grammar
   underivable
   indirection
Rules useless in grammar
    2 exp: underivable
    3 underivable: indirection
    4 indirection: underivable
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/reduce.at:325"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_73
#AT_START_74
# 74. reduce.at:343: Empty Language
at_setup_line='reduce.at:343'
at_func_banner 5
at_desc="Empty Language"
$at_quiet $as_echo_n " 74: $at_desc                                 "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "74. reduce.at:343: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%output "input.c"
%%
exp: exp;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/reduce.at:351: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
echo reduce.at:351 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y: warning: 2 nonterminals useless in grammar
input.y: warning: 2 rules useless in grammar
input.y:3.1-3: fatal error: start symbol exp does not derive any sentence
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/reduce.at:351"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_74
#AT_START_75
# 75. synclines.at:83: Prologue synch line
at_setup_line='synclines.at:83'
at_func_banner 6
at_desc="Prologue synch line"
$at_quiet $as_echo_n " 75: $at_desc                            "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "75. synclines.at:83: testing ..."
  $at_traceon


# It seems impossible to find a generic scheme to check the location
# of an error.  Even requiring GCC is not sufficient, since for instance
# the version modified by Apple:
#
# | Reading specs from /usr/libexec/gcc/darwin/ppc/2.95.2/specs
# | Apple Computer, Inc. version gcc-934.3, based on gcc version 2.95.2
# | 19991024 (release) configure:2124: $? = 0
#
# instead of:
#
# | input.y:2: #error "2"
#
# it reports:
#
# | input.y:2: "2"
# | cpp-precomp: warning: errors during smart preprocessing, retrying in basic mode

cat >syncline.c <<'_ATEOF'
#error "1"
_ATEOF


{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:83: \$CC \$CFLAGS \$CPPFLAGS -c syncline.c"
echo synclines.at:83 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -c syncline.c"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -c syncline.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -c syncline.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_skip $at_status "$at_srcdir/synclines.at:83"

$at_failed && at_func_log_failure
$at_traceon; }

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or
#   input.y:4.2: #error "4"    or
#   input.y:4:2: error: #error "4"
# =>
#   input.y:4: #error "4"
#
{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:83: sed -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/' stderr"
echo synclines.at:83 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "sed -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)$/\\1:\\2/' -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/' stderr"; then
  ( $at_traceon; sed -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/' stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/' stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:83"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:83: test \"\`cat stdout\`\" = 'syncline.c:1: #error \"1\"' || exit 77"
echo synclines.at:83 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; test "`cat stdout`" = 'syncline.c:1: #error "1"' || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test "`cat stdout`" = 'syncline.c:1: #error "1"' || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:83"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input.y <<'_ATEOF'
%{
#error "2"
void yyerror (const char *s);
int yylex (void);
%}
%%
exp: '0';
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/synclines.at:83: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo synclines.at:83 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:83"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/synclines.at:83: bison --xml=xml-tests/test.xml -o input.c input.y"
echo synclines.at:83 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:83"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/synclines.at:83: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo synclines.at:83 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:83"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/synclines.at:83: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo synclines.at:83 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:83"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:83: bison -o input.c input.y"
echo synclines.at:83 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:83"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:83: \$CC \$CFLAGS \$CPPFLAGS -c input.c"
echo synclines.at:83 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -c input.c"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -c input.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -c input.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_skip $at_status "$at_srcdir/synclines.at:83"

$at_failed && at_func_log_failure
$at_traceon; }

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or
#   input.y:4.2: #error "4"    or
#   input.y:4:2: error: #error "4"
# =>
#   input.y:4: #error "4"
#
{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:83: sed -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/' stderr"
echo synclines.at:83 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "sed -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)$/\\1:\\2/' -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/' stderr"; then
  ( $at_traceon; sed -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/' stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/' stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:83"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:83: cat stdout"
echo synclines.at:83 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stdout ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stdout ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "input.y:2: #error \"2\"
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:83"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_75
#AT_START_76
# 76. synclines.at:100: %union synch line
at_setup_line='synclines.at:100'
at_func_banner 6
at_desc="%union synch line"
$at_quiet $as_echo_n " 76: $at_desc                              "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "76. synclines.at:100: testing ..."
  $at_traceon


# It seems impossible to find a generic scheme to check the location
# of an error.  Even requiring GCC is not sufficient, since for instance
# the version modified by Apple:
#
# | Reading specs from /usr/libexec/gcc/darwin/ppc/2.95.2/specs
# | Apple Computer, Inc. version gcc-934.3, based on gcc version 2.95.2
# | 19991024 (release) configure:2124: $? = 0
#
# instead of:
#
# | input.y:2: #error "2"
#
# it reports:
#
# | input.y:2: "2"
# | cpp-precomp: warning: errors during smart preprocessing, retrying in basic mode

cat >syncline.c <<'_ATEOF'
#error "1"
_ATEOF


{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:100: \$CC \$CFLAGS \$CPPFLAGS -c syncline.c"
echo synclines.at:100 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -c syncline.c"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -c syncline.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -c syncline.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_skip $at_status "$at_srcdir/synclines.at:100"

$at_failed && at_func_log_failure
$at_traceon; }

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or
#   input.y:4.2: #error "4"    or
#   input.y:4:2: error: #error "4"
# =>
#   input.y:4: #error "4"
#
{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:100: sed -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/' stderr"
echo synclines.at:100 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "sed -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)$/\\1:\\2/' -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/' stderr"; then
  ( $at_traceon; sed -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/' stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/' stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:100"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:100: test \"\`cat stdout\`\" = 'syncline.c:1: #error \"1\"' || exit 77"
echo synclines.at:100 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; test "`cat stdout`" = 'syncline.c:1: #error "1"' || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test "`cat stdout`" = 'syncline.c:1: #error "1"' || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:100"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input.y <<'_ATEOF'
%union {
#error "2"
  char dummy;
}
%{
void yyerror (const char *s);
int yylex (void);
%}
%%
exp: '0';
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/synclines.at:100: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo synclines.at:100 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:100"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/synclines.at:100: bison --xml=xml-tests/test.xml -o input.c input.y"
echo synclines.at:100 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:100"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/synclines.at:100: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo synclines.at:100 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:100"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/synclines.at:100: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo synclines.at:100 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:100"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:100: bison -o input.c input.y"
echo synclines.at:100 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:100"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:100: \$CC \$CFLAGS \$CPPFLAGS -c input.c"
echo synclines.at:100 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -c input.c"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -c input.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -c input.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_skip $at_status "$at_srcdir/synclines.at:100"

$at_failed && at_func_log_failure
$at_traceon; }

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or
#   input.y:4.2: #error "4"    or
#   input.y:4:2: error: #error "4"
# =>
#   input.y:4: #error "4"
#
{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:100: sed -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/' stderr"
echo synclines.at:100 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "sed -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)$/\\1:\\2/' -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/' stderr"; then
  ( $at_traceon; sed -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/' stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/' stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:100"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:100: cat stdout"
echo synclines.at:100 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stdout ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stdout ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "input.y:2: #error \"2\"
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:100"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_76
#AT_START_77
# 77. synclines.at:120: Postprologue synch line
at_setup_line='synclines.at:120'
at_func_banner 6
at_desc="Postprologue synch line"
$at_quiet $as_echo_n " 77: $at_desc                        "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "77. synclines.at:120: testing ..."
  $at_traceon


# It seems impossible to find a generic scheme to check the location
# of an error.  Even requiring GCC is not sufficient, since for instance
# the version modified by Apple:
#
# | Reading specs from /usr/libexec/gcc/darwin/ppc/2.95.2/specs
# | Apple Computer, Inc. version gcc-934.3, based on gcc version 2.95.2
# | 19991024 (release) configure:2124: $? = 0
#
# instead of:
#
# | input.y:2: #error "2"
#
# it reports:
#
# | input.y:2: "2"
# | cpp-precomp: warning: errors during smart preprocessing, retrying in basic mode

cat >syncline.c <<'_ATEOF'
#error "1"
_ATEOF


{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:120: \$CC \$CFLAGS \$CPPFLAGS -c syncline.c"
echo synclines.at:120 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -c syncline.c"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -c syncline.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -c syncline.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_skip $at_status "$at_srcdir/synclines.at:120"

$at_failed && at_func_log_failure
$at_traceon; }

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or
#   input.y:4.2: #error "4"    or
#   input.y:4:2: error: #error "4"
# =>
#   input.y:4: #error "4"
#
{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:120: sed -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/' stderr"
echo synclines.at:120 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "sed -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)$/\\1:\\2/' -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/' stderr"; then
  ( $at_traceon; sed -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/' stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/' stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:120"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:120: test \"\`cat stdout\`\" = 'syncline.c:1: #error \"1\"' || exit 77"
echo synclines.at:120 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; test "`cat stdout`" = 'syncline.c:1: #error "1"' || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test "`cat stdout`" = 'syncline.c:1: #error "1"' || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:120"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input.y <<'_ATEOF'
%{
void yyerror (const char *s);
int yylex (void);
%}
%union
{
  int ival;
}
%{
#error "10"
%}
%%
exp: '0';
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/synclines.at:120: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo synclines.at:120 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:120"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/synclines.at:120: bison --xml=xml-tests/test.xml -o input.c input.y"
echo synclines.at:120 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:120"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/synclines.at:120: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo synclines.at:120 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:120"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/synclines.at:120: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo synclines.at:120 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:120"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:120: bison -o input.c input.y"
echo synclines.at:120 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:120"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:120: \$CC \$CFLAGS \$CPPFLAGS -c input.c"
echo synclines.at:120 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -c input.c"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -c input.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -c input.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_skip $at_status "$at_srcdir/synclines.at:120"

$at_failed && at_func_log_failure
$at_traceon; }

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or
#   input.y:4.2: #error "4"    or
#   input.y:4:2: error: #error "4"
# =>
#   input.y:4: #error "4"
#
{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:120: sed -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/' stderr"
echo synclines.at:120 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "sed -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)$/\\1:\\2/' -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/' stderr"; then
  ( $at_traceon; sed -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/' stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/' stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:120"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:120: cat stdout"
echo synclines.at:120 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stdout ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stdout ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "input.y:10: #error \"10\"
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:120"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_77
#AT_START_78
# 78. synclines.at:143: Action synch line
at_setup_line='synclines.at:143'
at_func_banner 6
at_desc="Action synch line"
$at_quiet $as_echo_n " 78: $at_desc                              "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "78. synclines.at:143: testing ..."
  $at_traceon


# It seems impossible to find a generic scheme to check the location
# of an error.  Even requiring GCC is not sufficient, since for instance
# the version modified by Apple:
#
# | Reading specs from /usr/libexec/gcc/darwin/ppc/2.95.2/specs
# | Apple Computer, Inc. version gcc-934.3, based on gcc version 2.95.2
# | 19991024 (release) configure:2124: $? = 0
#
# instead of:
#
# | input.y:2: #error "2"
#
# it reports:
#
# | input.y:2: "2"
# | cpp-precomp: warning: errors during smart preprocessing, retrying in basic mode

cat >syncline.c <<'_ATEOF'
#error "1"
_ATEOF


{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:143: \$CC \$CFLAGS \$CPPFLAGS -c syncline.c"
echo synclines.at:143 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -c syncline.c"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -c syncline.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -c syncline.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_skip $at_status "$at_srcdir/synclines.at:143"

$at_failed && at_func_log_failure
$at_traceon; }

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or
#   input.y:4.2: #error "4"    or
#   input.y:4:2: error: #error "4"
# =>
#   input.y:4: #error "4"
#
{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:143: sed -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/' stderr"
echo synclines.at:143 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "sed -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)$/\\1:\\2/' -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/' stderr"; then
  ( $at_traceon; sed -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/' stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/' stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:143"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:143: test \"\`cat stdout\`\" = 'syncline.c:1: #error \"1\"' || exit 77"
echo synclines.at:143 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; test "`cat stdout`" = 'syncline.c:1: #error "1"' || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test "`cat stdout`" = 'syncline.c:1: #error "1"' || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:143"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input.y <<'_ATEOF'
%{
void yyerror (const char *s);
int yylex (void);
%}
%%
exp:
{
#error "8"
};
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/synclines.at:143: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo synclines.at:143 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:143"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/synclines.at:143: bison --xml=xml-tests/test.xml -o input.c input.y"
echo synclines.at:143 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:143"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/synclines.at:143: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo synclines.at:143 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:143"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/synclines.at:143: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo synclines.at:143 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:143"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:143: bison -o input.c input.y"
echo synclines.at:143 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:143"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:143: \$CC \$CFLAGS \$CPPFLAGS -c input.c"
echo synclines.at:143 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -c input.c"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -c input.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -c input.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_skip $at_status "$at_srcdir/synclines.at:143"

$at_failed && at_func_log_failure
$at_traceon; }

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or
#   input.y:4.2: #error "4"    or
#   input.y:4:2: error: #error "4"
# =>
#   input.y:4: #error "4"
#
{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:143: sed -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/' stderr"
echo synclines.at:143 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "sed -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)$/\\1:\\2/' -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/' stderr"; then
  ( $at_traceon; sed -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/' stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/' stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:143"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:143: cat stdout"
echo synclines.at:143 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stdout ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stdout ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "input.y:8: #error \"8\"
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:143"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_78
#AT_START_79
# 79. synclines.at:162: Epilogue synch line
at_setup_line='synclines.at:162'
at_func_banner 6
at_desc="Epilogue synch line"
$at_quiet $as_echo_n " 79: $at_desc                            "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "79. synclines.at:162: testing ..."
  $at_traceon


# It seems impossible to find a generic scheme to check the location
# of an error.  Even requiring GCC is not sufficient, since for instance
# the version modified by Apple:
#
# | Reading specs from /usr/libexec/gcc/darwin/ppc/2.95.2/specs
# | Apple Computer, Inc. version gcc-934.3, based on gcc version 2.95.2
# | 19991024 (release) configure:2124: $? = 0
#
# instead of:
#
# | input.y:2: #error "2"
#
# it reports:
#
# | input.y:2: "2"
# | cpp-precomp: warning: errors during smart preprocessing, retrying in basic mode

cat >syncline.c <<'_ATEOF'
#error "1"
_ATEOF


{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:162: \$CC \$CFLAGS \$CPPFLAGS -c syncline.c"
echo synclines.at:162 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -c syncline.c"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -c syncline.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -c syncline.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_skip $at_status "$at_srcdir/synclines.at:162"

$at_failed && at_func_log_failure
$at_traceon; }

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or
#   input.y:4.2: #error "4"    or
#   input.y:4:2: error: #error "4"
# =>
#   input.y:4: #error "4"
#
{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:162: sed -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/' stderr"
echo synclines.at:162 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "sed -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)$/\\1:\\2/' -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/' stderr"; then
  ( $at_traceon; sed -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/' stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/' stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:162"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:162: test \"\`cat stdout\`\" = 'syncline.c:1: #error \"1\"' || exit 77"
echo synclines.at:162 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; test "`cat stdout`" = 'syncline.c:1: #error "1"' || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test "`cat stdout`" = 'syncline.c:1: #error "1"' || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:162"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input.y <<'_ATEOF'
%{
void yyerror (const char *s);
int yylex (void);
%}
%%
exp: '0';
%%
#error "8"
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/synclines.at:162: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo synclines.at:162 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:162"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/synclines.at:162: bison --xml=xml-tests/test.xml -o input.c input.y"
echo synclines.at:162 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:162"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/synclines.at:162: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo synclines.at:162 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:162"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/synclines.at:162: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo synclines.at:162 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:162"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:162: bison -o input.c input.y"
echo synclines.at:162 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:162"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:162: \$CC \$CFLAGS \$CPPFLAGS -c input.c"
echo synclines.at:162 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -c input.c"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -c input.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -c input.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_skip $at_status "$at_srcdir/synclines.at:162"

$at_failed && at_func_log_failure
$at_traceon; }

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or
#   input.y:4.2: #error "4"    or
#   input.y:4:2: error: #error "4"
# =>
#   input.y:4: #error "4"
#
{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:162: sed -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/' stderr"
echo synclines.at:162 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "sed -e 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)$/\\1:\\2/' -e 's/^\\([^:]*:[^:]*:\\)[^#]*\\( #error\\)/\\1\\2/' stderr"; then
  ( $at_traceon; sed -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/' stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed -e 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' -e 's/^\([^:]*:[^:]*:\)[^#]*\( #error\)/\1\2/' stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:162"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/synclines.at:162: cat stdout"
echo synclines.at:162 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stdout ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stdout ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "input.y:8: #error \"8\"
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/synclines.at:162"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_79
#AT_START_80
# 80. headers.at:25: %union and --defines
at_setup_line='headers.at:25'
at_func_banner 7
at_desc="%union and --defines"
$at_quiet $as_echo_n " 80: $at_desc                           "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "80. headers.at:25: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%union
{
  int   integer;
  char *string ;
}
%%
exp: {};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/headers.at:37: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --defines input.y"
echo headers.at:37 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --defines input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --defines input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/headers.at:37"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/headers.at:37: bison --xml=xml-tests/test.xml --defines input.y"
echo headers.at:37 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml --defines input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml --defines input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/headers.at:37"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/headers.at:37: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo headers.at:37 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/headers.at:37"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/headers.at:37: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo headers.at:37 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/headers.at:37"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/headers.at:37: bison --defines input.y"
echo headers.at:37 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --defines input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --defines input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/headers.at:37"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_80
#AT_START_81
# 81. headers.at:75: Invalid CPP guards: input/input
at_setup_line='headers.at:75'
at_func_banner 7
at_desc="Invalid CPP guards: input/input"
$at_quiet $as_echo_n " 81: $at_desc                "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "81. headers.at:75: testing ..."
  $at_traceon


# Possibly create inner directories.
dirname=`$as_dirname -- input/input ||
$as_expr Xinput/input : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 Xinput/input : 'X\(//\)[^/]' \| \
	 Xinput/input : 'X\(//\)$' \| \
	 Xinput/input : 'X\(/\)' \| . 2>/dev/null ||
$as_echo Xinput/input |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)[^/].*/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`
{ as_dir=$dirname
  case $as_dir in #(
  -*) as_dir=./$as_dir;;
  esac
  test -d "$as_dir" || { $as_mkdir_p && mkdir -p "$as_dir"; } || {
    as_dirs=
    while :; do
      case $as_dir in #(
      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
      *) as_qdir=$as_dir;;
      esac
      as_dirs="'$as_qdir' $as_dirs"
      as_dir=`$as_dirname -- "$as_dir" ||
$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 X"$as_dir" : 'X\(//\)[^/]' \| \
	 X"$as_dir" : 'X\(//\)$' \| \
	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X"$as_dir" |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)[^/].*/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`
      test -d "$as_dir" && break
    done
    test -z "$as_dirs" || eval "mkdir $as_dirs"
  } || test -d "$as_dir" || { { $as_echo "$as_me:$LINENO: error: cannot create directory $as_dir" >&5
$as_echo "$as_me: error: cannot create directory $as_dir" >&2;}
   { (exit 1); exit 1; }; }; }

cat >input/input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
#include <input/input.h>
void yyerror (const char *);
int yylex (void);
%}
%%
dummy:;
%%
#include <input/input.h>
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/headers.at:75: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --defines=input/input.h --output=y.tab.c input/input.y"
echo headers.at:75 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --defines=input/input.h --output=y.tab.c input/input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --defines=input/input.h --output=y.tab.c input/input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/headers.at:75"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/headers.at:75: bison --xml=xml-tests/test.xml --defines=input/input.h --output=y.tab.c input/input.y"
echo headers.at:75 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml --defines=input/input.h --output=y.tab.c input/input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml --defines=input/input.h --output=y.tab.c input/input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/headers.at:75"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/headers.at:75: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo headers.at:75 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/headers.at:75"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/headers.at:75: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo headers.at:75 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/headers.at:75"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/headers.at:75: bison --defines=input/input.h --output=y.tab.c input/input.y"
echo headers.at:75 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --defines=input/input.h --output=y.tab.c input/input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --defines=input/input.h --output=y.tab.c input/input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/headers.at:75"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/headers.at:75: \$CC \$CFLAGS \$CPPFLAGS -o y.tab.o -I. -c y.tab.c"
echo headers.at:75 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -o y.tab.o -I. -c y.tab.c"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -o y.tab.o -I. -c y.tab.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -o y.tab.o -I. -c y.tab.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/headers.at:75"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_81
#AT_START_82
# 82. headers.at:76: Invalid CPP guards: 9foo
at_setup_line='headers.at:76'
at_func_banner 7
at_desc="Invalid CPP guards: 9foo"
$at_quiet $as_echo_n " 82: $at_desc                       "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "82. headers.at:76: testing ..."
  $at_traceon


# Possibly create inner directories.
dirname=`$as_dirname -- 9foo ||
$as_expr X9foo : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 X9foo : 'X\(//\)[^/]' \| \
	 X9foo : 'X\(//\)$' \| \
	 X9foo : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X9foo |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)[^/].*/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`
{ as_dir=$dirname
  case $as_dir in #(
  -*) as_dir=./$as_dir;;
  esac
  test -d "$as_dir" || { $as_mkdir_p && mkdir -p "$as_dir"; } || {
    as_dirs=
    while :; do
      case $as_dir in #(
      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
      *) as_qdir=$as_dir;;
      esac
      as_dirs="'$as_qdir' $as_dirs"
      as_dir=`$as_dirname -- "$as_dir" ||
$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 X"$as_dir" : 'X\(//\)[^/]' \| \
	 X"$as_dir" : 'X\(//\)$' \| \
	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X"$as_dir" |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)[^/].*/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`
      test -d "$as_dir" && break
    done
    test -z "$as_dirs" || eval "mkdir $as_dirs"
  } || test -d "$as_dir" || { { $as_echo "$as_me:$LINENO: error: cannot create directory $as_dir" >&5
$as_echo "$as_me: error: cannot create directory $as_dir" >&2;}
   { (exit 1); exit 1; }; }; }

cat >9foo.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
#include <9foo.h>
void yyerror (const char *);
int yylex (void);
%}
%%
dummy:;
%%
#include <9foo.h>
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/headers.at:76: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --defines=9foo.h --output=y.tab.c 9foo.y"
echo headers.at:76 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --defines=9foo.h --output=y.tab.c 9foo.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --defines=9foo.h --output=y.tab.c 9foo.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/headers.at:76"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/headers.at:76: bison --xml=xml-tests/test.xml --defines=9foo.h --output=y.tab.c 9foo.y"
echo headers.at:76 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml --defines=9foo.h --output=y.tab.c 9foo.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml --defines=9foo.h --output=y.tab.c 9foo.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/headers.at:76"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/headers.at:76: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo headers.at:76 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/headers.at:76"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/headers.at:76: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo headers.at:76 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/headers.at:76"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/headers.at:76: bison --defines=9foo.h --output=y.tab.c 9foo.y"
echo headers.at:76 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --defines=9foo.h --output=y.tab.c 9foo.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --defines=9foo.h --output=y.tab.c 9foo.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/headers.at:76"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/headers.at:76: \$CC \$CFLAGS \$CPPFLAGS -o y.tab.o -I. -c y.tab.c"
echo headers.at:76 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -o y.tab.o -I. -c y.tab.c"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -o y.tab.o -I. -c y.tab.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -o y.tab.o -I. -c y.tab.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/headers.at:76"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_82
#AT_START_83
# 83. headers.at:85: export YYLTYPE
at_setup_line='headers.at:85'
at_func_banner 7
at_desc="export YYLTYPE"
$at_quiet $as_echo_n " 83: $at_desc                                 "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "83. headers.at:85: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%locations

%name-prefix "my_"
%{
#include <stdio.h>
#include <stdlib.h>

static int
my_lex (void)
{
  return EOF;
}

static void
my_error (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

%}
%%
exp:;
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/headers.at:112: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --defines -o input.c input.y"
echo headers.at:112 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --defines -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --defines -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/headers.at:112"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/headers.at:112: bison --xml=xml-tests/test.xml --defines -o input.c input.y"
echo headers.at:112 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml --defines -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml --defines -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/headers.at:112"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/headers.at:112: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo headers.at:112 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/headers.at:112"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/headers.at:112: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo headers.at:112 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/headers.at:112"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/headers.at:112: bison --defines -o input.c input.y"
echo headers.at:112 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --defines -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --defines -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/headers.at:112"

$at_failed && at_func_log_failure
$at_traceon; }


# YYLTYPE should be defined, and MY_LLOC declared.
cat >caller.c <<'_ATEOF'
#include "input.h"
YYLTYPE *my_llocp = &my_lloc;

int my_parse (void);

int
main (void)
{
  return my_parse ();
}
_ATEOF


# Link and execute, just to make sure everything is fine (and in
# particular, that MY_LLOC is indeed defined somewhere).
{ $at_traceoff
$as_echo "$at_srcdir/headers.at:130: \$CC \$CFLAGS \$CPPFLAGS -o caller.o -c caller.c"
echo headers.at:130 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -o caller.o -c caller.c"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -o caller.o -c caller.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -o caller.o -c caller.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/headers.at:130"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/headers.at:131: \$CC \$CFLAGS \$CPPFLAGS -o input.o -c input.c"
echo headers.at:131 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -o input.o -c input.c"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -o input.o -c input.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -o input.o -c input.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/headers.at:131"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/headers.at:132: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o caller caller.o input.o \$LIBS"
echo headers.at:132 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o caller caller.o input.o $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o caller caller.o input.o $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o caller caller.o input.o $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/headers.at:132"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/headers.at:133:  \$PREPARSER ./caller"
echo headers.at:133 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./caller"; then
  ( $at_traceon;  $PREPARSER ./caller ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./caller ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/headers.at:133"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_83
#AT_START_84
# 84. actions.at:24: Mid-rule actions
at_setup_line='actions.at:24'
at_func_banner 8
at_desc="Mid-rule actions"
$at_quiet $as_echo_n " 84: $at_desc                               "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "84. actions.at:24: testing ..."
  $at_traceon


# Bison once forgot the mid-rule actions.  It was because the action
# was attached to the host rule (the one with the mid-rule action),
# instead of being attached to the empty rule dedicated to this
# action.

cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%error-verbose
%debug
%{
# include <stdio.h>
# include <stdlib.h>
  static void yyerror (const char *msg);
  static int yylex (void);
%}
%%
exp:     { putchar ('0'); }
     '1' { putchar ('1'); }
     '2' { putchar ('2'); }
     '3' { putchar ('3'); }
     '4' { putchar ('4'); }
     '5' { putchar ('5'); }
     '6' { putchar ('6'); }
     '7' { putchar ('7'); }
     '8' { putchar ('8'); }
     '9' { putchar ('9'); }
         { putchar ('\n'); }
   ;
%%
static int
yylex (void)
{
  static char const input[] = "123456789";
  static size_t toknum;
  if (! (toknum < sizeof input))
    abort ();
  return input[toknum++];
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:77: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -d -v -o input.c input.y"
echo actions.at:77 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -d -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -d -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:77"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/actions.at:77: bison --xml=xml-tests/test.xml -d -v -o input.c input.y"
echo actions.at:77 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -d -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -d -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:77"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:77: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo actions.at:77 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:77"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:77: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo actions.at:77 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:77"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:77: bison -d -v -o input.c input.y"
echo actions.at:77 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -d -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -d -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:77"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/actions.at:78: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo actions.at:78 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:78"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/actions.at:79:  \$PREPARSER ./input"
echo actions.at:79 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input"; then
  ( $at_traceon;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "0123456789
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:79"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_84
#AT_START_85
# 85. actions.at:93: Exotic Dollars
at_setup_line='actions.at:93'
at_func_banner 8
at_desc="Exotic Dollars"
$at_quiet $as_echo_n " 85: $at_desc                                 "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "85. actions.at:93: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%error-verbose
%debug
%{
# include <stdio.h>
# include <stdlib.h>
  static void yyerror (const char *msg);
  static int yylex (void);
# define USE(Var)
%}

%union
{
  int val;
};

%type <val> a_1 a_2 a_5
            sum_of_the_five_previous_values

%%
exp: a_1 a_2 { $<val>$ = 3; } { $<val>$ = $<val>3 + 1; } a_5
     sum_of_the_five_previous_values
    {
       USE (($1, $2, $<foo>3, $<foo>4, $5));
       printf ("%d\n", $6);
    }
;
a_1: { $$ = 1; };
a_2: { $$ = 2; };
a_5: { $$ = 5; };

sum_of_the_five_previous_values:
    {
       $$ = $<val>0 + $<val>-1 + $<val>-2 + $<val>-3 + $<val>-4;
    }
;

%%
static int
yylex (void)
{
  static int called;
  if (called++)
    abort ();
  return EOF;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:155: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -d -v -o input.c input.y"
echo actions.at:155 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -d -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -d -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:155"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/actions.at:155: bison --xml=xml-tests/test.xml -d -v -o input.c input.y"
echo actions.at:155 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -d -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -d -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:155"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:155: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo actions.at:155 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:155"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:155: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo actions.at:155 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:155"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:155: bison -d -v -o input.c input.y"
echo actions.at:155 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -d -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -d -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:155"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/actions.at:156: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo actions.at:156 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:156"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/actions.at:157:  \$PREPARSER ./input"
echo actions.at:157 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input"; then
  ( $at_traceon;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "15
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:157"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_85
#AT_START_86
# 86. actions.at:574: Printers and Destructors :
at_setup_line='actions.at:574'
at_func_banner 8
at_desc="Printers and Destructors : "
$at_quiet $as_echo_n " 86: $at_desc                    "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "86. actions.at:574: testing ..."
  $at_traceon



# Make sure complex $n work.

# Be sure to pass all the %directives to this macro to have correct
# helping macros.  So don't put any directly in the Bison file.





# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code requires {
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#define YYINITDEPTH 10
#define YYMAXDEPTH 10
#define RANGE(Location) (Location).first_line, (Location).last_line
}

%error-verbose
%debug
%verbose
%locations



%code {

static int yylex (void);
static void yyerror (const char *msg);
}



/* FIXME: This %printer isn't actually tested.  */
%printer
  {
    fprintf (yyoutput, "%d", $$);
  }
  input line thing 'x' 'y'

%destructor
  { printf ("Freeing nterm input (%d@%d-%d)\n", $$, RANGE (@$)); }
  input

%destructor
  { printf ("Freeing nterm line (%d@%d-%d)\n", $$, RANGE (@$)); }
  line

%destructor
  { printf ("Freeing nterm thing (%d@%d-%d)\n", $$, RANGE (@$)); }
  thing

%destructor
  { printf ("Freeing token 'x' (%d@%d-%d)\n", $$, RANGE (@$)); }
  'x'

%destructor
  { printf ("Freeing token 'y' (%d@%d-%d)\n", $$, RANGE (@$)); }
  'y'

%token END 0
%destructor
  { printf ("Freeing token END (%d@%d-%d)\n", $$, RANGE (@$)); }
  END

%%
/*
   This grammar is made to exercise error recovery.
   "Lines" starting with `(' support error recovery, with
   ')' as synchronizing token.  Lines starting with 'x' can never
   be recovered from if in error.
*/

input:
  /* Nothing. */
    {
      $$ = 0;
      printf ("input (%d@%d-%d): /* Nothing */\n", $$, RANGE (@$));
    }
| line input /* Right recursive to load the stack so that popping at
		END can	be exercised.  */
    {
      $$ = 2;
      printf ("input (%d@%d-%d): line (%d@%d-%d) input (%d@%d-%d)\n",
	      $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2));
    }
;

line:
  thing thing thing ';'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): thing (%d@%d-%d) thing (%d@%d-%d) thing (%d@%d-%d) ';' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2),
              $3, RANGE (@3), $4, RANGE (@4));
    }
| '(' thing thing ')'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) thing (%d@%d-%d) thing (%d@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2),
              $3, RANGE (@3), $4, RANGE (@4));
    }
| '(' thing ')'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) thing (%d@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2), $3, RANGE (@3));
    }
| '(' error ')'
    {
      $$ = -1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) error (@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), RANGE (@2), $3, RANGE (@3));
    }
;

thing:
  'x'
    {
      $$ = $1;
      printf ("thing (%d@%d-%d): 'x' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1));
    }
;
%%
/* Alias to ARGV[1]. */
const char *source = 0;

static int
yylex (void)
{
  static unsigned int counter = 0;

  int c = (yylval) = counter++;
  /* As in BASIC, line numbers go from 10 to 10.  */
 (yylloc).first_line = (yylloc).first_column = 10 * c;
  (yylloc).last_line = (yylloc).last_column = (yylloc).first_line + 9;


  if (! (0 <= c && c <= strlen (source)))
    abort ();
  if (source[c])
    printf ("sending: '%c'", source[c]);
  else
    printf ("sending: END");
  printf (" (%d@%d-%d)\n", c, RANGE ((yylloc)));
  return source[c];
}

static void
yyerror (const char *msg)
{
  printf ("%d-%d: %s\n", RANGE (yylloc), msg);
}

int
main (int argc, const char *argv[])
{
  int status;
  yydebug = !!getenv ("YYDEBUG");
  assert (argc == 2);
  source = argv[1];
  status = yyparse ();
  switch (status)
    {
      case 0: printf ("Successful parse.\n"); break;
      case 1: printf ("Parsing FAILED.\n"); break;
      default: printf ("Parsing FAILED (status %d).\n", status); break;
    }
  return status;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:574: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo actions.at:574 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:574"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/actions.at:574: bison --xml=xml-tests/test.xml -o input.c input.y"
echo actions.at:574 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:574"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:574: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo actions.at:574 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:574"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:574: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo actions.at:574 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:574"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:574: bison -o input.c input.y"
echo actions.at:574 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:574"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/actions.at:574: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo actions.at:574 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:574"

$at_failed && at_func_log_failure
$at_traceon; }



# Check the location of "empty"
# -----------------------------
# I.e., epsilon-reductions, as in "(x)" which ends by reducing
# an empty "line" nterm.
# FIXME: This location is not satisfying.  Depend on the lookahead?
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:574:  \$PREPARSER ./input '(x)'"
echo actions.at:574 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '(x)'"; then
  ( $at_traceon;  $PREPARSER ./input '(x)' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '(x)' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: END (3@30-39)
input (0@29-29): /* Nothing */
input (2@0-29): line (0@0-29) input (0@29-29)
Freeing token END (3@30-39)
Freeing nterm input (2@0-29)
Successful parse.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:574"

$at_failed && at_func_log_failure
$at_traceon; }



# Check locations in error recovery
# ---------------------------------
# '(y)' is an error, but can be recovered from.  But what's the location
# of the error itself ('y'), and of the resulting reduction ('(error)').
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:574:  \$PREPARSER ./input '(y)'"
echo actions.at:574 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '(y)'"; then
  ( $at_traceon;  $PREPARSER ./input '(y)' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '(y)' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'y' (1@10-19)
10-19: syntax error, unexpected 'y', expecting 'x'
Freeing token 'y' (1@10-19)
sending: ')' (2@20-29)
line (-1@0-29): '(' (0@0-9) error (@10-19) ')' (2@20-29)
sending: END (3@30-39)
input (0@29-29): /* Nothing */
input (2@0-29): line (-1@0-29) input (0@29-29)
Freeing token END (3@30-39)
Freeing nterm input (2@0-29)
Successful parse.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:574"

$at_failed && at_func_log_failure
$at_traceon; }



# Syntax errors caught by the parser
# ----------------------------------
# Exercise the discarding of stack top and input until `error'
# can be reduced.
#
#     '(', 'x', 'x', 'x', 'x', 'x', ')',
#
# Load the stack and provoke an error that cannot be caught by the
# grammar, to check that the stack is cleared.  And make sure the
# lookahead is freed.
#
#     '(', 'x', ')',
#     '(', 'x', ')',
#     'y'
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:574:  \$PREPARSER ./input '(xxxxx)(x)(x)y'"
echo actions.at:574 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '(xxxxx)(x)(x)y'"; then
  ( $at_traceon;  $PREPARSER ./input '(xxxxx)(x)(x)y' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '(xxxxx)(x)(x)y' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: 'x' (2@20-29)
thing (2@20-29): 'x' (2@20-29)
sending: 'x' (3@30-39)
30-39: syntax error, unexpected 'x', expecting ')'
Freeing nterm thing (2@20-29)
Freeing nterm thing (1@10-19)
Freeing token 'x' (3@30-39)
sending: 'x' (4@40-49)
Freeing token 'x' (4@40-49)
sending: 'x' (5@50-59)
Freeing token 'x' (5@50-59)
sending: ')' (6@60-69)
line (-1@0-69): '(' (0@0-9) error (@10-59) ')' (6@60-69)
sending: '(' (7@70-79)
sending: 'x' (8@80-89)
thing (8@80-89): 'x' (8@80-89)
sending: ')' (9@90-99)
line (7@70-99): '(' (7@70-79) thing (8@80-89) ')' (9@90-99)
sending: '(' (10@100-109)
sending: 'x' (11@110-119)
thing (11@110-119): 'x' (11@110-119)
sending: ')' (12@120-129)
line (10@100-129): '(' (10@100-109) thing (11@110-119) ')' (12@120-129)
sending: 'y' (13@130-139)
input (0@129-129): /* Nothing */
input (2@100-129): line (10@100-129) input (0@129-129)
input (2@70-129): line (7@70-99) input (2@100-129)
input (2@0-129): line (-1@0-69) input (2@70-129)
130-139: syntax error, unexpected 'y', expecting END
Freeing nterm input (2@0-129)
Freeing token 'y' (13@130-139)
Parsing FAILED.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/actions.at:574"

$at_failed && at_func_log_failure
$at_traceon; }



# Syntax error caught by the parser where lookahead = END
# --------------------------------------------------------
# Load the stack and provoke an error that cannot be caught by the
# grammar, to check that the stack is cleared.  And make sure the
# lookahead is freed.
#
#     '(', 'x', ')',
#     '(', 'x', ')',
#     'x'
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:574:  \$PREPARSER ./input '(x)(x)x'"
echo actions.at:574 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '(x)(x)x'"; then
  ( $at_traceon;  $PREPARSER ./input '(x)(x)x' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '(x)(x)x' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: '(' (3@30-39)
sending: 'x' (4@40-49)
thing (4@40-49): 'x' (4@40-49)
sending: ')' (5@50-59)
line (3@30-59): '(' (3@30-39) thing (4@40-49) ')' (5@50-59)
sending: 'x' (6@60-69)
thing (6@60-69): 'x' (6@60-69)
sending: END (7@70-79)
70-79: syntax error, unexpected END, expecting 'x'
Freeing nterm thing (6@60-69)
Freeing nterm line (3@30-59)
Freeing nterm line (0@0-29)
Freeing token END (7@70-79)
Parsing FAILED.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/actions.at:574"

$at_failed && at_func_log_failure
$at_traceon; }



# Check destruction upon stack overflow
# -------------------------------------
# Upon stack overflow, all symbols on the stack should be destroyed.
# Only check for yacc.c.

{ $at_traceoff
$as_echo "$at_srcdir/actions.at:574:  \$PREPARSER ./input '(x)(x)(x)(x)(x)(x)(x)'"
echo actions.at:574 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '(x)(x)(x)(x)(x)(x)(x)'"; then
  ( $at_traceon;  $PREPARSER ./input '(x)(x)(x)(x)(x)(x)(x)' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '(x)(x)(x)(x)(x)(x)(x)' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: '(' (3@30-39)
sending: 'x' (4@40-49)
thing (4@40-49): 'x' (4@40-49)
sending: ')' (5@50-59)
line (3@30-59): '(' (3@30-39) thing (4@40-49) ')' (5@50-59)
sending: '(' (6@60-69)
sending: 'x' (7@70-79)
thing (7@70-79): 'x' (7@70-79)
sending: ')' (8@80-89)
line (6@60-89): '(' (6@60-69) thing (7@70-79) ')' (8@80-89)
sending: '(' (9@90-99)
sending: 'x' (10@100-109)
thing (10@100-109): 'x' (10@100-109)
sending: ')' (11@110-119)
line (9@90-119): '(' (9@90-99) thing (10@100-109) ')' (11@110-119)
sending: '(' (12@120-129)
sending: 'x' (13@130-139)
thing (13@130-139): 'x' (13@130-139)
sending: ')' (14@140-149)
line (12@120-149): '(' (12@120-129) thing (13@130-139) ')' (14@140-149)
sending: '(' (15@150-159)
sending: 'x' (16@160-169)
thing (16@160-169): 'x' (16@160-169)
sending: ')' (17@170-179)
line (15@150-179): '(' (15@150-159) thing (16@160-169) ')' (17@170-179)
sending: '(' (18@180-189)
sending: 'x' (19@190-199)
thing (19@190-199): 'x' (19@190-199)
sending: ')' (20@200-209)
200-209: memory exhausted
Freeing nterm thing (19@190-199)
Freeing nterm line (15@150-179)
Freeing nterm line (12@120-149)
Freeing nterm line (9@90-119)
Freeing nterm line (6@60-89)
Freeing nterm line (3@30-59)
Freeing nterm line (0@0-29)
Parsing FAILED (status 2).
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 2 $at_status "$at_srcdir/actions.at:574"

$at_failed && at_func_log_failure
$at_traceon; }





  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_86
#AT_START_87
# 87. actions.at:575: Printers and Destructors with union:
at_setup_line='actions.at:575'
at_func_banner 8
at_desc="Printers and Destructors with union: "
$at_quiet $as_echo_n " 87: $at_desc          "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "87. actions.at:575: testing ..."
  $at_traceon



# Make sure complex $n work.

# Be sure to pass all the %directives to this macro to have correct
# helping macros.  So don't put any directly in the Bison file.





# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code requires {
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#define YYINITDEPTH 10
#define YYMAXDEPTH 10
#define RANGE(Location) (Location).first_line, (Location).last_line
}

%error-verbose
%debug
%verbose
%locations

%union
{
  int ival;
}

%code provides {

static int yylex (void);
static void yyerror (const char *msg);
}

%type <ival> '(' 'x' 'y' ')' ';' thing line input END

/* FIXME: This %printer isn't actually tested.  */
%printer
  {
    fprintf (yyoutput, "%d", $$);
  }
  input line thing 'x' 'y'

%destructor
  { printf ("Freeing nterm input (%d@%d-%d)\n", $$, RANGE (@$)); }
  input

%destructor
  { printf ("Freeing nterm line (%d@%d-%d)\n", $$, RANGE (@$)); }
  line

%destructor
  { printf ("Freeing nterm thing (%d@%d-%d)\n", $$, RANGE (@$)); }
  thing

%destructor
  { printf ("Freeing token 'x' (%d@%d-%d)\n", $$, RANGE (@$)); }
  'x'

%destructor
  { printf ("Freeing token 'y' (%d@%d-%d)\n", $$, RANGE (@$)); }
  'y'

%token END 0
%destructor
  { printf ("Freeing token END (%d@%d-%d)\n", $$, RANGE (@$)); }
  END

%%
/*
   This grammar is made to exercise error recovery.
   "Lines" starting with `(' support error recovery, with
   ')' as synchronizing token.  Lines starting with 'x' can never
   be recovered from if in error.
*/

input:
  /* Nothing. */
    {
      $$ = 0;
      printf ("input (%d@%d-%d): /* Nothing */\n", $$, RANGE (@$));
    }
| line input /* Right recursive to load the stack so that popping at
		END can	be exercised.  */
    {
      $$ = 2;
      printf ("input (%d@%d-%d): line (%d@%d-%d) input (%d@%d-%d)\n",
	      $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2));
    }
;

line:
  thing thing thing ';'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): thing (%d@%d-%d) thing (%d@%d-%d) thing (%d@%d-%d) ';' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2),
              $3, RANGE (@3), $4, RANGE (@4));
    }
| '(' thing thing ')'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) thing (%d@%d-%d) thing (%d@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2),
              $3, RANGE (@3), $4, RANGE (@4));
    }
| '(' thing ')'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) thing (%d@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2), $3, RANGE (@3));
    }
| '(' error ')'
    {
      $$ = -1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) error (@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), RANGE (@2), $3, RANGE (@3));
    }
;

thing:
  'x'
    {
      $$ = $1;
      printf ("thing (%d@%d-%d): 'x' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1));
    }
;
%%
/* Alias to ARGV[1]. */
const char *source = 0;

static int
yylex (void)
{
  static unsigned int counter = 0;

  int c = (yylval).ival = counter++;
  /* As in BASIC, line numbers go from 10 to 10.  */
 (yylloc).first_line = (yylloc).first_column = 10 * c;
  (yylloc).last_line = (yylloc).last_column = (yylloc).first_line + 9;


  if (! (0 <= c && c <= strlen (source)))
    abort ();
  if (source[c])
    printf ("sending: '%c'", source[c]);
  else
    printf ("sending: END");
  printf (" (%d@%d-%d)\n", c, RANGE ((yylloc)));
  return source[c];
}

static void
yyerror (const char *msg)
{
  printf ("%d-%d: %s\n", RANGE (yylloc), msg);
}

int
main (int argc, const char *argv[])
{
  int status;
  yydebug = !!getenv ("YYDEBUG");
  assert (argc == 2);
  source = argv[1];
  status = yyparse ();
  switch (status)
    {
      case 0: printf ("Successful parse.\n"); break;
      case 1: printf ("Parsing FAILED.\n"); break;
      default: printf ("Parsing FAILED (status %d).\n", status); break;
    }
  return status;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:575: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo actions.at:575 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:575"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/actions.at:575: bison --xml=xml-tests/test.xml -o input.c input.y"
echo actions.at:575 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:575"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:575: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo actions.at:575 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:575"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:575: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo actions.at:575 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:575"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:575: bison -o input.c input.y"
echo actions.at:575 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:575"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/actions.at:575: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo actions.at:575 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:575"

$at_failed && at_func_log_failure
$at_traceon; }



# Check the location of "empty"
# -----------------------------
# I.e., epsilon-reductions, as in "(x)" which ends by reducing
# an empty "line" nterm.
# FIXME: This location is not satisfying.  Depend on the lookahead?
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:575:  \$PREPARSER ./input '(x)'"
echo actions.at:575 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '(x)'"; then
  ( $at_traceon;  $PREPARSER ./input '(x)' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '(x)' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: END (3@30-39)
input (0@29-29): /* Nothing */
input (2@0-29): line (0@0-29) input (0@29-29)
Freeing token END (3@30-39)
Freeing nterm input (2@0-29)
Successful parse.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:575"

$at_failed && at_func_log_failure
$at_traceon; }



# Check locations in error recovery
# ---------------------------------
# '(y)' is an error, but can be recovered from.  But what's the location
# of the error itself ('y'), and of the resulting reduction ('(error)').
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:575:  \$PREPARSER ./input '(y)'"
echo actions.at:575 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '(y)'"; then
  ( $at_traceon;  $PREPARSER ./input '(y)' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '(y)' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'y' (1@10-19)
10-19: syntax error, unexpected 'y', expecting 'x'
Freeing token 'y' (1@10-19)
sending: ')' (2@20-29)
line (-1@0-29): '(' (0@0-9) error (@10-19) ')' (2@20-29)
sending: END (3@30-39)
input (0@29-29): /* Nothing */
input (2@0-29): line (-1@0-29) input (0@29-29)
Freeing token END (3@30-39)
Freeing nterm input (2@0-29)
Successful parse.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:575"

$at_failed && at_func_log_failure
$at_traceon; }



# Syntax errors caught by the parser
# ----------------------------------
# Exercise the discarding of stack top and input until `error'
# can be reduced.
#
#     '(', 'x', 'x', 'x', 'x', 'x', ')',
#
# Load the stack and provoke an error that cannot be caught by the
# grammar, to check that the stack is cleared.  And make sure the
# lookahead is freed.
#
#     '(', 'x', ')',
#     '(', 'x', ')',
#     'y'
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:575:  \$PREPARSER ./input '(xxxxx)(x)(x)y'"
echo actions.at:575 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '(xxxxx)(x)(x)y'"; then
  ( $at_traceon;  $PREPARSER ./input '(xxxxx)(x)(x)y' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '(xxxxx)(x)(x)y' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: 'x' (2@20-29)
thing (2@20-29): 'x' (2@20-29)
sending: 'x' (3@30-39)
30-39: syntax error, unexpected 'x', expecting ')'
Freeing nterm thing (2@20-29)
Freeing nterm thing (1@10-19)
Freeing token 'x' (3@30-39)
sending: 'x' (4@40-49)
Freeing token 'x' (4@40-49)
sending: 'x' (5@50-59)
Freeing token 'x' (5@50-59)
sending: ')' (6@60-69)
line (-1@0-69): '(' (0@0-9) error (@10-59) ')' (6@60-69)
sending: '(' (7@70-79)
sending: 'x' (8@80-89)
thing (8@80-89): 'x' (8@80-89)
sending: ')' (9@90-99)
line (7@70-99): '(' (7@70-79) thing (8@80-89) ')' (9@90-99)
sending: '(' (10@100-109)
sending: 'x' (11@110-119)
thing (11@110-119): 'x' (11@110-119)
sending: ')' (12@120-129)
line (10@100-129): '(' (10@100-109) thing (11@110-119) ')' (12@120-129)
sending: 'y' (13@130-139)
input (0@129-129): /* Nothing */
input (2@100-129): line (10@100-129) input (0@129-129)
input (2@70-129): line (7@70-99) input (2@100-129)
input (2@0-129): line (-1@0-69) input (2@70-129)
130-139: syntax error, unexpected 'y', expecting END
Freeing nterm input (2@0-129)
Freeing token 'y' (13@130-139)
Parsing FAILED.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/actions.at:575"

$at_failed && at_func_log_failure
$at_traceon; }



# Syntax error caught by the parser where lookahead = END
# --------------------------------------------------------
# Load the stack and provoke an error that cannot be caught by the
# grammar, to check that the stack is cleared.  And make sure the
# lookahead is freed.
#
#     '(', 'x', ')',
#     '(', 'x', ')',
#     'x'
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:575:  \$PREPARSER ./input '(x)(x)x'"
echo actions.at:575 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '(x)(x)x'"; then
  ( $at_traceon;  $PREPARSER ./input '(x)(x)x' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '(x)(x)x' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: '(' (3@30-39)
sending: 'x' (4@40-49)
thing (4@40-49): 'x' (4@40-49)
sending: ')' (5@50-59)
line (3@30-59): '(' (3@30-39) thing (4@40-49) ')' (5@50-59)
sending: 'x' (6@60-69)
thing (6@60-69): 'x' (6@60-69)
sending: END (7@70-79)
70-79: syntax error, unexpected END, expecting 'x'
Freeing nterm thing (6@60-69)
Freeing nterm line (3@30-59)
Freeing nterm line (0@0-29)
Freeing token END (7@70-79)
Parsing FAILED.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/actions.at:575"

$at_failed && at_func_log_failure
$at_traceon; }



# Check destruction upon stack overflow
# -------------------------------------
# Upon stack overflow, all symbols on the stack should be destroyed.
# Only check for yacc.c.

{ $at_traceoff
$as_echo "$at_srcdir/actions.at:575:  \$PREPARSER ./input '(x)(x)(x)(x)(x)(x)(x)'"
echo actions.at:575 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '(x)(x)(x)(x)(x)(x)(x)'"; then
  ( $at_traceon;  $PREPARSER ./input '(x)(x)(x)(x)(x)(x)(x)' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '(x)(x)(x)(x)(x)(x)(x)' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: '(' (3@30-39)
sending: 'x' (4@40-49)
thing (4@40-49): 'x' (4@40-49)
sending: ')' (5@50-59)
line (3@30-59): '(' (3@30-39) thing (4@40-49) ')' (5@50-59)
sending: '(' (6@60-69)
sending: 'x' (7@70-79)
thing (7@70-79): 'x' (7@70-79)
sending: ')' (8@80-89)
line (6@60-89): '(' (6@60-69) thing (7@70-79) ')' (8@80-89)
sending: '(' (9@90-99)
sending: 'x' (10@100-109)
thing (10@100-109): 'x' (10@100-109)
sending: ')' (11@110-119)
line (9@90-119): '(' (9@90-99) thing (10@100-109) ')' (11@110-119)
sending: '(' (12@120-129)
sending: 'x' (13@130-139)
thing (13@130-139): 'x' (13@130-139)
sending: ')' (14@140-149)
line (12@120-149): '(' (12@120-129) thing (13@130-139) ')' (14@140-149)
sending: '(' (15@150-159)
sending: 'x' (16@160-169)
thing (16@160-169): 'x' (16@160-169)
sending: ')' (17@170-179)
line (15@150-179): '(' (15@150-159) thing (16@160-169) ')' (17@170-179)
sending: '(' (18@180-189)
sending: 'x' (19@190-199)
thing (19@190-199): 'x' (19@190-199)
sending: ')' (20@200-209)
200-209: memory exhausted
Freeing nterm thing (19@190-199)
Freeing nterm line (15@150-179)
Freeing nterm line (12@120-149)
Freeing nterm line (9@90-119)
Freeing nterm line (6@60-89)
Freeing nterm line (3@30-59)
Freeing nterm line (0@0-29)
Parsing FAILED (status 2).
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 2 $at_status "$at_srcdir/actions.at:575"

$at_failed && at_func_log_failure
$at_traceon; }





  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_87
#AT_START_88
# 88. actions.at:577: Printers and Destructors : %defines %skeleton "lalr1.cc"
at_setup_line='actions.at:577'
at_func_banner 8
at_desc="Printers and Destructors : %defines %skeleton \"lalr1.cc\""
$at_quiet $as_echo_n " 88: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "88. actions.at:577: testing ..."
  $at_traceon



# Make sure complex $n work.

# Be sure to pass all the %directives to this macro to have correct
# helping macros.  So don't put any directly in the Bison file.





# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code requires {
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#define YYINITDEPTH 10
#define YYMAXDEPTH 10
#define RANGE(Location) (Location).begin.line, (Location).end.line
}

%error-verbose
%debug
%verbose
%locations
%defines %skeleton "lalr1.cc"

%define global_tokens_and_yystype
%code {
typedef yy::location YYLTYPE;
static int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);

}



/* FIXME: This %printer isn't actually tested.  */
%printer
  {
    debug_stream () << $$;;
  }
  input line thing 'x' 'y'

%destructor
  { printf ("Freeing nterm input (%d@%d-%d)\n", $$, RANGE (@$)); }
  input

%destructor
  { printf ("Freeing nterm line (%d@%d-%d)\n", $$, RANGE (@$)); }
  line

%destructor
  { printf ("Freeing nterm thing (%d@%d-%d)\n", $$, RANGE (@$)); }
  thing

%destructor
  { printf ("Freeing token 'x' (%d@%d-%d)\n", $$, RANGE (@$)); }
  'x'

%destructor
  { printf ("Freeing token 'y' (%d@%d-%d)\n", $$, RANGE (@$)); }
  'y'

%token END 0
%destructor
  { printf ("Freeing token END (%d@%d-%d)\n", $$, RANGE (@$)); }
  END

%%
/*
   This grammar is made to exercise error recovery.
   "Lines" starting with `(' support error recovery, with
   ')' as synchronizing token.  Lines starting with 'x' can never
   be recovered from if in error.
*/

input:
  /* Nothing. */
    {
      $$ = 0;
      printf ("input (%d@%d-%d): /* Nothing */\n", $$, RANGE (@$));
    }
| line input /* Right recursive to load the stack so that popping at
		END can	be exercised.  */
    {
      $$ = 2;
      printf ("input (%d@%d-%d): line (%d@%d-%d) input (%d@%d-%d)\n",
	      $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2));
    }
;

line:
  thing thing thing ';'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): thing (%d@%d-%d) thing (%d@%d-%d) thing (%d@%d-%d) ';' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2),
              $3, RANGE (@3), $4, RANGE (@4));
    }
| '(' thing thing ')'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) thing (%d@%d-%d) thing (%d@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2),
              $3, RANGE (@3), $4, RANGE (@4));
    }
| '(' thing ')'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) thing (%d@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2), $3, RANGE (@3));
    }
| '(' error ')'
    {
      $$ = -1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) error (@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), RANGE (@2), $3, RANGE (@3));
    }
;

thing:
  'x'
    {
      $$ = $1;
      printf ("thing (%d@%d-%d): 'x' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1));
    }
;
%%
/* Alias to ARGV[1]. */
const char *source = 0;

static int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static unsigned int counter = 0;

  int c = (*lvalp) = counter++;
  /* As in BASIC, line numbers go from 10 to 10.  */
 (*llocp).begin.line = (*llocp).begin.column = 10 * c;
  (*llocp).end.line = (*llocp).end.column = (*llocp).begin.line + 9;


  if (! (0 <= c && c <= strlen (source)))
    abort ();
  if (source[c])
    printf ("sending: '%c'", source[c]);
  else
    printf ("sending: END");
  printf (" (%d@%d-%d)\n", c, RANGE ((*llocp)));
  return source[c];
}

/* A C++ error reporting function. */
void
yy::parser::error (const location& l, const std::string& m)
{
  printf ("%d-%d: %s\n", RANGE (l), m.c_str());
}

static bool yydebug;
int
yyparse ()
{
  yy::parser parser;
  parser.set_debug_level (yydebug);
  return parser.parse ();
}


int
main (int argc, const char *argv[])
{
  int status;
  yydebug = !!getenv ("YYDEBUG");
  assert (argc == 2);
  source = argv[1];
  status = yyparse ();
  switch (status)
    {
      case 0: printf ("Successful parse.\n"); break;
      case 1: printf ("Parsing FAILED.\n"); break;
      default: printf ("Parsing FAILED (status %d).\n", status); break;
    }
  return status;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:577: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
echo actions.at:577 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:577"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/actions.at:577: bison --xml=xml-tests/test.xml -o input.cc input.y"
echo actions.at:577 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:577"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:577: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo actions.at:577 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:577"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:577: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo actions.at:577 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:577"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:577: bison -o input.cc input.y"
echo actions.at:577 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:577"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/actions.at:577: \$BISON_CXX_WORKS"
echo actions.at:577 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:577"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/actions.at:577: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o input input.cc \$LIBS"
echo actions.at:577 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS"; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:577"

$at_failed && at_func_log_failure
$at_traceon; }



# Check the location of "empty"
# -----------------------------
# I.e., epsilon-reductions, as in "(x)" which ends by reducing
# an empty "line" nterm.
# FIXME: This location is not satisfying.  Depend on the lookahead?
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:577:  \$PREPARSER ./input '(x)'"
echo actions.at:577 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '(x)'"; then
  ( $at_traceon;  $PREPARSER ./input '(x)' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '(x)' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: END (3@30-39)
input (0@29-29): /* Nothing */
input (2@0-29): line (0@0-29) input (0@29-29)
Freeing token END (3@30-39)
Freeing nterm input (2@0-29)
Successful parse.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:577"

$at_failed && at_func_log_failure
$at_traceon; }



# Check locations in error recovery
# ---------------------------------
# '(y)' is an error, but can be recovered from.  But what's the location
# of the error itself ('y'), and of the resulting reduction ('(error)').
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:577:  \$PREPARSER ./input '(y)'"
echo actions.at:577 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '(y)'"; then
  ( $at_traceon;  $PREPARSER ./input '(y)' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '(y)' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'y' (1@10-19)
10-19: syntax error, unexpected 'y', expecting 'x'
Freeing token 'y' (1@10-19)
sending: ')' (2@20-29)
line (-1@0-29): '(' (0@0-9) error (@10-19) ')' (2@20-29)
sending: END (3@30-39)
input (0@29-29): /* Nothing */
input (2@0-29): line (-1@0-29) input (0@29-29)
Freeing token END (3@30-39)
Freeing nterm input (2@0-29)
Successful parse.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:577"

$at_failed && at_func_log_failure
$at_traceon; }



# Syntax errors caught by the parser
# ----------------------------------
# Exercise the discarding of stack top and input until `error'
# can be reduced.
#
#     '(', 'x', 'x', 'x', 'x', 'x', ')',
#
# Load the stack and provoke an error that cannot be caught by the
# grammar, to check that the stack is cleared.  And make sure the
# lookahead is freed.
#
#     '(', 'x', ')',
#     '(', 'x', ')',
#     'y'
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:577:  \$PREPARSER ./input '(xxxxx)(x)(x)y'"
echo actions.at:577 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '(xxxxx)(x)(x)y'"; then
  ( $at_traceon;  $PREPARSER ./input '(xxxxx)(x)(x)y' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '(xxxxx)(x)(x)y' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: 'x' (2@20-29)
thing (2@20-29): 'x' (2@20-29)
sending: 'x' (3@30-39)
30-39: syntax error, unexpected 'x', expecting ')'
Freeing nterm thing (2@20-29)
Freeing nterm thing (1@10-19)
Freeing token 'x' (3@30-39)
sending: 'x' (4@40-49)
Freeing token 'x' (4@40-49)
sending: 'x' (5@50-59)
Freeing token 'x' (5@50-59)
sending: ')' (6@60-69)
line (-1@0-69): '(' (0@0-9) error (@10-59) ')' (6@60-69)
sending: '(' (7@70-79)
sending: 'x' (8@80-89)
thing (8@80-89): 'x' (8@80-89)
sending: ')' (9@90-99)
line (7@70-99): '(' (7@70-79) thing (8@80-89) ')' (9@90-99)
sending: '(' (10@100-109)
sending: 'x' (11@110-119)
thing (11@110-119): 'x' (11@110-119)
sending: ')' (12@120-129)
line (10@100-129): '(' (10@100-109) thing (11@110-119) ')' (12@120-129)
sending: 'y' (13@130-139)
input (0@129-129): /* Nothing */
input (2@100-129): line (10@100-129) input (0@129-129)
input (2@70-129): line (7@70-99) input (2@100-129)
input (2@0-129): line (-1@0-69) input (2@70-129)
130-139: syntax error, unexpected 'y', expecting END
Freeing nterm input (2@0-129)
Freeing token 'y' (13@130-139)
Parsing FAILED.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/actions.at:577"

$at_failed && at_func_log_failure
$at_traceon; }



# Syntax error caught by the parser where lookahead = END
# --------------------------------------------------------
# Load the stack and provoke an error that cannot be caught by the
# grammar, to check that the stack is cleared.  And make sure the
# lookahead is freed.
#
#     '(', 'x', ')',
#     '(', 'x', ')',
#     'x'
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:577:  \$PREPARSER ./input '(x)(x)x'"
echo actions.at:577 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '(x)(x)x'"; then
  ( $at_traceon;  $PREPARSER ./input '(x)(x)x' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '(x)(x)x' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: '(' (3@30-39)
sending: 'x' (4@40-49)
thing (4@40-49): 'x' (4@40-49)
sending: ')' (5@50-59)
line (3@30-59): '(' (3@30-39) thing (4@40-49) ')' (5@50-59)
sending: 'x' (6@60-69)
thing (6@60-69): 'x' (6@60-69)
sending: END (7@70-79)
70-79: syntax error, unexpected END, expecting 'x'
Freeing nterm thing (6@60-69)
Freeing nterm line (3@30-59)
Freeing nterm line (0@0-29)
Freeing token END (7@70-79)
Parsing FAILED.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/actions.at:577"

$at_failed && at_func_log_failure
$at_traceon; }



# Check destruction upon stack overflow
# -------------------------------------
# Upon stack overflow, all symbols on the stack should be destroyed.
# Only check for yacc.c.




  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_88
#AT_START_89
# 89. actions.at:578: Printers and Destructors with union: %defines %skeleton "lalr1.cc"
at_setup_line='actions.at:578'
at_func_banner 8
at_desc="Printers and Destructors with union: %defines %skeleton \"lalr1.cc\""
$at_quiet $as_echo_n " 89: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "89. actions.at:578: testing ..."
  $at_traceon



# Make sure complex $n work.

# Be sure to pass all the %directives to this macro to have correct
# helping macros.  So don't put any directly in the Bison file.





# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code requires {
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#define YYINITDEPTH 10
#define YYMAXDEPTH 10
#define RANGE(Location) (Location).begin.line, (Location).end.line
}

%error-verbose
%debug
%verbose
%locations
%defines %skeleton "lalr1.cc"
%union
{
  int ival;
}
%define global_tokens_and_yystype
%code provides {
typedef yy::location YYLTYPE;
static int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);

}

%type <ival> '(' 'x' 'y' ')' ';' thing line input END

/* FIXME: This %printer isn't actually tested.  */
%printer
  {
    debug_stream () << $$;;
  }
  input line thing 'x' 'y'

%destructor
  { printf ("Freeing nterm input (%d@%d-%d)\n", $$, RANGE (@$)); }
  input

%destructor
  { printf ("Freeing nterm line (%d@%d-%d)\n", $$, RANGE (@$)); }
  line

%destructor
  { printf ("Freeing nterm thing (%d@%d-%d)\n", $$, RANGE (@$)); }
  thing

%destructor
  { printf ("Freeing token 'x' (%d@%d-%d)\n", $$, RANGE (@$)); }
  'x'

%destructor
  { printf ("Freeing token 'y' (%d@%d-%d)\n", $$, RANGE (@$)); }
  'y'

%token END 0
%destructor
  { printf ("Freeing token END (%d@%d-%d)\n", $$, RANGE (@$)); }
  END

%%
/*
   This grammar is made to exercise error recovery.
   "Lines" starting with `(' support error recovery, with
   ')' as synchronizing token.  Lines starting with 'x' can never
   be recovered from if in error.
*/

input:
  /* Nothing. */
    {
      $$ = 0;
      printf ("input (%d@%d-%d): /* Nothing */\n", $$, RANGE (@$));
    }
| line input /* Right recursive to load the stack so that popping at
		END can	be exercised.  */
    {
      $$ = 2;
      printf ("input (%d@%d-%d): line (%d@%d-%d) input (%d@%d-%d)\n",
	      $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2));
    }
;

line:
  thing thing thing ';'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): thing (%d@%d-%d) thing (%d@%d-%d) thing (%d@%d-%d) ';' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2),
              $3, RANGE (@3), $4, RANGE (@4));
    }
| '(' thing thing ')'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) thing (%d@%d-%d) thing (%d@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2),
              $3, RANGE (@3), $4, RANGE (@4));
    }
| '(' thing ')'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) thing (%d@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2), $3, RANGE (@3));
    }
| '(' error ')'
    {
      $$ = -1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) error (@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), RANGE (@2), $3, RANGE (@3));
    }
;

thing:
  'x'
    {
      $$ = $1;
      printf ("thing (%d@%d-%d): 'x' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1));
    }
;
%%
/* Alias to ARGV[1]. */
const char *source = 0;

static int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static unsigned int counter = 0;

  int c = (*lvalp).ival = counter++;
  /* As in BASIC, line numbers go from 10 to 10.  */
 (*llocp).begin.line = (*llocp).begin.column = 10 * c;
  (*llocp).end.line = (*llocp).end.column = (*llocp).begin.line + 9;


  if (! (0 <= c && c <= strlen (source)))
    abort ();
  if (source[c])
    printf ("sending: '%c'", source[c]);
  else
    printf ("sending: END");
  printf (" (%d@%d-%d)\n", c, RANGE ((*llocp)));
  return source[c];
}

/* A C++ error reporting function. */
void
yy::parser::error (const location& l, const std::string& m)
{
  printf ("%d-%d: %s\n", RANGE (l), m.c_str());
}

static bool yydebug;
int
yyparse ()
{
  yy::parser parser;
  parser.set_debug_level (yydebug);
  return parser.parse ();
}


int
main (int argc, const char *argv[])
{
  int status;
  yydebug = !!getenv ("YYDEBUG");
  assert (argc == 2);
  source = argv[1];
  status = yyparse ();
  switch (status)
    {
      case 0: printf ("Successful parse.\n"); break;
      case 1: printf ("Parsing FAILED.\n"); break;
      default: printf ("Parsing FAILED (status %d).\n", status); break;
    }
  return status;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:578: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
echo actions.at:578 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:578"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/actions.at:578: bison --xml=xml-tests/test.xml -o input.cc input.y"
echo actions.at:578 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:578"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:578: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo actions.at:578 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:578"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:578: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo actions.at:578 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:578"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:578: bison -o input.cc input.y"
echo actions.at:578 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:578"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/actions.at:578: \$BISON_CXX_WORKS"
echo actions.at:578 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:578"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/actions.at:578: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o input input.cc \$LIBS"
echo actions.at:578 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS"; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:578"

$at_failed && at_func_log_failure
$at_traceon; }



# Check the location of "empty"
# -----------------------------
# I.e., epsilon-reductions, as in "(x)" which ends by reducing
# an empty "line" nterm.
# FIXME: This location is not satisfying.  Depend on the lookahead?
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:578:  \$PREPARSER ./input '(x)'"
echo actions.at:578 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '(x)'"; then
  ( $at_traceon;  $PREPARSER ./input '(x)' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '(x)' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: END (3@30-39)
input (0@29-29): /* Nothing */
input (2@0-29): line (0@0-29) input (0@29-29)
Freeing token END (3@30-39)
Freeing nterm input (2@0-29)
Successful parse.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:578"

$at_failed && at_func_log_failure
$at_traceon; }



# Check locations in error recovery
# ---------------------------------
# '(y)' is an error, but can be recovered from.  But what's the location
# of the error itself ('y'), and of the resulting reduction ('(error)').
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:578:  \$PREPARSER ./input '(y)'"
echo actions.at:578 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '(y)'"; then
  ( $at_traceon;  $PREPARSER ./input '(y)' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '(y)' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'y' (1@10-19)
10-19: syntax error, unexpected 'y', expecting 'x'
Freeing token 'y' (1@10-19)
sending: ')' (2@20-29)
line (-1@0-29): '(' (0@0-9) error (@10-19) ')' (2@20-29)
sending: END (3@30-39)
input (0@29-29): /* Nothing */
input (2@0-29): line (-1@0-29) input (0@29-29)
Freeing token END (3@30-39)
Freeing nterm input (2@0-29)
Successful parse.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:578"

$at_failed && at_func_log_failure
$at_traceon; }



# Syntax errors caught by the parser
# ----------------------------------
# Exercise the discarding of stack top and input until `error'
# can be reduced.
#
#     '(', 'x', 'x', 'x', 'x', 'x', ')',
#
# Load the stack and provoke an error that cannot be caught by the
# grammar, to check that the stack is cleared.  And make sure the
# lookahead is freed.
#
#     '(', 'x', ')',
#     '(', 'x', ')',
#     'y'
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:578:  \$PREPARSER ./input '(xxxxx)(x)(x)y'"
echo actions.at:578 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '(xxxxx)(x)(x)y'"; then
  ( $at_traceon;  $PREPARSER ./input '(xxxxx)(x)(x)y' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '(xxxxx)(x)(x)y' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: 'x' (2@20-29)
thing (2@20-29): 'x' (2@20-29)
sending: 'x' (3@30-39)
30-39: syntax error, unexpected 'x', expecting ')'
Freeing nterm thing (2@20-29)
Freeing nterm thing (1@10-19)
Freeing token 'x' (3@30-39)
sending: 'x' (4@40-49)
Freeing token 'x' (4@40-49)
sending: 'x' (5@50-59)
Freeing token 'x' (5@50-59)
sending: ')' (6@60-69)
line (-1@0-69): '(' (0@0-9) error (@10-59) ')' (6@60-69)
sending: '(' (7@70-79)
sending: 'x' (8@80-89)
thing (8@80-89): 'x' (8@80-89)
sending: ')' (9@90-99)
line (7@70-99): '(' (7@70-79) thing (8@80-89) ')' (9@90-99)
sending: '(' (10@100-109)
sending: 'x' (11@110-119)
thing (11@110-119): 'x' (11@110-119)
sending: ')' (12@120-129)
line (10@100-129): '(' (10@100-109) thing (11@110-119) ')' (12@120-129)
sending: 'y' (13@130-139)
input (0@129-129): /* Nothing */
input (2@100-129): line (10@100-129) input (0@129-129)
input (2@70-129): line (7@70-99) input (2@100-129)
input (2@0-129): line (-1@0-69) input (2@70-129)
130-139: syntax error, unexpected 'y', expecting END
Freeing nterm input (2@0-129)
Freeing token 'y' (13@130-139)
Parsing FAILED.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/actions.at:578"

$at_failed && at_func_log_failure
$at_traceon; }



# Syntax error caught by the parser where lookahead = END
# --------------------------------------------------------
# Load the stack and provoke an error that cannot be caught by the
# grammar, to check that the stack is cleared.  And make sure the
# lookahead is freed.
#
#     '(', 'x', ')',
#     '(', 'x', ')',
#     'x'
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:578:  \$PREPARSER ./input '(x)(x)x'"
echo actions.at:578 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '(x)(x)x'"; then
  ( $at_traceon;  $PREPARSER ./input '(x)(x)x' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '(x)(x)x' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: '(' (3@30-39)
sending: 'x' (4@40-49)
thing (4@40-49): 'x' (4@40-49)
sending: ')' (5@50-59)
line (3@30-59): '(' (3@30-39) thing (4@40-49) ')' (5@50-59)
sending: 'x' (6@60-69)
thing (6@60-69): 'x' (6@60-69)
sending: END (7@70-79)
70-79: syntax error, unexpected END, expecting 'x'
Freeing nterm thing (6@60-69)
Freeing nterm line (3@30-59)
Freeing nterm line (0@0-29)
Freeing token END (7@70-79)
Parsing FAILED.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/actions.at:578"

$at_failed && at_func_log_failure
$at_traceon; }



# Check destruction upon stack overflow
# -------------------------------------
# Upon stack overflow, all symbols on the stack should be destroyed.
# Only check for yacc.c.




  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_89
#AT_START_90
# 90. actions.at:580: Printers and Destructors : %glr-parser
at_setup_line='actions.at:580'
at_func_banner 8
at_desc="Printers and Destructors : %glr-parser"
$at_quiet $as_echo_n " 90: $at_desc         "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "90. actions.at:580: testing ..."
  $at_traceon



# Make sure complex $n work.

# Be sure to pass all the %directives to this macro to have correct
# helping macros.  So don't put any directly in the Bison file.





# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code requires {
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#define YYINITDEPTH 10
#define YYMAXDEPTH 10
#define RANGE(Location) (Location).first_line, (Location).last_line
}

%error-verbose
%debug
%verbose
%locations
%glr-parser


%code {

static int yylex (void);
static void yyerror (const char *msg);
}



/* FIXME: This %printer isn't actually tested.  */
%printer
  {
    fprintf (yyoutput, "%d", $$);
  }
  input line thing 'x' 'y'

%destructor
  { printf ("Freeing nterm input (%d@%d-%d)\n", $$, RANGE (@$)); }
  input

%destructor
  { printf ("Freeing nterm line (%d@%d-%d)\n", $$, RANGE (@$)); }
  line

%destructor
  { printf ("Freeing nterm thing (%d@%d-%d)\n", $$, RANGE (@$)); }
  thing

%destructor
  { printf ("Freeing token 'x' (%d@%d-%d)\n", $$, RANGE (@$)); }
  'x'

%destructor
  { printf ("Freeing token 'y' (%d@%d-%d)\n", $$, RANGE (@$)); }
  'y'

%token END 0
%destructor
  { printf ("Freeing token END (%d@%d-%d)\n", $$, RANGE (@$)); }
  END

%%
/*
   This grammar is made to exercise error recovery.
   "Lines" starting with `(' support error recovery, with
   ')' as synchronizing token.  Lines starting with 'x' can never
   be recovered from if in error.
*/

input:
  /* Nothing. */
    {
      $$ = 0;
      printf ("input (%d@%d-%d): /* Nothing */\n", $$, RANGE (@$));
    }
| line input /* Right recursive to load the stack so that popping at
		END can	be exercised.  */
    {
      $$ = 2;
      printf ("input (%d@%d-%d): line (%d@%d-%d) input (%d@%d-%d)\n",
	      $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2));
    }
;

line:
  thing thing thing ';'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): thing (%d@%d-%d) thing (%d@%d-%d) thing (%d@%d-%d) ';' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2),
              $3, RANGE (@3), $4, RANGE (@4));
    }
| '(' thing thing ')'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) thing (%d@%d-%d) thing (%d@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2),
              $3, RANGE (@3), $4, RANGE (@4));
    }
| '(' thing ')'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) thing (%d@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2), $3, RANGE (@3));
    }
| '(' error ')'
    {
      $$ = -1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) error (@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), RANGE (@2), $3, RANGE (@3));
    }
;

thing:
  'x'
    {
      $$ = $1;
      printf ("thing (%d@%d-%d): 'x' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1));
    }
;
%%
/* Alias to ARGV[1]. */
const char *source = 0;

static int
yylex (void)
{
  static unsigned int counter = 0;

  int c = (yylval) = counter++;
  /* As in BASIC, line numbers go from 10 to 10.  */
 (yylloc).first_line = (yylloc).first_column = 10 * c;
  (yylloc).last_line = (yylloc).last_column = (yylloc).first_line + 9;


  if (! (0 <= c && c <= strlen (source)))
    abort ();
  if (source[c])
    printf ("sending: '%c'", source[c]);
  else
    printf ("sending: END");
  printf (" (%d@%d-%d)\n", c, RANGE ((yylloc)));
  return source[c];
}

static void
yyerror (const char *msg)
{
  printf ("%d-%d: %s\n", RANGE (yylloc), msg);
}

int
main (int argc, const char *argv[])
{
  int status;
  yydebug = !!getenv ("YYDEBUG");
  assert (argc == 2);
  source = argv[1];
  status = yyparse ();
  switch (status)
    {
      case 0: printf ("Successful parse.\n"); break;
      case 1: printf ("Parsing FAILED.\n"); break;
      default: printf ("Parsing FAILED (status %d).\n", status); break;
    }
  return status;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:580: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo actions.at:580 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:580"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/actions.at:580: bison --xml=xml-tests/test.xml -o input.c input.y"
echo actions.at:580 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:580"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:580: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo actions.at:580 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:580"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:580: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo actions.at:580 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:580"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:580: bison -o input.c input.y"
echo actions.at:580 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:580"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/actions.at:580: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo actions.at:580 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:580"

$at_failed && at_func_log_failure
$at_traceon; }



# Check the location of "empty"
# -----------------------------
# I.e., epsilon-reductions, as in "(x)" which ends by reducing
# an empty "line" nterm.
# FIXME: This location is not satisfying.  Depend on the lookahead?
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:580:  \$PREPARSER ./input '(x)'"
echo actions.at:580 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '(x)'"; then
  ( $at_traceon;  $PREPARSER ./input '(x)' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '(x)' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: END (3@30-39)
input (0@29-29): /* Nothing */
input (2@0-29): line (0@0-29) input (0@29-29)
Freeing token END (3@30-39)
Freeing nterm input (2@0-29)
Successful parse.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:580"

$at_failed && at_func_log_failure
$at_traceon; }



# Check locations in error recovery
# ---------------------------------
# '(y)' is an error, but can be recovered from.  But what's the location
# of the error itself ('y'), and of the resulting reduction ('(error)').
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:580:  \$PREPARSER ./input '(y)'"
echo actions.at:580 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '(y)'"; then
  ( $at_traceon;  $PREPARSER ./input '(y)' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '(y)' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'y' (1@10-19)
10-19: syntax error, unexpected 'y', expecting 'x'
Freeing token 'y' (1@10-19)
sending: ')' (2@20-29)
line (-1@0-29): '(' (0@0-9) error (@10-19) ')' (2@20-29)
sending: END (3@30-39)
input (0@29-29): /* Nothing */
input (2@0-29): line (-1@0-29) input (0@29-29)
Freeing token END (3@30-39)
Freeing nterm input (2@0-29)
Successful parse.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:580"

$at_failed && at_func_log_failure
$at_traceon; }



# Syntax errors caught by the parser
# ----------------------------------
# Exercise the discarding of stack top and input until `error'
# can be reduced.
#
#     '(', 'x', 'x', 'x', 'x', 'x', ')',
#
# Load the stack and provoke an error that cannot be caught by the
# grammar, to check that the stack is cleared.  And make sure the
# lookahead is freed.
#
#     '(', 'x', ')',
#     '(', 'x', ')',
#     'y'
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:580:  \$PREPARSER ./input '(xxxxx)(x)(x)y'"
echo actions.at:580 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '(xxxxx)(x)(x)y'"; then
  ( $at_traceon;  $PREPARSER ./input '(xxxxx)(x)(x)y' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '(xxxxx)(x)(x)y' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: 'x' (2@20-29)
thing (2@20-29): 'x' (2@20-29)
sending: 'x' (3@30-39)
30-39: syntax error, unexpected 'x', expecting ')'
Freeing nterm thing (2@20-29)
Freeing nterm thing (1@10-19)
Freeing token 'x' (3@30-39)
sending: 'x' (4@40-49)
Freeing token 'x' (4@40-49)
sending: 'x' (5@50-59)
Freeing token 'x' (5@50-59)
sending: ')' (6@60-69)
line (-1@0-69): '(' (0@0-9) error (@10-59) ')' (6@60-69)
sending: '(' (7@70-79)
sending: 'x' (8@80-89)
thing (8@80-89): 'x' (8@80-89)
sending: ')' (9@90-99)
line (7@70-99): '(' (7@70-79) thing (8@80-89) ')' (9@90-99)
sending: '(' (10@100-109)
sending: 'x' (11@110-119)
thing (11@110-119): 'x' (11@110-119)
sending: ')' (12@120-129)
line (10@100-129): '(' (10@100-109) thing (11@110-119) ')' (12@120-129)
sending: 'y' (13@130-139)
input (0@129-129): /* Nothing */
input (2@100-129): line (10@100-129) input (0@129-129)
input (2@70-129): line (7@70-99) input (2@100-129)
input (2@0-129): line (-1@0-69) input (2@70-129)
130-139: syntax error, unexpected 'y', expecting END
Freeing nterm input (2@0-129)
Freeing token 'y' (13@130-139)
Parsing FAILED.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/actions.at:580"

$at_failed && at_func_log_failure
$at_traceon; }



# Syntax error caught by the parser where lookahead = END
# --------------------------------------------------------
# Load the stack and provoke an error that cannot be caught by the
# grammar, to check that the stack is cleared.  And make sure the
# lookahead is freed.
#
#     '(', 'x', ')',
#     '(', 'x', ')',
#     'x'
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:580:  \$PREPARSER ./input '(x)(x)x'"
echo actions.at:580 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '(x)(x)x'"; then
  ( $at_traceon;  $PREPARSER ./input '(x)(x)x' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '(x)(x)x' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: '(' (3@30-39)
sending: 'x' (4@40-49)
thing (4@40-49): 'x' (4@40-49)
sending: ')' (5@50-59)
line (3@30-59): '(' (3@30-39) thing (4@40-49) ')' (5@50-59)
sending: 'x' (6@60-69)
thing (6@60-69): 'x' (6@60-69)
sending: END (7@70-79)
70-79: syntax error, unexpected END, expecting 'x'
Freeing nterm thing (6@60-69)
Freeing nterm line (3@30-59)
Freeing nterm line (0@0-29)
Freeing token END (7@70-79)
Parsing FAILED.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/actions.at:580"

$at_failed && at_func_log_failure
$at_traceon; }



# Check destruction upon stack overflow
# -------------------------------------
# Upon stack overflow, all symbols on the stack should be destroyed.
# Only check for yacc.c.




  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_90
#AT_START_91
# 91. actions.at:581: Printers and Destructors with union: %glr-parser
at_setup_line='actions.at:581'
at_func_banner 8
at_desc="Printers and Destructors with union: %glr-parser"
$at_quiet $as_echo_n " 91: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "91. actions.at:581: testing ..."
  $at_traceon



# Make sure complex $n work.

# Be sure to pass all the %directives to this macro to have correct
# helping macros.  So don't put any directly in the Bison file.





# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code requires {
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#define YYINITDEPTH 10
#define YYMAXDEPTH 10
#define RANGE(Location) (Location).first_line, (Location).last_line
}

%error-verbose
%debug
%verbose
%locations
%glr-parser
%union
{
  int ival;
}

%code provides {

static int yylex (void);
static void yyerror (const char *msg);
}

%type <ival> '(' 'x' 'y' ')' ';' thing line input END

/* FIXME: This %printer isn't actually tested.  */
%printer
  {
    fprintf (yyoutput, "%d", $$);
  }
  input line thing 'x' 'y'

%destructor
  { printf ("Freeing nterm input (%d@%d-%d)\n", $$, RANGE (@$)); }
  input

%destructor
  { printf ("Freeing nterm line (%d@%d-%d)\n", $$, RANGE (@$)); }
  line

%destructor
  { printf ("Freeing nterm thing (%d@%d-%d)\n", $$, RANGE (@$)); }
  thing

%destructor
  { printf ("Freeing token 'x' (%d@%d-%d)\n", $$, RANGE (@$)); }
  'x'

%destructor
  { printf ("Freeing token 'y' (%d@%d-%d)\n", $$, RANGE (@$)); }
  'y'

%token END 0
%destructor
  { printf ("Freeing token END (%d@%d-%d)\n", $$, RANGE (@$)); }
  END

%%
/*
   This grammar is made to exercise error recovery.
   "Lines" starting with `(' support error recovery, with
   ')' as synchronizing token.  Lines starting with 'x' can never
   be recovered from if in error.
*/

input:
  /* Nothing. */
    {
      $$ = 0;
      printf ("input (%d@%d-%d): /* Nothing */\n", $$, RANGE (@$));
    }
| line input /* Right recursive to load the stack so that popping at
		END can	be exercised.  */
    {
      $$ = 2;
      printf ("input (%d@%d-%d): line (%d@%d-%d) input (%d@%d-%d)\n",
	      $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2));
    }
;

line:
  thing thing thing ';'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): thing (%d@%d-%d) thing (%d@%d-%d) thing (%d@%d-%d) ';' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2),
              $3, RANGE (@3), $4, RANGE (@4));
    }
| '(' thing thing ')'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) thing (%d@%d-%d) thing (%d@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2),
              $3, RANGE (@3), $4, RANGE (@4));
    }
| '(' thing ')'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) thing (%d@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2), $3, RANGE (@3));
    }
| '(' error ')'
    {
      $$ = -1;
      printf ("line (%d@%d-%d): '(' (%d@%d-%d) error (@%d-%d) ')' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), RANGE (@2), $3, RANGE (@3));
    }
;

thing:
  'x'
    {
      $$ = $1;
      printf ("thing (%d@%d-%d): 'x' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1));
    }
;
%%
/* Alias to ARGV[1]. */
const char *source = 0;

static int
yylex (void)
{
  static unsigned int counter = 0;

  int c = (yylval).ival = counter++;
  /* As in BASIC, line numbers go from 10 to 10.  */
 (yylloc).first_line = (yylloc).first_column = 10 * c;
  (yylloc).last_line = (yylloc).last_column = (yylloc).first_line + 9;


  if (! (0 <= c && c <= strlen (source)))
    abort ();
  if (source[c])
    printf ("sending: '%c'", source[c]);
  else
    printf ("sending: END");
  printf (" (%d@%d-%d)\n", c, RANGE ((yylloc)));
  return source[c];
}

static void
yyerror (const char *msg)
{
  printf ("%d-%d: %s\n", RANGE (yylloc), msg);
}

int
main (int argc, const char *argv[])
{
  int status;
  yydebug = !!getenv ("YYDEBUG");
  assert (argc == 2);
  source = argv[1];
  status = yyparse ();
  switch (status)
    {
      case 0: printf ("Successful parse.\n"); break;
      case 1: printf ("Parsing FAILED.\n"); break;
      default: printf ("Parsing FAILED (status %d).\n", status); break;
    }
  return status;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:581: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo actions.at:581 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:581"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/actions.at:581: bison --xml=xml-tests/test.xml -o input.c input.y"
echo actions.at:581 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:581"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:581: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo actions.at:581 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:581"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:581: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo actions.at:581 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:581"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:581: bison -o input.c input.y"
echo actions.at:581 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:581"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/actions.at:581: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo actions.at:581 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:581"

$at_failed && at_func_log_failure
$at_traceon; }



# Check the location of "empty"
# -----------------------------
# I.e., epsilon-reductions, as in "(x)" which ends by reducing
# an empty "line" nterm.
# FIXME: This location is not satisfying.  Depend on the lookahead?
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:581:  \$PREPARSER ./input '(x)'"
echo actions.at:581 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '(x)'"; then
  ( $at_traceon;  $PREPARSER ./input '(x)' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '(x)' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: END (3@30-39)
input (0@29-29): /* Nothing */
input (2@0-29): line (0@0-29) input (0@29-29)
Freeing token END (3@30-39)
Freeing nterm input (2@0-29)
Successful parse.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:581"

$at_failed && at_func_log_failure
$at_traceon; }



# Check locations in error recovery
# ---------------------------------
# '(y)' is an error, but can be recovered from.  But what's the location
# of the error itself ('y'), and of the resulting reduction ('(error)').
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:581:  \$PREPARSER ./input '(y)'"
echo actions.at:581 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '(y)'"; then
  ( $at_traceon;  $PREPARSER ./input '(y)' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '(y)' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'y' (1@10-19)
10-19: syntax error, unexpected 'y', expecting 'x'
Freeing token 'y' (1@10-19)
sending: ')' (2@20-29)
line (-1@0-29): '(' (0@0-9) error (@10-19) ')' (2@20-29)
sending: END (3@30-39)
input (0@29-29): /* Nothing */
input (2@0-29): line (-1@0-29) input (0@29-29)
Freeing token END (3@30-39)
Freeing nterm input (2@0-29)
Successful parse.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:581"

$at_failed && at_func_log_failure
$at_traceon; }



# Syntax errors caught by the parser
# ----------------------------------
# Exercise the discarding of stack top and input until `error'
# can be reduced.
#
#     '(', 'x', 'x', 'x', 'x', 'x', ')',
#
# Load the stack and provoke an error that cannot be caught by the
# grammar, to check that the stack is cleared.  And make sure the
# lookahead is freed.
#
#     '(', 'x', ')',
#     '(', 'x', ')',
#     'y'
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:581:  \$PREPARSER ./input '(xxxxx)(x)(x)y'"
echo actions.at:581 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '(xxxxx)(x)(x)y'"; then
  ( $at_traceon;  $PREPARSER ./input '(xxxxx)(x)(x)y' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '(xxxxx)(x)(x)y' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: 'x' (2@20-29)
thing (2@20-29): 'x' (2@20-29)
sending: 'x' (3@30-39)
30-39: syntax error, unexpected 'x', expecting ')'
Freeing nterm thing (2@20-29)
Freeing nterm thing (1@10-19)
Freeing token 'x' (3@30-39)
sending: 'x' (4@40-49)
Freeing token 'x' (4@40-49)
sending: 'x' (5@50-59)
Freeing token 'x' (5@50-59)
sending: ')' (6@60-69)
line (-1@0-69): '(' (0@0-9) error (@10-59) ')' (6@60-69)
sending: '(' (7@70-79)
sending: 'x' (8@80-89)
thing (8@80-89): 'x' (8@80-89)
sending: ')' (9@90-99)
line (7@70-99): '(' (7@70-79) thing (8@80-89) ')' (9@90-99)
sending: '(' (10@100-109)
sending: 'x' (11@110-119)
thing (11@110-119): 'x' (11@110-119)
sending: ')' (12@120-129)
line (10@100-129): '(' (10@100-109) thing (11@110-119) ')' (12@120-129)
sending: 'y' (13@130-139)
input (0@129-129): /* Nothing */
input (2@100-129): line (10@100-129) input (0@129-129)
input (2@70-129): line (7@70-99) input (2@100-129)
input (2@0-129): line (-1@0-69) input (2@70-129)
130-139: syntax error, unexpected 'y', expecting END
Freeing nterm input (2@0-129)
Freeing token 'y' (13@130-139)
Parsing FAILED.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/actions.at:581"

$at_failed && at_func_log_failure
$at_traceon; }



# Syntax error caught by the parser where lookahead = END
# --------------------------------------------------------
# Load the stack and provoke an error that cannot be caught by the
# grammar, to check that the stack is cleared.  And make sure the
# lookahead is freed.
#
#     '(', 'x', ')',
#     '(', 'x', ')',
#     'x'
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:581:  \$PREPARSER ./input '(x)(x)x'"
echo actions.at:581 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '(x)(x)x'"; then
  ( $at_traceon;  $PREPARSER ./input '(x)(x)x' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '(x)(x)x' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "sending: '(' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: ')' (2@20-29)
line (0@0-29): '(' (0@0-9) thing (1@10-19) ')' (2@20-29)
sending: '(' (3@30-39)
sending: 'x' (4@40-49)
thing (4@40-49): 'x' (4@40-49)
sending: ')' (5@50-59)
line (3@30-59): '(' (3@30-39) thing (4@40-49) ')' (5@50-59)
sending: 'x' (6@60-69)
thing (6@60-69): 'x' (6@60-69)
sending: END (7@70-79)
70-79: syntax error, unexpected END, expecting 'x'
Freeing nterm thing (6@60-69)
Freeing nterm line (3@30-59)
Freeing nterm line (0@0-29)
Freeing token END (7@70-79)
Parsing FAILED.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/actions.at:581"

$at_failed && at_func_log_failure
$at_traceon; }



# Check destruction upon stack overflow
# -------------------------------------
# Upon stack overflow, all symbols on the stack should be destroyed.
# Only check for yacc.c.




  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_91
#AT_START_92
# 92. actions.at:592: Default tagless %printer and %destructor
at_setup_line='actions.at:592'
at_func_banner 8
at_desc="Default tagless %printer and %destructor"
$at_quiet $as_echo_n " 92: $at_desc       "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "92. actions.at:592: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%error-verbose
%debug
%locations
%initial-action {
  @$.first_line = @$.last_line = 1;
  @$.first_column = @$.last_column = 1;
}

%{
# include <stdio.h>
# include <stdlib.h>
  static void yyerror (const char *msg);
  static int yylex (void);
# define USE(SYM)
%}

%printer {
  fprintf (yyoutput, "<*> printer should not be called.\n");
} <*>

%printer {
  fprintf (yyoutput, "<> printer for '%c' @ %d", $$, @$.first_column);
} <>
%destructor {
  fprintf (stdout, "<> destructor for '%c' @ %d.\n", $$, @$.first_column);
} <>

%printer {
  fprintf (yyoutput, "'b'/'c' printer for '%c' @ %d", $$, @$.first_column);
} 'b' 'c'
%destructor {
  fprintf (stdout, "'b'/'c' destructor for '%c' @ %d.\n", $$, @$.first_column);
} 'b' 'c'

%destructor {
  fprintf (yyoutput, "<*> destructor should not be called.\n");
} <*>

%%

start: 'a' 'b' 'c' 'd' 'e' { $$ = 'S'; USE(($1, $2, $3, $4, $5)); } ;

%%

static int
yylex (void)
{
  static char const input[] = "abcd";
  static size_t toknum;
  if (! (toknum < sizeof input))
    abort ();
  yylval = input[toknum++];
  yylloc.first_line = yylloc.last_line = 1;
  yylloc.first_column = yylloc.last_column = toknum;
  return yylval;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  yydebug = 1;
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:666: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo actions.at:666 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:666"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/actions.at:666: bison --xml=xml-tests/test.xml -o input.c input.y"
echo actions.at:666 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:666"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:666: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo actions.at:666 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:666"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:666: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo actions.at:666 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:666"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:666: bison -o input.c input.y"
echo actions.at:666 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:666"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/actions.at:667: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo actions.at:667 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:667"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/actions.at:668:  \$PREPARSER ./input"
echo actions.at:668 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input"; then
  ( $at_traceon;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "Starting parse
Entering state 0
Reading a token: Next token is token 'a' (1.1-1.1: <> printer for 'a' @ 1)
Shifting token 'a' (1.1-1.1: <> printer for 'a' @ 1)
Entering state 1
Reading a token: Next token is token 'b' (1.2-1.2: 'b'/'c' printer for 'b' @ 2)
Shifting token 'b' (1.2-1.2: 'b'/'c' printer for 'b' @ 2)
Entering state 3
Reading a token: Next token is token 'c' (1.3-1.3: 'b'/'c' printer for 'c' @ 3)
Shifting token 'c' (1.3-1.3: 'b'/'c' printer for 'c' @ 3)
Entering state 5
Reading a token: Next token is token 'd' (1.4-1.4: <> printer for 'd' @ 4)
Shifting token 'd' (1.4-1.4: <> printer for 'd' @ 4)
Entering state 6
Reading a token: Now at end of input.
syntax error, unexpected \$end, expecting 'e'
Error: popping token 'd' (1.4-1.4: <> printer for 'd' @ 4)
Stack now 0 1 3 5
Error: popping token 'c' (1.3-1.3: 'b'/'c' printer for 'c' @ 3)
Stack now 0 1 3
Error: popping token 'b' (1.2-1.2: 'b'/'c' printer for 'b' @ 2)
Stack now 0 1
Error: popping token 'a' (1.1-1.1: <> printer for 'a' @ 1)
Stack now 0
Cleanup: discarding lookahead token \$end (1.5-1.5: )
Stack now 0
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "<> destructor for 'd' @ 4.
'b'/'c' destructor for 'c' @ 3.
'b'/'c' destructor for 'b' @ 2.
<> destructor for 'a' @ 1.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/actions.at:668"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_92
#AT_START_93
# 93. actions.at:710: Default tagged and per-type %printer and %destructor
at_setup_line='actions.at:710'
at_func_banner 8
at_desc="Default tagged and per-type %printer and %destructor"
$at_quiet $as_echo_n " 93: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "93. actions.at:710: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%error-verbose
%debug

%{
# include <stdio.h>
# include <stdlib.h>
  static void yyerror (const char *msg);
  static int yylex (void);
# define USE(SYM)
%}

%printer {
  fprintf (yyoutput, "<> printer should not be called.\n");
} <>

%union { int field0; int field1; int field2; }
%type <field0> start 'a' 'g'
%type <field1> 'e'
%type <field2> 'f'
%printer {
  fprintf (yyoutput, "<*>/<field2>/e printer");
} <*> 'e' <field2>
%destructor {
  fprintf (stdout, "<*>/<field2>/e destructor.\n");
} <*> 'e' <field2>

%type <field1> 'b'
%printer { fprintf (yyoutput, "<field1> printer"); } <field1>
%destructor { fprintf (stdout, "<field1> destructor.\n"); } <field1>

%type <field0> 'c'
%printer { fprintf (yyoutput, "'c' printer"); } 'c'
%destructor { fprintf (stdout, "'c' destructor.\n"); } 'c'

%type <field1> 'd'
%printer { fprintf (yyoutput, "'d' printer"); } 'd'
%destructor { fprintf (stdout, "'d' destructor.\n"); } 'd'

%destructor {
  fprintf (yyoutput, "<> destructor should not be called.\n");
} <>

%%

start:
  'a' 'b' 'c' 'd' 'e' 'f' 'g'
    {
      USE(($1, $2, $3, $4, $5, $6, $7));
      $$ = 'S';
    }
  ;

%%

static int
yylex (void)
{
  static char const input[] = "abcdef";
  static size_t toknum;
  if (! (toknum < sizeof input))
    abort ();
  return input[toknum++];
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  yydebug = 1;
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:791: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo actions.at:791 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:791"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/actions.at:791: bison --xml=xml-tests/test.xml -o input.c input.y"
echo actions.at:791 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:791"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:791: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo actions.at:791 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:791"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:791: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo actions.at:791 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:791"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:791: bison -o input.c input.y"
echo actions.at:791 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:791"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/actions.at:792: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo actions.at:792 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:792"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/actions.at:793:  \$PREPARSER ./input"
echo actions.at:793 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input"; then
  ( $at_traceon;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "Starting parse
Entering state 0
Reading a token: Next token is token 'a' (<*>/<field2>/e printer)
Shifting token 'a' (<*>/<field2>/e printer)
Entering state 1
Reading a token: Next token is token 'b' (<field1> printer)
Shifting token 'b' (<field1> printer)
Entering state 3
Reading a token: Next token is token 'c' ('c' printer)
Shifting token 'c' ('c' printer)
Entering state 5
Reading a token: Next token is token 'd' ('d' printer)
Shifting token 'd' ('d' printer)
Entering state 6
Reading a token: Next token is token 'e' (<*>/<field2>/e printer)
Shifting token 'e' (<*>/<field2>/e printer)
Entering state 7
Reading a token: Next token is token 'f' (<*>/<field2>/e printer)
Shifting token 'f' (<*>/<field2>/e printer)
Entering state 8
Reading a token: Now at end of input.
syntax error, unexpected \$end, expecting 'g'
Error: popping token 'f' (<*>/<field2>/e printer)
Stack now 0 1 3 5 6 7
Error: popping token 'e' (<*>/<field2>/e printer)
Stack now 0 1 3 5 6
Error: popping token 'd' ('d' printer)
Stack now 0 1 3 5
Error: popping token 'c' ('c' printer)
Stack now 0 1 3
Error: popping token 'b' (<field1> printer)
Stack now 0 1
Error: popping token 'a' (<*>/<field2>/e printer)
Stack now 0
Cleanup: discarding lookahead token \$end ()
Stack now 0
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "<*>/<field2>/e destructor.
<*>/<field2>/e destructor.
'd' destructor.
'c' destructor.
<field1> destructor.
<*>/<field2>/e destructor.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/actions.at:793"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_93
#AT_START_94
# 94. actions.at:847: Default %printer and %destructor for user-defined end token
at_setup_line='actions.at:847'
at_func_banner 8
at_desc="Default %printer and %destructor for user-defined end token"
$at_quiet $as_echo_n " 94: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "94. actions.at:847: testing ..."
  $at_traceon


# _AT_CHECK_DEFAULT_PRINTER_AND_DESTRUCTOR_FOR_END_TOKEN(TYPED)
# -----------------------------------------------------------------------------




cat >input0.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%error-verbose
%debug
%locations
%initial-action {
  @$.first_line = @$.last_line = 1;
  @$.first_column = @$.last_column = 1;
}

%{
# include <stdio.h>
# include <stdlib.h>
  static void yyerror (const char *msg);
  static int yylex (void);
# define USE(SYM)
%}

%destructor {
  fprintf (yyoutput, "<*> destructor should not be called.\n");
} <*>

%token END 0
%printer {
  fprintf (yyoutput, "<> for '%c' @ %d", $$, @$.first_column);
} <>
%destructor {
  fprintf (stdout, "<> for '%c' @ %d.\n", $$, @$.first_column);
} <>

%printer {
  fprintf (yyoutput, "<*> printer should not be called.\n");
} <*>




%%

start: { $$ = 'S'; } ;

%%

static int
yylex (void)
{
  static int called;
  if (called++)
    abort ();
  yylval = 'E';
  yylloc.first_line = yylloc.last_line = 1;
  yylloc.first_column = yylloc.last_column = 1;
  return 0;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  yydebug = 1;
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:950: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input0.c input0.y"
echo actions.at:950 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input0.c input0.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input0.c input0.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:950"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/actions.at:950: bison --xml=xml-tests/test.xml -o input0.c input0.y"
echo actions.at:950 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input0.c input0.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input0.c input0.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:950"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:950: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo actions.at:950 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:950"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:950: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo actions.at:950 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:950"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:950: bison -o input0.c input0.y"
echo actions.at:950 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input0.c input0.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input0.c input0.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:950"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/actions.at:950: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input0 input0.c \$LIBS"
echo actions.at:950 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input0 input0.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input0 input0.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input0 input0.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:950"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/actions.at:950:  \$PREPARSER ./input0"
echo actions.at:950 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input0"; then
  ( $at_traceon;  $PREPARSER ./input0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "Starting parse
Entering state 0
Reducing stack by rule 1 (line 46):
-> \$\$ = nterm start (1.1-1.1: <> for 'S' @ 1)
Stack now 0
Entering state 1
Reading a token: Now at end of input.
Shifting token END (1.1-1.1: <> for 'E' @ 1)
Entering state 2
Stack now 0 1 2
Cleanup: popping token END (1.1-1.1: <> for 'E' @ 1)
Cleanup: popping nterm start (1.1-1.1: <> for 'S' @ 1)
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "<> for 'E' @ 1.
<> for 'S' @ 1.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:950"

$at_failed && at_func_log_failure
$at_traceon; }







cat >input1.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%error-verbose
%debug
%locations
%initial-action {
  @$.first_line = @$.last_line = 1;
  @$.first_column = @$.last_column = 1;
}

%{
# include <stdio.h>
# include <stdlib.h>
  static void yyerror (const char *msg);
  static int yylex (void);
# define USE(SYM)
%}

%destructor {
  fprintf (yyoutput, "<> destructor should not be called.\n");
} <>

%token END 0
%printer {
  fprintf (yyoutput, "<*> for '%c' @ %d", $$, @$.first_column);
} <*>
%destructor {
  fprintf (stdout, "<*> for '%c' @ %d.\n", $$, @$.first_column);
} <*>

%printer {
  fprintf (yyoutput, "<> printer should not be called.\n");
} <>

%union { char tag; }
%type <tag> start END

%%

start: { $$ = 'S'; } ;

%%

static int
yylex (void)
{
  static int called;
  if (called++)
    abort ();
  yylval.tag = 'E';
  yylloc.first_line = yylloc.last_line = 1;
  yylloc.first_column = yylloc.last_column = 1;
  return 0;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  yydebug = 1;
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:951: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input1.c input1.y"
echo actions.at:951 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input1.c input1.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input1.c input1.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:951"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/actions.at:951: bison --xml=xml-tests/test.xml -o input1.c input1.y"
echo actions.at:951 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input1.c input1.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input1.c input1.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:951"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:951: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo actions.at:951 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:951"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:951: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo actions.at:951 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:951"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:951: bison -o input1.c input1.y"
echo actions.at:951 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input1.c input1.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input1.c input1.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:951"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/actions.at:951: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input1 input1.c \$LIBS"
echo actions.at:951 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input1 input1.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input1 input1.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input1 input1.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:951"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/actions.at:951:  \$PREPARSER ./input1"
echo actions.at:951 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input1"; then
  ( $at_traceon;  $PREPARSER ./input1 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input1 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "Starting parse
Entering state 0
Reducing stack by rule 1 (line 46):
-> \$\$ = nterm start (1.1-1.1: <*> for 'S' @ 1)
Stack now 0
Entering state 1
Reading a token: Now at end of input.
Shifting token END (1.1-1.1: <*> for 'E' @ 1)
Entering state 2
Stack now 0 1 2
Cleanup: popping token END (1.1-1.1: <*> for 'E' @ 1)
Cleanup: popping nterm start (1.1-1.1: <*> for 'S' @ 1)
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "<*> for 'E' @ 1.
<*> for 'S' @ 1.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:951"

$at_failed && at_func_log_failure
$at_traceon; }






  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_94
#AT_START_95
# 95. actions.at:961: Default %printer and %destructor are not for error or $undefined
at_setup_line='actions.at:961'
at_func_banner 8
at_desc="Default %printer and %destructor are not for error or \$undefined"
$at_quiet $as_echo_n " 95: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "95. actions.at:961: testing ..."
  $at_traceon


# If Bison were to apply the default %printer and %destructor to the error
# token or to $undefined:
#   - For the error token:
#     - It would generate warnings for unused $n.
#     - It would invoke the %printer and %destructor on the error token's
#       semantic value, which would be initialized from the lookahead, which
#       would be destroyed separately.
#   - For $undefined, who knows what the semantic value would be.

cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%debug

%{
# include <stdio.h>
# include <stdlib.h>
  static void yyerror (const char *msg);
  static int yylex (void);
# define USE(SYM)
%}

%printer {
  fprintf (yyoutput, "'%c'", $$);
} <> <*>
%destructor {
  fprintf (stderr, "DESTROY '%c'\n", $$);
} <> <*>

%%

start:
  { $$ = 'S'; }
  /* In order to reveal the problems that this bug caused during parsing, add
   * $2 to USE.  */
  | 'a' error 'b' 'c' { USE(($1, $3, $4)); $$ = 'S'; }
  ;

%%

static int
yylex (void)
{
  static char const input[] = "abd";
  static size_t toknum;
  if (! (toknum < sizeof input))
    abort ();
  yylval = input[toknum++];
  return yylval;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  yydebug = 1;
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:1026: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo actions.at:1026 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1026"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/actions.at:1026: bison --xml=xml-tests/test.xml -o input.c input.y"
echo actions.at:1026 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1026"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:1026: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo actions.at:1026 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1026"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:1026: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo actions.at:1026 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1026"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:1026: bison -o input.c input.y"
echo actions.at:1026 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1026"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/actions.at:1027: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo actions.at:1027 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1027"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/actions.at:1028:  \$PREPARSER ./input"
echo actions.at:1028 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input"; then
  ( $at_traceon;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "Starting parse
Entering state 0
Reading a token: Next token is token 'a' ('a')
Shifting token 'a' ('a')
Entering state 1
Reading a token: Next token is token 'b' ('b')
syntax error
Shifting token error ()
Entering state 3
Next token is token 'b' ('b')
Shifting token 'b' ('b')
Entering state 5
Reading a token: Next token is token \$undefined ()
Error: popping token 'b' ('b')
DESTROY 'b'
Stack now 0 1 3
Error: popping token error ()
Stack now 0 1
Shifting token error ()
Entering state 3
Next token is token \$undefined ()
Error: discarding token \$undefined ()
Error: popping token error ()
Stack now 0 1
Shifting token error ()
Entering state 3
Reading a token: Now at end of input.
Cleanup: discarding lookahead token \$end ()
Stack now 0 1 3
Cleanup: popping token error ()
Cleanup: popping token 'a' ('a')
DESTROY 'a'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/actions.at:1028"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_95
#AT_START_96
# 96. actions.at:1071: Default %printer and %destructor are not for $accept
at_setup_line='actions.at:1071'
at_func_banner 8
at_desc="Default %printer and %destructor are not for \$accept"
$at_quiet $as_echo_n " 96: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "96. actions.at:1071: testing ..."
  $at_traceon


# If YYSTYPE is a union and Bison were to apply the default %printer and
# %destructor to $accept:
#   - The %printer and %destructor code generated for $accept would always be
#     dead code because $accept is currently never shifted onto the stack.
#   - $$ for $accept would always be of type YYSTYPE because it's not possible
#     to declare `%type <field> $accept'.  (Also true for $undefined.)
#   - Thus, the compiler might complain that the user code assumes the wrong
#     type for $$ since the code might assume the type associated with a
#     specific union field, which is especially reasonable in C++ since that
#     type may be a base type.  This test case checks for this problem.  (Also
#     true for $undefined and the error token, so there are three warnings for
#     %printer and three for %destructor.)

cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%debug /* So that %printer is actually compiled.  */

%{
# include <stdio.h>
# include <stdlib.h>
  static void yyerror (const char *msg);
  static int yylex (void);
# define USE(SYM)
%}

%printer {
  char chr = $$;
  fprintf (yyoutput, "'%c'", chr);
} <> <*>
%destructor {
  char chr = $$;
  fprintf (stderr, "DESTROY '%c'\n", chr);
} <> <*>

%union { char chr; }
%type <chr> start

%%

start: { USE($$); } ;

%%

static int
yylex (void)
{
  static int called;
  if (called++)
    abort ();
  return 0;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:1137: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo actions.at:1137 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1137"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/actions.at:1137: bison --xml=xml-tests/test.xml -o input.c input.y"
echo actions.at:1137 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1137"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:1137: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo actions.at:1137 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1137"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:1137: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo actions.at:1137 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1137"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:1137: bison -o input.c input.y"
echo actions.at:1137 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1137"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/actions.at:1138: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo actions.at:1138 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1138"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_96
#AT_START_97
# 97. actions.at:1148: Default %printer and %destructor for mid-rule values
at_setup_line='actions.at:1148'
at_func_banner 8
at_desc="Default %printer and %destructor for mid-rule values"
$at_quiet $as_echo_n " 97: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "97. actions.at:1148: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%debug /* So that %printer is actually compiled.  */

%{
# include <stdio.h>
# include <stdlib.h>
  static void yyerror (const char *msg);
  static int yylex (void);
# define USE(SYM)
# define YYLTYPE int
# define YYLLOC_DEFAULT(Current, Rhs, N)
# define YY_LOCATION_PRINT(File, Loc)
%}

%printer { fprintf (yyoutput, "%d", @$); } <>
%destructor { fprintf (stderr, "DESTROY %d\n", @$); } <>
%printer { fprintf (yyoutput, "<*> printer should not be called"); } <*>
%destructor { fprintf (yyoutput, "<*> destructor should not be called"); } <*>

%%

start:
  {           @$ = 1; } // Not set or used.
  { USE ($$); @$ = 2; } // Both set and used.
  { USE ($$); @$ = 3; } // Only set.
  {           @$ = 4; } // Only used.
  'c'
  { USE (($$, $2, $4, $5)); @$ = 0; }
  ;

%%

static int
yylex (void)
{
  static int called;
  if (called++)
    abort ();
  return 0;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  yydebug = 1;
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:1205: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo actions.at:1205 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1205"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/actions.at:1205: bison --xml=xml-tests/test.xml -o input.c input.y"
echo actions.at:1205 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1205"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:1205: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo actions.at:1205 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1205"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:1205: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo actions.at:1205 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1205"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:1205: bison -o input.c input.y"
echo actions.at:1205 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:33.3-23: warning: unset value: \$\$
input.y:30.3-35.37: warning: unused value: \$3
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1205"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/actions.at:1210: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo actions.at:1210 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1210"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/actions.at:1211:  \$PREPARSER ./input"
echo actions.at:1211 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input"; then
  ( $at_traceon;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "Starting parse
Entering state 0
Reducing stack by rule 1 (line 30):
-> \$\$ = nterm \$@1 (: )
Stack now 0
Entering state 2
Reducing stack by rule 2 (line 31):
-> \$\$ = nterm @2 (: 2)
Stack now 0 2
Entering state 4
Reducing stack by rule 3 (line 32):
-> \$\$ = nterm @3 (: 3)
Stack now 0 2 4
Entering state 5
Reducing stack by rule 4 (line 33):
-> \$\$ = nterm @4 (: 4)
Stack now 0 2 4 5
Entering state 6
Reading a token: Now at end of input.
syntax error
Error: popping nterm @4 (: 4)
DESTROY 4
Stack now 0 2 4 5
Error: popping nterm @3 (: 3)
DESTROY 3
Stack now 0 2 4
Error: popping nterm @2 (: 2)
DESTROY 2
Stack now 0 2
Error: popping nterm \$@1 (: )
Stack now 0
Cleanup: discarding lookahead token \$end (: )
Stack now 0
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/actions.at:1211"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_97
#AT_START_98
# 98. actions.at:1304: @$ in %initial-action implies %locations
at_setup_line='actions.at:1304'
at_func_banner 8
at_desc="@\$ in %initial-action implies %locations"
$at_quiet $as_echo_n " 98: $at_desc       "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "98. actions.at:1304: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static int yylex (void);
  static void yyerror (char const *msg);
}

%debug

%initial-action {
  printf ("%d\n", @$.first_line);
}

%%

start:  ;

%%

static int
yylex (void)
{
  return 0;
}

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:1304: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo actions.at:1304 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1304"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/actions.at:1304: bison --xml=xml-tests/test.xml -o input.c input.y"
echo actions.at:1304 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1304"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:1304: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo actions.at:1304 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1304"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:1304: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo actions.at:1304 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1304"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:1304: bison -o input.c input.y"
echo actions.at:1304 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1304"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/actions.at:1304: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo actions.at:1304 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1304"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_98
#AT_START_99
# 99. actions.at:1305: @$ in %destructor implies %locations
at_setup_line='actions.at:1305'
at_func_banner 8
at_desc="@\$ in %destructor implies %locations"
$at_quiet $as_echo_n " 99: $at_desc           "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "99. actions.at:1305: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static int yylex (void);
  static void yyerror (char const *msg);
}

%debug

%destructor {
  printf ("%d\n", @$.first_line);
} start

%%

start:  ;

%%

static int
yylex (void)
{
  return 0;
}

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:1305: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo actions.at:1305 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1305"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/actions.at:1305: bison --xml=xml-tests/test.xml -o input.c input.y"
echo actions.at:1305 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1305"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:1305: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo actions.at:1305 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1305"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:1305: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo actions.at:1305 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1305"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:1305: bison -o input.c input.y"
echo actions.at:1305 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1305"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/actions.at:1305: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo actions.at:1305 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1305"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_99
#AT_START_100
# 100. actions.at:1306: @$ in %printer implies %locations
at_setup_line='actions.at:1306'
at_func_banner 8
at_desc="@\$ in %printer implies %locations"
$at_quiet $as_echo_n "100: $at_desc              "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "100. actions.at:1306: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%code {
  #include <stdio.h>
  static int yylex (void);
  static void yyerror (char const *msg);
}

%debug

%printer {
  printf ("%d\n", @$.first_line);
} start

%%

start:  ;

%%

static int
yylex (void)
{
  return 0;
}

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:1306: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo actions.at:1306 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1306"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/actions.at:1306: bison --xml=xml-tests/test.xml -o input.c input.y"
echo actions.at:1306 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1306"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:1306: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo actions.at:1306 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1306"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/actions.at:1306: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo actions.at:1306 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1306"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/actions.at:1306: bison -o input.c input.y"
echo actions.at:1306 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1306"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/actions.at:1306: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo actions.at:1306 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/actions.at:1306"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_100
#AT_START_101
# 101. conflicts.at:30: S/R in initial
at_setup_line='conflicts.at:30'
at_func_banner 9
at_desc="S/R in initial"
$at_quiet $as_echo_n "101: $at_desc                                 "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "101. conflicts.at:30: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%expect 1
%%
exp: e 'e';
e: 'e' | /* Nothing. */;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:39: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo conflicts.at:39 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:39"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:39: bison --xml=xml-tests/test.xml -o input.c input.y"
echo conflicts.at:39 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:39"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:39: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo conflicts.at:39 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:39"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:39: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo conflicts.at:39 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:39"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:39: bison -o input.c input.y"
echo conflicts.at:39 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:4.9: warning: rule useless in parser due to conflicts: e: /* empty */
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:39"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_101
#AT_START_102
# 102. conflicts.at:50: %nonassoc and eof
at_setup_line='conflicts.at:50'
at_func_banner 9
at_desc="%nonassoc and eof"
$at_quiet $as_echo_n "102: $at_desc                              "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "102. conflicts.at:50: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define YYERROR_VERBOSE 1
static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

/* The current argument. */
static const char *input;

static int
yylex (void)
{
  static size_t toknum;
  if (! (toknum <= strlen (input)))
    abort ();
  return input[toknum++];
}

%}

%nonassoc '<' '>'

%%
expr: expr '<' expr
    | expr '>' expr
    | '0'
    ;
%%
int
main (int argc, const char *argv[])
{
  input = argc <= 1 ? "" : argv[1];
  return yyparse ();
}
_ATEOF



# Specify the output files to avoid problems on different file systems.
if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:97: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo conflicts.at:97 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:97"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:97: bison --xml=xml-tests/test.xml -o input.c input.y"
echo conflicts.at:97 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:97"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:97: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo conflicts.at:97 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:97"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:97: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo conflicts.at:97 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:97"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:97: bison -o input.c input.y"
echo conflicts.at:97 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:97"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:98: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo conflicts.at:98 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:98"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:100:  \$PREPARSER ./input '0<0'"
echo conflicts.at:100 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '0<0'"; then
  ( $at_traceon;  $PREPARSER ./input '0<0' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '0<0' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:100"

$at_failed && at_func_log_failure
$at_traceon; }

# FIXME: This is an actual bug, but a new one, in the sense that
# no one has ever spotted it!  The messages are *wrong*: there should
# be nothing there, it should be expected eof.
{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:104:  \$PREPARSER ./input '0<0<0'"
echo conflicts.at:104 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '0<0<0'"; then
  ( $at_traceon;  $PREPARSER ./input '0<0<0' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '0<0<0' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "syntax error, unexpected '<', expecting '<' or '>'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/conflicts.at:104"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:108:  \$PREPARSER ./input '0>0'"
echo conflicts.at:108 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '0>0'"; then
  ( $at_traceon;  $PREPARSER ./input '0>0' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '0>0' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:108"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:109:  \$PREPARSER ./input '0>0>0'"
echo conflicts.at:109 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '0>0>0'"; then
  ( $at_traceon;  $PREPARSER ./input '0>0>0' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '0>0>0' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "syntax error, unexpected '>', expecting '<' or '>'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/conflicts.at:109"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:113:  \$PREPARSER ./input '0<0>0'"
echo conflicts.at:113 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input '0<0>0'"; then
  ( $at_traceon;  $PREPARSER ./input '0<0>0' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input '0<0>0' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "syntax error, unexpected '>', expecting '<' or '>'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/conflicts.at:113"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_102
#AT_START_103
# 103. conflicts.at:125: Unresolved SR Conflicts
at_setup_line='conflicts.at:125'
at_func_banner 9
at_desc="Unresolved SR Conflicts"
$at_quiet $as_echo_n "103: $at_desc                        "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "103. conflicts.at:125: testing ..."
  $at_traceon




cat >input.y <<'_ATEOF'
%token NUM OP
%%
exp: exp OP exp | NUM;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:135: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c --report=all input.y"
echo conflicts.at:135 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c --report=all input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c --report=all input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:135"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:135: bison --xml=xml-tests/test.xml -o input.c --report=all input.y"
echo conflicts.at:135 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c --report=all input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c --report=all input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:135"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:135: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo conflicts.at:135 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:135"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:135: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo conflicts.at:135 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:135"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:135: bison -o input.c --report=all input.y"
echo conflicts.at:135 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c --report=all input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c --report=all input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y: conflicts: 1 shift/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:135"

$at_failed && at_func_log_failure
$at_traceon; }


# Check the contents of the report.
{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:140: cat input.output"
echo conflicts.at:140 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat input.output ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat input.output ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "State 5 conflicts: 1 shift/reduce


Grammar

    0 \$accept: exp \$end

    1 exp: exp OP exp
    2    | NUM


Terminals, with rules where they appear

\$end (0) 0
error (256)
NUM (258) 2
OP (259) 1


Nonterminals, with rules where they appear

\$accept (5)
    on left: 0
exp (6)
    on left: 1 2, on right: 0 1


state 0

    0 \$accept: . exp \$end
    1 exp: . exp OP exp
    2    | . NUM

    NUM  shift, and go to state 1

    exp  go to state 2


state 1

    2 exp: NUM .

    \$default  reduce using rule 2 (exp)


state 2

    0 \$accept: exp . \$end
    1 exp: exp . OP exp

    \$end  shift, and go to state 3
    OP    shift, and go to state 4


state 3

    0 \$accept: exp \$end .

    \$default  accept


state 4

    1 exp: . exp OP exp
    1    | exp OP . exp
    2    | . NUM

    NUM  shift, and go to state 1

    exp  go to state 5


state 5

    1 exp: exp . OP exp
    1    | exp OP exp .  [\$end, OP]

    OP  shift, and go to state 4

    OP        [reduce using rule 1 (exp)]
    \$default  reduce using rule 1 (exp)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:140"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_103
#AT_START_104
# 104. conflicts.at:232: Resolved SR Conflicts
at_setup_line='conflicts.at:232'
at_func_banner 9
at_desc="Resolved SR Conflicts"
$at_quiet $as_echo_n "104: $at_desc                          "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "104. conflicts.at:232: testing ..."
  $at_traceon




cat >input.y <<'_ATEOF'
%token NUM OP
%left OP
%%
exp: exp OP exp | NUM;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:243: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c --report=all input.y"
echo conflicts.at:243 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c --report=all input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c --report=all input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:243"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:243: bison --xml=xml-tests/test.xml -o input.c --report=all input.y"
echo conflicts.at:243 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c --report=all input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c --report=all input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:243"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:243: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo conflicts.at:243 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:243"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:243: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo conflicts.at:243 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:243"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:243: bison -o input.c --report=all input.y"
echo conflicts.at:243 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c --report=all input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c --report=all input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:243"

$at_failed && at_func_log_failure
$at_traceon; }


# Check the contents of the report.
{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:246: cat input.output"
echo conflicts.at:246 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat input.output ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat input.output ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Grammar

    0 \$accept: exp \$end

    1 exp: exp OP exp
    2    | NUM


Terminals, with rules where they appear

\$end (0) 0
error (256)
NUM (258) 2
OP (259) 1


Nonterminals, with rules where they appear

\$accept (5)
    on left: 0
exp (6)
    on left: 1 2, on right: 0 1


state 0

    0 \$accept: . exp \$end
    1 exp: . exp OP exp
    2    | . NUM

    NUM  shift, and go to state 1

    exp  go to state 2


state 1

    2 exp: NUM .

    \$default  reduce using rule 2 (exp)


state 2

    0 \$accept: exp . \$end
    1 exp: exp . OP exp

    \$end  shift, and go to state 3
    OP    shift, and go to state 4


state 3

    0 \$accept: exp \$end .

    \$default  accept


state 4

    1 exp: . exp OP exp
    1    | exp OP . exp
    2    | . NUM

    NUM  shift, and go to state 1

    exp  go to state 5


state 5

    1 exp: exp . OP exp
    1    | exp OP exp .  [\$end, OP]

    \$default  reduce using rule 1 (exp)

    Conflict between rule 1 and token OP resolved as reduce (%left OP).
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:246"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_104
#AT_START_105
# 105. conflicts.at:354: Defaulted Conflicted Reduction
at_setup_line='conflicts.at:354'
at_func_banner 9
at_desc="Defaulted Conflicted Reduction"
$at_quiet $as_echo_n "105: $at_desc                 "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "105. conflicts.at:354: testing ..."
  $at_traceon



cat >input.y <<'_ATEOF'
%%
exp: num | id;
num: '0';
id : '0';
%%
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:365: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c --report=all input.y"
echo conflicts.at:365 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c --report=all input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c --report=all input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:365"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:365: bison --xml=xml-tests/test.xml -o input.c --report=all input.y"
echo conflicts.at:365 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c --report=all input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c --report=all input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:365"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:365: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo conflicts.at:365 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:365"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:365: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo conflicts.at:365 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:365"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:365: bison -o input.c --report=all input.y"
echo conflicts.at:365 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c --report=all input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c --report=all input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y: conflicts: 1 reduce/reduce
input.y:4.6-8: warning: rule useless in parser due to conflicts: id: '0'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:365"

$at_failed && at_func_log_failure
$at_traceon; }


# Check the contents of the report.
{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:371: cat input.output"
echo conflicts.at:371 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat input.output ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat input.output ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Rules useless in parser due to conflicts

    4 id: '0'


State 1 conflicts: 1 reduce/reduce


Grammar

    0 \$accept: exp \$end

    1 exp: num
    2    | id

    3 num: '0'

    4 id: '0'


Terminals, with rules where they appear

\$end (0) 0
'0' (48) 3 4
error (256)


Nonterminals, with rules where they appear

\$accept (4)
    on left: 0
exp (5)
    on left: 1 2, on right: 0
num (6)
    on left: 3, on right: 1
id (7)
    on left: 4, on right: 2


state 0

    0 \$accept: . exp \$end
    1 exp: . num
    2    | . id
    3 num: . '0'
    4 id: . '0'

    '0'  shift, and go to state 1

    exp  go to state 2
    num  go to state 3
    id   go to state 4


state 1

    3 num: '0' .  [\$end]
    4 id: '0' .  [\$end]

    \$end      reduce using rule 3 (num)
    \$end      [reduce using rule 4 (id)]
    \$default  reduce using rule 3 (num)


state 2

    0 \$accept: exp . \$end

    \$end  shift, and go to state 5


state 3

    1 exp: num .

    \$default  reduce using rule 1 (exp)


state 4

    2 exp: id .

    \$default  reduce using rule 2 (exp)


state 5

    0 \$accept: exp \$end .

    \$default  accept
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:371"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_105
#AT_START_106
# 106. conflicts.at:473: %expect not enough
at_setup_line='conflicts.at:473'
at_func_banner 9
at_desc="%expect not enough"
$at_quiet $as_echo_n "106: $at_desc                             "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "106. conflicts.at:473: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%token NUM OP
%expect 0
%%
exp: exp OP exp | NUM;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:482: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o input.c input.y"
echo conflicts.at:482 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o input.c input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y: conflicts: 1 shift/reduce
input.y: expected 0 shift/reduce conflicts
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/conflicts.at:482"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_106
#AT_START_107
# 107. conflicts.at:493: %expect right
at_setup_line='conflicts.at:493'
at_func_banner 9
at_desc="%expect right"
$at_quiet $as_echo_n "107: $at_desc                                  "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "107. conflicts.at:493: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%token NUM OP
%expect 1
%%
exp: exp OP exp | NUM;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:502: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo conflicts.at:502 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:502"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:502: bison --xml=xml-tests/test.xml -o input.c input.y"
echo conflicts.at:502 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:502"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:502: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo conflicts.at:502 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:502"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:502: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo conflicts.at:502 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:502"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:502: bison -o input.c input.y"
echo conflicts.at:502 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:502"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_107
#AT_START_108
# 108. conflicts.at:510: %expect too much
at_setup_line='conflicts.at:510'
at_func_banner 9
at_desc="%expect too much"
$at_quiet $as_echo_n "108: $at_desc                               "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "108. conflicts.at:510: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%token NUM OP
%expect 2
%%
exp: exp OP exp | NUM;
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:519: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o input.c input.y"
echo conflicts.at:519 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o input.c input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y: conflicts: 1 shift/reduce
input.y: expected 2 shift/reduce conflicts
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/conflicts.at:519"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_108
#AT_START_109
# 109. conflicts.at:530: %expect with reduce conflicts
at_setup_line='conflicts.at:530'
at_func_banner 9
at_desc="%expect with reduce conflicts"
$at_quiet $as_echo_n "109: $at_desc                  "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "109. conflicts.at:530: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%expect 0
%%
program: a 'a' | a a;
a: 'a';
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:539: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o input.c input.y"
echo conflicts.at:539 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o input.c input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y: conflicts: 1 reduce/reduce
input.y: expected 0 reduce/reduce conflicts
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/conflicts.at:539"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_109
#AT_START_110
# 110. conflicts.at:550: %no-default-prec without %prec
at_setup_line='conflicts.at:550'
at_func_banner 9
at_desc="%no-default-prec without %prec"
$at_quiet $as_echo_n "110: $at_desc                 "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "110. conflicts.at:550: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%left '+'
%left '*'

%%

%no-default-prec;

e:   e '+' e
   | e '*' e
   | '0'
   ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:566: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo conflicts.at:566 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:566"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:566: bison --xml=xml-tests/test.xml -o input.c input.y"
echo conflicts.at:566 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:566"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:566: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo conflicts.at:566 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:566"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:566: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo conflicts.at:566 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:566"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:566: bison -o input.c input.y"
echo conflicts.at:566 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y: conflicts: 4 shift/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:566"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_110
#AT_START_111
# 111. conflicts.at:576: %no-default-prec with %prec
at_setup_line='conflicts.at:576'
at_func_banner 9
at_desc="%no-default-prec with %prec"
$at_quiet $as_echo_n "111: $at_desc                    "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "111. conflicts.at:576: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%left '+'
%left '*'

%%

%no-default-prec;

e:   e '+' e %prec '+'
   | e '*' e %prec '*'
   | '0'
   ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:592: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo conflicts.at:592 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:592"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:592: bison --xml=xml-tests/test.xml -o input.c input.y"
echo conflicts.at:592 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:592"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:592: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo conflicts.at:592 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:592"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:592: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo conflicts.at:592 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:592"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:592: bison -o input.c input.y"
echo conflicts.at:592 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:592"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_111
#AT_START_112
# 112. conflicts.at:600: %default-prec
at_setup_line='conflicts.at:600'
at_func_banner 9
at_desc="%default-prec"
$at_quiet $as_echo_n "112: $at_desc                                  "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "112. conflicts.at:600: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%left '+'
%left '*'

%%

%default-prec;

e:   e '+' e
   | e '*' e
   | '0'
   ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:616: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo conflicts.at:616 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:616"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:616: bison --xml=xml-tests/test.xml -o input.c input.y"
echo conflicts.at:616 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:616"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:616: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo conflicts.at:616 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:616"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:616: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo conflicts.at:616 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:616"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:616: bison -o input.c input.y"
echo conflicts.at:616 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:616"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_112
#AT_START_113
# 113. conflicts.at:624: Unreachable States After Conflict Resolution
at_setup_line='conflicts.at:624'
at_func_banner 9
at_desc="Unreachable States After Conflict Resolution"
$at_quiet $as_echo_n "113: $at_desc   "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "113. conflicts.at:624: testing ..."
  $at_traceon


# If conflict resolution makes states unreachable, remove those states, report
# rules that are then unused, and don't report conflicts in those states.  Test
# what happens when a nonterminal becomes useless as a result of state removal
# since that causes lalr.o's goto map to be rewritten.

cat >input.y <<'_ATEOF'
%output "input.c"
%left 'a'

%%

start: resolved_conflict 'a' reported_conflicts 'a' ;

/* S/R conflict resolved as reduce, so the state with item
 * (resolved_conflict: 'a' . unreachable1) and all it transition successors are
 * unreachable, and the associated production is useless.  */
resolved_conflict:
    'a' unreachable1
  | %prec 'a'
  ;

/* S/R conflict that need not be reported since it is unreachable because of
 * the previous conflict resolution.  Nonterminal unreachable1 and all its
 * productions are useless.  */
unreachable1:
    'a' unreachable2
  |
  ;

/* Likewise for a R/R conflict and nonterminal unreachable2.  */
unreachable2: | ;

/* Make sure remaining S/R and R/R conflicts are still reported correctly even
 * when their states are renumbered due to state removal.  */
reported_conflicts:
    'a'
  | 'a'
  |
  ;

_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:668: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all input.y"
echo conflicts.at:668 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:668"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:668: bison --xml=xml-tests/test.xml --report=all input.y"
echo conflicts.at:668 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml --report=all input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml --report=all input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:668"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:668: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo conflicts.at:668 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:668"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:668: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo conflicts.at:668 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:668"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:668: bison --report=all input.y"
echo conflicts.at:668 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --report=all input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y: conflicts: 1 shift/reduce, 1 reduce/reduce
input.y:12.5-20: warning: rule useless in parser due to conflicts: resolved_conflict: 'a' unreachable1
input.y:20.5-20: warning: rule useless in parser due to conflicts: unreachable1: 'a' unreachable2
input.y:21.4: warning: rule useless in parser due to conflicts: unreachable1: /* empty */
input.y:25.13: warning: rule useless in parser due to conflicts: unreachable2: /* empty */
input.y:25.16: warning: rule useless in parser due to conflicts: unreachable2: /* empty */
input.y:31.5-7: warning: rule useless in parser due to conflicts: reported_conflicts: 'a'
input.y:32.4: warning: rule useless in parser due to conflicts: reported_conflicts: /* empty */
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:668"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:679: cat input.output"
echo conflicts.at:679 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat input.output ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat input.output ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Rules useless in parser due to conflicts

    2 resolved_conflict: 'a' unreachable1

    4 unreachable1: 'a' unreachable2
    5             | /* empty */

    6 unreachable2: /* empty */
    7             | /* empty */

    9 reported_conflicts: 'a'
   10                   | /* empty */


State 4 conflicts: 1 shift/reduce
State 5 conflicts: 1 reduce/reduce


Grammar

    0 \$accept: start \$end

    1 start: resolved_conflict 'a' reported_conflicts 'a'

    2 resolved_conflict: 'a' unreachable1
    3                  | /* empty */

    4 unreachable1: 'a' unreachable2
    5             | /* empty */

    6 unreachable2: /* empty */
    7             | /* empty */

    8 reported_conflicts: 'a'
    9                   | 'a'
   10                   | /* empty */


Terminals, with rules where they appear

\$end (0) 0
'a' (97) 1 2 4 8 9
error (256)


Nonterminals, with rules where they appear

\$accept (4)
    on left: 0
start (5)
    on left: 1, on right: 0
resolved_conflict (6)
    on left: 2 3, on right: 1
unreachable1 (7)
    on left: 4 5, on right: 2
unreachable2 (8)
    on left: 6 7, on right: 4
reported_conflicts (9)
    on left: 8 9 10, on right: 1


state 0

    0 \$accept: . start \$end
    1 start: . resolved_conflict 'a' reported_conflicts 'a'
    2 resolved_conflict: . 'a' unreachable1
    3                  | .  ['a']

    \$default  reduce using rule 3 (resolved_conflict)

    start              go to state 1
    resolved_conflict  go to state 2

    Conflict between rule 3 and token 'a' resolved as reduce (%left 'a').


state 1

    0 \$accept: start . \$end

    \$end  shift, and go to state 3


state 2

    1 start: resolved_conflict . 'a' reported_conflicts 'a'

    'a'  shift, and go to state 4


state 3

    0 \$accept: start \$end .

    \$default  accept


state 4

    1 start: resolved_conflict 'a' . reported_conflicts 'a'
    8 reported_conflicts: . 'a'
    9                   | . 'a'
   10                   | .  ['a']

    'a'  shift, and go to state 5

    'a'  [reduce using rule 10 (reported_conflicts)]

    reported_conflicts  go to state 6


state 5

    8 reported_conflicts: 'a' .  ['a']
    9                   | 'a' .  ['a']

    'a'       reduce using rule 8 (reported_conflicts)
    'a'       [reduce using rule 9 (reported_conflicts)]
    \$default  reduce using rule 8 (reported_conflicts)


state 6

    1 start: resolved_conflict 'a' reported_conflicts . 'a'

    'a'  shift, and go to state 7


state 7

    1 start: resolved_conflict 'a' reported_conflicts 'a' .

    \$default  reduce using rule 1 (start)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:679"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input-keep.y <<'_ATEOF'
%define lr.keep_unreachable_states
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:818: cat input.y >> input-keep.y"
echo conflicts.at:818 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat input.y >> input-keep.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat input.y >> input-keep.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:818"

$at_failed && at_func_log_failure
$at_traceon; }


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:820: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input-keep.y"
echo conflicts.at:820 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input-keep.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input-keep.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:820"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:820: bison --xml=xml-tests/test.xml input-keep.y"
echo conflicts.at:820 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml input-keep.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml input-keep.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:820"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:820: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo conflicts.at:820 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:820"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:820: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo conflicts.at:820 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:820"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:820: bison input-keep.y"
echo conflicts.at:820 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison input-keep.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison input-keep.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input-keep.y: conflicts: 2 shift/reduce, 2 reduce/reduce
input-keep.y:22.4: warning: rule useless in parser due to conflicts: unreachable1: /* empty */
input-keep.y:26.16: warning: rule useless in parser due to conflicts: unreachable2: /* empty */
input-keep.y:32.5-7: warning: rule useless in parser due to conflicts: reported_conflicts: 'a'
input-keep.y:33.4: warning: rule useless in parser due to conflicts: reported_conflicts: /* empty */
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:820"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_113
#AT_START_114
# 114. conflicts.at:835: Solved conflicts report for multiple reductions in a state
at_setup_line='conflicts.at:835'
at_func_banner 9
at_desc="Solved conflicts report for multiple reductions in a state"
$at_quiet $as_echo_n "114: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "114. conflicts.at:835: testing ..."
  $at_traceon


# Used to lose earlier solved conflict messages even within a single S/R/R.

cat >input.y <<'_ATEOF'
%left 'a'
%right 'b'
%right 'c'
%right 'd'
%%
start:
    'a'
  | empty_a 'a'
  | 'b'
  | empty_b 'b'
  | 'c'
  | empty_c1 'c'
  | empty_c2 'c'
  | empty_c3 'c'
  ;
empty_a: %prec 'a' ;
empty_b: %prec 'b' ;
empty_c1: %prec 'c' ;
empty_c2: %prec 'c' ;
empty_c3: %prec 'd' ;
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:861: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all -o input.c input.y"
echo conflicts.at:861 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:861"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:861: bison --xml=xml-tests/test.xml --report=all -o input.c input.y"
echo conflicts.at:861 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml --report=all -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml --report=all -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:861"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:861: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo conflicts.at:861 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:861"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:861: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo conflicts.at:861 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:861"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:861: bison --report=all -o input.c input.y"
echo conflicts.at:861 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --report=all -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:861"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:862: cat input.output | sed -n '/^state 0\$/,/^state 1\$/p'"
echo conflicts.at:862 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "cat input.output | sed -n '/^state 0$/,/^state 1$/p'"; then
  ( $at_traceon; cat input.output | sed -n '/^state 0$/,/^state 1$/p' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat input.output | sed -n '/^state 0$/,/^state 1$/p' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "state 0

    0 \$accept: . start \$end
    1 start: . 'a'
    2      | . empty_a 'a'
    3      | . 'b'
    4      | . empty_b 'b'
    5      | . 'c'
    6      | . empty_c1 'c'
    7      | . empty_c2 'c'
    8      | . empty_c3 'c'
    9 empty_a: .  ['a']
   10 empty_b: .  []
   11 empty_c1: .  []
   12 empty_c2: .  []
   13 empty_c3: .  ['c']

    'b'  shift, and go to state 1

    'c'       reduce using rule 13 (empty_c3)
    \$default  reduce using rule 9 (empty_a)

    start     go to state 2
    empty_a   go to state 3
    empty_b   go to state 4
    empty_c1  go to state 5
    empty_c2  go to state 6
    empty_c3  go to state 7

    Conflict between rule 9 and token 'a' resolved as reduce (%left 'a').
    Conflict between rule 10 and token 'b' resolved as shift (%right 'b').
    Conflict between rule 11 and token 'c' resolved as shift (%right 'c').
    Conflict between rule 12 and token 'c' resolved as shift (%right 'c').
    Conflict between rule 13 and token 'c' resolved as reduce ('c' < 'd').


state 1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:862"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_114
#AT_START_115
# 115. conflicts.at:915: %nonassoc error actions for multiple reductions in a state
at_setup_line='conflicts.at:915'
at_func_banner 9
at_desc="%nonassoc error actions for multiple reductions in a state"
$at_quiet $as_echo_n "115: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "115. conflicts.at:915: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%nonassoc 'a' 'b' 'c'
%%
start:
    'a'
  | empty_a 'a'
  | 'b'
  | empty_b 'b'
  | 'c'
  | empty_c1 'c'
  | empty_c2 'c'
  | empty_c3 'c'
  ;
empty_a: %prec 'a' ;
empty_b: %prec 'b' ;
empty_c1: %prec 'c' ;
empty_c2: %prec 'c' ;
empty_c3: %prec 'c' ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:937: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all -o input.c input.y"
echo conflicts.at:937 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:937"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:937: bison --xml=xml-tests/test.xml --report=all -o input.c input.y"
echo conflicts.at:937 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml --report=all -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml --report=all -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:937"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:937: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo conflicts.at:937 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:937"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/conflicts.at:937: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo conflicts.at:937 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:937"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:937: bison --report=all -o input.c input.y"
echo conflicts.at:937 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --report=all -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:937"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/conflicts.at:938: cat input.output | sed -n '/^state 0\$/,/^state 1\$/p'"
echo conflicts.at:938 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "cat input.output | sed -n '/^state 0$/,/^state 1$/p'"; then
  ( $at_traceon; cat input.output | sed -n '/^state 0$/,/^state 1$/p' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat input.output | sed -n '/^state 0$/,/^state 1$/p' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "state 0

    0 \$accept: . start \$end
    1 start: . 'a'
    2      | . empty_a 'a'
    3      | . 'b'
    4      | . empty_b 'b'
    5      | . 'c'
    6      | . empty_c1 'c'
    7      | . empty_c2 'c'
    8      | . empty_c3 'c'
    9 empty_a: .  []
   10 empty_b: .  []
   11 empty_c1: .  []
   12 empty_c2: .  ['c']
   13 empty_c3: .  ['c']

    'a'  error (nonassociative)
    'b'  error (nonassociative)
    'c'  error (nonassociative)

    'c'  [reduce using rule 12 (empty_c2)]
    'c'  [reduce using rule 13 (empty_c3)]

    start     go to state 1
    empty_a   go to state 2
    empty_b   go to state 3
    empty_c1  go to state 4
    empty_c2  go to state 5
    empty_c3  go to state 6

    Conflict between rule 9 and token 'a' resolved as an error (%nonassoc 'a').
    Conflict between rule 10 and token 'b' resolved as an error (%nonassoc 'b').
    Conflict between rule 11 and token 'c' resolved as an error (%nonassoc 'c').


state 1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/conflicts.at:938"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_115
#AT_START_116
# 116. calc.at:569: Calculator
at_setup_line='calc.at:569'
at_func_banner 10
at_desc="Calculator "
$at_quiet $as_echo_n "116: $at_desc                                    "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "116. calc.at:569: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */


%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = get_char ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:569: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:569 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:569"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:569: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:569 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:569"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:569: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:569 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:569"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:569: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:569 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:569"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:569: bison -o calc.c calc.y"
echo calc.at:569 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:569"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:569: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
echo calc.at:569 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:569"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:569:  \$PREPARSER ./calc input"
echo calc.at:569 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:569"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:569:  \$PREPARSER ./calc input"
echo calc.at:569 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:569"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:569: cat stderr"
echo calc.at:569 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:569"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:569:  \$PREPARSER ./calc input"
echo calc.at:569 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:569"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:569: cat stderr"
echo calc.at:569 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:569"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:569:  \$PREPARSER ./calc input"
echo calc.at:569 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:569"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:569: cat stderr"
echo calc.at:569 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:569"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:569:  \$PREPARSER ./calc input"
echo calc.at:569 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:569"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:569: cat stderr"
echo calc.at:569 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:569"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:569:  \$PREPARSER ./calc input"
echo calc.at:569 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:569"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:569: cat stderr"
echo calc.at:569 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:569"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:569:  \$PREPARSER ./calc input"
echo calc.at:569 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:569"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:569: cat stderr"
echo calc.at:569 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:569"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:569:  \$PREPARSER ./calc input"
echo calc.at:569 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:569"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:569: cat stderr"
echo calc.at:569 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:569"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:569:  \$PREPARSER ./calc input"
echo calc.at:569 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:569"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:569: cat stderr"
echo calc.at:569 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:569"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:569:  \$PREPARSER ./calc input"
echo calc.at:569 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:569"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:569: cat stderr"
echo calc.at:569 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:569"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:569:  \$PREPARSER ./calc input"
echo calc.at:569 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:569"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:569: cat stderr"
echo calc.at:569 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:569"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_116
#AT_START_117
# 117. calc.at:571: Calculator %defines
at_setup_line='calc.at:571'
at_func_banner 10
at_desc="Calculator %defines"
$at_quiet $as_echo_n "117: $at_desc                            "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "117. calc.at:571: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%defines

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}



static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.c <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.h"

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = get_char ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:571: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:571 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:571"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:571: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:571 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:571"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:571: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:571 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:571"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:571: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:571 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:571"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:571: bison -o calc.c calc.y"
echo calc.at:571 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:571"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:571: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c calc-lex.c \$LIBS"
echo calc.at:571 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:571"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:571:  \$PREPARSER ./calc input"
echo calc.at:571 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:571"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:571:  \$PREPARSER ./calc input"
echo calc.at:571 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:571"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:571: cat stderr"
echo calc.at:571 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:571"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:571:  \$PREPARSER ./calc input"
echo calc.at:571 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:571"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:571: cat stderr"
echo calc.at:571 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:571"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:571:  \$PREPARSER ./calc input"
echo calc.at:571 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:571"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:571: cat stderr"
echo calc.at:571 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:571"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:571:  \$PREPARSER ./calc input"
echo calc.at:571 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:571"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:571: cat stderr"
echo calc.at:571 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:571"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:571:  \$PREPARSER ./calc input"
echo calc.at:571 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:571"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:571: cat stderr"
echo calc.at:571 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:571"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:571:  \$PREPARSER ./calc input"
echo calc.at:571 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:571"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:571: cat stderr"
echo calc.at:571 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:571"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:571:  \$PREPARSER ./calc input"
echo calc.at:571 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:571"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:571: cat stderr"
echo calc.at:571 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:571"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:571:  \$PREPARSER ./calc input"
echo calc.at:571 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:571"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:571: cat stderr"
echo calc.at:571 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:571"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:571:  \$PREPARSER ./calc input"
echo calc.at:571 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:571"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:571: cat stderr"
echo calc.at:571 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:571"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:571:  \$PREPARSER ./calc input"
echo calc.at:571 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:571"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:571: cat stderr"
echo calc.at:571 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:571"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_117
#AT_START_118
# 118. calc.at:572: Calculator %locations
at_setup_line='calc.at:572'
at_func_banner 10
at_desc="Calculator %locations"
$at_quiet $as_echo_n "118: $at_desc                          "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "118. calc.at:572: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%locations

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (yylloc).first_line, (yylloc).first_column);
  if ((yylloc).first_line != (yylloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (yylloc).last_line,  (yylloc).last_column - 1);
  else if ((yylloc).first_column != (yylloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (yylloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static YYLTYPE last_yylloc;

static int
get_char (void)
{
  int res = getc (input);
  ;

  last_yylloc = (yylloc);
  if (res == '\n')
    {
      (yylloc).last_line++;
      (yylloc).last_column = 1;
    }
  else
    (yylloc).last_column++;

  return res;
}

static void
unget_char ( int c)
{
  ;

  /* Wrong when C == `\n'. */
  (yylloc) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (yylloc).last_column = 1;
      (yylloc).last_line = 1;

    }


 (yylloc).first_column = (yylloc).last_column;
  (yylloc).first_line   = (yylloc).last_line;


  /* Skip white space.  */
  while ((c = get_char ()) == ' ' || c == '\t')
    {
     (yylloc).first_column = (yylloc).last_column;
      (yylloc).first_line   = (yylloc).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:572: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:572 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:572"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:572: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:572 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:572"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:572: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:572 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:572"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:572: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:572 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:572"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:572: bison -o calc.c calc.y"
echo calc.at:572 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:572"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:572: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
echo calc.at:572 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:572"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:572:  \$PREPARSER ./calc input"
echo calc.at:572 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:572"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:572:  \$PREPARSER ./calc input"
echo calc.at:572 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:572"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:572: cat stderr"
echo calc.at:572 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:572"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:572:  \$PREPARSER ./calc input"
echo calc.at:572 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:572"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:572: cat stderr"
echo calc.at:572 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:572"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:572:  \$PREPARSER ./calc input"
echo calc.at:572 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:572"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:572: cat stderr"
echo calc.at:572 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:572"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:572:  \$PREPARSER ./calc input"
echo calc.at:572 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:572"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:572: cat stderr"
echo calc.at:572 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:572"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:572:  \$PREPARSER ./calc input"
echo calc.at:572 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:572"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:572: cat stderr"
echo calc.at:572 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:572"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:572:  \$PREPARSER ./calc input"
echo calc.at:572 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:572"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:572: cat stderr"
echo calc.at:572 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:572"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:572:  \$PREPARSER ./calc input"
echo calc.at:572 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:572"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:572: cat stderr"
echo calc.at:572 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:572"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:572:  \$PREPARSER ./calc input"
echo calc.at:572 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:572"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:572: cat stderr"
echo calc.at:572 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:572"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:572:  \$PREPARSER ./calc input"
echo calc.at:572 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:572"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:572: cat stderr"
echo calc.at:572 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:572"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:572:  \$PREPARSER ./calc input"
echo calc.at:572 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:572"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:572: cat stderr"
echo calc.at:572 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:572"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_118
#AT_START_119
# 119. calc.at:573: Calculator %name-prefix="calc"
at_setup_line='calc.at:573'
at_func_banner 10
at_desc="Calculator %name-prefix=\"calc\""
$at_quiet $as_echo_n "119: $at_desc                 "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "119. calc.at:573: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%name-prefix="calc"

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = get_char ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:573: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:573 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:573"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:573: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:573 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:573"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:573: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:573 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:573"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:573: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:573 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:573"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:573: bison -o calc.c calc.y"
echo calc.at:573 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:573"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:573: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
echo calc.at:573 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:573"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:573:  \$PREPARSER ./calc input"
echo calc.at:573 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:573"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:573:  \$PREPARSER ./calc input"
echo calc.at:573 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:573"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:573: cat stderr"
echo calc.at:573 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:573"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:573:  \$PREPARSER ./calc input"
echo calc.at:573 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:573"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:573: cat stderr"
echo calc.at:573 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:573"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:573:  \$PREPARSER ./calc input"
echo calc.at:573 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:573"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:573: cat stderr"
echo calc.at:573 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:573"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:573:  \$PREPARSER ./calc input"
echo calc.at:573 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:573"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:573: cat stderr"
echo calc.at:573 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:573"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:573:  \$PREPARSER ./calc input"
echo calc.at:573 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:573"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:573: cat stderr"
echo calc.at:573 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:573"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:573:  \$PREPARSER ./calc input"
echo calc.at:573 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:573"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:573: cat stderr"
echo calc.at:573 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:573"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:573:  \$PREPARSER ./calc input"
echo calc.at:573 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:573"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:573: cat stderr"
echo calc.at:573 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:573"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:573:  \$PREPARSER ./calc input"
echo calc.at:573 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:573"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:573: cat stderr"
echo calc.at:573 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:573"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:573:  \$PREPARSER ./calc input"
echo calc.at:573 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:573"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:573: cat stderr"
echo calc.at:573 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:573"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:573:  \$PREPARSER ./calc input"
echo calc.at:573 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:573"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:573: cat stderr"
echo calc.at:573 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:573"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_119
#AT_START_120
# 120. calc.at:574: Calculator %verbose
at_setup_line='calc.at:574'
at_func_banner 10
at_desc="Calculator %verbose"
$at_quiet $as_echo_n "120: $at_desc                            "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "120. calc.at:574: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%verbose

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = get_char ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:574: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:574 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:574"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:574: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:574 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:574"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:574: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:574 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:574"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:574: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:574 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:574"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:574: bison -o calc.c calc.y"
echo calc.at:574 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:574"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:574: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
echo calc.at:574 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:574"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:574:  \$PREPARSER ./calc input"
echo calc.at:574 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:574"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:574:  \$PREPARSER ./calc input"
echo calc.at:574 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:574"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:574: cat stderr"
echo calc.at:574 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:574"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:574:  \$PREPARSER ./calc input"
echo calc.at:574 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:574"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:574: cat stderr"
echo calc.at:574 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:574"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:574:  \$PREPARSER ./calc input"
echo calc.at:574 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:574"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:574: cat stderr"
echo calc.at:574 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:574"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:574:  \$PREPARSER ./calc input"
echo calc.at:574 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:574"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:574: cat stderr"
echo calc.at:574 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:574"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:574:  \$PREPARSER ./calc input"
echo calc.at:574 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:574"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:574: cat stderr"
echo calc.at:574 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:574"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:574:  \$PREPARSER ./calc input"
echo calc.at:574 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:574"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:574: cat stderr"
echo calc.at:574 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:574"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:574:  \$PREPARSER ./calc input"
echo calc.at:574 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:574"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:574: cat stderr"
echo calc.at:574 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:574"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:574:  \$PREPARSER ./calc input"
echo calc.at:574 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:574"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:574: cat stderr"
echo calc.at:574 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:574"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:574:  \$PREPARSER ./calc input"
echo calc.at:574 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:574"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:574: cat stderr"
echo calc.at:574 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:574"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:574:  \$PREPARSER ./calc input"
echo calc.at:574 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:574"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:574: cat stderr"
echo calc.at:574 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:574"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_120
#AT_START_121
# 121. calc.at:575: Calculator %yacc
at_setup_line='calc.at:575'
at_func_banner 10
at_desc="Calculator %yacc"
$at_quiet $as_echo_n "121: $at_desc                               "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "121. calc.at:575: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%yacc

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = get_char ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:575: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:575 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:575"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:575: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:575 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:575"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:575: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:575 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:575"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:575: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:575 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:575"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:575: bison -o calc.c calc.y"
echo calc.at:575 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:575"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:575: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
echo calc.at:575 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:575"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:575:  \$PREPARSER ./calc input"
echo calc.at:575 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:575"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:575:  \$PREPARSER ./calc input"
echo calc.at:575 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:575"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:575: cat stderr"
echo calc.at:575 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:575"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:575:  \$PREPARSER ./calc input"
echo calc.at:575 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:575"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:575: cat stderr"
echo calc.at:575 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:575"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:575:  \$PREPARSER ./calc input"
echo calc.at:575 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:575"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:575: cat stderr"
echo calc.at:575 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:575"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:575:  \$PREPARSER ./calc input"
echo calc.at:575 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:575"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:575: cat stderr"
echo calc.at:575 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:575"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:575:  \$PREPARSER ./calc input"
echo calc.at:575 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:575"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:575: cat stderr"
echo calc.at:575 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:575"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:575:  \$PREPARSER ./calc input"
echo calc.at:575 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:575"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:575: cat stderr"
echo calc.at:575 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:575"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:575:  \$PREPARSER ./calc input"
echo calc.at:575 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:575"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:575: cat stderr"
echo calc.at:575 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:575"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:575:  \$PREPARSER ./calc input"
echo calc.at:575 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:575"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:575: cat stderr"
echo calc.at:575 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:575"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:575:  \$PREPARSER ./calc input"
echo calc.at:575 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:575"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:575: cat stderr"
echo calc.at:575 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:575"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:575:  \$PREPARSER ./calc input"
echo calc.at:575 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:575"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:575: cat stderr"
echo calc.at:575 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:575"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_121
#AT_START_122
# 122. calc.at:576: Calculator %error-verbose
at_setup_line='calc.at:576'
at_func_banner 10
at_desc="Calculator %error-verbose"
$at_quiet $as_echo_n "122: $at_desc                      "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "122. calc.at:576: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%error-verbose

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = get_char ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:576: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:576 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:576"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:576: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:576 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:576"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:576: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:576 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:576"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:576: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:576 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:576"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:576: bison -o calc.c calc.y"
echo calc.at:576 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:576"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:576: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
echo calc.at:576 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:576"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:576:  \$PREPARSER ./calc input"
echo calc.at:576 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:576"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:576:  \$PREPARSER ./calc input"
echo calc.at:576 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:576"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:576: cat stderr"
echo calc.at:576 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:576"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:576:  \$PREPARSER ./calc input"
echo calc.at:576 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:576"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:576: cat stderr"
echo calc.at:576 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:576"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:576:  \$PREPARSER ./calc input"
echo calc.at:576 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:576"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:576: cat stderr"
echo calc.at:576 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:576"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:576:  \$PREPARSER ./calc input"
echo calc.at:576 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:576"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:576: cat stderr"
echo calc.at:576 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:576"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:576:  \$PREPARSER ./calc input"
echo calc.at:576 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:576"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:576: cat stderr"
echo calc.at:576 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:576"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:576:  \$PREPARSER ./calc input"
echo calc.at:576 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:576"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:576: cat stderr"
echo calc.at:576 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:576"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:576:  \$PREPARSER ./calc input"
echo calc.at:576 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:576"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:576: cat stderr"
echo calc.at:576 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:576"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:576:  \$PREPARSER ./calc input"
echo calc.at:576 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:576"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:576: cat stderr"
echo calc.at:576 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:576"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:576:  \$PREPARSER ./calc input"
echo calc.at:576 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:576"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:576: cat stderr"
echo calc.at:576 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:576"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:576:  \$PREPARSER ./calc input"
echo calc.at:576 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:576"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:576: cat stderr"
echo calc.at:576 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:576"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_122
#AT_START_123
# 123. calc.at:578: Calculator %define api.pure %locations
at_setup_line='calc.at:578'
at_func_banner 10
at_desc="Calculator %define api.pure %locations"
$at_quiet $as_echo_n "123: $at_desc         "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "123. calc.at:578: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%define api.pure %locations

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }


 (*llocp).first_column = (*llocp).last_column;
  (*llocp).first_line   = (*llocp).last_line;


  /* Skip white space.  */
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t')
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:578: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:578 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:578"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:578: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:578 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:578"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:578: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:578 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:578"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:578: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:578 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:578"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:578: bison -o calc.c calc.y"
echo calc.at:578 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:578"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:578: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
echo calc.at:578 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:578"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:578:  \$PREPARSER ./calc input"
echo calc.at:578 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:578"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:578:  \$PREPARSER ./calc input"
echo calc.at:578 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:578"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:578: cat stderr"
echo calc.at:578 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:578"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:578:  \$PREPARSER ./calc input"
echo calc.at:578 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:578"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:578: cat stderr"
echo calc.at:578 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:578"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:578:  \$PREPARSER ./calc input"
echo calc.at:578 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:578"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:578: cat stderr"
echo calc.at:578 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:578"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:578:  \$PREPARSER ./calc input"
echo calc.at:578 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:578"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:578: cat stderr"
echo calc.at:578 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:578"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:578:  \$PREPARSER ./calc input"
echo calc.at:578 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:578"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:578: cat stderr"
echo calc.at:578 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:578"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:578:  \$PREPARSER ./calc input"
echo calc.at:578 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:578"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:578: cat stderr"
echo calc.at:578 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:578"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:578:  \$PREPARSER ./calc input"
echo calc.at:578 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:578"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:578: cat stderr"
echo calc.at:578 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:578"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:578:  \$PREPARSER ./calc input"
echo calc.at:578 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:578"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:578: cat stderr"
echo calc.at:578 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:578"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:578:  \$PREPARSER ./calc input"
echo calc.at:578 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:578"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:578: cat stderr"
echo calc.at:578 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:578"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:578:  \$PREPARSER ./calc input"
echo calc.at:578 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:578"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:578: cat stderr"
echo calc.at:578 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:578"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_123
#AT_START_124
# 124. calc.at:579: Calculator %define api.push_pull "both" %define api.pure %locations
at_setup_line='calc.at:579'
at_func_banner 10
at_desc="Calculator %define api.push_pull \"both\" %define api.pure %locations"
$at_quiet $as_echo_n "124: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "124. calc.at:579: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%define api.push_pull "both" %define api.pure %locations

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }


 (*llocp).first_column = (*llocp).last_column;
  (*llocp).first_line   = (*llocp).last_line;


  /* Skip white space.  */
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t')
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:579: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:579 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:579"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:579: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:579 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:579"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:579: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:579 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:579"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:579: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:579 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:579"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:579: bison -o calc.c calc.y"
echo calc.at:579 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:579"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:579: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
echo calc.at:579 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:579"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:579:  \$PREPARSER ./calc input"
echo calc.at:579 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:579"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:579:  \$PREPARSER ./calc input"
echo calc.at:579 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:579"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:579: cat stderr"
echo calc.at:579 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:579"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:579:  \$PREPARSER ./calc input"
echo calc.at:579 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:579"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:579: cat stderr"
echo calc.at:579 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:579"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:579:  \$PREPARSER ./calc input"
echo calc.at:579 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:579"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:579: cat stderr"
echo calc.at:579 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:579"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:579:  \$PREPARSER ./calc input"
echo calc.at:579 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:579"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:579: cat stderr"
echo calc.at:579 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:579"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:579:  \$PREPARSER ./calc input"
echo calc.at:579 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:579"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:579: cat stderr"
echo calc.at:579 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:579"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:579:  \$PREPARSER ./calc input"
echo calc.at:579 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:579"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:579: cat stderr"
echo calc.at:579 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:579"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:579:  \$PREPARSER ./calc input"
echo calc.at:579 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:579"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:579: cat stderr"
echo calc.at:579 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:579"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:579:  \$PREPARSER ./calc input"
echo calc.at:579 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:579"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:579: cat stderr"
echo calc.at:579 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:579"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:579:  \$PREPARSER ./calc input"
echo calc.at:579 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:579"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:579: cat stderr"
echo calc.at:579 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:579"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:579:  \$PREPARSER ./calc input"
echo calc.at:579 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:579"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:579: cat stderr"
echo calc.at:579 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:579"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_124
#AT_START_125
# 125. calc.at:580: Calculator %error-verbose %locations
at_setup_line='calc.at:580'
at_func_banner 10
at_desc="Calculator %error-verbose %locations"
$at_quiet $as_echo_n "125: $at_desc           "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "125. calc.at:580: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%error-verbose %locations

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (yylloc).first_line, (yylloc).first_column);
  if ((yylloc).first_line != (yylloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (yylloc).last_line,  (yylloc).last_column - 1);
  else if ((yylloc).first_column != (yylloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (yylloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static YYLTYPE last_yylloc;

static int
get_char (void)
{
  int res = getc (input);
  ;

  last_yylloc = (yylloc);
  if (res == '\n')
    {
      (yylloc).last_line++;
      (yylloc).last_column = 1;
    }
  else
    (yylloc).last_column++;

  return res;
}

static void
unget_char ( int c)
{
  ;

  /* Wrong when C == `\n'. */
  (yylloc) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (yylloc).last_column = 1;
      (yylloc).last_line = 1;

    }


 (yylloc).first_column = (yylloc).last_column;
  (yylloc).first_line   = (yylloc).last_line;


  /* Skip white space.  */
  while ((c = get_char ()) == ' ' || c == '\t')
    {
     (yylloc).first_column = (yylloc).last_column;
      (yylloc).first_line   = (yylloc).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:580: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:580 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:580"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:580: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:580 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:580"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:580: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:580 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:580"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:580: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:580 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:580"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:580: bison -o calc.c calc.y"
echo calc.at:580 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:580"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:580: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
echo calc.at:580 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:580"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:580:  \$PREPARSER ./calc input"
echo calc.at:580 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:580"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:580:  \$PREPARSER ./calc input"
echo calc.at:580 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:580"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:580: cat stderr"
echo calc.at:580 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:580"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:580:  \$PREPARSER ./calc input"
echo calc.at:580 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:580"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:580: cat stderr"
echo calc.at:580 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:580"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:580:  \$PREPARSER ./calc input"
echo calc.at:580 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:580"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:580: cat stderr"
echo calc.at:580 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:580"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:580:  \$PREPARSER ./calc input"
echo calc.at:580 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:580"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:580: cat stderr"
echo calc.at:580 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:580"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:580:  \$PREPARSER ./calc input"
echo calc.at:580 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:580"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:580: cat stderr"
echo calc.at:580 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:580"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:580:  \$PREPARSER ./calc input"
echo calc.at:580 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:580"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:580: cat stderr"
echo calc.at:580 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:580"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:580:  \$PREPARSER ./calc input"
echo calc.at:580 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:580"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:580: cat stderr"
echo calc.at:580 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:580"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:580:  \$PREPARSER ./calc input"
echo calc.at:580 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:580"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:580: cat stderr"
echo calc.at:580 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:580"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:580:  \$PREPARSER ./calc input"
echo calc.at:580 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:580"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:580: cat stderr"
echo calc.at:580 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:580"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:580:  \$PREPARSER ./calc input"
echo calc.at:580 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:580"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:580: cat stderr"
echo calc.at:580 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:580"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_125
#AT_START_126
# 126. calc.at:582: Calculator %error-verbose %locations %defines %name-prefix "calc" %verbose %yacc
at_setup_line='calc.at:582'
at_func_banner 10
at_desc="Calculator %error-verbose %locations %defines %name-prefix \"calc\" %verbose %yacc"
$at_quiet $as_echo_n "126: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "126. calc.at:582: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%error-verbose %locations %defines %name-prefix "calc" %verbose %yacc

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (calclloc).first_line, (calclloc).first_column);
  if ((calclloc).first_line != (calclloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (calclloc).last_line,  (calclloc).last_column - 1);
  else if ((calclloc).first_column != (calclloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (calclloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.c <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.h"

#include <ctype.h>

int calclex (void);
static int get_char (void);
static void unget_char ( int c);


static YYLTYPE last_yylloc;

static int
get_char (void)
{
  int res = getc (input);
  ;

  last_yylloc = (calclloc);
  if (res == '\n')
    {
      (calclloc).last_line++;
      (calclloc).last_column = 1;
    }
  else
    (calclloc).last_column++;

  return res;
}

static void
unget_char ( int c)
{
  ;

  /* Wrong when C == `\n'. */
  (calclloc) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (calclloc).last_column = 1;
      (calclloc).last_line = 1;

    }


 (calclloc).first_column = (calclloc).last_column;
  (calclloc).first_line   = (calclloc).last_line;


  /* Skip white space.  */
  while ((c = get_char ()) == ' ' || c == '\t')
    {
     (calclloc).first_column = (calclloc).last_column;
      (calclloc).first_line   = (calclloc).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (calclval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:582: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:582 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:582"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:582: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:582 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:582"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:582: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:582 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:582"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:582: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:582 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:582"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:582: bison -o calc.c calc.y"
echo calc.at:582 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:582"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:582: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c calc-lex.c \$LIBS"
echo calc.at:582 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:582"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:582:  \$PREPARSER ./calc input"
echo calc.at:582 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:582"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:582:  \$PREPARSER ./calc input"
echo calc.at:582 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:582"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:582: cat stderr"
echo calc.at:582 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:582"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:582:  \$PREPARSER ./calc input"
echo calc.at:582 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:582"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:582: cat stderr"
echo calc.at:582 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:582"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:582:  \$PREPARSER ./calc input"
echo calc.at:582 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:582"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:582: cat stderr"
echo calc.at:582 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:582"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:582:  \$PREPARSER ./calc input"
echo calc.at:582 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:582"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:582: cat stderr"
echo calc.at:582 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:582"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:582:  \$PREPARSER ./calc input"
echo calc.at:582 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:582"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:582: cat stderr"
echo calc.at:582 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:582"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:582:  \$PREPARSER ./calc input"
echo calc.at:582 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:582"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:582: cat stderr"
echo calc.at:582 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:582"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:582:  \$PREPARSER ./calc input"
echo calc.at:582 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:582"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:582: cat stderr"
echo calc.at:582 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:582"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:582:  \$PREPARSER ./calc input"
echo calc.at:582 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:582"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:582: cat stderr"
echo calc.at:582 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:582"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:582:  \$PREPARSER ./calc input"
echo calc.at:582 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:582"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:582: cat stderr"
echo calc.at:582 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:582"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:582:  \$PREPARSER ./calc input"
echo calc.at:582 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:582"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:582: cat stderr"
echo calc.at:582 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:582"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_126
#AT_START_127
# 127. calc.at:584: Calculator %debug
at_setup_line='calc.at:584'
at_func_banner 10
at_desc="Calculator %debug"
$at_quiet $as_echo_n "127: $at_desc                              "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "127. calc.at:584: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%debug

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = get_char ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }

  yydebug = 1;
  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:584: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:584 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:584"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:584: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:584 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:584"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:584: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:584 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:584"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:584: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:584 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:584"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:584: bison -o calc.c calc.y"
echo calc.at:584 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:584"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:584: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
echo calc.at:584 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:584"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:584:  \$PREPARSER ./calc input"
echo calc.at:584 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:584"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:584:  \$PREPARSER ./calc input"
echo calc.at:584 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:584"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:584: cat stderr"
echo calc.at:584 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:584"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:584:  \$PREPARSER ./calc input"
echo calc.at:584 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:584"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:584: cat stderr"
echo calc.at:584 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:584"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:584:  \$PREPARSER ./calc input"
echo calc.at:584 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:584"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:584: cat stderr"
echo calc.at:584 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:584"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:584:  \$PREPARSER ./calc input"
echo calc.at:584 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:584"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:584: cat stderr"
echo calc.at:584 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:584"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:584:  \$PREPARSER ./calc input"
echo calc.at:584 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:584"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:584: cat stderr"
echo calc.at:584 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:584"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:584:  \$PREPARSER ./calc input"
echo calc.at:584 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:584"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:584: cat stderr"
echo calc.at:584 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:584"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:584:  \$PREPARSER ./calc input"
echo calc.at:584 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:584"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:584: cat stderr"
echo calc.at:584 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:584"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:584:  \$PREPARSER ./calc input"
echo calc.at:584 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:584"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:584: cat stderr"
echo calc.at:584 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:584"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:584:  \$PREPARSER ./calc input"
echo calc.at:584 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:584"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:584: cat stderr"
echo calc.at:584 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:584"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:584:  \$PREPARSER ./calc input"
echo calc.at:584 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:584"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:584: cat stderr"
echo calc.at:584 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:584"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_127
#AT_START_128
# 128. calc.at:585: Calculator %error-verbose %debug %locations %defines %name-prefix "calc" %verbose %yacc
at_setup_line='calc.at:585'
at_func_banner 10
at_desc="Calculator %error-verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc"
$at_quiet $as_echo_n "128: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "128. calc.at:585: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%error-verbose %debug %locations %defines %name-prefix "calc" %verbose %yacc

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (calclloc).first_line, (calclloc).first_column);
  if ((calclloc).first_line != (calclloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (calclloc).last_line,  (calclloc).last_column - 1);
  else if ((calclloc).first_column != (calclloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (calclloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }

  yydebug = 1;
  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.c <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.h"

#include <ctype.h>

int calclex (void);
static int get_char (void);
static void unget_char ( int c);


static YYLTYPE last_yylloc;

static int
get_char (void)
{
  int res = getc (input);
  ;

  last_yylloc = (calclloc);
  if (res == '\n')
    {
      (calclloc).last_line++;
      (calclloc).last_column = 1;
    }
  else
    (calclloc).last_column++;

  return res;
}

static void
unget_char ( int c)
{
  ;

  /* Wrong when C == `\n'. */
  (calclloc) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (calclloc).last_column = 1;
      (calclloc).last_line = 1;

    }


 (calclloc).first_column = (calclloc).last_column;
  (calclloc).first_line   = (calclloc).last_line;


  /* Skip white space.  */
  while ((c = get_char ()) == ' ' || c == '\t')
    {
     (calclloc).first_column = (calclloc).last_column;
      (calclloc).first_line   = (calclloc).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (calclval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:585: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:585 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:585"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:585: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:585 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:585"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:585: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:585 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:585"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:585: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:585 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:585"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:585: bison -o calc.c calc.y"
echo calc.at:585 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:585"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:585: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c calc-lex.c \$LIBS"
echo calc.at:585 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:585"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:585:  \$PREPARSER ./calc input"
echo calc.at:585 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:585"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:585:  \$PREPARSER ./calc input"
echo calc.at:585 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:585"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:585: cat stderr"
echo calc.at:585 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:585"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:585:  \$PREPARSER ./calc input"
echo calc.at:585 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:585"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:585: cat stderr"
echo calc.at:585 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:585"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:585:  \$PREPARSER ./calc input"
echo calc.at:585 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:585"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:585: cat stderr"
echo calc.at:585 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:585"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:585:  \$PREPARSER ./calc input"
echo calc.at:585 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:585"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:585: cat stderr"
echo calc.at:585 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:585"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:585:  \$PREPARSER ./calc input"
echo calc.at:585 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:585"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:585: cat stderr"
echo calc.at:585 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:585"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:585:  \$PREPARSER ./calc input"
echo calc.at:585 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:585"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:585: cat stderr"
echo calc.at:585 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:585"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:585:  \$PREPARSER ./calc input"
echo calc.at:585 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:585"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:585: cat stderr"
echo calc.at:585 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:585"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:585:  \$PREPARSER ./calc input"
echo calc.at:585 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:585"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:585: cat stderr"
echo calc.at:585 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:585"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:585:  \$PREPARSER ./calc input"
echo calc.at:585 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:585"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:585: cat stderr"
echo calc.at:585 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:585"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:585:  \$PREPARSER ./calc input"
echo calc.at:585 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:585"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:585: cat stderr"
echo calc.at:585 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:585"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_128
#AT_START_129
# 129. calc.at:587: Calculator %define api.pure %error-verbose %debug %locations %defines %name-prefix "calc" %verbose %yacc
at_setup_line='calc.at:587'
at_func_banner 10
at_desc="Calculator %define api.pure %error-verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc"
$at_quiet $as_echo_n "129: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "129. calc.at:587: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%define api.pure %error-verbose %debug %locations %defines %name-prefix "calc" %verbose %yacc

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}



static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }

  yydebug = 1;
  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.c <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.h"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }


 (*llocp).first_column = (*llocp).last_column;
  (*llocp).first_line   = (*llocp).last_line;


  /* Skip white space.  */
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t')
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:587: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:587 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:587"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:587: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:587 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:587"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:587: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:587 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:587"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:587: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:587 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:587"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:587: bison -o calc.c calc.y"
echo calc.at:587 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:587"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:587: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c calc-lex.c \$LIBS"
echo calc.at:587 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:587"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:587:  \$PREPARSER ./calc input"
echo calc.at:587 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:587"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:587:  \$PREPARSER ./calc input"
echo calc.at:587 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:587"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:587: cat stderr"
echo calc.at:587 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:587"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:587:  \$PREPARSER ./calc input"
echo calc.at:587 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:587"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:587: cat stderr"
echo calc.at:587 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:587"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:587:  \$PREPARSER ./calc input"
echo calc.at:587 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:587"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:587: cat stderr"
echo calc.at:587 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:587"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:587:  \$PREPARSER ./calc input"
echo calc.at:587 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:587"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:587: cat stderr"
echo calc.at:587 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:587"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:587:  \$PREPARSER ./calc input"
echo calc.at:587 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:587"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:587: cat stderr"
echo calc.at:587 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:587"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:587:  \$PREPARSER ./calc input"
echo calc.at:587 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:587"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:587: cat stderr"
echo calc.at:587 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:587"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:587:  \$PREPARSER ./calc input"
echo calc.at:587 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:587"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:587: cat stderr"
echo calc.at:587 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:587"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:587:  \$PREPARSER ./calc input"
echo calc.at:587 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:587"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:587: cat stderr"
echo calc.at:587 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:587"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:587:  \$PREPARSER ./calc input"
echo calc.at:587 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:587"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:587: cat stderr"
echo calc.at:587 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:587"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:587:  \$PREPARSER ./calc input"
echo calc.at:587 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:587"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:587: cat stderr"
echo calc.at:587 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:587"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_129
#AT_START_130
# 130. calc.at:588: Calculator %define api.push_pull "both" %define api.pure %error-verbose %debug %locations %defines %name-prefix "calc" %verbose %yacc
at_setup_line='calc.at:588'
at_func_banner 10
at_desc="Calculator %define api.push_pull \"both\" %define api.pure %error-verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc"
$at_quiet $as_echo_n "130: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "130. calc.at:588: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%define api.push_pull "both" %define api.pure %error-verbose %debug %locations %defines %name-prefix "calc" %verbose %yacc

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}



static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }

  yydebug = 1;
  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.c <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.h"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }


 (*llocp).first_column = (*llocp).last_column;
  (*llocp).first_line   = (*llocp).last_line;


  /* Skip white space.  */
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t')
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:588: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:588 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:588"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:588: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:588 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:588"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:588: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:588 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:588"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:588: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:588 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:588"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:588: bison -o calc.c calc.y"
echo calc.at:588 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:588"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:588: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c calc-lex.c \$LIBS"
echo calc.at:588 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:588"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:588:  \$PREPARSER ./calc input"
echo calc.at:588 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:588"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:588:  \$PREPARSER ./calc input"
echo calc.at:588 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:588"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:588: cat stderr"
echo calc.at:588 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:588"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:588:  \$PREPARSER ./calc input"
echo calc.at:588 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:588"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:588: cat stderr"
echo calc.at:588 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:588"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:588:  \$PREPARSER ./calc input"
echo calc.at:588 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:588"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:588: cat stderr"
echo calc.at:588 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:588"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:588:  \$PREPARSER ./calc input"
echo calc.at:588 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:588"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:588: cat stderr"
echo calc.at:588 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:588"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:588:  \$PREPARSER ./calc input"
echo calc.at:588 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:588"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:588: cat stderr"
echo calc.at:588 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:588"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:588:  \$PREPARSER ./calc input"
echo calc.at:588 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:588"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:588: cat stderr"
echo calc.at:588 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:588"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:588:  \$PREPARSER ./calc input"
echo calc.at:588 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:588"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:588: cat stderr"
echo calc.at:588 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:588"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:588:  \$PREPARSER ./calc input"
echo calc.at:588 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:588"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:588: cat stderr"
echo calc.at:588 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:588"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:588:  \$PREPARSER ./calc input"
echo calc.at:588 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:588"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:588: cat stderr"
echo calc.at:588 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:588"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:588:  \$PREPARSER ./calc input"
echo calc.at:588 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:588"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:588: cat stderr"
echo calc.at:588 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:588"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_130
#AT_START_131
# 131. calc.at:590: Calculator %define api.pure %error-verbose %debug %locations %defines %name-prefix "calc" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}
at_setup_line='calc.at:590'
at_func_banner 10
at_desc="Calculator %define api.pure %error-verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}"
$at_quiet $as_echo_n "131: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "131. calc.at:590: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%define api.pure %error-verbose %debug %locations %defines %name-prefix "calc" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (YYLTYPE *llocp,
                     semantic_value *result, int *count,
                     const char *s
                     );
int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         { ++*count; ++global_count; }
;

line:
  '\n'
| exp '\n'           { *result = global_result = $1; }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (YYLTYPE *llocp,
         semantic_value *result, int *count,
         const char *s)
{
(void) result; (void) count;

  fprintf (stderr, "%d.%d",
           (*llocp).first_line, (*llocp).first_column);
  if ((*llocp).first_line != (*llocp).last_line)
    fprintf (stderr, "-%d.%d",
	     (*llocp).last_line,  (*llocp).last_column - 1);
  else if ((*llocp).first_column != (*llocp).last_column - 1)
    fprintf (stderr, "-%d",
	     (*llocp).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }

  yydebug = 1;
  status = yyparse (&result, &count);
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.c <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.h"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }


 (*llocp).first_column = (*llocp).last_column;
  (*llocp).first_line   = (*llocp).last_line;


  /* Skip white space.  */
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t')
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:590: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:590 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:590"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:590: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:590 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:590"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:590: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:590 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:590"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:590: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:590 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:590"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:590: bison -o calc.c calc.y"
echo calc.at:590 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:590"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:590: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c calc-lex.c \$LIBS"
echo calc.at:590 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:590"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:590:  \$PREPARSER ./calc input"
echo calc.at:590 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:590"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:590:  \$PREPARSER ./calc input"
echo calc.at:590 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:590"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:590: cat stderr"
echo calc.at:590 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:590"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:590:  \$PREPARSER ./calc input"
echo calc.at:590 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:590"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:590: cat stderr"
echo calc.at:590 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:590"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:590:  \$PREPARSER ./calc input"
echo calc.at:590 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:590"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:590: cat stderr"
echo calc.at:590 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:590"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:590:  \$PREPARSER ./calc input"
echo calc.at:590 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:590"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:590: cat stderr"
echo calc.at:590 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:590"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:590:  \$PREPARSER ./calc input"
echo calc.at:590 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:590"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:590: cat stderr"
echo calc.at:590 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:590"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:590:  \$PREPARSER ./calc input"
echo calc.at:590 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:590"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:590: cat stderr"
echo calc.at:590 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:590"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:590:  \$PREPARSER ./calc input"
echo calc.at:590 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:590"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:590: cat stderr"
echo calc.at:590 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:590"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:590:  \$PREPARSER ./calc input"
echo calc.at:590 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:590"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:590: cat stderr"
echo calc.at:590 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:590"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:590:  \$PREPARSER ./calc input"
echo calc.at:590 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:590"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:590: cat stderr"
echo calc.at:590 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:590"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:590:  \$PREPARSER ./calc input"
echo calc.at:590 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:590"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:590: cat stderr"
echo calc.at:590 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:590"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_131
#AT_START_132
# 132. calc.at:607: Calculator %glr-parser
at_setup_line='calc.at:607'
at_func_banner 11
at_desc="Calculator %glr-parser "
$at_quiet $as_echo_n "132: $at_desc                        "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "132. calc.at:607: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = get_char ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:607: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:607 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:607"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:607: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:607 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:607"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:607: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:607 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:607"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:607: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:607 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:607"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:607: bison -o calc.c calc.y"
echo calc.at:607 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:607"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:607: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
echo calc.at:607 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:607"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:607:  \$PREPARSER ./calc input"
echo calc.at:607 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:607"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:607:  \$PREPARSER ./calc input"
echo calc.at:607 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:607"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:607: cat stderr"
echo calc.at:607 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:607"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:607:  \$PREPARSER ./calc input"
echo calc.at:607 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:607"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:607: cat stderr"
echo calc.at:607 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:607"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:607:  \$PREPARSER ./calc input"
echo calc.at:607 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:607"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:607: cat stderr"
echo calc.at:607 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:607"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:607:  \$PREPARSER ./calc input"
echo calc.at:607 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:607"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:607: cat stderr"
echo calc.at:607 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:607"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:607:  \$PREPARSER ./calc input"
echo calc.at:607 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:607"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:607: cat stderr"
echo calc.at:607 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:607"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:607:  \$PREPARSER ./calc input"
echo calc.at:607 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:607"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:607: cat stderr"
echo calc.at:607 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:607"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:607:  \$PREPARSER ./calc input"
echo calc.at:607 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:607"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:607: cat stderr"
echo calc.at:607 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:607"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:607:  \$PREPARSER ./calc input"
echo calc.at:607 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:607"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:607: cat stderr"
echo calc.at:607 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:607"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:607:  \$PREPARSER ./calc input"
echo calc.at:607 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:607"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:607: cat stderr"
echo calc.at:607 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:607"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:607:  \$PREPARSER ./calc input"
echo calc.at:607 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:607"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:607: cat stderr"
echo calc.at:607 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:607"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_132
#AT_START_133
# 133. calc.at:609: Calculator %glr-parser %defines
at_setup_line='calc.at:609'
at_func_banner 11
at_desc="Calculator %glr-parser %defines"
$at_quiet $as_echo_n "133: $at_desc                "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "133. calc.at:609: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser %defines

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}



static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.c <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.h"

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = get_char ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:609: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:609 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:609"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:609: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:609 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:609"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:609: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:609 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:609"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:609: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:609 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:609"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:609: bison -o calc.c calc.y"
echo calc.at:609 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:609"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:609: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c calc-lex.c \$LIBS"
echo calc.at:609 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:609"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:609:  \$PREPARSER ./calc input"
echo calc.at:609 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:609"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:609:  \$PREPARSER ./calc input"
echo calc.at:609 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:609"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:609: cat stderr"
echo calc.at:609 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:609"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:609:  \$PREPARSER ./calc input"
echo calc.at:609 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:609"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:609: cat stderr"
echo calc.at:609 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:609"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:609:  \$PREPARSER ./calc input"
echo calc.at:609 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:609"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:609: cat stderr"
echo calc.at:609 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:609"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:609:  \$PREPARSER ./calc input"
echo calc.at:609 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:609"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:609: cat stderr"
echo calc.at:609 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:609"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:609:  \$PREPARSER ./calc input"
echo calc.at:609 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:609"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:609: cat stderr"
echo calc.at:609 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:609"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:609:  \$PREPARSER ./calc input"
echo calc.at:609 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:609"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:609: cat stderr"
echo calc.at:609 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:609"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:609:  \$PREPARSER ./calc input"
echo calc.at:609 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:609"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:609: cat stderr"
echo calc.at:609 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:609"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:609:  \$PREPARSER ./calc input"
echo calc.at:609 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:609"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:609: cat stderr"
echo calc.at:609 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:609"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:609:  \$PREPARSER ./calc input"
echo calc.at:609 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:609"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:609: cat stderr"
echo calc.at:609 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:609"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:609:  \$PREPARSER ./calc input"
echo calc.at:609 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:609"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:609: cat stderr"
echo calc.at:609 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:609"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_133
#AT_START_134
# 134. calc.at:610: Calculator %glr-parser %locations
at_setup_line='calc.at:610'
at_func_banner 11
at_desc="Calculator %glr-parser %locations"
$at_quiet $as_echo_n "134: $at_desc              "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "134. calc.at:610: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser %locations

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (yylloc).first_line, (yylloc).first_column);
  if ((yylloc).first_line != (yylloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (yylloc).last_line,  (yylloc).last_column - 1);
  else if ((yylloc).first_column != (yylloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (yylloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static YYLTYPE last_yylloc;

static int
get_char (void)
{
  int res = getc (input);
  ;

  last_yylloc = (yylloc);
  if (res == '\n')
    {
      (yylloc).last_line++;
      (yylloc).last_column = 1;
    }
  else
    (yylloc).last_column++;

  return res;
}

static void
unget_char ( int c)
{
  ;

  /* Wrong when C == `\n'. */
  (yylloc) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (yylloc).last_column = 1;
      (yylloc).last_line = 1;

    }


 (yylloc).first_column = (yylloc).last_column;
  (yylloc).first_line   = (yylloc).last_line;


  /* Skip white space.  */
  while ((c = get_char ()) == ' ' || c == '\t')
    {
     (yylloc).first_column = (yylloc).last_column;
      (yylloc).first_line   = (yylloc).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:610: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:610 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:610"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:610: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:610 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:610"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:610: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:610 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:610"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:610: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:610 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:610"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:610: bison -o calc.c calc.y"
echo calc.at:610 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:610"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:610: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
echo calc.at:610 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:610"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:610:  \$PREPARSER ./calc input"
echo calc.at:610 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:610"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:610:  \$PREPARSER ./calc input"
echo calc.at:610 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:610"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:610: cat stderr"
echo calc.at:610 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:610"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:610:  \$PREPARSER ./calc input"
echo calc.at:610 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:610"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:610: cat stderr"
echo calc.at:610 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:610"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:610:  \$PREPARSER ./calc input"
echo calc.at:610 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:610"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:610: cat stderr"
echo calc.at:610 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:610"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:610:  \$PREPARSER ./calc input"
echo calc.at:610 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:610"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:610: cat stderr"
echo calc.at:610 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:610"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:610:  \$PREPARSER ./calc input"
echo calc.at:610 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:610"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:610: cat stderr"
echo calc.at:610 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:610"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:610:  \$PREPARSER ./calc input"
echo calc.at:610 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:610"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:610: cat stderr"
echo calc.at:610 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:610"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:610:  \$PREPARSER ./calc input"
echo calc.at:610 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:610"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:610: cat stderr"
echo calc.at:610 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:610"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:610:  \$PREPARSER ./calc input"
echo calc.at:610 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:610"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:610: cat stderr"
echo calc.at:610 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:610"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:610:  \$PREPARSER ./calc input"
echo calc.at:610 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:610"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:610: cat stderr"
echo calc.at:610 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:610"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:610:  \$PREPARSER ./calc input"
echo calc.at:610 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:610"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:610: cat stderr"
echo calc.at:610 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:610"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_134
#AT_START_135
# 135. calc.at:611: Calculator %glr-parser %name-prefix "calc"
at_setup_line='calc.at:611'
at_func_banner 11
at_desc="Calculator %glr-parser %name-prefix \"calc\""
$at_quiet $as_echo_n "135: $at_desc     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "135. calc.at:611: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser %name-prefix "calc"

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int calclex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = get_char ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (calclval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:611: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:611 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:611"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:611: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:611 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:611"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:611: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:611 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:611"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:611: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:611 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:611"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:611: bison -o calc.c calc.y"
echo calc.at:611 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:611"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:611: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
echo calc.at:611 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:611"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:611:  \$PREPARSER ./calc input"
echo calc.at:611 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:611"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:611:  \$PREPARSER ./calc input"
echo calc.at:611 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:611"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:611: cat stderr"
echo calc.at:611 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:611"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:611:  \$PREPARSER ./calc input"
echo calc.at:611 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:611"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:611: cat stderr"
echo calc.at:611 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:611"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:611:  \$PREPARSER ./calc input"
echo calc.at:611 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:611"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:611: cat stderr"
echo calc.at:611 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:611"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:611:  \$PREPARSER ./calc input"
echo calc.at:611 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:611"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:611: cat stderr"
echo calc.at:611 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:611"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:611:  \$PREPARSER ./calc input"
echo calc.at:611 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:611"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:611: cat stderr"
echo calc.at:611 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:611"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:611:  \$PREPARSER ./calc input"
echo calc.at:611 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:611"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:611: cat stderr"
echo calc.at:611 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:611"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:611:  \$PREPARSER ./calc input"
echo calc.at:611 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:611"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:611: cat stderr"
echo calc.at:611 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:611"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:611:  \$PREPARSER ./calc input"
echo calc.at:611 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:611"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:611: cat stderr"
echo calc.at:611 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:611"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:611:  \$PREPARSER ./calc input"
echo calc.at:611 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:611"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:611: cat stderr"
echo calc.at:611 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:611"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:611:  \$PREPARSER ./calc input"
echo calc.at:611 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:611"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:611: cat stderr"
echo calc.at:611 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:611"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_135
#AT_START_136
# 136. calc.at:612: Calculator %glr-parser %verbose
at_setup_line='calc.at:612'
at_func_banner 11
at_desc="Calculator %glr-parser %verbose"
$at_quiet $as_echo_n "136: $at_desc                "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "136. calc.at:612: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser %verbose

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = get_char ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:612: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:612 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:612"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:612: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:612 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:612"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:612: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:612 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:612"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:612: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:612 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:612"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:612: bison -o calc.c calc.y"
echo calc.at:612 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:612"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:612: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
echo calc.at:612 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:612"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:612:  \$PREPARSER ./calc input"
echo calc.at:612 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:612"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:612:  \$PREPARSER ./calc input"
echo calc.at:612 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:612"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:612: cat stderr"
echo calc.at:612 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:612"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:612:  \$PREPARSER ./calc input"
echo calc.at:612 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:612"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:612: cat stderr"
echo calc.at:612 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:612"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:612:  \$PREPARSER ./calc input"
echo calc.at:612 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:612"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:612: cat stderr"
echo calc.at:612 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:612"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:612:  \$PREPARSER ./calc input"
echo calc.at:612 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:612"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:612: cat stderr"
echo calc.at:612 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:612"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:612:  \$PREPARSER ./calc input"
echo calc.at:612 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:612"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:612: cat stderr"
echo calc.at:612 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:612"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:612:  \$PREPARSER ./calc input"
echo calc.at:612 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:612"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:612: cat stderr"
echo calc.at:612 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:612"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:612:  \$PREPARSER ./calc input"
echo calc.at:612 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:612"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:612: cat stderr"
echo calc.at:612 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:612"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:612:  \$PREPARSER ./calc input"
echo calc.at:612 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:612"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:612: cat stderr"
echo calc.at:612 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:612"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:612:  \$PREPARSER ./calc input"
echo calc.at:612 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:612"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:612: cat stderr"
echo calc.at:612 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:612"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:612:  \$PREPARSER ./calc input"
echo calc.at:612 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:612"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:612: cat stderr"
echo calc.at:612 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:612"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_136
#AT_START_137
# 137. calc.at:613: Calculator %glr-parser %yacc
at_setup_line='calc.at:613'
at_func_banner 11
at_desc="Calculator %glr-parser %yacc"
$at_quiet $as_echo_n "137: $at_desc                   "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "137. calc.at:613: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser %yacc

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = get_char ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:613: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:613 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:613"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:613: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:613 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:613"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:613: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:613 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:613"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:613: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:613 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:613"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:613: bison -o calc.c calc.y"
echo calc.at:613 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:613"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:613: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
echo calc.at:613 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:613"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:613:  \$PREPARSER ./calc input"
echo calc.at:613 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:613"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:613:  \$PREPARSER ./calc input"
echo calc.at:613 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:613"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:613: cat stderr"
echo calc.at:613 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:613"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:613:  \$PREPARSER ./calc input"
echo calc.at:613 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:613"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:613: cat stderr"
echo calc.at:613 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:613"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:613:  \$PREPARSER ./calc input"
echo calc.at:613 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:613"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:613: cat stderr"
echo calc.at:613 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:613"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:613:  \$PREPARSER ./calc input"
echo calc.at:613 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:613"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:613: cat stderr"
echo calc.at:613 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:613"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:613:  \$PREPARSER ./calc input"
echo calc.at:613 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:613"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:613: cat stderr"
echo calc.at:613 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:613"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:613:  \$PREPARSER ./calc input"
echo calc.at:613 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:613"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:613: cat stderr"
echo calc.at:613 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:613"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:613:  \$PREPARSER ./calc input"
echo calc.at:613 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:613"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:613: cat stderr"
echo calc.at:613 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:613"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:613:  \$PREPARSER ./calc input"
echo calc.at:613 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:613"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:613: cat stderr"
echo calc.at:613 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:613"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:613:  \$PREPARSER ./calc input"
echo calc.at:613 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:613"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:613: cat stderr"
echo calc.at:613 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:613"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:613:  \$PREPARSER ./calc input"
echo calc.at:613 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:613"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:613: cat stderr"
echo calc.at:613 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:613"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_137
#AT_START_138
# 138. calc.at:614: Calculator %glr-parser %error-verbose
at_setup_line='calc.at:614'
at_func_banner 11
at_desc="Calculator %glr-parser %error-verbose"
$at_quiet $as_echo_n "138: $at_desc          "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "138. calc.at:614: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser %error-verbose

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = get_char ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:614: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:614 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:614"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:614: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:614 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:614"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:614: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:614 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:614"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:614: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:614 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:614"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:614: bison -o calc.c calc.y"
echo calc.at:614 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:614"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:614: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
echo calc.at:614 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:614"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:614:  \$PREPARSER ./calc input"
echo calc.at:614 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:614"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:614:  \$PREPARSER ./calc input"
echo calc.at:614 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:614"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:614: cat stderr"
echo calc.at:614 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:614"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:614:  \$PREPARSER ./calc input"
echo calc.at:614 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:614"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:614: cat stderr"
echo calc.at:614 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:614"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:614:  \$PREPARSER ./calc input"
echo calc.at:614 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:614"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:614: cat stderr"
echo calc.at:614 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:614"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:614:  \$PREPARSER ./calc input"
echo calc.at:614 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:614"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:614: cat stderr"
echo calc.at:614 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:614"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:614:  \$PREPARSER ./calc input"
echo calc.at:614 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:614"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:614: cat stderr"
echo calc.at:614 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:614"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:614:  \$PREPARSER ./calc input"
echo calc.at:614 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:614"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:614: cat stderr"
echo calc.at:614 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:614"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:614:  \$PREPARSER ./calc input"
echo calc.at:614 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:614"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:614: cat stderr"
echo calc.at:614 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:614"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:614:  \$PREPARSER ./calc input"
echo calc.at:614 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:614"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:614: cat stderr"
echo calc.at:614 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:614"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:614:  \$PREPARSER ./calc input"
echo calc.at:614 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:614"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:614: cat stderr"
echo calc.at:614 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:614"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:614:  \$PREPARSER ./calc input"
echo calc.at:614 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:614"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:614: cat stderr"
echo calc.at:614 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:614"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_138
#AT_START_139
# 139. calc.at:616: Calculator %glr-parser %define api.pure %locations
at_setup_line='calc.at:616'
at_func_banner 11
at_desc="Calculator %glr-parser %define api.pure %locations"
$at_quiet $as_echo_n "139: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "139. calc.at:616: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser %define api.pure %locations

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (YYLTYPE *llocp,

                     const char *s
                     );
int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (YYLTYPE *llocp,

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (*llocp).first_line, (*llocp).first_column);
  if ((*llocp).first_line != (*llocp).last_line)
    fprintf (stderr, "-%d.%d",
	     (*llocp).last_line,  (*llocp).last_column - 1);
  else if ((*llocp).first_column != (*llocp).last_column - 1)
    fprintf (stderr, "-%d",
	     (*llocp).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }


 (*llocp).first_column = (*llocp).last_column;
  (*llocp).first_line   = (*llocp).last_line;


  /* Skip white space.  */
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t')
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:616: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:616 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:616"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:616: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:616 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:616"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:616: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:616 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:616"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:616: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:616 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:616"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:616: bison -o calc.c calc.y"
echo calc.at:616 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:616"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:616: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
echo calc.at:616 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:616"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:616:  \$PREPARSER ./calc input"
echo calc.at:616 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:616"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:616:  \$PREPARSER ./calc input"
echo calc.at:616 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:616"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:616: cat stderr"
echo calc.at:616 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:616"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:616:  \$PREPARSER ./calc input"
echo calc.at:616 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:616"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:616: cat stderr"
echo calc.at:616 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:616"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:616:  \$PREPARSER ./calc input"
echo calc.at:616 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:616"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:616: cat stderr"
echo calc.at:616 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:616"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:616:  \$PREPARSER ./calc input"
echo calc.at:616 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:616"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:616: cat stderr"
echo calc.at:616 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:616"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:616:  \$PREPARSER ./calc input"
echo calc.at:616 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:616"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:616: cat stderr"
echo calc.at:616 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:616"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:616:  \$PREPARSER ./calc input"
echo calc.at:616 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:616"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:616: cat stderr"
echo calc.at:616 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:616"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:616:  \$PREPARSER ./calc input"
echo calc.at:616 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:616"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:616: cat stderr"
echo calc.at:616 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:616"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:616:  \$PREPARSER ./calc input"
echo calc.at:616 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:616"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:616: cat stderr"
echo calc.at:616 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:616"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:616:  \$PREPARSER ./calc input"
echo calc.at:616 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:616"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:616: cat stderr"
echo calc.at:616 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:616"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:616:  \$PREPARSER ./calc input"
echo calc.at:616 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:616"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:616: cat stderr"
echo calc.at:616 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:616"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_139
#AT_START_140
# 140. calc.at:617: Calculator %glr-parser %error-verbose %locations
at_setup_line='calc.at:617'
at_func_banner 11
at_desc="Calculator %glr-parser %error-verbose %locations"
$at_quiet $as_echo_n "140: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "140. calc.at:617: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser %error-verbose %locations

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (yylloc).first_line, (yylloc).first_column);
  if ((yylloc).first_line != (yylloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (yylloc).last_line,  (yylloc).last_column - 1);
  else if ((yylloc).first_column != (yylloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (yylloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static YYLTYPE last_yylloc;

static int
get_char (void)
{
  int res = getc (input);
  ;

  last_yylloc = (yylloc);
  if (res == '\n')
    {
      (yylloc).last_line++;
      (yylloc).last_column = 1;
    }
  else
    (yylloc).last_column++;

  return res;
}

static void
unget_char ( int c)
{
  ;

  /* Wrong when C == `\n'. */
  (yylloc) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (yylloc).last_column = 1;
      (yylloc).last_line = 1;

    }


 (yylloc).first_column = (yylloc).last_column;
  (yylloc).first_line   = (yylloc).last_line;


  /* Skip white space.  */
  while ((c = get_char ()) == ' ' || c == '\t')
    {
     (yylloc).first_column = (yylloc).last_column;
      (yylloc).first_line   = (yylloc).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:617: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:617 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:617"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:617: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:617 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:617"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:617: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:617 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:617"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:617: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:617 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:617"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:617: bison -o calc.c calc.y"
echo calc.at:617 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:617"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:617: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
echo calc.at:617 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:617"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:617:  \$PREPARSER ./calc input"
echo calc.at:617 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:617"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:617:  \$PREPARSER ./calc input"
echo calc.at:617 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:617"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:617: cat stderr"
echo calc.at:617 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:617"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:617:  \$PREPARSER ./calc input"
echo calc.at:617 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:617"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:617: cat stderr"
echo calc.at:617 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:617"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:617:  \$PREPARSER ./calc input"
echo calc.at:617 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:617"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:617: cat stderr"
echo calc.at:617 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:617"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:617:  \$PREPARSER ./calc input"
echo calc.at:617 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:617"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:617: cat stderr"
echo calc.at:617 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:617"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:617:  \$PREPARSER ./calc input"
echo calc.at:617 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:617"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:617: cat stderr"
echo calc.at:617 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:617"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:617:  \$PREPARSER ./calc input"
echo calc.at:617 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:617"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:617: cat stderr"
echo calc.at:617 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:617"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:617:  \$PREPARSER ./calc input"
echo calc.at:617 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:617"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:617: cat stderr"
echo calc.at:617 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:617"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:617:  \$PREPARSER ./calc input"
echo calc.at:617 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:617"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:617: cat stderr"
echo calc.at:617 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:617"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:617:  \$PREPARSER ./calc input"
echo calc.at:617 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:617"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:617: cat stderr"
echo calc.at:617 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:617"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:617:  \$PREPARSER ./calc input"
echo calc.at:617 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:617"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:617: cat stderr"
echo calc.at:617 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:617"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_140
#AT_START_141
# 141. calc.at:619: Calculator %glr-parser %error-verbose %locations %defines %name-prefix "calc" %verbose %yacc
at_setup_line='calc.at:619'
at_func_banner 11
at_desc="Calculator %glr-parser %error-verbose %locations %defines %name-prefix \"calc\" %verbose %yacc"
$at_quiet $as_echo_n "141: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "141. calc.at:619: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser %error-verbose %locations %defines %name-prefix "calc" %verbose %yacc

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (calclloc).first_line, (calclloc).first_column);
  if ((calclloc).first_line != (calclloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (calclloc).last_line,  (calclloc).last_column - 1);
  else if ((calclloc).first_column != (calclloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (calclloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.c <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.h"

#include <ctype.h>

int calclex (void);
static int get_char (void);
static void unget_char ( int c);


static YYLTYPE last_yylloc;

static int
get_char (void)
{
  int res = getc (input);
  ;

  last_yylloc = (calclloc);
  if (res == '\n')
    {
      (calclloc).last_line++;
      (calclloc).last_column = 1;
    }
  else
    (calclloc).last_column++;

  return res;
}

static void
unget_char ( int c)
{
  ;

  /* Wrong when C == `\n'. */
  (calclloc) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (calclloc).last_column = 1;
      (calclloc).last_line = 1;

    }


 (calclloc).first_column = (calclloc).last_column;
  (calclloc).first_line   = (calclloc).last_line;


  /* Skip white space.  */
  while ((c = get_char ()) == ' ' || c == '\t')
    {
     (calclloc).first_column = (calclloc).last_column;
      (calclloc).first_line   = (calclloc).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (calclval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:619: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:619 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:619"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:619: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:619 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:619"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:619: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:619 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:619"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:619: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:619 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:619"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:619: bison -o calc.c calc.y"
echo calc.at:619 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:619"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:619: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c calc-lex.c \$LIBS"
echo calc.at:619 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:619"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:619:  \$PREPARSER ./calc input"
echo calc.at:619 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:619"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:619:  \$PREPARSER ./calc input"
echo calc.at:619 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:619"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:619: cat stderr"
echo calc.at:619 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:619"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:619:  \$PREPARSER ./calc input"
echo calc.at:619 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:619"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:619: cat stderr"
echo calc.at:619 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:619"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:619:  \$PREPARSER ./calc input"
echo calc.at:619 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:619"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:619: cat stderr"
echo calc.at:619 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:619"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:619:  \$PREPARSER ./calc input"
echo calc.at:619 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:619"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:619: cat stderr"
echo calc.at:619 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:619"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:619:  \$PREPARSER ./calc input"
echo calc.at:619 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:619"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:619: cat stderr"
echo calc.at:619 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:619"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:619:  \$PREPARSER ./calc input"
echo calc.at:619 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:619"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:619: cat stderr"
echo calc.at:619 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:619"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:619:  \$PREPARSER ./calc input"
echo calc.at:619 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:619"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:619: cat stderr"
echo calc.at:619 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:619"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:619:  \$PREPARSER ./calc input"
echo calc.at:619 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:619"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:619: cat stderr"
echo calc.at:619 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:619"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:619:  \$PREPARSER ./calc input"
echo calc.at:619 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:619"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:619: cat stderr"
echo calc.at:619 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:619"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:619:  \$PREPARSER ./calc input"
echo calc.at:619 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:619"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:619: cat stderr"
echo calc.at:619 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:619"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_141
#AT_START_142
# 142. calc.at:621: Calculator %glr-parser %debug
at_setup_line='calc.at:621'
at_func_banner 11
at_desc="Calculator %glr-parser %debug"
$at_quiet $as_echo_n "142: $at_desc                  "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "142. calc.at:621: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser %debug

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}

#include <ctype.h>

int yylex (void);
static int get_char (void);
static void unget_char ( int c);


static int
get_char (void)
{
  int res = getc (input);
  ;

  return res;
}

static void
unget_char ( int c)
{
  ;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = get_char ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}


static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }

  yydebug = 1;
  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF






if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:621: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:621 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:621"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:621: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:621 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:621"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:621: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:621 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:621"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:621: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:621 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:621"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:621: bison -o calc.c calc.y"
echo calc.at:621 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:621"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:621: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c \$LIBS"
echo calc.at:621 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:621"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:621:  \$PREPARSER ./calc input"
echo calc.at:621 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:621"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:621:  \$PREPARSER ./calc input"
echo calc.at:621 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:621"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:621: cat stderr"
echo calc.at:621 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:621"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:621:  \$PREPARSER ./calc input"
echo calc.at:621 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:621"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:621: cat stderr"
echo calc.at:621 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:621"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:621:  \$PREPARSER ./calc input"
echo calc.at:621 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:621"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:621: cat stderr"
echo calc.at:621 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:621"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:621:  \$PREPARSER ./calc input"
echo calc.at:621 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:621"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:621: cat stderr"
echo calc.at:621 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:621"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:621:  \$PREPARSER ./calc input"
echo calc.at:621 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:621"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:621: cat stderr"
echo calc.at:621 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:621"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:621:  \$PREPARSER ./calc input"
echo calc.at:621 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:621"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:621: cat stderr"
echo calc.at:621 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:621"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:621:  \$PREPARSER ./calc input"
echo calc.at:621 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:621"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:621: cat stderr"
echo calc.at:621 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:621"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:621:  \$PREPARSER ./calc input"
echo calc.at:621 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:621"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:621: cat stderr"
echo calc.at:621 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:621"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:621:  \$PREPARSER ./calc input"
echo calc.at:621 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:621"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:621: cat stderr"
echo calc.at:621 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:621"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:621:  \$PREPARSER ./calc input"
echo calc.at:621 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:621"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:621: cat stderr"
echo calc.at:621 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:621"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_142
#AT_START_143
# 143. calc.at:622: Calculator %glr-parser %error-verbose %debug %locations %defines %name-prefix "calc" %verbose %yacc
at_setup_line='calc.at:622'
at_func_banner 11
at_desc="Calculator %glr-parser %error-verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc"
$at_quiet $as_echo_n "143: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "143. calc.at:622: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser %error-verbose %debug %locations %defines %name-prefix "calc" %verbose %yacc

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
int yylex (void);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (calclloc).first_line, (calclloc).first_column);
  if ((calclloc).first_line != (calclloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (calclloc).last_line,  (calclloc).last_column - 1);
  else if ((calclloc).first_column != (calclloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (calclloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }

  yydebug = 1;
  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.c <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.h"

#include <ctype.h>

int calclex (void);
static int get_char (void);
static void unget_char ( int c);


static YYLTYPE last_yylloc;

static int
get_char (void)
{
  int res = getc (input);
  ;

  last_yylloc = (calclloc);
  if (res == '\n')
    {
      (calclloc).last_line++;
      (calclloc).last_column = 1;
    }
  else
    (calclloc).last_column++;

  return res;
}

static void
unget_char ( int c)
{
  ;

  /* Wrong when C == `\n'. */
  (calclloc) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (void)
{
  int c = get_char ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = get_char ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char ();
    }

  unget_char ( c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (calclloc).last_column = 1;
      (calclloc).last_line = 1;

    }


 (calclloc).first_column = (calclloc).last_column;
  (calclloc).first_line   = (calclloc).last_line;


  /* Skip white space.  */
  while ((c = get_char ()) == ' ' || c == '\t')
    {
     (calclloc).first_column = (calclloc).last_column;
      (calclloc).first_line   = (calclloc).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char ( c);
      (calclval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:622: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:622 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:622"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:622: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:622 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:622"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:622: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:622 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:622"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:622: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:622 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:622"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:622: bison -o calc.c calc.y"
echo calc.at:622 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:622"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:622: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c calc-lex.c \$LIBS"
echo calc.at:622 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:622"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:622:  \$PREPARSER ./calc input"
echo calc.at:622 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:622"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:622:  \$PREPARSER ./calc input"
echo calc.at:622 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:622"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:622: cat stderr"
echo calc.at:622 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:622"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:622:  \$PREPARSER ./calc input"
echo calc.at:622 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:622"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:622: cat stderr"
echo calc.at:622 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:622"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:622:  \$PREPARSER ./calc input"
echo calc.at:622 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:622"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:622: cat stderr"
echo calc.at:622 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:622"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:622:  \$PREPARSER ./calc input"
echo calc.at:622 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:622"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:622: cat stderr"
echo calc.at:622 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:622"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:622:  \$PREPARSER ./calc input"
echo calc.at:622 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:622"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:622: cat stderr"
echo calc.at:622 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:622"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:622:  \$PREPARSER ./calc input"
echo calc.at:622 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:622"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:622: cat stderr"
echo calc.at:622 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:622"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:622:  \$PREPARSER ./calc input"
echo calc.at:622 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:622"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:622: cat stderr"
echo calc.at:622 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:622"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:622:  \$PREPARSER ./calc input"
echo calc.at:622 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:622"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:622: cat stderr"
echo calc.at:622 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:622"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:622:  \$PREPARSER ./calc input"
echo calc.at:622 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:622"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:622: cat stderr"
echo calc.at:622 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:622"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:622:  \$PREPARSER ./calc input"
echo calc.at:622 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:622"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:622: cat stderr"
echo calc.at:622 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:622"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_143
#AT_START_144
# 144. calc.at:624: Calculator %glr-parser %define api.pure %error-verbose %debug %locations %defines %name-prefix "calc" %verbose %yacc
at_setup_line='calc.at:624'
at_func_banner 11
at_desc="Calculator %glr-parser %define api.pure %error-verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc"
$at_quiet $as_echo_n "144: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "144. calc.at:624: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser %define api.pure %error-verbose %debug %locations %defines %name-prefix "calc" %verbose %yacc

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (YYLTYPE *llocp,

                     const char *s
                     );
int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (YYLTYPE *llocp,

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (*llocp).first_line, (*llocp).first_column);
  if ((*llocp).first_line != (*llocp).last_line)
    fprintf (stderr, "-%d.%d",
	     (*llocp).last_line,  (*llocp).last_column - 1);
  else if ((*llocp).first_column != (*llocp).last_column - 1)
    fprintf (stderr, "-%d",
	     (*llocp).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }

  yydebug = 1;
  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.c <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.h"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }


 (*llocp).first_column = (*llocp).last_column;
  (*llocp).first_line   = (*llocp).last_line;


  /* Skip white space.  */
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t')
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:624: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:624 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:624"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:624: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:624 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:624"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:624: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:624 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:624"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:624: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:624 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:624"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:624: bison -o calc.c calc.y"
echo calc.at:624 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:624"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:624: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c calc-lex.c \$LIBS"
echo calc.at:624 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:624"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:624:  \$PREPARSER ./calc input"
echo calc.at:624 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:624"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:624:  \$PREPARSER ./calc input"
echo calc.at:624 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:624"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:624: cat stderr"
echo calc.at:624 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:624"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:624:  \$PREPARSER ./calc input"
echo calc.at:624 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:624"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:624: cat stderr"
echo calc.at:624 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:624"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:624:  \$PREPARSER ./calc input"
echo calc.at:624 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:624"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:624: cat stderr"
echo calc.at:624 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:624"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:624:  \$PREPARSER ./calc input"
echo calc.at:624 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:624"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:624: cat stderr"
echo calc.at:624 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:624"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:624:  \$PREPARSER ./calc input"
echo calc.at:624 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:624"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:624: cat stderr"
echo calc.at:624 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:624"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:624:  \$PREPARSER ./calc input"
echo calc.at:624 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:624"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:624: cat stderr"
echo calc.at:624 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:624"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:624:  \$PREPARSER ./calc input"
echo calc.at:624 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:624"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:624: cat stderr"
echo calc.at:624 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:624"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:624:  \$PREPARSER ./calc input"
echo calc.at:624 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:624"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:624: cat stderr"
echo calc.at:624 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:624"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:624:  \$PREPARSER ./calc input"
echo calc.at:624 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:624"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:624: cat stderr"
echo calc.at:624 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:624"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:624:  \$PREPARSER ./calc input"
echo calc.at:624 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:624"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:624: cat stderr"
echo calc.at:624 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:624"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_144
#AT_START_145
# 145. calc.at:626: Calculator %glr-parser %define api.pure %error-verbose %debug %locations %defines %name-prefix "calc" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}
at_setup_line='calc.at:626'
at_func_banner 11
at_desc="Calculator %glr-parser %define api.pure %error-verbose %debug %locations %defines %name-prefix \"calc\" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}"
$at_quiet $as_echo_n "145: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "145. calc.at:626: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%glr-parser %define api.pure %error-verbose %debug %locations %defines %name-prefix "calc" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}

%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (YYLTYPE *llocp,
                     semantic_value *result, int *count,
                     const char *s
                     );
int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}



/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         { ++*count; ++global_count; }
;

line:
  '\n'
| exp '\n'           { *result = global_result = $1; }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

static void
yyerror (YYLTYPE *llocp,
         semantic_value *result, int *count,
         const char *s)
{
(void) result; (void) count;

  fprintf (stderr, "%d.%d",
           (*llocp).first_line, (*llocp).first_column);
  if ((*llocp).first_line != (*llocp).last_line)
    fprintf (stderr, "-%d.%d",
	     (*llocp).last_line,  (*llocp).last_column - 1);
  else if ((*llocp).first_column != (*llocp).last_column - 1)
    fprintf (stderr, "-%d",
	     (*llocp).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }

  yydebug = 1;
  status = yyparse (&result, &count);
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.c <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.h"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }


 (*llocp).first_column = (*llocp).last_column;
  (*llocp).first_line   = (*llocp).last_line;


  /* Skip white space.  */
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t')
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:626: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.c calc.y"
echo calc.at:626 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:626"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:626: bison --xml=xml-tests/test.xml -o calc.c calc.y"
echo calc.at:626 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:626"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:626: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:626 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:626"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:626: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:626 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:626"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:626: bison -o calc.c calc.y"
echo calc.at:626 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.c calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:626"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/calc.at:626: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.c calc-lex.c \$LIBS"
echo calc.at:626 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o calc calc.c calc-lex.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:626"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:626:  \$PREPARSER ./calc input"
echo calc.at:626 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:626"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:626:  \$PREPARSER ./calc input"
echo calc.at:626 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:626"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:626: cat stderr"
echo calc.at:626 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:626"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:626:  \$PREPARSER ./calc input"
echo calc.at:626 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:626"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:626: cat stderr"
echo calc.at:626 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:626"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:626:  \$PREPARSER ./calc input"
echo calc.at:626 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:626"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:626: cat stderr"
echo calc.at:626 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:626"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:626:  \$PREPARSER ./calc input"
echo calc.at:626 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:626"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:626: cat stderr"
echo calc.at:626 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:626"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:626:  \$PREPARSER ./calc input"
echo calc.at:626 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:626"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:626: cat stderr"
echo calc.at:626 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:626"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:626:  \$PREPARSER ./calc input"
echo calc.at:626 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:626"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:626: cat stderr"
echo calc.at:626 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:626"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:626:  \$PREPARSER ./calc input"
echo calc.at:626 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:626"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:626: cat stderr"
echo calc.at:626 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:626"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:626:  \$PREPARSER ./calc input"
echo calc.at:626 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:626"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:626: cat stderr"
echo calc.at:626 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:626"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:626:  \$PREPARSER ./calc input"
echo calc.at:626 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:626"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:626: cat stderr"
echo calc.at:626 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:626"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:626:  \$PREPARSER ./calc input"
echo calc.at:626 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:626"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:626: cat stderr"
echo calc.at:626 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:626"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_145
#AT_START_146
# 146. calc.at:636: Calculator %skeleton "lalr1.cc" %defines %locations
at_setup_line='calc.at:636'
at_func_banner 12
at_desc="Calculator %skeleton \"lalr1.cc\" %defines %locations"
$at_quiet $as_echo_n "146: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "146. calc.at:636: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%skeleton "lalr1.cc" %defines %locations
%define global_tokens_and_yystype
%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE yy::location
#endif
#define first_line   begin.line
#define first_column begin.column
#define last_line    end.line
#define last_column  end.column
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}

/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++. */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C++ error reporting function.  */
void
yy::parser::error (const location& l, const std::string& m)
{
  (void) l;
  std::cerr << l << ": " << m << std::endl;
}

int
yyparse ()
{
  yy::parser parser;
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }


 (*llocp).first_column = (*llocp).last_column;
  (*llocp).first_line   = (*llocp).last_line;


  /* Skip white space.  */
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t')
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:636: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
echo calc.at:636 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:636: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
echo calc.at:636 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:636: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:636 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:636: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:636 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:636: bison -o calc.cc calc.y"
echo calc.at:636 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/calc.at:636: \$BISON_CXX_WORKS"
echo calc.at:636 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:636: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
echo calc.at:636 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS"; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:636:  \$PREPARSER ./calc input"
echo calc.at:636 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:636:  \$PREPARSER ./calc input"
echo calc.at:636 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:636: cat stderr"
echo calc.at:636 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:636:  \$PREPARSER ./calc input"
echo calc.at:636 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:636: cat stderr"
echo calc.at:636 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:636:  \$PREPARSER ./calc input"
echo calc.at:636 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:636: cat stderr"
echo calc.at:636 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:636:  \$PREPARSER ./calc input"
echo calc.at:636 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:636: cat stderr"
echo calc.at:636 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:636:  \$PREPARSER ./calc input"
echo calc.at:636 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:636: cat stderr"
echo calc.at:636 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:636:  \$PREPARSER ./calc input"
echo calc.at:636 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:636: cat stderr"
echo calc.at:636 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:636:  \$PREPARSER ./calc input"
echo calc.at:636 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:636: cat stderr"
echo calc.at:636 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:636:  \$PREPARSER ./calc input"
echo calc.at:636 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:636: cat stderr"
echo calc.at:636 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:636:  \$PREPARSER ./calc input"
echo calc.at:636 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:636: cat stderr"
echo calc.at:636 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:636:  \$PREPARSER ./calc input"
echo calc.at:636 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:636: cat stderr"
echo calc.at:636 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:636"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_146
#AT_START_147
# 147. calc.at:645: Calculator %language "C++" %defines %locations
at_setup_line='calc.at:645'
at_func_banner 12
at_desc="Calculator %language \"C++\" %defines %locations "
$at_quiet $as_echo_n "147: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "147. calc.at:645: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%language "C++" %defines %locations
%define global_tokens_and_yystype
%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE yy::location
#endif
#define first_line   begin.line
#define first_column begin.column
#define last_line    end.line
#define last_column  end.column
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}

/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++. */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C++ error reporting function.  */
void
yy::parser::error (const location& l, const std::string& m)
{
  (void) l;
  std::cerr << l << ": " << m << std::endl;
}

int
yyparse ()
{
  yy::parser parser;
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }


 (*llocp).first_column = (*llocp).last_column;
  (*llocp).first_line   = (*llocp).last_line;


  /* Skip white space.  */
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t')
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:645: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
echo calc.at:645 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:645: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
echo calc.at:645 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:645: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:645 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:645: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:645 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:645: bison -o calc.cc calc.y"
echo calc.at:645 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/calc.at:645: \$BISON_CXX_WORKS"
echo calc.at:645 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:645: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
echo calc.at:645 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS"; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:645:  \$PREPARSER ./calc input"
echo calc.at:645 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:645:  \$PREPARSER ./calc input"
echo calc.at:645 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:645: cat stderr"
echo calc.at:645 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:645:  \$PREPARSER ./calc input"
echo calc.at:645 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:645: cat stderr"
echo calc.at:645 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:645:  \$PREPARSER ./calc input"
echo calc.at:645 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:645: cat stderr"
echo calc.at:645 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:645:  \$PREPARSER ./calc input"
echo calc.at:645 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:645: cat stderr"
echo calc.at:645 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:645:  \$PREPARSER ./calc input"
echo calc.at:645 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:645: cat stderr"
echo calc.at:645 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:645:  \$PREPARSER ./calc input"
echo calc.at:645 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:645: cat stderr"
echo calc.at:645 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:645:  \$PREPARSER ./calc input"
echo calc.at:645 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:645: cat stderr"
echo calc.at:645 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:645:  \$PREPARSER ./calc input"
echo calc.at:645 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:645: cat stderr"
echo calc.at:645 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:645:  \$PREPARSER ./calc input"
echo calc.at:645 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:645: cat stderr"
echo calc.at:645 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:645:  \$PREPARSER ./calc input"
echo calc.at:645 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:645: cat stderr"
echo calc.at:645 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:645"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_147
#AT_START_148
# 148. calc.at:646: Calculator %language "C++" %defines %locations %error-verbose %name-prefix "calc" %verbose %yacc
at_setup_line='calc.at:646'
at_func_banner 12
at_desc="Calculator %language \"C++\" %defines %locations %error-verbose %name-prefix \"calc\" %verbose %yacc"
$at_quiet $as_echo_n "148: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "148. calc.at:646: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%language "C++" %defines %locations %error-verbose %name-prefix "calc" %verbose %yacc
%define global_tokens_and_yystype
%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE calc::location
#endif
#define first_line   begin.line
#define first_column begin.column
#define last_line    end.line
#define last_column  end.column
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}

/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++. */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C++ error reporting function.  */
void
calc::parser::error (const location& l, const std::string& m)
{
  (void) l;
  std::cerr << l << ": " << m << std::endl;
}

int
yyparse ()
{
  calc::parser parser;
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }


 (*llocp).first_column = (*llocp).last_column;
  (*llocp).first_line   = (*llocp).last_line;


  /* Skip white space.  */
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t')
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:646: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
echo calc.at:646 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:646: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
echo calc.at:646 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:646: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:646 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:646: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:646 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:646: bison -o calc.cc calc.y"
echo calc.at:646 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/calc.at:646: \$BISON_CXX_WORKS"
echo calc.at:646 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:646: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
echo calc.at:646 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS"; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:646:  \$PREPARSER ./calc input"
echo calc.at:646 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:646:  \$PREPARSER ./calc input"
echo calc.at:646 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:646: cat stderr"
echo calc.at:646 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:646:  \$PREPARSER ./calc input"
echo calc.at:646 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:646: cat stderr"
echo calc.at:646 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:646:  \$PREPARSER ./calc input"
echo calc.at:646 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:646: cat stderr"
echo calc.at:646 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:646:  \$PREPARSER ./calc input"
echo calc.at:646 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:646: cat stderr"
echo calc.at:646 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:646:  \$PREPARSER ./calc input"
echo calc.at:646 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:646: cat stderr"
echo calc.at:646 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:646:  \$PREPARSER ./calc input"
echo calc.at:646 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:646: cat stderr"
echo calc.at:646 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:646:  \$PREPARSER ./calc input"
echo calc.at:646 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:646: cat stderr"
echo calc.at:646 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:646:  \$PREPARSER ./calc input"
echo calc.at:646 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:646: cat stderr"
echo calc.at:646 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:646:  \$PREPARSER ./calc input"
echo calc.at:646 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:646: cat stderr"
echo calc.at:646 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:646:  \$PREPARSER ./calc input"
echo calc.at:646 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:646: cat stderr"
echo calc.at:646 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:646"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_148
#AT_START_149
# 149. calc.at:648: Calculator %language "C++" %defines %locations %error-verbose %debug %name-prefix "calc" %verbose %yacc
at_setup_line='calc.at:648'
at_func_banner 12
at_desc="Calculator %language \"C++\" %defines %locations %error-verbose %debug %name-prefix \"calc\" %verbose %yacc"
$at_quiet $as_echo_n "149: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "149. calc.at:648: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%language "C++" %defines %locations %error-verbose %debug %name-prefix "calc" %verbose %yacc
%define global_tokens_and_yystype
%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE calc::location
#endif
#define first_line   begin.line
#define first_column begin.column
#define last_line    end.line
#define last_column  end.column
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}

/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++. */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C++ error reporting function.  */
void
calc::parser::error (const location& l, const std::string& m)
{
  (void) l;
  std::cerr << l << ": " << m << std::endl;
}

int
yyparse ()
{
  calc::parser parser;
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }


 (*llocp).first_column = (*llocp).last_column;
  (*llocp).first_line   = (*llocp).last_line;


  /* Skip white space.  */
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t')
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:648: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
echo calc.at:648 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:648: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
echo calc.at:648 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:648: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:648 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:648: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:648 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:648: bison -o calc.cc calc.y"
echo calc.at:648 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/calc.at:648: \$BISON_CXX_WORKS"
echo calc.at:648 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:648: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
echo calc.at:648 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS"; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:648:  \$PREPARSER ./calc input"
echo calc.at:648 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:648:  \$PREPARSER ./calc input"
echo calc.at:648 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:648: cat stderr"
echo calc.at:648 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:648:  \$PREPARSER ./calc input"
echo calc.at:648 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:648: cat stderr"
echo calc.at:648 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:648:  \$PREPARSER ./calc input"
echo calc.at:648 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:648: cat stderr"
echo calc.at:648 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:648:  \$PREPARSER ./calc input"
echo calc.at:648 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:648: cat stderr"
echo calc.at:648 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:648:  \$PREPARSER ./calc input"
echo calc.at:648 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:648: cat stderr"
echo calc.at:648 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:648:  \$PREPARSER ./calc input"
echo calc.at:648 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:648: cat stderr"
echo calc.at:648 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:648:  \$PREPARSER ./calc input"
echo calc.at:648 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:648: cat stderr"
echo calc.at:648 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:648:  \$PREPARSER ./calc input"
echo calc.at:648 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:648: cat stderr"
echo calc.at:648 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:648:  \$PREPARSER ./calc input"
echo calc.at:648 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:648: cat stderr"
echo calc.at:648 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:648:  \$PREPARSER ./calc input"
echo calc.at:648 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:648: cat stderr"
echo calc.at:648 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:648"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_149
#AT_START_150
# 150. calc.at:650: Calculator %language "C++" %defines %locations %pure-parser %error-verbose %debug %name-prefix "calc" %verbose %yacc
at_setup_line='calc.at:650'
at_func_banner 12
at_desc="Calculator %language \"C++\" %defines %locations %pure-parser %error-verbose %debug %name-prefix \"calc\" %verbose %yacc"
$at_quiet $as_echo_n "150: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "150. calc.at:650: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%language "C++" %defines %locations %pure-parser %error-verbose %debug %name-prefix "calc" %verbose %yacc
%define global_tokens_and_yystype
%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE calc::location
#endif
#define first_line   begin.line
#define first_column begin.column
#define last_line    end.line
#define last_column  end.column
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}

/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++. */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C++ error reporting function.  */
void
calc::parser::error (const location& l, const std::string& m)
{
  (void) l;
  std::cerr << l << ": " << m << std::endl;
}

int
yyparse ()
{
  calc::parser parser;
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }


 (*llocp).first_column = (*llocp).last_column;
  (*llocp).first_line   = (*llocp).last_line;


  /* Skip white space.  */
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t')
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:650: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
echo calc.at:650 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:650: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
echo calc.at:650 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:650: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:650 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:650: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:650 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:650: bison -o calc.cc calc.y"
echo calc.at:650 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/calc.at:650: \$BISON_CXX_WORKS"
echo calc.at:650 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:650: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
echo calc.at:650 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS"; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:650:  \$PREPARSER ./calc input"
echo calc.at:650 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:650:  \$PREPARSER ./calc input"
echo calc.at:650 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:650: cat stderr"
echo calc.at:650 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:650:  \$PREPARSER ./calc input"
echo calc.at:650 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:650: cat stderr"
echo calc.at:650 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:650:  \$PREPARSER ./calc input"
echo calc.at:650 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:650: cat stderr"
echo calc.at:650 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:650:  \$PREPARSER ./calc input"
echo calc.at:650 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:650: cat stderr"
echo calc.at:650 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:650:  \$PREPARSER ./calc input"
echo calc.at:650 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:650: cat stderr"
echo calc.at:650 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:650:  \$PREPARSER ./calc input"
echo calc.at:650 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:650: cat stderr"
echo calc.at:650 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:650:  \$PREPARSER ./calc input"
echo calc.at:650 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:650: cat stderr"
echo calc.at:650 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:650:  \$PREPARSER ./calc input"
echo calc.at:650 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:650: cat stderr"
echo calc.at:650 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:650:  \$PREPARSER ./calc input"
echo calc.at:650 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:650: cat stderr"
echo calc.at:650 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:650:  \$PREPARSER ./calc input"
echo calc.at:650 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:650: cat stderr"
echo calc.at:650 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:650"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_150
#AT_START_151
# 151. calc.at:652: Calculator %language "C++" %defines %locations %pure-parser %error-verbose %debug %name-prefix "calc" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}
at_setup_line='calc.at:652'
at_func_banner 12
at_desc="Calculator %language \"C++\" %defines %locations %pure-parser %error-verbose %debug %name-prefix \"calc\" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}"
$at_quiet $as_echo_n "151: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "151. calc.at:652: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%language "C++" %defines %locations %pure-parser %error-verbose %debug %name-prefix "calc" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}
%define global_tokens_and_yystype
%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE calc::location
#endif
#define first_line   begin.line
#define first_column begin.column
#define last_line    end.line
#define last_column  end.column
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}

/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++. */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         { ++*count; ++global_count; }
;

line:
  '\n'
| exp '\n'           { *result = global_result = $1; }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C++ error reporting function.  */
void
calc::parser::error (const location& l, const std::string& m)
{
  (void) l;
  std::cerr << l << ": " << m << std::endl;
}

int
yyparse (semantic_value *result, int *count)
{
  calc::parser parser (result, count);
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse (&result, &count);
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }


 (*llocp).first_column = (*llocp).last_column;
  (*llocp).first_line   = (*llocp).last_line;


  /* Skip white space.  */
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t')
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:652: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
echo calc.at:652 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:652: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
echo calc.at:652 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:652: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:652 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:652: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:652 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:652: bison -o calc.cc calc.y"
echo calc.at:652 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/calc.at:652: \$BISON_CXX_WORKS"
echo calc.at:652 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:652: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
echo calc.at:652 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS"; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:652:  \$PREPARSER ./calc input"
echo calc.at:652 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:652:  \$PREPARSER ./calc input"
echo calc.at:652 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:652: cat stderr"
echo calc.at:652 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:652:  \$PREPARSER ./calc input"
echo calc.at:652 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:652: cat stderr"
echo calc.at:652 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:652:  \$PREPARSER ./calc input"
echo calc.at:652 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:652: cat stderr"
echo calc.at:652 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:652:  \$PREPARSER ./calc input"
echo calc.at:652 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:652: cat stderr"
echo calc.at:652 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:652:  \$PREPARSER ./calc input"
echo calc.at:652 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:652: cat stderr"
echo calc.at:652 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:652:  \$PREPARSER ./calc input"
echo calc.at:652 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:652: cat stderr"
echo calc.at:652 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:652:  \$PREPARSER ./calc input"
echo calc.at:652 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:652: cat stderr"
echo calc.at:652 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:652:  \$PREPARSER ./calc input"
echo calc.at:652 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:652: cat stderr"
echo calc.at:652 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:652:  \$PREPARSER ./calc input"
echo calc.at:652 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:652: cat stderr"
echo calc.at:652 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:652:  \$PREPARSER ./calc input"
echo calc.at:652 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:652: cat stderr"
echo calc.at:652 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:652"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_151
#AT_START_152
# 152. calc.at:663: Calculator %skeleton "glr.cc" %defines %locations
at_setup_line='calc.at:663'
at_func_banner 13
at_desc="Calculator %skeleton \"glr.cc\" %defines %locations"
$at_quiet $as_echo_n "152: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "152. calc.at:663: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%skeleton "glr.cc" %defines %locations
%define global_tokens_and_yystype
%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE yy::location
#endif
#define first_line   begin.line
#define first_column begin.column
#define last_line    end.line
#define last_column  end.column
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}

/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++. */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C++ error reporting function.  */
void
yy::parser::error (const location& l, const std::string& m)
{
  (void) l;
  std::cerr << l << ": " << m << std::endl;
}

int
yyparse ()
{
  yy::parser parser;
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }


 (*llocp).first_column = (*llocp).last_column;
  (*llocp).first_line   = (*llocp).last_line;


  /* Skip white space.  */
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t')
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:663: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
echo calc.at:663 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:663: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
echo calc.at:663 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:663: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:663 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:663: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:663 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:663: bison -o calc.cc calc.y"
echo calc.at:663 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/calc.at:663: \$BISON_CXX_WORKS"
echo calc.at:663 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:663: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
echo calc.at:663 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS"; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:663:  \$PREPARSER ./calc input"
echo calc.at:663 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:663:  \$PREPARSER ./calc input"
echo calc.at:663 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:663: cat stderr"
echo calc.at:663 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:663:  \$PREPARSER ./calc input"
echo calc.at:663 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:663: cat stderr"
echo calc.at:663 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:663:  \$PREPARSER ./calc input"
echo calc.at:663 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:663: cat stderr"
echo calc.at:663 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:663:  \$PREPARSER ./calc input"
echo calc.at:663 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:663: cat stderr"
echo calc.at:663 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:663:  \$PREPARSER ./calc input"
echo calc.at:663 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:663: cat stderr"
echo calc.at:663 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:663:  \$PREPARSER ./calc input"
echo calc.at:663 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:663: cat stderr"
echo calc.at:663 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:663:  \$PREPARSER ./calc input"
echo calc.at:663 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:663: cat stderr"
echo calc.at:663 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:663:  \$PREPARSER ./calc input"
echo calc.at:663 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:663: cat stderr"
echo calc.at:663 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:663:  \$PREPARSER ./calc input"
echo calc.at:663 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:663: cat stderr"
echo calc.at:663 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:663:  \$PREPARSER ./calc input"
echo calc.at:663 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:663: cat stderr"
echo calc.at:663 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:663"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_152
#AT_START_153
# 153. calc.at:672: Calculator %language "C++" %glr-parser %defines %locations
at_setup_line='calc.at:672'
at_func_banner 13
at_desc="Calculator %language \"C++\" %glr-parser %defines %locations "
$at_quiet $as_echo_n "153: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "153. calc.at:672: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%language "C++" %glr-parser %defines %locations
%define global_tokens_and_yystype
%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE yy::location
#endif
#define first_line   begin.line
#define first_column begin.column
#define last_line    end.line
#define last_column  end.column
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}

/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++. */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C++ error reporting function.  */
void
yy::parser::error (const location& l, const std::string& m)
{
  (void) l;
  std::cerr << l << ": " << m << std::endl;
}

int
yyparse ()
{
  yy::parser parser;
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }


 (*llocp).first_column = (*llocp).last_column;
  (*llocp).first_line   = (*llocp).last_line;


  /* Skip white space.  */
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t')
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:672: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
echo calc.at:672 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:672: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
echo calc.at:672 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:672: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:672 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:672: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:672 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:672: bison -o calc.cc calc.y"
echo calc.at:672 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/calc.at:672: \$BISON_CXX_WORKS"
echo calc.at:672 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:672: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
echo calc.at:672 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS"; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:672:  \$PREPARSER ./calc input"
echo calc.at:672 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:672:  \$PREPARSER ./calc input"
echo calc.at:672 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:672: cat stderr"
echo calc.at:672 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:672:  \$PREPARSER ./calc input"
echo calc.at:672 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:672: cat stderr"
echo calc.at:672 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:672:  \$PREPARSER ./calc input"
echo calc.at:672 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:672: cat stderr"
echo calc.at:672 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:672:  \$PREPARSER ./calc input"
echo calc.at:672 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:672: cat stderr"
echo calc.at:672 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:672:  \$PREPARSER ./calc input"
echo calc.at:672 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:672: cat stderr"
echo calc.at:672 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:672:  \$PREPARSER ./calc input"
echo calc.at:672 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:672: cat stderr"
echo calc.at:672 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:672:  \$PREPARSER ./calc input"
echo calc.at:672 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:672: cat stderr"
echo calc.at:672 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:672:  \$PREPARSER ./calc input"
echo calc.at:672 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:672: cat stderr"
echo calc.at:672 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:672:  \$PREPARSER ./calc input"
echo calc.at:672 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:672: cat stderr"
echo calc.at:672 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:672:  \$PREPARSER ./calc input"
echo calc.at:672 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:672: cat stderr"
echo calc.at:672 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:672"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_153
#AT_START_154
# 154. calc.at:673: Calculator %language "C++" %glr-parser %defines %locations %error-verbose %name-prefix "calc" %verbose %yacc
at_setup_line='calc.at:673'
at_func_banner 13
at_desc="Calculator %language \"C++\" %glr-parser %defines %locations %error-verbose %name-prefix \"calc\" %verbose %yacc"
$at_quiet $as_echo_n "154: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "154. calc.at:673: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%language "C++" %glr-parser %defines %locations %error-verbose %name-prefix "calc" %verbose %yacc
%define global_tokens_and_yystype
%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE calc::location
#endif
#define first_line   begin.line
#define first_column begin.column
#define last_line    end.line
#define last_column  end.column
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}

/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++. */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C++ error reporting function.  */
void
calc::parser::error (const location& l, const std::string& m)
{
  (void) l;
  std::cerr << l << ": " << m << std::endl;
}

int
yyparse ()
{
  calc::parser parser;
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }


 (*llocp).first_column = (*llocp).last_column;
  (*llocp).first_line   = (*llocp).last_line;


  /* Skip white space.  */
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t')
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:673: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
echo calc.at:673 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:673: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
echo calc.at:673 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:673: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:673 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:673: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:673 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:673: bison -o calc.cc calc.y"
echo calc.at:673 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/calc.at:673: \$BISON_CXX_WORKS"
echo calc.at:673 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:673: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
echo calc.at:673 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS"; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:673:  \$PREPARSER ./calc input"
echo calc.at:673 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:673:  \$PREPARSER ./calc input"
echo calc.at:673 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:673: cat stderr"
echo calc.at:673 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:673:  \$PREPARSER ./calc input"
echo calc.at:673 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:673: cat stderr"
echo calc.at:673 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:673:  \$PREPARSER ./calc input"
echo calc.at:673 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:673: cat stderr"
echo calc.at:673 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:673:  \$PREPARSER ./calc input"
echo calc.at:673 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:673: cat stderr"
echo calc.at:673 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:673:  \$PREPARSER ./calc input"
echo calc.at:673 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:673: cat stderr"
echo calc.at:673 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:673:  \$PREPARSER ./calc input"
echo calc.at:673 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:673: cat stderr"
echo calc.at:673 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:673:  \$PREPARSER ./calc input"
echo calc.at:673 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:673: cat stderr"
echo calc.at:673 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:673:  \$PREPARSER ./calc input"
echo calc.at:673 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:673: cat stderr"
echo calc.at:673 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:673:  \$PREPARSER ./calc input"
echo calc.at:673 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:673: cat stderr"
echo calc.at:673 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:673:  \$PREPARSER ./calc input"
echo calc.at:673 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:673: cat stderr"
echo calc.at:673 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:673"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_154
#AT_START_155
# 155. calc.at:675: Calculator %language "C++" %glr-parser %defines %locations %debug
at_setup_line='calc.at:675'
at_func_banner 13
at_desc="Calculator %language \"C++\" %glr-parser %defines %locations %debug"
$at_quiet $as_echo_n "155: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "155. calc.at:675: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%language "C++" %glr-parser %defines %locations %debug
%define global_tokens_and_yystype
%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE yy::location
#endif
#define first_line   begin.line
#define first_column begin.column
#define last_line    end.line
#define last_column  end.column
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}

/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++. */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C++ error reporting function.  */
void
yy::parser::error (const location& l, const std::string& m)
{
  (void) l;
  std::cerr << l << ": " << m << std::endl;
}

int
yyparse ()
{
  yy::parser parser;
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }


 (*llocp).first_column = (*llocp).last_column;
  (*llocp).first_line   = (*llocp).last_line;


  /* Skip white space.  */
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t')
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:675: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
echo calc.at:675 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:675: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
echo calc.at:675 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:675: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:675 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:675: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:675 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:675: bison -o calc.cc calc.y"
echo calc.at:675 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/calc.at:675: \$BISON_CXX_WORKS"
echo calc.at:675 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:675: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
echo calc.at:675 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS"; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:675:  \$PREPARSER ./calc input"
echo calc.at:675 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:675:  \$PREPARSER ./calc input"
echo calc.at:675 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:675: cat stderr"
echo calc.at:675 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:675:  \$PREPARSER ./calc input"
echo calc.at:675 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:675: cat stderr"
echo calc.at:675 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:675:  \$PREPARSER ./calc input"
echo calc.at:675 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:675: cat stderr"
echo calc.at:675 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:675:  \$PREPARSER ./calc input"
echo calc.at:675 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:675: cat stderr"
echo calc.at:675 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:675:  \$PREPARSER ./calc input"
echo calc.at:675 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:675: cat stderr"
echo calc.at:675 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:675:  \$PREPARSER ./calc input"
echo calc.at:675 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:675: cat stderr"
echo calc.at:675 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:675:  \$PREPARSER ./calc input"
echo calc.at:675 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:675: cat stderr"
echo calc.at:675 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:675:  \$PREPARSER ./calc input"
echo calc.at:675 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:675: cat stderr"
echo calc.at:675 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:675:  \$PREPARSER ./calc input"
echo calc.at:675 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:675: cat stderr"
echo calc.at:675 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:675:  \$PREPARSER ./calc input"
echo calc.at:675 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:675: cat stderr"
echo calc.at:675 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:675"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_155
#AT_START_156
# 156. calc.at:676: Calculator %language "C++" %glr-parser %defines %locations %error-verbose %debug %name-prefix "calc" %verbose %yacc
at_setup_line='calc.at:676'
at_func_banner 13
at_desc="Calculator %language \"C++\" %glr-parser %defines %locations %error-verbose %debug %name-prefix \"calc\" %verbose %yacc"
$at_quiet $as_echo_n "156: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "156. calc.at:676: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%language "C++" %glr-parser %defines %locations %error-verbose %debug %name-prefix "calc" %verbose %yacc
%define global_tokens_and_yystype
%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE calc::location
#endif
#define first_line   begin.line
#define first_column begin.column
#define last_line    end.line
#define last_column  end.column
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}

/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++. */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C++ error reporting function.  */
void
calc::parser::error (const location& l, const std::string& m)
{
  (void) l;
  std::cerr << l << ": " << m << std::endl;
}

int
yyparse ()
{
  calc::parser parser;
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }


 (*llocp).first_column = (*llocp).last_column;
  (*llocp).first_line   = (*llocp).last_line;


  /* Skip white space.  */
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t')
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:676: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
echo calc.at:676 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:676: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
echo calc.at:676 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:676: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:676 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:676: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:676 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:676: bison -o calc.cc calc.y"
echo calc.at:676 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/calc.at:676: \$BISON_CXX_WORKS"
echo calc.at:676 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:676: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
echo calc.at:676 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS"; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:676:  \$PREPARSER ./calc input"
echo calc.at:676 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:676:  \$PREPARSER ./calc input"
echo calc.at:676 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:676: cat stderr"
echo calc.at:676 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:676:  \$PREPARSER ./calc input"
echo calc.at:676 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:676: cat stderr"
echo calc.at:676 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:676:  \$PREPARSER ./calc input"
echo calc.at:676 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:676: cat stderr"
echo calc.at:676 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:676:  \$PREPARSER ./calc input"
echo calc.at:676 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:676: cat stderr"
echo calc.at:676 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:676:  \$PREPARSER ./calc input"
echo calc.at:676 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:676: cat stderr"
echo calc.at:676 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:676:  \$PREPARSER ./calc input"
echo calc.at:676 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:676: cat stderr"
echo calc.at:676 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:676:  \$PREPARSER ./calc input"
echo calc.at:676 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:676: cat stderr"
echo calc.at:676 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:676:  \$PREPARSER ./calc input"
echo calc.at:676 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:676: cat stderr"
echo calc.at:676 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:676:  \$PREPARSER ./calc input"
echo calc.at:676 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:676: cat stderr"
echo calc.at:676 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:676:  \$PREPARSER ./calc input"
echo calc.at:676 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:676: cat stderr"
echo calc.at:676 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:676"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_156
#AT_START_157
# 157. calc.at:678: Calculator %language "C++" %glr-parser %defines %locations %pure-parser %error-verbose %debug %name-prefix "calc" %verbose %yacc
at_setup_line='calc.at:678'
at_func_banner 13
at_desc="Calculator %language \"C++\" %glr-parser %defines %locations %pure-parser %error-verbose %debug %name-prefix \"calc\" %verbose %yacc"
$at_quiet $as_echo_n "157: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "157. calc.at:678: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%language "C++" %glr-parser %defines %locations %pure-parser %error-verbose %debug %name-prefix "calc" %verbose %yacc
%define global_tokens_and_yystype
%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE calc::location
#endif
#define first_line   begin.line
#define first_column begin.column
#define last_line    end.line
#define last_column  end.column
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}

/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++. */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           { USE ($1); }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C++ error reporting function.  */
void
calc::parser::error (const location& l, const std::string& m)
{
  (void) l;
  std::cerr << l << ": " << m << std::endl;
}

int
yyparse ()
{
  calc::parser parser;
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse ();
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }


 (*llocp).first_column = (*llocp).last_column;
  (*llocp).first_line   = (*llocp).last_line;


  /* Skip white space.  */
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t')
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:678: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
echo calc.at:678 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:678: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
echo calc.at:678 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:678: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:678 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:678: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:678 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:678: bison -o calc.cc calc.y"
echo calc.at:678 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/calc.at:678: \$BISON_CXX_WORKS"
echo calc.at:678 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:678: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
echo calc.at:678 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS"; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:678:  \$PREPARSER ./calc input"
echo calc.at:678 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:678:  \$PREPARSER ./calc input"
echo calc.at:678 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:678: cat stderr"
echo calc.at:678 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:678:  \$PREPARSER ./calc input"
echo calc.at:678 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:678: cat stderr"
echo calc.at:678 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:678:  \$PREPARSER ./calc input"
echo calc.at:678 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:678: cat stderr"
echo calc.at:678 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:678:  \$PREPARSER ./calc input"
echo calc.at:678 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:678: cat stderr"
echo calc.at:678 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:678:  \$PREPARSER ./calc input"
echo calc.at:678 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:678: cat stderr"
echo calc.at:678 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:678:  \$PREPARSER ./calc input"
echo calc.at:678 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:678: cat stderr"
echo calc.at:678 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:678:  \$PREPARSER ./calc input"
echo calc.at:678 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:678: cat stderr"
echo calc.at:678 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:678:  \$PREPARSER ./calc input"
echo calc.at:678 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:678: cat stderr"
echo calc.at:678 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:678:  \$PREPARSER ./calc input"
echo calc.at:678 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:678: cat stderr"
echo calc.at:678 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:678:  \$PREPARSER ./calc input"
echo calc.at:678 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:678: cat stderr"
echo calc.at:678 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:678"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_157
#AT_START_158
# 158. calc.at:680: Calculator %language "C++" %glr-parser %defines %locations %pure-parser %error-verbose %debug %name-prefix "calc" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}
at_setup_line='calc.at:680'
at_func_banner 13
at_desc="Calculator %language \"C++\" %glr-parser %defines %locations %pure-parser %error-verbose %debug %name-prefix \"calc\" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}"
$at_quiet $as_echo_n "158: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "158. calc.at:680: testing ..."
  $at_traceon









# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.














cat >calc.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Infix notation calculator--calc */
%language "C++" %glr-parser %defines %locations %pure-parser %error-verbose %debug %name-prefix "calc" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}
%define global_tokens_and_yystype
%code requires {
/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;
}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%code provides {
#include <stdio.h>
/* The input.  */
extern FILE *input;
#ifndef YYLTYPE
# define YYLTYPE calc::location
#endif
#define first_line   begin.line
#define first_column begin.column
#define last_line    end.line
#define last_column  end.column
}

%code {
#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H && !_WIN32
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#define USE(Var)

FILE *input;
static semantic_value global_result = 0;
static int global_count = 0;
static int power (int base, int exponent);

int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
}

/* The lalr1.cc skeleton, for backward compatibility, defines
   a constructor for position that initializes the filename.  The
   glr.cc skeleton does not (and in fact cannot: location/position
   are stored in a union, from which objects with constructors are
   excluded in C++. */
%initial-action {
  @$.initialize (0);
}


/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         { ++*count; ++global_count; }
;

line:
  '\n'
| exp '\n'           { *result = global_result = $1; }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111; yyerrok;  }
| '!'                { $$ = 0; YYERROR;     }
| '-' error          { $$ = 0; YYERROR;     }
;
%%

/* A C++ error reporting function.  */
void
calc::parser::error (const location& l, const std::string& m)
{
  (void) l;
  std::cerr << l << ": " << m << std::endl;
}

int
yyparse (semantic_value *result, int *count)
{
  calc::parser parser (result, count);
#if YYDEBUG
  parser.set_debug_level (1);
#endif
  return parser.parse ();
}




static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (3);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  /* This used to be alarm (10), but that isn't enough time for
     a July 1995 vintage DEC Alphastation 200 4/100 system,
     according to Nelson H. F. Beebe.  100 seconds is enough.  */
  alarm (100);

  if (argc == 2)
    input = fopen (argv[1], "r");
  else
    input = stdin;

  if (!input)
    {
      perror (argv[1]);
      return 3;
    }


  status = yyparse (&result, &count);
  fclose (input);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF


cat >calc-lex.cc <<'_ATEOF'
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc

#include "calc.hh"

#include <ctype.h>

int calclex (YYSTYPE *lvalp, YYLTYPE *llocp);
static int get_char (YYSTYPE *lvalp, YYLTYPE *llocp);
static void unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c);


static YYLTYPE last_yylloc;

static int
get_char (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int res = getc (input);
  (void) lvalp;(void) llocp;

  last_yylloc = (*llocp);
  if (res == '\n')
    {
      (*llocp).last_line++;
      (*llocp).last_column = 1;
    }
  else
    (*llocp).last_column++;

  return res;
}

static void
unget_char (YYSTYPE *lvalp, YYLTYPE *llocp,  int c)
{
  (void) lvalp;(void) llocp;

  /* Wrong when C == `\n'. */
  (*llocp) = last_yylloc;

  ungetc (c, input);
}

static int
read_signed_integer (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  int c = get_char (lvalp, llocp);
  int sign = 1;
  int n = 0;

  (void) lvalp;(void) llocp;
  if (c == '-')
    {
      c = get_char (lvalp, llocp);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = get_char (lvalp, llocp);
    }

  unget_char (lvalp, llocp,  c);

  return sign * n;
}


/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

int
calclex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*llocp).last_column = 1;
      (*llocp).last_line = 1;

    }


 (*llocp).first_column = (*llocp).last_column;
  (*llocp).first_line   = (*llocp).last_line;


  /* Skip white space.  */
  while ((c = get_char (lvalp, llocp)) == ' ' || c == '\t')
    {
     (*llocp).first_column = (*llocp).last_column;
      (*llocp).first_line   = (*llocp).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      unget_char (lvalp, llocp,  c);
      (*lvalp).ival = read_signed_integer (lvalp, llocp);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}
_ATEOF





if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:680: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o calc.cc calc.y"
echo calc.at:680 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/calc.at:680: bison --xml=xml-tests/test.xml -o calc.cc calc.y"
echo calc.at:680 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:680: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo calc.at:680 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/calc.at:680: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo calc.at:680 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:680: bison -o calc.cc calc.y"
echo calc.at:680 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o calc.cc calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/calc.at:680: \$BISON_CXX_WORKS"
echo calc.at:680 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:680: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o calc calc.cc calc-lex.cc \$LIBS"
echo calc.at:680 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS"; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o calc calc.cc calc-lex.cc $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }



# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:680:  \$PREPARSER ./calc input"
echo calc.at:680 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:680:  \$PREPARSER ./calc input"
echo calc.at:680 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected number
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:680: cat stderr"
echo calc.at:680 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:680:  \$PREPARSER ./calc input"
echo calc.at:680 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:680: cat stderr"
echo calc.at:680 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:680:  \$PREPARSER ./calc input"
echo calc.at:680 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:680: cat stderr"
echo calc.at:680 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:680:  \$PREPARSER ./calc input"
echo calc.at:680 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:680: cat stderr"
echo calc.at:680 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:680:  \$PREPARSER ./calc input"
echo calc.at:680 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:680: cat stderr"
echo calc.at:680 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
cat >input <<'_ATEOF'
NUL
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:680:  \$PREPARSER ./calc input"
echo calc.at:680 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected end of input
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:680: cat stderr"
echo calc.at:680 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:680:  \$PREPARSER ./calc input"
echo calc.at:680 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.18: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1.23: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.41: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:680: cat stderr"
echo calc.at:680 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:680:  \$PREPARSER ./calc input"
echo calc.at:680 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.10: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:680: cat stderr"
echo calc.at:680 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:680:  \$PREPARSER ./calc input"
echo calc.at:680 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.4: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.12: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:680: cat stderr"
echo calc.at:680 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }



# Check that yyerrok works properly: second error is not reported,
# third and fourth are.  Parse status is succesfull.
cat >input <<'_ATEOF'
(* *) + (*) + (*)
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/calc.at:680:  \$PREPARSER ./calc input"
echo calc.at:680 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./calc input"; then
  ( $at_traceon;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./calc input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Return/d
/^Shifting/d
/^state/d
/^Cleanup:/d
/^Error:/d
/^Next/d
/^Now/d
/^Discarding/d
/ \$[0-9$]* = /d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.10: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1.16: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
{ $at_traceoff
$as_echo "$at_srcdir/calc.at:680: cat stderr"
echo calc.at:680 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/calc.at:680"

$at_failed && at_func_log_failure
$at_traceon; }



























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_158
#AT_START_159
# 159. torture.at:139: Big triangle
at_setup_line='torture.at:139'
at_func_banner 14
at_desc="Big triangle"
$at_quiet $as_echo_n "159: $at_desc                                   "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "159. torture.at:139: testing ..."
  $at_traceon


# I have been able to go up to 2000 on my machine.
# I tried 3000, a 29Mb grammar file, but then my system killed bison.
# With 500 and the new parser, which consume far too much memory,
# it gets killed too.  Of course the parser is to be cleaned.
cat >gengram.pl <<'_ATEOF'
#! /usr/bin/perl -w

use strict;
my $max = $ARGV[0] || 10;

print <<EOF;
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%error-verbose
%debug
%{
#include <stdio.h>
#include <stdlib.h>

static int yylex (void);
static void yyerror (const char *msg);
%}
%union
{
  int val;
};

%token END "end"
%type <val> exp input
EOF

for my $size (1 .. $max)
  {
    print "%token t$size $size \"$size\"\n";
  };

print <<EOF;
%%
input:
  exp        { if (\$1 != 0) abort (); \$\$ = \$1; }
| input exp  { if (\$2 != \$1 + 1) abort (); \$\$ = \$2; }
;

exp:
  END
    { \$\$ = 0; }
EOF

for my $size (1 .. $max)
  {
    use Text::Wrap;
    print wrap ("| ", "   ",
		(map { "\"$_\"" } (1 .. $size)),
		" END \n"),
		  "    { \$\$ = $size; }\n";
  };
print ";\n";

print <<EOF;
%%
static int
yylex (void)
{
  static int inner = 1;
  static int outer = 0;
  if (outer > $max)
    return 0;
  else if (inner > outer)
    {
      inner = 1;
      ++outer;
      return END;
    }
  return inner++;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\\n", msg);
}

int
main (void)
{
  yydebug = !!getenv ("YYDEBUG");
  return yyparse ();
}
EOF
_ATEOF


{ $at_traceoff
$as_echo "$at_srcdir/torture.at:145: perl -w ./gengram.pl 200 || exit 77"
echo torture.at:145 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; perl -w ./gengram.pl 200 || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; perl -w ./gengram.pl 200 || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/torture.at:145"

$at_failed && at_func_log_failure
$at_traceon; }

mv stdout input.y

{ $at_traceoff
$as_echo "$at_srcdir/torture.at:146: bison -v -o input.c input.y"
echo torture.at:146 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:146"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/torture.at:147: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo torture.at:147 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/torture.at:147"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/torture.at:148:  \$PREPARSER ./input"
echo torture.at:148 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input"; then
  ( $at_traceon;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:148"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_159
#AT_START_160
# 160. torture.at:232: Big horizontal
at_setup_line='torture.at:232'
at_func_banner 14
at_desc="Big horizontal"
$at_quiet $as_echo_n "160: $at_desc                                 "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "160. torture.at:232: testing ..."
  $at_traceon


# I have been able to go up to 10000 on my machine, but I had to
# increase the maximum stack size (* 100).  It gave:
#
# input.y      263k
# input.tab.c  1.3M
# input        453k
#
# gengram.pl 10000                 0.70s user 0.01s sys  99% cpu    0.711 total
# bison input.y                  730.56s user 0.53s sys  99% cpu 12:12.34 total
# gcc -Wall input.tab.c -o input   5.81s user 0.20s sys 100% cpu     6.01 total
# ./input                          0.00s user 0.01s sys 108% cpu     0.01 total
#
cat >gengram.pl <<'_ATEOF'
#! /usr/bin/perl -w

use strict;
my $max = $ARGV[0] || 10;

print <<EOF;
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%error-verbose
%debug
%{
#include <stdio.h>
#include <stdlib.h>

static int yylex (void);
static void yyerror (const char *msg);
%}

%token
EOF
for my $size (1 .. $max)
  {
    print "    t$size $size \"$size\"\n";
  };

print <<EOF;

%%
EOF

use Text::Wrap;
print
  wrap ("exp: ", "  ",
	(map { "\"$_\"" } (1 .. $max)), ";"),
  "\n";

print <<EOF;
%%
static int
yylex (void)
{
  static int counter = 1;
  if (counter <= $max)
    return counter++;
  if (counter++ != $max + 1)
    abort ();
  return 0;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\\n", msg);
}

int
main (void)
{
  yydebug = !!getenv ("YYDEBUG");
  return yyparse ();
}
EOF
_ATEOF


{ $at_traceoff
$as_echo "$at_srcdir/torture.at:246: perl -w ./gengram.pl 1000 || exit 77"
echo torture.at:246 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; perl -w ./gengram.pl 1000 || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; perl -w ./gengram.pl 1000 || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/torture.at:246"

$at_failed && at_func_log_failure
$at_traceon; }

mv stdout input.y


# GNU m4 requires about 70 MiB for this test on a 32-bit host.
# Ask for 200 MiB, which should be plenty even on a 64-bit host.
data_limit=`(ulimit -S -d) 2>/dev/null`
case $data_limit in
[0-9]*)
  if test "$data_limit" -lt 204000; then
    { $at_traceoff
$as_echo "$at_srcdir/torture.at:250: ulimit -S -d 204000 || exit 77"
echo torture.at:250 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ulimit -S -d 204000 || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ulimit -S -d 204000 || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:250"

$at_failed && at_func_log_failure
$at_traceon; }

    ulimit -S -d 204000
  fi
esac

{ $at_traceoff
$as_echo "$at_srcdir/torture.at:252: bison -v -o input.c input.y"
echo torture.at:252 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:252"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/torture.at:253: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo torture.at:253 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/torture.at:253"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/torture.at:254:  \$PREPARSER ./input"
echo torture.at:254 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input"; then
  ( $at_traceon;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:254"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_160
#AT_START_161
# 161. torture.at:372: Many lookahead tokens
at_setup_line='torture.at:372'
at_func_banner 14
at_desc="Many lookahead tokens"
$at_quiet $as_echo_n "161: $at_desc                          "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "161. torture.at:372: testing ..."
  $at_traceon


cat >gengram.pl <<'_ATEOF'
#! /usr/bin/perl -w

use strict;
use Text::Wrap;
my $max = $ARGV[0] || 10;

print <<EOF;
%error-verbose
%debug
%{
# include <stdio.h>
# include <stdlib.h>
# include <assert.h>

static int yylex (void);
static void yyerror (const char *msg);
%}
%union
{
  int val;
};

%type <val> input exp
%token token
EOF

print
  wrap ("%type <val> ",
	"            ",
	map { "n$_" } (1 .. $max)),
  "\n";

print "%token\n";
for my $count (1 .. $max)
  {
    print "    t$count $count \"$count\"\n";
  };

print <<EOF;
%%
input:
  exp        { assert (\$1 == 1); \$\$ = \$1; }
| input exp  { assert (\$2 == \$1 + 1); \$\$ = \$2; }
;

exp:
  n1 "1" { assert (\$1 == 1); \$\$ = \$1; }
EOF

for my $count (2 .. $max)
  {
    print "| n$count \"$count\" { assert (\$1 == $count); \$\$ = \$1; }\n";
  };
print ";\n";

for my $count (1 .. $max)
  {
    print "n$count: token { \$\$ = $count; };\n";
  };

print <<EOF;
%%
static int
yylex (void)
{
  static int return_token = 1;
  static int counter = 1;
  if (counter > $max)
    {
      if (counter++ != $max + 1)
	abort ();
      return 0;
    }
  if (return_token)
    {
      return_token = 0;
      return token;
    }
  return_token = 1;
  return counter++;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\\n", msg);
}

int
main (void)
{
  yydebug = !!getenv ("YYDEBUG");
  return yyparse ();
}
EOF
_ATEOF


{ $at_traceoff
$as_echo "$at_srcdir/torture.at:374: perl -w ./gengram.pl 1000 || exit 77"
echo torture.at:374 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; perl -w ./gengram.pl 1000 || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; perl -w ./gengram.pl 1000 || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/torture.at:374"

$at_failed && at_func_log_failure
$at_traceon; }

mv stdout input.y


# GNU m4 requires about 70 MiB for this test on a 32-bit host.
# Ask for 200 MiB, which should be plenty even on a 64-bit host.
data_limit=`(ulimit -S -d) 2>/dev/null`
case $data_limit in
[0-9]*)
  if test "$data_limit" -lt 204000; then
    { $at_traceoff
$as_echo "$at_srcdir/torture.at:378: ulimit -S -d 204000 || exit 77"
echo torture.at:378 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ulimit -S -d 204000 || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ulimit -S -d 204000 || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:378"

$at_failed && at_func_log_failure
$at_traceon; }

    ulimit -S -d 204000
  fi
esac

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/torture.at:380: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -v -o input.c input.y"
echo torture.at:380 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/torture.at:380"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/torture.at:380: bison --xml=xml-tests/test.xml -v -o input.c input.y"
echo torture.at:380 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/torture.at:380"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/torture.at:380: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo torture.at:380 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:380"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/torture.at:380: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo torture.at:380 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:380"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/torture.at:380: bison -v -o input.c input.y"
echo torture.at:380 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:380"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/torture.at:381: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo torture.at:381 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/torture.at:381"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/torture.at:382:  \$PREPARSER ./input"
echo torture.at:382 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input"; then
  ( $at_traceon;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:382"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_161
#AT_START_162
# 162. torture.at:473: Exploding the Stack Size with Alloca
at_setup_line='torture.at:473'
at_func_banner 14
at_desc="Exploding the Stack Size with Alloca"
$at_quiet $as_echo_n "162: $at_desc           "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "162. torture.at:473: testing ..."
  $at_traceon




# A grammar of parens growing the stack thanks to right recursion.
# exp:
cat >input.y <<'_ATEOF'
%{
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>

#if (defined __GNUC__ || defined __BUILTIN_VA_ARG_INCR \
     || defined _AIX || defined _MSC_VER || defined _ALLOCA_H)
# define YYSTACK_USE_ALLOCA 1
#endif

  static int yylex (void);
  static void yyerror (const char *msg);
%}

%error-verbose
%debug
%token WAIT_FOR_EOF
%%
exp: WAIT_FOR_EOF exp | ;
%%
static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  if (yylval < 0)
    abort ();
  if (yylval--)
    return WAIT_FOR_EOF;
  else
    return EOF;
}

int
main (int argc, const char **argv)
{
  char *endp;
  YYSTYPE yylval_init;
  if (argc != 2)
    abort ();
  yylval_init = strtol (argv[1], &endp, 10);
  if (! (argv[1] != endp
	 && 0 <= yylval_init && yylval_init <= INT_MAX
	 && errno != ERANGE))
    abort ();
  yydebug = 1;
  {
    int count;
    int status;
    for (count = 0; count < 2; ++count)
      {
        int new_status;
        yylval = yylval_init;
        new_status = yyparse ();
        if (count > 0 && new_status != status)
          abort ();
        status = new_status;
      }
    return status;
  }
}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/torture.at:482: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo torture.at:482 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/torture.at:482"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/torture.at:482: bison --xml=xml-tests/test.xml -o input.c input.y"
echo torture.at:482 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/torture.at:482"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/torture.at:482: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo torture.at:482 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:482"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/torture.at:482: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo torture.at:482 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:482"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/torture.at:482: bison -o input.c input.y"
echo torture.at:482 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:482"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/torture.at:482: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo torture.at:482 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/torture.at:482"

$at_failed && at_func_log_failure
$at_traceon; }



# Below the limit of 200.
{ $at_traceoff
$as_echo "$at_srcdir/torture.at:485: VALGRIND_OPTS=\"\$VALGRIND_OPTS --log-fd=1\" \$PREPARSER ./input 20"
echo torture.at:485 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --log-fd=1\" $PREPARSER ./input 20"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 20 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 20 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:485"

$at_failed && at_func_log_failure
$at_traceon; }

# Two enlargements: 2 * 2 * 200.
{ $at_traceoff
$as_echo "$at_srcdir/torture.at:488: VALGRIND_OPTS=\"\$VALGRIND_OPTS --log-fd=1\" \$PREPARSER ./input 900"
echo torture.at:488 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --log-fd=1\" $PREPARSER ./input 900"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 900 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 900 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:488"

$at_failed && at_func_log_failure
$at_traceon; }

# Fails: beyond the limit of 10,000 (which we don't reach anyway since we
# multiply by two starting at 200 => 5120 is the last possible).
{ $at_traceoff
$as_echo "$at_srcdir/torture.at:492: VALGRIND_OPTS=\"\$VALGRIND_OPTS --log-fd=1\" \$PREPARSER ./input 10000"
echo torture.at:492 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --log-fd=1\" $PREPARSER ./input 10000"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 10000 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 10000 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 2 $at_status "$at_srcdir/torture.at:492"

$at_failed && at_func_log_failure
$at_traceon; }


# The push parser can't use alloca since the stacks can't be locals.  This test
# just helps guarantee we don't let the YYSTACK_USE_ALLOCA feature affect
# push parsers.
# A grammar of parens growing the stack thanks to right recursion.
# exp:
cat >input.y <<'_ATEOF'
%{
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>

#if (defined __GNUC__ || defined __BUILTIN_VA_ARG_INCR \
     || defined _AIX || defined _MSC_VER || defined _ALLOCA_H)
# define YYSTACK_USE_ALLOCA 1
#endif

  static int yylex (void);
  static void yyerror (const char *msg);
%}
%define api.push_pull "both"

%error-verbose
%debug
%token WAIT_FOR_EOF
%%
exp: WAIT_FOR_EOF exp | ;
%%
static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  if (yylval < 0)
    abort ();
  if (yylval--)
    return WAIT_FOR_EOF;
  else
    return EOF;
}

int
main (int argc, const char **argv)
{
  char *endp;
  YYSTYPE yylval_init;
  if (argc != 2)
    abort ();
  yylval_init = strtol (argv[1], &endp, 10);
  if (! (argv[1] != endp
	 && 0 <= yylval_init && yylval_init <= INT_MAX
	 && errno != ERANGE))
    abort ();
  yydebug = 1;
  {
    int count;
    int status;
    for (count = 0; count < 2; ++count)
      {
        int new_status;
        yylval = yylval_init;
        new_status = yyparse ();
        if (count > 0 && new_status != status)
          abort ();
        status = new_status;
      }
    return status;
  }
}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/torture.at:498: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo torture.at:498 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/torture.at:498"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/torture.at:498: bison --xml=xml-tests/test.xml -o input.c input.y"
echo torture.at:498 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/torture.at:498"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/torture.at:498: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo torture.at:498 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:498"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/torture.at:498: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo torture.at:498 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:498"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/torture.at:498: bison -o input.c input.y"
echo torture.at:498 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:498"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/torture.at:498: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo torture.at:498 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/torture.at:498"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/torture.at:501: VALGRIND_OPTS=\"\$VALGRIND_OPTS --log-fd=1\" \$PREPARSER ./input 20"
echo torture.at:501 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --log-fd=1\" $PREPARSER ./input 20"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 20 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 20 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:501"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/torture.at:503: VALGRIND_OPTS=\"\$VALGRIND_OPTS --log-fd=1\" \$PREPARSER ./input 900"
echo torture.at:503 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --log-fd=1\" $PREPARSER ./input 900"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 900 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 900 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:503"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/torture.at:505: VALGRIND_OPTS=\"\$VALGRIND_OPTS --log-fd=1\" \$PREPARSER ./input 10000"
echo torture.at:505 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --log-fd=1\" $PREPARSER ./input 10000"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 10000 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 10000 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 2 $at_status "$at_srcdir/torture.at:505"

$at_failed && at_func_log_failure
$at_traceon; }




  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_162
#AT_START_163
# 163. torture.at:519: Exploding the Stack Size with Malloc
at_setup_line='torture.at:519'
at_func_banner 14
at_desc="Exploding the Stack Size with Malloc"
$at_quiet $as_echo_n "163: $at_desc           "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "163. torture.at:519: testing ..."
  $at_traceon




# A grammar of parens growing the stack thanks to right recursion.
# exp:
cat >input.y <<'_ATEOF'
%{
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#define YYSTACK_USE_ALLOCA 0
  static int yylex (void);
  static void yyerror (const char *msg);
%}

%error-verbose
%debug
%token WAIT_FOR_EOF
%%
exp: WAIT_FOR_EOF exp | ;
%%
static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  if (yylval < 0)
    abort ();
  if (yylval--)
    return WAIT_FOR_EOF;
  else
    return EOF;
}

int
main (int argc, const char **argv)
{
  char *endp;
  YYSTYPE yylval_init;
  if (argc != 2)
    abort ();
  yylval_init = strtol (argv[1], &endp, 10);
  if (! (argv[1] != endp
	 && 0 <= yylval_init && yylval_init <= INT_MAX
	 && errno != ERANGE))
    abort ();
  yydebug = 1;
  {
    int count;
    int status;
    for (count = 0; count < 2; ++count)
      {
        int new_status;
        yylval = yylval_init;
        new_status = yyparse ();
        if (count > 0 && new_status != status)
          abort ();
        status = new_status;
      }
    return status;
  }
}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/torture.at:523: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo torture.at:523 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/torture.at:523"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/torture.at:523: bison --xml=xml-tests/test.xml -o input.c input.y"
echo torture.at:523 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/torture.at:523"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/torture.at:523: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo torture.at:523 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:523"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/torture.at:523: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo torture.at:523 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:523"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/torture.at:523: bison -o input.c input.y"
echo torture.at:523 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:523"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/torture.at:523: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo torture.at:523 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/torture.at:523"

$at_failed && at_func_log_failure
$at_traceon; }



# Below the limit of 200.
{ $at_traceoff
$as_echo "$at_srcdir/torture.at:526: VALGRIND_OPTS=\"\$VALGRIND_OPTS --log-fd=1\" \$PREPARSER ./input 20"
echo torture.at:526 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --log-fd=1\" $PREPARSER ./input 20"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 20 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 20 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:526"

$at_failed && at_func_log_failure
$at_traceon; }

# Two enlargements: 2 * 2 * 200.
{ $at_traceoff
$as_echo "$at_srcdir/torture.at:529: VALGRIND_OPTS=\"\$VALGRIND_OPTS --log-fd=1\" \$PREPARSER ./input 900"
echo torture.at:529 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --log-fd=1\" $PREPARSER ./input 900"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 900 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 900 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:529"

$at_failed && at_func_log_failure
$at_traceon; }

# Fails: beyond the limit of 10,000 (which we don't reach anyway since we
# multiply by two starting at 200 => 5120 is the possible).
{ $at_traceoff
$as_echo "$at_srcdir/torture.at:533: VALGRIND_OPTS=\"\$VALGRIND_OPTS --log-fd=1\" \$PREPARSER ./input 10000"
echo torture.at:533 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --log-fd=1\" $PREPARSER ./input 10000"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 10000 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 10000 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 2 $at_status "$at_srcdir/torture.at:533"

$at_failed && at_func_log_failure
$at_traceon; }


# A grammar of parens growing the stack thanks to right recursion.
# exp:
cat >input.y <<'_ATEOF'
%{
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#define YYSTACK_USE_ALLOCA 0
  static int yylex (void);
  static void yyerror (const char *msg);
%}
%define api.push_pull "both"

%error-verbose
%debug
%token WAIT_FOR_EOF
%%
exp: WAIT_FOR_EOF exp | ;
%%
static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  if (yylval < 0)
    abort ();
  if (yylval--)
    return WAIT_FOR_EOF;
  else
    return EOF;
}

int
main (int argc, const char **argv)
{
  char *endp;
  YYSTYPE yylval_init;
  if (argc != 2)
    abort ();
  yylval_init = strtol (argv[1], &endp, 10);
  if (! (argv[1] != endp
	 && 0 <= yylval_init && yylval_init <= INT_MAX
	 && errno != ERANGE))
    abort ();
  yydebug = 1;
  {
    int count;
    int status;
    for (count = 0; count < 2; ++count)
      {
        int new_status;
        yylval = yylval_init;
        new_status = yyparse ();
        if (count > 0 && new_status != status)
          abort ();
        status = new_status;
      }
    return status;
  }
}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/torture.at:536: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo torture.at:536 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/torture.at:536"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/torture.at:536: bison --xml=xml-tests/test.xml -o input.c input.y"
echo torture.at:536 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/torture.at:536"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/torture.at:536: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo torture.at:536 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:536"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/torture.at:536: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo torture.at:536 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:536"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/torture.at:536: bison -o input.c input.y"
echo torture.at:536 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:536"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/torture.at:536: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo torture.at:536 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/torture.at:536"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/torture.at:539: VALGRIND_OPTS=\"\$VALGRIND_OPTS --log-fd=1\" \$PREPARSER ./input 20"
echo torture.at:539 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --log-fd=1\" $PREPARSER ./input 20"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 20 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 20 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:539"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/torture.at:541: VALGRIND_OPTS=\"\$VALGRIND_OPTS --log-fd=1\" \$PREPARSER ./input 900"
echo torture.at:541 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --log-fd=1\" $PREPARSER ./input 900"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 900 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 900 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/torture.at:541"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/torture.at:543: VALGRIND_OPTS=\"\$VALGRIND_OPTS --log-fd=1\" \$PREPARSER ./input 10000"
echo torture.at:543 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --log-fd=1\" $PREPARSER ./input 10000"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 10000 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --log-fd=1" $PREPARSER ./input 10000 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 2 $at_status "$at_srcdir/torture.at:543"

$at_failed && at_func_log_failure
$at_traceon; }




  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_163
#AT_START_164
# 164. existing.at:24: GNU AWK Grammar
at_setup_line='existing.at:24'
at_func_banner 15
at_desc="GNU AWK Grammar"
$at_quiet $as_echo_n "164: $at_desc                                "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "164. existing.at:24: testing ..."
  $at_traceon


# We have been careful to strip all the actions excepts the
# mid-rule actions.  We rely on %expect to check that there are
# indeed 65 SR conflicts.
#
# Bison was once wrong, due to an incorrect computation of nullable.
# It reported 485 SR conflicts!

cat >input.y <<'_ATEOF'
%expect 65

%token FUNC_CALL NAME REGEXP
%token ERROR
%token YNUMBER YSTRING
%token RELOP APPEND_OP
%token ASSIGNOP MATCHOP NEWLINE CONCAT_OP
%token LEX_BEGIN LEX_END LEX_IF LEX_ELSE LEX_RETURN LEX_DELETE
%token LEX_WHILE LEX_DO LEX_FOR LEX_BREAK LEX_CONTINUE
%token LEX_PRINT LEX_PRINTF LEX_NEXT LEX_EXIT LEX_FUNCTION
%token LEX_GETLINE LEX_NEXTFILE
%token LEX_IN
%token LEX_AND LEX_OR INCREMENT DECREMENT
%token LEX_BUILTIN LEX_LENGTH

/* Lowest to highest */
%right ASSIGNOP
%right '?' ':'
%left LEX_OR
%left LEX_AND
%left LEX_GETLINE
%nonassoc LEX_IN
%left FUNC_CALL LEX_BUILTIN LEX_LENGTH
%nonassoc ','
%nonassoc MATCHOP
%nonassoc RELOP '<' '>' '|' APPEND_OP TWOWAYIO
%left CONCAT_OP
%left YSTRING YNUMBER
%left '+' '-'
%left '*' '/' '%'
%right '!' UNARY
%right '^'
%left INCREMENT DECREMENT
%left '$'
%left '(' ')'
%%

start
	: opt_nls program opt_nls
	;

program
	: rule
	| program rule
	| error
	| program error
	| /* empty */
	;

rule
	: LEX_BEGIN {} action
	| LEX_END {}   action
	| LEX_BEGIN statement_term
	| LEX_END statement_term
	| pattern action
	| action
	| pattern statement_term
	| function_prologue function_body
	;

func_name
	: NAME
	| FUNC_CALL
	| lex_builtin
	;

lex_builtin
	: LEX_BUILTIN
	| LEX_LENGTH
	;

function_prologue
	: LEX_FUNCTION {} func_name '(' opt_param_list r_paren opt_nls
	;

function_body
	: l_brace statements r_brace opt_semi opt_nls
	| l_brace r_brace opt_semi opt_nls
	;

pattern
	: exp
	| exp ',' exp
	;

regexp
	/*
	 * In this rule, want_regexp tells yylex that the next thing
	 * is a regexp so it should read up to the closing slash.
	 */
	: '/' {} REGEXP '/'
	;

action
	: l_brace statements r_brace opt_semi opt_nls
	| l_brace r_brace opt_semi opt_nls
	;

statements
	: statement
	| statements statement
	| error
	| statements error
	;

statement_term
	: nls
	| semi opt_nls
	;

statement
	: semi opt_nls
	| l_brace r_brace
	| l_brace statements r_brace
	| if_statement
	| LEX_WHILE '(' exp r_paren opt_nls statement
	| LEX_DO opt_nls statement LEX_WHILE '(' exp r_paren opt_nls
	| LEX_FOR '(' NAME LEX_IN NAME r_paren opt_nls statement
	| LEX_FOR '(' opt_exp semi opt_nls exp semi opt_nls opt_exp r_paren opt_nls statement
	| LEX_FOR '(' opt_exp semi opt_nls semi opt_nls opt_exp r_paren opt_nls statement
	| LEX_BREAK statement_term
	| LEX_CONTINUE statement_term
	| print '(' expression_list r_paren output_redir statement_term
	| print opt_rexpression_list output_redir statement_term
	| LEX_NEXT statement_term
	| LEX_NEXTFILE statement_term
	| LEX_EXIT opt_exp statement_term
	| LEX_RETURN {} opt_exp statement_term
	| LEX_DELETE NAME '[' expression_list ']' statement_term
	| LEX_DELETE NAME  statement_term
	| exp statement_term
	;

print
	: LEX_PRINT
	| LEX_PRINTF
	;

if_statement
	: LEX_IF '(' exp r_paren opt_nls statement
	| LEX_IF '(' exp r_paren opt_nls statement
	     LEX_ELSE opt_nls statement
	;

nls
	: NEWLINE
	| nls NEWLINE
	;

opt_nls
	: /* empty */
	| nls
	;

input_redir
	: /* empty */
	| '<' simp_exp
	;

output_redir
	: /* empty */
	| '>' exp
	| APPEND_OP exp
	| '|' exp
	| TWOWAYIO exp
	;

opt_param_list
	: /* empty */
	| param_list
	;

param_list
	: NAME
	| param_list comma NAME
	| error
	| param_list error
	| param_list comma error
	;

/* optional expression, as in for loop */
opt_exp
	: /* empty */
	| exp
	;

opt_rexpression_list
	: /* empty */
	| rexpression_list
	;

rexpression_list
	: rexp
	| rexpression_list comma rexp
	| error
	| rexpression_list error
	| rexpression_list error rexp
	| rexpression_list comma error
	;

opt_expression_list
	: /* empty */
	| expression_list
	;

expression_list
	: exp
	| expression_list comma exp
	| error
	| expression_list error
	| expression_list error exp
	| expression_list comma error
	;

/* Expressions, not including the comma operator.  */
exp	: variable ASSIGNOP {} exp
	| '(' expression_list r_paren LEX_IN NAME
	| exp '|' LEX_GETLINE opt_variable
	| exp TWOWAYIO LEX_GETLINE opt_variable
	| LEX_GETLINE opt_variable input_redir
	| exp LEX_AND exp
	| exp LEX_OR exp
	| exp MATCHOP exp
	| regexp
	| '!' regexp %prec UNARY
	| exp LEX_IN NAME
	| exp RELOP exp
	| exp '<' exp
	| exp '>' exp
	| exp '?' exp ':' exp
	| simp_exp
	| exp simp_exp %prec CONCAT_OP
	;

rexp
	: variable ASSIGNOP {} rexp
	| rexp LEX_AND rexp
	| rexp LEX_OR rexp
	| LEX_GETLINE opt_variable input_redir
	| regexp
	| '!' regexp %prec UNARY
	| rexp MATCHOP rexp
	| rexp LEX_IN NAME
	| rexp RELOP rexp
	| rexp '?' rexp ':' rexp
	| simp_exp
	| rexp simp_exp %prec CONCAT_OP
	;

simp_exp
	: non_post_simp_exp
	/* Binary operators in order of decreasing precedence.  */
	| simp_exp '^' simp_exp
	| simp_exp '*' simp_exp
	| simp_exp '/' simp_exp
	| simp_exp '%' simp_exp
	| simp_exp '+' simp_exp
	| simp_exp '-' simp_exp
	| variable INCREMENT
	| variable DECREMENT
	;

non_post_simp_exp
	: '!' simp_exp %prec UNARY
	| '(' exp r_paren
	| LEX_BUILTIN
	  '(' opt_expression_list r_paren
	| LEX_LENGTH '(' opt_expression_list r_paren
	| LEX_LENGTH
	| FUNC_CALL '(' opt_expression_list r_paren
	| variable
	| INCREMENT variable
	| DECREMENT variable
	| YNUMBER
	| YSTRING
	| '-' simp_exp    %prec UNARY
	| '+' simp_exp    %prec UNARY
	;

opt_variable
	: /* empty */
	| variable
	;

variable
	: NAME
	| NAME '[' expression_list ']'
	| '$' non_post_simp_exp
	;

l_brace
	: '{' opt_nls
	;

r_brace
	: '}' opt_nls
	;

r_paren
	: ')'
	;

opt_semi
	: /* empty */
	| semi
	;

semi
	: ';'
	;

comma	: ',' opt_nls
	;

%%
_ATEOF


# Pass plenty of options, to exercise plenty of code, even if we
# don't actually check the output.  But SEGV is watching us, and
# so might do dmalloc.
if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/existing.at:354: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --verbose --defines input.y"
echo existing.at:354 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --verbose --defines input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --verbose --defines input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/existing.at:354"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/existing.at:354: bison --xml=xml-tests/test.xml --verbose --defines input.y"
echo existing.at:354 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml --verbose --defines input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml --verbose --defines input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/existing.at:354"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/existing.at:354: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo existing.at:354 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/existing.at:354"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/existing.at:354: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo existing.at:354 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/existing.at:354"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/existing.at:354: bison --verbose --defines input.y"
echo existing.at:354 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --verbose --defines input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --verbose --defines input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/existing.at:354"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_164
#AT_START_165
# 165. existing.at:362: GNU Cim Grammar
at_setup_line='existing.at:362'
at_func_banner 15
at_desc="GNU Cim Grammar"
$at_quiet $as_echo_n "165: $at_desc                                "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "165. existing.at:362: testing ..."
  $at_traceon


# GNU Cim, the GNU Simula 87 Compiler.

# Bison was once wrong, due to an incorrect computation of the RR conflicts.
# It reported 80 SR && 99 RR conflicts instead of 78/10!!!

cat >input.y <<'_ATEOF'
%union {}

%token
	HACTIVATE HAFTER /*HAND*/ HARRAY HAT
	HBEFORE HBEGIN HBOOLEAN
	HCHARACTER HCLASS /*HCOMMENT*/ HCONC
	HDELAY HDO
	HELSE HEND HEQ /*HEQV*/ HEXTERNAL
	HFOR
	HGE HGO HGOTO HGT
	HHIDDEN
	HIF /*HIMP*/ HIN HINNER HINSPECT HINTEGER HIS
	HLABEL HLE HLONG HLT
	HNAME HNE HNEW HNONE /*HNOT*/ HNOTEXT
	/*HOR*/ HOTHERWISE
	HPRIOR HPROCEDURE HPROTECTED
	HQUA
	HREACTIVATE HREAL HREF
	HSHORT HSTEP HSWITCH
	HTEXT HTHEN HTHIS HTO
	HUNTIL
	HVALUE HVAR HVIRTUAL
	HWHEN HWHILE

	HASSIGNVALUE HASSIGNREF
	/*HDOT*/ HPAREXPSEPARATOR HLABELSEPARATOR HSTATEMENTSEPARATOR
	HBEGPAR HENDPAR
	HEQR HNER
	HADD HSUB HMUL HDIV HINTDIV HEXP
	HDOTDOTDOT

%token HIDENTIFIER
%token HBOOLEANKONST HINTEGERKONST HCHARACTERKONST
%token HREALKONST
%token HTEXTKONST


%right HASSIGN
%left   HORELSE
%left   HANDTHEN
%left   HEQV
%left   HIMP
%left   HOR
%left   HAND

%left   HNOT

%left HVALRELOPERATOR HREFRELOPERATOR HOBJRELOPERATOR

%left	HCONC

%left HTERMOPERATOR
%left UNEAR
%left HFACTOROPERATOR
%left         HPRIMARYOPERATOR

%left   HQUA

%left   HDOT

%start  MAIN_MODULE
%%
/* GRAMATIKK FOR PROGRAM MODULES */
MAIN_MODULE     :       {}
			MODULS
		|	error HSTATEMENTSEPARATOR MBEE_DECLSTMS
		;
EXT_DECLARATION	:	HEXTERNAL
			MBEE_TYPE
			HPROCEDURE
				{}
			EXT_LIST
		|
			HEXTERNAL
			HIDENTIFIER
			HPROCEDURE
				{}
			HIDENTIFIER {}
			EXTERNAL_KIND_ITEM
		|	HEXTERNAL
			HCLASS
				{}
			EXT_LIST

		;
EXTERNAL_KIND_ITEM:	EXT_IDENT
			HOBJRELOPERATOR
				{}
			MBEE_TYPE HPROCEDURE
			HIDENTIFIER
				{}
			HEADING EMPTY_BLOCK
				{}
/*		|
			EXT_IDENT
				{}
			MBEE_REST_EXT_LIST
		;
MBEE_REST_EXT_LIST:	/* EMPTY
		|	HPAREXPSEPARATOR EXT_KIND_LIST
		;
EXT_KIND_LIST	:	EXT_KIND_ITEM
		|	EXT_KIND_LIST HPAREXPSEPARATOR EXT_KIND_ITEM
		;
EXT_KIND_ITEM	:	HIDENTIFIER
			EXT_IDENT
				{}*/
		;
EMPTY_BLOCK	:	/*EMPT*/
		|	HBEGIN HEND
		;
EXT_LIST	:	EXT_ITEM
		|	EXT_LIST HPAREXPSEPARATOR EXT_ITEM
		;
EXT_ITEM	:	HIDENTIFIER
			EXT_IDENT
		;
EXT_IDENT	:	/* EMPTY */
		|	HVALRELOPERATOR {}
			HTEXTKONST
		;
/* GRAMATIKK FOR TYPER */
NO_TYPE         :       /*EMPT*/
		;
MBEE_TYPE       :       NO_TYPE
		|       TYPE
		;
TYPE            :       HREF HBEGPAR
			HIDENTIFIER
				{}
			HENDPAR
		|       HTEXT
		|       HBOOLEAN
		|       HCHARACTER
		|       HSHORT HINTEGER
		|       HINTEGER
		|       HREAL
		|       HLONG HREAL
		;

/* GRAMATIKK FOR DEL AV SETNINGER */
MBEE_ELSE_PART  :       /*EMPT*/
/*		|	HELSE
			HIF
			EXPRESSION
			HTHEN   {}
			BLOCK   {}
			MBEE_ELSE_PART          {}*/
		|       HELSE   {}
			BLOCK
		;
FOR_LIST        :       FOR_LIST_ELEMENT
		|       FOR_LIST_ELEMENT
			HPAREXPSEPARATOR
			FOR_LIST
		;
FOR_LIST_ELEMENT:       EXPRESSION
			MBEE_F_L_EL_R_PT
		;
MBEE_F_L_EL_R_PT:       /*EMPT*/
		|       HWHILE
			EXPRESSION
		|       HSTEP
			EXPRESSION
			HUNTIL
			EXPRESSION
		;
GOTO            :       HGO
			HTO
		|       HGOTO
		;
CONN_STATE_R_PT :       WHEN_CLAUSE_LIST
		|       HDO   {}
			BLOCK
		;
WHEN_CLAUSE_LIST:       HWHEN
			HIDENTIFIER
			HDO    {}
			BLOCK
		|       WHEN_CLAUSE_LIST
			HWHEN
			HIDENTIFIER
			HDO    {}
			BLOCK
		;
MBEE_OTWI_CLAUS :       /*EMPT*/
		|       HOTHERWISE {}

			BLOCK
		;
ACTIVATOR	:	HACTIVATE
		|	HREACTIVATE
		;
SCHEDULE	:	/*EMPT*/
		|	ATDELAY EXPRESSION	{}
			PRIOR
		|	BEFOREAFTER		{}
			EXPRESSION
		;
ATDELAY		:	HAT
		|	HDELAY
		;
BEFOREAFTER	:	HBEFORE
		|	HAFTER
		;
PRIOR		:	/*EMPT*/
		|	HPRIOR
		;
/* GRAMATIKK FOR SETNINGER OG DEKLARASJONER */
MODULSTATEMENT  :       HWHILE
			EXPRESSION
			HDO     {}
			BLOCK
		|       HIF
			EXPRESSION
			HTHEN   {}
			BLOCK   {}
			MBEE_ELSE_PART
		|       HFOR
			HIDENTIFIER
			HASSIGN {}
			FOR_LIST
			HDO     {}
			BLOCK
		|       GOTO
			EXPRESSION
		|       HINSPECT
			EXPRESSION              {}
			CONN_STATE_R_PT
				{}
			MBEE_OTWI_CLAUS
		|       HINNER
		|       HIDENTIFIER
			HLABELSEPARATOR
				{}
			DECLSTATEMENT
		|       EXPRESSION_SIMP
			HBEGIN
				{}
			IMPORT_SPEC_MODULE
				{}
			MBEE_DECLSTMS
			HEND
		|	EXPRESSION_SIMP HBEGIN error HSTATEMENTSEPARATOR
			MBEE_DECLSTMS HEND
		|	EXPRESSION_SIMP HBEGIN error HEND
		|       EXPRESSION_SIMP
		|	ACTIVATOR EXPRESSION SCHEDULE
		|       HBEGIN
				{}
			MBEE_DECLSTMS
			HEND
		|       MBEE_TYPE HPROCEDURE
			HIDENTIFIER
				{}
			HEADING BLOCK
		|       HIDENTIFIER
			HCLASS
			NO_TYPE
				{}
			IMPORT_SPEC_MODULE
			HIDENTIFIER
				{}
			HEADING
			BLOCK
		|       HCLASS
			NO_TYPE
			HIDENTIFIER
				{}
			HEADING
			BLOCK
		|       EXT_DECLARATION
		|       /*EMPT*/
		;
IMPORT_SPEC_MODULE:
		;
DECLSTATEMENT	:	MODULSTATEMENT
		|       TYPE
			HIDENTIFIER
			MBEE_CONSTANT
			HPAREXPSEPARATOR
				{}
			IDENTIFIER_LISTC
		|       TYPE
			HIDENTIFIER
			MBEE_CONSTANT
		|       MBEE_TYPE
			HARRAY  {}
			ARR_SEGMENT_LIST
		|       HSWITCH
			HIDENTIFIER
			HASSIGN {}
			SWITCH_LIST
		;
BLOCK           :       DECLSTATEMENT
		|       HBEGIN MBEE_DECLSTMS HEND
		|	HBEGIN error HSTATEMENTSEPARATOR MBEE_DECLSTMS HEND
		|	HBEGIN error HEND
		;
MBEE_DECLSTMS   :       MBEE_DECLSTMSU
		;
MBEE_DECLSTMSU  :       DECLSTATEMENT
		|       MBEE_DECLSTMSU
			HSTATEMENTSEPARATOR
			DECLSTATEMENT
		;
MODULS		:	MODULSTATEMENT
		|	MODULS HSTATEMENTSEPARATOR MODULSTATEMENT
		;
/* GRAMATIKK FOR DEL AV DEKLARASJONER */
ARR_SEGMENT_LIST:       ARR_SEGMENT
		|       ARR_SEGMENT_LIST
			HPAREXPSEPARATOR
			ARR_SEGMENT
		;
ARR_SEGMENT	:       ARRAY_SEGMENT
			HBEGPAR
			BAUND_PAIR_LIST HENDPAR
		;
ARRAY_SEGMENT   :       ARRAY_SEGMENT_EL        {}

		|       ARRAY_SEGMENT_EL
			HPAREXPSEPARATOR
			ARRAY_SEGMENT
		;
ARRAY_SEGMENT_EL:       HIDENTIFIER
		;
BAUND_PAIR_LIST :       BAUND_PAIR
		|       BAUND_PAIR
			HPAREXPSEPARATOR
			BAUND_PAIR_LIST
		;
BAUND_PAIR      :       EXPRESSION
			HLABELSEPARATOR
			EXPRESSION
		;
SWITCH_LIST     :       EXPRESSION
		|       EXPRESSION
			HPAREXPSEPARATOR
			SWITCH_LIST
		;
HEADING         :       MBEE_FMAL_PAR_P HSTATEMENTSEPARATOR {}
			MBEE_MODE_PART  {}
			MBEE_SPEC_PART  {}
			MBEE_PROT_PART  {}
			MBEE_VIRT_PART
		;
MBEE_FMAL_PAR_P :       /*EMPT*/
		|       FMAL_PAR_PART
		;
FMAL_PAR_PART   :       HBEGPAR NO_TYPE
			MBEE_LISTV HENDPAR
		;
MBEE_LISTV      :       /*EMPT*/
		|       LISTV
		;
LISTV           :       HIDENTIFIER
		|	FPP_CATEG HDOTDOTDOT
		|       HIDENTIFIER     {}
			HPAREXPSEPARATOR LISTV
		|       FPP_SPEC
		|       FPP_SPEC
			HPAREXPSEPARATOR LISTV
		;
FPP_HEADING     :       HBEGPAR NO_TYPE
			FPP_MBEE_LISTV HENDPAR
		;
FPP_MBEE_LISTV  :       /*EMPT*/
		|       FPP_LISTV
		;
FPP_LISTV       :	FPP_CATEG HDOTDOTDOT
		|       FPP_SPEC
		|       FPP_SPEC
			HPAREXPSEPARATOR LISTV
		;
FPP_SPEC        :       FPP_CATEG SPECIFIER HIDENTIFIER
		|	FPP_CATEG FPP_PROC_DECL_IN_SPEC
		;
FPP_CATEG       :       HNAME HLABELSEPARATOR
		|       HVALUE HLABELSEPARATOR
		|       HVAR HLABELSEPARATOR
		|       /*EMPT*/
		;
FPP_PROC_DECL_IN_SPEC:	MBEE_TYPE HPROCEDURE
			HIDENTIFIER
					{}
			FPP_HEADING {} { /* Yes, two "final" actions. */ }
		;
IDENTIFIER_LISTV:       HIDENTIFIER
		|	HDOTDOTDOT
		|       HIDENTIFIER     {}
			HPAREXPSEPARATOR IDENTIFIER_LISTV
		;
MBEE_MODE_PART  :       /*EMPT*/
		|       MODE_PART
		;
MODE_PART       :       NAME_PART
		|       VALUE_PART
		|       VAR_PART
		|       NAME_PART VALUE_PART
		|       VALUE_PART NAME_PART
		|       NAME_PART VAR_PART
		|       VAR_PART NAME_PART
		|       VALUE_PART VAR_PART
		|       VAR_PART VALUE_PART
		|       VAR_PART NAME_PART VALUE_PART
		|       NAME_PART VAR_PART VALUE_PART
		|       NAME_PART VALUE_PART VAR_PART
		|       VAR_PART VALUE_PART NAME_PART
		|       VALUE_PART VAR_PART NAME_PART
		|       VALUE_PART NAME_PART VAR_PART
		;
NAME_PART       :       HNAME           {}
			IDENTIFIER_LISTV
			HSTATEMENTSEPARATOR
		;
VAR_PART        :       HVAR            {}
			IDENTIFIER_LISTV
			HSTATEMENTSEPARATOR
		;
VALUE_PART      :       HVALUE          {}
			IDENTIFIER_LISTV HSTATEMENTSEPARATOR
		;
MBEE_SPEC_PART  :       /*EMPT*/
		|       SPEC_PART
		;
SPEC_PART       :       ONE_SPEC
		|       SPEC_PART ONE_SPEC
		;
ONE_SPEC	:	SPECIFIER IDENTIFIER_LIST HSTATEMENTSEPARATOR
		|	NO_TYPE HPROCEDURE HIDENTIFIER HOBJRELOPERATOR
			  {}
			PROC_DECL_IN_SPEC HSTATEMENTSEPARATOR
		|       FPP_PROC_DECL_IN_SPEC HSTATEMENTSEPARATOR
		|       MBEE_TYPE HPROCEDURE HIDENTIFIER HSTATEMENTSEPARATOR
		|       MBEE_TYPE HPROCEDURE HIDENTIFIER HPAREXPSEPARATOR
			IDENTIFIER_LIST HSTATEMENTSEPARATOR
		;
SPECIFIER       :       TYPE
		|       MBEE_TYPE
			HARRAY
		|       HLABEL
		|       HSWITCH
		;
PROC_DECL_IN_SPEC:	MBEE_TYPE HPROCEDURE
			HIDENTIFIER
					{}
			HEADING
					{}
			MBEE_BEGIN_END
		;
MBEE_BEGIN_END	:	/* EMPTY */
		|	HBEGIN HEND
		;
MBEE_PROT_PART  :       /*EMPT*/
		|       PROTECTION_PART
		;
PROTECTION_PART :       PROT_SPECIFIER IDENTIFIER_LIST
			HSTATEMENTSEPARATOR
		|       PROTECTION_PART  PROT_SPECIFIER
			IDENTIFIER_LIST HSTATEMENTSEPARATOR
		;
PROT_SPECIFIER  :       HHIDDEN
		|       HPROTECTED
		|       HHIDDEN
			HPROTECTED
		|       HPROTECTED
			HHIDDEN
		;
MBEE_VIRT_PART  :       /*EMPT*/
		|       VIRTUAL_PART
		;
VIRTUAL_PART    :       HVIRTUAL
			HLABELSEPARATOR
			MBEE_SPEC_PART
		;
IDENTIFIER_LIST :       HIDENTIFIER
		|       IDENTIFIER_LIST HPAREXPSEPARATOR
			HIDENTIFIER
		;
IDENTIFIER_LISTC:       HIDENTIFIER
			MBEE_CONSTANT
		|       IDENTIFIER_LISTC HPAREXPSEPARATOR
			HIDENTIFIER
			MBEE_CONSTANT
		;
MBEE_CONSTANT	:	/* EMPTY */
		|	HVALRELOPERATOR
				{}
			EXPRESSION
		;

/* GRAMATIKK FOR UTTRYKK */
EXPRESSION      :       EXPRESSION_SIMP
		|       HIF
			EXPRESSION
			HTHEN
			EXPRESSION
			HELSE
			EXPRESSION
		;
EXPRESSION_SIMP :	EXPRESSION_SIMP
			HASSIGN
			EXPRESSION
		|

			EXPRESSION_SIMP
			HCONC
			EXPRESSION_SIMP
		|       EXPRESSION_SIMP HOR
			HELSE
			EXPRESSION_SIMP
			%prec HORELSE
		|       EXPRESSION_SIMP HAND
			HTHEN
			EXPRESSION_SIMP
			%prec HANDTHEN
		|       EXPRESSION_SIMP
			HEQV EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HIMP EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HOR EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HAND EXPRESSION_SIMP
		|       HNOT EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HVALRELOPERATOR
			EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HREFRELOPERATOR
			EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HOBJRELOPERATOR
			EXPRESSION_SIMP
		|       HTERMOPERATOR
			EXPRESSION_SIMP %prec UNEAR
		|       EXPRESSION_SIMP
			HTERMOPERATOR
			EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HFACTOROPERATOR
			EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HPRIMARYOPERATOR
			EXPRESSION_SIMP
		|       HBEGPAR
			EXPRESSION HENDPAR
		|       HTEXTKONST
		|       HCHARACTERKONST
		|       HREALKONST
		|       HINTEGERKONST
		|       HBOOLEANKONST
		|       HNONE
		|       HIDENTIFIER
				{}
			MBEE_ARG_R_PT
		|       HTHIS HIDENTIFIER
		|       HNEW
			HIDENTIFIER
			ARG_R_PT
		|       EXPRESSION_SIMP
			HDOT
			EXPRESSION_SIMP
		|       EXPRESSION_SIMP
			HQUA HIDENTIFIER
		;
ARG_R_PT        :       /*EMPTY*/
		|       HBEGPAR
			ARGUMENT_LIST HENDPAR
		;
MBEE_ARG_R_PT   :       /*EMPTY*/
		|       HBEGPAR
			ARGUMENT_LIST HENDPAR
		;
ARGUMENT_LIST   :       EXPRESSION
		|       EXPRESSION
			HPAREXPSEPARATOR
			ARGUMENT_LIST
		;
%%
_ATEOF


# Pass plenty of options, to exercise plenty of code, even if we
# don't actually check the output.  But SEGV is watching us, and
# so might do dmalloc.
if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/existing.at:956: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --verbose --defines input.y"
echo existing.at:956 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --verbose --defines input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --verbose --defines input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/existing.at:956"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/existing.at:956: bison --xml=xml-tests/test.xml --verbose --defines input.y"
echo existing.at:956 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml --verbose --defines input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml --verbose --defines input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/existing.at:956"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/existing.at:956: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo existing.at:956 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/existing.at:956"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/existing.at:956: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo existing.at:956 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/existing.at:956"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/existing.at:956: bison --verbose --defines input.y"
echo existing.at:956 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --verbose --defines input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --verbose --defines input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y: conflicts: 78 shift/reduce, 10 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/existing.at:956"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/existing.at:960: grep '^State.*conflicts:' input.output"
echo existing.at:960 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep '^State.*conflicts:' input.output ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep '^State.*conflicts:' input.output ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "State 64 conflicts: 14 shift/reduce
State 164 conflicts: 1 shift/reduce
State 201 conflicts: 33 shift/reduce, 4 reduce/reduce
State 206 conflicts: 1 shift/reduce
State 240 conflicts: 1 shift/reduce
State 335 conflicts: 9 shift/reduce, 2 reduce/reduce
State 356 conflicts: 1 shift/reduce
State 360 conflicts: 9 shift/reduce, 2 reduce/reduce
State 427 conflicts: 9 shift/reduce, 2 reduce/reduce
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/existing.at:960"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_165
#AT_START_166
# 166. existing.at:978: GNU pic Grammar
at_setup_line='existing.at:978'
at_func_banner 15
at_desc="GNU pic Grammar"
$at_quiet $as_echo_n "166: $at_desc                                "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "166. existing.at:978: testing ..."
  $at_traceon


# GNU pic, part of groff.

# Bison once reported shift/reduce conflicts that it shouldn't have.

cat >input.y <<'_ATEOF'
%union {}

%token LABEL
%token VARIABLE
%token NUMBER
%token TEXT
%token COMMAND_LINE
%token DELIMITED
%token ORDINAL
%token TH
%token LEFT_ARROW_HEAD
%token RIGHT_ARROW_HEAD
%token DOUBLE_ARROW_HEAD
%token LAST
%token UP
%token DOWN
%token LEFT
%token RIGHT
%token BOX
%token CIRCLE
%token ELLIPSE
%token ARC
%token LINE
%token ARROW
%token MOVE
%token SPLINE
%token HEIGHT
%token RADIUS
%token WIDTH
%token DIAMETER
%token FROM
%token TO
%token AT
%token WITH
%token BY
%token THEN
%token SOLID
%token DOTTED
%token DASHED
%token CHOP
%token SAME
%token INVISIBLE
%token LJUST
%token RJUST
%token ABOVE
%token BELOW
%token OF
%token THE
%token WAY
%token BETWEEN
%token AND
%token HERE
%token DOT_N
%token DOT_E
%token DOT_W
%token DOT_S
%token DOT_NE
%token DOT_SE
%token DOT_NW
%token DOT_SW
%token DOT_C
%token DOT_START
%token DOT_END
%token DOT_X
%token DOT_Y
%token DOT_HT
%token DOT_WID
%token DOT_RAD
%token SIN
%token COS
%token ATAN2
%token LOG
%token EXP
%token SQRT
%token K_MAX
%token K_MIN
%token INT
%token RAND
%token SRAND
%token COPY
%token THRU
%token TOP
%token BOTTOM
%token UPPER
%token LOWER
%token SH
%token PRINT
%token CW
%token CCW
%token FOR
%token DO
%token IF
%token ELSE
%token ANDAND
%token OROR
%token NOTEQUAL
%token EQUALEQUAL
%token LESSEQUAL
%token GREATEREQUAL
%token LEFT_CORNER
%token RIGHT_CORNER
%token NORTH
%token SOUTH
%token EAST
%token WEST
%token CENTER
%token END
%token START
%token RESET
%token UNTIL
%token PLOT
%token THICKNESS
%token FILL
%token COLORED
%token OUTLINED
%token SHADED
%token ALIGNED
%token SPRINTF
%token COMMAND

%left '.'

/* this ensures that plot 17 "%g" parses as (plot 17 "%g") */
%left PLOT
%left TEXT SPRINTF

/* give text adjustments higher precedence than TEXT, so that
box "foo" above ljust == box ("foo" above ljust)
*/

%left LJUST RJUST ABOVE BELOW

%left LEFT RIGHT
/* Give attributes that take an optional expression a higher
precedence than left and right, so that eg `line chop left'
parses properly. */
%left CHOP SOLID DASHED DOTTED UP DOWN FILL COLORED OUTLINED
%left LABEL

%left VARIABLE NUMBER '(' SIN COS ATAN2 LOG EXP SQRT K_MAX K_MIN INT RAND SRAND LAST
%left ORDINAL HERE '`'

%left BOX CIRCLE ELLIPSE ARC LINE ARROW SPLINE '[' /* ] */

/* these need to be lower than '-' */
%left HEIGHT RADIUS WIDTH DIAMETER FROM TO AT THICKNESS

/* these must have higher precedence than CHOP so that `label %prec CHOP'
works */
%left DOT_N DOT_E DOT_W DOT_S DOT_NE DOT_SE DOT_NW DOT_SW DOT_C
%left DOT_START DOT_END TOP BOTTOM LEFT_CORNER RIGHT_CORNER
%left UPPER LOWER NORTH SOUTH EAST WEST CENTER START END

%left ','
%left OROR
%left ANDAND
%left EQUALEQUAL NOTEQUAL
%left '<' '>' LESSEQUAL GREATEREQUAL

%left BETWEEN OF
%left AND

%left '+' '-'
%left '*' '/' '%'
%right '!'
%right '^'

%%

top:
	optional_separator
	| element_list
	;

element_list:
	optional_separator middle_element_list optional_separator
	;

middle_element_list:
	element
	| middle_element_list separator element
	;

optional_separator:
	/* empty */
	| separator
	;

separator:
	';'
	| separator ';'
	;

placeless_element:
	VARIABLE '=' any_expr
	| VARIABLE ':' '=' any_expr
	| UP
	| DOWN
	| LEFT
	| RIGHT
	| COMMAND_LINE
	| COMMAND print_args
	| PRINT print_args
	| SH
		{}
	  DELIMITED
	| COPY TEXT
	| COPY TEXT THRU
		{}
	  DELIMITED
		{}
	  until
	| COPY THRU
		{}
	  DELIMITED
		{}
	  until
	| FOR VARIABLE '=' expr TO expr optional_by DO
		{}
	  DELIMITED
	| simple_if
	| simple_if ELSE
		{}
	  DELIMITED
	| reset_variables
	| RESET
	;

reset_variables:
	RESET VARIABLE
	| reset_variables VARIABLE
	| reset_variables ',' VARIABLE
	;

print_args:
	print_arg
	| print_args print_arg
	;

print_arg:
	expr							%prec ','
	| text
	| position						%prec ','
	;

simple_if:
	IF any_expr THEN
		{}
	DELIMITED
	;

until:
	/* empty */
	| UNTIL TEXT
	;

any_expr:
	expr
	| text_expr
	;

text_expr:
	text EQUALEQUAL text
	| text NOTEQUAL text
	| text_expr ANDAND text_expr
	| text_expr ANDAND expr
	| expr ANDAND text_expr
	| text_expr OROR text_expr
	| text_expr OROR expr
	| expr OROR text_expr
	| '!' text_expr
	;

optional_by:
	/* empty */
	| BY expr
	| BY '*' expr
	;

element:
	object_spec
	| LABEL ':' optional_separator element
	| LABEL ':' optional_separator position_not_place
	| LABEL ':' optional_separator place
	| '{' {} element_list '}'
		{}
	  optional_element
	| placeless_element
	;

optional_element:
	/* empty */
	| element
	;

object_spec:
	BOX
	| CIRCLE
	| ELLIPSE
	| ARC
	| LINE
	| ARROW
	| MOVE
	| SPLINE
	| text							%prec TEXT
	| PLOT expr
	| PLOT expr text
	| '['
		{}
	  element_list ']'
	| object_spec HEIGHT expr
	| object_spec RADIUS expr
	| object_spec WIDTH expr
	| object_spec DIAMETER expr
	| object_spec expr					%prec HEIGHT
	| object_spec UP
	| object_spec UP expr
	| object_spec DOWN
	| object_spec DOWN expr
	| object_spec RIGHT
	| object_spec RIGHT expr
	| object_spec LEFT
	| object_spec LEFT expr
	| object_spec FROM position
	| object_spec TO position
	| object_spec AT position
	| object_spec WITH path
	| object_spec WITH position				%prec ','
	| object_spec BY expr_pair
	| object_spec THEN
	| object_spec SOLID
	| object_spec DOTTED
	| object_spec DOTTED expr
	| object_spec DASHED
	| object_spec DASHED expr
	| object_spec FILL
	| object_spec FILL expr
	| object_spec SHADED text
	| object_spec COLORED text
	| object_spec OUTLINED text
	| object_spec CHOP
	| object_spec CHOP expr
	| object_spec SAME
	| object_spec INVISIBLE
	| object_spec LEFT_ARROW_HEAD
	| object_spec RIGHT_ARROW_HEAD
	| object_spec DOUBLE_ARROW_HEAD
	| object_spec CW
	| object_spec CCW
	| object_spec text					%prec TEXT
	| object_spec LJUST
	| object_spec RJUST
	| object_spec ABOVE
	| object_spec BELOW
	| object_spec THICKNESS expr
	| object_spec ALIGNED
	;

text:
	TEXT
	| SPRINTF '(' TEXT sprintf_args ')'
	;

sprintf_args:
	/* empty */
	| sprintf_args ',' expr
	;

position:
	position_not_place
	| place
	;

position_not_place:
	expr_pair
	| position '+' expr_pair
	| position '-' expr_pair
	| '(' position ',' position ')'
	| expr between position AND position
	| expr '<' position ',' position '>'
	;

between:
	BETWEEN
	| OF THE WAY BETWEEN
	;

expr_pair:
	expr ',' expr
	| '(' expr_pair ')'
	;

place:
	/* line at A left == line (at A) left */
	label							%prec CHOP
	| label corner
	| corner label
	| corner OF label
	| HERE
	;

label:
	LABEL
	| nth_primitive
	| label '.' LABEL
	;

ordinal:
	ORDINAL
	| '`' any_expr TH
	;

optional_ordinal_last:
	LAST
	| ordinal LAST
	;

nth_primitive:
	ordinal object_type
	| optional_ordinal_last object_type
	;

object_type:
	BOX
	| CIRCLE
	| ELLIPSE
	| ARC
	| LINE
	| ARROW
	| SPLINE
	| '[' ']'
	| TEXT
	;

label_path:
	'.' LABEL
	| label_path '.' LABEL
	;

relative_path:
	corner							%prec CHOP
	/* give this a lower precedence than LEFT and RIGHT so that
	   [A: box] with .A left == [A: box] with (.A left) */
	| label_path						%prec TEXT
	| label_path corner
	;

path:
	relative_path
	| '(' relative_path ',' relative_path ')'
		{}
	/* The rest of these rules are a compatibility sop. */
	| ORDINAL LAST object_type relative_path
	| LAST object_type relative_path
	| ORDINAL object_type relative_path
	| LABEL relative_path
	;

corner:
	DOT_N
	| DOT_E
	| DOT_W
	| DOT_S
	| DOT_NE
	| DOT_SE
	| DOT_NW
	| DOT_SW
	| DOT_C
	| DOT_START
	| DOT_END
	| TOP
	| BOTTOM
	| LEFT
	| RIGHT
	| UPPER LEFT
	| LOWER LEFT
	| UPPER RIGHT
	| LOWER RIGHT
	| LEFT_CORNER
	| RIGHT_CORNER
	| UPPER LEFT_CORNER
	| LOWER LEFT_CORNER
	| UPPER RIGHT_CORNER
	| LOWER RIGHT_CORNER
	| NORTH
	| SOUTH
	| EAST
	| WEST
	| CENTER
	| START
	| END
	;

expr:
	VARIABLE
	| NUMBER
	| place DOT_X
	| place DOT_Y
	| place DOT_HT
	| place DOT_WID
	| place DOT_RAD
	| expr '+' expr
	| expr '-' expr
	| expr '*' expr
	| expr '/' expr
	| expr '%' expr
	| expr '^' expr
	| '-' expr						%prec '!'
	| '(' any_expr ')'
	| SIN '(' any_expr ')'
	| COS '(' any_expr ')'
	| ATAN2 '(' any_expr ',' any_expr ')'
	| LOG '(' any_expr ')'
	| EXP '(' any_expr ')'
	| SQRT '(' any_expr ')'
	| K_MAX '(' any_expr ',' any_expr ')'
	| K_MIN '(' any_expr ',' any_expr ')'
	| INT '(' any_expr ')'
	| RAND '(' any_expr ')'
	| RAND '(' ')'
	| SRAND '(' any_expr ')'
	| expr '<' expr
	| expr LESSEQUAL expr
	| expr '>' expr
	| expr GREATEREQUAL expr
	| expr EQUALEQUAL expr
	| expr NOTEQUAL expr
	| expr ANDAND expr
	| expr OROR expr
	| '!' expr
	;
_ATEOF


# Pass plenty of options, to exercise plenty of code, even if we
# don't actually check the output.  But SEGV is watching us, and
# so might do dmalloc.
if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/existing.at:1521: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --verbose --defines input.y"
echo existing.at:1521 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --verbose --defines input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --verbose --defines input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/existing.at:1521"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/existing.at:1521: bison --xml=xml-tests/test.xml --verbose --defines input.y"
echo existing.at:1521 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml --verbose --defines input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml --verbose --defines input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/existing.at:1521"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/existing.at:1521: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo existing.at:1521 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/existing.at:1521"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/existing.at:1521: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo existing.at:1521 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/existing.at:1521"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/existing.at:1521: bison --verbose --defines input.y"
echo existing.at:1521 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --verbose --defines input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --verbose --defines input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:453.11-48: warning: rule useless in parser due to conflicts: path: ORDINAL LAST object_type relative_path
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/existing.at:1521"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_166
#AT_START_167
# 167. regression.at:26: Trivial grammars
at_setup_line='regression.at:26'
at_func_banner 16
at_desc="Trivial grammars"
$at_quiet $as_echo_n "167: $at_desc                               "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "167. regression.at:26: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
void yyerror (char const *);
int yylex (void);
#define YYSTYPE int *
%}

%error-verbose

%%

program: 'x';
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:42: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo regression.at:42 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:42"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:42: bison --xml=xml-tests/test.xml -o input.c input.y"
echo regression.at:42 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:42"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:42: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:42 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:42"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:42: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:42 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:42"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:42: bison -o input.c input.y"
echo regression.at:42 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:42"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/regression.at:43: \$CC \$CFLAGS \$CPPFLAGS -o input.o -c input.c"
echo regression.at:43 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -o input.o -c input.c"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -o input.o -c input.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -o input.o -c input.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:43"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/regression.at:44: \$CC \$CFLAGS \$CPPFLAGS -o input.o -DYYDEBUG -c input.c"
echo regression.at:44 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -o input.o -DYYDEBUG -c input.c"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -o input.o -DYYDEBUG -c input.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -o input.o -DYYDEBUG -c input.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:44"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_167
#AT_START_168
# 168. regression.at:54: YYSTYPE typedef
at_setup_line='regression.at:54'
at_func_banner 16
at_desc="YYSTYPE typedef"
$at_quiet $as_echo_n "168: $at_desc                                "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "168. regression.at:54: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
void yyerror (char const *);
int yylex (void);
typedef union { char const *val; } YYSTYPE;
%}

%type <val> program

%%

program: { $$ = ""; };
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:70: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo regression.at:70 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:70"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:70: bison --xml=xml-tests/test.xml -o input.c input.y"
echo regression.at:70 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:70"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:70: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:70 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:70"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:70: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:70 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:70"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:70: bison -o input.c input.y"
echo regression.at:70 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:70"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/regression.at:71: \$CC \$CFLAGS \$CPPFLAGS -o input.o -c input.c"
echo regression.at:71 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -o input.o -c input.c"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -o input.o -c input.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -o input.o -c input.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:71"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_168
#AT_START_169
# 169. regression.at:82: Early token definitions with --yacc
at_setup_line='regression.at:82'
at_func_banner 16
at_desc="Early token definitions with --yacc"
$at_quiet $as_echo_n "169: $at_desc            "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "169. regression.at:82: testing ..."
  $at_traceon


# Found in GCJ: they expect the tokens to be defined before the user
# prologue, so that they can use the token definitions in it.

cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
void yyerror (const char *s);
int yylex (void);
%}

%union
{
  int val;
};
%{
#ifndef MY_TOKEN
# error "MY_TOKEN not defined."
#endif
%}
%token MY_TOKEN
%%
exp: MY_TOKEN;
%%
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:108: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -y -o input.c input.y"
echo regression.at:108 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -y -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -y -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:108"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:108: bison --xml=xml-tests/test.xml -y -o input.c input.y"
echo regression.at:108 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -y -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -y -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:108"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:108: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:108 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:108"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:108: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:108 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:108"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:108: bison -y -o input.c input.y"
echo regression.at:108 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -y -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -y -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:108"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/regression.at:109: \$CC \$CFLAGS \$CPPFLAGS -o input.o -c input.c"
echo regression.at:109 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -o input.o -c input.c"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -o input.o -c input.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -o input.o -c input.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:109"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_169
#AT_START_170
# 170. regression.at:120: Early token definitions without --yacc
at_setup_line='regression.at:120'
at_func_banner 16
at_desc="Early token definitions without --yacc"
$at_quiet $as_echo_n "170: $at_desc         "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "170. regression.at:120: testing ..."
  $at_traceon


# Found in GCJ: they expect the tokens to be defined before the user
# prologue, so that they can use the token definitions in it.

cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
#include <stdio.h>
void yyerror (const char *s);
int yylex (void);
void print_my_token (void);
%}

%union
{
  int val;
};
%{
void
print_my_token (void)
{
  enum yytokentype my_token = MY_TOKEN;
  printf ("%d\n", my_token);
}
%}
%token MY_TOKEN
%%
exp: MY_TOKEN;
%%
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:151: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo regression.at:151 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:151"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:151: bison --xml=xml-tests/test.xml -o input.c input.y"
echo regression.at:151 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:151"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:151: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:151 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:151"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:151: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:151 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:151"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:151: bison -o input.c input.y"
echo regression.at:151 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:151"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/regression.at:152: \$CC \$CFLAGS \$CPPFLAGS -o input.o -c input.c"
echo regression.at:152 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -o input.o -c input.c"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -o input.o -c input.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -o input.o -c input.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:152"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_170
#AT_START_171
# 171. regression.at:163: Braces parsing
at_setup_line='regression.at:163'
at_func_banner 16
at_desc="Braces parsing"
$at_quiet $as_echo_n "171: $at_desc                                 "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "171. regression.at:163: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
/* Bison used to swallow the character after `}'. */

%%
exp: { tests = {{{{{{{{{{}}}}}}}}}}; };
%%
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:173: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -v -o input.c input.y"
echo regression.at:173 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:173"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:173: bison --xml=xml-tests/test.xml -v -o input.c input.y"
echo regression.at:173 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:173"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:173: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:173 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:173"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:173: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:173 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:173"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:173: bison -v -o input.c input.y"
echo regression.at:173 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:173"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/regression.at:175: grep 'tests = {{{{{{{{{{}}}}}}}}}};' input.c"
echo regression.at:175 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep 'tests = {{{{{{{{{{}}}}}}}}}};' input.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep 'tests = {{{{{{{{{{}}}}}}}}}};' input.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:175"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_171
#AT_START_172
# 172. regression.at:185: Duplicate string
at_setup_line='regression.at:185'
at_func_banner 16
at_desc="Duplicate string"
$at_quiet $as_echo_n "172: $at_desc                               "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "172. regression.at:185: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
/* `Bison -v' used to dump core when two tokens are defined with the same
   string, as LE and GE below. */

%token NUM
%token LE "<="
%token GE "<="

%%
exp: '(' exp ')' | NUM ;
%%
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:200: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -v -o input.c input.y"
echo regression.at:200 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:200"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:200: bison --xml=xml-tests/test.xml -v -o input.c input.y"
echo regression.at:200 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:200"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:200: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:200 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:200"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:200: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:200 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:200"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:200: bison -v -o input.c input.y"
echo regression.at:200 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:6.8-14: warning: symbol \`\"<=\"' used more than once as a literal string
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:200"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_172
#AT_START_173
# 173. regression.at:211: Rule Line Numbers
at_setup_line='regression.at:211'
at_func_banner 16
at_desc="Rule Line Numbers"
$at_quiet $as_echo_n "173: $at_desc                              "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "173. regression.at:211: testing ..."
  $at_traceon




cat >input.y <<'_ATEOF'
%%
expr:
'a'

{

}

'b'

{

}

|


{


}

'c'

{

};
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:245: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c -v input.y"
echo regression.at:245 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c -v input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c -v input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:245"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:245: bison --xml=xml-tests/test.xml -o input.c -v input.y"
echo regression.at:245 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c -v input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c -v input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:245"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:245: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:245 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:245"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:245: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:245 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:245"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:245: bison -o input.c -v input.y"
echo regression.at:245 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c -v input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c -v input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:245"

$at_failed && at_func_log_failure
$at_traceon; }


# Check the contents of the report.
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:248: cat input.output"
echo regression.at:248 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat input.output ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat input.output ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Grammar

    0 \$accept: expr \$end

    1 \$@1: /* empty */

    2 expr: 'a' \$@1 'b'

    3 \$@2: /* empty */

    4 expr: \$@2 'c'


Terminals, with rules where they appear

\$end (0) 0
'a' (97) 2
'b' (98) 2
'c' (99) 4
error (256)


Nonterminals, with rules where they appear

\$accept (6)
    on left: 0
expr (7)
    on left: 2 4, on right: 0
\$@1 (8)
    on left: 1, on right: 2
\$@2 (9)
    on left: 3, on right: 4


state 0

    0 \$accept: . expr \$end

    'a'  shift, and go to state 1

    \$default  reduce using rule 3 (\$@2)

    expr  go to state 2
    \$@2   go to state 3


state 1

    2 expr: 'a' . \$@1 'b'

    \$default  reduce using rule 1 (\$@1)

    \$@1  go to state 4


state 2

    0 \$accept: expr . \$end

    \$end  shift, and go to state 5


state 3

    4 expr: \$@2 . 'c'

    'c'  shift, and go to state 6


state 4

    2 expr: 'a' \$@1 . 'b'

    'b'  shift, and go to state 7


state 5

    0 \$accept: expr \$end .

    \$default  accept


state 6

    4 expr: \$@2 'c' .

    \$default  reduce using rule 4 (expr)


state 7

    2 expr: 'a' \$@1 'b' .

    \$default  reduce using rule 2 (expr)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:248"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_173
#AT_START_174
# 174. regression.at:355: Mixing %token styles
at_setup_line='regression.at:355'
at_func_banner 16
at_desc="Mixing %token styles"
$at_quiet $as_echo_n "174: $at_desc                           "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "174. regression.at:355: testing ..."
  $at_traceon


# Taken from the documentation.
cat >input.y <<'_ATEOF'
%token  <operator>  OR      "||"
%token  <operator>  LE 134  "<="
%left  OR  "<="
%%
exp: ;
%%
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:367: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -v -o input.c input.y"
echo regression.at:367 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:367"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:367: bison --xml=xml-tests/test.xml -v -o input.c input.y"
echo regression.at:367 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:367"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:367: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:367 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:367"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:367: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:367 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:367"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:367: bison -v -o input.c input.y"
echo regression.at:367 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:367"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_174
#AT_START_175
# 175. regression.at:378: Invalid inputs
at_setup_line='regression.at:378'
at_func_banner 16
at_desc="Invalid inputs"
$at_quiet $as_echo_n "175: $at_desc                                 "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "175. regression.at:378: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%%
?
default: 'a' }
%&
%a-does-not-exist
%-
%{
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/regression.at:390: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
echo regression.at:390 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:2.1: invalid character: \`?'
input.y:3.14: invalid character: \`}'
input.y:4.1: invalid character: \`%'
input.y:4.2: invalid character: \`&'
input.y:5.1-17: invalid directive: \`%a-does-not-exist'
input.y:6.1: invalid character: \`%'
input.y:6.2: invalid character: \`-'
input.y:7.1-8.0: missing \`%}' at end of file
input.y:7.1-8.0: syntax error, unexpected %{...%}
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/regression.at:390"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_175
#AT_START_176
# 176. regression.at:405: Invalid inputs with {}
at_setup_line='regression.at:405'
at_func_banner 16
at_desc="Invalid inputs with {}"
$at_quiet $as_echo_n "176: $at_desc                         "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "176. regression.at:405: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'

%destructor
%initial-action
%lex-param
%parse-param
%printer
%union
_ATEOF



{ $at_traceoff
$as_echo "$at_srcdir/regression.at:417: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"
echo regression.at:417 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison input.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:3.1-15: syntax error, unexpected %initial-action, expecting {...}
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/regression.at:417"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_176
#AT_START_177
# 177. regression.at:430: Token definitions
at_setup_line='regression.at:430'
at_func_banner 16
at_desc="Token definitions"
$at_quiet $as_echo_n "177: $at_desc                              "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "177. regression.at:430: testing ..."
  $at_traceon


# Bison managed, when fed with `%token 'f' "f"' to #define 'f'!
cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
#include <stdlib.h>
#include <stdio.h>
void yyerror (const char *s);
int yylex (void);
%}
%error-verbose
%token MYEOF 0 "end of file"
%token 'a' "a"
%token B_TOKEN "b"
%token C_TOKEN 'c'
%token 'd' D_TOKEN
%token SPECIAL "\\\'\?\"\a\b\f\n\r\t\v\001\201\x001\x000081??!"
%token SPECIAL "\\\'\?\"\a\b\f\n\r\t\v\001\201\x001\x000081??!"
%%
exp: "a" "\\\'\?\"\a\b\f\n\r\t\v\001\201\x001\x000081??!";
%%
void
yyerror (char const *s)
{
  fprintf (stderr, "%s\n", s);
}

int
yylex (void)
{
  static int called;
  if (called++)
    abort ();
  return SPECIAL;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



# Checking the warning message guarantees that the trigraph "??!" isn't
# unnecessarily escaped here even though it would need to be if encoded in a
# C-string literal.  Also notice that unnecessary escaping, such as "\?", from
# the user specification is eliminated.
if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:477: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo regression.at:477 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:477"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:477: bison --xml=xml-tests/test.xml -o input.c input.y"
echo regression.at:477 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:477"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:477: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:477 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:477"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:477: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:477 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:477"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:477: bison -o input.c input.y"
echo regression.at:477 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:22.8-14: warning: symbol SPECIAL redeclared
input.y:22.8-63: warning: symbol \`\"\\\\'?\\\"\\a\\b\\f\\n\\r\\t\\v\\001\\201\\001\\201??!\"' used more than once as a literal string
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:477"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/regression.at:481: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo regression.at:481 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:481"

$at_failed && at_func_log_failure
$at_traceon; }


# Checking the error message here guarantees that yytname, which does contain
# C-string literals, does have the trigraph escaped correctly.  Thus, the
# symbol name reported by the parser is exactly the same as that reported by
# Bison itself.
cat >experr <<'_ATEOF'
syntax error, unexpected "\\'?\"\a\b\f\n\r\t\v\001\201\001\201??!", expecting a
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/regression.at:490:  \$PREPARSER ./input"
echo regression.at:490 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input"; then
  ( $at_traceon;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
$at_diff experr "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/regression.at:490"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_177
#AT_START_178
# 178. regression.at:500: Characters Escapes
at_setup_line='regression.at:500'
at_func_banner 16
at_desc="Characters Escapes"
$at_quiet $as_echo_n "178: $at_desc                             "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "178. regression.at:500: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
void yyerror (const char *s);
int yylex (void);
%}
%%
exp:
  '\'' "\'"
| '\"' "\""
| '"'  "'"
;
_ATEOF


# Pacify font-lock-mode: "

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:516: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo regression.at:516 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:516"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:516: bison --xml=xml-tests/test.xml -o input.c input.y"
echo regression.at:516 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:516"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:516: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:516 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:516"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:516: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:516 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:516"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:516: bison -o input.c input.y"
echo regression.at:516 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:516"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/regression.at:517: \$CC \$CFLAGS \$CPPFLAGS -o input.o -c input.c"
echo regression.at:517 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS -o input.o -c input.c"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS -o input.o -c input.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS -o input.o -c input.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:517"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_178
#AT_START_179
# 179. regression.at:531: Web2c Report
at_setup_line='regression.at:531'
at_func_banner 16
at_desc="Web2c Report"
$at_quiet $as_echo_n "179: $at_desc                                   "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "179. regression.at:531: testing ..."
  $at_traceon




cat >input.y <<'_ATEOF'
%token	undef_id_tok const_id_tok

%start CONST_DEC_PART

%%
CONST_DEC_PART:
         CONST_DEC_LIST
        ;

CONST_DEC_LIST:
	  CONST_DEC
        | CONST_DEC_LIST CONST_DEC
        ;

CONST_DEC:
	  { } undef_id_tok '=' const_id_tok ';'
        ;
%%
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:556: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -v input.y"
echo regression.at:556 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -v input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -v input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:556"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:556: bison --xml=xml-tests/test.xml -v input.y"
echo regression.at:556 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -v input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -v input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:556"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:556: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:556 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:556"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:556: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:556 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:556"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:556: bison -v input.y"
echo regression.at:556 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -v input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -v input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:556"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/regression.at:557: cat input.output"
echo regression.at:557 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat input.output ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat input.output ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Grammar

    0 \$accept: CONST_DEC_PART \$end

    1 CONST_DEC_PART: CONST_DEC_LIST

    2 CONST_DEC_LIST: CONST_DEC
    3               | CONST_DEC_LIST CONST_DEC

    4 \$@1: /* empty */

    5 CONST_DEC: \$@1 undef_id_tok '=' const_id_tok ';'


Terminals, with rules where they appear

\$end (0) 0
';' (59) 5
'=' (61) 5
error (256)
undef_id_tok (258) 5
const_id_tok (259) 5


Nonterminals, with rules where they appear

\$accept (7)
    on left: 0
CONST_DEC_PART (8)
    on left: 1, on right: 0
CONST_DEC_LIST (9)
    on left: 2 3, on right: 1 3
CONST_DEC (10)
    on left: 5, on right: 2 3
\$@1 (11)
    on left: 4, on right: 5


state 0

    0 \$accept: . CONST_DEC_PART \$end

    \$default  reduce using rule 4 (\$@1)

    CONST_DEC_PART  go to state 1
    CONST_DEC_LIST  go to state 2
    CONST_DEC       go to state 3
    \$@1             go to state 4


state 1

    0 \$accept: CONST_DEC_PART . \$end

    \$end  shift, and go to state 5


state 2

    1 CONST_DEC_PART: CONST_DEC_LIST .
    3 CONST_DEC_LIST: CONST_DEC_LIST . CONST_DEC

    undef_id_tok  reduce using rule 4 (\$@1)
    \$default      reduce using rule 1 (CONST_DEC_PART)

    CONST_DEC  go to state 6
    \$@1        go to state 4


state 3

    2 CONST_DEC_LIST: CONST_DEC .

    \$default  reduce using rule 2 (CONST_DEC_LIST)


state 4

    5 CONST_DEC: \$@1 . undef_id_tok '=' const_id_tok ';'

    undef_id_tok  shift, and go to state 7


state 5

    0 \$accept: CONST_DEC_PART \$end .

    \$default  accept


state 6

    3 CONST_DEC_LIST: CONST_DEC_LIST CONST_DEC .

    \$default  reduce using rule 3 (CONST_DEC_LIST)


state 7

    5 CONST_DEC: \$@1 undef_id_tok . '=' const_id_tok ';'

    '='  shift, and go to state 8


state 8

    5 CONST_DEC: \$@1 undef_id_tok '=' . const_id_tok ';'

    const_id_tok  shift, and go to state 9


state 9

    5 CONST_DEC: \$@1 undef_id_tok '=' const_id_tok . ';'

    ';'  shift, and go to state 10


state 10

    5 CONST_DEC: \$@1 undef_id_tok '=' const_id_tok ';' .

    \$default  reduce using rule 5 (CONST_DEC)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:557"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_179
#AT_START_180
# 180. regression.at:708: Web2c Actions
at_setup_line='regression.at:708'
at_func_banner 16
at_desc="Web2c Actions"
$at_quiet $as_echo_n "180: $at_desc                                  "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "180. regression.at:708: testing ..."
  $at_traceon




cat >input.y <<'_ATEOF'
%%
statement:  struct_stat;
struct_stat:  /* empty. */ | if else;
if: "if" "const" "then" statement;
else: "else" statement;
%%
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:721: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -v -o input.c input.y"
echo regression.at:721 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:721"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:721: bison --xml=xml-tests/test.xml -v -o input.c input.y"
echo regression.at:721 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:721"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:721: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:721 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:721"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:721: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:721 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:721"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:721: bison -v -o input.c input.y"
echo regression.at:721 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -v -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -v -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:721"

$at_failed && at_func_log_failure
$at_traceon; }


# Check only the tables.
sed -n 's/  *$//;/^static const.*\[\] =/,/^}/p' input.c >tables.c

{ $at_traceoff
$as_echo "$at_srcdir/regression.at:726: cat tables.c"
echo regression.at:726 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat tables.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat tables.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "static const yytype_uint8 yytranslate[] =
{
       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
       5,     6
};
static const yytype_uint8 yyprhs[] =
{
       0,     0,     3,     5,     6,     9,    14
};
static const yytype_int8 yyrhs[] =
{
       8,     0,    -1,     9,    -1,    -1,    10,    11,    -1,     3,
       4,     5,     8,    -1,     6,     8,    -1
};
static const yytype_uint8 yyrline[] =
{
       0,     2,     2,     3,     3,     4,     5
};
static const char *const yytname[] =
{
  \"\$end\", \"error\", \"\$undefined\", \"\\\"if\\\"\", \"\\\"const\\\"\", \"\\\"then\\\"\",
  \"\\\"else\\\"\", \"\$accept\", \"statement\", \"struct_stat\", \"if\", \"else\", 0
};
static const yytype_uint16 yytoknum[] =
{
       0,   256,   257,   258,   259,   260,   261
};
static const yytype_uint8 yyr1[] =
{
       0,     7,     8,     9,     9,    10,    11
};
static const yytype_uint8 yyr2[] =
{
       0,     2,     1,     0,     2,     4,     2
};
static const yytype_uint8 yydefact[] =
{
       3,     0,     0,     2,     0,     0,     1,     3,     4,     3,
       6,     5
};
static const yytype_int8 yydefgoto[] =
{
      -1,     2,     3,     4,     8
};
static const yytype_int8 yypact[] =
{
      -2,    -1,     4,    -8,     0,     2,    -8,    -2,    -8,    -2,
      -8,    -8
};
static const yytype_int8 yypgoto[] =
{
      -8,    -7,    -8,    -8,    -8
};
static const yytype_uint8 yytable[] =
{
      10,     1,    11,     5,     6,     0,     7,     9
};
static const yytype_int8 yycheck[] =
{
       7,     3,     9,     4,     0,    -1,     6,     5
};
static const yytype_uint8 yystos[] =
{
       0,     3,     8,     9,    10,     4,     0,     6,    11,     5,
       8,     8
};
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:726"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_180
#AT_START_181
# 181. regression.at:954: Dancer
at_setup_line='regression.at:954'
at_func_banner 16
at_desc="Dancer "
$at_quiet $as_echo_n "181: $at_desc                                        "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "181. regression.at:954: testing ..."
  $at_traceon






# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











cat >dancer.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
static int yylex (void);
#include <stdlib.h>
#include <stdio.h>
static void yyerror (const char *);
%}

%token ARROW INVALID NUMBER STRING DATA
%defines
%verbose
%error-verbose
/* Grammar follows */
%%
line: header body
   ;

header: '<' from ARROW to '>' type ':'
   | '<' ARROW to '>' type ':'
   | ARROW to type ':'
   | type ':'
   | '<' '>'
   ;

from: DATA
   | STRING
   | INVALID
   ;

to: DATA
   | STRING
   | INVALID
   ;

type: DATA
   | STRING
   | INVALID
   ;

body: /* empty */
   | body member
   ;

member: STRING
   | DATA
   | '+' NUMBER
   | '-' NUMBER
   | NUMBER
   | INVALID
   ;
%%
static void
yyerror (const char *s)
{
  fprintf (stderr, "%s\n", s);
}

static int
yylex (void)
{
  static int const tokens[] =
    {
      ':', -1
    };
  static size_t toknum;

  if (! (toknum < sizeof tokens / sizeof *tokens))
    abort ();
  return tokens[toknum++];
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:954: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o dancer.c dancer.y"
echo regression.at:954 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:954"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:954: bison --xml=xml-tests/test.xml -o dancer.c dancer.y"
echo regression.at:954 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:954"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:954: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:954 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:954"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:954: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:954 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:954"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:954: bison -o dancer.c dancer.y"
echo regression.at:954 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:954"

$at_failed && at_func_log_failure
$at_traceon; }

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:954: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o dancer.c dancer.y"
echo regression.at:954 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:954"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:954: bison --xml=xml-tests/test.xml -o dancer.c dancer.y"
echo regression.at:954 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:954"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:954: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:954 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:954"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:954: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:954 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:954"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:954: bison -o dancer.c dancer.y"
echo regression.at:954 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:954"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/regression.at:954: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o dancer dancer.c \$LIBS"
echo regression.at:954 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o dancer dancer.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o dancer dancer.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o dancer dancer.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:954"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/regression.at:954:  \$PREPARSER ./dancer"
echo regression.at:954 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./dancer"; then
  ( $at_traceon;  $PREPARSER ./dancer ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./dancer ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "syntax error, unexpected ':'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/regression.at:954"

$at_failed && at_func_log_failure
$at_traceon; }
























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_181
#AT_START_182
# 182. regression.at:955: Dancer %glr-parser
at_setup_line='regression.at:955'
at_func_banner 16
at_desc="Dancer %glr-parser"
$at_quiet $as_echo_n "182: $at_desc                             "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "182. regression.at:955: testing ..."
  $at_traceon






# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











cat >dancer.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
static int yylex (void);
#include <stdlib.h>
#include <stdio.h>
static void yyerror (const char *);
%}
%glr-parser
%token ARROW INVALID NUMBER STRING DATA
%defines
%verbose
%error-verbose
/* Grammar follows */
%%
line: header body
   ;

header: '<' from ARROW to '>' type ':'
   | '<' ARROW to '>' type ':'
   | ARROW to type ':'
   | type ':'
   | '<' '>'
   ;

from: DATA
   | STRING
   | INVALID
   ;

to: DATA
   | STRING
   | INVALID
   ;

type: DATA
   | STRING
   | INVALID
   ;

body: /* empty */
   | body member
   ;

member: STRING
   | DATA
   | '+' NUMBER
   | '-' NUMBER
   | NUMBER
   | INVALID
   ;
%%
static void
yyerror (const char *s)
{
  fprintf (stderr, "%s\n", s);
}

static int
yylex (void)
{
  static int const tokens[] =
    {
      ':', -1
    };
  static size_t toknum;

  if (! (toknum < sizeof tokens / sizeof *tokens))
    abort ();
  return tokens[toknum++];
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:955: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o dancer.c dancer.y"
echo regression.at:955 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:955"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:955: bison --xml=xml-tests/test.xml -o dancer.c dancer.y"
echo regression.at:955 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:955"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:955: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:955 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:955"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:955: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:955 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:955"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:955: bison -o dancer.c dancer.y"
echo regression.at:955 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:955"

$at_failed && at_func_log_failure
$at_traceon; }

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:955: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o dancer.c dancer.y"
echo regression.at:955 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:955"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:955: bison --xml=xml-tests/test.xml -o dancer.c dancer.y"
echo regression.at:955 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:955"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:955: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:955 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:955"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:955: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:955 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:955"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:955: bison -o dancer.c dancer.y"
echo regression.at:955 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:955"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/regression.at:955: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o dancer dancer.c \$LIBS"
echo regression.at:955 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o dancer dancer.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o dancer dancer.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o dancer dancer.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:955"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/regression.at:955:  \$PREPARSER ./dancer"
echo regression.at:955 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./dancer"; then
  ( $at_traceon;  $PREPARSER ./dancer ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./dancer ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "syntax error, unexpected ':'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/regression.at:955"

$at_failed && at_func_log_failure
$at_traceon; }
























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_182
#AT_START_183
# 183. regression.at:956: Dancer %skeleton "lalr1.cc"
at_setup_line='regression.at:956'
at_func_banner 16
at_desc="Dancer %skeleton \"lalr1.cc\""
$at_quiet $as_echo_n "183: $at_desc                    "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "183. regression.at:956: testing ..."
  $at_traceon






# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











cat >dancer.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
static int yylex (int *);

%}
%skeleton "lalr1.cc"
%token ARROW INVALID NUMBER STRING DATA
%defines
%verbose
%error-verbose
/* Grammar follows */
%%
line: header body
   ;

header: '<' from ARROW to '>' type ':'
   | '<' ARROW to '>' type ':'
   | ARROW to type ':'
   | type ':'
   | '<' '>'
   ;

from: DATA
   | STRING
   | INVALID
   ;

to: DATA
   | STRING
   | INVALID
   ;

type: DATA
   | STRING
   | INVALID
   ;

body: /* empty */
   | body member
   ;

member: STRING
   | DATA
   | '+' NUMBER
   | '-' NUMBER
   | NUMBER
   | INVALID
   ;
%%
/* A C++ error reporting function. */
void
yy::parser::error (const location&, const std::string& m)
{
  std::cerr << m << std::endl;
}

int
yyparse ()
{
  yy::parser parser;
#if YYDEBUG
  parser.set_debug_level (YYDEBUG);
#endif
  return parser.parse ();
}


static int
yylex (int *lval)
{
  static int const tokens[] =
    {
      ':', -1
    };
  static size_t toknum;
  *lval = 0; /* Pacify GCC.  */
  if (! (toknum < sizeof tokens / sizeof *tokens))
    abort ();
  return tokens[toknum++];
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:956: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o dancer.c dancer.y"
echo regression.at:956 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:956"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:956: bison --xml=xml-tests/test.xml -o dancer.c dancer.y"
echo regression.at:956 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:956"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:956: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:956 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:956"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:956: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:956 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:956"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:956: bison -o dancer.c dancer.y"
echo regression.at:956 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o dancer.c dancer.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:956"

$at_failed && at_func_log_failure
$at_traceon; }

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:956: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o dancer.cc dancer.y"
echo regression.at:956 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o dancer.cc dancer.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o dancer.cc dancer.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:956"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:956: bison --xml=xml-tests/test.xml -o dancer.cc dancer.y"
echo regression.at:956 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o dancer.cc dancer.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o dancer.cc dancer.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:956"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:956: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:956 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:956"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:956: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:956 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:956"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:956: bison -o dancer.cc dancer.y"
echo regression.at:956 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o dancer.cc dancer.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o dancer.cc dancer.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:956"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/regression.at:956: \$BISON_CXX_WORKS"
echo regression.at:956 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:956"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/regression.at:956: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o dancer dancer.cc \$LIBS"
echo regression.at:956 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o dancer dancer.cc $LIBS"; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o dancer dancer.cc $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o dancer dancer.cc $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:956"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/regression.at:956:  \$PREPARSER ./dancer"
echo regression.at:956 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./dancer"; then
  ( $at_traceon;  $PREPARSER ./dancer ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./dancer ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "syntax error, unexpected ':'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/regression.at:956"

$at_failed && at_func_log_failure
$at_traceon; }
























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_183
#AT_START_184
# 184. regression.at:1054: Expecting two tokens
at_setup_line='regression.at:1054'
at_func_banner 16
at_desc="Expecting two tokens "
$at_quiet $as_echo_n "184: $at_desc                          "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "184. regression.at:1054: testing ..."
  $at_traceon






# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











cat >expect2.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
static int yylex (void);
#include <stdio.h>
#include <stdlib.h>
static void yyerror (const char *);
%}

%defines
%error-verbose
%token A 1000
%token B

%%
program: /* empty */
 | program e ';'
 | program error ';';

e: e '+' t | t;
t: A | B;

%%
static void
yyerror (const char *s)
{
  fprintf (stderr, "%s\n", s);
}

static int
yylex (void)
{
  static int const tokens[] =
    {
      1000, '+', '+', -1
    };
  static size_t toknum;

  if (! (toknum < sizeof tokens / sizeof *tokens))
    abort ();
  return tokens[toknum++];
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1054: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o expect2.c expect2.y"
echo regression.at:1054 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1054"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1054: bison --xml=xml-tests/test.xml -o expect2.c expect2.y"
echo regression.at:1054 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1054"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1054: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:1054 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1054"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1054: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:1054 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1054"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:1054: bison -o expect2.c expect2.y"
echo regression.at:1054 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1054"

$at_failed && at_func_log_failure
$at_traceon; }

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1054: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o expect2.c expect2.y"
echo regression.at:1054 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1054"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1054: bison --xml=xml-tests/test.xml -o expect2.c expect2.y"
echo regression.at:1054 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1054"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1054: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:1054 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1054"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1054: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:1054 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1054"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:1054: bison -o expect2.c expect2.y"
echo regression.at:1054 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1054"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/regression.at:1054: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o expect2 expect2.c \$LIBS"
echo regression.at:1054 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o expect2 expect2.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o expect2 expect2.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o expect2 expect2.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1054"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/regression.at:1054:  \$PREPARSER ./expect2"
echo regression.at:1054 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./expect2"; then
  ( $at_traceon;  $PREPARSER ./expect2 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./expect2 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "syntax error, unexpected '+', expecting A or B
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/regression.at:1054"

$at_failed && at_func_log_failure
$at_traceon; }
























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_184
#AT_START_185
# 185. regression.at:1055: Expecting two tokens %glr-parser
at_setup_line='regression.at:1055'
at_func_banner 16
at_desc="Expecting two tokens %glr-parser"
$at_quiet $as_echo_n "185: $at_desc               "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "185. regression.at:1055: testing ..."
  $at_traceon






# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











cat >expect2.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
static int yylex (void);
#include <stdio.h>
#include <stdlib.h>
static void yyerror (const char *);
%}
%glr-parser
%defines
%error-verbose
%token A 1000
%token B

%%
program: /* empty */
 | program e ';'
 | program error ';';

e: e '+' t | t;
t: A | B;

%%
static void
yyerror (const char *s)
{
  fprintf (stderr, "%s\n", s);
}

static int
yylex (void)
{
  static int const tokens[] =
    {
      1000, '+', '+', -1
    };
  static size_t toknum;

  if (! (toknum < sizeof tokens / sizeof *tokens))
    abort ();
  return tokens[toknum++];
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1055: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o expect2.c expect2.y"
echo regression.at:1055 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1055"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1055: bison --xml=xml-tests/test.xml -o expect2.c expect2.y"
echo regression.at:1055 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1055"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1055: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:1055 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1055"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1055: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:1055 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1055"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:1055: bison -o expect2.c expect2.y"
echo regression.at:1055 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1055"

$at_failed && at_func_log_failure
$at_traceon; }

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1055: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o expect2.c expect2.y"
echo regression.at:1055 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1055"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1055: bison --xml=xml-tests/test.xml -o expect2.c expect2.y"
echo regression.at:1055 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1055"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1055: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:1055 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1055"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1055: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:1055 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1055"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:1055: bison -o expect2.c expect2.y"
echo regression.at:1055 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1055"

$at_failed && at_func_log_failure
$at_traceon; }

   { $at_traceoff
$as_echo "$at_srcdir/regression.at:1055: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o expect2 expect2.c \$LIBS"
echo regression.at:1055 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o expect2 expect2.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o expect2 expect2.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o expect2 expect2.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1055"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/regression.at:1055:  \$PREPARSER ./expect2"
echo regression.at:1055 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./expect2"; then
  ( $at_traceon;  $PREPARSER ./expect2 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./expect2 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "syntax error, unexpected '+', expecting A or B
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/regression.at:1055"

$at_failed && at_func_log_failure
$at_traceon; }
























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_185
#AT_START_186
# 186. regression.at:1056: Expecting two tokens %skeleton "lalr1.cc"
at_setup_line='regression.at:1056'
at_func_banner 16
at_desc="Expecting two tokens %skeleton \"lalr1.cc\""
$at_quiet $as_echo_n "186: $at_desc      "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "186. regression.at:1056: testing ..."
  $at_traceon






# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.











cat >expect2.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
static int yylex (int *);

%}
%skeleton "lalr1.cc"
%defines
%error-verbose
%token A 1000
%token B

%%
program: /* empty */
 | program e ';'
 | program error ';';

e: e '+' t | t;
t: A | B;

%%
/* A C++ error reporting function. */
void
yy::parser::error (const location&, const std::string& m)
{
  std::cerr << m << std::endl;
}

int
yyparse ()
{
  yy::parser parser;
  return parser.parse ();
}


static int
yylex (int *lval)
{
  static int const tokens[] =
    {
      1000, '+', '+', -1
    };
  static size_t toknum;
  *lval = 0; /* Pacify GCC.  */
  if (! (toknum < sizeof tokens / sizeof *tokens))
    abort ();
  return tokens[toknum++];
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1056: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o expect2.c expect2.y"
echo regression.at:1056 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1056"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1056: bison --xml=xml-tests/test.xml -o expect2.c expect2.y"
echo regression.at:1056 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1056"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1056: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:1056 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1056"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1056: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:1056 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1056"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:1056: bison -o expect2.c expect2.y"
echo regression.at:1056 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o expect2.c expect2.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1056"

$at_failed && at_func_log_failure
$at_traceon; }

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1056: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o expect2.cc expect2.y"
echo regression.at:1056 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o expect2.cc expect2.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o expect2.cc expect2.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1056"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1056: bison --xml=xml-tests/test.xml -o expect2.cc expect2.y"
echo regression.at:1056 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o expect2.cc expect2.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o expect2.cc expect2.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1056"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1056: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:1056 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1056"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1056: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:1056 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1056"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:1056: bison -o expect2.cc expect2.y"
echo regression.at:1056 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o expect2.cc expect2.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o expect2.cc expect2.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1056"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/regression.at:1056: \$BISON_CXX_WORKS"
echo regression.at:1056 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1056"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/regression.at:1056: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o expect2 expect2.cc \$LIBS"
echo regression.at:1056 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o expect2 expect2.cc $LIBS"; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o expect2 expect2.cc $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o expect2 expect2.cc $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1056"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/regression.at:1056:  \$PREPARSER ./expect2"
echo regression.at:1056 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./expect2"; then
  ( $at_traceon;  $PREPARSER ./expect2 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./expect2 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "syntax error, unexpected '+', expecting A or B
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/regression.at:1056"

$at_failed && at_func_log_failure
$at_traceon; }
























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_186
#AT_START_187
# 187. regression.at:1064: Braced code in declaration in rules section
at_setup_line='regression.at:1064'
at_func_banner 16
at_desc="Braced code in declaration in rules section"
$at_quiet $as_echo_n "187: $at_desc    "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "187. regression.at:1064: testing ..."
  $at_traceon


# Bison once mistook braced code in a declaration in the rules section to be a
# rule action.

cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
#include <stdio.h>
static void yyerror (char const *msg);
static int yylex (void);
%}

%error-verbose

%%

start:
  {
    printf ("Bison would once convert this action to a midrule because of the"
	    " subsequent braced code.\n");
  }
  ;

%destructor { fprintf (stderr, "DESTRUCTOR\n"); } 'a';
%printer { fprintf (yyoutput, "PRINTER"); } 'a';

%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  return 'a';
}

int
main (void)
{
  yydebug = 1;
  return !yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1112: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -t -o input.c input.y"
echo regression.at:1112 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -t -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -t -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1112"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1112: bison --xml=xml-tests/test.xml -t -o input.c input.y"
echo regression.at:1112 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -t -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -t -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1112"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1112: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:1112 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1112"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1112: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:1112 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1112"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:1112: bison -t -o input.c input.y"
echo regression.at:1112 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -t -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -t -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1112"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/regression.at:1113: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo regression.at:1113 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1113"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/regression.at:1114:  \$PREPARSER ./input"
echo regression.at:1114 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input"; then
  ( $at_traceon;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "Starting parse
Entering state 0
Reducing stack by rule 1 (line 20):
-> \$\$ = nterm start ()
Stack now 0
Entering state 1
Reading a token: Next token is token 'a' (PRINTER)
syntax error, unexpected 'a', expecting \$end
Error: popping nterm start ()
Stack now 0
Cleanup: discarding lookahead token 'a' (PRINTER)
DESTRUCTOR
Stack now 0
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Bison would once convert this action to a midrule because of the subsequent braced code.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1114"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_187
#AT_START_188
# 188. regression.at:1140: String alias declared after use
at_setup_line='regression.at:1140'
at_func_banner 16
at_desc="String alias declared after use"
$at_quiet $as_echo_n "188: $at_desc                "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "188. regression.at:1140: testing ..."
  $at_traceon


# Bison once incorrectly asserted that the symbol number for either a token or
# its alias was the highest symbol number so far at the point of the alias
# declaration.  That was true unless the declaration appeared after their first
# uses and other tokens appeared in between.

cat >input.y <<'_ATEOF'
%%
start: 'a' "A" 'b';
%token 'a' "A";
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1153: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -t -o input.c input.y"
echo regression.at:1153 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -t -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -t -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1153"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1153: bison --xml=xml-tests/test.xml -t -o input.c input.y"
echo regression.at:1153 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -t -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -t -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1153"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1153: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:1153 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1153"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1153: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:1153 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1153"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:1153: bison -t -o input.c input.y"
echo regression.at:1153 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -t -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -t -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1153"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_188
#AT_START_189
# 189. regression.at:1163: Extra lookahead sets in report
at_setup_line='regression.at:1163'
at_func_banner 16
at_desc="Extra lookahead sets in report"
$at_quiet $as_echo_n "189: $at_desc                 "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "189. regression.at:1163: testing ..."
  $at_traceon


# Bison prints each reduction's lookahead set only next to the associated
# state's one item that (1) is associated with the same rule as the reduction
# and (2) has its dot at the end of its RHS.  Previously, Bison also
# erroneously printed the lookahead set next to all of the state's other items
# associated with the same rule.  This bug affected only the `.output' file and
# not the generated parser source code.

cat >input.y <<'_ATEOF'
%%
start: a | 'a' a 'a' ;
a: 'a' ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1178: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot --report=all input.y"
echo regression.at:1178 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot --report=all input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1178"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1178: bison --xml=xml-tests/test.xml --report=all input.y"
echo regression.at:1178 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml --report=all input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml --report=all input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1178"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1178: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:1178 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1178"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1178: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:1178 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1178"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:1178: bison --report=all input.y"
echo regression.at:1178 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --report=all input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1178"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/regression.at:1179: sed -n '/^state 1\$/,/^state 2\$/p' input.output"
echo regression.at:1179 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "sed -n '/^state 1$/,/^state 2$/p' input.output"; then
  ( $at_traceon; sed -n '/^state 1$/,/^state 2$/p' input.output ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed -n '/^state 1$/,/^state 2$/p' input.output ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "state 1

    2 start: 'a' . a 'a'
    3 a: . 'a'
    3  | 'a' .  [\$end]

    'a'  shift, and go to state 4

    \$default  reduce using rule 3 (a)

    a  go to state 5


state 2
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1179"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_189
#AT_START_190
# 190. regression.at:1204: Token number in precedence declaration
at_setup_line='regression.at:1204'
at_func_banner 16
at_desc="Token number in precedence declaration"
$at_quiet $as_echo_n "190: $at_desc         "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "190. regression.at:1204: testing ..."
  $at_traceon


# POSIX says token numbers can be declared in %left, %right, and %nonassoc, but
# we lost this in Bison 1.50.

cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%{
  #include <stdio.h>
  void yyerror (char const *);
  int yylex (void);
%}

%error-verbose
%left TK1 1 TK2 2 "tok alias" 3

%%

start: TK1 sr_conflict "tok alias" ;

sr_conflict:
  TK2
  | TK2 "tok alias"
  ;

%%

void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
yylex (void)
{
  static int const input[] = { 1, 2, 3, 0 };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1251: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo regression.at:1251 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1251"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1251: bison --xml=xml-tests/test.xml -o input.c input.y"
echo regression.at:1251 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1251"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1251: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:1251 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1251"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1251: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:1251 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1251"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:1251: bison -o input.c input.y"
echo regression.at:1251 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:24.5-19: warning: rule useless in parser due to conflicts: sr_conflict: TK2 \"tok alias\"
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1251"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/regression.at:1254: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo regression.at:1254 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1254"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/regression.at:1255:  \$PREPARSER ./input"
echo regression.at:1255 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input"; then
  ( $at_traceon;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1255"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_190
#AT_START_191
# 191. regression.at:1265: Fix user actions without a trailing semicolon
at_setup_line='regression.at:1265'
at_func_banner 16
at_desc="Fix user actions without a trailing semicolon"
$at_quiet $as_echo_n "191: $at_desc  "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "191. regression.at:1265: testing ..."
  $at_traceon


# This feature is undocumented, but we accidentally broke it in 2.3a, and there
# was a complaint at:
# <http://lists.gnu.org/archive/html/bug-bison/2008-11/msg00001.html>.

cat >input.y <<'_ATEOF'
%%
start: {asdffdsa} ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1276: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo regression.at:1276 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1276"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1276: bison --xml=xml-tests/test.xml -o input.c input.y"
echo regression.at:1276 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1276"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1276: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo regression.at:1276 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1276"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/regression.at:1276: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo regression.at:1276 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1276"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/regression.at:1276: bison -o input.c input.y"
echo regression.at:1276 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1276"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/regression.at:1277: sed -n '/asdffdsa/s/^ *//p' input.c"
echo regression.at:1277 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; sed -n '/asdffdsa/s/^ *//p' input.c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed -n '/asdffdsa/s/^ *//p' input.c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "{asdffdsa;}
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/regression.at:1277"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_191
#AT_START_192
# 192. c++.at:100: Doxygen Public Documentation
at_setup_line='c++.at:100'
at_func_banner 17
at_desc="Doxygen Public Documentation"
$at_quiet $as_echo_n "192: $at_desc                   "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "192. c++.at:100: testing ..."
  $at_traceon


cat >input.yy <<'_ATEOF'
%skeleton "lalr1.cc"
%locations
%debug
%defines
%%
exp:;
%%
yy::parser::error (const location& l, const std::string& m)
{
  std::cerr << l << s << std::endl;
}
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:100: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.yy"
echo c++.at:100 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.yy ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.yy ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:100"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/c++.at:100: bison --xml=xml-tests/test.xml -o input.cc input.yy"
echo c++.at:100 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.cc input.yy ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.cc input.yy ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:100"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:100: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo c++.at:100 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:100"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:100: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo c++.at:100 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:100"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/c++.at:100: bison -o input.cc input.yy"
echo c++.at:100 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.cc input.yy ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.cc input.yy ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:100"

$at_failed && at_func_log_failure
$at_traceon; }


cat >Doxyfile <<'_ATEOF'
# The PROJECT_NAME tag is a single word (or a sequence of words
# surrounded by quotes) that should identify the project.
PROJECT_NAME = "Bison C++ Parser"

# The QUIET tag can be used to turn on/off the messages that are
# generated by doxygen. Possible values are YES and NO. If left blank
# NO is used.
QUIET = YES

# The WARNINGS tag can be used to turn on/off the warning messages
# that are generated by doxygen. Possible values are YES and NO. If
# left blank NO is used.
WARNINGS     = YES
# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate
# warnings for undocumented members. If EXTRACT_ALL is set to YES then
# this flag will automatically be disabled.
WARN_IF_UNDOCUMENTED   = YES
# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings
# for potential errors in the documentation, such as not documenting
# some parameters in a documented function, or documenting parameters
# that don't exist or using markup commands wrongly.
WARN_IF_DOC_ERROR      = YES
# The WARN_FORMAT tag determines the format of the warning messages
# that doxygen can produce. The string should contain the $file,
# $line, and $text tags, which will be replaced by the file and line
# number from which the warning originated and the warning text.
WARN_FORMAT            = "$file:$line: $text"

# If the EXTRACT_ALL tag is set to YES doxygen will assume all
# entities in documentation are documented, even if no documentation
# was available.  Private class members and static file members will
# be hidden unless the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set
# to YES
EXTRACT_ALL            = YES

# If the EXTRACT_PRIVATE tag is set to YES all private members of a
# class will be included in the documentation.
EXTRACT_PRIVATE        = NO

# If the EXTRACT_STATIC tag is set to YES all static members of a file
# will be included in the documentation.
EXTRACT_STATIC         = NO
_ATEOF


{ $at_traceoff
$as_echo "$at_srcdir/c++.at:100: doxygen --version || exit 77"
echo c++.at:100 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; doxygen --version || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; doxygen --version || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:100"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/c++.at:100: doxygen"
echo c++.at:100 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; doxygen ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; doxygen ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:100"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_192
#AT_START_193
# 193. c++.at:101: Doxygen Private Documentation
at_setup_line='c++.at:101'
at_func_banner 17
at_desc="Doxygen Private Documentation"
$at_quiet $as_echo_n "193: $at_desc                  "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "193. c++.at:101: testing ..."
  $at_traceon


cat >input.yy <<'_ATEOF'
%skeleton "lalr1.cc"
%locations
%debug
%defines
%%
exp:;
%%
yy::parser::error (const location& l, const std::string& m)
{
  std::cerr << l << s << std::endl;
}
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:101: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.yy"
echo c++.at:101 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.yy ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.yy ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:101"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/c++.at:101: bison --xml=xml-tests/test.xml -o input.cc input.yy"
echo c++.at:101 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.cc input.yy ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.cc input.yy ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:101"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:101: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo c++.at:101 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:101"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:101: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo c++.at:101 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:101"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/c++.at:101: bison -o input.cc input.yy"
echo c++.at:101 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.cc input.yy ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.cc input.yy ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:101"

$at_failed && at_func_log_failure
$at_traceon; }


cat >Doxyfile <<'_ATEOF'
# The PROJECT_NAME tag is a single word (or a sequence of words
# surrounded by quotes) that should identify the project.
PROJECT_NAME = "Bison C++ Parser"

# The QUIET tag can be used to turn on/off the messages that are
# generated by doxygen. Possible values are YES and NO. If left blank
# NO is used.
QUIET = YES

# The WARNINGS tag can be used to turn on/off the warning messages
# that are generated by doxygen. Possible values are YES and NO. If
# left blank NO is used.
WARNINGS     = YES
# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate
# warnings for undocumented members. If EXTRACT_ALL is set to YES then
# this flag will automatically be disabled.
WARN_IF_UNDOCUMENTED   = YES
# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings
# for potential errors in the documentation, such as not documenting
# some parameters in a documented function, or documenting parameters
# that don't exist or using markup commands wrongly.
WARN_IF_DOC_ERROR      = YES
# The WARN_FORMAT tag determines the format of the warning messages
# that doxygen can produce. The string should contain the $file,
# $line, and $text tags, which will be replaced by the file and line
# number from which the warning originated and the warning text.
WARN_FORMAT            = "$file:$line: $text"

# If the EXTRACT_ALL tag is set to YES doxygen will assume all
# entities in documentation are documented, even if no documentation
# was available.  Private class members and static file members will
# be hidden unless the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set
# to YES
EXTRACT_ALL            = YES

# If the EXTRACT_PRIVATE tag is set to YES all private members of a
# class will be included in the documentation.
EXTRACT_PRIVATE        = YES

# If the EXTRACT_STATIC tag is set to YES all static members of a file
# will be included in the documentation.
EXTRACT_STATIC         = YES
_ATEOF


{ $at_traceoff
$as_echo "$at_srcdir/c++.at:101: doxygen --version || exit 77"
echo c++.at:101 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; doxygen --version || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; doxygen --version || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:101"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/c++.at:101: doxygen"
echo c++.at:101 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; doxygen ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; doxygen ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:101"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_193
#AT_START_194
# 194. c++.at:159: Relative namespace references
at_setup_line='c++.at:159'
at_func_banner 17
at_desc="Relative namespace references"
$at_quiet $as_echo_n "194: $at_desc                  "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "194. c++.at:159: testing ..."
  $at_traceon



cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define namespace "foo"
%union { int i; }
%define global_tokens_and_yystype

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
foo::parser::error (const foo::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
  foo::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:160: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
echo c++.at:160 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:160"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/c++.at:160: bison --xml=xml-tests/test.xml -o input.cc input.y"
echo c++.at:160 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:160"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:160: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo c++.at:160 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:160"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:160: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo c++.at:160 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:160"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/c++.at:160: bison -o input.cc input.y"
echo c++.at:160 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:160"

$at_failed && at_func_log_failure
$at_traceon; }



{ $at_traceoff
$as_echo "$at_srcdir/c++.at:160: \$BISON_CXX_WORKS"
echo c++.at:160 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:160"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/c++.at:160: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o input input.cc \$LIBS"
echo c++.at:160 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS"; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:160"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/c++.at:160:  \$PREPARSER ./input"
echo c++.at:160 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input"; then
  ( $at_traceon;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:160"

$at_failed && at_func_log_failure
$at_traceon; }





cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define namespace "foo::bar"
%union { int i; }
%define global_tokens_and_yystype

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
foo::bar::parser::error (const foo::bar::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
  foo::bar::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:161: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
echo c++.at:161 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:161"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/c++.at:161: bison --xml=xml-tests/test.xml -o input.cc input.y"
echo c++.at:161 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:161"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:161: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo c++.at:161 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:161"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:161: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo c++.at:161 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:161"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/c++.at:161: bison -o input.cc input.y"
echo c++.at:161 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:161"

$at_failed && at_func_log_failure
$at_traceon; }



{ $at_traceoff
$as_echo "$at_srcdir/c++.at:161: \$BISON_CXX_WORKS"
echo c++.at:161 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:161"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/c++.at:161: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o input input.cc \$LIBS"
echo c++.at:161 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS"; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:161"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/c++.at:161:  \$PREPARSER ./input"
echo c++.at:161 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input"; then
  ( $at_traceon;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:161"

$at_failed && at_func_log_failure
$at_traceon; }





cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define namespace "foo::bar::baz"
%union { int i; }
%define global_tokens_and_yystype

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
foo::bar::baz::parser::error (const foo::bar::baz::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
  foo::bar::baz::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:162: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
echo c++.at:162 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:162"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/c++.at:162: bison --xml=xml-tests/test.xml -o input.cc input.y"
echo c++.at:162 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:162"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:162: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo c++.at:162 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:162"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:162: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo c++.at:162 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:162"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/c++.at:162: bison -o input.cc input.y"
echo c++.at:162 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:162"

$at_failed && at_func_log_failure
$at_traceon; }



{ $at_traceoff
$as_echo "$at_srcdir/c++.at:162: \$BISON_CXX_WORKS"
echo c++.at:162 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:162"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/c++.at:162: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o input input.cc \$LIBS"
echo c++.at:162 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS"; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:162"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/c++.at:162:  \$PREPARSER ./input"
echo c++.at:162 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input"; then
  ( $at_traceon;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:162"

$at_failed && at_func_log_failure
$at_traceon; }



  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_194
#AT_START_195
# 195. c++.at:165: Absolute namespace references
at_setup_line='c++.at:165'
at_func_banner 17
at_desc="Absolute namespace references"
$at_quiet $as_echo_n "195: $at_desc                  "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "195. c++.at:165: testing ..."
  $at_traceon



cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define namespace "::foo"
%union { int i; }
%define global_tokens_and_yystype

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
::foo::parser::error (const ::foo::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
  ::foo::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:166: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
echo c++.at:166 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:166"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/c++.at:166: bison --xml=xml-tests/test.xml -o input.cc input.y"
echo c++.at:166 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:166"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:166: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo c++.at:166 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:166"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:166: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo c++.at:166 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:166"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/c++.at:166: bison -o input.cc input.y"
echo c++.at:166 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:166"

$at_failed && at_func_log_failure
$at_traceon; }



{ $at_traceoff
$as_echo "$at_srcdir/c++.at:166: \$BISON_CXX_WORKS"
echo c++.at:166 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:166"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/c++.at:166: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o input input.cc \$LIBS"
echo c++.at:166 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS"; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:166"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/c++.at:166:  \$PREPARSER ./input"
echo c++.at:166 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input"; then
  ( $at_traceon;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:166"

$at_failed && at_func_log_failure
$at_traceon; }





cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define namespace "::foo::bar"
%union { int i; }
%define global_tokens_and_yystype

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
::foo::bar::parser::error (const ::foo::bar::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
  ::foo::bar::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:167: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
echo c++.at:167 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:167"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/c++.at:167: bison --xml=xml-tests/test.xml -o input.cc input.y"
echo c++.at:167 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:167"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:167: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo c++.at:167 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:167"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:167: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo c++.at:167 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:167"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/c++.at:167: bison -o input.cc input.y"
echo c++.at:167 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:167"

$at_failed && at_func_log_failure
$at_traceon; }



{ $at_traceoff
$as_echo "$at_srcdir/c++.at:167: \$BISON_CXX_WORKS"
echo c++.at:167 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:167"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/c++.at:167: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o input input.cc \$LIBS"
echo c++.at:167 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS"; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:167"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/c++.at:167:  \$PREPARSER ./input"
echo c++.at:167 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input"; then
  ( $at_traceon;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:167"

$at_failed && at_func_log_failure
$at_traceon; }





cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define namespace "::foo::bar::baz"
%union { int i; }
%define global_tokens_and_yystype

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
::foo::bar::baz::parser::error (const ::foo::bar::baz::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
  ::foo::bar::baz::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:168: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
echo c++.at:168 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:168"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/c++.at:168: bison --xml=xml-tests/test.xml -o input.cc input.y"
echo c++.at:168 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:168"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:168: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo c++.at:168 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:168"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:168: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo c++.at:168 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:168"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/c++.at:168: bison -o input.cc input.y"
echo c++.at:168 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:168"

$at_failed && at_func_log_failure
$at_traceon; }



{ $at_traceoff
$as_echo "$at_srcdir/c++.at:168: \$BISON_CXX_WORKS"
echo c++.at:168 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:168"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/c++.at:168: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o input input.cc \$LIBS"
echo c++.at:168 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS"; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:168"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/c++.at:168:  \$PREPARSER ./input"
echo c++.at:168 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input"; then
  ( $at_traceon;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:168"

$at_failed && at_func_log_failure
$at_traceon; }





cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define namespace "	::foo"
%union { int i; }
%define global_tokens_and_yystype

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
	::foo::parser::error (const 	::foo::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
  	::foo::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:169: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
echo c++.at:169 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:169"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/c++.at:169: bison --xml=xml-tests/test.xml -o input.cc input.y"
echo c++.at:169 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:169"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:169: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo c++.at:169 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:169"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:169: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo c++.at:169 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:169"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/c++.at:169: bison -o input.cc input.y"
echo c++.at:169 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:169"

$at_failed && at_func_log_failure
$at_traceon; }



{ $at_traceoff
$as_echo "$at_srcdir/c++.at:169: \$BISON_CXX_WORKS"
echo c++.at:169 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:169"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/c++.at:169: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o input input.cc \$LIBS"
echo c++.at:169 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS"; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:169"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/c++.at:169:  \$PREPARSER ./input"
echo c++.at:169 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input"; then
  ( $at_traceon;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:169"

$at_failed && at_func_log_failure
$at_traceon; }





cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define namespace "  	 ::foo::bar"
%union { int i; }
%define global_tokens_and_yystype

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
  	 ::foo::bar::parser::error (const   	 ::foo::bar::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
    	 ::foo::bar::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:170: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
echo c++.at:170 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:170"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/c++.at:170: bison --xml=xml-tests/test.xml -o input.cc input.y"
echo c++.at:170 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:170"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:170: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo c++.at:170 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:170"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:170: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo c++.at:170 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:170"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/c++.at:170: bison -o input.cc input.y"
echo c++.at:170 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:170"

$at_failed && at_func_log_failure
$at_traceon; }



{ $at_traceoff
$as_echo "$at_srcdir/c++.at:170: \$BISON_CXX_WORKS"
echo c++.at:170 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:170"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/c++.at:170: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o input input.cc \$LIBS"
echo c++.at:170 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS"; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:170"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/c++.at:170:  \$PREPARSER ./input"
echo c++.at:170 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input"; then
  ( $at_traceon;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:170"

$at_failed && at_func_log_failure
$at_traceon; }





cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define namespace "  ::foo::bar::baz"
%union { int i; }
%define global_tokens_and_yystype

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
  ::foo::bar::baz::parser::error (const   ::foo::bar::baz::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
    ::foo::bar::baz::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:171: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
echo c++.at:171 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:171"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/c++.at:171: bison --xml=xml-tests/test.xml -o input.cc input.y"
echo c++.at:171 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:171"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:171: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo c++.at:171 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:171"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:171: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo c++.at:171 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:171"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/c++.at:171: bison -o input.cc input.y"
echo c++.at:171 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:171"

$at_failed && at_func_log_failure
$at_traceon; }



{ $at_traceoff
$as_echo "$at_srcdir/c++.at:171: \$BISON_CXX_WORKS"
echo c++.at:171 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$BISON_CXX_WORKS"; then
  ( $at_traceon; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $BISON_CXX_WORKS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:171"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/c++.at:171: \$CXX \$CXXFLAGS \$CPPFLAGS \$LDFLAGS -o input input.cc \$LIBS"
echo c++.at:171 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS"; then
  ( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CXX $CXXFLAGS $CPPFLAGS $LDFLAGS -o input input.cc $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:171"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/c++.at:171:  \$PREPARSER ./input"
echo c++.at:171 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input"; then
  ( $at_traceon;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:171"

$at_failed && at_func_log_failure
$at_traceon; }



  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_195
#AT_START_196
# 196. c++.at:174: Syntactically invalid namespace references
at_setup_line='c++.at:174'
at_func_banner 17
at_desc="Syntactically invalid namespace references"
$at_quiet $as_echo_n "196: $at_desc     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "196. c++.at:174: testing ..."
  $at_traceon



cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define namespace ":foo:bar"
%union { int i; }
%define global_tokens_and_yystype

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
:foo:bar::parser::error (const :foo:bar::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
  :foo:bar::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:175: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
echo c++.at:175 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:175"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/c++.at:175: bison --xml=xml-tests/test.xml -o input.cc input.y"
echo c++.at:175 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:175"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:175: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo c++.at:175 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:175"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:175: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo c++.at:175 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:175"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/c++.at:175: bison -o input.cc input.y"
echo c++.at:175 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:175"

$at_failed && at_func_log_failure
$at_traceon; }







cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define namespace "foo: :bar"
%union { int i; }
%define global_tokens_and_yystype

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
foo: :bar::parser::error (const foo: :bar::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
  foo: :bar::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:176: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
echo c++.at:176 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:176"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/c++.at:176: bison --xml=xml-tests/test.xml -o input.cc input.y"
echo c++.at:176 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:176"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:176: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo c++.at:176 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:176"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:176: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo c++.at:176 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:176"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/c++.at:176: bison -o input.cc input.y"
echo c++.at:176 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:176"

$at_failed && at_func_log_failure
$at_traceon; }





# This one is interesting because `[3]' is encoded as `[3]', which
# contains single occurrences of `:'.


cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define namespace "foo[3]::bar::baz"
%union { int i; }
%define global_tokens_and_yystype

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
foo[3]::bar::baz::parser::error (const foo[3]::bar::baz::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
  foo[3]::bar::baz::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:179: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
echo c++.at:179 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:179"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/c++.at:179: bison --xml=xml-tests/test.xml -o input.cc input.y"
echo c++.at:179 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:179"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:179: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo c++.at:179 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:179"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:179: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo c++.at:179 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:179"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/c++.at:179: bison -o input.cc input.y"
echo c++.at:179 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:179"

$at_failed && at_func_log_failure
$at_traceon; }







cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define namespace "foo::bar,baz"
%union { int i; }
%define global_tokens_and_yystype

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
foo::bar,baz::parser::error (const foo::bar,baz::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
  foo::bar,baz::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:180: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
echo c++.at:180 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:180"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/c++.at:180: bison --xml=xml-tests/test.xml -o input.cc input.y"
echo c++.at:180 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:180"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:180: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo c++.at:180 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:180"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:180: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo c++.at:180 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:180"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/c++.at:180: bison -o input.cc input.y"
echo c++.at:180 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:180"

$at_failed && at_func_log_failure
$at_traceon; }







cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%language "C++"
%defines
%define namespace "foo::bar::(baz"
%union { int i; }
%define global_tokens_and_yystype

%code {
  // YYSTYPE contains a namespace reference.
  int yylex (YYSTYPE *lval) {
    lval->i = 3;
    return 0;
  }
}

%%

start: ;

%%

void
foo::bar::(baz::parser::error (const foo::bar::(baz::parser::location_type &loc,
                     const std::string &msg)
{
  std::cerr << "At " << loc << ": " << msg << std::endl;
}

int
main (void)
{
  foo::bar::(baz::parser p;
  return p.parse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:181: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.cc input.y"
echo c++.at:181 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:181"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/c++.at:181: bison --xml=xml-tests/test.xml -o input.cc input.y"
echo c++.at:181 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/c++.at:181"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:181: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo c++.at:181 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:181"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/c++.at:181: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo c++.at:181 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:181"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/c++.at:181: bison -o input.cc input.y"
echo c++.at:181 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.cc input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/c++.at:181"

$at_failed && at_func_log_failure
$at_traceon; }





  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_196
#AT_START_197
# 197. java.at:385: Calculator
at_setup_line='java.at:385'
at_func_banner 18
at_desc="Calculator "
$at_quiet $as_echo_n "197: $at_desc                                    "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "197. java.at:385: testing ..."
  $at_traceon







# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.












cat >Calc.y <<'_ATEOF'
/* Infix notation calculator--calc */
%language "Java"
%name-prefix "Calc"
%define parser_class_name "Calc"
%define public


%code {

  public static void main (String args[]) throws IOException
  {
    CalcLexer l = new CalcLexer (System.in);
    Calc p = new Calc (l);
    p.parse ();
  }

}

%code imports {
  import java.io.StreamTokenizer;
  import java.io.InputStream;
  import java.io.InputStreamReader;
  import java.io.Reader;
  import java.io.IOException;
}

/* Bison Declarations */
%token <Integer> NUM "number"
%type  <Integer> exp

%nonassoc '=' /* comparison            */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'
| exp '\n'
| error '\n'
;

exp:
  NUM                { $$ = $1;                                             }
| exp '=' exp
  {
    if ($1.intValue () != $3.intValue ())
      yyerror ("calc: error: " + $1 + " != " + $3);
  }
| exp '+' exp        { $$ = new Integer ($1.intValue () + $3.intValue ());  }
| exp '-' exp        { $$ = new Integer ($1.intValue () - $3.intValue ());  }
| exp '*' exp        { $$ = new Integer ($1.intValue () * $3.intValue ());  }
| exp '/' exp        { $$ = new Integer ($1.intValue () / $3.intValue ());  }
| '-' exp  %prec NEG { $$ = new Integer (-$2.intValue ());                  }
| exp '^' exp        { $$ = new Integer ((int)
                                         Math.pow ($1.intValue (),
                                                   $3.intValue ()));        }
| '(' exp ')'        { $$ = $2;                                             }
| '(' error ')'      { $$ = new Integer (1111);                             }
| '!'                { $$ = new Integer (0); return YYERROR;                }
| '-' error          { $$ = new Integer (0); return YYERROR;                }
;


%%
class CalcLexer implements Calc.Lexer {

  StreamTokenizer st;

  public CalcLexer (InputStream is)
  {
    st = new StreamTokenizer (new InputStreamReader (is));
    st.resetSyntax ();
    st.eolIsSignificant (true);
    st.whitespaceChars (9, 9);
    st.whitespaceChars (32, 32);
    st.wordChars (48, 57);
  }


  public void yyerror (String s)
  {
    System.err.println (s);
  }


  Integer yylval;

  public Object getLVal() {
    return yylval;
  }

  public int yylex () throws IOException {
    int ttype = st.nextToken ();

    if (ttype == st.TT_EOF)
      return Calc.EOF;

    else if (ttype == st.TT_EOL)
      {

        return (int) '\n';
      }

    else if (ttype == st.TT_WORD)
      {
        yylval = new Integer (st.sval);
        return Calc.NUM;
      }

    else
      return st.ttype;
  }



}


class Position {
  public int line;

  public Position ()
  {
    line = 0;
  }

  public Position (int l)
  {
    line = l;
  }

  public long getHashCode ()
  {
    return line;
  }

  public boolean equals (Position l)
  {
    return l.line == line;
  }

  public String toString ()
  {
    return Integer.toString (line);
  }

  public int lineno ()
  {
    return line;
  }
}

_ATEOF




if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:385: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o Calc.java Calc.y"
echo java.at:385 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:385: bison --xml=xml-tests/test.xml -o Calc.java Calc.y"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:385: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:385 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:385: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:385 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: bison -o Calc.java Calc.y"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:385 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: \$SHELL ../../../javacomp.sh Calc.java"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh Calc.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh Calc.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh Calc.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected $undefined
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '='
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
2: syntax error, unexpected '+'
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < /dev/null"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < /dev/null"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < /dev/null ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < /dev/null ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected end of input
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_197
#AT_START_198
# 198. java.at:385: Calculator %error-verbose
at_setup_line='java.at:385'
at_func_banner 18
at_desc="Calculator %error-verbose "
$at_quiet $as_echo_n "198: $at_desc                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "198. java.at:385: testing ..."
  $at_traceon







# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.












cat >Calc.y <<'_ATEOF'
/* Infix notation calculator--calc */
%language "Java"
%name-prefix "Calc"
%define parser_class_name "Calc"
%define public

%error-verbose
%code {

  public static void main (String args[]) throws IOException
  {
    CalcLexer l = new CalcLexer (System.in);
    Calc p = new Calc (l);
    p.parse ();
  }

}

%code imports {
  import java.io.StreamTokenizer;
  import java.io.InputStream;
  import java.io.InputStreamReader;
  import java.io.Reader;
  import java.io.IOException;
}

/* Bison Declarations */
%token <Integer> NUM "number"
%type  <Integer> exp

%nonassoc '=' /* comparison            */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'
| exp '\n'
| error '\n'
;

exp:
  NUM                { $$ = $1;                                             }
| exp '=' exp
  {
    if ($1.intValue () != $3.intValue ())
      yyerror ("calc: error: " + $1 + " != " + $3);
  }
| exp '+' exp        { $$ = new Integer ($1.intValue () + $3.intValue ());  }
| exp '-' exp        { $$ = new Integer ($1.intValue () - $3.intValue ());  }
| exp '*' exp        { $$ = new Integer ($1.intValue () * $3.intValue ());  }
| exp '/' exp        { $$ = new Integer ($1.intValue () / $3.intValue ());  }
| '-' exp  %prec NEG { $$ = new Integer (-$2.intValue ());                  }
| exp '^' exp        { $$ = new Integer ((int)
                                         Math.pow ($1.intValue (),
                                                   $3.intValue ()));        }
| '(' exp ')'        { $$ = $2;                                             }
| '(' error ')'      { $$ = new Integer (1111);                             }
| '!'                { $$ = new Integer (0); return YYERROR;                }
| '-' error          { $$ = new Integer (0); return YYERROR;                }
;


%%
class CalcLexer implements Calc.Lexer {

  StreamTokenizer st;

  public CalcLexer (InputStream is)
  {
    st = new StreamTokenizer (new InputStreamReader (is));
    st.resetSyntax ();
    st.eolIsSignificant (true);
    st.whitespaceChars (9, 9);
    st.whitespaceChars (32, 32);
    st.wordChars (48, 57);
  }


  public void yyerror (String s)
  {
    System.err.println (s);
  }


  Integer yylval;

  public Object getLVal() {
    return yylval;
  }

  public int yylex () throws IOException {
    int ttype = st.nextToken ();

    if (ttype == st.TT_EOF)
      return Calc.EOF;

    else if (ttype == st.TT_EOL)
      {

        return (int) '\n';
      }

    else if (ttype == st.TT_WORD)
      {
        yylval = new Integer (st.sval);
        return Calc.NUM;
      }

    else
      return st.ttype;
  }



}


class Position {
  public int line;

  public Position ()
  {
    line = 0;
  }

  public Position (int l)
  {
    line = l;
  }

  public long getHashCode ()
  {
    return line;
  }

  public boolean equals (Position l)
  {
    return l.line == line;
  }

  public String toString ()
  {
    return Integer.toString (line);
  }

  public int lineno ()
  {
    return line;
  }
}

_ATEOF




if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:385: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o Calc.java Calc.y"
echo java.at:385 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:385: bison --xml=xml-tests/test.xml -o Calc.java Calc.y"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:385: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:385 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:385: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:385 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: bison -o Calc.java Calc.y"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:385 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: \$SHELL ../../../javacomp.sh Calc.java"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh Calc.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh Calc.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh Calc.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected $undefined
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '='
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
2: syntax error, unexpected '+'
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < /dev/null"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < /dev/null"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < /dev/null ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < /dev/null ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected end of input
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_198
#AT_START_199
# 199. java.at:385: Calculator %locations
at_setup_line='java.at:385'
at_func_banner 18
at_desc="Calculator %locations "
$at_quiet $as_echo_n "199: $at_desc                         "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "199. java.at:385: testing ..."
  $at_traceon







# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.












cat >Calc.y <<'_ATEOF'
/* Infix notation calculator--calc */
%language "Java"
%name-prefix "Calc"
%define parser_class_name "Calc"
%define public

%locations
%code {

  public static void main (String args[]) throws IOException
  {
    CalcLexer l = new CalcLexer (System.in);
    Calc p = new Calc (l);
    p.parse ();
  }

}

%code imports {
  import java.io.StreamTokenizer;
  import java.io.InputStream;
  import java.io.InputStreamReader;
  import java.io.Reader;
  import java.io.IOException;
}

/* Bison Declarations */
%token <Integer> NUM "number"
%type  <Integer> exp

%nonassoc '=' /* comparison            */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'
| exp '\n'
| error '\n'
;

exp:
  NUM                { $$ = $1;                                             }
| exp '=' exp
  {
    if ($1.intValue () != $3.intValue ())
      yyerror ("calc: error: " + $1 + " != " + $3);
  }
| exp '+' exp        { $$ = new Integer ($1.intValue () + $3.intValue ());  }
| exp '-' exp        { $$ = new Integer ($1.intValue () - $3.intValue ());  }
| exp '*' exp        { $$ = new Integer ($1.intValue () * $3.intValue ());  }
| exp '/' exp        { $$ = new Integer ($1.intValue () / $3.intValue ());  }
| '-' exp  %prec NEG { $$ = new Integer (-$2.intValue ());                  }
| exp '^' exp        { $$ = new Integer ((int)
                                         Math.pow ($1.intValue (),
                                                   $3.intValue ()));        }
| '(' exp ')'        { $$ = $2;                                             }
| '(' error ')'      { $$ = new Integer (1111);                             }
| '!'                { $$ = new Integer (0); return YYERROR;                }
| '-' error          { $$ = new Integer (0); return YYERROR;                }
;


%%
class CalcLexer implements Calc.Lexer {

  StreamTokenizer st;

  public CalcLexer (InputStream is)
  {
    st = new StreamTokenizer (new InputStreamReader (is));
    st.resetSyntax ();
    st.eolIsSignificant (true);
    st.whitespaceChars (9, 9);
    st.whitespaceChars (32, 32);
    st.wordChars (48, 57);
  }


  Position yystartpos;
  Position yyendpos = new Position (1);

  public Position getStartPos() {
    return yystartpos;
  }

  public Position getEndPos() {
    return yyendpos;
  }

  public void yyerror (Calc.Location l, String s)
  {
    if (l == null)
      System.err.println (s);
    else
      System.err.println (l.begin + ": " + s);
  }


  Integer yylval;

  public Object getLVal() {
    return yylval;
  }

  public int yylex () throws IOException {
    int ttype = st.nextToken ();
    yystartpos = yyendpos;
    if (ttype == st.TT_EOF)
      return Calc.EOF;

    else if (ttype == st.TT_EOL)
      {
        yyendpos = new Position (yyendpos.lineno () + 1);
        return (int) '\n';
      }

    else if (ttype == st.TT_WORD)
      {
        yylval = new Integer (st.sval);
        return Calc.NUM;
      }

    else
      return st.ttype;
  }



}


class Position {
  public int line;

  public Position ()
  {
    line = 0;
  }

  public Position (int l)
  {
    line = l;
  }

  public long getHashCode ()
  {
    return line;
  }

  public boolean equals (Position l)
  {
    return l.line == line;
  }

  public String toString ()
  {
    return Integer.toString (line);
  }

  public int lineno ()
  {
    return line;
  }
}

_ATEOF




if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:385: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o Calc.java Calc.y"
echo java.at:385 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:385: bison --xml=xml-tests/test.xml -o Calc.java Calc.y"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:385: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:385 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:385: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:385 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: bison -o Calc.java Calc.y"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:385 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: \$SHELL ../../../javacomp.sh Calc.java"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh Calc.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh Calc.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh Calc.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected $undefined
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '='
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
2: syntax error, unexpected '+'
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < /dev/null"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < /dev/null"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < /dev/null ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < /dev/null ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected end of input
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_199
#AT_START_200
# 200. java.at:385: Calculator %error-verbose %locations
at_setup_line='java.at:385'
at_func_banner 18
at_desc="Calculator %error-verbose %locations "
$at_quiet $as_echo_n "200: $at_desc          "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "200. java.at:385: testing ..."
  $at_traceon







# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.












cat >Calc.y <<'_ATEOF'
/* Infix notation calculator--calc */
%language "Java"
%name-prefix "Calc"
%define parser_class_name "Calc"
%define public

%error-verbose %locations
%code {

  public static void main (String args[]) throws IOException
  {
    CalcLexer l = new CalcLexer (System.in);
    Calc p = new Calc (l);
    p.parse ();
  }

}

%code imports {
  import java.io.StreamTokenizer;
  import java.io.InputStream;
  import java.io.InputStreamReader;
  import java.io.Reader;
  import java.io.IOException;
}

/* Bison Declarations */
%token <Integer> NUM "number"
%type  <Integer> exp

%nonassoc '=' /* comparison            */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'
| exp '\n'
| error '\n'
;

exp:
  NUM                { $$ = $1;                                             }
| exp '=' exp
  {
    if ($1.intValue () != $3.intValue ())
      yyerror ("calc: error: " + $1 + " != " + $3);
  }
| exp '+' exp        { $$ = new Integer ($1.intValue () + $3.intValue ());  }
| exp '-' exp        { $$ = new Integer ($1.intValue () - $3.intValue ());  }
| exp '*' exp        { $$ = new Integer ($1.intValue () * $3.intValue ());  }
| exp '/' exp        { $$ = new Integer ($1.intValue () / $3.intValue ());  }
| '-' exp  %prec NEG { $$ = new Integer (-$2.intValue ());                  }
| exp '^' exp        { $$ = new Integer ((int)
                                         Math.pow ($1.intValue (),
                                                   $3.intValue ()));        }
| '(' exp ')'        { $$ = $2;                                             }
| '(' error ')'      { $$ = new Integer (1111);                             }
| '!'                { $$ = new Integer (0); return YYERROR;                }
| '-' error          { $$ = new Integer (0); return YYERROR;                }
;


%%
class CalcLexer implements Calc.Lexer {

  StreamTokenizer st;

  public CalcLexer (InputStream is)
  {
    st = new StreamTokenizer (new InputStreamReader (is));
    st.resetSyntax ();
    st.eolIsSignificant (true);
    st.whitespaceChars (9, 9);
    st.whitespaceChars (32, 32);
    st.wordChars (48, 57);
  }


  Position yystartpos;
  Position yyendpos = new Position (1);

  public Position getStartPos() {
    return yystartpos;
  }

  public Position getEndPos() {
    return yyendpos;
  }

  public void yyerror (Calc.Location l, String s)
  {
    if (l == null)
      System.err.println (s);
    else
      System.err.println (l.begin + ": " + s);
  }


  Integer yylval;

  public Object getLVal() {
    return yylval;
  }

  public int yylex () throws IOException {
    int ttype = st.nextToken ();
    yystartpos = yyendpos;
    if (ttype == st.TT_EOF)
      return Calc.EOF;

    else if (ttype == st.TT_EOL)
      {
        yyendpos = new Position (yyendpos.lineno () + 1);
        return (int) '\n';
      }

    else if (ttype == st.TT_WORD)
      {
        yylval = new Integer (st.sval);
        return Calc.NUM;
      }

    else
      return st.ttype;
  }



}


class Position {
  public int line;

  public Position ()
  {
    line = 0;
  }

  public Position (int l)
  {
    line = l;
  }

  public long getHashCode ()
  {
    return line;
  }

  public boolean equals (Position l)
  {
    return l.line == line;
  }

  public String toString ()
  {
    return Integer.toString (line);
  }

  public int lineno ()
  {
    return line;
  }
}

_ATEOF




if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:385: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o Calc.java Calc.y"
echo java.at:385 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:385: bison --xml=xml-tests/test.xml -o Calc.java Calc.y"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:385: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:385 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:385: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:385 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: bison -o Calc.java Calc.y"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:385 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: \$SHELL ../../../javacomp.sh Calc.java"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh Calc.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh Calc.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh Calc.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected $undefined
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '='
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
2: syntax error, unexpected '+'
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < /dev/null"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < /dev/null"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < /dev/null ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < /dev/null ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected end of input
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:385:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:385: cat stderr"
echo java.at:385 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:385"

$at_failed && at_func_log_failure
$at_traceon; }


























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_200
#AT_START_201
# 201. java.at:394: Calculator %lex-param { InputStream is }
at_setup_line='java.at:394'
at_func_banner 18
at_desc="Calculator %lex-param { InputStream is } "
$at_quiet $as_echo_n "201: $at_desc      "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "201. java.at:394: testing ..."
  $at_traceon







# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.












cat >Calc.y <<'_ATEOF'
/* Infix notation calculator--calc */
%language "Java"
%name-prefix "Calc"
%define parser_class_name "Calc"
%define public

%lex-param { InputStream is }
%code {

  public static void main (String args[]) throws IOException
  {
    new Calc (System.in).parse ();
  }

}

%code imports {
  import java.io.StreamTokenizer;
  import java.io.InputStream;
  import java.io.InputStreamReader;
  import java.io.Reader;
  import java.io.IOException;
}

/* Bison Declarations */
%token <Integer> NUM "number"
%type  <Integer> exp

%nonassoc '=' /* comparison            */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'
| exp '\n'
| error '\n'
;

exp:
  NUM                { $$ = $1;                                             }
| exp '=' exp
  {
    if ($1.intValue () != $3.intValue ())
      yyerror ("calc: error: " + $1 + " != " + $3);
  }
| exp '+' exp        { $$ = new Integer ($1.intValue () + $3.intValue ());  }
| exp '-' exp        { $$ = new Integer ($1.intValue () - $3.intValue ());  }
| exp '*' exp        { $$ = new Integer ($1.intValue () * $3.intValue ());  }
| exp '/' exp        { $$ = new Integer ($1.intValue () / $3.intValue ());  }
| '-' exp  %prec NEG { $$ = new Integer (-$2.intValue ());                  }
| exp '^' exp        { $$ = new Integer ((int)
                                         Math.pow ($1.intValue (),
                                                   $3.intValue ()));        }
| '(' exp ')'        { $$ = $2;                                             }
| '(' error ')'      { $$ = new Integer (1111);                             }
| '!'                { $$ = new Integer (0); return YYERROR;                }
| '-' error          { $$ = new Integer (0); return YYERROR;                }
;


%code lexer {

  StreamTokenizer st;

  public YYLexer (InputStream is)
  {
    st = new StreamTokenizer (new InputStreamReader (is));
    st.resetSyntax ();
    st.eolIsSignificant (true);
    st.whitespaceChars (9, 9);
    st.whitespaceChars (32, 32);
    st.wordChars (48, 57);
  }


  public void yyerror (String s)
  {
    System.err.println (s);
  }


  Integer yylval;

  public Object getLVal() {
    return yylval;
  }

  public int yylex () throws IOException {
    int ttype = st.nextToken ();

    if (ttype == st.TT_EOF)
      return Calc.EOF;

    else if (ttype == st.TT_EOL)
      {

        return (int) '\n';
      }

    else if (ttype == st.TT_WORD)
      {
        yylval = new Integer (st.sval);
        return Calc.NUM;
      }

    else
      return st.ttype;
  }



};
%%


class Position {
  public int line;

  public Position ()
  {
    line = 0;
  }

  public Position (int l)
  {
    line = l;
  }

  public long getHashCode ()
  {
    return line;
  }

  public boolean equals (Position l)
  {
    return l.line == line;
  }

  public String toString ()
  {
    return Integer.toString (line);
  }

  public int lineno ()
  {
    return line;
  }
}

_ATEOF




if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:394: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o Calc.java Calc.y"
echo java.at:394 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:394: bison --xml=xml-tests/test.xml -o Calc.java Calc.y"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:394: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:394 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:394: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:394 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: bison -o Calc.java Calc.y"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:394 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: \$SHELL ../../../javacomp.sh Calc.java"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh Calc.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh Calc.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh Calc.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected $undefined
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '='
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
2: syntax error, unexpected '+'
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < /dev/null"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < /dev/null"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < /dev/null ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < /dev/null ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected end of input
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_201
#AT_START_202
# 202. java.at:394: Calculator %error-verbose %lex-param { InputStream is }
at_setup_line='java.at:394'
at_func_banner 18
at_desc="Calculator %error-verbose %lex-param { InputStream is } "
$at_quiet $as_echo_n "202: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "202. java.at:394: testing ..."
  $at_traceon







# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.












cat >Calc.y <<'_ATEOF'
/* Infix notation calculator--calc */
%language "Java"
%name-prefix "Calc"
%define parser_class_name "Calc"
%define public

%error-verbose %lex-param { InputStream is }
%code {

  public static void main (String args[]) throws IOException
  {
    new Calc (System.in).parse ();
  }

}

%code imports {
  import java.io.StreamTokenizer;
  import java.io.InputStream;
  import java.io.InputStreamReader;
  import java.io.Reader;
  import java.io.IOException;
}

/* Bison Declarations */
%token <Integer> NUM "number"
%type  <Integer> exp

%nonassoc '=' /* comparison            */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'
| exp '\n'
| error '\n'
;

exp:
  NUM                { $$ = $1;                                             }
| exp '=' exp
  {
    if ($1.intValue () != $3.intValue ())
      yyerror ("calc: error: " + $1 + " != " + $3);
  }
| exp '+' exp        { $$ = new Integer ($1.intValue () + $3.intValue ());  }
| exp '-' exp        { $$ = new Integer ($1.intValue () - $3.intValue ());  }
| exp '*' exp        { $$ = new Integer ($1.intValue () * $3.intValue ());  }
| exp '/' exp        { $$ = new Integer ($1.intValue () / $3.intValue ());  }
| '-' exp  %prec NEG { $$ = new Integer (-$2.intValue ());                  }
| exp '^' exp        { $$ = new Integer ((int)
                                         Math.pow ($1.intValue (),
                                                   $3.intValue ()));        }
| '(' exp ')'        { $$ = $2;                                             }
| '(' error ')'      { $$ = new Integer (1111);                             }
| '!'                { $$ = new Integer (0); return YYERROR;                }
| '-' error          { $$ = new Integer (0); return YYERROR;                }
;


%code lexer {

  StreamTokenizer st;

  public YYLexer (InputStream is)
  {
    st = new StreamTokenizer (new InputStreamReader (is));
    st.resetSyntax ();
    st.eolIsSignificant (true);
    st.whitespaceChars (9, 9);
    st.whitespaceChars (32, 32);
    st.wordChars (48, 57);
  }


  public void yyerror (String s)
  {
    System.err.println (s);
  }


  Integer yylval;

  public Object getLVal() {
    return yylval;
  }

  public int yylex () throws IOException {
    int ttype = st.nextToken ();

    if (ttype == st.TT_EOF)
      return Calc.EOF;

    else if (ttype == st.TT_EOL)
      {

        return (int) '\n';
      }

    else if (ttype == st.TT_WORD)
      {
        yylval = new Integer (st.sval);
        return Calc.NUM;
      }

    else
      return st.ttype;
  }



};
%%


class Position {
  public int line;

  public Position ()
  {
    line = 0;
  }

  public Position (int l)
  {
    line = l;
  }

  public long getHashCode ()
  {
    return line;
  }

  public boolean equals (Position l)
  {
    return l.line == line;
  }

  public String toString ()
  {
    return Integer.toString (line);
  }

  public int lineno ()
  {
    return line;
  }
}

_ATEOF




if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:394: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o Calc.java Calc.y"
echo java.at:394 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:394: bison --xml=xml-tests/test.xml -o Calc.java Calc.y"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:394: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:394 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:394: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:394 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: bison -o Calc.java Calc.y"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:394 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: \$SHELL ../../../javacomp.sh Calc.java"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh Calc.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh Calc.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh Calc.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected $undefined
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '='
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
2: syntax error, unexpected '+'
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < /dev/null"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < /dev/null"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < /dev/null ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < /dev/null ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected end of input
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_202
#AT_START_203
# 203. java.at:394: Calculator %locations %lex-param { InputStream is }
at_setup_line='java.at:394'
at_func_banner 18
at_desc="Calculator %locations %lex-param { InputStream is } "
$at_quiet $as_echo_n "203: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "203. java.at:394: testing ..."
  $at_traceon







# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.












cat >Calc.y <<'_ATEOF'
/* Infix notation calculator--calc */
%language "Java"
%name-prefix "Calc"
%define parser_class_name "Calc"
%define public

%locations %lex-param { InputStream is }
%code {

  public static void main (String args[]) throws IOException
  {
    new Calc (System.in).parse ();
  }

}

%code imports {
  import java.io.StreamTokenizer;
  import java.io.InputStream;
  import java.io.InputStreamReader;
  import java.io.Reader;
  import java.io.IOException;
}

/* Bison Declarations */
%token <Integer> NUM "number"
%type  <Integer> exp

%nonassoc '=' /* comparison            */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'
| exp '\n'
| error '\n'
;

exp:
  NUM                { $$ = $1;                                             }
| exp '=' exp
  {
    if ($1.intValue () != $3.intValue ())
      yyerror ("calc: error: " + $1 + " != " + $3);
  }
| exp '+' exp        { $$ = new Integer ($1.intValue () + $3.intValue ());  }
| exp '-' exp        { $$ = new Integer ($1.intValue () - $3.intValue ());  }
| exp '*' exp        { $$ = new Integer ($1.intValue () * $3.intValue ());  }
| exp '/' exp        { $$ = new Integer ($1.intValue () / $3.intValue ());  }
| '-' exp  %prec NEG { $$ = new Integer (-$2.intValue ());                  }
| exp '^' exp        { $$ = new Integer ((int)
                                         Math.pow ($1.intValue (),
                                                   $3.intValue ()));        }
| '(' exp ')'        { $$ = $2;                                             }
| '(' error ')'      { $$ = new Integer (1111);                             }
| '!'                { $$ = new Integer (0); return YYERROR;                }
| '-' error          { $$ = new Integer (0); return YYERROR;                }
;


%code lexer {

  StreamTokenizer st;

  public YYLexer (InputStream is)
  {
    st = new StreamTokenizer (new InputStreamReader (is));
    st.resetSyntax ();
    st.eolIsSignificant (true);
    st.whitespaceChars (9, 9);
    st.whitespaceChars (32, 32);
    st.wordChars (48, 57);
  }


  Position yystartpos;
  Position yyendpos = new Position (1);

  public Position getStartPos() {
    return yystartpos;
  }

  public Position getEndPos() {
    return yyendpos;
  }

  public void yyerror (Calc.Location l, String s)
  {
    if (l == null)
      System.err.println (s);
    else
      System.err.println (l.begin + ": " + s);
  }


  Integer yylval;

  public Object getLVal() {
    return yylval;
  }

  public int yylex () throws IOException {
    int ttype = st.nextToken ();
    yystartpos = yyendpos;
    if (ttype == st.TT_EOF)
      return Calc.EOF;

    else if (ttype == st.TT_EOL)
      {
        yyendpos = new Position (yyendpos.lineno () + 1);
        return (int) '\n';
      }

    else if (ttype == st.TT_WORD)
      {
        yylval = new Integer (st.sval);
        return Calc.NUM;
      }

    else
      return st.ttype;
  }



};
%%


class Position {
  public int line;

  public Position ()
  {
    line = 0;
  }

  public Position (int l)
  {
    line = l;
  }

  public long getHashCode ()
  {
    return line;
  }

  public boolean equals (Position l)
  {
    return l.line == line;
  }

  public String toString ()
  {
    return Integer.toString (line);
  }

  public int lineno ()
  {
    return line;
  }
}

_ATEOF




if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:394: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o Calc.java Calc.y"
echo java.at:394 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:394: bison --xml=xml-tests/test.xml -o Calc.java Calc.y"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:394: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:394 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:394: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:394 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: bison -o Calc.java Calc.y"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:394 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: \$SHELL ../../../javacomp.sh Calc.java"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh Calc.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh Calc.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh Calc.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected $undefined
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '='
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
2: syntax error, unexpected '+'
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < /dev/null"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < /dev/null"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < /dev/null ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < /dev/null ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected end of input
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_203
#AT_START_204
# 204. java.at:394: Calculator %error-verbose %locations %lex-param { InputStream is }
at_setup_line='java.at:394'
at_func_banner 18
at_desc="Calculator %error-verbose %locations %lex-param { InputStream is } "
$at_quiet $as_echo_n "204: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "204. java.at:394: testing ..."
  $at_traceon







# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.












cat >Calc.y <<'_ATEOF'
/* Infix notation calculator--calc */
%language "Java"
%name-prefix "Calc"
%define parser_class_name "Calc"
%define public

%error-verbose %locations %lex-param { InputStream is }
%code {

  public static void main (String args[]) throws IOException
  {
    new Calc (System.in).parse ();
  }

}

%code imports {
  import java.io.StreamTokenizer;
  import java.io.InputStream;
  import java.io.InputStreamReader;
  import java.io.Reader;
  import java.io.IOException;
}

/* Bison Declarations */
%token <Integer> NUM "number"
%type  <Integer> exp

%nonassoc '=' /* comparison            */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'
| exp '\n'
| error '\n'
;

exp:
  NUM                { $$ = $1;                                             }
| exp '=' exp
  {
    if ($1.intValue () != $3.intValue ())
      yyerror ("calc: error: " + $1 + " != " + $3);
  }
| exp '+' exp        { $$ = new Integer ($1.intValue () + $3.intValue ());  }
| exp '-' exp        { $$ = new Integer ($1.intValue () - $3.intValue ());  }
| exp '*' exp        { $$ = new Integer ($1.intValue () * $3.intValue ());  }
| exp '/' exp        { $$ = new Integer ($1.intValue () / $3.intValue ());  }
| '-' exp  %prec NEG { $$ = new Integer (-$2.intValue ());                  }
| exp '^' exp        { $$ = new Integer ((int)
                                         Math.pow ($1.intValue (),
                                                   $3.intValue ()));        }
| '(' exp ')'        { $$ = $2;                                             }
| '(' error ')'      { $$ = new Integer (1111);                             }
| '!'                { $$ = new Integer (0); return YYERROR;                }
| '-' error          { $$ = new Integer (0); return YYERROR;                }
;


%code lexer {

  StreamTokenizer st;

  public YYLexer (InputStream is)
  {
    st = new StreamTokenizer (new InputStreamReader (is));
    st.resetSyntax ();
    st.eolIsSignificant (true);
    st.whitespaceChars (9, 9);
    st.whitespaceChars (32, 32);
    st.wordChars (48, 57);
  }


  Position yystartpos;
  Position yyendpos = new Position (1);

  public Position getStartPos() {
    return yystartpos;
  }

  public Position getEndPos() {
    return yyendpos;
  }

  public void yyerror (Calc.Location l, String s)
  {
    if (l == null)
      System.err.println (s);
    else
      System.err.println (l.begin + ": " + s);
  }


  Integer yylval;

  public Object getLVal() {
    return yylval;
  }

  public int yylex () throws IOException {
    int ttype = st.nextToken ();
    yystartpos = yyendpos;
    if (ttype == st.TT_EOF)
      return Calc.EOF;

    else if (ttype == st.TT_EOL)
      {
        yyendpos = new Position (yyendpos.lineno () + 1);
        return (int) '\n';
      }

    else if (ttype == st.TT_WORD)
      {
        yylval = new Integer (st.sval);
        return Calc.NUM;
      }

    else
      return st.ttype;
  }



};
%%


class Position {
  public int line;

  public Position ()
  {
    line = 0;
  }

  public Position (int l)
  {
    line = l;
  }

  public long getHashCode ()
  {
    return line;
  }

  public boolean equals (Position l)
  {
    return l.line == line;
  }

  public String toString ()
  {
    return Integer.toString (line);
  }

  public int lineno ()
  {
    return line;
  }
}

_ATEOF




if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:394: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o Calc.java Calc.y"
echo java.at:394 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:394: bison --xml=xml-tests/test.xml -o Calc.java Calc.y"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:394: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:394 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:394: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:394 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: bison -o Calc.java Calc.y"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o Calc.java Calc.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:394 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: \$SHELL ../../../javacomp.sh Calc.java"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh Calc.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh Calc.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh Calc.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1//2
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '/', expecting number or '-' or '(' or '!'
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
error
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected $undefined
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '='
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'

+1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
2: syntax error, unexpected '+'
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Exercise error messages with EOF: work on an empty file.
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < /dev/null"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < /dev/null"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < /dev/null ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < /dev/null ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected end of input
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/java.at:394:  \$SHELL ../../../javaexec.sh Calc < input"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $SHELL ../../../javaexec.sh Calc < input"; then
  ( $at_traceon;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $SHELL ../../../javaexec.sh Calc < input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; tee stderr <"$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
cat >expout <<'_ATEOF'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected number
calc: error: 2222 != 1
_ATEOF

# 2. If locations are not used, remove them.

# 3. If error-verbose is not used, strip the`, unexpected....' part.

# 4. Check
{ $at_traceoff
$as_echo "$at_srcdir/java.at:394: cat stderr"
echo java.at:394 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; cat stderr ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; cat stderr ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:394"

$at_failed && at_func_log_failure
$at_traceon; }


























  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_204
#AT_START_205
# 205. java.at:480: Java parser class and package names
at_setup_line='java.at:480'
at_func_banner 19
at_desc="Java parser class and package names"
$at_quiet $as_echo_n "205: $at_desc            "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "205. java.at:480: testing ..."
  $at_traceon



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:482: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:482 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:482"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:482: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:482 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:482"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:482: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:482 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:482"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:482: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:482 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:482"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:482: bison YYParser.y"
echo java.at:482 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:482"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:482: grep -q '[mb]4_' YYParser.y"
echo java.at:482 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:482"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:482: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:482 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:482"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:482: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:482 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:482"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:483: grep -c '^class YYParser\$' YYParser.java"
echo java.at:483 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^class YYParser$' YYParser.java"; then
  ( $at_traceon; grep -c '^class YYParser$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^class YYParser$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:483"

$at_failed && at_func_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%name-prefix "Prefix"
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:485: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:485 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:485"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:485: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:485 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:485"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:485: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:485 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:485"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:485: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:485 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:485"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:485: bison YYParser.y"
echo java.at:485 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:485"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:485: grep -q '[mb]4_' YYParser.y"
echo java.at:485 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:485"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:485: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:485 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:485"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:485: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:485 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:485"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:486: grep -c '^class PrefixParser\$' YYParser.java"
echo java.at:486 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^class PrefixParser$' YYParser.java"; then
  ( $at_traceon; grep -c '^class PrefixParser$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^class PrefixParser$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:486"

$at_failed && at_func_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%define parser_class_name "ParserClassName"
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:488: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:488 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:488"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:488: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:488 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:488"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:488: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:488 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:488"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:488: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:488 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:488"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:488: bison YYParser.y"
echo java.at:488 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:488"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:488: grep -q '[mb]4_' YYParser.y"
echo java.at:488 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:488"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:488: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:488 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:488"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:488: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:488 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:488"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:489: grep -c '^class ParserClassName\$' YYParser.java"
echo java.at:489 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^class ParserClassName$' YYParser.java"; then
  ( $at_traceon; grep -c '^class ParserClassName$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^class ParserClassName$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:489"

$at_failed && at_func_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%define package "user_java_package"
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:491: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:491 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:491"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:491: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:491 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:491"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:491: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:491 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:491"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:491: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:491 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:491"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:491: bison YYParser.y"
echo java.at:491 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:491"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:491: grep -q '[mb]4_' YYParser.y"
echo java.at:491 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:491"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:491: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:491 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:491"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:491: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:491 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:491"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:492: grep -c '^package user_java_package;\$' YYParser.java"
echo java.at:492 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^package user_java_package;$' YYParser.java"; then
  ( $at_traceon; grep -c '^package user_java_package;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^package user_java_package;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:492"

$at_failed && at_func_log_failure
$at_traceon; }



  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_205
#AT_START_206
# 206. java.at:501: Java parser class modifiers
at_setup_line='java.at:501'
at_func_banner 19
at_desc="Java parser class modifiers"
$at_quiet $as_echo_n "206: $at_desc                    "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "206. java.at:501: testing ..."
  $at_traceon



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%define abstract
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:503: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:503 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:503"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:503: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:503 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:503"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:503: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:503 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:503"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:503: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:503 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:503"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:503: bison YYParser.y"
echo java.at:503 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:503"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:503: grep -q '[mb]4_' YYParser.y"
echo java.at:503 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:503"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:503: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:503 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:503"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:503: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:503 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:503"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:504: grep -c '^abstract class YYParser\$' YYParser.java"
echo java.at:504 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^abstract class YYParser$' YYParser.java"; then
  ( $at_traceon; grep -c '^abstract class YYParser$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^abstract class YYParser$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:504"

$at_failed && at_func_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%define final
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:506: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:506 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:506"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:506: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:506 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:506"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:506: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:506 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:506"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:506: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:506 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:506"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:506: bison YYParser.y"
echo java.at:506 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:506"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:506: grep -q '[mb]4_' YYParser.y"
echo java.at:506 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:506"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:506: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:506 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:506"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:506: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:506 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:506"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:507: grep -c '^final class YYParser\$' YYParser.java"
echo java.at:507 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^final class YYParser$' YYParser.java"; then
  ( $at_traceon; grep -c '^final class YYParser$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^final class YYParser$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:507"

$at_failed && at_func_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%define strictfp
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:509: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:509 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:509"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:509: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:509 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:509"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:509: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:509 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:509"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:509: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:509 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:509"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:509: bison YYParser.y"
echo java.at:509 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:509"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:509: grep -q '[mb]4_' YYParser.y"
echo java.at:509 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:509"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:509: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:509 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:509"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:509: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:509 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:509"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:510: grep -c '^strictfp class YYParser\$' YYParser.java"
echo java.at:510 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^strictfp class YYParser$' YYParser.java"; then
  ( $at_traceon; grep -c '^strictfp class YYParser$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^strictfp class YYParser$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:510"

$at_failed && at_func_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define abstract
%define strictfp
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:512: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:512 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:512"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:512: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:512 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:512"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:512: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:512 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:512"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:512: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:512 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:512"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:512: bison YYParser.y"
echo java.at:512 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:512"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:512: grep -q '[mb]4_' YYParser.y"
echo java.at:512 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:512"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:512: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:512 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:512"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:512: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:512 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:512"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:515: grep -c '^abstract strictfp class YYParser\$' YYParser.java"
echo java.at:515 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^abstract strictfp class YYParser$' YYParser.java"; then
  ( $at_traceon; grep -c '^abstract strictfp class YYParser$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^abstract strictfp class YYParser$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:515"

$at_failed && at_func_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define final
%define strictfp
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:517: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:517 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:517"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:517: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:517 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:517"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:517: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:517 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:517"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:517: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:517 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:517"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:517: bison YYParser.y"
echo java.at:517 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:517"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:517: grep -q '[mb]4_' YYParser.y"
echo java.at:517 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:517"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:517: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:517 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:517"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:517: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:517 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:517"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:520: grep -c '^final strictfp class YYParser\$' YYParser.java"
echo java.at:520 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^final strictfp class YYParser$' YYParser.java"; then
  ( $at_traceon; grep -c '^final strictfp class YYParser$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^final strictfp class YYParser$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:520"

$at_failed && at_func_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%define public
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:522: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:522 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:522"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:522: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:522 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:522"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:522: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:522 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:522"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:522: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:522 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:522"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:522: bison YYParser.y"
echo java.at:522 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:522"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:522: grep -q '[mb]4_' YYParser.y"
echo java.at:522 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:522"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:522: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:522 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:522"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:522: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:522 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:522"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:523: grep -c '^public class YYParser\$' YYParser.java"
echo java.at:523 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^public class YYParser$' YYParser.java"; then
  ( $at_traceon; grep -c '^public class YYParser$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^public class YYParser$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:523"

$at_failed && at_func_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define public
%define abstract
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:525: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:525 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:525"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:525: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:525 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:525"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:525: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:525 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:525"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:525: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:525 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:525"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:525: bison YYParser.y"
echo java.at:525 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:525"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:525: grep -q '[mb]4_' YYParser.y"
echo java.at:525 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:525"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:525: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:525 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:525"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:525: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:525 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:525"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:528: grep -c '^public abstract class YYParser\$' YYParser.java"
echo java.at:528 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^public abstract class YYParser$' YYParser.java"; then
  ( $at_traceon; grep -c '^public abstract class YYParser$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^public abstract class YYParser$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:528"

$at_failed && at_func_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define public
%define final
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:530: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:530 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:530"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:530: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:530 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:530"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:530: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:530 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:530"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:530: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:530 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:530"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:530: bison YYParser.y"
echo java.at:530 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:530"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:530: grep -q '[mb]4_' YYParser.y"
echo java.at:530 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:530"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:530: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:530 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:530"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:530: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:530 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:530"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:533: grep -c '^public final class YYParser\$' YYParser.java"
echo java.at:533 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^public final class YYParser$' YYParser.java"; then
  ( $at_traceon; grep -c '^public final class YYParser$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^public final class YYParser$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:533"

$at_failed && at_func_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define public
%define strictfp
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:535: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:535 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:535"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:535: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:535 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:535"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:535: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:535 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:535"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:535: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:535 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:535"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:535: bison YYParser.y"
echo java.at:535 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:535"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:535: grep -q '[mb]4_' YYParser.y"
echo java.at:535 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:535"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:535: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:535 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:535"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:535: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:535 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:535"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:538: grep -c '^public strictfp class YYParser\$' YYParser.java"
echo java.at:538 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^public strictfp class YYParser$' YYParser.java"; then
  ( $at_traceon; grep -c '^public strictfp class YYParser$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^public strictfp class YYParser$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:538"

$at_failed && at_func_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define public
%define abstract
%define strictfp
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:540: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:540 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:540"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:540: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:540 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:540"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:540: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:540 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:540"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:540: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:540 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:540"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:540: bison YYParser.y"
echo java.at:540 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:540"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:540: grep -q '[mb]4_' YYParser.y"
echo java.at:540 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:540"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:540: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:540 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:540"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:540: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:540 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:540"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:544: grep -c '^public abstract strictfp class YYParser\$' YYParser.java"
echo java.at:544 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^public abstract strictfp class YYParser$' YYParser.java"; then
  ( $at_traceon; grep -c '^public abstract strictfp class YYParser$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^public abstract strictfp class YYParser$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:544"

$at_failed && at_func_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define public
%define final
%define strictfp
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:546: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:546 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:546"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:546: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:546 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:546"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:546: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:546 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:546"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:546: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:546 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:546"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:546: bison YYParser.y"
echo java.at:546 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:546"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:546: grep -q '[mb]4_' YYParser.y"
echo java.at:546 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:546"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:546: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:546 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:546"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:546: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:546 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:546"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:550: grep -c '^public final strictfp class YYParser\$' YYParser.java"
echo java.at:550 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^public final strictfp class YYParser$' YYParser.java"; then
  ( $at_traceon; grep -c '^public final strictfp class YYParser$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^public final strictfp class YYParser$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:550"

$at_failed && at_func_log_failure
$at_traceon; }



  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_206
#AT_START_207
# 207. java.at:559: Java parser class extends and implements
at_setup_line='java.at:559'
at_func_banner 19
at_desc="Java parser class extends and implements"
$at_quiet $as_echo_n "207: $at_desc       "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "207. java.at:559: testing ..."
  $at_traceon



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%define extends "Thread"
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:561: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:561 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:561"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:561: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:561 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:561"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:561: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:561 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:561"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:561: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:561 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:561"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:561: bison YYParser.y"
echo java.at:561 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:561"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:561: grep -q '[mb]4_' YYParser.y"
echo java.at:561 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:561"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:561: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:561 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:561"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:561: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:561 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:561"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:562: grep -c '^class YYParser extends Thread\$' YYParser.java"
echo java.at:562 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^class YYParser extends Thread$' YYParser.java"; then
  ( $at_traceon; grep -c '^class YYParser extends Thread$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^class YYParser extends Thread$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:562"

$at_failed && at_func_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%define implements "Cloneable"
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:564: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:564 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:564"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:564: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:564 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:564"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:564: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:564 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:564"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:564: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:564 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:564"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:564: bison YYParser.y"
echo java.at:564 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:564"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:564: grep -q '[mb]4_' YYParser.y"
echo java.at:564 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:564"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:564: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:564 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:564"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:564: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:564 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:564"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:565: grep -c '^class YYParser implements Cloneable\$' YYParser.java"
echo java.at:565 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^class YYParser implements Cloneable$' YYParser.java"; then
  ( $at_traceon; grep -c '^class YYParser implements Cloneable$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^class YYParser implements Cloneable$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:565"

$at_failed && at_func_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define extends "Thread"
%define implements "Cloneable"
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:567: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:567 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:567"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:567: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:567 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:567"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:567: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:567 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:567"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:567: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:567 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:567"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:567: bison YYParser.y"
echo java.at:567 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:567"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:567: grep -q '[mb]4_' YYParser.y"
echo java.at:567 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:567"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:567: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:567 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:567"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:567: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:567 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:567"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:570: grep -c '^class YYParser extends Thread implements Cloneable\$' YYParser.java"
echo java.at:570 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^class YYParser extends Thread implements Cloneable$' YYParser.java"; then
  ( $at_traceon; grep -c '^class YYParser extends Thread implements Cloneable$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^class YYParser extends Thread implements Cloneable$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:570"

$at_failed && at_func_log_failure
$at_traceon; }



  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_207
#AT_START_208
# 208. java.at:579: Java %parse-param and %lex-param
at_setup_line='java.at:579'
at_func_banner 19
at_desc="Java %parse-param and %lex-param"
$at_quiet $as_echo_n "208: $at_desc               "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "208. java.at:579: testing ..."
  $at_traceon



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:581: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:581 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:581"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:581: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:581 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:581"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:581: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:581 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:581"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:581: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:581 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:581"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:581: bison YYParser.y"
echo java.at:581 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:581"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:581: grep -q '[mb]4_' YYParser.y"
echo java.at:581 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:581"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:581: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:581 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:581"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:581: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:581 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:581"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:582: grep -c '^ *public YYParser (Lexer yylexer) {\$' YYParser.java"
echo java.at:582 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public YYParser (Lexer yylexer) {$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public YYParser (Lexer yylexer) {$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public YYParser (Lexer yylexer) {$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:582"

$at_failed && at_func_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%parse-param {int parse_param1}
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:584: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:584 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:584"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:584: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:584 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:584"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:584: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:584 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:584"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:584: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:584 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:584"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:584: bison YYParser.y"
echo java.at:584 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:584"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:584: grep -q '[mb]4_' YYParser.y"
echo java.at:584 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:584"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:584: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:584 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:584"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:584: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:584 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:584"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:585: grep -c '^ *protected final int parse_param1;\$' YYParser.java"
echo java.at:585 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *protected final int parse_param1;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *protected final int parse_param1;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *protected final int parse_param1;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:585"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:586: grep -c '^ *public YYParser (Lexer yylexer, *int parse_param1) {\$' YYParser.java"
echo java.at:586 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public YYParser (Lexer yylexer, *int parse_param1) {$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public YYParser (Lexer yylexer, *int parse_param1) {$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public YYParser (Lexer yylexer, *int parse_param1) {$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:586"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:587: grep -c '^[ 	]*this.parse_param1 = parse_param1;\$' YYParser.java"
echo java.at:587 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^[ 	]*this.parse_param1 = parse_param1;$' YYParser.java"; then
  ( $at_traceon; grep -c '^[ 	]*this.parse_param1 = parse_param1;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^[ 	]*this.parse_param1 = parse_param1;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:587"

$at_failed && at_func_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%parse-param {int parse_param1}
%parse-param {long parse_param2}
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:589: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:589 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:589"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:589: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:589 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:589"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:589: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:589 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:589"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:589: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:589 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:589"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:589: bison YYParser.y"
echo java.at:589 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:589"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:589: grep -q '[mb]4_' YYParser.y"
echo java.at:589 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:589"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:589: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:589 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:589"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:589: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:589 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:589"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:592: grep -c '^ *protected final int parse_param1;\$' YYParser.java"
echo java.at:592 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *protected final int parse_param1;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *protected final int parse_param1;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *protected final int parse_param1;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:592"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:593: grep -c '^ *protected final long parse_param2;\$' YYParser.java"
echo java.at:593 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *protected final long parse_param2;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *protected final long parse_param2;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *protected final long parse_param2;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:593"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:594: grep -c '^ *public YYParser (Lexer yylexer, *int parse_param1, *long parse_param2) {\$' YYParser.java"
echo java.at:594 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public YYParser (Lexer yylexer, *int parse_param1, *long parse_param2) {$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public YYParser (Lexer yylexer, *int parse_param1, *long parse_param2) {$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public YYParser (Lexer yylexer, *int parse_param1, *long parse_param2) {$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:594"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:595: grep -c '^[ 	]*this.parse_param1 = parse_param1;\$' YYParser.java"
echo java.at:595 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^[ 	]*this.parse_param1 = parse_param1;$' YYParser.java"; then
  ( $at_traceon; grep -c '^[ 	]*this.parse_param1 = parse_param1;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^[ 	]*this.parse_param1 = parse_param1;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:595"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:596: grep -c '^[ 	]*this.parse_param2 = parse_param2;\$' YYParser.java"
echo java.at:596 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^[ 	]*this.parse_param2 = parse_param2;$' YYParser.java"; then
  ( $at_traceon; grep -c '^[ 	]*this.parse_param2 = parse_param2;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^[ 	]*this.parse_param2 = parse_param2;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:596"

$at_failed && at_func_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table


%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex ()
  {
    return EOF;
  }


}
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:598: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:598 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:598"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:598: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:598 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:598"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:598: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:598 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:598"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:598: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:598 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:598"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:598: bison YYParser.y"
echo java.at:598 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:598"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:598: grep -q '[mb]4_' YYParser.y"
echo java.at:598 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:598"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:598: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:598 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:598"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:598: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:598 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:598"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:599: grep -c '^ *public YYParser () {\$' YYParser.java"
echo java.at:599 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public YYParser () {$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public YYParser () {$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public YYParser () {$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:599"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:600: grep -c '^ *protected YYParser (Lexer yylexer) {\$' YYParser.java"
echo java.at:600 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *protected YYParser (Lexer yylexer) {$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *protected YYParser (Lexer yylexer) {$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *protected YYParser (Lexer yylexer) {$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:600"

$at_failed && at_func_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%parse-param {int parse_param1}

%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex ()
  {
    return EOF;
  }


}
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:602: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:602 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:602"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:602: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:602 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:602"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:602: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:602 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:602"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:602: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:602 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:602"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:602: bison YYParser.y"
echo java.at:602 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:602"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:602: grep -q '[mb]4_' YYParser.y"
echo java.at:602 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:602"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:602: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:602 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:602"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:602: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:602 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:602"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:604: grep -c '^ *protected final int parse_param1;\$' YYParser.java"
echo java.at:604 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *protected final int parse_param1;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *protected final int parse_param1;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *protected final int parse_param1;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:604"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:605: grep -c '^ *public YYParser (int parse_param1) {\$' YYParser.java"
echo java.at:605 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public YYParser (int parse_param1) {$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public YYParser (int parse_param1) {$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public YYParser (int parse_param1) {$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:605"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:606: grep -c '^ *protected YYParser (Lexer yylexer, *int parse_param1) {\$' YYParser.java"
echo java.at:606 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *protected YYParser (Lexer yylexer, *int parse_param1) {$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *protected YYParser (Lexer yylexer, *int parse_param1) {$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *protected YYParser (Lexer yylexer, *int parse_param1) {$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:606"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:607: grep -c '^[ 	]*this.parse_param1 = parse_param1;\$' YYParser.java"
echo java.at:607 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^[ 	]*this.parse_param1 = parse_param1;$' YYParser.java"; then
  ( $at_traceon; grep -c '^[ 	]*this.parse_param1 = parse_param1;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^[ 	]*this.parse_param1 = parse_param1;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "2
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:607"

$at_failed && at_func_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%parse-param {int parse_param1}
%parse-param {long parse_param2}

%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex ()
  {
    return EOF;
  }


}
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:609: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:609 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:609"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:609: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:609 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:609"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:609: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:609 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:609"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:609: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:609 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:609"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:609: bison YYParser.y"
echo java.at:609 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:609"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:609: grep -q '[mb]4_' YYParser.y"
echo java.at:609 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:609"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:609: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:609 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:609"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:609: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:609 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:609"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:613: grep -c '^ *protected final int parse_param1;\$' YYParser.java"
echo java.at:613 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *protected final int parse_param1;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *protected final int parse_param1;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *protected final int parse_param1;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:613"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:614: grep -c '^ *protected final long parse_param2;\$' YYParser.java"
echo java.at:614 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *protected final long parse_param2;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *protected final long parse_param2;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *protected final long parse_param2;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:614"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:615: grep -c '^ *public YYParser (int parse_param1, *long parse_param2) {\$' YYParser.java"
echo java.at:615 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public YYParser (int parse_param1, *long parse_param2) {$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public YYParser (int parse_param1, *long parse_param2) {$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public YYParser (int parse_param1, *long parse_param2) {$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:615"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:616: grep -c '^ *protected YYParser (Lexer yylexer, *int parse_param1, *long parse_param2) {\$' YYParser.java"
echo java.at:616 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *protected YYParser (Lexer yylexer, *int parse_param1, *long parse_param2) {$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *protected YYParser (Lexer yylexer, *int parse_param1, *long parse_param2) {$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *protected YYParser (Lexer yylexer, *int parse_param1, *long parse_param2) {$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:616"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:617: grep -c '^[ 	]*this.parse_param1 = parse_param1;\$' YYParser.java"
echo java.at:617 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^[ 	]*this.parse_param1 = parse_param1;$' YYParser.java"; then
  ( $at_traceon; grep -c '^[ 	]*this.parse_param1 = parse_param1;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^[ 	]*this.parse_param1 = parse_param1;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "2
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:617"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:618: grep -c '^[ 	]*this.parse_param2 = parse_param2;\$' YYParser.java"
echo java.at:618 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^[ 	]*this.parse_param2 = parse_param2;$' YYParser.java"; then
  ( $at_traceon; grep -c '^[ 	]*this.parse_param2 = parse_param2;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^[ 	]*this.parse_param2 = parse_param2;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "2
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:618"

$at_failed && at_func_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table
%lex-param {char lex_param1}

%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex ()
  {
    return EOF;
  }

  YYLexer (char lex_param1) {}
}
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:620: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:620 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:620"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:620: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:620 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:620"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:620: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:620 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:620"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:620: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:620 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:620"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:620: bison YYParser.y"
echo java.at:620 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:620"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:620: grep -q '[mb]4_' YYParser.y"
echo java.at:620 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:620"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:620: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:620 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:620"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:620: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:620 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:620"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:622: grep -c '^ *public YYParser (char lex_param1) {\$' YYParser.java"
echo java.at:622 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public YYParser (char lex_param1) {$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public YYParser (char lex_param1) {$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public YYParser (char lex_param1) {$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:622"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:623: grep -c '^.* = new YYLexer *(lex_param1);\$' YYParser.java"
echo java.at:623 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^.* = new YYLexer *(lex_param1);$' YYParser.java"; then
  ( $at_traceon; grep -c '^.* = new YYLexer *(lex_param1);$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^.* = new YYLexer *(lex_param1);$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:623"

$at_failed && at_func_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%lex-param {char lex_param1}
%lex-param {short lex_param2}

%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex ()
  {
    return EOF;
  }

  YYLexer (char lex_param1, short lex_param2) {}
}
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:625: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:625 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:625"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:625: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:625 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:625"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:625: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:625 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:625"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:625: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:625 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:625"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:625: bison YYParser.y"
echo java.at:625 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:625"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:625: grep -q '[mb]4_' YYParser.y"
echo java.at:625 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:625"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:625: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:625 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:625"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:625: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:625 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:625"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:629: grep -c '^ *public YYParser (char lex_param1, *short lex_param2) {\$' YYParser.java"
echo java.at:629 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public YYParser (char lex_param1, *short lex_param2) {$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public YYParser (char lex_param1, *short lex_param2) {$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public YYParser (char lex_param1, *short lex_param2) {$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:629"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:630: grep -c '^.* = new YYLexer *(lex_param1, *lex_param2);\$' YYParser.java"
echo java.at:630 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^.* = new YYLexer *(lex_param1, *lex_param2);$' YYParser.java"; then
  ( $at_traceon; grep -c '^.* = new YYLexer *(lex_param1, *lex_param2);$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^.* = new YYLexer *(lex_param1, *lex_param2);$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:630"

$at_failed && at_func_log_failure
$at_traceon; }




cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%parse-param {int parse_param1}
%parse-param {long parse_param2}
%lex-param {char lex_param1}
%lex-param {short lex_param2}

%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex ()
  {
    return EOF;
  }

  YYLexer (char lex_param1, short lex_param2) {}
}
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:632: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:632 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:632"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:632: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:632 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:632"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:632: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:632 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:632"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:632: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:632 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:632"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:632: bison YYParser.y"
echo java.at:632 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:632"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:632: grep -q '[mb]4_' YYParser.y"
echo java.at:632 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:632"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:632: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:632 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:632"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:632: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:632 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:632"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:638: grep -c '^ *protected final int parse_param1;\$' YYParser.java"
echo java.at:638 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *protected final int parse_param1;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *protected final int parse_param1;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *protected final int parse_param1;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:638"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:639: grep -c '^ *protected final long parse_param2;\$' YYParser.java"
echo java.at:639 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *protected final long parse_param2;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *protected final long parse_param2;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *protected final long parse_param2;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:639"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:640: grep -c '^ *public YYParser (char lex_param1, *short lex_param2, *int parse_param1, *long parse_param2) {\$' YYParser.java"
echo java.at:640 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public YYParser (char lex_param1, *short lex_param2, *int parse_param1, *long parse_param2) {$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public YYParser (char lex_param1, *short lex_param2, *int parse_param1, *long parse_param2) {$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public YYParser (char lex_param1, *short lex_param2, *int parse_param1, *long parse_param2) {$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:640"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:641: grep -c '^.* = new YYLexer *(lex_param1, *lex_param2);\$' YYParser.java"
echo java.at:641 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^.* = new YYLexer *(lex_param1, *lex_param2);$' YYParser.java"; then
  ( $at_traceon; grep -c '^.* = new YYLexer *(lex_param1, *lex_param2);$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^.* = new YYLexer *(lex_param1, *lex_param2);$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:641"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:642: grep -c '^ *protected YYParser (Lexer yylexer, *int parse_param1, *long parse_param2) {\$' YYParser.java"
echo java.at:642 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *protected YYParser (Lexer yylexer, *int parse_param1, *long parse_param2) {$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *protected YYParser (Lexer yylexer, *int parse_param1, *long parse_param2) {$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *protected YYParser (Lexer yylexer, *int parse_param1, *long parse_param2) {$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:642"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:643: grep -c '^[ 	]*this.parse_param1 = parse_param1;\$' YYParser.java"
echo java.at:643 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^[ 	]*this.parse_param1 = parse_param1;$' YYParser.java"; then
  ( $at_traceon; grep -c '^[ 	]*this.parse_param1 = parse_param1;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^[ 	]*this.parse_param1 = parse_param1;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "2
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:643"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:644: grep -c '^[ 	]*this.parse_param2 = parse_param2;\$' YYParser.java"
echo java.at:644 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^[ 	]*this.parse_param2 = parse_param2;$' YYParser.java"; then
  ( $at_traceon; grep -c '^[ 	]*this.parse_param2 = parse_param2;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^[ 	]*this.parse_param2 = parse_param2;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "2
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:644"

$at_failed && at_func_log_failure
$at_traceon; }



  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_208
#AT_START_209
# 209. java.at:653: Java throws specifications
at_setup_line='java.at:653'
at_func_banner 19
at_desc="Java throws specifications"
$at_quiet $as_echo_n "209: $at_desc                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "209. java.at:653: testing ..."
  $at_traceon


# %define throws	- 0 1 2
# %define lex-throws	- 0 1 2
# %code lexer		  0 1





















cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table




%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () throws java.io.IOException *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws java.io.IOException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws java.io.IOException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws java.io.IOException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws java.io.IOException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define throws ""


%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () throws java.io.IOException *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws java.io.IOException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws java.io.IOException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws java.io.IOException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws java.io.IOException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define throws "ClassNotFoundException"

%initial-action {if (true) throw new ClassNotFoundException();}
%%
start: "end" {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () throws java.io.IOException *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define throws "ClassNotFoundException, InstantiationException"

%initial-action {if (true) throw new InstantiationException();}
%%
start: "end" {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () throws java.io.IOException *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException, InstantiationException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException, InstantiationException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table


%define lex_throws ""

%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define throws ""
%define lex_throws ""

%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define throws "ClassNotFoundException"
%define lex_throws ""
%initial-action {if (true) throw new ClassNotFoundException();}
%%
start: "end" {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws ClassNotFoundException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws ClassNotFoundException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define throws "ClassNotFoundException, InstantiationException"
%define lex_throws ""
%initial-action {if (true) throw new InstantiationException();}
%%
start: "end" {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws ClassNotFoundException, InstantiationException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws ClassNotFoundException, InstantiationException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table


%define lex_throws "InterruptedException"

%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () throws InterruptedException *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws InterruptedException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws InterruptedException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws InterruptedException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws InterruptedException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define throws ""
%define lex_throws "InterruptedException"

%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () throws InterruptedException *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws InterruptedException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws InterruptedException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws InterruptedException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws InterruptedException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define throws "ClassNotFoundException"
%define lex_throws "InterruptedException"
%initial-action {if (true) throw new ClassNotFoundException();}
%%
start: "end" {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () throws InterruptedException *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define throws "ClassNotFoundException, InstantiationException"
%define lex_throws "InterruptedException"
%initial-action {if (true) throw new InstantiationException();}
%%
start: "end" {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () throws InterruptedException *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException, InstantiationException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException, InstantiationException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table


%define lex_throws "InterruptedException, IllegalAccessException"

%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define throws ""
%define lex_throws "InterruptedException, IllegalAccessException"

%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define throws "ClassNotFoundException"
%define lex_throws "InterruptedException, IllegalAccessException"
%initial-action {if (true) throw new ClassNotFoundException();}
%%
start: "end" {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define throws "ClassNotFoundException, InstantiationException"
%define lex_throws "InterruptedException, IllegalAccessException"
%initial-action {if (true) throw new InstantiationException();}
%%
start: "end" {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException, InstantiationException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException, InstantiationException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table





%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex () throws java.io.IOException
  {
    throw new java.io.IOException();
  }


}
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () throws java.io.IOException *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws java.io.IOException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws java.io.IOException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws java.io.IOException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws java.io.IOException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define throws ""



%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex () throws java.io.IOException
  {
    throw new java.io.IOException();
  }


}
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () throws java.io.IOException *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws java.io.IOException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws java.io.IOException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws java.io.IOException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws java.io.IOException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define throws "ClassNotFoundException"

%initial-action {if (true) throw new ClassNotFoundException();}

%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex () throws java.io.IOException
  {
    throw new java.io.IOException();
  }


}
%%
start: "end" {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () throws java.io.IOException *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define throws "ClassNotFoundException, InstantiationException"

%initial-action {if (true) throw new InstantiationException();}

%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex () throws java.io.IOException
  {
    throw new java.io.IOException();
  }


}
%%
start: "end" {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () throws java.io.IOException *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () throws java.io.IOException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException, InstantiationException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException, InstantiationException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws java.io.IOException, ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table


%define lex_throws ""


%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex ()
  {
    return EOF;
  }


}
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define throws ""
%define lex_throws ""


%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex ()
  {
    return EOF;
  }


}
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define throws "ClassNotFoundException"
%define lex_throws ""
%initial-action {if (true) throw new ClassNotFoundException();}

%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex ()
  {
    return EOF;
  }


}
%%
start: "end" {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws ClassNotFoundException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws ClassNotFoundException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define throws "ClassNotFoundException, InstantiationException"
%define lex_throws ""
%initial-action {if (true) throw new InstantiationException();}

%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex ()
  {
    return EOF;
  }


}
%%
start: "end" {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws ClassNotFoundException, InstantiationException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws ClassNotFoundException, InstantiationException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table


%define lex_throws "InterruptedException"


%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex () throws InterruptedException
  {
    throw new InterruptedException();
  }


}
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () throws InterruptedException *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws InterruptedException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws InterruptedException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws InterruptedException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws InterruptedException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define throws ""
%define lex_throws "InterruptedException"


%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex () throws InterruptedException
  {
    throw new InterruptedException();
  }


}
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () throws InterruptedException *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws InterruptedException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws InterruptedException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws InterruptedException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws InterruptedException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define throws "ClassNotFoundException"
%define lex_throws "InterruptedException"
%initial-action {if (true) throw new ClassNotFoundException();}

%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex () throws InterruptedException
  {
    throw new InterruptedException();
  }


}
%%
start: "end" {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () throws InterruptedException *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define throws "ClassNotFoundException, InstantiationException"
%define lex_throws "InterruptedException"
%initial-action {if (true) throw new InstantiationException();}

%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex () throws InterruptedException
  {
    throw new InterruptedException();
  }


}
%%
start: "end" {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () throws InterruptedException *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () throws InterruptedException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException, InstantiationException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException, InstantiationException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws InterruptedException, ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table


%define lex_throws "InterruptedException, IllegalAccessException"


%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex () throws InterruptedException, IllegalAccessException
  {
    throw new IllegalAccessException();
  }


}
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define throws ""
%define lex_throws "InterruptedException, IllegalAccessException"


%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex () throws InterruptedException, IllegalAccessException
  {
    throw new IllegalAccessException();
  }


}
%%
start: "end" {};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define throws "ClassNotFoundException"
%define lex_throws "InterruptedException, IllegalAccessException"
%initial-action {if (true) throw new ClassNotFoundException();}

%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex () throws InterruptedException, IllegalAccessException
  {
    throw new IllegalAccessException();
  }


}
%%
start: "end" {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define throws "ClassNotFoundException, InstantiationException"
%define lex_throws "InterruptedException, IllegalAccessException"
%initial-action {if (true) throw new InstantiationException();}

%code lexer
{
  Object yylval;
  public Object getLVal() { return yylval; }

  public Position getStartPos() { return null; }
  public Position getEndPos()   { return null; }

  public void yyerror (Location loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex () throws InterruptedException, IllegalAccessException
  {
    throw new IllegalAccessException();
  }


}
%%
start: "end" {throw new ClassNotFoundException();};
%%
class Position {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: bison YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -q '[mb]4_' YYParser.y"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:713 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *int yylex () throws InterruptedException, IllegalAccessException *;$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *private int yyaction ([^)]*) throws ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:713: grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException, InstantiationException *\$' YYParser.java"
echo java.at:713 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException, InstantiationException *$' YYParser.java"; then
  ( $at_traceon; grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -c '^ *public boolean parse () throws InterruptedException, IllegalAccessException, ClassNotFoundException, InstantiationException *$' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:713"

$at_failed && at_func_log_failure
$at_traceon; }




  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_209
#AT_START_210
# 210. java.at:742: Java stype, position_class and location_class
at_setup_line='java.at:742'
at_func_banner 19
at_desc="Java stype, position_class and location_class"
$at_quiet $as_echo_n "210: $at_desc  "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "210. java.at:742: testing ..."
  $at_traceon



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define stype "java.awt.Color"
%type<java.awt.Color> start;
%define location_type "MyLoc"
%define position_type "MyPos"
%code { class MyPos {} }
%%
start: "end" {$$ = $<java.awt.Color>1;};
%%
class MyPos {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:744: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:744 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:744"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:744: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:744 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:744"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:744: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:744 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:744"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:744: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:744 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:744"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:744: bison YYParser.y"
echo java.at:744 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:744"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:744: grep -q '[mb]4_' YYParser.y"
echo java.at:744 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:744"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:744: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:744 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:744"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:744: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:744 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:744"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:750: grep -q 'java.awt.Color' YYParser.java"
echo java.at:750 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q 'java.awt.Color' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q 'java.awt.Color' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:750"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:751: egrep -v ' */?\\*' YYParser.java | grep -q 'Position'"
echo java.at:751 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; egrep -v ' */?\*' YYParser.java | grep -q 'Position' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; egrep -v ' */?\*' YYParser.java | grep -q 'Position' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:751"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:752: egrep -v ' */?\\*' YYParser.java | grep -q 'Location'"
echo java.at:752 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; egrep -v ' */?\*' YYParser.java | grep -q 'Location' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; egrep -v ' */?\*' YYParser.java | grep -q 'Location' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:752"

$at_failed && at_func_log_failure
$at_traceon; }



cat >YYParser.y <<'_ATEOF'

%language "Java"
%locations
%debug
%error-verbose
%token-table

%define stype "java.awt.Color"
%type<java.awt.Color> start;
%define location_type "MyLoc"
%define position_type "MyPos"
%code { class MyPos {} }

%code lexer
{
  java.awt.Color yylval;
  public java.awt.Color getLVal() { return yylval; }

  public MyPos getStartPos() { return null; }
  public MyPos getEndPos()   { return null; }

  public void yyerror (MyLoc loc, String s)
  {
    System.err.println (loc + ": " + s);
  }

  public int yylex ()
  {
    return EOF;
  }


}
%%
start: "end" {$$ = $<java.awt.Color>1;};
%%
class MyPos {}
_ATEOF

if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/java.at:754: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot YYParser.y"
echo java.at:754 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:754"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/java.at:754: bison --xml=xml-tests/test.xml YYParser.y"
echo java.at:754 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:754"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:754: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo java.at:754 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:754"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/java.at:754: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo java.at:754 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:754"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/java.at:754: bison YYParser.y"
echo java.at:754 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:754"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:754: grep -q '[mb]4_' YYParser.y"
echo java.at:754 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q '[mb]4_' YYParser.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:754"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:754: test -n \"\$CONF_JAVA\" || exit 77
test -n \"\$CONF_JAVAC\" || exit 77"
echo java.at:754 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:754"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:754: \$SHELL ../../../javacomp.sh YYParser.java"
echo java.at:754 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$SHELL ../../../javacomp.sh YYParser.java"; then
  ( $at_traceon; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $SHELL ../../../javacomp.sh YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/java.at:754"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/java.at:762: grep -q 'java.awt.Color' YYParser.java"
echo java.at:762 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; grep -q 'java.awt.Color' YYParser.java ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; grep -q 'java.awt.Color' YYParser.java ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/java.at:762"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:763: egrep -v ' */?\\*' YYParser.java | grep -q 'Position'"
echo java.at:763 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; egrep -v ' */?\*' YYParser.java | grep -q 'Position' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; egrep -v ' */?\*' YYParser.java | grep -q 'Position' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:763"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/java.at:764: egrep -v ' */?\\*' YYParser.java | grep -q 'Location'"
echo java.at:764 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; egrep -v ' */?\*' YYParser.java | grep -q 'Location' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; egrep -v ' */?\*' YYParser.java | grep -q 'Location' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/java.at:764"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_210
#AT_START_211
# 211. cxx-type.at:413: GLR: Resolve ambiguity, impure, no locations
at_setup_line='cxx-type.at:413'
at_func_banner 20
at_desc="GLR: Resolve ambiguity, impure, no locations"
$at_quiet $as_echo_n "211: $at_desc   "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "211. cxx-type.at:413: testing ..."
  $at_traceon







# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.












cat >types.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Simplified C++ Type and Expression Grammar.  */



%{
  #include <stdio.h>
  union Node {
    struct {
      int isNterm;
      int parents;
    } nodeInfo;
    struct {
      int isNterm; /* 1 */
      int parents;
      char const *form;
      union Node *children[3];
    } nterm;
    struct {
      int isNterm; /* 0 */
      int parents;
      char *text;
    } term;
  };
  typedef union Node Node;
  static Node *new_nterm (char const *, Node *, Node *, Node *);
  static Node *new_term (char *);
  static void free_node (Node *);
  static char *node_to_string (Node *);
  #define YYSTYPE Node *

  #define YYINITDEPTH 10
  #define YYSTACKEXPANDABLE 1
  struct YYLTYPE;
#if YYPURE
# if YYLSP_NEEDED
#  define LEX_PARAMETERS YYSTYPE *lvalp, struct YYLTYPE *llocp
#  define ERROR_PARAMETERS struct YYLTYPE *llocp, char const *s
# else
#  define LEX_PARAMETERS YYSTYPE *lvalp
# endif
#endif
#ifndef LEX_PARAMETERS
# define LEX_PARAMETERS void
#endif
#ifndef ERROR_PARAMETERS
# define ERROR_PARAMETERS char const *s
#endif
  int yylex (LEX_PARAMETERS);
  void yyerror (ERROR_PARAMETERS);
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%destructor { free_node ($$); } stmt expr decl declarator TYPENAME ID

%%

prog :
     | prog stmt   {
			char *output;
			output = node_to_string ($2);
			printf ("%s\n", output);
			free (output);
			free_node ($2);
		   }
     ;

stmt : expr ';'  %dprec 1	{ $$ = $1; }
     | decl      %dprec 2
     | error ';'	{ $$ = new_nterm ("<error>", 0, 0, 0); }
     | '@'		{ YYACCEPT; }
     ;

expr : ID
     | TYPENAME '(' expr ')'
			{ $$ = new_nterm ("<cast>(%s,%s)", $3, $1, 0); }
     | expr '+' expr	{ $$ = new_nterm ("+(%s,%s)", $1, $3, 0); }
     | expr '=' expr    { $$ = new_nterm ("=(%s,%s)", $1, $3, 0); }
     ;

decl : TYPENAME declarator ';'
			{ $$ = new_nterm ("<declare>(%s,%s)", $1, $2, 0); }
     | TYPENAME declarator '=' expr ';'
			{ $$ = new_nterm ("<init-declare>(%s,%s,%s)", $1,
					  $2, $4); }
     ;

declarator : ID
     | '(' declarator ')' { $$ = $2; }
     ;

%%

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

int
main (int argc, char **argv)
{
  if (argc != 2)
    abort ();
  if (!freopen (argv[1], "r", stdin))
    return 3;
  return yyparse ();
}

int
yylex (LEX_PARAMETERS)
{
  char buffer[256];
  int c;
  unsigned int i;
  static int lineNum = 1;
  static int colNum = 0;

#if YYPURE
# undef yylloc
# define yylloc (*llocp)
# undef yylval
# define yylval (*lvalp)
#endif

  while (1)
    {
      if (feof (stdin))
	abort ();
      c = getchar ();
      switch (c)
	{
	case EOF:
	  return 0;
	case '\t':
	  colNum = (colNum + 7) & ~7;
	  break;
	case ' ': case '\f':
	  colNum += 1;
	  break;
	case '\n':
	  lineNum += 1;
	  colNum = 0;
	  break;
	default:
	  {
	    int tok;
#if YYLSP_NEEDED
	    yylloc.first_line = yylloc.last_line = lineNum;
	    yylloc.first_column = colNum;
#endif
	    if (isalpha (c))
	      {
		i = 0;

		do
		  {
		    buffer[i++] = c;
		    colNum += 1;
		    if (i == sizeof buffer - 1)
		      abort ();
		    c = getchar ();
		  }
		while (isalnum (c) || c == '_');

		ungetc (c, stdin);
		buffer[i++] = 0;
		tok = isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
		yylval = new_term (strcpy ((char *) malloc (i), buffer));
	      }
	    else
	      {
		colNum += 1;
		tok = c;
		yylval = 0;
	      }
#if YYLSP_NEEDED
	    yylloc.last_column = colNum-1;
#endif
	    return tok;
	  }
	}
    }
}

void
yyerror (ERROR_PARAMETERS)
{
#if YYPURE && YYLSP_NEEDED
  /* Pacify GCC by using llocp.  */
  if (! llocp)
    abort ();
#endif
  fprintf (stderr, "%s\n", s);
}

static Node *
new_nterm (char const *form, Node *child0, Node *child1, Node *child2)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->nterm.isNterm = 1;
  node->nterm.parents = 0;
  node->nterm.form = form;
  node->nterm.children[0] = child0;
  if (child0)
    child0->nodeInfo.parents += 1;
  node->nterm.children[1] = child1;
  if (child1)
    child1->nodeInfo.parents += 1;
  node->nterm.children[2] = child2;
  if (child2)
    child2->nodeInfo.parents += 1;
  return node;
}

static Node *
new_term (char *text)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->term.isNterm = 0;
  node->term.parents = 0;
  node->term.text = text;
  return node;
}

static void
free_node (Node *node)
{
  if (!node)
    return;
  node->nodeInfo.parents -= 1;
  /* Free only if 0 (last parent) or -1 (no parents).  */
  if (node->nodeInfo.parents > 0)
    return;
  if (node->nodeInfo.isNterm == 1)
    {
      free_node (node->nterm.children[0]);
      free_node (node->nterm.children[1]);
      free_node (node->nterm.children[2]);
    }
  else
    free (node->term.text);
  free (node);
}

static char *
node_to_string (Node *node)
{
  char *child0;
  char *child1;
  char *child2;
  char *buffer;
  if (!node)
    {
      buffer = (char *) malloc (1);
      buffer[0] = 0;
    }
  else if (node->nodeInfo.isNterm == 1)
    {
      child0 = node_to_string (node->nterm.children[0]);
      child1 = node_to_string (node->nterm.children[1]);
      child2 = node_to_string (node->nterm.children[2]);
      buffer = (char *) malloc (strlen (node->nterm.form) + strlen (child0)
				+ strlen (child1) + strlen (child2) + 1);
      sprintf (buffer, node->nterm.form, child0, child1, child2);
      free (child0);
      free (child1);
      free (child2);
    }
  else
    buffer = strdup (node->term.text);
  return buffer;
}



_ATEOF



cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:414: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o types.c types.y"
echo cxx-type.at:414 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o types.c types.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o types.c types.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:414"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:414: bison --xml=xml-tests/test.xml -o types.c types.y"
echo cxx-type.at:414 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o types.c types.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o types.c types.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:414"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:414: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo cxx-type.at:414 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:414"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:414: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo cxx-type.at:414 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:414"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:414: bison -o types.c types.y"
echo cxx-type.at:414 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o types.c types.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o types.c types.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:414"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:414: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o types types.c \$LIBS"
echo cxx-type.at:414 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:414"

$at_failed && at_func_log_failure
$at_traceon; }

























{ $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:416:  \$PREPARSER ./types test-input"
echo cxx-type.at:416 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./types test-input"; then
  ( $at_traceon;  $PREPARSER ./types test-input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./types test-input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "syntax error
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "+(z,q)
<declare>(T,x)
<init-declare>(T,x,y)
=(x,y)
+(<cast>(x,T),y)
<declare>(T,x)
<init-declare>(T,y,+(z,q))
<error>
+(z,q)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:416"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_211
#AT_START_212
# 212. cxx-type.at:420: GLR: Resolve ambiguity, impure, locations
at_setup_line='cxx-type.at:420'
at_func_banner 20
at_desc="GLR: Resolve ambiguity, impure, locations"
$at_quiet $as_echo_n "212: $at_desc      "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "212. cxx-type.at:420: testing ..."
  $at_traceon







# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.












cat >types.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Simplified C++ Type and Expression Grammar.  */

%locations

%{
  #include <stdio.h>
  union Node {
    struct {
      int isNterm;
      int parents;
    } nodeInfo;
    struct {
      int isNterm; /* 1 */
      int parents;
      char const *form;
      union Node *children[3];
    } nterm;
    struct {
      int isNterm; /* 0 */
      int parents;
      char *text;
    } term;
  };
  typedef union Node Node;
  static Node *new_nterm (char const *, Node *, Node *, Node *);
  static Node *new_term (char *);
  static void free_node (Node *);
  static char *node_to_string (Node *);
  #define YYSTYPE Node *

  #define YYINITDEPTH 10
  #define YYSTACKEXPANDABLE 1
  struct YYLTYPE;
#if YYPURE
# if YYLSP_NEEDED
#  define LEX_PARAMETERS YYSTYPE *lvalp, struct YYLTYPE *llocp
#  define ERROR_PARAMETERS struct YYLTYPE *llocp, char const *s
# else
#  define LEX_PARAMETERS YYSTYPE *lvalp
# endif
#endif
#ifndef LEX_PARAMETERS
# define LEX_PARAMETERS void
#endif
#ifndef ERROR_PARAMETERS
# define ERROR_PARAMETERS char const *s
#endif
  int yylex (LEX_PARAMETERS);
  void yyerror (ERROR_PARAMETERS);
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%destructor { free_node ($$); } stmt expr decl declarator TYPENAME ID

%%

prog :
     | prog stmt   {
			char *output;
			printf ("%d.%d-%d.%d: ",
			     @2.first_line, @2.first_column,
			     @2.last_line, @2.last_column);
			output = node_to_string ($2);
			printf ("%s\n", output);
			free (output);
			free_node ($2);
		   }
     ;

stmt : expr ';'  %dprec 1	{ $$ = $1; }
     | decl      %dprec 2
     | error ';'	{ $$ = new_nterm ("<error>", 0, 0, 0); }
     | '@'		{ YYACCEPT; }
     ;

expr : ID
     | TYPENAME '(' expr ')'
			{ $$ = new_nterm ("<cast>(%s,%s)", $3, $1, 0); }
     | expr '+' expr	{ $$ = new_nterm ("+(%s,%s)", $1, $3, 0); }
     | expr '=' expr    { $$ = new_nterm ("=(%s,%s)", $1, $3, 0); }
     ;

decl : TYPENAME declarator ';'
			{ $$ = new_nterm ("<declare>(%s,%s)", $1, $2, 0); }
     | TYPENAME declarator '=' expr ';'
			{ $$ = new_nterm ("<init-declare>(%s,%s,%s)", $1,
					  $2, $4); }
     ;

declarator : ID
     | '(' declarator ')' { $$ = $2; }
     ;

%%

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

int
main (int argc, char **argv)
{
  if (argc != 2)
    abort ();
  if (!freopen (argv[1], "r", stdin))
    return 3;
  return yyparse ();
}

int
yylex (LEX_PARAMETERS)
{
  char buffer[256];
  int c;
  unsigned int i;
  static int lineNum = 1;
  static int colNum = 0;

#if YYPURE
# undef yylloc
# define yylloc (*llocp)
# undef yylval
# define yylval (*lvalp)
#endif

  while (1)
    {
      if (feof (stdin))
	abort ();
      c = getchar ();
      switch (c)
	{
	case EOF:
	  return 0;
	case '\t':
	  colNum = (colNum + 7) & ~7;
	  break;
	case ' ': case '\f':
	  colNum += 1;
	  break;
	case '\n':
	  lineNum += 1;
	  colNum = 0;
	  break;
	default:
	  {
	    int tok;
#if YYLSP_NEEDED
	    yylloc.first_line = yylloc.last_line = lineNum;
	    yylloc.first_column = colNum;
#endif
	    if (isalpha (c))
	      {
		i = 0;

		do
		  {
		    buffer[i++] = c;
		    colNum += 1;
		    if (i == sizeof buffer - 1)
		      abort ();
		    c = getchar ();
		  }
		while (isalnum (c) || c == '_');

		ungetc (c, stdin);
		buffer[i++] = 0;
		tok = isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
		yylval = new_term (strcpy ((char *) malloc (i), buffer));
	      }
	    else
	      {
		colNum += 1;
		tok = c;
		yylval = 0;
	      }
#if YYLSP_NEEDED
	    yylloc.last_column = colNum-1;
#endif
	    return tok;
	  }
	}
    }
}

void
yyerror (ERROR_PARAMETERS)
{
#if YYPURE && YYLSP_NEEDED
  /* Pacify GCC by using llocp.  */
  if (! llocp)
    abort ();
#endif
  fprintf (stderr, "%s\n", s);
}

static Node *
new_nterm (char const *form, Node *child0, Node *child1, Node *child2)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->nterm.isNterm = 1;
  node->nterm.parents = 0;
  node->nterm.form = form;
  node->nterm.children[0] = child0;
  if (child0)
    child0->nodeInfo.parents += 1;
  node->nterm.children[1] = child1;
  if (child1)
    child1->nodeInfo.parents += 1;
  node->nterm.children[2] = child2;
  if (child2)
    child2->nodeInfo.parents += 1;
  return node;
}

static Node *
new_term (char *text)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->term.isNterm = 0;
  node->term.parents = 0;
  node->term.text = text;
  return node;
}

static void
free_node (Node *node)
{
  if (!node)
    return;
  node->nodeInfo.parents -= 1;
  /* Free only if 0 (last parent) or -1 (no parents).  */
  if (node->nodeInfo.parents > 0)
    return;
  if (node->nodeInfo.isNterm == 1)
    {
      free_node (node->nterm.children[0]);
      free_node (node->nterm.children[1]);
      free_node (node->nterm.children[2]);
    }
  else
    free (node->term.text);
  free (node);
}

static char *
node_to_string (Node *node)
{
  char *child0;
  char *child1;
  char *child2;
  char *buffer;
  if (!node)
    {
      buffer = (char *) malloc (1);
      buffer[0] = 0;
    }
  else if (node->nodeInfo.isNterm == 1)
    {
      child0 = node_to_string (node->nterm.children[0]);
      child1 = node_to_string (node->nterm.children[1]);
      child2 = node_to_string (node->nterm.children[2]);
      buffer = (char *) malloc (strlen (node->nterm.form) + strlen (child0)
				+ strlen (child1) + strlen (child2) + 1);
      sprintf (buffer, node->nterm.form, child0, child1, child2);
      free (child0);
      free (child1);
      free (child2);
    }
  else
    buffer = strdup (node->term.text);
  return buffer;
}



_ATEOF



cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:421: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o types.c types.y"
echo cxx-type.at:421 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o types.c types.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o types.c types.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:421"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:421: bison --xml=xml-tests/test.xml -o types.c types.y"
echo cxx-type.at:421 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o types.c types.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o types.c types.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:421"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:421: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo cxx-type.at:421 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:421"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:421: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo cxx-type.at:421 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:421"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:421: bison -o types.c types.y"
echo cxx-type.at:421 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o types.c types.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o types.c types.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:421"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:421: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o types types.c \$LIBS"
echo cxx-type.at:421 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:421"

$at_failed && at_func_log_failure
$at_traceon; }

























{ $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:422:  \$PREPARSER ./types test-input"
echo cxx-type.at:422 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./types test-input"; then
  ( $at_traceon;  $PREPARSER ./types test-input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./types test-input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "syntax error
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "3.0-3.5: +(z,q)
5.0-5.3: <declare>(T,x)
7.0-7.7: <init-declare>(T,x,y)
9.0-9.5: =(x,y)
11.0-11.9: +(<cast>(x,T),y)
13.0-13.5: <declare>(T,x)
15.0-15.13: <init-declare>(T,y,+(z,q))
17.0-17.15: <error>
19.0-19.5: +(z,q)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:422"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_212
#AT_START_213
# 213. cxx-type.at:426: GLR: Resolve ambiguity, pure, no locations
at_setup_line='cxx-type.at:426'
at_func_banner 20
at_desc="GLR: Resolve ambiguity, pure, no locations"
$at_quiet $as_echo_n "213: $at_desc     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "213. cxx-type.at:426: testing ..."
  $at_traceon







# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.












cat >types.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Simplified C++ Type and Expression Grammar.  */

%define api.pure

%{
  #include <stdio.h>
  union Node {
    struct {
      int isNterm;
      int parents;
    } nodeInfo;
    struct {
      int isNterm; /* 1 */
      int parents;
      char const *form;
      union Node *children[3];
    } nterm;
    struct {
      int isNterm; /* 0 */
      int parents;
      char *text;
    } term;
  };
  typedef union Node Node;
  static Node *new_nterm (char const *, Node *, Node *, Node *);
  static Node *new_term (char *);
  static void free_node (Node *);
  static char *node_to_string (Node *);
  #define YYSTYPE Node *

  #define YYINITDEPTH 10
  #define YYSTACKEXPANDABLE 1
  struct YYLTYPE;
#if YYPURE
# if YYLSP_NEEDED
#  define LEX_PARAMETERS YYSTYPE *lvalp, struct YYLTYPE *llocp
#  define ERROR_PARAMETERS struct YYLTYPE *llocp, char const *s
# else
#  define LEX_PARAMETERS YYSTYPE *lvalp
# endif
#endif
#ifndef LEX_PARAMETERS
# define LEX_PARAMETERS void
#endif
#ifndef ERROR_PARAMETERS
# define ERROR_PARAMETERS char const *s
#endif
  int yylex (LEX_PARAMETERS);
  void yyerror (ERROR_PARAMETERS);
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%destructor { free_node ($$); } stmt expr decl declarator TYPENAME ID

%%

prog :
     | prog stmt   {
			char *output;
			output = node_to_string ($2);
			printf ("%s\n", output);
			free (output);
			free_node ($2);
		   }
     ;

stmt : expr ';'  %dprec 1	{ $$ = $1; }
     | decl      %dprec 2
     | error ';'	{ $$ = new_nterm ("<error>", 0, 0, 0); }
     | '@'		{ YYACCEPT; }
     ;

expr : ID
     | TYPENAME '(' expr ')'
			{ $$ = new_nterm ("<cast>(%s,%s)", $3, $1, 0); }
     | expr '+' expr	{ $$ = new_nterm ("+(%s,%s)", $1, $3, 0); }
     | expr '=' expr    { $$ = new_nterm ("=(%s,%s)", $1, $3, 0); }
     ;

decl : TYPENAME declarator ';'
			{ $$ = new_nterm ("<declare>(%s,%s)", $1, $2, 0); }
     | TYPENAME declarator '=' expr ';'
			{ $$ = new_nterm ("<init-declare>(%s,%s,%s)", $1,
					  $2, $4); }
     ;

declarator : ID
     | '(' declarator ')' { $$ = $2; }
     ;

%%

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

int
main (int argc, char **argv)
{
  if (argc != 2)
    abort ();
  if (!freopen (argv[1], "r", stdin))
    return 3;
  return yyparse ();
}

int
yylex (LEX_PARAMETERS)
{
  char buffer[256];
  int c;
  unsigned int i;
  static int lineNum = 1;
  static int colNum = 0;

#if YYPURE
# undef yylloc
# define yylloc (*llocp)
# undef yylval
# define yylval (*lvalp)
#endif

  while (1)
    {
      if (feof (stdin))
	abort ();
      c = getchar ();
      switch (c)
	{
	case EOF:
	  return 0;
	case '\t':
	  colNum = (colNum + 7) & ~7;
	  break;
	case ' ': case '\f':
	  colNum += 1;
	  break;
	case '\n':
	  lineNum += 1;
	  colNum = 0;
	  break;
	default:
	  {
	    int tok;
#if YYLSP_NEEDED
	    yylloc.first_line = yylloc.last_line = lineNum;
	    yylloc.first_column = colNum;
#endif
	    if (isalpha (c))
	      {
		i = 0;

		do
		  {
		    buffer[i++] = c;
		    colNum += 1;
		    if (i == sizeof buffer - 1)
		      abort ();
		    c = getchar ();
		  }
		while (isalnum (c) || c == '_');

		ungetc (c, stdin);
		buffer[i++] = 0;
		tok = isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
		yylval = new_term (strcpy ((char *) malloc (i), buffer));
	      }
	    else
	      {
		colNum += 1;
		tok = c;
		yylval = 0;
	      }
#if YYLSP_NEEDED
	    yylloc.last_column = colNum-1;
#endif
	    return tok;
	  }
	}
    }
}

void
yyerror (ERROR_PARAMETERS)
{
#if YYPURE && YYLSP_NEEDED
  /* Pacify GCC by using llocp.  */
  if (! llocp)
    abort ();
#endif
  fprintf (stderr, "%s\n", s);
}

static Node *
new_nterm (char const *form, Node *child0, Node *child1, Node *child2)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->nterm.isNterm = 1;
  node->nterm.parents = 0;
  node->nterm.form = form;
  node->nterm.children[0] = child0;
  if (child0)
    child0->nodeInfo.parents += 1;
  node->nterm.children[1] = child1;
  if (child1)
    child1->nodeInfo.parents += 1;
  node->nterm.children[2] = child2;
  if (child2)
    child2->nodeInfo.parents += 1;
  return node;
}

static Node *
new_term (char *text)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->term.isNterm = 0;
  node->term.parents = 0;
  node->term.text = text;
  return node;
}

static void
free_node (Node *node)
{
  if (!node)
    return;
  node->nodeInfo.parents -= 1;
  /* Free only if 0 (last parent) or -1 (no parents).  */
  if (node->nodeInfo.parents > 0)
    return;
  if (node->nodeInfo.isNterm == 1)
    {
      free_node (node->nterm.children[0]);
      free_node (node->nterm.children[1]);
      free_node (node->nterm.children[2]);
    }
  else
    free (node->term.text);
  free (node);
}

static char *
node_to_string (Node *node)
{
  char *child0;
  char *child1;
  char *child2;
  char *buffer;
  if (!node)
    {
      buffer = (char *) malloc (1);
      buffer[0] = 0;
    }
  else if (node->nodeInfo.isNterm == 1)
    {
      child0 = node_to_string (node->nterm.children[0]);
      child1 = node_to_string (node->nterm.children[1]);
      child2 = node_to_string (node->nterm.children[2]);
      buffer = (char *) malloc (strlen (node->nterm.form) + strlen (child0)
				+ strlen (child1) + strlen (child2) + 1);
      sprintf (buffer, node->nterm.form, child0, child1, child2);
      free (child0);
      free (child1);
      free (child2);
    }
  else
    buffer = strdup (node->term.text);
  return buffer;
}



_ATEOF



cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:427: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o types.c types.y"
echo cxx-type.at:427 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o types.c types.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o types.c types.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:427"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:427: bison --xml=xml-tests/test.xml -o types.c types.y"
echo cxx-type.at:427 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o types.c types.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o types.c types.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:427"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:427: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo cxx-type.at:427 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:427"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:427: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo cxx-type.at:427 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:427"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:427: bison -o types.c types.y"
echo cxx-type.at:427 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o types.c types.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o types.c types.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:427"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:427: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o types types.c \$LIBS"
echo cxx-type.at:427 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:427"

$at_failed && at_func_log_failure
$at_traceon; }

























{ $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:429:  \$PREPARSER ./types test-input"
echo cxx-type.at:429 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./types test-input"; then
  ( $at_traceon;  $PREPARSER ./types test-input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./types test-input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "syntax error
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "+(z,q)
<declare>(T,x)
<init-declare>(T,x,y)
=(x,y)
+(<cast>(x,T),y)
<declare>(T,x)
<init-declare>(T,y,+(z,q))
<error>
+(z,q)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:429"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_213
#AT_START_214
# 214. cxx-type.at:433: GLR: Resolve ambiguity, pure, locations
at_setup_line='cxx-type.at:433'
at_func_banner 20
at_desc="GLR: Resolve ambiguity, pure, locations"
$at_quiet $as_echo_n "214: $at_desc        "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "214. cxx-type.at:433: testing ..."
  $at_traceon







# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.












cat >types.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Simplified C++ Type and Expression Grammar.  */

%define api.pure %locations

%{
  #include <stdio.h>
  union Node {
    struct {
      int isNterm;
      int parents;
    } nodeInfo;
    struct {
      int isNterm; /* 1 */
      int parents;
      char const *form;
      union Node *children[3];
    } nterm;
    struct {
      int isNterm; /* 0 */
      int parents;
      char *text;
    } term;
  };
  typedef union Node Node;
  static Node *new_nterm (char const *, Node *, Node *, Node *);
  static Node *new_term (char *);
  static void free_node (Node *);
  static char *node_to_string (Node *);
  #define YYSTYPE Node *

  #define YYINITDEPTH 10
  #define YYSTACKEXPANDABLE 1
  struct YYLTYPE;
#if YYPURE
# if YYLSP_NEEDED
#  define LEX_PARAMETERS YYSTYPE *lvalp, struct YYLTYPE *llocp
#  define ERROR_PARAMETERS struct YYLTYPE *llocp, char const *s
# else
#  define LEX_PARAMETERS YYSTYPE *lvalp
# endif
#endif
#ifndef LEX_PARAMETERS
# define LEX_PARAMETERS void
#endif
#ifndef ERROR_PARAMETERS
# define ERROR_PARAMETERS char const *s
#endif
  int yylex (LEX_PARAMETERS);
  void yyerror (ERROR_PARAMETERS);
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%destructor { free_node ($$); } stmt expr decl declarator TYPENAME ID

%%

prog :
     | prog stmt   {
			char *output;
			printf ("%d.%d-%d.%d: ",
			     @2.first_line, @2.first_column,
			     @2.last_line, @2.last_column);
			output = node_to_string ($2);
			printf ("%s\n", output);
			free (output);
			free_node ($2);
		   }
     ;

stmt : expr ';'  %dprec 1	{ $$ = $1; }
     | decl      %dprec 2
     | error ';'	{ $$ = new_nterm ("<error>", 0, 0, 0); }
     | '@'		{ YYACCEPT; }
     ;

expr : ID
     | TYPENAME '(' expr ')'
			{ $$ = new_nterm ("<cast>(%s,%s)", $3, $1, 0); }
     | expr '+' expr	{ $$ = new_nterm ("+(%s,%s)", $1, $3, 0); }
     | expr '=' expr    { $$ = new_nterm ("=(%s,%s)", $1, $3, 0); }
     ;

decl : TYPENAME declarator ';'
			{ $$ = new_nterm ("<declare>(%s,%s)", $1, $2, 0); }
     | TYPENAME declarator '=' expr ';'
			{ $$ = new_nterm ("<init-declare>(%s,%s,%s)", $1,
					  $2, $4); }
     ;

declarator : ID
     | '(' declarator ')' { $$ = $2; }
     ;

%%

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

int
main (int argc, char **argv)
{
  if (argc != 2)
    abort ();
  if (!freopen (argv[1], "r", stdin))
    return 3;
  return yyparse ();
}

int
yylex (LEX_PARAMETERS)
{
  char buffer[256];
  int c;
  unsigned int i;
  static int lineNum = 1;
  static int colNum = 0;

#if YYPURE
# undef yylloc
# define yylloc (*llocp)
# undef yylval
# define yylval (*lvalp)
#endif

  while (1)
    {
      if (feof (stdin))
	abort ();
      c = getchar ();
      switch (c)
	{
	case EOF:
	  return 0;
	case '\t':
	  colNum = (colNum + 7) & ~7;
	  break;
	case ' ': case '\f':
	  colNum += 1;
	  break;
	case '\n':
	  lineNum += 1;
	  colNum = 0;
	  break;
	default:
	  {
	    int tok;
#if YYLSP_NEEDED
	    yylloc.first_line = yylloc.last_line = lineNum;
	    yylloc.first_column = colNum;
#endif
	    if (isalpha (c))
	      {
		i = 0;

		do
		  {
		    buffer[i++] = c;
		    colNum += 1;
		    if (i == sizeof buffer - 1)
		      abort ();
		    c = getchar ();
		  }
		while (isalnum (c) || c == '_');

		ungetc (c, stdin);
		buffer[i++] = 0;
		tok = isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
		yylval = new_term (strcpy ((char *) malloc (i), buffer));
	      }
	    else
	      {
		colNum += 1;
		tok = c;
		yylval = 0;
	      }
#if YYLSP_NEEDED
	    yylloc.last_column = colNum-1;
#endif
	    return tok;
	  }
	}
    }
}

void
yyerror (ERROR_PARAMETERS)
{
#if YYPURE && YYLSP_NEEDED
  /* Pacify GCC by using llocp.  */
  if (! llocp)
    abort ();
#endif
  fprintf (stderr, "%s\n", s);
}

static Node *
new_nterm (char const *form, Node *child0, Node *child1, Node *child2)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->nterm.isNterm = 1;
  node->nterm.parents = 0;
  node->nterm.form = form;
  node->nterm.children[0] = child0;
  if (child0)
    child0->nodeInfo.parents += 1;
  node->nterm.children[1] = child1;
  if (child1)
    child1->nodeInfo.parents += 1;
  node->nterm.children[2] = child2;
  if (child2)
    child2->nodeInfo.parents += 1;
  return node;
}

static Node *
new_term (char *text)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->term.isNterm = 0;
  node->term.parents = 0;
  node->term.text = text;
  return node;
}

static void
free_node (Node *node)
{
  if (!node)
    return;
  node->nodeInfo.parents -= 1;
  /* Free only if 0 (last parent) or -1 (no parents).  */
  if (node->nodeInfo.parents > 0)
    return;
  if (node->nodeInfo.isNterm == 1)
    {
      free_node (node->nterm.children[0]);
      free_node (node->nterm.children[1]);
      free_node (node->nterm.children[2]);
    }
  else
    free (node->term.text);
  free (node);
}

static char *
node_to_string (Node *node)
{
  char *child0;
  char *child1;
  char *child2;
  char *buffer;
  if (!node)
    {
      buffer = (char *) malloc (1);
      buffer[0] = 0;
    }
  else if (node->nodeInfo.isNterm == 1)
    {
      child0 = node_to_string (node->nterm.children[0]);
      child1 = node_to_string (node->nterm.children[1]);
      child2 = node_to_string (node->nterm.children[2]);
      buffer = (char *) malloc (strlen (node->nterm.form) + strlen (child0)
				+ strlen (child1) + strlen (child2) + 1);
      sprintf (buffer, node->nterm.form, child0, child1, child2);
      free (child0);
      free (child1);
      free (child2);
    }
  else
    buffer = strdup (node->term.text);
  return buffer;
}



_ATEOF



cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:434: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o types.c types.y"
echo cxx-type.at:434 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o types.c types.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o types.c types.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:434"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:434: bison --xml=xml-tests/test.xml -o types.c types.y"
echo cxx-type.at:434 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o types.c types.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o types.c types.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:434"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:434: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo cxx-type.at:434 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:434"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:434: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo cxx-type.at:434 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:434"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:434: bison -o types.c types.y"
echo cxx-type.at:434 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o types.c types.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o types.c types.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:434"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:434: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o types types.c \$LIBS"
echo cxx-type.at:434 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:434"

$at_failed && at_func_log_failure
$at_traceon; }

























{ $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:436:  \$PREPARSER ./types test-input"
echo cxx-type.at:436 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./types test-input"; then
  ( $at_traceon;  $PREPARSER ./types test-input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./types test-input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "syntax error
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "3.0-3.5: +(z,q)
5.0-5.3: <declare>(T,x)
7.0-7.7: <init-declare>(T,x,y)
9.0-9.5: =(x,y)
11.0-11.9: +(<cast>(x,T),y)
13.0-13.5: <declare>(T,x)
15.0-15.13: <init-declare>(T,y,+(z,q))
17.0-17.15: <error>
19.0-19.5: +(z,q)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:436"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_214
#AT_START_215
# 215. cxx-type.at:440: GLR: Merge conflicting parses, impure, no locations
at_setup_line='cxx-type.at:440'
at_func_banner 20
at_desc="GLR: Merge conflicting parses, impure, no locations"
$at_quiet $as_echo_n "215: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "215. cxx-type.at:440: testing ..."
  $at_traceon







# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.












cat >types.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Simplified C++ Type and Expression Grammar.  */



%{
  #include <stdio.h>
  union Node {
    struct {
      int isNterm;
      int parents;
    } nodeInfo;
    struct {
      int isNterm; /* 1 */
      int parents;
      char const *form;
      union Node *children[3];
    } nterm;
    struct {
      int isNterm; /* 0 */
      int parents;
      char *text;
    } term;
  };
  typedef union Node Node;
  static Node *new_nterm (char const *, Node *, Node *, Node *);
  static Node *new_term (char *);
  static void free_node (Node *);
  static char *node_to_string (Node *);
  #define YYSTYPE Node *
 static YYSTYPE stmtMerge (YYSTYPE x0, YYSTYPE x1);
  #define YYINITDEPTH 10
  #define YYSTACKEXPANDABLE 1
  struct YYLTYPE;
#if YYPURE
# if YYLSP_NEEDED
#  define LEX_PARAMETERS YYSTYPE *lvalp, struct YYLTYPE *llocp
#  define ERROR_PARAMETERS struct YYLTYPE *llocp, char const *s
# else
#  define LEX_PARAMETERS YYSTYPE *lvalp
# endif
#endif
#ifndef LEX_PARAMETERS
# define LEX_PARAMETERS void
#endif
#ifndef ERROR_PARAMETERS
# define ERROR_PARAMETERS char const *s
#endif
  int yylex (LEX_PARAMETERS);
  void yyerror (ERROR_PARAMETERS);
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%destructor { free_node ($$); } stmt expr decl declarator TYPENAME ID

%%

prog :
     | prog stmt   {
			char *output;
			output = node_to_string ($2);
			printf ("%s\n", output);
			free (output);
			free_node ($2);
		   }
     ;

stmt : expr ';'  %merge <stmtMerge>	{ $$ = $1; }
     | decl      %merge <stmtMerge>
     | error ';'	{ $$ = new_nterm ("<error>", 0, 0, 0); }
     | '@'		{ YYACCEPT; }
     ;

expr : ID
     | TYPENAME '(' expr ')'
			{ $$ = new_nterm ("<cast>(%s,%s)", $3, $1, 0); }
     | expr '+' expr	{ $$ = new_nterm ("+(%s,%s)", $1, $3, 0); }
     | expr '=' expr    { $$ = new_nterm ("=(%s,%s)", $1, $3, 0); }
     ;

decl : TYPENAME declarator ';'
			{ $$ = new_nterm ("<declare>(%s,%s)", $1, $2, 0); }
     | TYPENAME declarator '=' expr ';'
			{ $$ = new_nterm ("<init-declare>(%s,%s,%s)", $1,
					  $2, $4); }
     ;

declarator : ID
     | '(' declarator ')' { $$ = $2; }
     ;

%%

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

int
main (int argc, char **argv)
{
  if (argc != 2)
    abort ();
  if (!freopen (argv[1], "r", stdin))
    return 3;
  return yyparse ();
}

int
yylex (LEX_PARAMETERS)
{
  char buffer[256];
  int c;
  unsigned int i;
  static int lineNum = 1;
  static int colNum = 0;

#if YYPURE
# undef yylloc
# define yylloc (*llocp)
# undef yylval
# define yylval (*lvalp)
#endif

  while (1)
    {
      if (feof (stdin))
	abort ();
      c = getchar ();
      switch (c)
	{
	case EOF:
	  return 0;
	case '\t':
	  colNum = (colNum + 7) & ~7;
	  break;
	case ' ': case '\f':
	  colNum += 1;
	  break;
	case '\n':
	  lineNum += 1;
	  colNum = 0;
	  break;
	default:
	  {
	    int tok;
#if YYLSP_NEEDED
	    yylloc.first_line = yylloc.last_line = lineNum;
	    yylloc.first_column = colNum;
#endif
	    if (isalpha (c))
	      {
		i = 0;

		do
		  {
		    buffer[i++] = c;
		    colNum += 1;
		    if (i == sizeof buffer - 1)
		      abort ();
		    c = getchar ();
		  }
		while (isalnum (c) || c == '_');

		ungetc (c, stdin);
		buffer[i++] = 0;
		tok = isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
		yylval = new_term (strcpy ((char *) malloc (i), buffer));
	      }
	    else
	      {
		colNum += 1;
		tok = c;
		yylval = 0;
	      }
#if YYLSP_NEEDED
	    yylloc.last_column = colNum-1;
#endif
	    return tok;
	  }
	}
    }
}

void
yyerror (ERROR_PARAMETERS)
{
#if YYPURE && YYLSP_NEEDED
  /* Pacify GCC by using llocp.  */
  if (! llocp)
    abort ();
#endif
  fprintf (stderr, "%s\n", s);
}

static Node *
new_nterm (char const *form, Node *child0, Node *child1, Node *child2)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->nterm.isNterm = 1;
  node->nterm.parents = 0;
  node->nterm.form = form;
  node->nterm.children[0] = child0;
  if (child0)
    child0->nodeInfo.parents += 1;
  node->nterm.children[1] = child1;
  if (child1)
    child1->nodeInfo.parents += 1;
  node->nterm.children[2] = child2;
  if (child2)
    child2->nodeInfo.parents += 1;
  return node;
}

static Node *
new_term (char *text)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->term.isNterm = 0;
  node->term.parents = 0;
  node->term.text = text;
  return node;
}

static void
free_node (Node *node)
{
  if (!node)
    return;
  node->nodeInfo.parents -= 1;
  /* Free only if 0 (last parent) or -1 (no parents).  */
  if (node->nodeInfo.parents > 0)
    return;
  if (node->nodeInfo.isNterm == 1)
    {
      free_node (node->nterm.children[0]);
      free_node (node->nterm.children[1]);
      free_node (node->nterm.children[2]);
    }
  else
    free (node->term.text);
  free (node);
}

static char *
node_to_string (Node *node)
{
  char *child0;
  char *child1;
  char *child2;
  char *buffer;
  if (!node)
    {
      buffer = (char *) malloc (1);
      buffer[0] = 0;
    }
  else if (node->nodeInfo.isNterm == 1)
    {
      child0 = node_to_string (node->nterm.children[0]);
      child1 = node_to_string (node->nterm.children[1]);
      child2 = node_to_string (node->nterm.children[2]);
      buffer = (char *) malloc (strlen (node->nterm.form) + strlen (child0)
				+ strlen (child1) + strlen (child2) + 1);
      sprintf (buffer, node->nterm.form, child0, child1, child2);
      free (child0);
      free (child1);
      free (child2);
    }
  else
    buffer = strdup (node->term.text);
  return buffer;
}


static YYSTYPE
stmtMerge (YYSTYPE x0, YYSTYPE x1)
{
  return new_nterm ("<OR>(%s,%s)", x0, x1, 0);
}

_ATEOF



cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:441: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o types.c types.y"
echo cxx-type.at:441 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o types.c types.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o types.c types.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:441"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:441: bison --xml=xml-tests/test.xml -o types.c types.y"
echo cxx-type.at:441 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o types.c types.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o types.c types.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:441"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:441: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo cxx-type.at:441 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:441"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:441: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo cxx-type.at:441 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:441"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:441: bison -o types.c types.y"
echo cxx-type.at:441 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o types.c types.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o types.c types.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:441"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:441: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o types types.c \$LIBS"
echo cxx-type.at:441 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:441"

$at_failed && at_func_log_failure
$at_traceon; }

























{ $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:443:  \$PREPARSER ./types test-input"
echo cxx-type.at:443 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./types test-input"; then
  ( $at_traceon;  $PREPARSER ./types test-input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./types test-input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "syntax error
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "+(z,q)
<declare>(T,x)
<init-declare>(T,x,y)
=(x,y)
+(<cast>(x,T),y)
<OR>(<declare>(T,x),<cast>(x,T))
<OR>(<init-declare>(T,y,+(z,q)),=(<cast>(y,T),+(z,q)))
<error>
+(z,q)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:443"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_215
#AT_START_216
# 216. cxx-type.at:447: GLR: Merge conflicting parses, impure, locations
at_setup_line='cxx-type.at:447'
at_func_banner 20
at_desc="GLR: Merge conflicting parses, impure, locations"
$at_quiet $as_echo_n "216: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "216. cxx-type.at:447: testing ..."
  $at_traceon







# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.












cat >types.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Simplified C++ Type and Expression Grammar.  */

%locations

%{
  #include <stdio.h>
  union Node {
    struct {
      int isNterm;
      int parents;
    } nodeInfo;
    struct {
      int isNterm; /* 1 */
      int parents;
      char const *form;
      union Node *children[3];
    } nterm;
    struct {
      int isNterm; /* 0 */
      int parents;
      char *text;
    } term;
  };
  typedef union Node Node;
  static Node *new_nterm (char const *, Node *, Node *, Node *);
  static Node *new_term (char *);
  static void free_node (Node *);
  static char *node_to_string (Node *);
  #define YYSTYPE Node *
 static YYSTYPE stmtMerge (YYSTYPE x0, YYSTYPE x1);
  #define YYINITDEPTH 10
  #define YYSTACKEXPANDABLE 1
  struct YYLTYPE;
#if YYPURE
# if YYLSP_NEEDED
#  define LEX_PARAMETERS YYSTYPE *lvalp, struct YYLTYPE *llocp
#  define ERROR_PARAMETERS struct YYLTYPE *llocp, char const *s
# else
#  define LEX_PARAMETERS YYSTYPE *lvalp
# endif
#endif
#ifndef LEX_PARAMETERS
# define LEX_PARAMETERS void
#endif
#ifndef ERROR_PARAMETERS
# define ERROR_PARAMETERS char const *s
#endif
  int yylex (LEX_PARAMETERS);
  void yyerror (ERROR_PARAMETERS);
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%destructor { free_node ($$); } stmt expr decl declarator TYPENAME ID

%%

prog :
     | prog stmt   {
			char *output;
			printf ("%d.%d-%d.%d: ",
			     @2.first_line, @2.first_column,
			     @2.last_line, @2.last_column);
			output = node_to_string ($2);
			printf ("%s\n", output);
			free (output);
			free_node ($2);
		   }
     ;

stmt : expr ';'  %merge <stmtMerge>	{ $$ = $1; }
     | decl      %merge <stmtMerge>
     | error ';'	{ $$ = new_nterm ("<error>", 0, 0, 0); }
     | '@'		{ YYACCEPT; }
     ;

expr : ID
     | TYPENAME '(' expr ')'
			{ $$ = new_nterm ("<cast>(%s,%s)", $3, $1, 0); }
     | expr '+' expr	{ $$ = new_nterm ("+(%s,%s)", $1, $3, 0); }
     | expr '=' expr    { $$ = new_nterm ("=(%s,%s)", $1, $3, 0); }
     ;

decl : TYPENAME declarator ';'
			{ $$ = new_nterm ("<declare>(%s,%s)", $1, $2, 0); }
     | TYPENAME declarator '=' expr ';'
			{ $$ = new_nterm ("<init-declare>(%s,%s,%s)", $1,
					  $2, $4); }
     ;

declarator : ID
     | '(' declarator ')' { $$ = $2; }
     ;

%%

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

int
main (int argc, char **argv)
{
  if (argc != 2)
    abort ();
  if (!freopen (argv[1], "r", stdin))
    return 3;
  return yyparse ();
}

int
yylex (LEX_PARAMETERS)
{
  char buffer[256];
  int c;
  unsigned int i;
  static int lineNum = 1;
  static int colNum = 0;

#if YYPURE
# undef yylloc
# define yylloc (*llocp)
# undef yylval
# define yylval (*lvalp)
#endif

  while (1)
    {
      if (feof (stdin))
	abort ();
      c = getchar ();
      switch (c)
	{
	case EOF:
	  return 0;
	case '\t':
	  colNum = (colNum + 7) & ~7;
	  break;
	case ' ': case '\f':
	  colNum += 1;
	  break;
	case '\n':
	  lineNum += 1;
	  colNum = 0;
	  break;
	default:
	  {
	    int tok;
#if YYLSP_NEEDED
	    yylloc.first_line = yylloc.last_line = lineNum;
	    yylloc.first_column = colNum;
#endif
	    if (isalpha (c))
	      {
		i = 0;

		do
		  {
		    buffer[i++] = c;
		    colNum += 1;
		    if (i == sizeof buffer - 1)
		      abort ();
		    c = getchar ();
		  }
		while (isalnum (c) || c == '_');

		ungetc (c, stdin);
		buffer[i++] = 0;
		tok = isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
		yylval = new_term (strcpy ((char *) malloc (i), buffer));
	      }
	    else
	      {
		colNum += 1;
		tok = c;
		yylval = 0;
	      }
#if YYLSP_NEEDED
	    yylloc.last_column = colNum-1;
#endif
	    return tok;
	  }
	}
    }
}

void
yyerror (ERROR_PARAMETERS)
{
#if YYPURE && YYLSP_NEEDED
  /* Pacify GCC by using llocp.  */
  if (! llocp)
    abort ();
#endif
  fprintf (stderr, "%s\n", s);
}

static Node *
new_nterm (char const *form, Node *child0, Node *child1, Node *child2)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->nterm.isNterm = 1;
  node->nterm.parents = 0;
  node->nterm.form = form;
  node->nterm.children[0] = child0;
  if (child0)
    child0->nodeInfo.parents += 1;
  node->nterm.children[1] = child1;
  if (child1)
    child1->nodeInfo.parents += 1;
  node->nterm.children[2] = child2;
  if (child2)
    child2->nodeInfo.parents += 1;
  return node;
}

static Node *
new_term (char *text)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->term.isNterm = 0;
  node->term.parents = 0;
  node->term.text = text;
  return node;
}

static void
free_node (Node *node)
{
  if (!node)
    return;
  node->nodeInfo.parents -= 1;
  /* Free only if 0 (last parent) or -1 (no parents).  */
  if (node->nodeInfo.parents > 0)
    return;
  if (node->nodeInfo.isNterm == 1)
    {
      free_node (node->nterm.children[0]);
      free_node (node->nterm.children[1]);
      free_node (node->nterm.children[2]);
    }
  else
    free (node->term.text);
  free (node);
}

static char *
node_to_string (Node *node)
{
  char *child0;
  char *child1;
  char *child2;
  char *buffer;
  if (!node)
    {
      buffer = (char *) malloc (1);
      buffer[0] = 0;
    }
  else if (node->nodeInfo.isNterm == 1)
    {
      child0 = node_to_string (node->nterm.children[0]);
      child1 = node_to_string (node->nterm.children[1]);
      child2 = node_to_string (node->nterm.children[2]);
      buffer = (char *) malloc (strlen (node->nterm.form) + strlen (child0)
				+ strlen (child1) + strlen (child2) + 1);
      sprintf (buffer, node->nterm.form, child0, child1, child2);
      free (child0);
      free (child1);
      free (child2);
    }
  else
    buffer = strdup (node->term.text);
  return buffer;
}


static YYSTYPE
stmtMerge (YYSTYPE x0, YYSTYPE x1)
{
  return new_nterm ("<OR>(%s,%s)", x0, x1, 0);
}

_ATEOF



cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:448: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o types.c types.y"
echo cxx-type.at:448 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o types.c types.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o types.c types.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:448"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:448: bison --xml=xml-tests/test.xml -o types.c types.y"
echo cxx-type.at:448 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o types.c types.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o types.c types.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:448"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:448: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo cxx-type.at:448 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:448"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:448: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo cxx-type.at:448 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:448"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:448: bison -o types.c types.y"
echo cxx-type.at:448 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o types.c types.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o types.c types.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:448"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:448: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o types types.c \$LIBS"
echo cxx-type.at:448 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:448"

$at_failed && at_func_log_failure
$at_traceon; }

























{ $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:450:  \$PREPARSER ./types test-input"
echo cxx-type.at:450 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./types test-input"; then
  ( $at_traceon;  $PREPARSER ./types test-input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./types test-input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "syntax error
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "3.0-3.5: +(z,q)
5.0-5.3: <declare>(T,x)
7.0-7.7: <init-declare>(T,x,y)
9.0-9.5: =(x,y)
11.0-11.9: +(<cast>(x,T),y)
13.0-13.5: <OR>(<declare>(T,x),<cast>(x,T))
15.0-15.13: <OR>(<init-declare>(T,y,+(z,q)),=(<cast>(y,T),+(z,q)))
17.0-17.15: <error>
19.0-19.5: +(z,q)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:450"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_216
#AT_START_217
# 217. cxx-type.at:454: GLR: Merge conflicting parses, pure, no locations
at_setup_line='cxx-type.at:454'
at_func_banner 20
at_desc="GLR: Merge conflicting parses, pure, no locations"
$at_quiet $as_echo_n "217: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "217. cxx-type.at:454: testing ..."
  $at_traceon







# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.












cat >types.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Simplified C++ Type and Expression Grammar.  */

%define api.pure

%{
  #include <stdio.h>
  union Node {
    struct {
      int isNterm;
      int parents;
    } nodeInfo;
    struct {
      int isNterm; /* 1 */
      int parents;
      char const *form;
      union Node *children[3];
    } nterm;
    struct {
      int isNterm; /* 0 */
      int parents;
      char *text;
    } term;
  };
  typedef union Node Node;
  static Node *new_nterm (char const *, Node *, Node *, Node *);
  static Node *new_term (char *);
  static void free_node (Node *);
  static char *node_to_string (Node *);
  #define YYSTYPE Node *
 static YYSTYPE stmtMerge (YYSTYPE x0, YYSTYPE x1);
  #define YYINITDEPTH 10
  #define YYSTACKEXPANDABLE 1
  struct YYLTYPE;
#if YYPURE
# if YYLSP_NEEDED
#  define LEX_PARAMETERS YYSTYPE *lvalp, struct YYLTYPE *llocp
#  define ERROR_PARAMETERS struct YYLTYPE *llocp, char const *s
# else
#  define LEX_PARAMETERS YYSTYPE *lvalp
# endif
#endif
#ifndef LEX_PARAMETERS
# define LEX_PARAMETERS void
#endif
#ifndef ERROR_PARAMETERS
# define ERROR_PARAMETERS char const *s
#endif
  int yylex (LEX_PARAMETERS);
  void yyerror (ERROR_PARAMETERS);
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%destructor { free_node ($$); } stmt expr decl declarator TYPENAME ID

%%

prog :
     | prog stmt   {
			char *output;
			output = node_to_string ($2);
			printf ("%s\n", output);
			free (output);
			free_node ($2);
		   }
     ;

stmt : expr ';'  %merge <stmtMerge>	{ $$ = $1; }
     | decl      %merge <stmtMerge>
     | error ';'	{ $$ = new_nterm ("<error>", 0, 0, 0); }
     | '@'		{ YYACCEPT; }
     ;

expr : ID
     | TYPENAME '(' expr ')'
			{ $$ = new_nterm ("<cast>(%s,%s)", $3, $1, 0); }
     | expr '+' expr	{ $$ = new_nterm ("+(%s,%s)", $1, $3, 0); }
     | expr '=' expr    { $$ = new_nterm ("=(%s,%s)", $1, $3, 0); }
     ;

decl : TYPENAME declarator ';'
			{ $$ = new_nterm ("<declare>(%s,%s)", $1, $2, 0); }
     | TYPENAME declarator '=' expr ';'
			{ $$ = new_nterm ("<init-declare>(%s,%s,%s)", $1,
					  $2, $4); }
     ;

declarator : ID
     | '(' declarator ')' { $$ = $2; }
     ;

%%

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

int
main (int argc, char **argv)
{
  if (argc != 2)
    abort ();
  if (!freopen (argv[1], "r", stdin))
    return 3;
  return yyparse ();
}

int
yylex (LEX_PARAMETERS)
{
  char buffer[256];
  int c;
  unsigned int i;
  static int lineNum = 1;
  static int colNum = 0;

#if YYPURE
# undef yylloc
# define yylloc (*llocp)
# undef yylval
# define yylval (*lvalp)
#endif

  while (1)
    {
      if (feof (stdin))
	abort ();
      c = getchar ();
      switch (c)
	{
	case EOF:
	  return 0;
	case '\t':
	  colNum = (colNum + 7) & ~7;
	  break;
	case ' ': case '\f':
	  colNum += 1;
	  break;
	case '\n':
	  lineNum += 1;
	  colNum = 0;
	  break;
	default:
	  {
	    int tok;
#if YYLSP_NEEDED
	    yylloc.first_line = yylloc.last_line = lineNum;
	    yylloc.first_column = colNum;
#endif
	    if (isalpha (c))
	      {
		i = 0;

		do
		  {
		    buffer[i++] = c;
		    colNum += 1;
		    if (i == sizeof buffer - 1)
		      abort ();
		    c = getchar ();
		  }
		while (isalnum (c) || c == '_');

		ungetc (c, stdin);
		buffer[i++] = 0;
		tok = isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
		yylval = new_term (strcpy ((char *) malloc (i), buffer));
	      }
	    else
	      {
		colNum += 1;
		tok = c;
		yylval = 0;
	      }
#if YYLSP_NEEDED
	    yylloc.last_column = colNum-1;
#endif
	    return tok;
	  }
	}
    }
}

void
yyerror (ERROR_PARAMETERS)
{
#if YYPURE && YYLSP_NEEDED
  /* Pacify GCC by using llocp.  */
  if (! llocp)
    abort ();
#endif
  fprintf (stderr, "%s\n", s);
}

static Node *
new_nterm (char const *form, Node *child0, Node *child1, Node *child2)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->nterm.isNterm = 1;
  node->nterm.parents = 0;
  node->nterm.form = form;
  node->nterm.children[0] = child0;
  if (child0)
    child0->nodeInfo.parents += 1;
  node->nterm.children[1] = child1;
  if (child1)
    child1->nodeInfo.parents += 1;
  node->nterm.children[2] = child2;
  if (child2)
    child2->nodeInfo.parents += 1;
  return node;
}

static Node *
new_term (char *text)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->term.isNterm = 0;
  node->term.parents = 0;
  node->term.text = text;
  return node;
}

static void
free_node (Node *node)
{
  if (!node)
    return;
  node->nodeInfo.parents -= 1;
  /* Free only if 0 (last parent) or -1 (no parents).  */
  if (node->nodeInfo.parents > 0)
    return;
  if (node->nodeInfo.isNterm == 1)
    {
      free_node (node->nterm.children[0]);
      free_node (node->nterm.children[1]);
      free_node (node->nterm.children[2]);
    }
  else
    free (node->term.text);
  free (node);
}

static char *
node_to_string (Node *node)
{
  char *child0;
  char *child1;
  char *child2;
  char *buffer;
  if (!node)
    {
      buffer = (char *) malloc (1);
      buffer[0] = 0;
    }
  else if (node->nodeInfo.isNterm == 1)
    {
      child0 = node_to_string (node->nterm.children[0]);
      child1 = node_to_string (node->nterm.children[1]);
      child2 = node_to_string (node->nterm.children[2]);
      buffer = (char *) malloc (strlen (node->nterm.form) + strlen (child0)
				+ strlen (child1) + strlen (child2) + 1);
      sprintf (buffer, node->nterm.form, child0, child1, child2);
      free (child0);
      free (child1);
      free (child2);
    }
  else
    buffer = strdup (node->term.text);
  return buffer;
}


static YYSTYPE
stmtMerge (YYSTYPE x0, YYSTYPE x1)
{
  return new_nterm ("<OR>(%s,%s)", x0, x1, 0);
}

_ATEOF



cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:455: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o types.c types.y"
echo cxx-type.at:455 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o types.c types.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o types.c types.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:455"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:455: bison --xml=xml-tests/test.xml -o types.c types.y"
echo cxx-type.at:455 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o types.c types.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o types.c types.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:455"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:455: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo cxx-type.at:455 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:455"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:455: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo cxx-type.at:455 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:455"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:455: bison -o types.c types.y"
echo cxx-type.at:455 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o types.c types.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o types.c types.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:455"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:455: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o types types.c \$LIBS"
echo cxx-type.at:455 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:455"

$at_failed && at_func_log_failure
$at_traceon; }

























{ $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:457:  \$PREPARSER ./types test-input"
echo cxx-type.at:457 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./types test-input"; then
  ( $at_traceon;  $PREPARSER ./types test-input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./types test-input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "syntax error
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "+(z,q)
<declare>(T,x)
<init-declare>(T,x,y)
=(x,y)
+(<cast>(x,T),y)
<OR>(<declare>(T,x),<cast>(x,T))
<OR>(<init-declare>(T,y,+(z,q)),=(<cast>(y,T),+(z,q)))
<error>
+(z,q)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:457"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_217
#AT_START_218
# 218. cxx-type.at:460: GLR: Merge conflicting parses, pure, locations
at_setup_line='cxx-type.at:460'
at_func_banner 20
at_desc="GLR: Merge conflicting parses, pure, locations"
$at_quiet $as_echo_n "218: $at_desc "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "218. cxx-type.at:460: testing ..."
  $at_traceon







# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.












cat >types.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Simplified C++ Type and Expression Grammar.  */

%define api.pure %locations

%{
  #include <stdio.h>
  union Node {
    struct {
      int isNterm;
      int parents;
    } nodeInfo;
    struct {
      int isNterm; /* 1 */
      int parents;
      char const *form;
      union Node *children[3];
    } nterm;
    struct {
      int isNterm; /* 0 */
      int parents;
      char *text;
    } term;
  };
  typedef union Node Node;
  static Node *new_nterm (char const *, Node *, Node *, Node *);
  static Node *new_term (char *);
  static void free_node (Node *);
  static char *node_to_string (Node *);
  #define YYSTYPE Node *
 static YYSTYPE stmtMerge (YYSTYPE x0, YYSTYPE x1);
  #define YYINITDEPTH 10
  #define YYSTACKEXPANDABLE 1
  struct YYLTYPE;
#if YYPURE
# if YYLSP_NEEDED
#  define LEX_PARAMETERS YYSTYPE *lvalp, struct YYLTYPE *llocp
#  define ERROR_PARAMETERS struct YYLTYPE *llocp, char const *s
# else
#  define LEX_PARAMETERS YYSTYPE *lvalp
# endif
#endif
#ifndef LEX_PARAMETERS
# define LEX_PARAMETERS void
#endif
#ifndef ERROR_PARAMETERS
# define ERROR_PARAMETERS char const *s
#endif
  int yylex (LEX_PARAMETERS);
  void yyerror (ERROR_PARAMETERS);
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%destructor { free_node ($$); } stmt expr decl declarator TYPENAME ID

%%

prog :
     | prog stmt   {
			char *output;
			printf ("%d.%d-%d.%d: ",
			     @2.first_line, @2.first_column,
			     @2.last_line, @2.last_column);
			output = node_to_string ($2);
			printf ("%s\n", output);
			free (output);
			free_node ($2);
		   }
     ;

stmt : expr ';'  %merge <stmtMerge>	{ $$ = $1; }
     | decl      %merge <stmtMerge>
     | error ';'	{ $$ = new_nterm ("<error>", 0, 0, 0); }
     | '@'		{ YYACCEPT; }
     ;

expr : ID
     | TYPENAME '(' expr ')'
			{ $$ = new_nterm ("<cast>(%s,%s)", $3, $1, 0); }
     | expr '+' expr	{ $$ = new_nterm ("+(%s,%s)", $1, $3, 0); }
     | expr '=' expr    { $$ = new_nterm ("=(%s,%s)", $1, $3, 0); }
     ;

decl : TYPENAME declarator ';'
			{ $$ = new_nterm ("<declare>(%s,%s)", $1, $2, 0); }
     | TYPENAME declarator '=' expr ';'
			{ $$ = new_nterm ("<init-declare>(%s,%s,%s)", $1,
					  $2, $4); }
     ;

declarator : ID
     | '(' declarator ')' { $$ = $2; }
     ;

%%

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

int
main (int argc, char **argv)
{
  if (argc != 2)
    abort ();
  if (!freopen (argv[1], "r", stdin))
    return 3;
  return yyparse ();
}

int
yylex (LEX_PARAMETERS)
{
  char buffer[256];
  int c;
  unsigned int i;
  static int lineNum = 1;
  static int colNum = 0;

#if YYPURE
# undef yylloc
# define yylloc (*llocp)
# undef yylval
# define yylval (*lvalp)
#endif

  while (1)
    {
      if (feof (stdin))
	abort ();
      c = getchar ();
      switch (c)
	{
	case EOF:
	  return 0;
	case '\t':
	  colNum = (colNum + 7) & ~7;
	  break;
	case ' ': case '\f':
	  colNum += 1;
	  break;
	case '\n':
	  lineNum += 1;
	  colNum = 0;
	  break;
	default:
	  {
	    int tok;
#if YYLSP_NEEDED
	    yylloc.first_line = yylloc.last_line = lineNum;
	    yylloc.first_column = colNum;
#endif
	    if (isalpha (c))
	      {
		i = 0;

		do
		  {
		    buffer[i++] = c;
		    colNum += 1;
		    if (i == sizeof buffer - 1)
		      abort ();
		    c = getchar ();
		  }
		while (isalnum (c) || c == '_');

		ungetc (c, stdin);
		buffer[i++] = 0;
		tok = isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
		yylval = new_term (strcpy ((char *) malloc (i), buffer));
	      }
	    else
	      {
		colNum += 1;
		tok = c;
		yylval = 0;
	      }
#if YYLSP_NEEDED
	    yylloc.last_column = colNum-1;
#endif
	    return tok;
	  }
	}
    }
}

void
yyerror (ERROR_PARAMETERS)
{
#if YYPURE && YYLSP_NEEDED
  /* Pacify GCC by using llocp.  */
  if (! llocp)
    abort ();
#endif
  fprintf (stderr, "%s\n", s);
}

static Node *
new_nterm (char const *form, Node *child0, Node *child1, Node *child2)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->nterm.isNterm = 1;
  node->nterm.parents = 0;
  node->nterm.form = form;
  node->nterm.children[0] = child0;
  if (child0)
    child0->nodeInfo.parents += 1;
  node->nterm.children[1] = child1;
  if (child1)
    child1->nodeInfo.parents += 1;
  node->nterm.children[2] = child2;
  if (child2)
    child2->nodeInfo.parents += 1;
  return node;
}

static Node *
new_term (char *text)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->term.isNterm = 0;
  node->term.parents = 0;
  node->term.text = text;
  return node;
}

static void
free_node (Node *node)
{
  if (!node)
    return;
  node->nodeInfo.parents -= 1;
  /* Free only if 0 (last parent) or -1 (no parents).  */
  if (node->nodeInfo.parents > 0)
    return;
  if (node->nodeInfo.isNterm == 1)
    {
      free_node (node->nterm.children[0]);
      free_node (node->nterm.children[1]);
      free_node (node->nterm.children[2]);
    }
  else
    free (node->term.text);
  free (node);
}

static char *
node_to_string (Node *node)
{
  char *child0;
  char *child1;
  char *child2;
  char *buffer;
  if (!node)
    {
      buffer = (char *) malloc (1);
      buffer[0] = 0;
    }
  else if (node->nodeInfo.isNterm == 1)
    {
      child0 = node_to_string (node->nterm.children[0]);
      child1 = node_to_string (node->nterm.children[1]);
      child2 = node_to_string (node->nterm.children[2]);
      buffer = (char *) malloc (strlen (node->nterm.form) + strlen (child0)
				+ strlen (child1) + strlen (child2) + 1);
      sprintf (buffer, node->nterm.form, child0, child1, child2);
      free (child0);
      free (child1);
      free (child2);
    }
  else
    buffer = strdup (node->term.text);
  return buffer;
}


static YYSTYPE
stmtMerge (YYSTYPE x0, YYSTYPE x1)
{
  return new_nterm ("<OR>(%s,%s)", x0, x1, 0);
}

_ATEOF



cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:461: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o types.c types.y"
echo cxx-type.at:461 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o types.c types.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o types.c types.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:461"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:461: bison --xml=xml-tests/test.xml -o types.c types.y"
echo cxx-type.at:461 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o types.c types.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o types.c types.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:461"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:461: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo cxx-type.at:461 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:461"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:461: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo cxx-type.at:461 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:461"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:461: bison -o types.c types.y"
echo cxx-type.at:461 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o types.c types.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o types.c types.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:461"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:461: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o types types.c \$LIBS"
echo cxx-type.at:461 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:461"

$at_failed && at_func_log_failure
$at_traceon; }

























{ $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:463:  \$PREPARSER ./types test-input"
echo cxx-type.at:463 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./types test-input"; then
  ( $at_traceon;  $PREPARSER ./types test-input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./types test-input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "syntax error
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "3.0-3.5: +(z,q)
5.0-5.3: <declare>(T,x)
7.0-7.7: <init-declare>(T,x,y)
9.0-9.5: =(x,y)
11.0-11.9: +(<cast>(x,T),y)
13.0-13.5: <OR>(<declare>(T,x),<cast>(x,T))
15.0-15.13: <OR>(<init-declare>(T,y,+(z,q)),=(<cast>(y,T),+(z,q)))
17.0-17.15: <error>
19.0-19.5: +(z,q)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:463"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_218
#AT_START_219
# 219. cxx-type.at:467: GLR: Verbose messages, resolve ambiguity, impure, no locations
at_setup_line='cxx-type.at:467'
at_func_banner 20
at_desc="GLR: Verbose messages, resolve ambiguity, impure, no locations"
$at_quiet $as_echo_n "219: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "219. cxx-type.at:467: testing ..."
  $at_traceon







# Using yacc.c?








# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.


# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.












cat >types.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Simplified C++ Type and Expression Grammar.  */

%error-verbose

%{
  #include <stdio.h>
  union Node {
    struct {
      int isNterm;
      int parents;
    } nodeInfo;
    struct {
      int isNterm; /* 1 */
      int parents;
      char const *form;
      union Node *children[3];
    } nterm;
    struct {
      int isNterm; /* 0 */
      int parents;
      char *text;
    } term;
  };
  typedef union Node Node;
  static Node *new_nterm (char const *, Node *, Node *, Node *);
  static Node *new_term (char *);
  static void free_node (Node *);
  static char *node_to_string (Node *);
  #define YYSTYPE Node *
 static YYSTYPE stmtMerge (YYSTYPE x0, YYSTYPE x1);
  #define YYINITDEPTH 10
  #define YYSTACKEXPANDABLE 1
  struct YYLTYPE;
#if YYPURE
# if YYLSP_NEEDED
#  define LEX_PARAMETERS YYSTYPE *lvalp, struct YYLTYPE *llocp
#  define ERROR_PARAMETERS struct YYLTYPE *llocp, char const *s
# else
#  define LEX_PARAMETERS YYSTYPE *lvalp
# endif
#endif
#ifndef LEX_PARAMETERS
# define LEX_PARAMETERS void
#endif
#ifndef ERROR_PARAMETERS
# define ERROR_PARAMETERS char const *s
#endif
  int yylex (LEX_PARAMETERS);
  void yyerror (ERROR_PARAMETERS);
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%destructor { free_node ($$); } stmt expr decl declarator TYPENAME ID

%%

prog :
     | prog stmt   {
			char *output;
			output = node_to_string ($2);
			printf ("%s\n", output);
			free (output);
			free_node ($2);
		   }
     ;

stmt : expr ';'  %merge <stmtMerge>	{ $$ = $1; }
     | decl      %merge <stmtMerge>
     | error ';'	{ $$ = new_nterm ("<error>", 0, 0, 0); }
     | '@'		{ YYACCEPT; }
     ;

expr : ID
     | TYPENAME '(' expr ')'
			{ $$ = new_nterm ("<cast>(%s,%s)", $3, $1, 0); }
     | expr '+' expr	{ $$ = new_nterm ("+(%s,%s)", $1, $3, 0); }
     | expr '=' expr    { $$ = new_nterm ("=(%s,%s)", $1, $3, 0); }
     ;

decl : TYPENAME declarator ';'
			{ $$ = new_nterm ("<declare>(%s,%s)", $1, $2, 0); }
     | TYPENAME declarator '=' expr ';'
			{ $$ = new_nterm ("<init-declare>(%s,%s,%s)", $1,
					  $2, $4); }
     ;

declarator : ID
     | '(' declarator ')' { $$ = $2; }
     ;

%%

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

int
main (int argc, char **argv)
{
  if (argc != 2)
    abort ();
  if (!freopen (argv[1], "r", stdin))
    return 3;
  return yyparse ();
}

int
yylex (LEX_PARAMETERS)
{
  char buffer[256];
  int c;
  unsigned int i;
  static int lineNum = 1;
  static int colNum = 0;

#if YYPURE
# undef yylloc
# define yylloc (*llocp)
# undef yylval
# define yylval (*lvalp)
#endif

  while (1)
    {
      if (feof (stdin))
	abort ();
      c = getchar ();
      switch (c)
	{
	case EOF:
	  return 0;
	case '\t':
	  colNum = (colNum + 7) & ~7;
	  break;
	case ' ': case '\f':
	  colNum += 1;
	  break;
	case '\n':
	  lineNum += 1;
	  colNum = 0;
	  break;
	default:
	  {
	    int tok;
#if YYLSP_NEEDED
	    yylloc.first_line = yylloc.last_line = lineNum;
	    yylloc.first_column = colNum;
#endif
	    if (isalpha (c))
	      {
		i = 0;

		do
		  {
		    buffer[i++] = c;
		    colNum += 1;
		    if (i == sizeof buffer - 1)
		      abort ();
		    c = getchar ();
		  }
		while (isalnum (c) || c == '_');

		ungetc (c, stdin);
		buffer[i++] = 0;
		tok = isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
		yylval = new_term (strcpy ((char *) malloc (i), buffer));
	      }
	    else
	      {
		colNum += 1;
		tok = c;
		yylval = 0;
	      }
#if YYLSP_NEEDED
	    yylloc.last_column = colNum-1;
#endif
	    return tok;
	  }
	}
    }
}

void
yyerror (ERROR_PARAMETERS)
{
#if YYPURE && YYLSP_NEEDED
  /* Pacify GCC by using llocp.  */
  if (! llocp)
    abort ();
#endif
  fprintf (stderr, "%s\n", s);
}

static Node *
new_nterm (char const *form, Node *child0, Node *child1, Node *child2)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->nterm.isNterm = 1;
  node->nterm.parents = 0;
  node->nterm.form = form;
  node->nterm.children[0] = child0;
  if (child0)
    child0->nodeInfo.parents += 1;
  node->nterm.children[1] = child1;
  if (child1)
    child1->nodeInfo.parents += 1;
  node->nterm.children[2] = child2;
  if (child2)
    child2->nodeInfo.parents += 1;
  return node;
}

static Node *
new_term (char *text)
{
  Node *node = (Node *) malloc (sizeof (Node));
  node->term.isNterm = 0;
  node->term.parents = 0;
  node->term.text = text;
  return node;
}

static void
free_node (Node *node)
{
  if (!node)
    return;
  node->nodeInfo.parents -= 1;
  /* Free only if 0 (last parent) or -1 (no parents).  */
  if (node->nodeInfo.parents > 0)
    return;
  if (node->nodeInfo.isNterm == 1)
    {
      free_node (node->nterm.children[0]);
      free_node (node->nterm.children[1]);
      free_node (node->nterm.children[2]);
    }
  else
    free (node->term.text);
  free (node);
}

static char *
node_to_string (Node *node)
{
  char *child0;
  char *child1;
  char *child2;
  char *buffer;
  if (!node)
    {
      buffer = (char *) malloc (1);
      buffer[0] = 0;
    }
  else if (node->nodeInfo.isNterm == 1)
    {
      child0 = node_to_string (node->nterm.children[0]);
      child1 = node_to_string (node->nterm.children[1]);
      child2 = node_to_string (node->nterm.children[2]);
      buffer = (char *) malloc (strlen (node->nterm.form) + strlen (child0)
				+ strlen (child1) + strlen (child2) + 1);
      sprintf (buffer, node->nterm.form, child0, child1, child2);
      free (child0);
      free (child1);
      free (child2);
    }
  else
    buffer = strdup (node->term.text);
  return buffer;
}


static YYSTYPE
stmtMerge (YYSTYPE x0, YYSTYPE x1)
{
  return new_nterm ("<OR>(%s,%s)", x0, x1, 0);
}

_ATEOF



cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:468: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o types.c types.y"
echo cxx-type.at:468 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o types.c types.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o types.c types.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:468"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:468: bison --xml=xml-tests/test.xml -o types.c types.y"
echo cxx-type.at:468 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o types.c types.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o types.c types.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:468"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:468: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo cxx-type.at:468 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:468"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:468: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo cxx-type.at:468 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:468"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:468: bison -o types.c types.y"
echo cxx-type.at:468 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o types.c types.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o types.c types.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:468"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:468: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o types types.c \$LIBS"
echo cxx-type.at:468 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o types types.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:468"

$at_failed && at_func_log_failure
$at_traceon; }

























{ $at_traceoff
$as_echo "$at_srcdir/cxx-type.at:470:  \$PREPARSER ./types test-input"
echo cxx-type.at:470 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./types test-input"; then
  ( $at_traceon;  $PREPARSER ./types test-input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./types test-input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "syntax error, unexpected ID, expecting '=' or '+' or ')'
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "+(z,q)
<declare>(T,x)
<init-declare>(T,x,y)
=(x,y)
+(<cast>(x,T),y)
<OR>(<declare>(T,x),<cast>(x,T))
<OR>(<init-declare>(T,y,+(z,q)),=(<cast>(y,T),+(z,q)))
<error>
+(z,q)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/cxx-type.at:470"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_219
#AT_START_220
# 220. glr-regression.at:23: Badly Collapsed GLR States
at_setup_line='glr-regression.at:23'
at_func_banner 21
at_desc="Badly Collapsed GLR States"
$at_quiet $as_echo_n "220: $at_desc                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "220. glr-regression.at:23: testing ..."
  $at_traceon


cat >glr-regr1.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Regression Test: Improper state compression */
/* Reported by Scott McPeak */

%{
#include <stdio.h>
#include <stdlib.h>

#define YYSTYPE int
static YYSTYPE exprMerge (YYSTYPE x0, YYSTYPE x1);
int yylex (void);
void yyerror (char const *msg);
%}


%glr-parser


/* -------- productions ------ */
%%

StartSymbol: E  { $$=0; }                   %merge <exprMerge>
           ;

E: E 'P' E { $$=1; printf("E -> E 'P' E\n"); }  %merge <exprMerge>
 | 'B'     { $$=2; printf("E -> 'B'\n"); }      %merge <exprMerge>
 ;



/* ---------- C code ----------- */
%%

static YYSTYPE exprMerge (YYSTYPE x0, YYSTYPE x1)
{
  (void) x0;
  (void) x1;
  printf ("<OR>\n");
  return 0;
}

int
main (void)
{
  return yyparse ();
}

void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}


int
yylex (void)
{
  for (;;)
    {
      int ch;
      if (feof (stdin))
	abort ();
      ch = getchar ();
      if (ch == EOF)
	return 0;
      else if (ch == 'B' || ch == 'P')
	return ch;
    }
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:96: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr1.c glr-regr1.y"
echo glr-regression.at:96 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr1.c glr-regr1.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr1.c glr-regr1.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:96"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:96: bison --xml=xml-tests/test.xml -o glr-regr1.c glr-regr1.y"
echo glr-regression.at:96 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o glr-regr1.c glr-regr1.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o glr-regr1.c glr-regr1.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:96"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:96: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:96 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:96"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:96: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:96 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:96"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:96: bison -o glr-regr1.c glr-regr1.y"
echo glr-regression.at:96 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o glr-regr1.c glr-regr1.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o glr-regr1.c glr-regr1.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "glr-regr1.y: conflicts: 1 shift/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:96"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:99: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr1 glr-regr1.c \$LIBS"
echo glr-regression.at:99 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr1 glr-regr1.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr1 glr-regr1.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr1 glr-regr1.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:99"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:100:  \$PREPARSER echo BPBPB | ./glr-regr1"
echo glr-regression.at:100 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER echo BPBPB | ./glr-regr1"; then
  ( $at_traceon;  $PREPARSER echo BPBPB | ./glr-regr1 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER echo BPBPB | ./glr-regr1 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "E -> 'B'
E -> 'B'
E -> E 'P' E
E -> 'B'
E -> E 'P' E
E -> 'B'
E -> E 'P' E
E -> E 'P' E
<OR>
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:100"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_220
#AT_START_221
# 221. glr-regression.at:118: Improper handling of embedded actions and dollar(-N) in GLR parsers
at_setup_line='glr-regression.at:118'
at_func_banner 21
at_desc="Improper handling of embedded actions and dollar(-N) in GLR parsers"
$at_quiet $as_echo_n "221: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "221. glr-regression.at:118: testing ..."
  $at_traceon


cat >glr-regr2a.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Regression Test: Improper handling of embedded actions and $-N  */
/* Reported by S. Eken */

%{
  #define YYSTYPE char *

  #include <ctype.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  int yylex (void);
  void yyerror (char const *);
%}

%glr-parser

%%

command:
    's' var 't'
       { printf ("Variable: '%s'\n", $2); }
    'v' 'x' 'q'
       { free ($2); }
  | 's' var_list 't' 'e'
       { printf ("Varlist: '%s'\n", $2); free ($2); }
  | 's' var 't' var_printer 'x'
       { free ($2); }
  ;

var:
  'V'
     { $$ = $1; }
  ;

var_list:
  var
    { $$ = $1; }
  | var ',' var_list
    {
      char *s = (char *) realloc ($1, strlen ($1) + 1 + strlen ($3) + 1);
      strcat (s, ",");
      strcat (s, $3);
      free ($3);
      $$ = s;
    }
  ;

var_printer: 'v'
   { printf ("Variable: '%s'\n", $-1); }

%%

FILE *input;

int
yylex (void)
{
  char buf[50];
  char *s;
  if (feof (stdin))
    abort ();
  switch (fscanf (input, " %1[a-z,]", buf)) {
  case 1:
    return buf[0];
  case EOF:
    return 0;
  default:
    break;
  }
  if (fscanf (input, "%49s", buf) != 1)
    return 0;
  if (sizeof buf - 1 <= strlen (buf))
    abort ();
  s = (char *) malloc (strlen (buf) + 1);
  strcpy (s, buf);
  yylval = s;
  return 'V';
}

void
yyerror (char const *s)
{ printf ("%s\n", s);
}

int
main (int argc, char **argv)
{
  input = stdin;
  if (argc == 2 && !(input = fopen (argv[1], "r"))) return 3;
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:214: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr2a.c glr-regr2a.y"
echo glr-regression.at:214 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr2a.c glr-regr2a.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr2a.c glr-regr2a.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:214"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:214: bison --xml=xml-tests/test.xml -o glr-regr2a.c glr-regr2a.y"
echo glr-regression.at:214 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o glr-regr2a.c glr-regr2a.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o glr-regr2a.c glr-regr2a.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:214"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:214: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:214 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:214"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:214: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:214 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:214"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:214: bison -o glr-regr2a.c glr-regr2a.y"
echo glr-regression.at:214 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o glr-regr2a.c glr-regr2a.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o glr-regr2a.c glr-regr2a.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "glr-regr2a.y: conflicts: 2 shift/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:214"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:217: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr2a glr-regr2a.c \$LIBS"
echo glr-regression.at:217 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr2a glr-regr2a.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr2a glr-regr2a.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr2a glr-regr2a.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:217"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:219:  \$PREPARSER echo s VARIABLE_1 t v x q | ./glr-regr2a"
echo glr-regression.at:219 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER echo s VARIABLE_1 t v x q | ./glr-regr2a"; then
  ( $at_traceon;  $PREPARSER echo s VARIABLE_1 t v x q | ./glr-regr2a ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER echo s VARIABLE_1 t v x q | ./glr-regr2a ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Variable: 'VARIABLE_1'
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:219"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:222:  \$PREPARSER echo s VARIABLE_1 , ANOTHER_VARIABLE_2 t e | ./glr-regr2a"
echo glr-regression.at:222 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER echo s VARIABLE_1 , ANOTHER_VARIABLE_2 t e | ./glr-regr2a"; then
  ( $at_traceon;  $PREPARSER echo s VARIABLE_1 , ANOTHER_VARIABLE_2 t e | ./glr-regr2a ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER echo s VARIABLE_1 , ANOTHER_VARIABLE_2 t e | ./glr-regr2a ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Varlist: 'VARIABLE_1,ANOTHER_VARIABLE_2'
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:222"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:226:  \$PREPARSER echo s VARIABLE_3 t v x | ./glr-regr2a"
echo glr-regression.at:226 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER echo s VARIABLE_3 t v x | ./glr-regr2a"; then
  ( $at_traceon;  $PREPARSER echo s VARIABLE_3 t v x | ./glr-regr2a ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER echo s VARIABLE_3 t v x | ./glr-regr2a ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Variable: 'VARIABLE_3'
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:226"

$at_failed && at_func_log_failure
$at_traceon; }



  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_221
#AT_START_222
# 222. glr-regression.at:237: Improper merging of GLR delayed action sets
at_setup_line='glr-regression.at:237'
at_func_banner 21
at_desc="Improper merging of GLR delayed action sets"
$at_quiet $as_echo_n "222: $at_desc    "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "222. glr-regression.at:237: testing ..."
  $at_traceon


cat >glr-regr3.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

/* Regression Test: Improper merging of GLR delayed action sets.  */
/* Reported by M. Rosien */

%{
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

static int MergeRule (int x0, int x1);
static void yyerror (char const * s);
int yylex (void);

#define RULE(x) (1 << (x))

%}

%glr-parser

%token BAD_CHAR
%token P1 P2 T1 T2 T3 T4 O1 O2

%%

S : P1 T4 O2 NT6 P2  { printf ("Result: %x\n", $4); }
;

NT1 : P1 T1 O1 T2 P2 { $$ = RULE(2); }  %merge<MergeRule>
;

NT2 : NT1             { $$ = RULE(3); } %merge<MergeRule>
    | P1 NT1 O1 T3 P2 { $$ = RULE(4); } %merge<MergeRule>
;

NT3 : T3              { $$ = RULE(5); } %merge<MergeRule>
    | P1 NT1 O1 T3 P2 { $$ = RULE(6); } %merge<MergeRule>
;

NT4 : NT3              { $$ = RULE(7); } %merge<MergeRule>
    | NT2              { $$ = RULE(8); } %merge<MergeRule>
    | P1 NT2 O1 NT3 P2 { $$ = RULE(9); } %merge<MergeRule>
;

NT5 : NT4              { $$ = RULE(10); } %merge<MergeRule>
;

NT6 : P1 NT1 O1 T3 P2  { $$ = RULE(11) | $2; } %merge<MergeRule>
    | NT5              { $$ = RULE(12) | $1; } %merge<MergeRule>
;

%%

static int MergeRule (int x0, int x1) {
  return x0 | x1;
}

static void yyerror(char const * s) {
  fprintf(stderr,"error: %s\n",s);
}

FILE *input = NULL;

int P[] = { P1, P2 };
int O[] = { O1, O2 };
int T[] = { T1, T2, T3, T4 };

int yylex (void)
{
  char inp[3];
  if (feof (stdin))
    abort ();
  if (fscanf (input, "%2s", inp) == EOF)
    return 0;
  switch (inp[0])
    {
    case 'p': return P[inp[1] - '1'];
    case 't': return T[inp[1] - '1'];
    case 'o': return O[inp[1] - '1'];
    }
  return BAD_CHAR;
}

int main(int argc, char* argv[]) {
  input = stdin;
  if (argc == 2 && !(input = fopen (argv[1], "r"))) return 3;
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:328: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr3.c glr-regr3.y"
echo glr-regression.at:328 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr3.c glr-regr3.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr3.c glr-regr3.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:328"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:328: bison --xml=xml-tests/test.xml -o glr-regr3.c glr-regr3.y"
echo glr-regression.at:328 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o glr-regr3.c glr-regr3.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o glr-regr3.c glr-regr3.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:328"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:328: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:328 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:328"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:328: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:328 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:328"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:328: bison -o glr-regr3.c glr-regr3.y"
echo glr-regression.at:328 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o glr-regr3.c glr-regr3.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o glr-regr3.c glr-regr3.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "glr-regr3.y: conflicts: 1 shift/reduce, 1 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:328"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:331: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr3 glr-regr3.c \$LIBS"
echo glr-regression.at:331 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr3 glr-regr3.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr3 glr-regr3.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr3 glr-regr3.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:331"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:333:  \$PREPARSER echo p1 t4 o2 p1 p1 t1 o1 t2 p2 o1 t3 p2 p2 | ./glr-regr3"
echo glr-regression.at:333 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER echo p1 t4 o2 p1 p1 t1 o1 t2 p2 o1 t3 p2 p2 | ./glr-regr3"; then
  ( $at_traceon;  $PREPARSER echo p1 t4 o2 p1 p1 t1 o1 t2 p2 o1 t3 p2 p2 | ./glr-regr3 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER echo p1 t4 o2 p1 p1 t1 o1 t2 p2 o1 t3 p2 p2 | ./glr-regr3 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Result: 1c04
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:333"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_222
#AT_START_223
# 223. glr-regression.at:346: Duplicate representation of merged trees
at_setup_line='glr-regression.at:346'
at_func_banner 21
at_desc="Duplicate representation of merged trees"
$at_quiet $as_echo_n "223: $at_desc       "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "223. glr-regression.at:346: testing ..."
  $at_traceon


cat >glr-regr4.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%union { char *ptr; }
%type <ptr> S A A1 A2 B
%glr-parser

%{
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  static char *merge (YYSTYPE, YYSTYPE);
  static char *make_value (char const *, char const *);
  static void yyerror (char const *);
  static int yylex (void);
  static char *ptrs[100];
  static char **ptrs_next = ptrs;
%}

%%

tree: S { printf ("%s\n", $1); } ;

S:
  A   %merge<merge> { $$ = make_value ("S", $1); }
  | B %merge<merge> { $$ = make_value ("S", $1); }
  ;

A:
  A1   %merge<merge> { $$ = make_value ("A", $1); }
  | A2 %merge<merge> { $$ = make_value ("A", $1); }
  ;

A1: 'a' { $$ = make_value ("A1", "'a'"); } ;
A2: 'a' { $$ = make_value ("A2", "'a'"); } ;
B:  'a' { $$ = make_value ("B", "'a'");  } ;

%%

static int
yylex (void)
{
  static char const input[] = "a";
  static size_t toknum;
  if (! (toknum < sizeof input))
    abort ();
  return input[toknum++];
}

int
main (void)
{
  int status = yyparse ();
  while (ptrs_next != ptrs)
    free (*--ptrs_next);
  return status;
}

static char *
make_value (char const *parent, char const *child)
{
  char const format[] = "%s <- %s";
  char *value = *ptrs_next++ =
    (char *) malloc (strlen (parent) + strlen (child) + sizeof format);
  sprintf (value, format, parent, child);
  return value;
}

static char *
merge (YYSTYPE s1, YYSTYPE s2)
{
  char const format[] = "merge{ %s and %s }";
  char *value = *ptrs_next++ =
    (char *) malloc (strlen (s1.ptr) + strlen (s2.ptr) + sizeof format);
  sprintf (value, format, s1.ptr, s2.ptr);
  return value;
}

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:432: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr4.c glr-regr4.y"
echo glr-regression.at:432 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr4.c glr-regr4.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr4.c glr-regr4.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:432"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:432: bison --xml=xml-tests/test.xml -o glr-regr4.c glr-regr4.y"
echo glr-regression.at:432 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o glr-regr4.c glr-regr4.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o glr-regr4.c glr-regr4.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:432"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:432: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:432 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:432"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:432: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:432 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:432"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:432: bison -o glr-regr4.c glr-regr4.y"
echo glr-regression.at:432 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o glr-regr4.c glr-regr4.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o glr-regr4.c glr-regr4.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "glr-regr4.y: conflicts: 1 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:432"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:435: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr4 glr-regr4.c \$LIBS"
echo glr-regression.at:435 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr4 glr-regr4.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr4 glr-regr4.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr4 glr-regr4.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:435"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:437:  \$PREPARSER ./glr-regr4"
echo glr-regression.at:437 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./glr-regr4"; then
  ( $at_traceon;  $PREPARSER ./glr-regr4 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./glr-regr4 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "merge{ S <- merge{ A <- A1 <- 'a' and A <- A2 <- 'a' } and S <- B <- 'a' }
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:437"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_223
#AT_START_224
# 224. glr-regression.at:449: User destructor for unresolved GLR semantic value
at_setup_line='glr-regression.at:449'
at_func_banner 21
at_desc="User destructor for unresolved GLR semantic value"
$at_quiet $as_echo_n "224: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "224. glr-regression.at:449: testing ..."
  $at_traceon


cat >glr-regr5.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%{
  #include <stdio.h>
  #include <stdlib.h>
  static void yyerror (char const *);
  static int yylex (void);
  enum { MAGIC_VALUE = -1057808125 }; /* originally chosen at random */
%}

%glr-parser
%union { int value; }
%type <value> start

%destructor {
  if ($$ != MAGIC_VALUE)
    {
      fprintf (stderr, "Bad destructor call.\n");
      exit (EXIT_FAILURE);
    }
} start

%%

start:
   'a' { $$ = MAGIC_VALUE; }
   | 'a' { $$ = MAGIC_VALUE; }
   ;

%%

static int
yylex (void)
{
  static char const input[] = "a";
  static size_t toknum;
  if (! (toknum < sizeof input))
    abort ();
  return input[toknum++];
}

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  return yyparse () != 1;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:505: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr5.c glr-regr5.y"
echo glr-regression.at:505 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr5.c glr-regr5.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr5.c glr-regr5.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:505"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:505: bison --xml=xml-tests/test.xml -o glr-regr5.c glr-regr5.y"
echo glr-regression.at:505 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o glr-regr5.c glr-regr5.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o glr-regr5.c glr-regr5.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:505"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:505: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:505 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:505"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:505: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:505 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:505"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:505: bison -o glr-regr5.c glr-regr5.y"
echo glr-regression.at:505 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o glr-regr5.c glr-regr5.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o glr-regr5.c glr-regr5.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "glr-regr5.y: conflicts: 1 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:505"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:508: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr5 glr-regr5.c \$LIBS"
echo glr-regression.at:508 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr5 glr-regr5.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr5 glr-regr5.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr5 glr-regr5.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:508"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:510:  \$PREPARSER ./glr-regr5"
echo glr-regression.at:510 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./glr-regr5"; then
  ( $at_traceon;  $PREPARSER ./glr-regr5 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./glr-regr5 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "syntax is ambiguous
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:510"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_224
#AT_START_225
# 225. glr-regression.at:522: User destructor after an error during a split parse
at_setup_line='glr-regression.at:522'
at_func_banner 21
at_desc="User destructor after an error during a split parse"
$at_quiet $as_echo_n "225: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "225. glr-regression.at:522: testing ..."
  $at_traceon


cat >glr-regr6.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%{
  #include <stdio.h>
  #include <stdlib.h>
  static void yyerror (char const *);
  static int yylex (void);
%}

%glr-parser
%union { int value; }
%type <value> 'a'

%destructor {
  printf ("Destructor called.\n");
} 'a'

%%

start: 'a' | 'a' ;

%%

static int
yylex (void)
{
  static char const input[] = "a";
  static size_t toknum;
  if (! (toknum < sizeof input))
    abort ();
  return input[toknum++];
}

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  return yyparse () != 1;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:570: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr6.c glr-regr6.y"
echo glr-regression.at:570 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr6.c glr-regr6.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr6.c glr-regr6.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:570"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:570: bison --xml=xml-tests/test.xml -o glr-regr6.c glr-regr6.y"
echo glr-regression.at:570 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o glr-regr6.c glr-regr6.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o glr-regr6.c glr-regr6.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:570"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:570: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:570 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:570"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:570: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:570 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:570"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:570: bison -o glr-regr6.c glr-regr6.y"
echo glr-regression.at:570 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o glr-regr6.c glr-regr6.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o glr-regr6.c glr-regr6.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "glr-regr6.y: conflicts: 1 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:570"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:573: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr6 glr-regr6.c \$LIBS"
echo glr-regression.at:573 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr6 glr-regr6.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr6 glr-regr6.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr6 glr-regr6.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:573"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:575:  \$PREPARSER ./glr-regr6"
echo glr-regression.at:575 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./glr-regr6"; then
  ( $at_traceon;  $PREPARSER ./glr-regr6 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./glr-regr6 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "syntax is ambiguous
" | \
  $at_diff - "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Destructor called.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:575"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_225
#AT_START_226
# 226. glr-regression.at:589: Duplicated user destructor for lookahead
at_setup_line='glr-regression.at:589'
at_func_banner 21
at_desc="Duplicated user destructor for lookahead"
$at_quiet $as_echo_n "226: $at_desc       "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "226. glr-regression.at:589: testing ..."
  $at_traceon


cat >glr-regr7.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%{
  #include <stdio.h>
  #include <stdlib.h>
  static void yyerror (char const *);
  static int yylex (void);
  #define YYSTACKEXPANDABLE 0
  typedef struct count_node {
    int count;
    struct count_node *prev;
  } count_node;
  static count_node *tail;
%}

%glr-parser
%union { count_node *node; }
%type <node> 'a'

%destructor {
  if ($$->count++)
    fprintf (stderr, "Destructor called on same value twice.\n");
} 'a'

%%

start:
    stack1 start
  | stack2 start
  | /* empty */
  ;
stack1: 'a' ;
stack2: 'a' ;

%%

static int
yylex (void)
{
  yylval.node = (count_node*) malloc (sizeof *yylval.node);
  if (!yylval.node)
    {
      fprintf (stderr, "Test inconclusive.\n");
      exit (EXIT_FAILURE);
    }
  yylval.node->count = 0;
  yylval.node->prev = tail;
  tail = yylval.node;
  return 'a';
}

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  int status = yyparse ();
  while (tail)
    {
      count_node *prev = tail->prev;
      free (tail);
      tail = prev;
    }
  return status;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:662: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr7.c glr-regr7.y"
echo glr-regression.at:662 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr7.c glr-regr7.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr7.c glr-regr7.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:662"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:662: bison --xml=xml-tests/test.xml -o glr-regr7.c glr-regr7.y"
echo glr-regression.at:662 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o glr-regr7.c glr-regr7.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o glr-regr7.c glr-regr7.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:662"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:662: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:662 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:662"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:662: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:662 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:662"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:662: bison -o glr-regr7.c glr-regr7.y"
echo glr-regression.at:662 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o glr-regr7.c glr-regr7.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o glr-regr7.c glr-regr7.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "glr-regr7.y: conflicts: 2 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:662"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:665: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr7 glr-regr7.c \$LIBS"
echo glr-regression.at:665 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr7 glr-regr7.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr7 glr-regr7.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr7 glr-regr7.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:665"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:667:  \$PREPARSER ./glr-regr7"
echo glr-regression.at:667 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./glr-regr7"; then
  ( $at_traceon;  $PREPARSER ./glr-regr7 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./glr-regr7 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "memory exhausted
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 2 $at_status "$at_srcdir/glr-regression.at:667"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_226
#AT_START_227
# 227. glr-regression.at:681: Incorrectly initialized location for empty right-hand side in GLR
at_setup_line='glr-regression.at:681'
at_func_banner 21
at_desc="Incorrectly initialized location for empty right-hand side in GLR"
$at_quiet $as_echo_n "227: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "227. glr-regression.at:681: testing ..."
  $at_traceon


cat >glr-regr8.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%{
  #include <stdio.h>
  #include <stdlib.h>
  static void yyerror (char const *);
  static int yylex (void);
  static void yyerror (char const *msg);
%}

%token T_CONSTANT
%token T_PORT
%token T_SIGNAL

%glr-parser

%%


PortClause	: T_PORT InterfaceDeclaration T_PORT
		{ printf("%d/%d - %d/%d - %d/%d\n",
			 @1.first_column, @1.last_column,
			 @2.first_column, @2.last_column,
			 @3.first_column, @3.last_column); }
	;

InterfaceDeclaration	: OptConstantWord	%dprec 1
	| OptSignalWord	%dprec 2
	;

OptConstantWord	: /* empty */
	| T_CONSTANT
	;

OptSignalWord	: /* empty */
		{ printf("empty: %d/%d\n", @$.first_column, @$.last_column); }
	| T_SIGNAL
	;

%%

void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int lexIndex;

int yylex (void)
{
  lexIndex += 1;
  switch (lexIndex)
    {
    default:
      abort ();
    case 1:
      yylloc.first_column = 1;
      yylloc.last_column = 9;
      return T_PORT;
    case 2:
      yylloc.first_column = 13;
      yylloc.last_column = 17;
      return T_PORT;
    case 3:
      return 0;
    }
}

int
main (void)
{
  yyparse();
  return 0;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:760: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr8.c glr-regr8.y"
echo glr-regression.at:760 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr8.c glr-regr8.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr8.c glr-regr8.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:760"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:760: bison --xml=xml-tests/test.xml -o glr-regr8.c glr-regr8.y"
echo glr-regression.at:760 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o glr-regr8.c glr-regr8.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o glr-regr8.c glr-regr8.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:760"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:760: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:760 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:760"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:760: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:760 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:760"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:760: bison -o glr-regr8.c glr-regr8.y"
echo glr-regression.at:760 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o glr-regr8.c glr-regr8.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o glr-regr8.c glr-regr8.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "glr-regr8.y: conflicts: 1 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:760"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:763: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr8 glr-regr8.c \$LIBS"
echo glr-regression.at:763 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr8 glr-regr8.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr8 glr-regr8.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr8 glr-regr8.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:763"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:765:  \$PREPARSER ./glr-regr8"
echo glr-regression.at:765 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./glr-regr8"; then
  ( $at_traceon;  $PREPARSER ./glr-regr8 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./glr-regr8 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "empty: 9/9
1/9 - 9/9 - 13/17
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:765"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_227
#AT_START_228
# 228. glr-regression.at:779: No users destructors if stack 0 deleted
at_setup_line='glr-regression.at:779'
at_func_banner 21
at_desc="No users destructors if stack 0 deleted"
$at_quiet $as_echo_n "228: $at_desc        "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "228. glr-regression.at:779: testing ..."
  $at_traceon


cat >glr-regr9.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%{
# include <stdio.h>
# include <stdlib.h>
  static void yyerror (char const *);
  static int yylex (void);
# define YYSTACKEXPANDABLE 0
  static int tokens = 0;
  static int destructors = 0;
# define USE(Var)
%}

%glr-parser
%union { int dummy; }
%type <dummy> 'a'

%destructor {
  destructors += 1;
} 'a'

%%

start:
    ambig0 'a'   { destructors += 2; USE ($2); }
  | ambig1 start { destructors += 1; }
  | ambig2 start { destructors += 1; }
  ;

ambig0: 'a' ;
ambig1: 'a' ;
ambig2: 'a' ;

%%

static int
yylex (void)
{
  tokens += 1;
  return 'a';
}

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  int exit_status;
  exit_status = yyparse ();
  if (tokens != destructors)
    {
      fprintf (stderr, "Tokens = %d, Destructors = %d\n", tokens, destructors);
      return 1;
    }
  return !exit_status;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:843: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr9.c glr-regr9.y"
echo glr-regression.at:843 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr9.c glr-regr9.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr9.c glr-regr9.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:843"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:843: bison --xml=xml-tests/test.xml -o glr-regr9.c glr-regr9.y"
echo glr-regression.at:843 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o glr-regr9.c glr-regr9.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o glr-regr9.c glr-regr9.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:843"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:843: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:843 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:843"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:843: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:843 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:843"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:843: bison -o glr-regr9.c glr-regr9.y"
echo glr-regression.at:843 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o glr-regr9.c glr-regr9.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o glr-regr9.c glr-regr9.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "glr-regr9.y: conflicts: 1 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:843"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:846: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr9 glr-regr9.c \$LIBS"
echo glr-regression.at:846 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr9 glr-regr9.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr9 glr-regr9.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr9 glr-regr9.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:846"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:848:  \$PREPARSER ./glr-regr9"
echo glr-regression.at:848 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./glr-regr9"; then
  ( $at_traceon;  $PREPARSER ./glr-regr9 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./glr-regr9 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "memory exhausted
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:848"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_228
#AT_START_229
# 229. glr-regression.at:859: Corrupted semantic options if user action cuts parse
at_setup_line='glr-regression.at:859'
at_func_banner 21
at_desc="Corrupted semantic options if user action cuts parse"
$at_quiet $as_echo_n "229: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "229. glr-regression.at:859: testing ..."
  $at_traceon


cat >glr-regr10.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%{
# include <stdlib.h>
# include <stdio.h>
  static void yyerror (char const *);
  static int yylex (void);
  #define GARBAGE_SIZE 50
  static char garbage[GARBAGE_SIZE];
%}

%glr-parser
%union { char *ptr; }
%type <ptr> start

%%

start:
    %dprec 2 { $$ = garbage; YYACCEPT; }
  | %dprec 1 { $$ = garbage; YYACCEPT; }
  ;

%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int called;
  if (called++)
    abort ();
  return 0;
}

int
main (void)
{
  int i;
  for (i = 0; i < GARBAGE_SIZE; i+=1)
    garbage[i] = 108;
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:910: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr10.c glr-regr10.y"
echo glr-regression.at:910 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr10.c glr-regr10.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr10.c glr-regr10.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:910"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:910: bison --xml=xml-tests/test.xml -o glr-regr10.c glr-regr10.y"
echo glr-regression.at:910 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o glr-regr10.c glr-regr10.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o glr-regr10.c glr-regr10.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:910"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:910: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:910 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:910"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:910: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:910 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:910"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:910: bison -o glr-regr10.c glr-regr10.y"
echo glr-regression.at:910 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o glr-regr10.c glr-regr10.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o glr-regr10.c glr-regr10.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "glr-regr10.y: conflicts: 1 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:910"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:913: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr10 glr-regr10.c \$LIBS"
echo glr-regression.at:913 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr10 glr-regr10.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr10 glr-regr10.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr10 glr-regr10.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:913"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:915:  \$PREPARSER ./glr-regr10"
echo glr-regression.at:915 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./glr-regr10"; then
  ( $at_traceon;  $PREPARSER ./glr-regr10 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./glr-regr10 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:915"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_229
#AT_START_230
# 230. glr-regression.at:924: Undesirable destructors if user action cuts parse
at_setup_line='glr-regression.at:924'
at_func_banner 21
at_desc="Undesirable destructors if user action cuts parse"
$at_quiet $as_echo_n "230: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "230. glr-regression.at:924: testing ..."
  $at_traceon


cat >glr-regr11.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%{
# include <stdlib.h>
  static void yyerror (char const *);
  static int yylex (void);
  static int destructors = 0;
# define USE(val)
%}

%glr-parser
%union { int dummy; }
%type <int> 'a'
%destructor { destructors += 1; } 'a'

%%

start:
    'a' %dprec 2 { USE ($1); destructors += 1; YYACCEPT; }
  | 'a' %dprec 1 { USE ($1); destructors += 1; YYACCEPT; }
  ;

%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static char const input[] = "a";
  static size_t toknum;
  if (! (toknum < sizeof input))
    abort ();
  return input[toknum++];
}

int
main (void)
{
  int exit_status = yyparse ();
  if (destructors != 1)
    {
      fprintf (stderr, "Destructor calls: %d\n", destructors);
      return 1;
    }
  return exit_status;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:979: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr11.c glr-regr11.y"
echo glr-regression.at:979 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr11.c glr-regr11.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr11.c glr-regr11.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:979"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:979: bison --xml=xml-tests/test.xml -o glr-regr11.c glr-regr11.y"
echo glr-regression.at:979 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o glr-regr11.c glr-regr11.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o glr-regr11.c glr-regr11.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:979"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:979: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:979 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:979"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:979: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:979 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:979"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:979: bison -o glr-regr11.c glr-regr11.y"
echo glr-regression.at:979 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o glr-regr11.c glr-regr11.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o glr-regr11.c glr-regr11.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "glr-regr11.y: conflicts: 1 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:979"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:982: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr11 glr-regr11.c \$LIBS"
echo glr-regression.at:982 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr11 glr-regr11.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr11 glr-regr11.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr11 glr-regr11.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:982"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:984:  \$PREPARSER ./glr-regr11"
echo glr-regression.at:984 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./glr-regr11"; then
  ( $at_traceon;  $PREPARSER ./glr-regr11 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./glr-regr11 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:984"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_230
#AT_START_231
# 231. glr-regression.at:993: Leaked semantic values if user action cuts parse
at_setup_line='glr-regression.at:993'
at_func_banner 21
at_desc="Leaked semantic values if user action cuts parse"
$at_quiet $as_echo_n "231: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "231. glr-regression.at:993: testing ..."
  $at_traceon


cat >glr-regr12.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%glr-parser
%union { int dummy; }
%token PARENT_RHS_AFTER
%type <dummy> parent_rhs_before merged PARENT_RHS_AFTER
%destructor { parent_rhs_before_value = 0; } parent_rhs_before
%destructor { merged_value = 0; } merged
%destructor { parent_rhs_after_value = 0; } PARENT_RHS_AFTER

%{
# include <stdlib.h>
  static int merge (YYSTYPE, YYSTYPE);
  static void yyerror (char const *);
  static int yylex (void);
  static int parent_rhs_before_value = 0;
  static int merged_value = 0;
  static int parent_rhs_after_value = 0;
# define USE(val)
%}

%%

start:
  alt1 %dprec 1
  | alt2 %dprec 2
  ;

alt1:
  PARENT_RHS_AFTER {
    USE ($1);
    parent_rhs_after_value = 0;
  }
  ;

alt2:
  parent_rhs_before merged PARENT_RHS_AFTER {
    USE (($1, $2, $3));
    parent_rhs_before_value = 0;
    merged_value = 0;
    parent_rhs_after_value = 0;
  }
  ;

parent_rhs_before:
  {
    USE ($$);
    parent_rhs_before_value = 1;
  }
  ;

merged:
  %merge<merge> {
    USE ($$);
    merged_value = 1;
  }
  | cut %merge<merge> {
    USE ($$);
    merged_value = 1;
  }
  ;

cut: { YYACCEPT; } ;

%%

static int
merge (YYSTYPE s1, YYSTYPE s2)
{
  /* Not invoked. */
  char dummy = s1.dummy + s2.dummy;
  return dummy;
}

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = { PARENT_RHS_AFTER, 0 };
  static size_t toknum;
  if (! (toknum < sizeof input / sizeof *input))
    abort ();
  if (input[toknum] == PARENT_RHS_AFTER)
    parent_rhs_after_value = 1;
  return input[toknum++];
}

int
main (void)
{
  int exit_status = yyparse ();
  if (parent_rhs_before_value)
    {
      fprintf (stderr, "`parent_rhs_before' destructor not called.\n");
      exit_status = 1;
    }
  if (merged_value)
    {
      fprintf (stderr, "`merged' destructor not called.\n");
      exit_status = 1;
    }
  if (parent_rhs_after_value)
    {
      fprintf (stderr, "`PARENT_RHS_AFTER' destructor not called.\n");
      exit_status = 1;
    }
  return exit_status;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1110: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr12.c glr-regr12.y"
echo glr-regression.at:1110 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr12.c glr-regr12.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr12.c glr-regr12.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1110"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1110: bison --xml=xml-tests/test.xml -o glr-regr12.c glr-regr12.y"
echo glr-regression.at:1110 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o glr-regr12.c glr-regr12.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o glr-regr12.c glr-regr12.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1110"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1110: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:1110 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1110"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1110: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:1110 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1110"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1110: bison -o glr-regr12.c glr-regr12.y"
echo glr-regression.at:1110 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o glr-regr12.c glr-regr12.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o glr-regr12.c glr-regr12.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "glr-regr12.y: conflicts: 1 shift/reduce, 1 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1110"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1113: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr12 glr-regr12.c \$LIBS"
echo glr-regression.at:1113 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr12 glr-regr12.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr12 glr-regr12.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr12 glr-regr12.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1113"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1115:  \$PREPARSER ./glr-regr12"
echo glr-regression.at:1115 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./glr-regr12"; then
  ( $at_traceon;  $PREPARSER ./glr-regr12 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./glr-regr12 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1115"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_231
#AT_START_232
# 232. glr-regression.at:1126: Incorrect lookahead during deterministic GLR
at_setup_line='glr-regression.at:1126'
at_func_banner 21
at_desc="Incorrect lookahead during deterministic GLR"
$at_quiet $as_echo_n "232: $at_desc   "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "232. glr-regression.at:1126: testing ..."
  $at_traceon


cat >glr-regr13.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


/* Tests:
     - Defaulted state with initial yychar: yychar == YYEMPTY.
     - Nondefaulted state: yychar != YYEMPTY.
     - Defaulted state after lookahead: yychar != YYEMPTY.
     - Defaulted state after shift: yychar == YYEMPTY.
     - User action changing the lookahead.  */

%{
  #include <stdio.h>
  static void yyerror (char const *);
  static int yylex (void);
  static void print_lookahead (char const *);
  #define USE(value)
%}

%union { char value; }
%type <value> 'a' 'b'
%glr-parser
%locations

%%

start:
  defstate_init defstate_shift 'b' change_lookahead 'a' {
    USE ($3);
    print_lookahead ("start <- defstate_init defstate_shift 'b'");
  }
  ;
defstate_init:
  {
    print_lookahead ("defstate_init <- empty string");
  }
  ;
defstate_shift:
  nondefstate defstate_look 'a' {
    USE ($3);
    print_lookahead ("defstate_shift <- nondefstate defstate_look 'a'");
  }
  ;
defstate_look:
  {
    print_lookahead ("defstate_look <- empty string");
  }
  ;
nondefstate:
  {
    print_lookahead ("nondefstate <- empty string");
  }
  | 'b' {
    USE ($1);
    print_lookahead ("nondefstate <- 'b'");
  }
  ;
change_lookahead:
  {
    yychar = 'a';
  }
  ;

%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static char const input[] = "ab";
  static size_t toknum;
  if (! (toknum < sizeof input))
    abort ();
  yylloc.first_line = yylloc.last_line = 1;
  yylloc.first_column = yylloc.last_column = toknum + 1;
  yylval.value = input[toknum] + 'A' - 'a';
  return input[toknum++];
}

static void
print_lookahead (char const *reduction)
{
  printf ("%s:\n  yychar=", reduction);
  if (yychar == YYEMPTY)
    printf ("YYEMPTY");
  else if (yychar == YYEOF)
    printf ("YYEOF");
  else
    {
      printf ("'%c', yylval='", yychar);
      if (yylval.value > ' ')
	printf ("%c", yylval.value);
      printf ("', yylloc=(%d,%d),(%d,%d)",
	      yylloc.first_line, yylloc.first_column,
	      yylloc.last_line, yylloc.last_column);
    }
  printf ("\n");
}

int
main (void)
{
  yychar = '#'; /* Not a token in the grammar.  */
  yylval.value = '!';
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1239: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr13.c glr-regr13.y"
echo glr-regression.at:1239 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr13.c glr-regr13.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr13.c glr-regr13.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1239"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1239: bison --xml=xml-tests/test.xml -o glr-regr13.c glr-regr13.y"
echo glr-regression.at:1239 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o glr-regr13.c glr-regr13.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o glr-regr13.c glr-regr13.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1239"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1239: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:1239 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1239"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1239: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:1239 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1239"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1239: bison -o glr-regr13.c glr-regr13.y"
echo glr-regression.at:1239 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o glr-regr13.c glr-regr13.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o glr-regr13.c glr-regr13.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1239"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1240: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr13 glr-regr13.c \$LIBS"
echo glr-regression.at:1240 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr13 glr-regr13.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr13 glr-regr13.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr13 glr-regr13.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1240"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1242:  \$PREPARSER ./glr-regr13"
echo glr-regression.at:1242 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./glr-regr13"; then
  ( $at_traceon;  $PREPARSER ./glr-regr13 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./glr-regr13 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "defstate_init <- empty string:
  yychar=YYEMPTY
nondefstate <- empty string:
  yychar='a', yylval='A', yylloc=(1,1),(1,1)
defstate_look <- empty string:
  yychar='a', yylval='A', yylloc=(1,1),(1,1)
defstate_shift <- nondefstate defstate_look 'a':
  yychar=YYEMPTY
start <- defstate_init defstate_shift 'b':
  yychar=YYEMPTY
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1242"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_232
#AT_START_233
# 233. glr-regression.at:1262: Incorrect lookahead during nondeterministic GLR
at_setup_line='glr-regression.at:1262'
at_func_banner 21
at_desc="Incorrect lookahead during nondeterministic GLR"
$at_quiet $as_echo_n "233: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "233. glr-regression.at:1262: testing ..."
  $at_traceon


cat >glr-regr14.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


/* Tests:
     - Conflicting actions (split-off parse, which copies lookahead need,
       which is necessarily yytrue) and nonconflicting actions (non-split-off
       parse) for nondefaulted state: yychar != YYEMPTY.
     - Merged deferred actions (lookahead need and RHS from different stack
       than the target state) and nonmerged deferred actions (same stack).
     - Defaulted state after lookahead: yychar != YYEMPTY.
     - Defaulted state after shift: yychar == YYEMPTY.
     - yychar != YYEMPTY but lookahead need is yyfalse (a previous stack has
       seen the lookahead but current stack has not).
     - Exceeding stack capacity (stack explosion), and thus reallocating
       lookahead need array.
   Note that it does not seem possible to see the initial yychar value during
   nondeterministic operation since:
     - In order to preserve the initial yychar, only defaulted states may be
       entered.
     - If only defaulted states are entered, there are no conflicts, so
       nondeterministic operation does not start.  */

%union { char value; }

%{
  #include <stdlib.h>
  #include <stdio.h>
  static void yyerror (char const *);
  static int yylex (void);
  static void print_lookahead (char const *);
  static char merge (union YYSTYPE, union YYSTYPE);
  #define USE(value)
%}

%type <value> 'a' 'b' 'c' 'd' stack_explosion
%glr-parser
%locations

%%

start:
  merge 'c' stack_explosion {
    USE ($2); USE ($3);
    print_lookahead ("start <- merge 'c' stack_explosion");
  }
  ;

/* When merging the 2 deferred actions, the lookahead needs are different.  */
merge:
  nonconflict1 'a' 'b' nonconflict2 %dprec 1 {
    USE ($2); USE ($3);
    print_lookahead ("merge <- nonconflict1 'a' 'b' nonconflict2");
  }
  | conflict defstate_look 'a' nonconflict2 'b' defstate_shift %dprec 2 {
    USE ($3); USE ($5);
    print_lookahead ("merge <- conflict defstate_look 'a' nonconflict2 'b'"
		      " defstate_shift");
  }
  ;

nonconflict1:
  {
    print_lookahead ("nonconflict1 <- empty string");
  }
  ;
nonconflict2:
  {
    print_lookahead ("nonconflict2 <- empty string");
  }
  | 'a' {
    USE ($1);
    print_lookahead ("nonconflict2 <- 'a'");
  }
  ;
conflict:
  {
    print_lookahead ("conflict <- empty string");
  }
  ;
defstate_look:
  {
    print_lookahead ("defstate_look <- empty string");
  }
  ;

/* yychar != YYEMPTY but lookahead need is yyfalse.  */
defstate_shift:
  {
    print_lookahead ("defstate_shift <- empty string");
  }
  ;

stack_explosion:
  { $$ = '\0'; }
  | alt1 stack_explosion %merge<merge> { $$ = $2; }
  | alt2 stack_explosion %merge<merge> { $$ = $2; }
  | alt3 stack_explosion %merge<merge> { $$ = $2; }
  ;
alt1:
  'd' no_look {
    USE ($1);
    if (yychar != 'd' && yychar != YYEOF)
      {
	fprintf (stderr, "Incorrect lookahead during stack explosion.\n");
      }
  }
  ;
alt2:
  'd' no_look {
    USE ($1);
    if (yychar != 'd' && yychar != YYEOF)
      {
	fprintf (stderr, "Incorrect lookahead during stack explosion.\n");
      }
  }
  ;
alt3:
  'd' no_look {
    USE ($1);
    if (yychar != 'd' && yychar != YYEOF)
      {
	fprintf (stderr, "Incorrect lookahead during stack explosion.\n");
      }
  }
  ;
no_look:
  {
    if (yychar != YYEMPTY)
      {
	fprintf (stderr,
		 "Found lookahead where shouldn't during stack explosion.\n");
      }
  }
  ;

%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static char const input[] = "abcdddd";
  static size_t toknum;
  if (! (toknum < sizeof input))
    abort ();
  yylloc.first_line = yylloc.last_line = 1;
  yylloc.first_column = yylloc.last_column = toknum + 1;
  yylval.value = input[toknum] + 'A' - 'a';
  return input[toknum++];
}

static void
print_lookahead (char const *reduction)
{
  printf ("%s:\n  yychar=", reduction);
  if (yychar == YYEMPTY)
    printf ("YYEMPTY");
  else if (yychar == YYEOF)
    printf ("YYEOF");
  else
    {
      printf ("'%c', yylval='", yychar);
      if (yylval.value > ' ')
	printf ("%c", yylval.value);
      printf ("', yylloc=(%d,%d),(%d,%d)",
	      yylloc.first_line, yylloc.first_column,
	      yylloc.last_line, yylloc.last_column);
    }
  printf ("\n");
}

static char
merge (union YYSTYPE s1, union YYSTYPE s2)
{
  char dummy = s1.value + s2.value;
  return dummy;
}

int
main (void)
{
  yychar = '#'; /* Not a token in the grammar.  */
  yylval.value = '!';
  return yyparse ();
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1455: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr14.c glr-regr14.y"
echo glr-regression.at:1455 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr14.c glr-regr14.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr14.c glr-regr14.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1455"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1455: bison --xml=xml-tests/test.xml -o glr-regr14.c glr-regr14.y"
echo glr-regression.at:1455 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o glr-regr14.c glr-regr14.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o glr-regr14.c glr-regr14.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1455"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1455: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:1455 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1455"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1455: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:1455 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1455"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1455: bison -o glr-regr14.c glr-regr14.y"
echo glr-regression.at:1455 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o glr-regr14.c glr-regr14.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o glr-regr14.c glr-regr14.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "glr-regr14.y: conflicts: 3 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1455"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1458: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr14 glr-regr14.c \$LIBS"
echo glr-regression.at:1458 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr14 glr-regr14.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr14 glr-regr14.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr14 glr-regr14.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1458"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1460:  \$PREPARSER ./glr-regr14"
echo glr-regression.at:1460 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./glr-regr14"; then
  ( $at_traceon;  $PREPARSER ./glr-regr14 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./glr-regr14 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "conflict <- empty string:
  yychar='a', yylval='A', yylloc=(1,1),(1,1)
defstate_look <- empty string:
  yychar='a', yylval='A', yylloc=(1,1),(1,1)
nonconflict2 <- empty string:
  yychar='b', yylval='B', yylloc=(1,2),(1,2)
defstate_shift <- empty string:
  yychar=YYEMPTY
merge <- conflict defstate_look 'a' nonconflict2 'b' defstate_shift:
  yychar=YYEMPTY
start <- merge 'c' stack_explosion:
  yychar=YYEOF
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1460"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_233
#AT_START_234
# 234. glr-regression.at:1482: Leaked semantic values when reporting ambiguity
at_setup_line='glr-regression.at:1482'
at_func_banner 21
at_desc="Leaked semantic values when reporting ambiguity"
$at_quiet $as_echo_n "234: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "234. glr-regression.at:1482: testing ..."
  $at_traceon


cat >glr-regr15.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%glr-parser
%destructor { parent_rhs_before_value = 0; } parent_rhs_before

%{
# include <stdlib.h>
  static void yyerror (char const *);
  static int yylex (void);
  static int parent_rhs_before_value = 0;
# define USE(val)
%}

%%

start:
  alt1 %dprec 1
  | alt2 %dprec 2
  ;

/* This stack must be merged into the other stacks *last* (added at the
   beginning of the semantic options list) so that yyparse will choose to clean
   it up rather than the tree for which some semantic actions have been
   performed.  Thus, if yyreportAmbiguity longjmp's to yyparse, the values from
   those other trees are not cleaned up.  */
alt1: ;

alt2:
  parent_rhs_before ambiguity {
    USE ($1);
    parent_rhs_before_value = 0;
  }
  ;

parent_rhs_before:
  {
    USE ($$);
    parent_rhs_before_value = 1;
  }
  ;

ambiguity: ambiguity1 | ambiguity2 ;
ambiguity1: ;
ambiguity2: ;

%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int called;
  if (called++)
    abort ();
  return 0;
}

int
main (void)
{
  int exit_status = yyparse () != 1;
  if (parent_rhs_before_value)
    {
      fprintf (stderr, "`parent_rhs_before' destructor not called.\n");
      exit_status = 1;
    }
  return exit_status;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1559: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr15.c glr-regr15.y"
echo glr-regression.at:1559 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr15.c glr-regr15.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr15.c glr-regr15.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1559"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1559: bison --xml=xml-tests/test.xml -o glr-regr15.c glr-regr15.y"
echo glr-regression.at:1559 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o glr-regr15.c glr-regr15.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o glr-regr15.c glr-regr15.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1559"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1559: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:1559 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1559"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1559: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:1559 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1559"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1559: bison -o glr-regr15.c glr-regr15.y"
echo glr-regression.at:1559 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o glr-regr15.c glr-regr15.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o glr-regr15.c glr-regr15.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "glr-regr15.y: conflicts: 2 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1559"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1562: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr15 glr-regr15.c \$LIBS"
echo glr-regression.at:1562 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr15 glr-regr15.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr15 glr-regr15.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr15 glr-regr15.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1562"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1564:  \$PREPARSER ./glr-regr15"
echo glr-regression.at:1564 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./glr-regr15"; then
  ( $at_traceon;  $PREPARSER ./glr-regr15 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./glr-regr15 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "syntax is ambiguous
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1564"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_234
#AT_START_235
# 235. glr-regression.at:1575: Leaked lookahead after nondeterministic parse syntax error
at_setup_line='glr-regression.at:1575'
at_func_banner 21
at_desc="Leaked lookahead after nondeterministic parse syntax error"
$at_quiet $as_echo_n "235: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "235. glr-regression.at:1575: testing ..."
  $at_traceon

cat >glr-regr16.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%glr-parser
%destructor { lookahead_value = 0; } 'b'

%{
# include <stdlib.h>
  static void yyerror (char const *);
  static int yylex (void);
  static int lookahead_value = 0;
# define USE(val)
%}

%%

start: alt1 'a' | alt2 'a' ;
alt1: ;
alt2: ;

%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static char const input[] = "ab";
  static size_t toknum;
  if (! (toknum < sizeof input))
    abort ();
  if (input[toknum] == 'b')
    lookahead_value = 1;
  return input[toknum++];
}

int
main (void)
{
  int exit_status = yyparse () != 1;
  if (lookahead_value)
    {
      fprintf (stderr, "Lookahead destructor not called.\n");
      exit_status = 1;
    }
  return exit_status;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1628: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr16.c glr-regr16.y"
echo glr-regression.at:1628 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr16.c glr-regr16.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr16.c glr-regr16.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1628"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1628: bison --xml=xml-tests/test.xml -o glr-regr16.c glr-regr16.y"
echo glr-regression.at:1628 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o glr-regr16.c glr-regr16.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o glr-regr16.c glr-regr16.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1628"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1628: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:1628 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1628"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1628: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:1628 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1628"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1628: bison -o glr-regr16.c glr-regr16.y"
echo glr-regression.at:1628 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o glr-regr16.c glr-regr16.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o glr-regr16.c glr-regr16.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "glr-regr16.y: conflicts: 1 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1628"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1631: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr16 glr-regr16.c \$LIBS"
echo glr-regression.at:1631 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr16 glr-regr16.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr16 glr-regr16.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr16 glr-regr16.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1631"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1633:  \$PREPARSER ./glr-regr16"
echo glr-regression.at:1633 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./glr-regr16"; then
  ( $at_traceon;  $PREPARSER ./glr-regr16 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./glr-regr16 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "syntax error
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1633"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_235
#AT_START_236
# 236. glr-regression.at:1644: Uninitialized location when reporting ambiguity
at_setup_line='glr-regression.at:1644'
at_func_banner 21
at_desc="Uninitialized location when reporting ambiguity"
$at_quiet $as_echo_n "236: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "236. glr-regression.at:1644: testing ..."
  $at_traceon

cat >glr-regr17.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%glr-parser
%locations
%define api.pure
%error-verbose

%union { int dummy; }

%{
  static void yyerror (YYLTYPE *, char const *);
  static int yylex (YYSTYPE *, YYLTYPE *);
%}

%initial-action {
  @$.first_line = 1;
  @$.first_column = 1;
  @$.last_line = 1;
  @$.last_column = 1;
}

%%

/* Tests the case of an empty RHS that has inherited the location of the
   previous nonterminal, which is unresolved.  That location is reported as the
   last position of the ambiguity.  */
start: ambig1 empty1 | ambig2 empty2 ;

/* Tests multiple levels of yyresolveLocations recursion.  */
ambig1: sub_ambig1 | sub_ambig2 ;
ambig2: sub_ambig1 | sub_ambig2 ;

/* Tests the case of a non-empty RHS as well as the case of an empty RHS that
   has inherited the initial location.  The empty RHS's location is reported as
   the first position in the ambiguity.  */
sub_ambig1: empty1 'a' 'b' ;
sub_ambig2: empty2 'a' 'b' ;
empty1: ;
empty2: ;

%%

static void
yyerror (YYLTYPE *locp, char const *msg)
{
  fprintf (stderr, "Error at %d.%d-%d.%d: %s.\n", locp->first_line,
	   locp->first_column, locp->last_line, locp->last_column, msg);
}

static int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
{
  static char const input[] = "ab";
  static size_t toknum;
  if (! (toknum < sizeof input))
    abort ();
  lvalp->dummy = 0;
  llocp->first_line = llocp->last_line = 2;
  llocp->first_column = toknum + 1;
  llocp->last_column = llocp->first_column + 1;
  return input[toknum++];
}

int
main (void)
{
  return yyparse () != 1;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1715: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o glr-regr17.c glr-regr17.y"
echo glr-regression.at:1715 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr17.c glr-regr17.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o glr-regr17.c glr-regr17.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1715"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1715: bison --xml=xml-tests/test.xml -o glr-regr17.c glr-regr17.y"
echo glr-regression.at:1715 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o glr-regr17.c glr-regr17.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o glr-regr17.c glr-regr17.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1715"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1715: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:1715 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1715"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1715: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo glr-regression.at:1715 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1715"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1715: bison -o glr-regr17.c glr-regr17.y"
echo glr-regression.at:1715 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o glr-regr17.c glr-regr17.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o glr-regr17.c glr-regr17.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "glr-regr17.y: conflicts: 3 reduce/reduce
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1715"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1718: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o glr-regr17 glr-regr17.c \$LIBS"
echo glr-regression.at:1718 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr17 glr-regr17.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr17 glr-regr17.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o glr-regr17 glr-regr17.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1718"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1720:  \$PREPARSER ./glr-regr17"
echo glr-regression.at:1720 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./glr-regr17"; then
  ( $at_traceon;  $PREPARSER ./glr-regr17 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./glr-regr17 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "Error at 1.1-2.3: syntax is ambiguous.
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/glr-regression.at:1720"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_236
#AT_START_237
# 237. glr-regression.at:1731: Missed %merge type warnings when LHS type is declared later
at_setup_line='glr-regression.at:1731'
at_func_banner 21
at_desc="Missed %merge type warnings when LHS type is declared later"
$at_quiet $as_echo_n "237: $at_desc"
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "237. glr-regression.at:1731: testing ..."
  $at_traceon

cat >glr-regr18.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}

%glr-parser

%{
  #include <stdlib.h>
  static void yyerror (char const *);
  static int yylex ();
%}

%union {
  int type1;
  int type2;
  int type3;
}

%%

sym1: sym2 %merge<merge> { $$ = $1; } ;
sym2: sym3 %merge<merge> { $$ = $1; } ;
sym3: %merge<merge> { $$ = 0; } ;

%type <type1> sym1;
%type <type2> sym2;
%type <type3> sym3;

%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex ()
{
  static int called;
  if (called++)
    abort ();
  return 0;
}

int
main (void)
{
  return yyparse ();
}
_ATEOF




{ $at_traceoff
$as_echo "$at_srcdir/glr-regression.at:1781: VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o glr-regr18.c glr-regr18.y"
echo glr-regression.at:1781 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "VALGRIND_OPTS=\"$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison -o glr-regr18.c glr-regr18.y"; then
  ( $at_traceon; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o glr-regr18.c glr-regr18.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison -o glr-regr18.c glr-regr18.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "glr-regr18.y:26.18-24: result type clash on merge function \`merge': <type2> != <type1>
glr-regr18.y:25.18-24: previous declaration
glr-regr18.y:27.13-19: result type clash on merge function \`merge': <type3> != <type2>
glr-regr18.y:26.18-24: previous declaration
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/glr-regression.at:1781"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_237
#AT_START_238
# 238. push.at:23: Push Parsing: Memory Leak for Early Deletion
at_setup_line='push.at:23'
at_func_banner 22
at_desc="Push Parsing: Memory Leak for Early Deletion"
$at_quiet $as_echo_n "238: $at_desc   "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "238. push.at:23: testing ..."
  $at_traceon


# Requires Valgrind.

cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%{
  #include <assert.h>
  #include <stdio.h>
  #define YYINITDEPTH 1
  void yyerror (char const *msg);
%}

%define api.pure %define api.push_pull "push"

%%

start: 'a' 'b' 'c' ;

%%

void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  yypstate *ps;

  /* Make sure we don't try to free ps->yyss in this case.  */
  ps = yypstate_new ();
  yypstate_delete (ps);

  /* yypstate_delete used to leak ps->yyss if the stack was reallocated but the
     parse did not return on success, syntax error, or memory exhaustion.  */
  ps = yypstate_new ();
  assert (yypush_parse (ps, 'a', NULL) == YYPUSH_MORE);
  yypstate_delete (ps);

  ps = yypstate_new ();
  assert (yypush_parse (ps, 'a', NULL) == YYPUSH_MORE);
  assert (yypush_parse (ps, 'b', NULL) == YYPUSH_MORE);
  yypstate_delete (ps);

  return 0;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/push.at:74: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo push.at:74 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/push.at:74"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/push.at:74: bison --xml=xml-tests/test.xml -o input.c input.y"
echo push.at:74 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/push.at:74"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/push.at:74: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo push.at:74 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/push.at:74"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/push.at:74: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo push.at:74 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/push.at:74"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/push.at:74: bison -o input.c input.y"
echo push.at:74 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/push.at:74"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/push.at:75: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo push.at:75 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/push.at:75"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/push.at:76:  \$PREPARSER ./input"
echo push.at:76 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input"; then
  ( $at_traceon;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/push.at:76"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_238
#AT_START_239
# 239. push.at:84: Push Parsing: Multiple impure instances
at_setup_line='push.at:84'
at_func_banner 22
at_desc="Push Parsing: Multiple impure instances"
$at_quiet $as_echo_n "239: $at_desc        "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "239. push.at:84: testing ..."
  $at_traceon





cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%{
  #include <assert.h>
  #include <stdio.h>
  void yyerror (char const *msg);
  int yylex (void);
%}

%define api.push_pull "both"

%%

start: ;

%%

void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
yylex (void)
{
  return 0;
}

int
main (void)
{
  yypstate *ps;
  int i;

  for (i = 0; i < 2; ++i)
    {
      ps = yypstate_new ();
      assert (ps);
      assert (yypstate_new () == NULL);
      assert (yyparse () == 2);
      yychar = 0;
      assert (yypush_parse (ps) == 0);
      assert (yypstate_new () == NULL);
      assert (yyparse () == 2);
      yypstate_delete (ps);
    }

  return 0;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/push.at:144: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo push.at:144 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/push.at:144"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/push.at:144: bison --xml=xml-tests/test.xml -o input.c input.y"
echo push.at:144 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/push.at:144"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/push.at:144: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo push.at:144 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/push.at:144"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/push.at:144: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo push.at:144 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/push.at:144"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/push.at:144: bison -o input.c input.y"
echo push.at:144 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/push.at:144"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/push.at:144: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo push.at:144 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/push.at:144"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/push.at:144:  \$PREPARSER ./input"
echo push.at:144 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input"; then
  ( $at_traceon;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/push.at:144"

$at_failed && at_func_log_failure
$at_traceon; }



cat >input.y <<'_ATEOF'
%code top {
#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
}


%{
  #include <assert.h>
  #include <stdio.h>
  void yyerror (char const *msg);
  int yylex (void);
%}

%define api.push_pull "push"

%%

start: ;

%%

void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
yylex (void)
{
  return 0;
}

int
main (void)
{
  yypstate *ps;
  int i;

  for (i = 0; i < 2; ++i)
    {
      ps = yypstate_new ();
      assert (ps);
      assert (yypstate_new () == NULL);
      ;
      yychar = 0;
      assert (yypush_parse (ps) == 0);
      assert (yypstate_new () == NULL);
      ;
      yypstate_delete (ps);
    }

  return 0;
}
_ATEOF



if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/push.at:145: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot -o input.c input.y"
echo push.at:145 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/push.at:145"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/push.at:145: bison --xml=xml-tests/test.xml -o input.c input.y"
echo push.at:145 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/push.at:145"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/push.at:145: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo push.at:145 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/push.at:145"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/push.at:145: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo push.at:145 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/push.at:145"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/push.at:145: bison -o input.c input.y"
echo push.at:145 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison -o input.c input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/push.at:145"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/push.at:145: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS -o input input.c \$LIBS"
echo push.at:145 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "$CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS"; then
  ( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $CC $CFLAGS $CPPFLAGS $LDFLAGS -o input input.c $LIBS ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/push.at:145"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/push.at:145:  \$PREPARSER ./input"
echo push.at:145 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline " $PREPARSER ./input"; then
  ( $at_traceon;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :;  $PREPARSER ./input ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/push.at:145"

$at_failed && at_func_log_failure
$at_traceon; }





  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_239
#AT_START_240
# 240. push.at:155: Push Parsing: Unsupported Skeletons
at_setup_line='push.at:155'
at_func_banner 22
at_desc="Push Parsing: Unsupported Skeletons"
$at_quiet $as_echo_n "240: $at_desc            "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "240. push.at:155: testing ..."
  $at_traceon


cat >input.y <<'_ATEOF'
%glr-parser
%define api.push_pull "push"
%%
start: ;
_ATEOF


if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests
    # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  { $at_traceoff
$as_echo "$at_srcdir/push.at:164: bison --report=all --report-file=xml-tests/test.output \\
             --graph=xml-tests/test.dot input.y"
echo push.at:164 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/push.at:164"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/push.at:164: bison --xml=xml-tests/test.xml input.y"
echo push.at:164 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison --xml=xml-tests/test.xml input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_func_check_status 0 $at_status "$at_srcdir/push.at:164"

$at_failed && at_func_log_failure
$at_traceon; }

    cp xml-tests/test.output expout
  { $at_traceoff
$as_echo "$at_srcdir/push.at:164: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2text.xsl \\
             xml-tests/test.xml"
echo push.at:164 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/push.at:164"

$at_failed && at_func_log_failure
$at_traceon; }

  cp xml-tests/test.dot expout
  { $at_traceoff
$as_echo "$at_srcdir/push.at:164: \$XSLTPROC \\
             \`VALGRIND_OPTS=\"\$VALGRIND_OPTS --leak-check=summary --show-reachable=no\"; export VALGRIND_OPTS; bison --print-datadir\`/xslt/xml2dot.xsl \\
             xml-tests/test.xml"
echo push.at:164 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; $XSLTPROC \
             `VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/push.at:164"

$at_failed && at_func_log_failure
$at_traceon; }

  rm -rf xml-tests expout
fi
{ $at_traceoff
$as_echo "$at_srcdir/push.at:164: bison input.y"
echo push.at:164 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; bison input.y ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; bison input.y ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "input.y:2.9-21: warning: %define variable \`api.push_pull' is not used
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/push.at:164"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_240
