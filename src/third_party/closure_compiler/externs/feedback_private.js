// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file was generated by:
//   tools/json_schema_compiler/compiler.py.
// NOTE: The format of types has changed. 'FooType' is now
//   'chrome.feedbackPrivate.FooType'.
// Please run the closure compiler before committing changes.
// See https://chromium.googlesource.com/chromium/src/+/main/docs/closure_compilation.md

/** @fileoverview Externs generated from namespace: feedbackPrivate */

/** @const */
chrome.feedbackPrivate = {};

/**
 * @typedef {{
 *   name: string,
 *   data: (Blob|undefined)
 * }}
 */
chrome.feedbackPrivate.AttachedFile;

/**
 * @typedef {{
 *   key: string,
 *   value: string
 * }}
 */
chrome.feedbackPrivate.SystemInformation;

/**
 * @enum {string}
 */
chrome.feedbackPrivate.FeedbackFlow = {
  REGULAR: 'regular',
  LOGIN: 'login',
  SAD_TAB_CRASH: 'sadTabCrash',
  GOOGLE_INTERNAL: 'googleInternal',
};

/**
 * @typedef {{
 *   attachedFile: (!chrome.feedbackPrivate.AttachedFile|undefined),
 *   categoryTag: (string|undefined),
 *   description: string,
 *   descriptionPlaceholder: (string|undefined),
 *   email: (string|undefined),
 *   pageUrl: (string|undefined),
 *   productId: (number|undefined),
 *   screenshot: (Blob|undefined),
 *   traceId: (number|undefined),
 *   systemInformation: (!Array<!chrome.feedbackPrivate.SystemInformation>|undefined),
 *   sendHistograms: (boolean|undefined),
 *   flow: (!chrome.feedbackPrivate.FeedbackFlow|undefined),
 *   attachedFileBlobUuid: (string|undefined),
 *   screenshotBlobUuid: (string|undefined),
 *   useSystemWindowFrame: (boolean|undefined),
 *   sendBluetoothLogs: (boolean|undefined),
 *   sendTabTitles: (boolean|undefined),
 *   assistantDebugInfoAllowed: (boolean|undefined),
 *   fromAssistant: (boolean|undefined),
 *   includeBluetoothLogs: (boolean|undefined),
 *   showQuestionnaire: (boolean|undefined)
 * }}
 */
chrome.feedbackPrivate.FeedbackInfo;

/**
 * @enum {string}
 */
chrome.feedbackPrivate.Status = {
  SUCCESS: 'success',
  DELAYED: 'delayed',
};

/**
 * @enum {string}
 */
chrome.feedbackPrivate.LandingPageType = {
  NORMAL: 'normal',
  TECHSTOP: 'techstop',
  NO_LANDING_PAGE: 'noLandingPage',
};

/**
 * @enum {string}
 */
chrome.feedbackPrivate.LogSource = {
  MESSAGES: 'messages',
  UI_LATEST: 'uiLatest',
  DRM_MODETEST: 'drmModetest',
  LSUSB: 'lsusb',
  ATRUS_LOG: 'atrusLog',
  NET_LOG: 'netLog',
  EVENT_LOG: 'eventLog',
  UPDATE_ENGINE_LOG: 'updateEngineLog',
  POWERD_LATEST: 'powerdLatest',
  POWERD_PREVIOUS: 'powerdPrevious',
  LSPCI: 'lspci',
  IFCONFIG: 'ifconfig',
  UPTIME: 'uptime',
};

/**
 * @typedef {{
 *   source: !chrome.feedbackPrivate.LogSource,
 *   incremental: boolean,
 *   readerId: (number|undefined)
 * }}
 */
chrome.feedbackPrivate.ReadLogSourceParams;

/**
 * @typedef {{
 *   readerId: number,
 *   logLines: !Array<string>
 * }}
 */
chrome.feedbackPrivate.ReadLogSourceResult;

/**
 * Returns the email of the currently active or logged in user.
 * @param {function(string): void} callback
 */
chrome.feedbackPrivate.getUserEmail = function(callback) {};

/**
 * Returns the system information dictionary.
 * @param {function(!Array<!chrome.feedbackPrivate.SystemInformation>): void}
 *     callback
 */
chrome.feedbackPrivate.getSystemInformation = function(callback) {};

/**
 * Sends a feedback report.
 * @param {!chrome.feedbackPrivate.FeedbackInfo} feedback
 * @param {?boolean|undefined} loadSystemInfo Optional flag when present and is
 *     true, the backend should load system information before sending the
 *     report. This is added to reduce user's wait time when sending reports
 *     because loading system information is slow.
 * @param {?number|undefined} formOpenTime The epoch time when the feedback form
 *     was opened. This is used for metrics.
 * @param {function(!chrome.feedbackPrivate.Status, !chrome.feedbackPrivate.LandingPageType): void}
 *     callback
 */
chrome.feedbackPrivate.sendFeedback = function(feedback, loadSystemInfo, formOpenTime, callback) {};

/**
 * Gets localized translated strings for feedback. It returns the strings as a
 * dictionary mapping from string identifier to the translated string to use in
 * the feedback app UI.
 * @param {!chrome.feedbackPrivate.FeedbackFlow} flow
 * @param {function(Object): void} callback
 */
chrome.feedbackPrivate.getStrings = function(flow, callback) {};

/**
 * Reads from a log source indicated by <code>source</code>. <p>If
 * <code>incremental</code> is false: <ul>   <li>Returns the entire contents of
 * the log file.</li>   <li>Returns <code>readerId</code> value of 0 to
 * callback.</li> </ul> If <code>incremental</code> is true, and no
 * <code>readerId</code> is provided: <ul>   <li>Returns the entire contents of
 * the log file.</li>   <li>Starts tracking the file read handle, which is
 * returned as a       nonzero <code>readerId</code> value in the callback.
 * </li>   <li>If can't create a new file handle, returns <code>readerId</code>
 * value of 0 in the callback.       </li> </ul> If <code>incremental</code> is
 * true, and a valid non-zero <code>readerId</code> is provided: <ul>
 * <li>Returns new lines written to the file since the last time this
 * function was called for the same file and <code>readerId</code>.       </li>
 * <li>Returns the same <code>readerId</code> value to the callback.</li> </ul>
 * @param {!chrome.feedbackPrivate.ReadLogSourceParams} params
 * @param {function(!chrome.feedbackPrivate.ReadLogSourceResult): void} callback
 */
chrome.feedbackPrivate.readLogSource = function(params, callback) {};

/**
 * Invoked when the extension is complete during sending feedback from the login
 * page. This is then used to know we can unload the feedback extension from the
 * login profile.
 */
chrome.feedbackPrivate.loginFeedbackComplete = function() {};

/**
 * Fired when the a user requests the launch of the feedback UI. We're using an
 * event for this versus using the override API since we want to be invoked, but
 * not showing a UI, so the feedback extension can take a screenshot of the
 * user's desktop.
 * @type {!ChromeEvent}
 */
chrome.feedbackPrivate.onFeedbackRequested;
