// RUN: hlo_to_llvm_ir %s | FileCheck %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// The script is designed to make adding checks to
// a test case fast, it is *not* designed to be authoritative
// about what constitutes a good test! The CHECK should be
// minimized and named to reflect the test intent.


// CHECK-LABEL: entry:
// CHECK:         %[[VAL_0:.*]] = alloca i32, align 4
// CHECK:         %[[VAL_1:.*]] = alloca i32, align 4
// CHECK:         %[[VAL_2:.*]] = alloca i32, align 4
// CHECK:         %[[VAL_3:.*]] = alloca i32, align 4
// CHECK:         %[[VAL_4:.*]] = getelementptr inbounds i8, i8* %[[VAL_5:.*]], i64 0
// CHECK:         %[[VAL_6:.*]] = bitcast i8* %[[VAL_4]] to [100 x [200 x float]]*
// CHECK:         %[[VAL_7:.*]] = getelementptr inbounds i8, i8* %[[VAL_8:.*]], i64 0
// CHECK:         %[[VAL_9:.*]] = bitcast i8* %[[VAL_7]] to [200 x [100 x float]]*
// CHECK:         %[[VAL_10:.*]] = bitcast [100 x [200 x float]]* %[[VAL_6]] to [1 x [100 x [200 x float]]]*
// CHECK:         %[[VAL_11:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !2
// CHECK:         %[[VAL_12:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !3
// CHECK:         %[[VAL_13:.*]] = urem i32 %[[VAL_11]], 128
// CHECK:         %[[VAL_14:.*]] = udiv i32 %[[VAL_11]], 128
// CHECK:         %[[VAL_15:.*]] = mul i32 %[[VAL_12]], 1
// CHECK:         %[[VAL_16:.*]] = add i32 %[[VAL_15]], %[[VAL_14]]
// CHECK:         %[[VAL_17:.*]] = icmp ult i32 %[[VAL_16]], 28
// CHECK:         br i1 %[[VAL_17]], label %[[VAL_18:.*]], label %[[VAL_19:.*]]
// CHECK:       12:                                               ; preds = %[[VAL_20:.*]]
// CHECK:         %[[VAL_21:.*]] = urem i32 %[[VAL_13]], 32
// CHECK:         %[[VAL_22:.*]] = udiv i32 %[[VAL_13]], 32
// CHECK:         %[[VAL_23:.*]] = urem i32 %[[VAL_13]], 32
// CHECK:         %[[VAL_24:.*]] = udiv i32 %[[VAL_16]], 1
// CHECK:         %[[VAL_25:.*]] = urem i32 %[[VAL_24]], 4
// CHECK:         %[[VAL_26:.*]] = udiv i32 %[[VAL_16]], 4
// CHECK:         %[[VAL_27:.*]] = urem i32 %[[VAL_26]], 7
// CHECK:         %[[VAL_28:.*]] = udiv i32 %[[VAL_16]], 28
// CHECK:         %[[VAL_29:.*]] = mul i32 %[[VAL_28]], 1
// CHECK:         %[[VAL_30:.*]] = icmp eq i32 %[[VAL_27]], 6
// CHECK:         %[[VAL_31:.*]] = select i1 %[[VAL_30]], i32 8, i32 32
// CHECK:         %[[VAL_32:.*]] = icmp eq i32 %[[VAL_25]], 3
// CHECK:         %[[VAL_33:.*]] = select i1 %[[VAL_32]], i32 4, i32 32
// CHECK:         %[[VAL_34:.*]] = mul i32 %[[VAL_27]], 32
// CHECK:         %[[VAL_35:.*]] = mul i32 %[[VAL_25]], 32
// CHECK:         %[[VAL_36:.*]] = mul i32 %[[VAL_21]], 1
// CHECK:         %[[VAL_37:.*]] = add i32 %[[VAL_34]], %[[VAL_36]]
// CHECK:         store i32 %[[VAL_22]], i32* %[[VAL_3]], align 4
// CHECK:         br label %[[VAL_38:.*]]
// CHECK:       y_in_tile.loop_header:                            ; preds = %[[VAL_39:.*]], %[[VAL_18]]
// CHECK:         %[[VAL_40:.*]] = load i32, i32* %[[VAL_3]], align 4
// CHECK:         %[[VAL_41:.*]] = icmp uge i32 %[[VAL_40]], %[[VAL_33]]
// CHECK:         br i1 %[[VAL_41]], label %[[VAL_42:.*]], label %[[VAL_43:.*]]
// CHECK:       y_in_tile.loop_body:                              ; preds = %[[VAL_38]]
// CHECK:         %[[VAL_44:.*]] = add nuw nsw i32 %[[VAL_40]], 4
// CHECK:         store i32 %[[VAL_44]], i32* %[[VAL_3]], align 4
// CHECK:         %[[VAL_45:.*]] = icmp eq i32 %[[VAL_40]], %[[VAL_22]]
// CHECK:         %[[VAL_46:.*]] = add i32 %[[VAL_35]], %[[VAL_40]]
// CHECK:         store i32 0, i32* %[[VAL_2]], align 4
// CHECK:         br label %[[VAL_47:.*]]
// CHECK:       tile_loop.loop_header:                            ; preds = %[[VAL_48:.*]], %[[VAL_43]]
// CHECK:         %[[VAL_49:.*]] = load i32, i32* %[[VAL_2]], align 4
// CHECK:         %[[VAL_50:.*]] = icmp uge i32 %[[VAL_49]], 1
// CHECK:         br i1 %[[VAL_50]], label %[[VAL_39]], label %[[VAL_51:.*]]
// CHECK:       tile_loop.loop_body:                              ; preds = %[[VAL_47]]
// CHECK:         %[[VAL_52:.*]] = add nuw nsw i32 %[[VAL_49]], 1
// CHECK:         store i32 %[[VAL_52]], i32* %[[VAL_2]], align 4
// CHECK:         %[[VAL_53:.*]] = icmp eq i32 %[[VAL_49]], 0
// CHECK:         %[[VAL_54:.*]] = mul i32 %[[VAL_49]], 1
// CHECK:         %[[VAL_55:.*]] = add i32 %[[VAL_54]], 0
// CHECK:         %[[VAL_56:.*]] = mul i32 %[[VAL_49]], 1
// CHECK:         %[[VAL_57:.*]] = add i32 %[[VAL_56]], 0
// CHECK:         %[[VAL_58:.*]] = add i32 %[[VAL_57]], %[[VAL_36]]
// CHECK:         %[[VAL_59:.*]] = mul i32 %[[VAL_49]], 1
// CHECK:         %[[VAL_60:.*]] = add i32 %[[VAL_59]], 0
// CHECK:         %[[VAL_61:.*]] = add i32 %[[VAL_37]], %[[VAL_60]]
// CHECK:         %[[VAL_62:.*]] = icmp ult i32 %[[VAL_58]], %[[VAL_31]]
// CHECK:         br i1 %[[VAL_62]], label %[[VAL_63:.*]], label %[[VAL_48]]
// CHECK:       x_in_tile-after:                                  ; preds = %[[VAL_63]], %[[VAL_51]]
// CHECK:         br label %[[VAL_47]], !llvm.loop !4
// CHECK:       tile_loop.loop_exit:                              ; preds = %[[VAL_47]]
// CHECK:         br label %[[VAL_38]], !llvm.loop !7
// CHECK:       y_in_tile.loop_exit:                              ; preds = %[[VAL_38]]
// CHECK:         call void @llvm.nvvm.barrier0()
// CHECK:         %[[VAL_64:.*]] = mul i32 %[[VAL_21]], 1
// CHECK:         %[[VAL_65:.*]] = add i32 %[[VAL_35]], %[[VAL_64]]
// CHECK:         store i32 %[[VAL_22]], i32* %[[VAL_1]], align 4
// CHECK:         br label %[[VAL_66:.*]]
// CHECK:       y_in_tile.loop_header5:                           ; preds = %[[VAL_67:.*]], %[[VAL_42]]
// CHECK:         %[[VAL_68:.*]] = load i32, i32* %[[VAL_1]], align 4
// CHECK:         %[[VAL_69:.*]] = icmp uge i32 %[[VAL_68]], %[[VAL_31]]
// CHECK:         br i1 %[[VAL_69]], label %[[VAL_70:.*]], label %[[VAL_71:.*]]
// CHECK:       y_in_tile.loop_body6:                             ; preds = %[[VAL_66]]
// CHECK:         %[[VAL_72:.*]] = add nuw nsw i32 %[[VAL_68]], 4
// CHECK:         store i32 %[[VAL_72]], i32* %[[VAL_1]], align 4
// CHECK:         %[[VAL_73:.*]] = icmp eq i32 %[[VAL_68]], %[[VAL_22]]
// CHECK:         %[[VAL_74:.*]] = add i32 %[[VAL_34]], %[[VAL_68]]
// CHECK:         store i32 0, i32* %[[VAL_0]], align 4
// CHECK:         br label %[[VAL_75:.*]]
// CHECK:       tile_loop.loop_header11:                          ; preds = %[[VAL_76:.*]], %[[VAL_71]]
// CHECK:         %[[VAL_77:.*]] = load i32, i32* %[[VAL_0]], align 4
// CHECK:         %[[VAL_78:.*]] = icmp uge i32 %[[VAL_77]], 1
// CHECK:         br i1 %[[VAL_78]], label %[[VAL_67]], label %[[VAL_79:.*]]
// CHECK:       tile_loop.loop_body12:                            ; preds = %[[VAL_75]]
// CHECK:         %[[VAL_80:.*]] = add nuw nsw i32 %[[VAL_77]], 1
// CHECK:         store i32 %[[VAL_80]], i32* %[[VAL_0]], align 4
// CHECK:         %[[VAL_81:.*]] = icmp eq i32 %[[VAL_77]], 0
// CHECK:         %[[VAL_82:.*]] = mul i32 %[[VAL_77]], 1
// CHECK:         %[[VAL_83:.*]] = add i32 %[[VAL_82]], 0
// CHECK:         %[[VAL_84:.*]] = mul i32 %[[VAL_77]], 1
// CHECK:         %[[VAL_85:.*]] = add i32 %[[VAL_84]], 0
// CHECK:         %[[VAL_86:.*]] = add i32 %[[VAL_85]], %[[VAL_64]]
// CHECK:         %[[VAL_87:.*]] = mul i32 %[[VAL_77]], 1
// CHECK:         %[[VAL_88:.*]] = add i32 %[[VAL_87]], 0
// CHECK:         %[[VAL_89:.*]] = add i32 %[[VAL_65]], %[[VAL_88]]
// CHECK:         %[[VAL_90:.*]] = icmp ult i32 %[[VAL_86]], %[[VAL_33]]
// CHECK:         br i1 %[[VAL_90]], label %[[VAL_91:.*]], label %[[VAL_76]]
// CHECK:       x_in_tile-after18:                                ; preds = %[[VAL_91]], %[[VAL_79]]
// CHECK:         br label %[[VAL_75]], !llvm.loop !8
// CHECK:       tile_loop.loop_exit10:                            ; preds = %[[VAL_75]]
// CHECK:         br label %[[VAL_66]], !llvm.loop !9
// CHECK:       y_in_tile.loop_exit4:                             ; preds = %[[VAL_66]]
// CHECK:         ret void
// CHECK:       early_return:                                     ; preds = %[[VAL_20]]
// CHECK:         ret void
// CHECK:       x_in_tile-true:                                   ; preds = %[[VAL_51]]
// CHECK:         %[[VAL_92:.*]] = getelementptr inbounds [1 x [100 x [200 x float]]], [1 x [100 x [200 x float]]]* %[[VAL_10]], i32 0, i32 0, i32 %[[VAL_46]], i32 %[[VAL_61]]
// CHECK:         %[[VAL_93:.*]] = load float, float* %[[VAL_92]], align 4, !invariant.load !10
// CHECK:         %[[VAL_94:.*]] = getelementptr inbounds [1 x [32 x [33 x float]]], [1 x [32 x [33 x float]]] addrspace(3)* @b.tile0, i32 0, i32 %[[VAL_14]], i32 %[[VAL_40]], i32 %[[VAL_58]]
// CHECK:         %[[VAL_95:.*]] = addrspacecast float addrspace(3)* %[[VAL_94]] to float*
// CHECK:         store float %[[VAL_93]], float* %[[VAL_95]], align 4
// CHECK:         br label %[[VAL_48]]
// CHECK:       x_in_tile-true17:                                 ; preds = %[[VAL_79]]
// CHECK:         %[[VAL_96:.*]] = getelementptr inbounds [1 x [32 x [33 x float]]], [1 x [32 x [33 x float]]] addrspace(3)* @b.tile0, i32 0, i32 %[[VAL_14]], i32 %[[VAL_86]], i32 %[[VAL_68]]
// CHECK:         %[[VAL_97:.*]] = addrspacecast float addrspace(3)* %[[VAL_96]] to float*
// CHECK:         %[[VAL_98:.*]] = load float, float* %[[VAL_97]], align 4
// CHECK:         %[[VAL_99:.*]] = getelementptr inbounds [200 x [100 x float]], [200 x [100 x float]]* %[[VAL_9]], i32 0, i32 %[[VAL_74]], i32 %[[VAL_89]]
// CHECK:         store float %[[VAL_98]], float* %[[VAL_99]], align 4
// CHECK:         br label %[[VAL_76]]

HloModule Test

ENTRY main {
  a = f32[100, 200]{1,0} parameter(0)
  ROOT b = f32[100, 200]{0,1} copy(a)
}
