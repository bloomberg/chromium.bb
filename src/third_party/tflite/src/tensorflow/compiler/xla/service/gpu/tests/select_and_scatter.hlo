// RUN: hlo_to_llvm_ir %s | FileCheck %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// CHECK-LABEL: entry:
// CHECK:         %[[VAL_0:.*]] = alloca i8, align 1
// CHECK:         %[[VAL_1:.*]] = alloca i32, align 4
// CHECK:         %[[VAL_2:.*]] = alloca i1, align 1
// CHECK:         %[[VAL_3:.*]] = alloca i32, align 4
// CHECK:         %[[VAL_4:.*]] = alloca float, align 4
// CHECK:         %[[VAL_5:.*]] = getelementptr inbounds i8, i8* %[[VAL_6:.*]], i64 0
// CHECK:         %[[VAL_7:.*]] = bitcast i8* %[[VAL_5]] to [6 x float]*
// CHECK:         %[[VAL_8:.*]] = getelementptr inbounds i8, i8* %[[VAL_9:.*]], i64 0
// CHECK:         %[[VAL_10:.*]] = bitcast i8* %[[VAL_8]] to [2 x float]*
// CHECK:         %[[VAL_11:.*]] = getelementptr inbounds i8, i8* %[[VAL_12:.*]], i64 0
// CHECK:         %[[VAL_13:.*]] = bitcast i8* %[[VAL_11]] to [6 x float]*
// CHECK:         %[[VAL_14:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !2
// CHECK:         %[[VAL_15:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !3
// CHECK:         %[[VAL_16:.*]] = mul nuw nsw i32 %[[VAL_14]], 2
// CHECK:         %[[VAL_17:.*]] = add nuw nsw i32 %[[VAL_16]], %[[VAL_15]]
// CHECK:         %[[VAL_18:.*]] = icmp ult i32 %[[VAL_17]], 2
// CHECK:         call void @llvm.assume(i1 %[[VAL_18]])
// CHECK:         %[[VAL_19:.*]] = udiv i32 %[[VAL_17]], 1
// CHECK:         %[[VAL_20:.*]] = icmp ult i32 %[[VAL_17]], 2
// CHECK:         br i1 %[[VAL_20]], label %[[VAL_21:.*]], label %[[VAL_22:.*]]
// CHECK:       select-and-scatter.12.in_bounds-after:            ; preds = %[[VAL_23:.*]], %[[VAL_24:.*]]
// CHECK:         ret void
// CHECK:       select-and-scatter.12.in_bounds-true:             ; preds = %[[VAL_24]]
// CHECK:         store i1 false, i1* %[[VAL_2]], align 1
// CHECK:         store i32 0, i32* %[[VAL_1]], align 4
// CHECK:         br label %[[VAL_25:.*]]
// CHECK:       select-and-scatter.12inner.loop_header.window.0:  ; preds = %[[VAL_26:.*]], %[[VAL_21]]
// CHECK:         %[[VAL_27:.*]] = load i32, i32* %[[VAL_1]], align 4
// CHECK:         %[[VAL_28:.*]] = icmp uge i32 %[[VAL_27]], 3
// CHECK:         br i1 %[[VAL_28]], label %[[VAL_23]], label %[[VAL_29:.*]]
// CHECK:       select-and-scatter.12inner.loop_body.window.0:    ; preds = %[[VAL_25]]
// CHECK:         %[[VAL_30:.*]] = mul nsw i32 %[[VAL_19]], 3
// CHECK:         %[[VAL_31:.*]] = add nsw i32 %[[VAL_30]], %[[VAL_27]]
// CHECK:         %[[VAL_32:.*]] = sub nsw i32 %[[VAL_31]], 0
// CHECK:         %[[VAL_33:.*]] = icmp ult i32 %[[VAL_32]], 6
// CHECK:         %[[VAL_34:.*]] = and i1 true, %[[VAL_33]]
// CHECK:         br i1 %[[VAL_34]], label %[[VAL_35:.*]], label %[[VAL_36:.*]]
// CHECK:       in-bounds-after:                                  ; preds = %[[VAL_36]], %[[VAL_37:.*]]
// CHECK:         %[[VAL_38:.*]] = add nuw nsw i32 %[[VAL_27]], 1
// CHECK:         store i32 %[[VAL_38]], i32* %[[VAL_1]], align 4
// CHECK:         br label %[[VAL_25]]
// CHECK:       select-and-scatter.12inner.loop_exit.window.0:    ; preds = %[[VAL_25]]
// CHECK:         %[[VAL_39:.*]] = getelementptr inbounds i32, i32* %[[VAL_3]], i32 0
// CHECK:         %[[VAL_40:.*]] = load i32, i32* %[[VAL_39]], align 4
// CHECK:         %[[VAL_41:.*]] = bitcast [2 x float]* %[[VAL_10]] to float*
// CHECK:         %[[VAL_42:.*]] = getelementptr inbounds float, float* %[[VAL_41]], i32 %[[VAL_17]]
// CHECK:         %[[VAL_43:.*]] = getelementptr inbounds [6 x float], [6 x float]* %[[VAL_13]], i32 0, i32 %[[VAL_40]]
// CHECK:         %[[VAL_44:.*]] = load float, float* %[[VAL_42]], align 4
// CHECK:         %[[VAL_45:.*]] = atomicrmw fadd float* %[[VAL_43]], float %[[VAL_44]] seq_cst
// CHECK:         br label %[[VAL_22]]
// CHECK:       in-bounds-true:                                   ; preds = %[[VAL_29]]
// CHECK:         %[[VAL_46:.*]] = load i1, i1* %[[VAL_2]], align 1
// CHECK:         br i1 %[[VAL_46]], label %[[VAL_47:.*]], label %[[VAL_48:.*]]
// CHECK:       initialized-after:                                ; preds = %[[VAL_48]], %[[VAL_49:.*]]
// CHECK:         br label %[[VAL_26]]
// CHECK:       in-bounds-false:                                  ; preds = %[[VAL_29]]
// CHECK:         br label %[[VAL_26]]
// CHECK:       initialized-true:                                 ; preds = %[[VAL_35]]
// CHECK:         %[[VAL_50:.*]] = getelementptr inbounds [6 x float], [6 x float]* %[[VAL_7]], i32 0, i32 %[[VAL_32]]
// CHECK:         call void @region_0_4(float* %[[VAL_4]], float* %[[VAL_50]], i8* %[[VAL_0]])
// CHECK:         %[[VAL_51:.*]] = load i8, i8* %[[VAL_0]], align 1
// CHECK:         %[[VAL_52:.*]] = icmp ne i8 %[[VAL_51]], 0
// CHECK:         br i1 %[[VAL_52]], label %[[VAL_53:.*]], label %[[VAL_54:.*]]
// CHECK:       if-select-lhs-after:                              ; preds = %[[VAL_54]], %[[VAL_53]]
// CHECK:         br label %[[VAL_37]]
// CHECK:       initialized-false:                                ; preds = %[[VAL_35]]
// CHECK:         %[[VAL_55:.*]] = getelementptr inbounds [6 x float], [6 x float]* %[[VAL_7]], i32 0, i32 %[[VAL_32]]
// CHECK:         %[[VAL_56:.*]] = load float, float* %[[VAL_55]], align 4, !invariant.load !4
// CHECK:         store float %[[VAL_56]], float* %[[VAL_4]], align 4
// CHECK:         %[[VAL_57:.*]] = getelementptr inbounds i32, i32* %[[VAL_3]], i32 0
// CHECK:         store i32 %[[VAL_32]], i32* %[[VAL_57]], align 4
// CHECK:         store i1 true, i1* %[[VAL_2]], align 1
// CHECK:         br label %[[VAL_37]]
// CHECK:       if-select-lhs-true:                               ; preds = %[[VAL_47]]
// CHECK:         br label %[[VAL_49]]
// CHECK:       if-select-lhs-false:                              ; preds = %[[VAL_47]]
// CHECK:         %[[VAL_58:.*]] = load float, float* %[[VAL_50]], align 4
// CHECK:         store float %[[VAL_58]], float* %[[VAL_4]], align 4
// CHECK:         %[[VAL_59:.*]] = getelementptr inbounds i32, i32* %[[VAL_3]], i32 0
// CHECK:         store i32 %[[VAL_32]], i32* %[[VAL_59]], align 4
// CHECK:         br label %[[VAL_49]]
// CHECK:       entry:
// CHECK:         %[[VAL_60:.*]] = alloca i8, align 1
// CHECK:         %[[VAL_61:.*]] = load float, float* %[[VAL_62:.*]], align 4
// CHECK:         %[[VAL_63:.*]] = load float, float* %[[VAL_64:.*]], align 4
// CHECK:         %[[VAL_65:.*]] = fcmp oge float %[[VAL_61]], %[[VAL_63]]
// CHECK:         %[[VAL_66:.*]] = zext i1 %[[VAL_65]] to i8
// CHECK:         store i8 %[[VAL_66]], i8* %[[VAL_60]], align 1
// CHECK:         %[[VAL_67:.*]] = load i8, i8* %[[VAL_60]], align 1
// CHECK:         store i8 %[[VAL_67]], i8* %[[VAL_68:.*]], align 1
// CHECK:         ret void

HloModule SelectAndScatter

%ge_F32 (lhs.5: f32[], rhs.6: f32[]) -> pred[] {
  %lhs.5 = f32[] parameter(0)
  %rhs.6 = f32[] parameter(1)
  ROOT %compare.7 = pred[] compare(f32[] %lhs.5, f32[] %rhs.6), direction=GE
}

%add_F32 (lhs.9: f32[], rhs.10: f32[]) -> f32[] {
  %lhs.9 = f32[] parameter(0)
  %rhs.10 = f32[] parameter(1)
  ROOT %add.11 = f32[] add(f32[] %lhs.9, f32[] %rhs.10)
}

ENTRY main () -> f32[6] {
  %operand = f32[6]{0} parameter(0)
  %source = f32[2]{0} parameter(1)
  %init = f32[] constant(0)
  ROOT %select-and-scatter.12 = f32[6]{0} select-and-scatter(f32[6]{0} %operand, f32[2]{0} %source, f32[] %init), window={size=3 stride=3}, select=%ge_F32, scatter=%add_F32
}