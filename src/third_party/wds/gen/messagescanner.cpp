#line 10 "messagelexer.l"
/*
 * This file is part of Wireless Display Software for Linux OS
 *
 * Copyright (C) 2015 Intel Corporation.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */

#include <stdint.h>

#define YY_NO_UNISTD_H 1



#define  YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 4
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

#ifdef yy_create_buffer
#define message__create_buffer_ALREADY_DEFINED
#else
#define yy_create_buffer message__create_buffer
#endif

#ifdef yy_delete_buffer
#define message__delete_buffer_ALREADY_DEFINED
#else
#define yy_delete_buffer message__delete_buffer
#endif

#ifdef yy_scan_buffer
#define message__scan_buffer_ALREADY_DEFINED
#else
#define yy_scan_buffer message__scan_buffer
#endif

#ifdef yy_scan_string
#define message__scan_string_ALREADY_DEFINED
#else
#define yy_scan_string message__scan_string
#endif

#ifdef yy_scan_bytes
#define message__scan_bytes_ALREADY_DEFINED
#else
#define yy_scan_bytes message__scan_bytes
#endif

#ifdef yy_init_buffer
#define message__init_buffer_ALREADY_DEFINED
#else
#define yy_init_buffer message__init_buffer
#endif

#ifdef yy_flush_buffer
#define message__flush_buffer_ALREADY_DEFINED
#else
#define yy_flush_buffer message__flush_buffer
#endif

#ifdef yy_load_buffer_state
#define message__load_buffer_state_ALREADY_DEFINED
#else
#define yy_load_buffer_state message__load_buffer_state
#endif

#ifdef yy_switch_to_buffer
#define message__switch_to_buffer_ALREADY_DEFINED
#else
#define yy_switch_to_buffer message__switch_to_buffer
#endif

#ifdef yypush_buffer_state
#define message_push_buffer_state_ALREADY_DEFINED
#else
#define yypush_buffer_state message_push_buffer_state
#endif

#ifdef yypop_buffer_state
#define message_pop_buffer_state_ALREADY_DEFINED
#else
#define yypop_buffer_state message_pop_buffer_state
#endif

#ifdef yyensure_buffer_stack
#define message_ensure_buffer_stack_ALREADY_DEFINED
#else
#define yyensure_buffer_stack message_ensure_buffer_stack
#endif

#ifdef yylex
#define message_lex_ALREADY_DEFINED
#else
#define yylex message_lex
#endif

#ifdef yyrestart
#define message_restart_ALREADY_DEFINED
#else
#define yyrestart message_restart
#endif

#ifdef yylex_init
#define message_lex_init_ALREADY_DEFINED
#else
#define yylex_init message_lex_init
#endif

#ifdef yylex_init_extra
#define message_lex_init_extra_ALREADY_DEFINED
#else
#define yylex_init_extra message_lex_init_extra
#endif

#ifdef yylex_destroy
#define message_lex_destroy_ALREADY_DEFINED
#else
#define yylex_destroy message_lex_destroy
#endif

#ifdef yyget_debug
#define message_get_debug_ALREADY_DEFINED
#else
#define yyget_debug message_get_debug
#endif

#ifdef yyset_debug
#define message_set_debug_ALREADY_DEFINED
#else
#define yyset_debug message_set_debug
#endif

#ifdef yyget_extra
#define message_get_extra_ALREADY_DEFINED
#else
#define yyget_extra message_get_extra
#endif

#ifdef yyset_extra
#define message_set_extra_ALREADY_DEFINED
#else
#define yyset_extra message_set_extra
#endif

#ifdef yyget_in
#define message_get_in_ALREADY_DEFINED
#else
#define yyget_in message_get_in
#endif

#ifdef yyset_in
#define message_set_in_ALREADY_DEFINED
#else
#define yyset_in message_set_in
#endif

#ifdef yyget_out
#define message_get_out_ALREADY_DEFINED
#else
#define yyget_out message_get_out
#endif

#ifdef yyset_out
#define message_set_out_ALREADY_DEFINED
#else
#define yyset_out message_set_out
#endif

#ifdef yyget_leng
#define message_get_leng_ALREADY_DEFINED
#else
#define yyget_leng message_get_leng
#endif

#ifdef yyget_text
#define message_get_text_ALREADY_DEFINED
#else
#define yyget_text message_get_text
#endif

#ifdef yyget_lineno
#define message_get_lineno_ALREADY_DEFINED
#else
#define yyget_lineno message_get_lineno
#endif

#ifdef yyset_lineno
#define message_set_lineno_ALREADY_DEFINED
#else
#define yyset_lineno message_set_lineno
#endif

#ifdef yyget_column
#define message_get_column_ALREADY_DEFINED
#else
#define yyget_column message_get_column
#endif

#ifdef yyset_column
#define message_set_column_ALREADY_DEFINED
#else
#define yyset_column message_set_column
#endif

#ifdef yywrap
#define message_wrap_ALREADY_DEFINED
#else
#define yywrap message_wrap
#endif

#ifdef yyget_lval
#define message_get_lval_ALREADY_DEFINED
#else
#define yyget_lval message_get_lval
#endif

#ifdef yyset_lval
#define message_set_lval_ALREADY_DEFINED
#else
#define yyset_lval message_set_lval
#endif

#ifdef yyalloc
#define message_alloc_ALREADY_DEFINED
#else
#define yyalloc message_alloc
#endif

#ifdef yyrealloc
#define message_realloc_ALREADY_DEFINED
#else
#define yyrealloc message_realloc
#endif

#ifdef yyfree
#define message_free_ALREADY_DEFINED
#else
#define yyfree message_free
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types. 
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t; 
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN               (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN              (-32767-1)
#endif
#ifndef INT32_MIN
#define INT32_MIN              (-2147483647-1)
#endif
#ifndef INT8_MAX
#define INT8_MAX               (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX              (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX              (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX              (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX             (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX             (4294967295U)
#endif

#ifndef SIZE_MAX
#define SIZE_MAX (~(size_t)0)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

/* begin standard C++ headers. */

/* TODO: this is always defined, so inline it */
#define yyconst const

#if defined(__GNUC__) && __GNUC__ >= 3
#define yynoreturn __attribute__((__noreturn__))
#else
#define yynoreturn
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an
 *   integer in range [0..255] for use as an array index.
 */
#define YY_SC_TO_UI(c) ((YY_CHAR)(c))

/* An opaque pointer. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

/* For convenience, these vars (plus the bison vars far below)
   are macros in the reentrant scanner. */
#define yyin yyg->yyin_r
#define yyout yyg->yyout_r
#define yyextra yyg->yyextra_r
#define yyleng yyg->yyleng_r
#define yytext yyg->yytext_r
#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)
#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)
#define yy_flex_debug yyg->yy_flex_debug_r

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN yyg->yy_start = 1 + 2 *
/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((yyg->yy_start - 1) / 2)
#define YYSTATE YY_START
/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart(yyin, yyscanner)
#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 16384
#endif /* __ia64__ */
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

#define YY_LESS_LINENO(n)
#define YY_LINENO_REWIND_TO(ptr)

/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		*yy_cp = yyg->yy_hold_char; \
		YY_RESTORE_YY_MORE_OFFSET \
		yyg->yy_c_buf_p = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )
#define unput(c) yyunput( c, yyg->yytext_ptr , yyscanner )


#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
	{
	FILE *yy_input_file;

        char* yy_ch_buf;  /* input buffer */
        char* yy_buf_pos; /* current position in input buffer */

        /* Size of input buffer in bytes, not including room for EOB
         * characters.
         */
        int yy_buf_size;

        /* Number of characters read into yy_ch_buf, not including EOB
         * characters.
         */
        int yy_n_chars;

        /* Whether we "own" the buffer - i.e., we know we created it,
         * and can realloc() it to grow it, and should free() it to
         * delete it.
         */
        int yy_is_our_buffer;

        /* Whether this is an "interactive" input source; if so, and
         * if we're using stdio for input, then we want to use getc()
         * instead of fread(), to make sure we stop fetching input after
         * each newline.
         */
        int yy_is_interactive;

        /* Whether we're considered to be at the beginning of a line.
         * If so, '^' rules will be active on the next match, otherwise
         * not.
         */
        int yy_at_bol;

        int yy_bs_lineno; /**< The line count. */
        int yy_bs_column; /**< The column count. */

        /* Whether to try to fill the input buffer when we reach the
         * end of it.
         */
        int yy_fill_buffer;

        int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
        /* When an EOF's been seen but there's still some text to process
         * then we mark the buffer as YY_EOF_PENDING, to indicate that we
         * shouldn't try reading from the input source any more.  We might
         * still have a bunch of tokens to match, though, because of
         * possible backing-up.
         *
         * When we actually see the EOF, we change the status to "new"
         * (via yyrestart()), so that the user can continue scanning by
         * just pointing yyin at a new input file.
         */
#define YY_BUFFER_EOF_PENDING 2

	};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ( yyg->yy_buffer_stack \
                          ? yyg->yy_buffer_stack[yyg->yy_buffer_stack_top] \
                          : NULL)
/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE yyg->yy_buffer_stack[yyg->yy_buffer_stack_top]

        void yyrestart(FILE* input_file, yyscan_t yyscanner);
        void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer,
                                 yyscan_t yyscanner);
        YY_BUFFER_STATE yy_create_buffer(FILE* file,
                                         int size,
                                         yyscan_t yyscanner);
        void yy_delete_buffer(YY_BUFFER_STATE b, yyscan_t yyscanner);
        void yy_flush_buffer(YY_BUFFER_STATE b, yyscan_t yyscanner);
        void yypush_buffer_state(YY_BUFFER_STATE new_buffer,
                                 yyscan_t yyscanner);
        void yypop_buffer_state(yyscan_t yyscanner);

        static void yyensure_buffer_stack(yyscan_t yyscanner);
        static void yy_load_buffer_state(yyscan_t yyscanner);
        static void yy_init_buffer(YY_BUFFER_STATE b,
                                   FILE* file,
                                   yyscan_t yyscanner);
#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER, yyscanner)

        YY_BUFFER_STATE yy_scan_buffer(char* base,
                                       yy_size_t size,
                                       yyscan_t yyscanner);
        YY_BUFFER_STATE yy_scan_string(const char* yy_str, yyscan_t yyscanner);
        YY_BUFFER_STATE yy_scan_bytes(const char* bytes,
                                      int len,
                                      yyscan_t yyscanner);

        void* yyalloc(yy_size_t, yyscan_t yyscanner);
        void* yyrealloc(void*, yy_size_t, yyscan_t yyscanner);
        void yyfree(void*, yyscan_t yyscanner);

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive)                        \
  {                                                               \
    if (!YY_CURRENT_BUFFER) {                                     \
      yyensure_buffer_stack(yyscanner);                           \
      YY_CURRENT_BUFFER_LVALUE =                                  \
          yy_create_buffer(yyin, YY_BUF_SIZE, yyscanner);         \
    }                                                             \
    YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
  }
#define yy_set_bol(at_bol)                                \
  {                                                       \
    if (!YY_CURRENT_BUFFER) {                             \
      yyensure_buffer_stack(yyscanner);                   \
      YY_CURRENT_BUFFER_LVALUE =                          \
          yy_create_buffer(yyin, YY_BUF_SIZE, yyscanner); \
    }                                                     \
    YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol;         \
  }
#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */

#define message_wrap(yyscanner) (/*CONSTCOND*/ 1)
#define YY_SKIP_YYWRAP
        typedef flex_uint8_t YY_CHAR;

        typedef int yy_state_type;

#define yytext_ptr yytext_r

        static yy_state_type yy_get_previous_state(yyscan_t yyscanner);
        static yy_state_type yy_try_NUL_trans(yy_state_type current_state,
                                              yyscan_t yyscanner);
        static int yy_get_next_buffer(yyscan_t yyscanner);
        static void yynoreturn yy_fatal_error(const char* msg,
                                              yyscan_t yyscanner);

        /* Done after the current pattern has been matched and before the
         * corresponding action - sets up yytext.
         */
#define YY_DO_BEFORE_ACTION      \
  yyg->yytext_ptr = yy_bp;       \
  yyleng = (int)(yy_cp - yy_bp); \
  yyg->yy_hold_char = *yy_cp;    \
  *yy_cp = '\0';                 \
  yyg->yy_c_buf_p = yy_cp;
#define YY_NUM_RULES 82
#define YY_END_OF_BUFFER 83
        /* This struct is not used in this scanner,
           but its presence is necessary. */
        struct yy_trans_info {
          flex_int32_t yy_verify;
          flex_int32_t yy_nxt;
        };
        static const flex_int16_t yy_accept[948] = {
            0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
            0,  0,  83, 81, 11, 2,  3,  7,  6,  5,  10, 69, 9,  8,  4,  81, 81,
            81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
            68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
            68, 68, 68, 81, 81, 81, 81, 81, 81, 68, 68, 68, 68, 68, 81, 68, 45,
            46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 47, 48, 48, 48,

            48, 48, 48, 48, 48, 48, 48, 48, 48, 11, 1,  69, 0,  0,  38, 0,  0,
            0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
            0,  0,  0,  0,  68, 68, 68, 38, 68, 68, 68, 68, 68, 68, 68, 68, 68,
            68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 0,  0,
            0,  0,  0,  0,  0,  0,  68, 68, 68, 68, 68, 68, 68, 0,  68, 45, 46,
            46, 46, 46, 46, 46, 46, 46, 47, 48, 48, 48, 48, 48, 48, 48,

            48, 14, 15, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
            0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  37, 0,  0,  14, 15, 68, 68,
            68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
            68, 68, 68, 68, 68, 37, 68, 68, 68, 0,  0,  0,  0,  0,  0,  0,  0,
            68, 68, 68, 68, 68, 68, 68, 0,  68, 14, 15, 14, 15, 14, 15, 14, 15,
            0,  0,  0,  0,  0,  0,  25, 0,  0,  0,  0,  13, 0,  0,  0,

            0,  12, 0,  0,  0,  0,  0,  0,  0,  0,  0,  68, 68, 68, 68, 68, 68,
            25, 68, 68, 68, 68, 13, 68, 68, 68, 68, 12, 68, 68, 68, 68, 68, 68,
            68, 68, 68, 70, 0,  0,  0,  0,  75, 0,  0,  0,  68, 68, 68, 68, 68,
            68, 68, 0,  68, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  28,
            0,  41, 18, 0,  0,  0,  0,  0,  0,  39, 0,  68, 68, 68, 68, 68, 68,
            68, 68, 68, 68, 68, 28, 68, 41, 68, 68, 68, 68, 68, 68, 68,

            68, 68, 68, 68, 68, 68, 68, 68, 68, 39, 68, 0,  0,  0,  77, 74, 0,
            0,  68, 68, 68, 68, 68, 68, 0,  32, 0,  43, 0,  0,  0,  0,  0,  0,
            0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  40, 32, 68, 43, 68, 68, 68,
            68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
            68, 68, 68, 68, 68, 68, 68, 40, 0,  0,  0,  0,  0,  68, 68, 68, 68,
            0,  42, 24, 33, 16, 17, 0,  0,  0,  0,  0,  0,  0,  21, 0,

            0,  0,  0,  0,  42, 24, 33, 68, 68, 68, 68, 68, 68, 21, 68, 68, 68,
            68, 68, 68, 68, 68, 68, 68, 68, 59, 68, 68, 68, 68, 68, 68, 68, 0,
            71, 0,  0,  0,  68, 68, 68, 68, 0,  0,  0,  36, 0,  31, 27, 0,  0,
            0,  0,  0,  0,  0,  68, 68, 36, 68, 31, 27, 68, 68, 68, 68, 68, 68,
            68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 0,  0,
            0,  76, 68, 68, 68, 0,  0,  0,  0,  0,  0,  0,  20, 0,  0,

            0,  22, 0,  44, 68, 68, 68, 68, 68, 22, 68, 44, 68, 68, 68, 68, 68,
            68, 68, 68, 68, 68, 68, 58, 68, 68, 68, 68, 0,  0,  0,  68, 68, 0,
            0,  0,  0,  0,  0,  0,  30, 0,  0,  0,  68, 68, 68, 30, 68, 68, 68,
            68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 0,  0,
            0,  68, 68, 0,  0,  0,  0,  0,  0,  0,  0,  0,  29, 68, 68, 68, 68,
            29, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 65, 68, 68,

            68, 68, 0,  0,  0,  68, 68, 0,  0,  0,  0,  0,  0,  0,  0,  0,  68,
            68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
            68, 68, 0,  0,  0,  68, 68, 0,  0,  0,  0,  0,  0,  0,  34, 0,  68,
            68, 68, 34, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
            68, 68, 73, 0,  72, 68, 68, 0,  0,  0,  0,  0,  35, 0,  0,  68, 68,
            68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68,

            68, 78, 0,  0,  0,  0,  0,  0,  0,  68, 68, 68, 68, 68, 68, 68, 68,
            68, 68, 67, 68, 68, 68, 68, 68, 68, 68, 0,  0,  0,  0,  0,  0,  0,
            0,  68, 68, 68, 49, 68, 68, 68, 68, 54, 53, 68, 68, 68, 68, 68, 63,
            68, 0,  0,  26, 0,  0,  68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
            50, 0,  0,  0,  0,  68, 68, 68, 68, 66, 68, 68, 68, 68, 55, 68, 0,
            0,  0,  19, 68, 68, 68, 68, 68, 68, 68, 68, 62, 0,  0,  23,

            51, 68, 57, 68, 68, 56, 68, 0,  0,  68, 68, 68, 68, 0,  68, 52, 68,
            68, 0,  68, 68, 68, 0,  68, 68, 68, 0,  68, 68, 68, 0,  68, 61, 68,
            0,  60, 68, 0,  68, 0,  64, 0,  0,  0,  79, 80, 0};

        static const YY_CHAR yy_ec[256] = {
            0,  1,  1,  1,  1,  1,  1,  1,  1,  2,  3,  1,  1,  4,  1,  1,  1,
            1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  5,  1,
            1,  1,  1,  1,  1,  1,  1,  1,  6,  1,  7,  8,  9,  10, 11, 12, 13,
            14, 15, 16, 17, 17, 17, 17, 18, 19, 1,  20, 1,  1,  1,  21, 22, 23,
            24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
            41, 42, 43, 44, 45, 46, 1,  1,  1,  1,  47, 1,  48, 49, 50, 51,

            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68,
            69, 70, 44, 71, 72, 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
            1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
            1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
            1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
            1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,

            1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
            1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
            1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
            1,  1,  1,  1};

        static const YY_CHAR yy_meta[73] = {
            0, 1, 1, 2, 2, 1, 1, 1, 3, 1, 1, 4, 4, 4, 4, 4, 4, 4, 1,
            1, 1, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 3, 3, 3,
            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};

        static const flex_int16_t yy_base[954] = {
            0,    0,    72,   142,  145,  148,  150,  129,  131,  0,    0,
            0,    0,    117,  119,  188,  231,  274,  317,  1959, 2296, 157,
            2296, 1953, 2296, 2296, 2296, 2296, 161,  2296, 2296, 2296, 158,
            121,  159,  160,  156,  197,  320,  189,  189,  206,  196,  310,
            198,  239,  253,  321,  195,  206,  236,  287,  227,  254,  247,
            275,  0,    296,  323,  319,  319,  330,  320,  322,  323,  326,
            335,  367,  320,  368,  364,  0,    370,  362,  378,  376,  378,
            379,  371,  417,  404,  387,  417,  421,  300,  427,  374,  426,
            422,  419,  0,    478,  475,  460,  484,  488,  464,  539,  495,
            419,  449,

            477,  483,  0,    546,  525,  516,  553,  556,  557,  213,  2296,
            572,  497,  1941, 2296, 548,  552,  572,  576,  577,  578,  585,
            568,  569,  593,  595,  590,  616,  587,  597,  595,  594,  608,
            598,  597,  612,  1946, 608,  0,    618,  1939, 0,    611,  606,
            626,  617,  631,  640,  639,  622,  624,  647,  649,  644,  671,
            642,  653,  651,  649,  663,  653,  652,  667,  670,  1944, 669,
            1947, 685,  659,  674,  663,  685,  687,  687,  700,  678,  693,
            681,  708,  713,  709,  702,  719,  758,  0,    727,  1935, 726,
            739,  755,  767,  771,  784,  0,    741,  1934, 746,  786,  787,
            797,

            791,  2296, 2296, 777,  792,  794,  797,  783,  789,  803,  789,
            787,  791,  810,  800,  813,  803,  804,  807,  823,  816,  825,
            826,  1937, 827,  836,  828,  2296, 840,  845,  0,    0,    843,
            849,  850,  849,  836,  841,  855,  841,  839,  842,  860,  851,
            861,  848,  852,  857,  873,  860,  869,  875,  1880, 877,  888,
            880,  0,    1839, 891,  896,  1874, 1815, 891,  1823, 882,  879,
            881,  888,  1778, 901,  1664, 892,  888,  893,  897,  900,  902,
            0,    0,    931,  943,  0,    0,    946,  947,  908,  929,  923,
            918,  919,  1656, 1617, 950,  932,  934,  940,  2296, 1621, 951,
            948,

            944,  2296, 1533, 963,  945,  965,  954,  957,  955,  963,  975,
            967,  984,  976,  971,  969,  1487, 1452, 993,  978,  980,  986,
            0,    1478, 997,  994,  988,  0,    1477, 1004, 986,  994,  997,
            995,  1044, 1005, 1014, 2296, 1006, 1008, 1001, 1029, 2296, 1024,
            1026, 1039, 1028, 1037, 1049, 0,    1039, 1040, 1053, 1476, 1475,
            1057, 1047, 1063, 1064, 1058, 1480, 1074, 1060, 1437, 1079, 1093,
            1080, 2296, 1077, 2296, 2296, 1080, 1094, 1079, 1098, 1101, 1089,
            2296, 1103, 1108, 1098, 1106, 1103, 1095, 1474, 1111, 1098, 1434,
            1108, 1117, 0,    1099, 0,    1102, 1117, 1123, 1125, 1113, 1128,
            1129,

            1140, 1133, 1160, 1130, 1141, 1140, 1143, 1153, 1154, 0,    1160,
            1165, 1153, 1162, 2296, 2296, 1169, 1156, 1171, 1159, 0,    0,
            1173, 1161, 1470, 2296, 1175, 2296, 1178, 1179, 175,  1184, 1181,
            1193, 1199, 1186, 1193, 1191, 1184, 1207, 1198, 1214, 1196, 1197,
            2296, 0,    1213, 0,    1216, 1215, 1220, 1217, 1221, 1222, 1208,
            1212, 1205, 1225, 1233, 1216, 1218, 1432, 1235, 1431, 1231, 1236,
            1239, 1256, 1242, 1257, 1243, 1267, 1260, 1268, 1267, 0,    1254,
            1254, 1273, 1257, 1253, 1260, 1260, 1262, 1258, 1466, 2296, 1380,
            2296, 2296, 2296, 1266, 1279, 1287, 1279, 1288, 1292, 1273, 2296,
            1289,

            1397, 1293, 1297, 1308, 0,    1317, 0,    1298, 1312, 1317, 1311,
            1319, 1303, 0,    1310, 1308, 1312, 1323, 1307, 1321, 1326, 1328,
            1322, 1318, 1319, 0,    1012, 1352, 1317, 1332, 1340, 1345, 1360,
            1365, 2296, 1037, 1366, 1354, 1369, 0,    1371, 1362, 1386, 1381,
            993,  2296, 1366, 2296, 2296, 1363, 1386, 1376, 1370, 1371, 1379,
            1397, 1399, 991,  0,    1384, 0,    0,    1402, 1392, 1383, 1388,
            1406, 1403, 1400, 1404, 1406, 1416, 1418, 1412, 1413, 1408, 1425,
            1430, 1433, 1436, 1434, 984,  1428, 1431, 1422, 1436, 2296, 1441,
            1442, 0,    932,  1494, 1503, 1512, 1465, 1463, 1479, 2296, 1502,
            1492,

            1509, 2296, 1511, 2296, 1514, 1504, 1512, 1510, 1499, 0,    1517,
            0,    1517, 885,  1504, 1503, 1521, 1511, 1521, 1526, 1523, 1511,
            1516, 0,    1529, 1527, 1557, 746,  1529, 1529, 1531, 1533, 1559,
            1575, 1586, 1601, 257,  1557, 1565, 1577, 2296, 1567, 1570, 1580,
            1573, 1590, 1595, 0,    1586, 1597, 1601, 1604, 1595, 737,  1589,
            1590, 1610, 1592, 1601, 1601, 1600, 1597, 1605, 1623, 1620, 1621,
            1608, 1626, 1618, 1619, 1620, 774,  1667, 1679, 1688, 701,  1623,
            1663, 1671, 725,  2296, 696,  1668, 1673, 1674, 0,    1675, 1676,
            1691, 1675, 1679, 695,  651,  619,  1674, 1691, 1696, 576,  565,
            1682,

            1679, 1685, 1696, 529,  1697, 1698, 1699, 1715, 1743, 1752, 1761,
            1721, 1722, 1733, 1746, 1738, 1749, 1742, 1745, 1752, 488,  1761,
            1746, 1747, 1750, 1754, 1752, 1767, 1768, 1770, 1755, 1758, 1764,
            1778, 1760, 1763, 1764, 515,  1765, 1766, 1769, 512,  1824, 1833,
            1842, 1787, 499,  1807, 2296, 1826, 1832, 451,  1818, 0,    1838,
            1840, 421,  1830, 420,  1829, 1839, 1845, 1831, 419,  1842, 1847,
            1848, 1852, 1846, 1843, 2296, 453,  2296, 0,    0,    1868, 1895,
            1904, 1913, 1866, 2296, 416,  1885, 1884, 415,  1895, 1908, 1910,
            411,  1894, 1900, 1902, 1908, 1898, 1915, 1905, 1903, 1903, 1915,
            1911,

            1925, 2296, 209,  1964, 1973, 1982, 1961, 1970, 1980, 1964, 1973,
            1968, 1968, 1980, 1973, 1966, 1972, 1982, 1990, 0,    1986, 1982,
            1976, 1990, 1987, 1993, 1981, 1979, 2039, 2047, 2056, 2065, 434,
            2053, 2063, 398,  2056, 2053, 0,    2066, 2053, 2053, 2065, 0,
            0,    2052, 368,  2059, 2058, 2065, 0,    2056, 2070, 2087, 2296,
            2066, 2067, 2068, 2087, 2076, 2086, 2100, 2103, 2091, 2087, 2104,
            2106, 2091, 0,    2112, 2128, 2106, 2107, 2108, 2109, 2123, 2119,
            0,    2120, 2129, 2124, 364,  0,    2119, 394,  2155, 299,  2296,
            298,  2139, 2154, 2141, 2152, 2161, 2151, 2161, 0,    298,  2181,
            2296,

            0,    259,  0,    2150, 2154, 0,    2179, 253,  253,  2161, 2168,
            183,  2167, 219,  2175, 0,    2180, 2193, 2176, 2183, 2182, 2196,
            2179, 2191, 2197, 2193, 2185, 2190, 2201, 2200, 2208, 2207, 0,
            2206, 2215, 0,    2197, 2205, 2207, 2210, 0,    2230, 208,  209,
            2296, 2296, 2296, 2281, 2285, 2287, 2291, 222,  221};

        static const flex_int16_t yy_def[954] = {
            0,   947, 947, 948, 948, 949, 949, 1,   2,   1,   2,   1,   2,
            1,   2,   1,   2,   1,   2,   947, 947, 947, 947, 947, 947, 947,
            947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
            947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 950,
            950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950,
            950, 950, 950, 950, 950, 950, 951, 947, 947, 947, 947, 947, 950,
            950, 950, 950, 950, 947, 950, 952, 952, 952, 952, 952, 952, 952,
            950, 91,  91,  91,  91,  91,  953, 953, 953, 953,

            953, 953, 953, 91,  104, 104, 104, 104, 104, 947, 947, 947, 947,
            947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
            947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 950,
            950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950,
            950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950,
            950, 951, 947, 947, 947, 947, 947, 947, 947, 950, 950, 950, 950,
            950, 950, 950, 947, 950, 952, 952, 952, 952, 952, 91,  91,  91,
            91,  953, 953, 953, 953, 953, 104, 104, 104,

            104, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
            947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
            947, 947, 947, 947, 950, 950, 950, 950, 950, 950, 950, 950, 950,
            950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950,
            950, 950, 950, 950, 950, 950, 950, 950, 947, 947, 947, 947, 947,
            947, 947, 947, 950, 950, 950, 950, 950, 950, 950, 947, 950, 952,
            952, 91,  91,  953, 953, 104, 104, 947, 947, 947, 947, 947, 947,
            947, 947, 947, 947, 947, 947, 947, 947, 947,

            947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 950, 950,
            950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950,
            950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 947, 947,
            947, 947, 947, 947, 947, 947, 947, 950, 950, 950, 950, 950, 950,
            950, 947, 950, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
            947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
            947, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950,
            950, 950, 950, 950, 950, 950, 950, 950, 950,

            950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 947, 947,
            947, 947, 947, 947, 947, 950, 950, 950, 950, 950, 950, 947, 947,
            947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
            947, 947, 947, 947, 947, 947, 950, 950, 950, 950, 950, 950, 950,
            950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950,
            950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 947, 947,
            947, 947, 947, 950, 950, 950, 950, 947, 947, 947, 947, 947, 947,
            947, 947, 947, 947, 947, 947, 947, 947, 947,

            947, 947, 947, 947, 950, 950, 950, 950, 950, 950, 950, 950, 950,
            950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950,
            950, 950, 950, 950, 950, 950, 950, 947, 947, 947, 947, 947, 950,
            950, 950, 950, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
            947, 947, 947, 947, 950, 950, 950, 950, 950, 950, 950, 950, 950,
            950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950,
            950, 950, 950, 950, 950, 947, 947, 947, 947, 950, 950, 950, 947,
            947, 947, 947, 947, 947, 947, 947, 947, 947,

            947, 947, 947, 947, 950, 950, 950, 950, 950, 950, 950, 950, 950,
            950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950,
            950, 950, 947, 947, 947, 950, 950, 947, 947, 947, 947, 947, 947,
            947, 947, 947, 947, 947, 950, 950, 950, 950, 950, 950, 950, 950,
            950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950,
            950, 947, 947, 947, 950, 950, 947, 947, 947, 947, 947, 947, 947,
            947, 947, 947, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950,
            950, 950, 950, 950, 950, 950, 950, 950, 950,

            950, 950, 947, 947, 947, 950, 950, 947, 947, 947, 947, 947, 947,
            947, 947, 947, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950,
            950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 947, 947, 947,
            950, 950, 947, 947, 947, 947, 947, 947, 947, 947, 947, 950, 950,
            950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950,
            950, 950, 950, 950, 950, 947, 947, 947, 950, 950, 947, 947, 947,
            947, 947, 947, 947, 947, 950, 950, 950, 950, 950, 950, 950, 950,
            950, 950, 950, 950, 950, 950, 950, 950, 950,

            950, 947, 947, 947, 947, 947, 947, 947, 947, 950, 950, 950, 950,
            950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950,
            950, 947, 947, 947, 947, 947, 947, 947, 947, 950, 950, 950, 950,
            950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950,
            947, 947, 947, 947, 947, 950, 950, 950, 950, 950, 950, 950, 950,
            950, 950, 950, 950, 947, 947, 947, 947, 950, 950, 950, 950, 950,
            950, 950, 950, 950, 950, 950, 947, 947, 947, 947, 950, 950, 950,
            950, 950, 950, 950, 950, 950, 947, 947, 947,

            950, 950, 950, 950, 950, 950, 950, 947, 947, 950, 950, 950, 950,
            947, 950, 950, 950, 950, 947, 950, 950, 950, 947, 950, 950, 950,
            947, 950, 950, 950, 947, 950, 950, 950, 947, 950, 950, 947, 950,
            947, 950, 947, 947, 947, 947, 947, 0,   947, 947, 947, 947, 947,
            947};

        static const flex_int16_t yy_nxt[2369] = {
            0,   20,  21,  22,  23,  21,  24,  25,  26,  20,  27,  28,  28,
            28,  28,  28,  28,  28,  29,  30,  31,  32,  33,  34,  35,  36,
            20,  37,  38,  39,  40,  41,  42,  43,  44,  20,  45,  20,  46,
            47,  20,  48,  20,  49,  20,  20,  50,  20,  32,  33,  34,  35,
            36,  20,  37,  38,  39,  40,  41,  42,  43,  44,  20,  45,  20,
            46,  47,  20,  48,  20,  49,  20,  50,  20,  21,  22,  23,  21,
            24,  25,  26,  20,  27,  28,  28,  28,  28,  28,  28,  28,  29,
            30,  31,  51,  52,  53,  54,  55,  56,  57,  58,

            59,  60,  61,  62,  63,  64,  56,  65,  56,  66,  67,  56,  68,
            56,  69,  56,  56,  70,  20,  51,  52,  53,  54,  55,  56,  57,
            58,  59,  60,  61,  62,  63,  64,  56,  65,  56,  66,  67,  56,
            68,  56,  69,  56,  70,  22,  23,  20,  22,  23,  20,  22,  23,
            22,  23,  82,  72,  83,  77,  110, 20,  115, 110, 20,  73,  74,
            78,  79,  75,  76,  80,  81,  112, 112, 112, 112, 112, 112, 112,
            113, 116, 114, 82,  72,  83,  77,  490, 491, 115, 117, 118, 73,
            74,  78,  79,  75,  76,  80,  81,  84,  84,

            84,  84,  84,  84,  84,  113, 116, 114, 85,  86,  87,  88,  89,
            90,  110, 117, 118, 110, 828, 945, 946, 119, 122, 123, 194, 185,
            829, 944, 919, 917, 124, 125, 128, 136, 137, 85,  86,  87,  88,
            89,  90,  84,  84,  84,  84,  84,  84,  84,  119, 122, 123, 91,
            92,  93,  94,  95,  96,  124, 125, 128, 136, 137, 828, 914, 138,
            634, 142, 591, 591, 591, 591, 591, 591, 129, 143, 144, 130, 131,
            91,  92,  93,  94,  95,  96,  97,  97,  97,  97,  97,  97,  97,
            138, 132, 142, 98,  99,  100, 101, 102, 103,

            129, 143, 144, 130, 131, 910, 908, 140, 145, 141, 184, 184, 184,
            184, 184, 184, 184, 900, 900, 132, 146, 98,  99,  100, 101, 102,
            103, 97,  97,  97,  97,  97,  97,  97,  140, 145, 141, 104, 105,
            106, 107, 108, 109, 120, 126, 133, 147, 146, 121, 134, 127, 148,
            149, 150, 151, 152, 153, 155, 163, 158, 156, 135, 154, 157, 104,
            105, 106, 107, 108, 109, 120, 126, 133, 147, 159, 121, 134, 127,
            148, 149, 150, 151, 152, 153, 155, 163, 158, 156, 135, 154, 157,
            160, 166, 164, 168, 161, 165, 169, 171, 170,

            173, 159, 174, 175, 134, 898, 176, 162, 177, 172, 896, 181, 129,
            115, 865, 130, 135, 855, 160, 166, 164, 168, 161, 165, 169, 171,
            170, 173, 180, 174, 175, 134, 161, 176, 162, 177, 172, 178, 181,
            129, 115, 131, 130, 135, 162, 158, 188, 186, 179, 187, 117, 156,
            118, 855, 157, 180, 182, 815, 115, 161, 183, 811, 808, 802, 178,
            795, 790, 788, 131, 197, 781, 162, 158, 188, 186, 179, 187, 117,
            156, 118, 192, 157, 189, 182, 189, 115, 189, 183, 189, 189, 189,
            189, 189, 189, 189, 189, 197, 189, 190, 189,

            191, 189, 189, 189, 189, 117, 189, 192, 189, 189, 189, 189, 144,
            189, 142, 195, 118, 196, 781, 202, 776, 145, 189, 772, 189, 190,
            189, 191, 189, 189, 189, 189, 117, 189, 755, 189, 201, 189, 198,
            144, 738, 142, 195, 118, 196, 198, 202, 198, 145, 193, 193, 193,
            193, 193, 193, 193, 198, 198, 198, 198, 198, 198, 198, 201, 142,
            198, 199, 198, 200, 198, 198, 198, 198, 198, 198, 198, 198, 198,
            198, 198, 204, 144, 112, 112, 112, 112, 112, 112, 112, 145, 205,
            142, 206, 199, 198, 200, 198, 198, 198, 209,

            198, 210, 198, 198, 198, 198, 198, 204, 144, 207, 211, 733, 213,
            214, 208, 215, 145, 205, 216, 206, 212, 218, 732, 219, 221, 222,
            209, 223, 210, 224, 225, 226, 227, 228, 230, 217, 207, 211, 213,
            214, 231, 208, 215, 233, 234, 216, 235, 212, 218, 220, 236, 221,
            222, 238, 223, 237, 224, 225, 226, 227, 228, 230, 217, 239, 240,
            728, 242, 231, 243, 244, 233, 234, 245, 235, 241, 247, 220, 236,
            248, 250, 238, 251, 237, 252, 253, 254, 255, 256, 257, 246, 239,
            240, 242, 258, 243, 260, 244, 727, 263, 245,

            264, 241, 247, 265, 249, 266, 250, 268, 251, 225, 252, 253, 254,
            255, 256, 257, 246, 270, 207, 271, 258, 272, 260, 208, 262, 263,
            267, 264, 273, 275, 265, 249, 266, 236, 268, 254, 225, 224, 237,
            269, 276, 726, 717, 716, 270, 207, 271, 712, 272, 278, 208, 262,
            274, 267, 253, 273, 275, 277, 204, 189, 236, 189, 254, 282, 224,
            237, 269, 276, 184, 184, 184, 184, 184, 184, 184, 189, 278, 280,
            204, 274, 281, 253, 708, 690, 277, 204, 189, 189, 189, 189, 282,
            189, 666, 189, 193, 193, 193, 193, 193, 193,

            193, 286, 189, 233, 280, 204, 198, 198, 198, 284, 285, 198, 287,
            198, 189, 288, 189, 198, 189, 198, 189, 289, 290, 233, 291, 292,
            293, 294, 286, 295, 233, 296, 297, 198, 198, 198, 284, 298, 198,
            287, 198, 299, 288, 300, 198, 301, 198, 302, 289, 290, 233, 291,
            292, 293, 294, 303, 295, 304, 296, 297, 305, 307, 308, 309, 298,
            310, 311, 312, 299, 313, 300, 314, 301, 315, 302, 316, 317, 318,
            319, 320, 321, 322, 303, 323, 304, 324, 325, 305, 307, 308, 309,
            326, 310, 311, 312, 327, 313, 328, 314, 329,

            315, 330, 316, 317, 318, 319, 320, 321, 322, 331, 323, 332, 324,
            325, 333, 334, 336, 337, 326, 340, 342, 344, 327, 343, 328, 346,
            329, 345, 330, 348, 349, 652, 350, 351, 353, 354, 331, 355, 332,
            352, 634, 333, 334, 336, 337, 356, 340, 342, 344, 343, 357, 189,
            346, 189, 358, 359, 348, 349, 350, 360, 351, 353, 354, 189, 355,
            189, 198, 198, 198, 198, 363, 364, 356, 365, 366, 368, 369, 357,
            189, 370, 189, 358, 359, 372, 373, 374, 360, 375, 376, 377, 189,
            378, 189, 198, 198, 198, 198, 363, 364, 379,

            365, 366, 368, 369, 380, 381, 370, 382, 383, 384, 372, 373, 374,
            387, 375, 376, 377, 388, 378, 389, 390, 391, 392, 393, 394, 395,
            379, 396, 397, 398, 627, 380, 381, 410, 382, 383, 384, 606, 411,
            596, 387, 412, 413, 414, 388, 585, 389, 390, 391, 392, 393, 394,
            395, 415, 396, 397, 398, 399, 576, 416, 410, 417, 418, 419, 400,
            411, 401, 402, 412, 413, 414, 420, 403, 421, 422, 423, 424, 426,
            427, 404, 415, 405, 406, 407, 408, 409, 416, 428, 417, 418, 419,
            400, 429, 401, 402, 430, 432, 433, 420, 403,

            421, 422, 423, 424, 426, 427, 404, 435, 405, 406, 407, 408, 409,
            436, 428, 437, 438, 439, 440, 429, 441, 442, 430, 432, 433, 443,
            444, 445, 446, 447, 448, 449, 450, 451, 435, 452, 454, 455, 456,
            457, 436, 458, 437, 438, 439, 440, 459, 441, 442, 460, 461, 462,
            443, 444, 445, 446, 447, 448, 449, 450, 451, 467, 452, 454, 455,
            456, 457, 470, 458, 463, 464, 465, 468, 459, 466, 471, 460, 461,
            462, 472, 473, 474, 475, 469, 476, 477, 478, 479, 467, 480, 481,
            482, 483, 484, 470, 485, 463, 464, 465, 487,

            488, 466, 471, 489, 492, 493, 472, 473, 474, 475, 469, 476, 477,
            478, 479, 494, 480, 481, 482, 483, 484, 495, 485, 496, 497, 498,
            487, 488, 499, 500, 489, 492, 493, 501, 502, 503, 504, 505, 506,
            507, 508, 509, 494, 510, 511, 512, 513, 515, 495, 514, 496, 497,
            498, 516, 499, 517, 500, 518, 520, 522, 501, 502, 503, 504, 505,
            506, 507, 508, 509, 523, 510, 511, 512, 513, 515, 514, 524, 525,
            526, 527, 516, 528, 517, 529, 518, 520, 522, 530, 531, 532, 533,
            534, 535, 536, 537, 538, 523, 539, 540, 541,

            542, 545, 546, 524, 525, 526, 527, 547, 528, 548, 529, 549, 550,
            551, 530, 531, 532, 533, 534, 535, 536, 537, 538, 552, 539, 540,
            541, 542, 545, 546, 554, 555, 556, 558, 547, 559, 548, 560, 549,
            550, 551, 561, 562, 563, 564, 565, 566, 567, 568, 569, 552, 570,
            571, 574, 575, 572, 579, 554, 555, 556, 558, 573, 559, 557, 560,
            580, 581, 582, 561, 562, 563, 564, 565, 566, 567, 568, 569, 577,
            570, 571, 574, 575, 572, 579, 583, 584, 586, 587, 573, 588, 578,
            589, 580, 581, 582, 590, 591, 592, 593, 594,

            594, 594, 594, 595, 577, 597, 553, 598, 599, 600, 601, 583, 584,
            586, 587, 602, 588, 578, 589, 603, 604, 605, 590, 607, 608, 609,
            544, 610, 611, 612, 595, 613, 597, 598, 614, 599, 600, 601, 615,
            616, 617, 602, 618, 619, 620, 621, 603, 604, 605, 622, 607, 608,
            609, 610, 623, 611, 612, 624, 613, 625, 626, 614, 628, 629, 630,
            615, 616, 617, 631, 618, 619, 620, 621, 632, 633, 543, 622, 521,
            519, 486, 453, 623, 431, 434, 624, 638, 625, 626, 431, 628, 629,
            630, 425, 425, 639, 631, 371, 367, 386, 385,

            632, 633, 634, 640, 635, 635, 635, 635, 635, 635, 635, 634, 638,
            636, 636, 636, 636, 636, 637, 591, 634, 639, 591, 591, 591, 591,
            591, 591, 591, 641, 640, 642, 643, 644, 645, 646, 647, 648, 649,
            650, 651, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663,
            371, 667, 668, 669, 641, 670, 642, 643, 644, 645, 646, 647, 648,
            649, 650, 651, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662,
            663, 664, 667, 668, 669, 671, 670, 672, 673, 674, 675, 675, 675,
            675, 676, 677, 634, 665, 591, 591, 591, 591,

            591, 591, 591, 678, 679, 680, 664, 681, 682, 634, 671, 591, 591,
            591, 591, 591, 591, 591, 683, 676, 677, 684, 665, 685, 686, 687,
            688, 689, 691, 692, 678, 679, 680, 693, 681, 682, 694, 695, 696,
            697, 367, 698, 699, 700, 701, 683, 702, 703, 684, 704, 685, 686,
            687, 688, 689, 691, 692, 705, 706, 707, 693, 713, 694, 362, 695,
            696, 697, 698, 361, 699, 700, 701, 341, 702, 703, 708, 704, 709,
            709, 709, 709, 709, 709, 709, 705, 706, 707, 708, 713, 710, 710,
            710, 710, 710, 711, 672, 708, 714, 672, 672,

            672, 672, 672, 672, 672, 715, 718, 719, 720, 721, 722, 723, 724,
            725, 729, 730, 731, 734, 735, 736, 737, 739, 740, 741, 714, 742,
            743, 744, 745, 745, 745, 745, 715, 718, 719, 720, 721, 722, 723,
            724, 725, 729, 730, 731, 734, 735, 736, 737, 739, 740, 741, 708,
            746, 672, 672, 672, 672, 672, 672, 672, 708, 747, 672, 672, 672,
            672, 672, 672, 672, 708, 748, 672, 672, 672, 672, 672, 672, 749,
            750, 746, 751, 752, 753, 754, 756, 757, 758, 759, 747, 760, 761,
            762, 763, 764, 765, 766, 767, 748, 768, 769,

            770, 771, 773, 774, 749, 750, 775, 751, 752, 753, 754, 756, 757,
            758, 759, 780, 760, 761, 762, 763, 764, 765, 766, 767, 347, 768,
            769, 770, 771, 773, 774, 341, 776, 775, 777, 777, 777, 777, 777,
            777, 777, 776, 780, 778, 778, 778, 778, 778, 779, 742, 776, 782,
            742, 742, 742, 742, 742, 742, 742, 783, 784, 339, 785, 786, 787,
            789, 791, 792, 793, 794, 796, 797, 798, 799, 800, 801, 338, 782,
            803, 804, 805, 806, 806, 806, 806, 335, 783, 784, 785, 306, 786,
            787, 789, 791, 792, 793, 794, 796, 797, 798,

            799, 800, 801, 776, 807, 742, 742, 742, 742, 742, 742, 742, 776,
            809, 742, 742, 742, 742, 742, 742, 742, 776, 810, 742, 742, 742,
            742, 742, 742, 812, 813, 807, 814, 816, 817, 818, 819, 820, 821,
            822, 809, 823, 824, 825, 826, 827, 306, 283, 279, 810, 261, 259,
            232, 229, 203, 111, 812, 813, 947, 814, 816, 817, 818, 819, 820,
            821, 822, 947, 823, 824, 825, 826, 827, 828, 830, 830, 830, 830,
            830, 830, 830, 829, 828, 831, 831, 831, 831, 831, 832, 803, 829,
            828, 803, 803, 803, 803, 803, 803, 803, 829,

            833, 834, 835, 836, 837, 838, 839, 840, 841, 947, 842, 843, 844,
            845, 846, 847, 848, 849, 850, 851, 852, 853, 947, 947, 947, 947,
            947, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 947, 843,
            844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 854, 854,
            854, 854, 854, 854, 828, 803, 803, 803, 803, 803, 803, 803, 829,
            828, 803, 803, 803, 803, 803, 803, 803, 829, 828, 803, 803, 803,
            803, 803, 803, 856, 829, 857, 858, 859, 860, 861, 862, 863, 864,
            866, 867, 868, 869, 870, 828, 871, 871, 871,

            871, 871, 871, 871, 872, 873, 874, 875, 856, 876, 857, 858, 859,
            860, 861, 862, 863, 864, 866, 867, 868, 869, 870, 877, 878, 879,
            880, 881, 882, 883, 884, 872, 873, 874, 875, 885, 876, 828, 886,
            886, 886, 886, 886, 886, 886, 887, 888, 889, 890, 891, 877, 878,
            879, 880, 881, 882, 883, 884, 892, 893, 894, 895, 885, 897, 828,
            899, 899, 899, 899, 899, 899, 899, 887, 888, 889, 890, 891, 901,
            902, 903, 904, 905, 906, 907, 911, 892, 893, 894, 895, 897, 828,
            909, 909, 909, 909, 909, 909, 909, 912, 913,

            915, 916, 918, 920, 901, 902, 903, 904, 905, 906, 907, 911, 921,
            922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 912, 933,
            913, 915, 916, 918, 920, 934, 935, 936, 937, 938, 939, 940, 942,
            921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 941,
            933, 943, 947, 947, 947, 947, 934, 935, 936, 937, 938, 939, 940,
            942, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 941,
            947, 947, 943, 71,  71,  71,  71,  20,  20,  20,  20,  139, 139,
            167, 947, 167, 167, 19,  947, 947, 947, 947,

            947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
            947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
            947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
            947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
            947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
            947, 947, 947};

        static const flex_int16_t yy_chk[2369] = {
            0,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   1,   2,   2,   2,   2,   2,
            2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
            2,   2,   2,   2,   2,   2,   2,   2,   2,   2,

            2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
            2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
            2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
            2,   2,   2,   2,   2,   3,   3,   3,   4,   4,   4,   5,   5,
            6,   6,   13,  7,   14,  8,   21,  3,   33,  21,  4,   7,   7,
            8,   8,   7,   7,   8,   8,   28,  28,  28,  28,  28,  28,  28,
            32,  34,  32,  13,  7,   14,  8,   431, 431, 33,  35,  36,  7,
            7,   8,   8,   7,   7,   8,   8,   15,  15,

            15,  15,  15,  15,  15,  32,  34,  32,  15,  15,  15,  15,  15,
            15,  110, 35,  36,  110, 803, 944, 944, 37,  39,  40,  953, 952,
            803, 943, 914, 912, 41,  42,  44,  48,  49,  15,  15,  15,  15,
            15,  15,  16,  16,  16,  16,  16,  16,  16,  37,  39,  40,  16,
            16,  16,  16,  16,  16,  41,  42,  44,  48,  49,  909, 908, 50,
            637, 52,  637, 637, 637, 637, 637, 637, 45,  53,  54,  45,  46,
            16,  16,  16,  16,  16,  16,  17,  17,  17,  17,  17,  17,  17,
            50,  46,  52,  17,  17,  17,  17,  17,  17,

            45,  53,  54,  45,  46,  902, 898, 51,  55,  51,  84,  84,  84,
            84,  84,  84,  84,  889, 887, 46,  57,  17,  17,  17,  17,  17,
            17,  18,  18,  18,  18,  18,  18,  18,  51,  55,  51,  18,  18,
            18,  18,  18,  18,  38,  43,  47,  58,  57,  38,  47,  43,  58,
            59,  60,  61,  62,  63,  64,  68,  66,  65,  47,  63,  65,  18,
            18,  18,  18,  18,  18,  38,  43,  47,  58,  66,  38,  47,  43,
            58,  59,  60,  61,  62,  63,  64,  68,  66,  65,  47,  63,  65,
            67,  70,  69,  72,  67,  69,  73,  74,  73,

            75,  66,  76,  77,  75,  885, 78,  67,  78,  74,  882, 81,  74,
            86,  847, 74,  75,  836, 67,  70,  69,  72,  67,  69,  73,  74,
            73,  75,  80,  76,  77,  75,  80,  78,  67,  78,  74,  79,  81,
            74,  86,  82,  74,  75,  80,  83,  87,  85,  79,  85,  88,  79,
            89,  833, 79,  80,  82,  789, 99,  80,  83,  785, 782, 772, 79,
            764, 759, 757, 82,  100, 752, 80,  83,  87,  85,  79,  85,  88,
            79,  89,  93,  79,  93,  82,  96,  99,  96,  83,  91,  91,  91,
            91,  91,  91,  91,  92,  100, 92,  91,  91,

            91,  91,  91,  91,  94,  101, 94,  93,  95,  93,  95,  96,  94,
            96,  92,  98,  102, 98,  747, 113, 742, 95,  92,  738, 92,  91,
            91,  91,  91,  91,  91,  94,  101, 94,  721, 95,  106, 95,  106,
            94,  704, 92,  98,  102, 98,  105, 113, 105, 95,  97,  97,  97,
            97,  97,  97,  97,  104, 104, 104, 104, 104, 104, 104, 106, 105,
            106, 104, 104, 104, 104, 104, 104, 105, 107, 105, 107, 108, 109,
            108, 109, 116, 107, 112, 112, 112, 112, 112, 112, 112, 108, 117,
            105, 118, 104, 104, 104, 104, 104, 104, 120,

            107, 121, 107, 108, 109, 108, 109, 116, 107, 119, 122, 699, 123,
            124, 119, 125, 108, 117, 126, 118, 122, 127, 698, 128, 129, 130,
            120, 131, 121, 132, 133, 134, 135, 136, 138, 126, 119, 122, 123,
            124, 140, 119, 125, 143, 144, 126, 145, 122, 127, 128, 146, 129,
            130, 147, 131, 146, 132, 133, 134, 135, 136, 138, 126, 148, 149,
            694, 150, 140, 151, 152, 143, 144, 153, 145, 149, 154, 128, 146,
            155, 156, 147, 157, 146, 158, 159, 160, 161, 162, 163, 153, 148,
            149, 150, 164, 151, 166, 152, 693, 169, 153,

            170, 149, 154, 171, 155, 172, 156, 174, 157, 173, 158, 159, 160,
            161, 162, 163, 153, 176, 168, 177, 164, 178, 166, 168, 168, 169,
            173, 170, 179, 181, 171, 155, 172, 175, 174, 180, 173, 182, 175,
            175, 182, 692, 682, 680, 176, 168, 177, 676, 178, 186, 168, 168,
            180, 173, 183, 179, 181, 183, 188, 189, 175, 189, 180, 195, 182,
            175, 175, 182, 184, 184, 184, 184, 184, 184, 184, 190, 186, 190,
            197, 180, 191, 183, 672, 654, 183, 188, 189, 191, 189, 191, 195,
            192, 628, 192, 193, 193, 193, 193, 193, 193,

            193, 204, 190, 192, 190, 197, 198, 199, 198, 199, 200, 201, 205,
            201, 191, 206, 191, 200, 192, 200, 192, 207, 208, 201, 209, 210,
            211, 212, 204, 213, 192, 214, 215, 198, 199, 198, 199, 216, 201,
            205, 201, 217, 206, 218, 200, 219, 200, 220, 207, 208, 201, 209,
            210, 211, 212, 221, 213, 222, 214, 215, 223, 225, 226, 227, 216,
            229, 230, 233, 217, 234, 218, 235, 219, 236, 220, 237, 238, 239,
            240, 241, 242, 243, 221, 244, 222, 245, 246, 223, 225, 226, 227,
            247, 229, 230, 233, 248, 234, 249, 235, 250,

            236, 251, 237, 238, 239, 240, 241, 242, 243, 252, 244, 254, 245,
            246, 255, 256, 259, 260, 247, 263, 265, 267, 248, 266, 249, 268,
            250, 267, 251, 270, 272, 614, 273, 274, 275, 276, 252, 277, 254,
            274, 591, 255, 256, 259, 260, 286, 263, 265, 267, 266, 287, 280,
            268, 280, 288, 289, 270, 272, 273, 290, 274, 275, 276, 281, 277,
            281, 284, 285, 284, 285, 293, 294, 286, 295, 296, 299, 300, 287,
            280, 301, 280, 288, 289, 304, 305, 306, 290, 307, 308, 309, 281,
            310, 281, 284, 285, 284, 285, 293, 294, 311,

            295, 296, 299, 300, 312, 313, 301, 314, 315, 316, 304, 305, 306,
            319, 307, 308, 309, 320, 310, 321, 322, 325, 326, 327, 330, 331,
            311, 332, 333, 334, 582, 312, 313, 336, 314, 315, 316, 558, 337,
            545, 319, 339, 340, 341, 320, 536, 321, 322, 325, 326, 327, 330,
            331, 342, 332, 333, 334, 335, 527, 344, 336, 345, 346, 347, 335,
            337, 335, 335, 339, 340, 341, 348, 335, 349, 351, 352, 353, 356,
            357, 335, 342, 335, 335, 335, 335, 335, 344, 358, 345, 346, 347,
            335, 359, 335, 335, 360, 362, 363, 348, 335,

            349, 351, 352, 353, 356, 357, 335, 365, 335, 335, 335, 335, 335,
            366, 358, 367, 369, 372, 373, 359, 374, 375, 360, 362, 363, 376,
            377, 379, 380, 381, 382, 383, 384, 386, 365, 387, 389, 390, 392,
            394, 366, 395, 367, 369, 372, 373, 396, 374, 375, 397, 398, 399,
            376, 377, 379, 380, 381, 382, 383, 384, 386, 402, 387, 389, 390,
            392, 394, 404, 395, 400, 400, 401, 403, 396, 401, 405, 397, 398,
            399, 406, 407, 408, 409, 403, 411, 412, 413, 414, 402, 417, 418,
            419, 420, 423, 404, 424, 400, 400, 401, 427,

            429, 401, 405, 430, 432, 433, 406, 407, 408, 409, 403, 411, 412,
            413, 414, 434, 417, 418, 419, 420, 423, 435, 424, 436, 437, 438,
            427, 429, 439, 440, 430, 432, 433, 441, 442, 443, 444, 447, 449,
            450, 451, 452, 434, 453, 454, 455, 456, 458, 435, 457, 436, 437,
            438, 459, 439, 460, 440, 461, 463, 465, 441, 442, 443, 444, 447,
            449, 450, 451, 452, 466, 453, 454, 455, 456, 458, 457, 466, 467,
            468, 469, 459, 470, 460, 471, 461, 463, 465, 472, 473, 474, 475,
            477, 478, 479, 480, 481, 466, 482, 483, 484,

            485, 492, 493, 466, 467, 468, 469, 494, 470, 495, 471, 496, 497,
            498, 472, 473, 474, 475, 477, 478, 479, 480, 481, 500, 482, 483,
            484, 485, 492, 493, 502, 503, 504, 508, 494, 509, 495, 510, 496,
            497, 498, 511, 512, 513, 515, 516, 517, 518, 519, 520, 500, 521,
            522, 524, 525, 523, 529, 502, 503, 504, 508, 523, 509, 506, 510,
            530, 531, 532, 511, 512, 513, 515, 516, 517, 518, 519, 520, 528,
            521, 522, 524, 525, 523, 529, 533, 534, 537, 538, 523, 539, 528,
            541, 530, 531, 532, 542, 543, 543, 543, 543,

            543, 543, 543, 544, 528, 547, 501, 550, 551, 552, 553, 533, 534,
            537, 538, 554, 539, 528, 541, 555, 556, 557, 542, 560, 563, 564,
            488, 565, 566, 567, 544, 568, 547, 550, 569, 551, 552, 553, 570,
            571, 572, 554, 573, 574, 575, 576, 555, 556, 557, 577, 560, 563,
            564, 565, 578, 566, 567, 579, 568, 580, 581, 569, 583, 584, 585,
            570, 571, 572, 586, 573, 574, 575, 576, 588, 589, 486, 577, 464,
            462, 425, 388, 578, 385, 364, 579, 595, 580, 581, 361, 583, 584,
            585, 355, 354, 596, 586, 329, 324, 318, 317,

            588, 589, 592, 597, 592, 592, 592, 592, 592, 592, 592, 593, 595,
            593, 593, 593, 593, 593, 593, 593, 594, 596, 594, 594, 594, 594,
            594, 594, 594, 599, 597, 600, 601, 603, 605, 606, 607, 608, 609,
            611, 613, 615, 616, 617, 618, 619, 620, 621, 622, 623, 625, 626,
            303, 629, 630, 631, 599, 632, 600, 601, 603, 605, 606, 607, 608,
            609, 611, 613, 615, 616, 617, 618, 619, 620, 621, 622, 623, 625,
            626, 627, 629, 630, 631, 633, 632, 634, 634, 634, 634, 634, 634,
            634, 638, 639, 635, 627, 635, 635, 635, 635,

            635, 635, 635, 640, 642, 643, 627, 644, 645, 636, 633, 636, 636,
            636, 636, 636, 636, 636, 646, 638, 639, 647, 627, 649, 650, 651,
            652, 653, 655, 656, 640, 642, 643, 657, 644, 645, 658, 659, 660,
            661, 298, 662, 663, 664, 665, 646, 666, 667, 647, 668, 649, 650,
            651, 652, 653, 655, 656, 669, 670, 671, 657, 677, 658, 292, 659,
            660, 661, 662, 291, 663, 664, 665, 271, 666, 667, 673, 668, 673,
            673, 673, 673, 673, 673, 673, 669, 670, 671, 674, 677, 674, 674,
            674, 674, 674, 674, 674, 675, 678, 675, 675,

            675, 675, 675, 675, 675, 679, 683, 684, 685, 687, 688, 689, 690,
            691, 695, 696, 697, 700, 701, 702, 703, 705, 706, 707, 678, 708,
            708, 708, 708, 708, 708, 708, 679, 683, 684, 685, 687, 688, 689,
            690, 691, 695, 696, 697, 700, 701, 702, 703, 705, 706, 707, 709,
            712, 709, 709, 709, 709, 709, 709, 709, 710, 713, 710, 710, 710,
            710, 710, 710, 710, 711, 714, 711, 711, 711, 711, 711, 711, 715,
            716, 712, 717, 718, 719, 720, 722, 723, 724, 725, 713, 726, 727,
            728, 729, 730, 731, 732, 733, 714, 734, 735,

            736, 737, 739, 740, 715, 716, 741, 717, 718, 719, 720, 722, 723,
            724, 725, 746, 726, 727, 728, 729, 730, 731, 732, 733, 269, 734,
            735, 736, 737, 739, 740, 264, 743, 741, 743, 743, 743, 743, 743,
            743, 743, 744, 746, 744, 744, 744, 744, 744, 744, 744, 745, 748,
            745, 745, 745, 745, 745, 745, 745, 750, 751, 262, 753, 755, 756,
            758, 760, 761, 762, 763, 765, 766, 767, 768, 769, 770, 261, 748,
            776, 776, 776, 776, 776, 776, 776, 258, 750, 751, 753, 253, 755,
            756, 758, 760, 761, 762, 763, 765, 766, 767,

            768, 769, 770, 777, 780, 777, 777, 777, 777, 777, 777, 777, 778,
            783, 778, 778, 778, 778, 778, 778, 778, 779, 784, 779, 779, 779,
            779, 779, 779, 786, 787, 780, 788, 790, 791, 792, 793, 794, 795,
            796, 783, 797, 798, 799, 800, 801, 224, 196, 187, 784, 167, 165,
            141, 137, 114, 23,  786, 787, 19,  788, 790, 791, 792, 793, 794,
            795, 796, 0,   797, 798, 799, 800, 801, 804, 804, 804, 804, 804,
            804, 804, 804, 804, 805, 805, 805, 805, 805, 805, 805, 805, 805,
            806, 806, 806, 806, 806, 806, 806, 806, 806,

            807, 808, 809, 810, 811, 812, 813, 814, 815, 0,   816, 817, 818,
            819, 821, 822, 823, 824, 825, 826, 827, 828, 0,   0,   0,   0,
            0,   807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 0,   817,
            818, 819, 821, 822, 823, 824, 825, 826, 827, 828, 829, 829, 829,
            829, 829, 829, 829, 830, 830, 830, 830, 830, 830, 830, 830, 830,
            831, 831, 831, 831, 831, 831, 831, 831, 831, 832, 832, 832, 832,
            832, 832, 832, 834, 832, 835, 837, 838, 840, 841, 842, 843, 846,
            848, 849, 850, 852, 853, 854, 854, 854, 854,

            854, 854, 854, 854, 856, 857, 858, 859, 834, 860, 835, 837, 838,
            840, 841, 842, 843, 846, 848, 849, 850, 852, 853, 861, 862, 863,
            864, 865, 866, 867, 868, 856, 857, 858, 859, 870, 860, 871, 871,
            871, 871, 871, 871, 871, 871, 872, 873, 874, 875, 876, 861, 862,
            863, 864, 865, 866, 867, 868, 877, 879, 880, 881, 870, 884, 886,
            886, 886, 886, 886, 886, 886, 886, 872, 873, 874, 875, 876, 890,
            891, 892, 893, 894, 895, 896, 904, 877, 879, 880, 881, 884, 899,
            899, 899, 899, 899, 899, 899, 899, 905, 907,

            910, 911, 913, 915, 890, 891, 892, 893, 894, 895, 896, 904, 917,
            918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 905, 929,
            907, 910, 911, 913, 915, 930, 931, 932, 934, 935, 937, 938, 940,
            917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 939,
            929, 942, 0,   0,   0,   0,   930, 931, 932, 934, 935, 937, 938,
            940, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   939,
            0,   0,   942, 948, 948, 948, 948, 949, 949, 949, 949, 950, 950,
            951, 0,   951, 951, 947, 947, 947, 947, 947,

            947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
            947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
            947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
            947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
            947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
            947, 947, 947};

        /* The intent behind this definition is that it'll catch
         * any uses of REJECT which flex missed.
         */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET

#include <string>

#include "parser.h"
#define yyterminate() return (END)

#define INITIAL 0
#define MATCH_STRING_STATE 1
#define MATCH_RESPONSE_CODE_STATE 2
#define SUPPORTED_METHODS_STATE 3
#define CONTENT_TYPE_STATE 4
#define SESSION_STATE 5
#define MATCH_PRESENTATION_URL 6
#define NUM_AS_HEX_MODE 7
#define MATCH_EDID_STATE 8

#ifndef YY_NO_UNISTD_H
        /* Special case for "unistd.h", since it is non-ANSI. We include it way
         * down here because we want the user's section 1 to have been scanned
         * first. The user has a chance to override it with an option.
         */
#include <unistd.h>
#endif

#define YY_EXTRA_TYPE bool

        /* Holds the entire state of the reentrant scanner. */
        struct yyguts_t {
          /* User-defined. Not touched by flex. */
          YY_EXTRA_TYPE yyextra_r;

          /* The rest are the same as the globals declared in the non-reentrant
           * scanner. */
          FILE *yyin_r, *yyout_r;
          size_t yy_buffer_stack_top;       /**< index of top of stack. */
          size_t yy_buffer_stack_max;       /**< capacity of stack. */
          YY_BUFFER_STATE* yy_buffer_stack; /**< Stack as an array. */
          char yy_hold_char;
          int yy_n_chars;
          int yyleng_r;
          char* yy_c_buf_p;
          int yy_init;
          int yy_start;
          int yy_did_buffer_switch_on_eof;
          int yy_start_stack_ptr;
          int yy_start_stack_depth;
          int* yy_start_stack;
          yy_state_type yy_last_accepting_state;
          char* yy_last_accepting_cpos;

          int yylineno_r;
          int yy_flex_debug_r;

          char* yytext_r;
          int yy_more_flag;
          int yy_more_len;

          YYSTYPE* yylval_r;

        }; /* end struct yyguts_t */

        static int yy_init_globals(yyscan_t yyscanner);

        /* This must go here because YYSTYPE and YYLTYPE are included
         * from bison output in section 1.*/
#define yylval yyg->yylval_r

        int yylex_init(yyscan_t* scanner);

        int yylex_init_extra(YY_EXTRA_TYPE user_defined, yyscan_t* scanner);

        /* Accessor methods to globals.
           These are made visible to non-reentrant scanners for convenience. */

        int yylex_destroy(yyscan_t yyscanner);

        int yyget_debug(yyscan_t yyscanner);

        void yyset_debug(int debug_flag, yyscan_t yyscanner);

        YY_EXTRA_TYPE yyget_extra(yyscan_t yyscanner);

        void yyset_extra(YY_EXTRA_TYPE user_defined, yyscan_t yyscanner);

        FILE* yyget_in(yyscan_t yyscanner);

        void yyset_in(FILE* _in_str, yyscan_t yyscanner);

        FILE* yyget_out(yyscan_t yyscanner);

        void yyset_out(FILE* _out_str, yyscan_t yyscanner);

        int yyget_leng(yyscan_t yyscanner);

        char* yyget_text(yyscan_t yyscanner);

        int yyget_lineno(yyscan_t yyscanner);

        void yyset_lineno(int _line_number, yyscan_t yyscanner);

        int yyget_column(yyscan_t yyscanner);

        void yyset_column(int _column_no, yyscan_t yyscanner);

        YYSTYPE* yyget_lval(yyscan_t yyscanner);

        void yyset_lval(YYSTYPE* yylval_param, yyscan_t yyscanner);

        /* Macros after this point can all be overridden by user definitions in
         * section 1.
         */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
        extern "C" int yywrap(yyscan_t yyscanner);
#else
        extern int yywrap(yyscan_t yyscanner);
#endif
#endif

#ifndef YY_NO_UNPUT

#endif

#ifndef yytext_ptr
        static void yy_flex_strncpy(char*,
                                    const char*,
                                    int,
                                    yyscan_t yyscanner);
#endif

#ifdef YY_NEED_STRLEN
        static int yy_flex_strlen(const char*, yyscan_t yyscanner);
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
        static int yyinput(yyscan_t yyscanner);
#else
        static int input(yyscan_t yyscanner);
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO                                        \
  do {                                              \
    if (fwrite(yytext, (size_t)yyleng, 1, yyout)) { \
    }                                               \
  } while (0)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf, result, max_size)                                     \
  if (YY_CURRENT_BUFFER_LVALUE->yy_is_interactive) {                        \
    int c = '*';                                                            \
    int n;                                                                  \
    for (n = 0; n < max_size && (c = getc(yyin)) != EOF && c != '\n'; ++n)  \
      buf[n] = (char)c;                                                     \
    if (c == '\n')                                                          \
      buf[n++] = (char)c;                                                   \
    if (c == EOF && ferror(yyin))                                           \
      YY_FATAL_ERROR("input in flex scanner failed");                       \
    result = n;                                                             \
  } else {                                                                  \
    errno = 0;                                                              \
    while ((result = (int)fread(buf, 1, (yy_size_t)max_size, yyin)) == 0 && \
           ferror(yyin)) {                                                  \
      if (errno != EINTR) {                                                 \
        YY_FATAL_ERROR("input in flex scanner failed");                     \
        break;                                                              \
      }                                                                     \
      errno = 0;                                                            \
      clearerr(yyin);                                                       \
    }                                                                       \
  }

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg , yyscanner)
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

        extern int yylex(YYSTYPE* yylval_param, yyscan_t yyscanner);

#define YY_DECL int yylex(YYSTYPE* yylval_param, yyscan_t yyscanner)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/ break;
#endif

#define YY_RULE_SETUP \
	if ( yyleng > 0 ) \
		YY_CURRENT_BUFFER_LVALUE->yy_at_bol = \
				(yytext[yyleng - 1] == '\n'); \
	YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
  yy_state_type yy_current_state;
  char *yy_cp, *yy_bp;
  int yy_act;
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;

  yylval = yylval_param;

  if (!yyg->yy_init) {
    yyg->yy_init = 1;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

                if (!yyg->yy_start)
                  yyg->yy_start = 1; /* first start state */

                if (!yyin)
                  yyin = stdin;

                if (!yyout)
                  yyout = stdout;

                if (!YY_CURRENT_BUFFER) {
                  yyensure_buffer_stack(yyscanner);
                  YY_CURRENT_BUFFER_LVALUE =
                      yy_create_buffer(yyin, YY_BUF_SIZE, yyscanner);
                }

                yy_load_buffer_state(yyscanner);
  }

  {
    while (
        /*CONSTCOND*/ 1) /* loops until end-of-file is reached */
    {
      yy_cp = yyg->yy_c_buf_p;

      /* Support of yytext. */
      *yy_cp = yyg->yy_hold_char;

      /* yy_bp points to the position in yy_ch_buf of the start of
       * the current run.
       */
      yy_bp = yy_cp;

      yy_current_state = yyg->yy_start;
      yy_current_state += YY_AT_BOL();
    yy_match:
      do {
        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
        if (yy_accept[yy_current_state]) {
          yyg->yy_last_accepting_state = yy_current_state;
          yyg->yy_last_accepting_cpos = yy_cp;
        }
        while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
          yy_current_state = (int)yy_def[yy_current_state];
          if (yy_current_state >= 948)
            yy_c = yy_meta[yy_c];
        }
        yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
        ++yy_cp;
      } while (yy_current_state != 947);
      yy_cp = yyg->yy_last_accepting_cpos;
      yy_current_state = yyg->yy_last_accepting_state;

    yy_find_action:
      yy_act = yy_accept[yy_current_state];

      YY_DO_BEFORE_ACTION;

    do_action: /* This label is used only to access EOF actions. */

      switch (yy_act) { /* beginning of action switch */
        case 0:         /* must back up */
          /* undo the effects of YY_DO_BEFORE_ACTION */
          *yy_cp = yyg->yy_hold_char;
          yy_cp = yyg->yy_last_accepting_cpos;
          yy_current_state = yyg->yy_last_accepting_state;
          goto yy_find_action;

        case 1:
          /* rule 1 can match eol */
          YY_RULE_SETUP { BEGIN(INITIAL); }
          YY_BREAK
        case 2:
          /* rule 2 can match eol */
          YY_RULE_SETUP { BEGIN(INITIAL); }
          YY_BREAK
        case 3:
          YY_RULE_SETUP { BEGIN(INITIAL); }
          YY_BREAK
        /* Convert these */
        case 4:
          YY_RULE_SETUP { return '='; }
          YY_BREAK
        case 5:
          YY_RULE_SETUP { return '-'; }
          YY_BREAK
        case 6:
          YY_RULE_SETUP { return ','; }
          YY_BREAK
        case 7:
          YY_RULE_SETUP { return '*'; }
          YY_BREAK
        case 8:
          YY_RULE_SETUP { return ';'; }
          YY_BREAK
        case 9:
          YY_RULE_SETUP { return ':'; }
          YY_BREAK
        case 10:
          YY_RULE_SETUP { return '/'; }
          YY_BREAK
        case 11:
          YY_RULE_SETUP
          return WFD_SP;
          YY_BREAK
        case 12:
          YY_RULE_SETUP
          return WFD_NONE;
          YY_BREAK
        case 13:
          YY_RULE_SETUP
          return WFD_AUDIO_CODEC_LPCM;
          YY_BREAK
        case 14:
          YY_RULE_SETUP
          return WFD_AUDIO_CODEC_AAC;
          YY_BREAK
        case 15:
          YY_RULE_SETUP
          return WFD_AUDIO_CODEC_AC3;
          YY_BREAK
        case 16:
          YY_RULE_SETUP
          return WFD_HDCP_SPEC_2_0;
          YY_BREAK
        case 17:
          YY_RULE_SETUP
          return WFD_HDCP_SPEC_2_1;
          YY_BREAK
        case 18:
          YY_RULE_SETUP
          return WFD_IP_PORT;
          YY_BREAK
        case 19:
          YY_RULE_SETUP
          return WFD_STREAM_PROFILE;
          YY_BREAK
        case 20:
          YY_RULE_SETUP
          return WFD_MODE_PLAY;
          YY_BREAK
        case 21:
          YY_RULE_SETUP
          return WFD_ROUTE_PRIMARY;
          YY_BREAK
        case 22:
          YY_RULE_SETUP
          return WFD_ROUTE_SECONDARY;
          YY_BREAK
        case 23:
          YY_RULE_SETUP
          return WFD_INPUT_CATEGORY_LIST;
          YY_BREAK
        case 24:
          YY_RULE_SETUP
          return WFD_INPUT_CATEGORY_GENERIC;
          YY_BREAK
        case 25:
          YY_RULE_SETUP
          return WFD_INPUT_CATEGORY_HIDC;
          YY_BREAK
        case 26:
          YY_RULE_SETUP
          return WFD_GENERIC_CAP_LIST;
          YY_BREAK
        case 27:
          YY_RULE_SETUP
          return WFD_INPUT_TYPE_KEYBOARD;
          YY_BREAK
        case 28:
          YY_RULE_SETUP
          return WFD_INPUT_TYPE_MOUSE;
          YY_BREAK
        case 29:
          YY_RULE_SETUP
          return WFD_INPUT_TYPE_SINGLE_TOUCH;
          YY_BREAK
        case 30:
          YY_RULE_SETUP
          return WFD_INPUT_TYPE_MULTI_TOUCH;
          YY_BREAK
        case 31:
          YY_RULE_SETUP
          return WFD_INPUT_TYPE_JOYSTICK;
          YY_BREAK
        case 32:
          YY_RULE_SETUP
          return WFD_INPUT_TYPE_CAMERA;
          YY_BREAK
        case 33:
          YY_RULE_SETUP
          return WFD_INPUT_TYPE_GESTURE;
          YY_BREAK
        case 34:
          YY_RULE_SETUP
          return WFD_INPUT_TYPE_REMOTE_CONTROL;
          YY_BREAK
        case 35:
          YY_RULE_SETUP
          return WFD_HIDC_CAP_LIST;
          YY_BREAK
        case 36:
          YY_RULE_SETUP
          return WFD_INPUT_PATH_INFRARED;
          YY_BREAK
        case 37:
          YY_RULE_SETUP
          return WFD_INPUT_PATH_USB;
          YY_BREAK
        case 38:
          YY_RULE_SETUP
          return WFD_INPUT_PATH_BT;
          YY_BREAK
        case 39:
          YY_RULE_SETUP
          return WFD_INPUT_PATH_WIFI;
          YY_BREAK
        case 40:
          YY_RULE_SETUP
          return WFD_INPUT_PATH_ZIGBEE;
          YY_BREAK
        case 41:
          YY_RULE_SETUP
          return WFD_INPUT_PATH_NOSP;
          YY_BREAK
        case 42:
          YY_RULE_SETUP
          return WFD_UIBC_SETTING_DISABLE;
          YY_BREAK
        case 43:
          YY_RULE_SETUP
          return WFD_UIBC_SETTING_ENABLE;
          YY_BREAK
        case 44:
          YY_RULE_SETUP
          return WFD_SUPPORTED;
          YY_BREAK
        case 45:
          YY_RULE_SETUP {
            std::string str(yytext, yyleng);
            str += '\0';
            errno = 0;
            yylval->nval = strtoull(str.c_str(), NULL, 16);
            if (errno)
              yyterminate();
            return WFD_NUM;
          }
          YY_BREAK
        case 46:
          YY_RULE_SETUP {
            std::string str(yytext, yyleng);
            str += '\0';
            errno = 0;
            yylval->nval = strtoull(str.c_str(), NULL, 16);
            if (errno)
              yyterminate();
            return WFD_NUM;
          }
          YY_BREAK
        case 47:
          YY_RULE_SETUP {
            yylval->sval = new std::string(yytext);
            return WFD_STRING;
          }
          YY_BREAK
        case 48:
          YY_RULE_SETUP {
            yylval->sval = new std::string(yytext);
            return WFD_STRING;
          }
          YY_BREAK
        case 49:
          YY_RULE_SETUP {
            BEGIN(NUM_AS_HEX_MODE);
            return WFD_AUDIO_CODECS;
          }
          YY_BREAK
        case 50:
          YY_RULE_SETUP {
            BEGIN(NUM_AS_HEX_MODE);
            return WFD_VIDEO_FORMATS;
          }
          YY_BREAK
        case 51:
          YY_RULE_SETUP {
            BEGIN(NUM_AS_HEX_MODE);
            return WFD_3D_FORMATS;
          }
          YY_BREAK
        case 52:
          YY_RULE_SETUP { return WFD_CONTENT_PROTECTION; }
          YY_BREAK
        case 53:
          YY_RULE_SETUP {
            BEGIN(MATCH_EDID_STATE);
            return WFD_DISPLAY_EDID;
          }
          YY_BREAK
        case 54:
          YY_RULE_SETUP {
            BEGIN(NUM_AS_HEX_MODE);
            return WFD_COUPLED_SINK;
          }
          YY_BREAK
        case 55:
          YY_RULE_SETUP {
            BEGIN(SUPPORTED_METHODS_STATE);
            return WFD_TRIGGER_METHOD;
          }
          YY_BREAK
        case 56:
          YY_RULE_SETUP {
            BEGIN(MATCH_PRESENTATION_URL);
            return WFD_PRESENTATION_URL;
          }
          YY_BREAK
        case 57:
          YY_RULE_SETUP { return WFD_CLIENT_RTP_PORTS; }
          YY_BREAK
        case 58:
          YY_RULE_SETUP { return WFD_ROUTE; }
          YY_BREAK
        case 59:
          YY_RULE_SETUP { return WFD_I2C; }
          YY_BREAK
        case 60:
          YY_RULE_SETUP {
            BEGIN(NUM_AS_HEX_MODE);
            return WFD_AV_FORMAT_CHANGE_TIMING;
          }
          YY_BREAK
        case 61:
          YY_RULE_SETUP {
            BEGIN(NUM_AS_HEX_MODE);
            return WFD_PREFERRED_DISPLAY_MODE;
          }
          YY_BREAK
        case 62:
          YY_RULE_SETUP { return WFD_UIBC_CAPABILITY; }
          YY_BREAK
        case 63:
          YY_RULE_SETUP { return WFD_UIBC_SETTING; }
          YY_BREAK
        case 64:
          YY_RULE_SETUP { return WFD_STANDBY_RESUME_CAPABILITY; }
          YY_BREAK
        case 65:
          YY_RULE_SETUP {
            if (yyextra)  // Is reply.
              return WFD_STANDBY_IN_RESPONSE;
            return WFD_STANDBY_IN_REQUEST;
          }
          YY_BREAK
        case 66:
          YY_RULE_SETUP {
            BEGIN(NUM_AS_HEX_MODE);
            return WFD_CONNECTOR_TYPE;
          }
          YY_BREAK
        case 67:
          YY_RULE_SETUP { return WFD_IDR_REQUEST; }
          YY_BREAK
        case 68:
          YY_RULE_SETUP {
            BEGIN(MATCH_STRING_STATE);
            yylval->sval = new std::string(yytext, yyleng);
            return WFD_GENERIC_PROPERTY;
          }
          YY_BREAK
        case 69:
          YY_RULE_SETUP {
            std::string str(yytext, yyleng);
            str += '\0';
            errno = 0;
            yylval->nval = strtoull(str.c_str(), NULL, 10);
            if (errno)
              yyterminate();
            return WFD_NUM;
          }
          YY_BREAK
        case 70:
          /* rule 70 can match eol */
          *yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 2);
          yyg->yy_c_buf_p = yy_cp -= 2;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP {
            BEGIN(INITIAL);
            yylval->sval = new std::string(yytext);
            return WFD_STRING;
          }
          YY_BREAK
        case 71:
          YY_RULE_SETUP { return WFD_OPTIONS; }
          YY_BREAK
        case 72:
          YY_RULE_SETUP { return WFD_SET_PARAMETER; }
          YY_BREAK
        case 73:
          YY_RULE_SETUP { return WFD_GET_PARAMETER; }
          YY_BREAK
        case 74:
          YY_RULE_SETUP { return WFD_SETUP; }
          YY_BREAK
        case 75:
          YY_RULE_SETUP { return WFD_PLAY; }
          YY_BREAK
        case 76:
          YY_RULE_SETUP { return WFD_TEARDOWN; }
          YY_BREAK
        case 77:
          YY_RULE_SETUP { return WFD_PAUSE; }
          YY_BREAK
        case 78:
          YY_RULE_SETUP { return WFD_TAG; }
          YY_BREAK
        case 79:
          YY_RULE_SETUP {
            yylval->sval = new std::string(yytext);
            return WFD_PRESENTATION_URL_0;
          }
          YY_BREAK
        case 80:
          YY_RULE_SETUP {
            yylval->sval = new std::string(yytext);
            return WFD_PRESENTATION_URL_1;
          }
          YY_BREAK
        /* all unmatched */
        case 81:
          YY_RULE_SETUP {}
          YY_BREAK
        case 82:
          YY_RULE_SETUP
          YY_FATAL_ERROR("flex scanner jammed");
          YY_BREAK
        case YY_STATE_EOF(INITIAL):
        case YY_STATE_EOF(MATCH_STRING_STATE):
        case YY_STATE_EOF(MATCH_RESPONSE_CODE_STATE):
        case YY_STATE_EOF(SUPPORTED_METHODS_STATE):
        case YY_STATE_EOF(CONTENT_TYPE_STATE):
        case YY_STATE_EOF(SESSION_STATE):
        case YY_STATE_EOF(MATCH_PRESENTATION_URL):
        case YY_STATE_EOF(NUM_AS_HEX_MODE):
        case YY_STATE_EOF(MATCH_EDID_STATE):
          yyterminate();

        case YY_END_OF_BUFFER: {
          /* Amount of text matched not including the EOB char. */
          int yy_amount_of_matched_text = (int)(yy_cp - yyg->yytext_ptr) - 1;

          /* Undo the effects of YY_DO_BEFORE_ACTION. */
          *yy_cp = yyg->yy_hold_char;
          YY_RESTORE_YY_MORE_OFFSET

          if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW) {
            /* We're scanning a new file or input source.  It's
             * possible that this happened because the user
             * just pointed yyin at a new source and called
             * yylex().  If so, then we have to assure
             * consistency between YY_CURRENT_BUFFER and our
             * globals.  Here is the right place to do so, because
             * this is the first action (other than possibly a
             * back-up) that will match for the new input source.
             */
            yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
            YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
            YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
          }

          /* Note that here we test for yy_c_buf_p "<=" to the position
           * of the first EOB in the buffer, since yy_c_buf_p will
           * already have been incremented past the NUL character
           * (since all states make transitions on EOB to the
           * end-of-buffer state).  Contrast this with the test
           * in input().
           */
          if (yyg->yy_c_buf_p <=
              &YY_CURRENT_BUFFER_LVALUE
                   ->yy_ch_buf[yyg->yy_n_chars]) { /* This was really a NUL. */
            yy_state_type yy_next_state;

            yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

            yy_current_state = yy_get_previous_state(yyscanner);

            /* Okay, we're now positioned to make the NUL
             * transition.  We couldn't have
             * yy_get_previous_state() go ahead and do it
             * for us because it doesn't know how to deal
             * with the possibility of jamming (and we don't
             * want to build jamming into it because then it
             * will run more slowly).
             */

            yy_next_state = yy_try_NUL_trans(yy_current_state, yyscanner);

            yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;

            if (yy_next_state) {
              /* Consume the NUL. */
              yy_cp = ++yyg->yy_c_buf_p;
              yy_current_state = yy_next_state;
              goto yy_match;
            }

            else {
              yy_cp = yyg->yy_last_accepting_cpos;
              yy_current_state = yyg->yy_last_accepting_state;
              goto yy_find_action;
            }
          }

          else
            switch (yy_get_next_buffer(yyscanner)) {
              case EOB_ACT_END_OF_FILE: {
                yyg->yy_did_buffer_switch_on_eof = 0;

                if (yywrap(yyscanner)) {
                  /* Note: because we've taken care in
                   * yy_get_next_buffer() to have set up
                   * yytext, we can now set up
                   * yy_c_buf_p so that if some total
                   * hoser (like flex itself) wants to
                   * call the scanner after we return the
                   * YY_NULL, it'll still work - another
                   * YY_NULL will get returned.
                   */
                  yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;

                  yy_act = YY_STATE_EOF(YY_START);
                  goto do_action;
                }

                else {
                  if (!yyg->yy_did_buffer_switch_on_eof)
                    YY_NEW_FILE;
                }
                break;
              }

              case EOB_ACT_CONTINUE_SCAN:
                yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

                yy_current_state = yy_get_previous_state(yyscanner);

                yy_cp = yyg->yy_c_buf_p;
                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
                goto yy_match;

              case EOB_ACT_LAST_MATCH:
                yyg->yy_c_buf_p =
                    &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

                yy_current_state = yy_get_previous_state(yyscanner);

                yy_cp = yyg->yy_c_buf_p;
                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
                goto yy_find_action;
            }
          break;
        }

        default:
          YY_FATAL_ERROR("fatal flex scanner internal error--no action found");
      } /* end of action switch */
    }   /* end of scanning one token */
  }     /* end of user's declarations */
} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    char* dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
    char* source = yyg->yytext_ptr;
    int number_to_move, i;
    int ret_val;

    if (yyg->yy_c_buf_p >
        &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1])
      YY_FATAL_ERROR("fatal flex scanner internal error--end of buffer missed");

    if (YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer ==
        0) { /* Don't try to fill the buffer, so this is an EOF. */
      if (yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1) {
        /* We matched a single character, the EOB, so
         * treat this as a final EOF.
         */
        return EOB_ACT_END_OF_FILE;
      }

      else {
        /* We matched some text prior to the EOB, first
         * process it.
         */
        return EOB_ACT_LAST_MATCH;
      }
    }

    /* Try to read more data. */

    /* First move last chars to start of buffer. */
    number_to_move = (int)(yyg->yy_c_buf_p - yyg->yytext_ptr - 1);

    for (i = 0; i < number_to_move; ++i)
      *(dest++) = *(source++);

    if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING)
      /* don't do the read, it's not guaranteed to return an EOF,
       * just force an EOF
       */
      YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

    else {
      int num_to_read =
          YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

      while (num_to_read <= 0) { /* Not enough room in the buffer - grow it. */

        /* just a shorter name for the current buffer */
        YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

        int yy_c_buf_p_offset = (int)(yyg->yy_c_buf_p - b->yy_ch_buf);

        if (b->yy_is_our_buffer) {
          int new_size = b->yy_buf_size * 2;

          if (new_size <= 0)
            b->yy_buf_size += b->yy_buf_size / 8;
          else
            b->yy_buf_size *= 2;

          b->yy_ch_buf = (char*)
              /* Include room in for 2 EOB chars. */
              yyrealloc((void*)b->yy_ch_buf, (yy_size_t)(b->yy_buf_size + 2),
                        yyscanner);
        } else
          /* Can't grow it, we don't own it. */
          b->yy_ch_buf = NULL;

        if (!b->yy_ch_buf)
          YY_FATAL_ERROR("fatal error - scanner input buffer overflow");

        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

        num_to_read =
            YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
      }

      if (num_to_read > YY_READ_BUF_SIZE)
        num_to_read = YY_READ_BUF_SIZE;

      /* Read in more data. */
      YY_INPUT((&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
               yyg->yy_n_chars, num_to_read);

      YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
    }

    if (yyg->yy_n_chars == 0) {
      if (number_to_move == YY_MORE_ADJ) {
        ret_val = EOB_ACT_END_OF_FILE;
        yyrestart(yyin, yyscanner);
      }

      else {
        ret_val = EOB_ACT_LAST_MATCH;
        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_EOF_PENDING;
      }
    }

    else
      ret_val = EOB_ACT_CONTINUE_SCAN;

    if ((yyg->yy_n_chars + number_to_move) >
        YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
      /* Extend the array by 50%, plus the number we really need. */
      int new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
      YY_CURRENT_BUFFER_LVALUE->yy_ch_buf =
          (char*)yyrealloc((void*)YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,
                           (yy_size_t)new_size, yyscanner);
      if (!YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
        YY_FATAL_ERROR("out of dynamic memory in yy_get_next_buffer()");
      /* "- 2" to take care of EOB's */
      YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int)(new_size - 2);
    }

    yyg->yy_n_chars += number_to_move;
    YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] =
        YY_END_OF_BUFFER_CHAR;
    YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] =
        YY_END_OF_BUFFER_CHAR;

    yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

    return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
      yy_state_type yy_current_state;
      char* yy_cp;
      struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;

      yy_current_state = yyg->yy_start;
      yy_current_state += YY_AT_BOL();

      for (yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p;
           ++yy_cp) {
        YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
        if (yy_accept[yy_current_state]) {
          yyg->yy_last_accepting_state = yy_current_state;
          yyg->yy_last_accepting_cpos = yy_cp;
        }
        while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
          yy_current_state = (int)yy_def[yy_current_state];
          if (yy_current_state >= 948)
            yy_c = yy_meta[yy_c];
        }
        yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
      }

      return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
      int yy_is_jam;
      struct yyguts_t* yyg = (struct yyguts_t*)
          yyscanner; /* This var may be unused depending upon options. */
      char* yy_cp = yyg->yy_c_buf_p;

      YY_CHAR yy_c = 1;
      if (yy_accept[yy_current_state]) {
        yyg->yy_last_accepting_state = yy_current_state;
        yyg->yy_last_accepting_cpos = yy_cp;
      }
      while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
        yy_current_state = (int)yy_def[yy_current_state];
        if (yy_current_state >= 948)
          yy_c = yy_meta[yy_c];
      }
      yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
      yy_is_jam = (yy_current_state == 947);

      (void)yyg;
      return yy_is_jam ? 0 : yy_current_state;
    }

#ifndef YY_NO_UNPUT

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
#else
    static int input  (yyscan_t yyscanner)
#endif

{
	int c;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	*yyg->yy_c_buf_p = yyg->yy_hold_char;

	if ( *yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
		{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
			/* This was really a NUL. */
			*yyg->yy_c_buf_p = '\0';

		else
			{ /* need more input */
                  int offset = (int)(yyg->yy_c_buf_p - yyg->yytext_ptr);
                  ++yyg->yy_c_buf_p;

                  switch (yy_get_next_buffer(yyscanner)) {
                    case EOB_ACT_LAST_MATCH:
                      /* This happens because yy_g_n_b()
                       * sees that we've accumulated a
                       * token and flags that we need to
                       * try matching the token before
                       * proceeding.  But for input(),
                       * there's no matching to consider.
                       * So convert the EOB_ACT_LAST_MATCH
                       * to EOB_ACT_END_OF_FILE.
                       */

                      /* Reset buffer status. */
                      yyrestart(yyin, yyscanner);

                      /*FALLTHROUGH*/

                    case EOB_ACT_END_OF_FILE: {
                      if (yywrap(yyscanner))
                        return 0;

                      if (!yyg->yy_did_buffer_switch_on_eof)
                        YY_NEW_FILE;
#ifdef __cplusplus
					return yyinput(yyscanner);
#else
					return input(yyscanner);
#endif
                    }

                    case EOB_ACT_CONTINUE_SCAN:
                      yyg->yy_c_buf_p = yyg->yytext_ptr + offset;
                      break;
                  }
                }
        }

        c = *(unsigned char*)yyg->yy_c_buf_p; /* cast for 8-bit char's */
        *yyg->yy_c_buf_p = '\0';              /* preserve yytext */
        yyg->yy_hold_char = *++yyg->yy_c_buf_p;

        YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');

        return c;
}
#endif	/* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 * @param yyscanner The scanner object.
 * @note This function does not reset the start condition to @c INITIAL .
 */
void yyrestart(FILE* input_file, yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;

  if (!YY_CURRENT_BUFFER) {
    yyensure_buffer_stack(yyscanner);
    YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE, yyscanner);
  }

  yy_init_buffer(YY_CURRENT_BUFFER, input_file, yyscanner);
  yy_load_buffer_state(yyscanner);
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 * @param yyscanner The scanner object.
 */
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer, yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;

  /* TODO. We should be able to replace this entire function body
   * with
   *		yypop_buffer_state();
   *		yypush_buffer_state(new_buffer);
   */
  yyensure_buffer_stack(yyscanner);
  if (YY_CURRENT_BUFFER == new_buffer)
    return;

  if (YY_CURRENT_BUFFER) {
    /* Flush out information for old buffer. */
    *yyg->yy_c_buf_p = yyg->yy_hold_char;
    YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
  }

  YY_CURRENT_BUFFER_LVALUE = new_buffer;
  yy_load_buffer_state(yyscanner);

  /* We don't actually know whether we did this switch during
   * EOF (yywrap()) processing, but the only time this flag
   * is looked at is after yywrap() is called, so it's safe
   * to go ahead and always set it.
   */
  yyg->yy_did_buffer_switch_on_eof = 1;
}

static void yy_load_buffer_state(yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;
  yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
  yyg->yytext_ptr = yyg->yy_c_buf_p = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
  yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
  yyg->yy_hold_char = *yyg->yy_c_buf_p;
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 * @param yyscanner The scanner object.
 * @return the allocated buffer state.
 */
YY_BUFFER_STATE yy_create_buffer(FILE* file, int size, yyscan_t yyscanner) {
  YY_BUFFER_STATE b;

  b = (YY_BUFFER_STATE)yyalloc(sizeof(struct yy_buffer_state), yyscanner);
  if (!b)
    YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

  b->yy_buf_size = size;

  /* yy_ch_buf has to be 2 characters longer than the size given because
   * we need to put in 2 end-of-buffer characters.
   */
  b->yy_ch_buf = (char*)yyalloc((yy_size_t)(b->yy_buf_size + 2), yyscanner);
  if (!b->yy_ch_buf)
    YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

  b->yy_is_our_buffer = 1;

  yy_init_buffer(b, file, yyscanner);

  return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 * @param yyscanner The scanner object.
 */
void yy_delete_buffer(YY_BUFFER_STATE b, yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;

  if (!b)
    return;

  if (b == YY_CURRENT_BUFFER) /* Not sure if we should pop here. */
    YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE)0;

  if (b->yy_is_our_buffer)
    yyfree((void*)b->yy_ch_buf, yyscanner);

  yyfree((void*)b, yyscanner);
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
static void yy_init_buffer(YY_BUFFER_STATE b, FILE* file, yyscan_t yyscanner)

{
  int oerrno = errno;
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;

  yy_flush_buffer(b, yyscanner);

  b->yy_input_file = file;
  b->yy_fill_buffer = 1;

  /* If b is the current buffer, then yy_init_buffer was _probably_
   * called from yyrestart() or through yy_get_next_buffer.
   * In that case, we don't want to reset the lineno or column.
   */
  if (b != YY_CURRENT_BUFFER) {
    b->yy_bs_lineno = 1;
    b->yy_bs_column = 0;
  }

  b->yy_is_interactive = 0;

  errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 * @param yyscanner The scanner object.
 */
void yy_flush_buffer(YY_BUFFER_STATE b, yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;
  if (!b)
    return;

  b->yy_n_chars = 0;

  /* We always need two end-of-buffer characters.  The first causes
   * a transition to the end-of-buffer state.  The second causes
   * a jam in that state.
   */
  b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
  b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

  b->yy_buf_pos = &b->yy_ch_buf[0];

  b->yy_at_bol = 1;
  b->yy_buffer_status = YY_BUFFER_NEW;

  if (b == YY_CURRENT_BUFFER)
    yy_load_buffer_state(yyscanner);
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *  @param yyscanner The scanner object.
 */
void yypush_buffer_state(YY_BUFFER_STATE new_buffer, yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;
  if (new_buffer == NULL)
    return;

  yyensure_buffer_stack(yyscanner);

  /* This block is copied from yy_switch_to_buffer. */
  if (YY_CURRENT_BUFFER) {
    /* Flush out information for old buffer. */
    *yyg->yy_c_buf_p = yyg->yy_hold_char;
    YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
  }

  /* Only push if top exists. Otherwise, replace top. */
  if (YY_CURRENT_BUFFER)
    yyg->yy_buffer_stack_top++;
  YY_CURRENT_BUFFER_LVALUE = new_buffer;

  /* copied from yy_switch_to_buffer. */
  yy_load_buffer_state(yyscanner);
  yyg->yy_did_buffer_switch_on_eof = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *  @param yyscanner The scanner object.
 */
void yypop_buffer_state(yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;
  if (!YY_CURRENT_BUFFER)
    return;

  yy_delete_buffer(YY_CURRENT_BUFFER, yyscanner);
  YY_CURRENT_BUFFER_LVALUE = NULL;
  if (yyg->yy_buffer_stack_top > 0)
    --yyg->yy_buffer_stack_top;

  if (YY_CURRENT_BUFFER) {
    yy_load_buffer_state(yyscanner);
    yyg->yy_did_buffer_switch_on_eof = 1;
  }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void yyensure_buffer_stack(yyscan_t yyscanner) {
  yy_size_t num_to_alloc;
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;

  if (!yyg->yy_buffer_stack) {
    /* First allocation is just for 2 elements, since we don't know if this
     * scanner will even need a stack. We use 2 instead of 1 to avoid an
     * immediate realloc on the next call.
     */
    num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
    yyg->yy_buffer_stack = (struct yy_buffer_state**)yyalloc(
        num_to_alloc * sizeof(struct yy_buffer_state*), yyscanner);
    if (!yyg->yy_buffer_stack)
      YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");

    memset(yyg->yy_buffer_stack, 0,
           num_to_alloc * sizeof(struct yy_buffer_state*));

    yyg->yy_buffer_stack_max = num_to_alloc;
    yyg->yy_buffer_stack_top = 0;
    return;
  }

  if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1) {
    /* Increase the buffer to prepare for a possible push. */
    yy_size_t grow_size = 8 /* arbitrary grow size */;

    num_to_alloc = yyg->yy_buffer_stack_max + grow_size;
    yyg->yy_buffer_stack = (struct yy_buffer_state**)yyrealloc(
        yyg->yy_buffer_stack, num_to_alloc * sizeof(struct yy_buffer_state*),
        yyscanner);
    if (!yyg->yy_buffer_stack)
      YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");

    /* zero only the new slots.*/
    memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0,
           grow_size * sizeof(struct yy_buffer_state*));
    yyg->yy_buffer_stack_max = num_to_alloc;
  }
}

/** Setup the input buffer state to scan directly from a user-specified
 * character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_buffer(char* base, yy_size_t size, yyscan_t yyscanner) {
  YY_BUFFER_STATE b;

  if (size < 2 || base[size - 2] != YY_END_OF_BUFFER_CHAR ||
      base[size - 1] != YY_END_OF_BUFFER_CHAR)
    /* They forgot to leave room for the EOB's. */
    return NULL;

  b = (YY_BUFFER_STATE)yyalloc(sizeof(struct yy_buffer_state), yyscanner);
  if (!b)
    YY_FATAL_ERROR("out of dynamic memory in yy_scan_buffer()");

  b->yy_buf_size = (int)(size - 2); /* "- 2" to take care of EOB's */
  b->yy_buf_pos = b->yy_ch_buf = base;
  b->yy_is_our_buffer = 0;
  b->yy_input_file = NULL;
  b->yy_n_chars = b->yy_buf_size;
  b->yy_is_interactive = 0;
  b->yy_at_bol = 1;
  b->yy_fill_buffer = 0;
  b->yy_buffer_status = YY_BUFFER_NEW;

  yy_switch_to_buffer(b, yyscanner);

  return b;
}

/** Setup the input buffer state to scan a string. The next call to yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       yy_scan_bytes() instead.
 */
YY_BUFFER_STATE yy_scan_string(const char* yystr, yyscan_t yyscanner) {
  return yy_scan_bytes(yystr, (int)strlen(yystr), yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to
 * yylex() will scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_bytes(const char* yybytes,
                              int _yybytes_len,
                              yyscan_t yyscanner) {
  YY_BUFFER_STATE b;
  char* buf;
  yy_size_t n;
  int i;

  /* Get memory for full buffer, including space for trailing EOB's. */
  n = (yy_size_t)(_yybytes_len + 2);
  buf = (char*)yyalloc(n, yyscanner);
  if (!buf)
    YY_FATAL_ERROR("out of dynamic memory in yy_scan_bytes()");

  for (i = 0; i < _yybytes_len; ++i)
    buf[i] = yybytes[i];

  buf[_yybytes_len] = buf[_yybytes_len + 1] = YY_END_OF_BUFFER_CHAR;

  b = yy_scan_buffer(buf, n, yyscanner);
  if (!b)
    YY_FATAL_ERROR("bad buffer in yy_scan_bytes()");

  /* It's okay to grow etc. this buffer, and we should throw it
   * away when we're done.
   */
  b->yy_is_our_buffer = 1;

  return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error(const char* msg, yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;
  (void)yyg;
  fprintf(stderr, "%s\n", msg);
  exit(YY_EXIT_FAILURE);
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		yytext[yyleng] = yyg->yy_hold_char; \
		yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
		yyg->yy_hold_char = *yyg->yy_c_buf_p; \
		*yyg->yy_c_buf_p = '\0'; \
		yyleng = yyless_macro_arg; \
		} \
	while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

/** Get the user-defined data for this scanner.
 * @param yyscanner The scanner object.
 */
YY_EXTRA_TYPE yyget_extra(yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;
  return yyextra;
}

/** Get the current line number.
 * @param yyscanner The scanner object.
 */
int yyget_lineno(yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;

  if (!YY_CURRENT_BUFFER)
    return 0;

  return yylineno;
}

/** Get the current column number.
 * @param yyscanner The scanner object.
 */
int yyget_column(yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;

  if (!YY_CURRENT_BUFFER)
    return 0;

  return yycolumn;
}

/** Get the input stream.
 * @param yyscanner The scanner object.
 */
FILE* yyget_in(yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;
  return yyin;
}

/** Get the output stream.
 * @param yyscanner The scanner object.
 */
FILE* yyget_out(yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;
  return yyout;
}

/** Get the length of the current token.
 * @param yyscanner The scanner object.
 */
int yyget_leng(yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;
  return yyleng;
}

/** Get the current token.
 * @param yyscanner The scanner object.
 */

char* yyget_text(yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;
  return yytext;
}

/** Set the user-defined data. This data is never touched by the scanner.
 * @param user_defined The data to be associated with this scanner.
 * @param yyscanner The scanner object.
 */
void yyset_extra(YY_EXTRA_TYPE user_defined, yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;
  yyextra = user_defined;
}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void yyset_lineno(int _line_number, yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;

  /* lineno is only valid if an input buffer exists. */
  if (!YY_CURRENT_BUFFER)
    YY_FATAL_ERROR("yyset_lineno called with no buffer");

  yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void yyset_column(int _column_no, yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;

  /* column is only valid if an input buffer exists. */
  if (!YY_CURRENT_BUFFER)
    YY_FATAL_ERROR("yyset_column called with no buffer");

  yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see yy_switch_to_buffer
 */
void yyset_in(FILE* _in_str, yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;
  yyin = _in_str;
}

void yyset_out(FILE* _out_str, yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;
  yyout = _out_str;
}

int yyget_debug(yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;
  return yy_flex_debug;
}

void yyset_debug(int _bdebug, yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;
  yy_flex_debug = _bdebug;
}

/* Accessor methods for yylval and yylloc */

YYSTYPE* yyget_lval(yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;
  return yylval;
}

void yyset_lval(YYSTYPE* yylval_param, yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;
  yylval = yylval_param;
}

/* User-visible API */

/* yylex_init is special because it creates the scanner itself, so it is
 * the ONLY reentrant function that doesn't take the scanner as the last
 * argument. That's why we explicitly handle the declaration, instead of using
 * our macros.
 */
int yylex_init(yyscan_t* ptr_yy_globals) {
  if (ptr_yy_globals == NULL) {
    errno = EINVAL;
    return 1;
  }

  *ptr_yy_globals = (yyscan_t)yyalloc(sizeof(struct yyguts_t), NULL);

  if (*ptr_yy_globals == NULL) {
    errno = ENOMEM;
    return 1;
  }

  /* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for
   * releases. */
  memset(*ptr_yy_globals, 0x00, sizeof(struct yyguts_t));

  return yy_init_globals(*ptr_yy_globals);
}

/* yylex_init_extra has the same functionality as yylex_init, but follows the
 * convention of taking the scanner as the last argument. Note however, that
 * this is a *pointer* to a scanner, as it will be allocated by this call (and
 * is the reason, too, why this function also must handle its own declaration).
 * The user defined value in the first argument will be available to yyalloc in
 * the yyextra field.
 */
int yylex_init_extra(YY_EXTRA_TYPE yy_user_defined, yyscan_t* ptr_yy_globals) {
  struct yyguts_t dummy_yyguts;

  yyset_extra(yy_user_defined, &dummy_yyguts);

  if (ptr_yy_globals == NULL) {
    errno = EINVAL;
    return 1;
  }

  *ptr_yy_globals = (yyscan_t)yyalloc(sizeof(struct yyguts_t), &dummy_yyguts);

  if (*ptr_yy_globals == NULL) {
    errno = ENOMEM;
    return 1;
  }

  /* By setting to 0xAA, we expose bugs in
  yy_init_globals. Leave at 0x00 for releases. */
  memset(*ptr_yy_globals, 0x00, sizeof(struct yyguts_t));

  yyset_extra(yy_user_defined, *ptr_yy_globals);

  return yy_init_globals(*ptr_yy_globals);
}

static int yy_init_globals (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    /* Initialization is the same as for the non-reentrant scanner.
     * This function is called from yylex_destroy(), so don't allocate here.
     */

    yyg->yy_buffer_stack = NULL;
    yyg->yy_buffer_stack_top = 0;
    yyg->yy_buffer_stack_max = 0;
    yyg->yy_c_buf_p = NULL;
    yyg->yy_init = 0;
    yyg->yy_start = 0;

    yyg->yy_start_stack_ptr = 0;
    yyg->yy_start_stack_depth = 0;
    yyg->yy_start_stack =  NULL;

/* Defined in main.c */
#ifdef YY_STDINIT
    yyin = stdin;
    yyout = stdout;
#else
  yyin = NULL;
  yyout = NULL;
#endif

    /* For future reference: Set errno on error, since we are called by
     * yylex_init()
     */
    return 0;
}

/* yylex_destroy is for both reentrant and non-reentrant scanners. */
int yylex_destroy(yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;

  /* Pop the buffer stack, destroying each element. */
  while (YY_CURRENT_BUFFER) {
    yy_delete_buffer(YY_CURRENT_BUFFER, yyscanner);
    YY_CURRENT_BUFFER_LVALUE = NULL;
    yypop_buffer_state(yyscanner);
  }

  /* Destroy the stack itself. */
  yyfree(yyg->yy_buffer_stack, yyscanner);
  yyg->yy_buffer_stack = NULL;

  /* Destroy the start condition stack. */
  yyfree(yyg->yy_start_stack, yyscanner);
  yyg->yy_start_stack = NULL;

  /* Reset the globals. This is important in a non-reentrant scanner so the next
   * time yylex() is called, initialization will occur. */
  yy_init_globals(yyscanner);

  /* Destroy the main struct (reentrant only). */
  yyfree(yyscanner, yyscanner);
  yyscanner = NULL;
  return 0;
}

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy(char* s1,
                            const char* s2,
                            int n,
                            yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;
  (void)yyg;

  int i;
  for (i = 0; i < n; ++i)
    s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen(const char* s, yyscan_t yyscanner) {
  int n;
  for (n = 0; s[n]; ++n)
    ;

  return n;
}
#endif

void* yyalloc(yy_size_t size, yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;
  (void)yyg;
  return malloc(size);
}

void* yyrealloc(void* ptr, yy_size_t size, yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;
  (void)yyg;

  /* The cast to (char *) in the following accommodates both
   * implementations that use char* generic pointers, and those
   * that use void* generic pointers.  It works with the latter
   * because both ANSI C and C++ allow castless assignment from
   * any pointer type to void*, and deal with argument conversions
   * as though doing an assignment.
   */
  return realloc(ptr, size);
}

void yyfree(void* ptr, yyscan_t yyscanner) {
  struct yyguts_t* yyg = (struct yyguts_t*)yyscanner;
  (void)yyg;
  free((char*)ptr); /* see yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"
