<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vulkan Memory Allocator: vk_mem_alloc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vulkan Memory Allocator
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vk_mem_alloc.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;vulkan/vulkan.h&gt;</code><br />
</div>
<p><a href="vk__mem__alloc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_device_memory_callbacks.html">VmaDeviceMemoryCallbacks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of callbacks that the library will call for <code>vkAllocateMemory</code> and <code>vkFreeMemory</code>.  <a href="struct_vma_device_memory_callbacks.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_vulkan_functions.html">VmaVulkanFunctions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointers to some Vulkan functions - a subset used by the library.  <a href="struct_vma_vulkan_functions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_record_settings.html">VmaRecordSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for recording calls to VMA functions. To be used in <a class="el" href="struct_vma_allocator_create_info.html#ace2aa4877b16a42b0b7673d4e26000ee" title="Parameters for recording of VMA calls. Can be null.">VmaAllocatorCreateInfo::pRecordSettings</a>.  <a href="struct_vma_record_settings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_allocator_create_info.html">VmaAllocatorCreateInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of a Allocator to be created.  <a href="struct_vma_allocator_create_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_allocator_info.html">VmaAllocatorInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about existing <a class="el" href="struct_vma_allocator.html" title="Represents main object of this library initialized.">VmaAllocator</a> object.  <a href="struct_vma_allocator_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_stat_info.html">VmaStatInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculated statistics of memory usage in entire allocator.  <a href="struct_vma_stat_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_stats.html">VmaStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General statistics from current state of Allocator.  <a href="struct_vma_stats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_budget.html">VmaBudget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics of current memory usage and available budget, in bytes, for specific memory heap.  <a href="struct_vma_budget.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_pool_create_info.html">VmaPoolCreateInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes parameter of created <a class="el" href="struct_vma_pool.html" title="Represents custom memory pool.">VmaPool</a>.  <a href="struct_vma_pool_create_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_pool_stats.html">VmaPoolStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes parameter of existing <a class="el" href="struct_vma_pool.html" title="Represents custom memory pool.">VmaPool</a>.  <a href="struct_vma_pool_stats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters of <a class="el" href="struct_vma_allocation.html" title="Represents single memory allocation.">VmaAllocation</a> objects, that can be retrieved using function <a class="el" href="vk__mem__alloc_8h.html#a86dd08aba8633bfa4ad0df2e76481d8b" title="Returns current information about specified allocation and atomically marks it as used in current fra...">vmaGetAllocationInfo()</a>.  <a href="struct_vma_allocation_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_defragmentation_info2.html">VmaDefragmentationInfo2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for defragmentation.  <a href="struct_vma_defragmentation_info2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_defragmentation_pass_move_info.html">VmaDefragmentationPassMoveInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_defragmentation_pass_info.html">VmaDefragmentationPassInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for incremental defragmentation steps.  <a href="struct_vma_defragmentation_pass_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_defragmentation_info.html">VmaDefragmentationInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated. Optional configuration parameters to be passed to function <a class="el" href="vk__mem__alloc_8h.html#a9f0f8f56db5f7f57fe4454f465142dac" title="Deprecated. Compacts memory by moving allocations.">vmaDefragment()</a>.  <a href="struct_vma_defragmentation_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_defragmentation_stats.html">VmaDefragmentationStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics returned by function <a class="el" href="vk__mem__alloc_8h.html#a9f0f8f56db5f7f57fe4454f465142dac" title="Deprecated. Compacts memory by moving allocations.">vmaDefragment()</a>.  <a href="struct_vma_defragmentation_stats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1f0c126759fc96ccb6e2d23c101d770c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a1f0c126759fc96ccb6e2d23c101d770c">VMA_RECORDING_ENABLED</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a1f0c126759fc96ccb6e2d23c101d770c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f918755b601cf4bffca775992e6fb90"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a9f918755b601cf4bffca775992e6fb90">NOMINMAX</a></td></tr>
<tr class="separator:a9f918755b601cf4bffca775992e6fb90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2407c283893638cc039bb31fcd74b6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a1a2407c283893638cc039bb31fcd74b6">VMA_VULKAN_VERSION</a>&#160;&#160;&#160;1000000</td></tr>
<tr class="separator:a1a2407c283893638cc039bb31fcd74b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b860e63b96d11e44ae8587ba06bbf4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#af7b860e63b96d11e44ae8587ba06bbf4">VMA_DEDICATED_ALLOCATION</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:af7b860e63b96d11e44ae8587ba06bbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88bef97f86d70a34a4c0746e09a2680d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a88bef97f86d70a34a4c0746e09a2680d">VMA_BIND_MEMORY2</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a88bef97f86d70a34a4c0746e09a2680d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05decf1cf4ebf767beba7acca6c1ec3a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a05decf1cf4ebf767beba7acca6c1ec3a">VMA_MEMORY_BUDGET</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a05decf1cf4ebf767beba7acca6c1ec3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9d5e71b70dd1a137c303a8a8262c10"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a7f9d5e71b70dd1a137c303a8a8262c10">VMA_BUFFER_DEVICE_ADDRESS</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a7f9d5e71b70dd1a137c303a8a8262c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25f0d55fd91cb166f002b63244800e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#ae25f0d55fd91cb166f002b63244800e1">VMA_STATS_STRING_ENABLED</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ae25f0d55fd91cb166f002b63244800e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7e1ed85f7799600b03ad51a77acc21f3"><td class="memItemLeft" align="right" valign="top">typedef void(VKAPI_PTR *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a7e1ed85f7799600b03ad51a77acc21f3">PFN_vmaAllocateDeviceMemoryFunction</a>) (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, uint32_t memoryType, VkDeviceMemory memory, VkDeviceSize size, void *pUserData)</td></tr>
<tr class="memdesc:a7e1ed85f7799600b03ad51a77acc21f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function called after successful vkAllocateMemory.  <a href="vk__mem__alloc_8h.html#a7e1ed85f7799600b03ad51a77acc21f3">More...</a><br /></td></tr>
<tr class="separator:a7e1ed85f7799600b03ad51a77acc21f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154ccaaf53dc2c36378f80f0c4f3679b"><td class="memItemLeft" align="right" valign="top">typedef void(VKAPI_PTR *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a154ccaaf53dc2c36378f80f0c4f3679b">PFN_vmaFreeDeviceMemoryFunction</a>) (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, uint32_t memoryType, VkDeviceMemory memory, VkDeviceSize size, void *pUserData)</td></tr>
<tr class="memdesc:a154ccaaf53dc2c36378f80f0c4f3679b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function called before vkFreeMemory.  <a href="vk__mem__alloc_8h.html#a154ccaaf53dc2c36378f80f0c4f3679b">More...</a><br /></td></tr>
<tr class="separator:a154ccaaf53dc2c36378f80f0c4f3679b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77692d3c8770ea8882d573206bd27b2b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_vma_device_memory_callbacks.html">VmaDeviceMemoryCallbacks</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a77692d3c8770ea8882d573206bd27b2b">VmaDeviceMemoryCallbacks</a></td></tr>
<tr class="memdesc:a77692d3c8770ea8882d573206bd27b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of callbacks that the library will call for <code>vkAllocateMemory</code> and <code>vkFreeMemory</code>.  <a href="vk__mem__alloc_8h.html#a77692d3c8770ea8882d573206bd27b2b">More...</a><br /></td></tr>
<tr class="separator:a77692d3c8770ea8882d573206bd27b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd73b95e737ee7e76f827cb5472f559f"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="vk__mem__alloc_8h.html#a4f87c9100d154a65a4ad495f7763cf7c">VmaAllocatorCreateFlagBits</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#afd73b95e737ee7e76f827cb5472f559f">VmaAllocatorCreateFlagBits</a></td></tr>
<tr class="memdesc:afd73b95e737ee7e76f827cb5472f559f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags for created <a class="el" href="struct_vma_allocator.html" title="Represents main object of this library initialized.">VmaAllocator</a>.  <a href="vk__mem__alloc_8h.html#afd73b95e737ee7e76f827cb5472f559f">More...</a><br /></td></tr>
<tr class="separator:afd73b95e737ee7e76f827cb5472f559f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe6863e160722c2c1bbcf7573fddc4d"><td class="memItemLeft" align="right" valign="top">typedef VkFlags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#acfe6863e160722c2c1bbcf7573fddc4d">VmaAllocatorCreateFlags</a></td></tr>
<tr class="separator:acfe6863e160722c2c1bbcf7573fddc4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0a8e3b5040d847571cca6c7f9a8074"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_vma_vulkan_functions.html">VmaVulkanFunctions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#abb0a8e3b5040d847571cca6c7f9a8074">VmaVulkanFunctions</a></td></tr>
<tr class="memdesc:abb0a8e3b5040d847571cca6c7f9a8074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointers to some Vulkan functions - a subset used by the library.  <a href="vk__mem__alloc_8h.html#abb0a8e3b5040d847571cca6c7f9a8074">More...</a><br /></td></tr>
<tr class="separator:abb0a8e3b5040d847571cca6c7f9a8074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd24d5eb58abff7e1f43cb32a1ba1413"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="vk__mem__alloc_8h.html#a4dd2c44642312a147a4e93373a6e64d2">VmaRecordFlagBits</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#acd24d5eb58abff7e1f43cb32a1ba1413">VmaRecordFlagBits</a></td></tr>
<tr class="memdesc:acd24d5eb58abff7e1f43cb32a1ba1413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to be used in <a class="el" href="struct_vma_record_settings.html#ad8fdcc92119ae7a8c08c1a564c01d63a" title="Flags for recording. Use VmaRecordFlagBits enum.">VmaRecordSettings::flags</a>.  <a href="vk__mem__alloc_8h.html#acd24d5eb58abff7e1f43cb32a1ba1413">More...</a><br /></td></tr>
<tr class="separator:acd24d5eb58abff7e1f43cb32a1ba1413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3929a1a4547c592fc0b0e55ef452828"><td class="memItemLeft" align="right" valign="top">typedef VkFlags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#af3929a1a4547c592fc0b0e55ef452828">VmaRecordFlags</a></td></tr>
<tr class="separator:af3929a1a4547c592fc0b0e55ef452828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e21c877101493fce582664cd8754fc"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_vma_record_settings.html">VmaRecordSettings</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a16e21c877101493fce582664cd8754fc">VmaRecordSettings</a></td></tr>
<tr class="memdesc:a16e21c877101493fce582664cd8754fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for recording calls to VMA functions. To be used in <a class="el" href="struct_vma_allocator_create_info.html#ace2aa4877b16a42b0b7673d4e26000ee" title="Parameters for recording of VMA calls. Can be null.">VmaAllocatorCreateInfo::pRecordSettings</a>.  <a href="vk__mem__alloc_8h.html#a16e21c877101493fce582664cd8754fc">More...</a><br /></td></tr>
<tr class="separator:a16e21c877101493fce582664cd8754fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9652301d33759b83e52d4f3605a14a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_vma_allocator_create_info.html">VmaAllocatorCreateInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#aad9652301d33759b83e52d4f3605a14a">VmaAllocatorCreateInfo</a></td></tr>
<tr class="memdesc:aad9652301d33759b83e52d4f3605a14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of a Allocator to be created.  <a href="vk__mem__alloc_8h.html#aad9652301d33759b83e52d4f3605a14a">More...</a><br /></td></tr>
<tr class="separator:aad9652301d33759b83e52d4f3605a14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1988031b0223fdbd564250fa1edd942c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_vma_allocator_info.html">VmaAllocatorInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a1988031b0223fdbd564250fa1edd942c">VmaAllocatorInfo</a></td></tr>
<tr class="memdesc:a1988031b0223fdbd564250fa1edd942c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about existing <a class="el" href="struct_vma_allocator.html" title="Represents main object of this library initialized.">VmaAllocator</a> object.  <a href="vk__mem__alloc_8h.html#a1988031b0223fdbd564250fa1edd942c">More...</a><br /></td></tr>
<tr class="separator:a1988031b0223fdbd564250fa1edd942c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5b57e29c97b5d69c6d5654d60df878"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_vma_stat_info.html">VmaStatInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#aec5b57e29c97b5d69c6d5654d60df878">VmaStatInfo</a></td></tr>
<tr class="memdesc:aec5b57e29c97b5d69c6d5654d60df878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculated statistics of memory usage in entire allocator.  <a href="vk__mem__alloc_8h.html#aec5b57e29c97b5d69c6d5654d60df878">More...</a><br /></td></tr>
<tr class="separator:aec5b57e29c97b5d69c6d5654d60df878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21813b2efdf3836767a9058cd8a94034"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_vma_stats.html">VmaStats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a21813b2efdf3836767a9058cd8a94034">VmaStats</a></td></tr>
<tr class="memdesc:a21813b2efdf3836767a9058cd8a94034"><td class="mdescLeft">&#160;</td><td class="mdescRight">General statistics from current state of Allocator.  <a href="vk__mem__alloc_8h.html#a21813b2efdf3836767a9058cd8a94034">More...</a><br /></td></tr>
<tr class="separator:a21813b2efdf3836767a9058cd8a94034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa078667e71b1ef24e87a6a30d128381d"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_vma_budget.html">VmaBudget</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#aa078667e71b1ef24e87a6a30d128381d">VmaBudget</a></td></tr>
<tr class="memdesc:aa078667e71b1ef24e87a6a30d128381d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics of current memory usage and available budget, in bytes, for specific memory heap.  <a href="vk__mem__alloc_8h.html#aa078667e71b1ef24e87a6a30d128381d">More...</a><br /></td></tr>
<tr class="separator:aa078667e71b1ef24e87a6a30d128381d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806e8499dde802e59eb72a1dc811c35f"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="vk__mem__alloc_8h.html#aa5846affa1e9da3800e3e78fae2305cc">VmaMemoryUsage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a806e8499dde802e59eb72a1dc811c35f">VmaMemoryUsage</a></td></tr>
<tr class="separator:a806e8499dde802e59eb72a1dc811c35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fceecc301f4064dc808d3cd6c038941"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597">VmaAllocationCreateFlagBits</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a4fceecc301f4064dc808d3cd6c038941">VmaAllocationCreateFlagBits</a></td></tr>
<tr class="memdesc:a4fceecc301f4064dc808d3cd6c038941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to be passed as <a class="el" href="struct_vma_allocation_create_info.html#add09658ac14fe290ace25470ddd6d41b" title="Use VmaAllocationCreateFlagBits enum.">VmaAllocationCreateInfo::flags</a>.  <a href="vk__mem__alloc_8h.html#a4fceecc301f4064dc808d3cd6c038941">More...</a><br /></td></tr>
<tr class="separator:a4fceecc301f4064dc808d3cd6c038941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5225e5e11f8376f6a31a1791f3d6e817"><td class="memItemLeft" align="right" valign="top">typedef VkFlags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a5225e5e11f8376f6a31a1791f3d6e817">VmaAllocationCreateFlags</a></td></tr>
<tr class="separator:a5225e5e11f8376f6a31a1791f3d6e817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf110892ea2fb4649fedb68488d026a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a3bf110892ea2fb4649fedb68488d026a">VmaAllocationCreateInfo</a></td></tr>
<tr class="separator:a3bf110892ea2fb4649fedb68488d026a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4f2efc2509157a9e4ecd4fd7942303"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="vk__mem__alloc_8h.html#a9a7c45f9c863695d98c83fa5ac940fe7">VmaPoolCreateFlagBits</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a4d4f2efc2509157a9e4ecd4fd7942303">VmaPoolCreateFlagBits</a></td></tr>
<tr class="memdesc:a4d4f2efc2509157a9e4ecd4fd7942303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to be passed as <a class="el" href="struct_vma_pool_create_info.html#a8405139f63d078340ae74513a59f5446" title="Use combination of VmaPoolCreateFlagBits.">VmaPoolCreateInfo::flags</a>.  <a href="vk__mem__alloc_8h.html#a4d4f2efc2509157a9e4ecd4fd7942303">More...</a><br /></td></tr>
<tr class="separator:a4d4f2efc2509157a9e4ecd4fd7942303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2770e325ea42e087c1b91fdf46d0292a"><td class="memItemLeft" align="right" valign="top">typedef VkFlags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a2770e325ea42e087c1b91fdf46d0292a">VmaPoolCreateFlags</a></td></tr>
<tr class="separator:a2770e325ea42e087c1b91fdf46d0292a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1017aa83489c0eee8d2163d2bf253f67"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_vma_pool_create_info.html">VmaPoolCreateInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a1017aa83489c0eee8d2163d2bf253f67">VmaPoolCreateInfo</a></td></tr>
<tr class="memdesc:a1017aa83489c0eee8d2163d2bf253f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes parameter of created <a class="el" href="struct_vma_pool.html" title="Represents custom memory pool.">VmaPool</a>.  <a href="vk__mem__alloc_8h.html#a1017aa83489c0eee8d2163d2bf253f67">More...</a><br /></td></tr>
<tr class="separator:a1017aa83489c0eee8d2163d2bf253f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4759a2d9f99c19ba7627553c847132f1"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_vma_pool_stats.html">VmaPoolStats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a4759a2d9f99c19ba7627553c847132f1">VmaPoolStats</a></td></tr>
<tr class="memdesc:a4759a2d9f99c19ba7627553c847132f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes parameter of existing <a class="el" href="struct_vma_pool.html" title="Represents custom memory pool.">VmaPool</a>.  <a href="vk__mem__alloc_8h.html#a4759a2d9f99c19ba7627553c847132f1">More...</a><br /></td></tr>
<tr class="separator:a4759a2d9f99c19ba7627553c847132f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf7774606721026a68aabe3af2e5b50"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a1cf7774606721026a68aabe3af2e5b50">VmaAllocationInfo</a></td></tr>
<tr class="memdesc:a1cf7774606721026a68aabe3af2e5b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters of <a class="el" href="struct_vma_allocation.html" title="Represents single memory allocation.">VmaAllocation</a> objects, that can be retrieved using function <a class="el" href="vk__mem__alloc_8h.html#a86dd08aba8633bfa4ad0df2e76481d8b" title="Returns current information about specified allocation and atomically marks it as used in current fra...">vmaGetAllocationInfo()</a>.  <a href="vk__mem__alloc_8h.html#a1cf7774606721026a68aabe3af2e5b50">More...</a><br /></td></tr>
<tr class="separator:a1cf7774606721026a68aabe3af2e5b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13415cc0b443353a7b5abda300b833fc"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="vk__mem__alloc_8h.html#a6552a65b71d16f378c6994b3ceaef50c">VmaDefragmentationFlagBits</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a13415cc0b443353a7b5abda300b833fc">VmaDefragmentationFlagBits</a></td></tr>
<tr class="memdesc:a13415cc0b443353a7b5abda300b833fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to be used in <a class="el" href="vk__mem__alloc_8h.html#a36ba776fd7fd5cb1e9359fdc0d8e6e8a" title="Begins defragmentation process.">vmaDefragmentationBegin()</a>. None at the moment. Reserved for future use.  <a href="vk__mem__alloc_8h.html#a13415cc0b443353a7b5abda300b833fc">More...</a><br /></td></tr>
<tr class="separator:a13415cc0b443353a7b5abda300b833fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a77cef37e5d3c4fc9eb328885d048d"><td class="memItemLeft" align="right" valign="top">typedef VkFlags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a88a77cef37e5d3c4fc9eb328885d048d">VmaDefragmentationFlags</a></td></tr>
<tr class="separator:a88a77cef37e5d3c4fc9eb328885d048d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6daeffaa670ce6d11a203a6224c9937"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_vma_defragmentation_info2.html">VmaDefragmentationInfo2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#ad6daeffaa670ce6d11a203a6224c9937">VmaDefragmentationInfo2</a></td></tr>
<tr class="memdesc:ad6daeffaa670ce6d11a203a6224c9937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for defragmentation.  <a href="vk__mem__alloc_8h.html#ad6daeffaa670ce6d11a203a6224c9937">More...</a><br /></td></tr>
<tr class="separator:ad6daeffaa670ce6d11a203a6224c9937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6799e8e2b1527abfc84d33bc44aeaf5"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_vma_defragmentation_pass_move_info.html">VmaDefragmentationPassMoveInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#ad6799e8e2b1527abfc84d33bc44aeaf5">VmaDefragmentationPassMoveInfo</a></td></tr>
<tr class="separator:ad6799e8e2b1527abfc84d33bc44aeaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72aebd522242d56abea67b4f47f6549e"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_vma_defragmentation_pass_info.html">VmaDefragmentationPassInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a72aebd522242d56abea67b4f47f6549e">VmaDefragmentationPassInfo</a></td></tr>
<tr class="memdesc:a72aebd522242d56abea67b4f47f6549e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for incremental defragmentation steps.  <a href="vk__mem__alloc_8h.html#a72aebd522242d56abea67b4f47f6549e">More...</a><br /></td></tr>
<tr class="separator:a72aebd522242d56abea67b4f47f6549e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf47f96bf92bed2a49461bd9af3acfa"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_vma_defragmentation_info.html">VmaDefragmentationInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a2bf47f96bf92bed2a49461bd9af3acfa">VmaDefragmentationInfo</a></td></tr>
<tr class="memdesc:a2bf47f96bf92bed2a49461bd9af3acfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated. Optional configuration parameters to be passed to function <a class="el" href="vk__mem__alloc_8h.html#a9f0f8f56db5f7f57fe4454f465142dac" title="Deprecated. Compacts memory by moving allocations.">vmaDefragment()</a>.  <a href="vk__mem__alloc_8h.html#a2bf47f96bf92bed2a49461bd9af3acfa">More...</a><br /></td></tr>
<tr class="separator:a2bf47f96bf92bed2a49461bd9af3acfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94034192259c2e34a4d1c5e27810403"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_vma_defragmentation_stats.html">VmaDefragmentationStats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#ad94034192259c2e34a4d1c5e27810403">VmaDefragmentationStats</a></td></tr>
<tr class="memdesc:ad94034192259c2e34a4d1c5e27810403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics returned by function <a class="el" href="vk__mem__alloc_8h.html#a9f0f8f56db5f7f57fe4454f465142dac" title="Deprecated. Compacts memory by moving allocations.">vmaDefragment()</a>.  <a href="vk__mem__alloc_8h.html#ad94034192259c2e34a4d1c5e27810403">More...</a><br /></td></tr>
<tr class="separator:ad94034192259c2e34a4d1c5e27810403"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a4f87c9100d154a65a4ad495f7763cf7c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a4f87c9100d154a65a4ad495f7763cf7c">VmaAllocatorCreateFlagBits</a> { <br />
&#160;&#160;<a class="el" href="vk__mem__alloc_8h.html#a4f87c9100d154a65a4ad495f7763cf7ca4816ddaed324ba110172ca608a20f29d">VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT</a> = 0x00000001, 
<a class="el" href="vk__mem__alloc_8h.html#a4f87c9100d154a65a4ad495f7763cf7cace7da7cc6e71a625dfa763c55a597878">VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT</a> = 0x00000002, 
<a class="el" href="vk__mem__alloc_8h.html#a4f87c9100d154a65a4ad495f7763cf7ca8fb75bf07cd184ab903596295e863dee">VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</a> = 0x00000004, 
<a class="el" href="vk__mem__alloc_8h.html#a4f87c9100d154a65a4ad495f7763cf7ca4d4687863f7bd4b418c6006dc04400b0">VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT</a> = 0x00000008, 
<br />
&#160;&#160;<a class="el" href="vk__mem__alloc_8h.html#a4f87c9100d154a65a4ad495f7763cf7ca2acce4886d8078552efa38878413970f">VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT</a> = 0x00000010, 
<a class="el" href="vk__mem__alloc_8h.html#a4f87c9100d154a65a4ad495f7763cf7ca5f1b28b0414319d1687e1f2b30ab0089">VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT</a> = 0x00000020, 
<a class="el" href="vk__mem__alloc_8h.html#a4f87c9100d154a65a4ad495f7763cf7cae4d5ad929caba5f23eb502b13bd5286c">VMA_ALLOCATOR_CREATE_FLAG_BITS_MAX_ENUM</a> = 0x7FFFFFFF
<br />
 }</td></tr>
<tr class="memdesc:a4f87c9100d154a65a4ad495f7763cf7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags for created <a class="el" href="struct_vma_allocator.html" title="Represents main object of this library initialized.">VmaAllocator</a>.  <a href="vk__mem__alloc_8h.html#a4f87c9100d154a65a4ad495f7763cf7c">More...</a><br /></td></tr>
<tr class="separator:a4f87c9100d154a65a4ad495f7763cf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd2c44642312a147a4e93373a6e64d2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a4dd2c44642312a147a4e93373a6e64d2">VmaRecordFlagBits</a> { <a class="el" href="vk__mem__alloc_8h.html#a4dd2c44642312a147a4e93373a6e64d2a8e7ab322e8732654be627c4ea8f36cc7">VMA_RECORD_FLUSH_AFTER_CALL_BIT</a> = 0x00000001, 
<a class="el" href="vk__mem__alloc_8h.html#a4dd2c44642312a147a4e93373a6e64d2a20dd17d69966dbffa054739d6090b85e">VMA_RECORD_FLAG_BITS_MAX_ENUM</a> = 0x7FFFFFFF
 }</td></tr>
<tr class="memdesc:a4dd2c44642312a147a4e93373a6e64d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to be used in <a class="el" href="struct_vma_record_settings.html#ad8fdcc92119ae7a8c08c1a564c01d63a" title="Flags for recording. Use VmaRecordFlagBits enum.">VmaRecordSettings::flags</a>.  <a href="vk__mem__alloc_8h.html#a4dd2c44642312a147a4e93373a6e64d2">More...</a><br /></td></tr>
<tr class="separator:a4dd2c44642312a147a4e93373a6e64d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5846affa1e9da3800e3e78fae2305cc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#aa5846affa1e9da3800e3e78fae2305cc">VmaMemoryUsage</a> { <br />
&#160;&#160;<a class="el" href="vk__mem__alloc_8h.html#aa5846affa1e9da3800e3e78fae2305ccaf50d27e34e0925cf3a63db8c839121dd">VMA_MEMORY_USAGE_UNKNOWN</a> = 0, 
<a class="el" href="vk__mem__alloc_8h.html#aa5846affa1e9da3800e3e78fae2305ccac6b5dc1432d88647aa4cd456246eadf7">VMA_MEMORY_USAGE_GPU_ONLY</a> = 1, 
<a class="el" href="vk__mem__alloc_8h.html#aa5846affa1e9da3800e3e78fae2305cca40bdf4cddeffeb12f43d45ca1286e0a5">VMA_MEMORY_USAGE_CPU_ONLY</a> = 2, 
<a class="el" href="vk__mem__alloc_8h.html#aa5846affa1e9da3800e3e78fae2305cca9066b52c5a7079bb74a69aaf8b92ff67">VMA_MEMORY_USAGE_CPU_TO_GPU</a> = 3, 
<br />
&#160;&#160;<a class="el" href="vk__mem__alloc_8h.html#aa5846affa1e9da3800e3e78fae2305cca7b586d2fdaf82a463b58f581ed72be27">VMA_MEMORY_USAGE_GPU_TO_CPU</a> = 4, 
<a class="el" href="vk__mem__alloc_8h.html#aa5846affa1e9da3800e3e78fae2305cca416a444d4d0fc20067c3f76f32ff2500">VMA_MEMORY_USAGE_CPU_COPY</a> = 5, 
<a class="el" href="vk__mem__alloc_8h.html#aa5846affa1e9da3800e3e78fae2305cca835333d9072db63a653818030e17614d">VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED</a> = 6, 
<a class="el" href="vk__mem__alloc_8h.html#aa5846affa1e9da3800e3e78fae2305cca091e69437ef693e8d0d287f1c719ba6e">VMA_MEMORY_USAGE_MAX_ENUM</a> = 0x7FFFFFFF
<br />
 }</td></tr>
<tr class="separator:aa5846affa1e9da3800e3e78fae2305cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9889c10c798b040d59c92f257cae597"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597">VmaAllocationCreateFlagBits</a> { <br />
&#160;&#160;<a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</a> = 0x00000001, 
<a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a89759603401014eb325eb22a3839f2ff">VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</a> = 0x00000002, 
<a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f">VMA_ALLOCATION_CREATE_MAPPED_BIT</a> = 0x00000004, 
<a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a5f436af6c8fe8540573a6d22627a6fd2">VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT</a> = 0x00000008, 
<br />
&#160;&#160;<a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a68686d0ce9beb0d4d1b9f2b8b1389a7e">VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT</a> = 0x00000010, 
<a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597aa6f24f821cd6a7c5e4a443f7bf59c520">VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</a> = 0x00000020, 
<a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a42ba3a2d2c7117953210b7c3ef8da0df">VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT</a> = 0x00000040, 
<a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a2310568c62208af432724305fe29ccea">VMA_ALLOCATION_CREATE_DONT_BIND_BIT</a> = 0x00000080, 
<br />
&#160;&#160;<a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597ab8b1764f3e9022368e440c057783b92d">VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT</a> = 0x00000100, 
<a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a839826775c62319466441f86496f036d">VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</a> = 0x00010000, 
<a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597ad242a04f802e25fef0b880afe8bb0a62">VMA_ALLOCATION_CREATE_STRATEGY_WORST_FIT_BIT</a> = 0x00020000, 
<a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a33eb2052674f3ad92386c714a65fb777">VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</a> = 0x00040000, 
<br />
&#160;&#160;<a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a8af1210cf591784afa026d94998f735d">VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</a> = VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT, 
<a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a0729e932b7ea170e3a128cad96c5cf6d">VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</a> = VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT, 
<a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a621b704103eb3360230c860acf36e706">VMA_ALLOCATION_CREATE_STRATEGY_MIN_FRAGMENTATION_BIT</a> = VMA_ALLOCATION_CREATE_STRATEGY_WORST_FIT_BIT, 
<a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a8e16845d81ae3d27c47106d4770d5c7e">VMA_ALLOCATION_CREATE_STRATEGY_MASK</a>, 
<br />
&#160;&#160;<a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597ae5633ec569f4899cf8f29e7385b2f882">VMA_ALLOCATION_CREATE_FLAG_BITS_MAX_ENUM</a> = 0x7FFFFFFF
<br />
 }</td></tr>
<tr class="memdesc:ad9889c10c798b040d59c92f257cae597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to be passed as <a class="el" href="struct_vma_allocation_create_info.html#add09658ac14fe290ace25470ddd6d41b" title="Use VmaAllocationCreateFlagBits enum.">VmaAllocationCreateInfo::flags</a>.  <a href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597">More...</a><br /></td></tr>
<tr class="separator:ad9889c10c798b040d59c92f257cae597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7c45f9c863695d98c83fa5ac940fe7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a9a7c45f9c863695d98c83fa5ac940fe7">VmaPoolCreateFlagBits</a> { <br />
&#160;&#160;<a class="el" href="vk__mem__alloc_8h.html#a9a7c45f9c863695d98c83fa5ac940fe7a9f1a499508a8edb4e8ba40aa0290a3d2">VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT</a> = 0x00000002, 
<a class="el" href="vk__mem__alloc_8h.html#a9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726">VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</a> = 0x00000004, 
<a class="el" href="vk__mem__alloc_8h.html#a9a7c45f9c863695d98c83fa5ac940fe7a97a0dc38e5161b780594d998d313d35e">VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT</a> = 0x00000008, 
<a class="el" href="vk__mem__alloc_8h.html#a9a7c45f9c863695d98c83fa5ac940fe7af4d270f8f42517a0f70037ceb6ac1d9c">VMA_POOL_CREATE_ALGORITHM_MASK</a>, 
<br />
&#160;&#160;<a class="el" href="vk__mem__alloc_8h.html#a9a7c45f9c863695d98c83fa5ac940fe7a1c7312bea9ea246846b9054fd6bd6aec">VMA_POOL_CREATE_FLAG_BITS_MAX_ENUM</a> = 0x7FFFFFFF
<br />
 }</td></tr>
<tr class="memdesc:a9a7c45f9c863695d98c83fa5ac940fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to be passed as <a class="el" href="struct_vma_pool_create_info.html#a8405139f63d078340ae74513a59f5446" title="Use combination of VmaPoolCreateFlagBits.">VmaPoolCreateInfo::flags</a>.  <a href="vk__mem__alloc_8h.html#a9a7c45f9c863695d98c83fa5ac940fe7">More...</a><br /></td></tr>
<tr class="separator:a9a7c45f9c863695d98c83fa5ac940fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6552a65b71d16f378c6994b3ceaef50c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a6552a65b71d16f378c6994b3ceaef50c">VmaDefragmentationFlagBits</a> { <a class="el" href="vk__mem__alloc_8h.html#a6552a65b71d16f378c6994b3ceaef50ca31af49446af2459284a568ce2f3fdd33">VMA_DEFRAGMENTATION_FLAG_INCREMENTAL</a> = 0x1, 
<a class="el" href="vk__mem__alloc_8h.html#a6552a65b71d16f378c6994b3ceaef50cab87ec33154803bfeb5ac2b379f1d6a97">VMA_DEFRAGMENTATION_FLAG_BITS_MAX_ENUM</a> = 0x7FFFFFFF
 }</td></tr>
<tr class="memdesc:a6552a65b71d16f378c6994b3ceaef50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to be used in <a class="el" href="vk__mem__alloc_8h.html#a36ba776fd7fd5cb1e9359fdc0d8e6e8a" title="Begins defragmentation process.">vmaDefragmentationBegin()</a>. None at the moment. Reserved for future use.  <a href="vk__mem__alloc_8h.html#a6552a65b71d16f378c6994b3ceaef50c">More...</a><br /></td></tr>
<tr class="separator:a6552a65b71d16f378c6994b3ceaef50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a200692051ddb34240248234f5f4c17bb"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a200692051ddb34240248234f5f4c17bb">vmaCreateAllocator</a> (const <a class="el" href="struct_vma_allocator_create_info.html">VmaAllocatorCreateInfo</a> *pCreateInfo, <a class="el" href="struct_vma_allocator.html">VmaAllocator</a> *pAllocator)</td></tr>
<tr class="memdesc:a200692051ddb34240248234f5f4c17bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates Allocator object.  <a href="vk__mem__alloc_8h.html#a200692051ddb34240248234f5f4c17bb">More...</a><br /></td></tr>
<tr class="separator:a200692051ddb34240248234f5f4c17bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d164061c88f22fb1fd3c8f3534bc1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#aa8d164061c88f22fb1fd3c8f3534bc1d">vmaDestroyAllocator</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator)</td></tr>
<tr class="memdesc:aa8d164061c88f22fb1fd3c8f3534bc1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys allocator object.  <a href="vk__mem__alloc_8h.html#aa8d164061c88f22fb1fd3c8f3534bc1d">More...</a><br /></td></tr>
<tr class="separator:aa8d164061c88f22fb1fd3c8f3534bc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa02231a791b37255720d566a52683e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#afa02231a791b37255720d566a52683e7">vmaGetAllocatorInfo</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocator_info.html">VmaAllocatorInfo</a> *pAllocatorInfo)</td></tr>
<tr class="memdesc:afa02231a791b37255720d566a52683e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns information about existing <a class="el" href="struct_vma_allocator.html" title="Represents main object of this library initialized.">VmaAllocator</a> object - handle to Vulkan device etc.  <a href="vk__mem__alloc_8h.html#afa02231a791b37255720d566a52683e7">More...</a><br /></td></tr>
<tr class="separator:afa02231a791b37255720d566a52683e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecabf7b6e91ea87d0316fa0a9e014fe0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#aecabf7b6e91ea87d0316fa0a9e014fe0">vmaGetPhysicalDeviceProperties</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, const VkPhysicalDeviceProperties **ppPhysicalDeviceProperties)</td></tr>
<tr class="separator:aecabf7b6e91ea87d0316fa0a9e014fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88db292a17974f911182543fda52d19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#ab88db292a17974f911182543fda52d19">vmaGetMemoryProperties</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, const VkPhysicalDeviceMemoryProperties **ppPhysicalDeviceMemoryProperties)</td></tr>
<tr class="separator:ab88db292a17974f911182543fda52d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8701444752eb5de4464adb5a2b514bca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a8701444752eb5de4464adb5a2b514bca">vmaGetMemoryTypeProperties</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, uint32_t memoryTypeIndex, VkMemoryPropertyFlags *pFlags)</td></tr>
<tr class="memdesc:a8701444752eb5de4464adb5a2b514bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given Memory Type Index, returns Property Flags of this memory type.  <a href="vk__mem__alloc_8h.html#a8701444752eb5de4464adb5a2b514bca">More...</a><br /></td></tr>
<tr class="separator:a8701444752eb5de4464adb5a2b514bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade56bf8dc9f5a5eaddf5f119ed525236"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#ade56bf8dc9f5a5eaddf5f119ed525236">vmaSetCurrentFrameIndex</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, uint32_t frameIndex)</td></tr>
<tr class="memdesc:ade56bf8dc9f5a5eaddf5f119ed525236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets index of the current frame.  <a href="vk__mem__alloc_8h.html#ade56bf8dc9f5a5eaddf5f119ed525236">More...</a><br /></td></tr>
<tr class="separator:ade56bf8dc9f5a5eaddf5f119ed525236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333b61c1788cb23559177531e6a93ca3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a333b61c1788cb23559177531e6a93ca3">vmaCalculateStats</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_stats.html">VmaStats</a> *pStats)</td></tr>
<tr class="memdesc:a333b61c1788cb23559177531e6a93ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves statistics from current state of the Allocator.  <a href="vk__mem__alloc_8h.html#a333b61c1788cb23559177531e6a93ca3">More...</a><br /></td></tr>
<tr class="separator:a333b61c1788cb23559177531e6a93ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0ed24ebea2d0099eed5f801daaefba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#aec0ed24ebea2d0099eed5f801daaefba">vmaGetBudget</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_budget.html">VmaBudget</a> *pBudget)</td></tr>
<tr class="memdesc:aec0ed24ebea2d0099eed5f801daaefba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves information about current memory budget for all memory heaps.  <a href="vk__mem__alloc_8h.html#aec0ed24ebea2d0099eed5f801daaefba">More...</a><br /></td></tr>
<tr class="separator:aec0ed24ebea2d0099eed5f801daaefba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4fee7eb5253377599ef4fd38c93c2a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#aa4fee7eb5253377599ef4fd38c93c2a0">vmaBuildStatsString</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, char **ppStatsString, VkBool32 detailedMap)</td></tr>
<tr class="memdesc:aa4fee7eb5253377599ef4fd38c93c2a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds and returns statistics as string in JSON format.  <a href="vk__mem__alloc_8h.html#aa4fee7eb5253377599ef4fd38c93c2a0">More...</a><br /></td></tr>
<tr class="separator:aa4fee7eb5253377599ef4fd38c93c2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3104eb30d8122c84dd8541063f145288"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a3104eb30d8122c84dd8541063f145288">vmaFreeStatsString</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, char *pStatsString)</td></tr>
<tr class="separator:a3104eb30d8122c84dd8541063f145288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef15a94b58fbcb0fe706d5720e84a74a"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#aef15a94b58fbcb0fe706d5720e84a74a">vmaFindMemoryTypeIndex</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, uint32_t memoryTypeBits, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *pAllocationCreateInfo, uint32_t *pMemoryTypeIndex)</td></tr>
<tr class="memdesc:aef15a94b58fbcb0fe706d5720e84a74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helps to find memoryTypeIndex, given memoryTypeBits and <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a>.  <a href="vk__mem__alloc_8h.html#aef15a94b58fbcb0fe706d5720e84a74a">More...</a><br /></td></tr>
<tr class="separator:aef15a94b58fbcb0fe706d5720e84a74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae790ab9ffaf7667fb8f62523e6897888"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#ae790ab9ffaf7667fb8f62523e6897888">vmaFindMemoryTypeIndexForBufferInfo</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, const VkBufferCreateInfo *pBufferCreateInfo, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *pAllocationCreateInfo, uint32_t *pMemoryTypeIndex)</td></tr>
<tr class="memdesc:ae790ab9ffaf7667fb8f62523e6897888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helps to find memoryTypeIndex, given VkBufferCreateInfo and <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a>.  <a href="vk__mem__alloc_8h.html#ae790ab9ffaf7667fb8f62523e6897888">More...</a><br /></td></tr>
<tr class="separator:ae790ab9ffaf7667fb8f62523e6897888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088da83d8eaf3ce9056d9ea0b981d472"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a088da83d8eaf3ce9056d9ea0b981d472">vmaFindMemoryTypeIndexForImageInfo</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, const VkImageCreateInfo *pImageCreateInfo, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *pAllocationCreateInfo, uint32_t *pMemoryTypeIndex)</td></tr>
<tr class="memdesc:a088da83d8eaf3ce9056d9ea0b981d472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helps to find memoryTypeIndex, given VkImageCreateInfo and <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a>.  <a href="vk__mem__alloc_8h.html#a088da83d8eaf3ce9056d9ea0b981d472">More...</a><br /></td></tr>
<tr class="separator:a088da83d8eaf3ce9056d9ea0b981d472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8770ded7c59c8caac6de0c2cb00b50"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a5c8770ded7c59c8caac6de0c2cb00b50">vmaCreatePool</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, const <a class="el" href="struct_vma_pool_create_info.html">VmaPoolCreateInfo</a> *pCreateInfo, <a class="el" href="struct_vma_pool.html">VmaPool</a> *pPool)</td></tr>
<tr class="memdesc:a5c8770ded7c59c8caac6de0c2cb00b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates Vulkan device memory and creates <a class="el" href="struct_vma_pool.html" title="Represents custom memory pool.">VmaPool</a> object.  <a href="vk__mem__alloc_8h.html#a5c8770ded7c59c8caac6de0c2cb00b50">More...</a><br /></td></tr>
<tr class="separator:a5c8770ded7c59c8caac6de0c2cb00b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5485779c8f1948238fc4e92232fa65e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a5485779c8f1948238fc4e92232fa65e1">vmaDestroyPool</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_pool.html">VmaPool</a> pool)</td></tr>
<tr class="memdesc:a5485779c8f1948238fc4e92232fa65e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys <a class="el" href="struct_vma_pool.html" title="Represents custom memory pool.">VmaPool</a> object and frees Vulkan device memory.  <a href="vk__mem__alloc_8h.html#a5485779c8f1948238fc4e92232fa65e1">More...</a><br /></td></tr>
<tr class="separator:a5485779c8f1948238fc4e92232fa65e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8bf76997b234ef68aad922616df4153"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#ae8bf76997b234ef68aad922616df4153">vmaGetPoolStats</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_pool.html">VmaPool</a> pool, <a class="el" href="struct_vma_pool_stats.html">VmaPoolStats</a> *pPoolStats)</td></tr>
<tr class="memdesc:ae8bf76997b234ef68aad922616df4153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves statistics of existing <a class="el" href="struct_vma_pool.html" title="Represents custom memory pool.">VmaPool</a> object.  <a href="vk__mem__alloc_8h.html#ae8bf76997b234ef68aad922616df4153">More...</a><br /></td></tr>
<tr class="separator:ae8bf76997b234ef68aad922616df4153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736bd6cbda886f36c891727e73bd4024"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a736bd6cbda886f36c891727e73bd4024">vmaMakePoolAllocationsLost</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_pool.html">VmaPool</a> pool, size_t *pLostAllocationCount)</td></tr>
<tr class="memdesc:a736bd6cbda886f36c891727e73bd4024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks all allocations in given pool as lost if they are not used in current frame or <a class="el" href="struct_vma_pool_create_info.html#a9437e43ffbb644dbbf7fc4e50cfad6aa" title="Maximum number of additional frames that are in use at the same time as current frame.">VmaPoolCreateInfo::frameInUseCount</a> back from now.  <a href="vk__mem__alloc_8h.html#a736bd6cbda886f36c891727e73bd4024">More...</a><br /></td></tr>
<tr class="separator:a736bd6cbda886f36c891727e73bd4024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad535935619c7a549bf837e1bb0068f89"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#ad535935619c7a549bf837e1bb0068f89">vmaCheckPoolCorruption</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_pool.html">VmaPool</a> pool)</td></tr>
<tr class="memdesc:ad535935619c7a549bf837e1bb0068f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks magic number in margins around all allocations in given memory pool in search for corruptions.  <a href="vk__mem__alloc_8h.html#ad535935619c7a549bf837e1bb0068f89">More...</a><br /></td></tr>
<tr class="separator:ad535935619c7a549bf837e1bb0068f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09b4e4eafdbee812e8d73ddf960f030"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#af09b4e4eafdbee812e8d73ddf960f030">vmaGetPoolName</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_pool.html">VmaPool</a> pool, const char **ppName)</td></tr>
<tr class="memdesc:af09b4e4eafdbee812e8d73ddf960f030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves name of a custom pool.  <a href="vk__mem__alloc_8h.html#af09b4e4eafdbee812e8d73ddf960f030">More...</a><br /></td></tr>
<tr class="separator:af09b4e4eafdbee812e8d73ddf960f030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbae3a0b4ab078024462fc85c37f3b58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#adbae3a0b4ab078024462fc85c37f3b58">vmaSetPoolName</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_pool.html">VmaPool</a> pool, const char *pName)</td></tr>
<tr class="memdesc:adbae3a0b4ab078024462fc85c37f3b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets name of a custom pool.  <a href="vk__mem__alloc_8h.html#adbae3a0b4ab078024462fc85c37f3b58">More...</a><br /></td></tr>
<tr class="separator:adbae3a0b4ab078024462fc85c37f3b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf28077dbf82d0908b8acbe8ee8dd9b8"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#abf28077dbf82d0908b8acbe8ee8dd9b8">vmaAllocateMemory</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, const VkMemoryRequirements *pVkMemoryRequirements, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *pCreateInfo, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *pAllocation, <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *pAllocationInfo)</td></tr>
<tr class="memdesc:abf28077dbf82d0908b8acbe8ee8dd9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">General purpose memory allocation.  <a href="vk__mem__alloc_8h.html#abf28077dbf82d0908b8acbe8ee8dd9b8">More...</a><br /></td></tr>
<tr class="separator:abf28077dbf82d0908b8acbe8ee8dd9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37e82e492b3de38fc3f4cffd9ad0ae1"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#ad37e82e492b3de38fc3f4cffd9ad0ae1">vmaAllocateMemoryPages</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, const VkMemoryRequirements *pVkMemoryRequirements, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *pCreateInfo, size_t allocationCount, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *pAllocations, <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *pAllocationInfo)</td></tr>
<tr class="memdesc:ad37e82e492b3de38fc3f4cffd9ad0ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">General purpose memory allocation for multiple allocation objects at once.  <a href="vk__mem__alloc_8h.html#ad37e82e492b3de38fc3f4cffd9ad0ae1">More...</a><br /></td></tr>
<tr class="separator:ad37e82e492b3de38fc3f4cffd9ad0ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdf64415b6c3d83c454f28d2c53df7b"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a7fdf64415b6c3d83c454f28d2c53df7b">vmaAllocateMemoryForBuffer</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, VkBuffer buffer, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *pCreateInfo, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *pAllocation, <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *pAllocationInfo)</td></tr>
<tr class="separator:a7fdf64415b6c3d83c454f28d2c53df7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0faa3f9e5fb233d29d1e00390650febb"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a0faa3f9e5fb233d29d1e00390650febb">vmaAllocateMemoryForImage</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, VkImage image, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *pCreateInfo, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *pAllocation, <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *pAllocationInfo)</td></tr>
<tr class="memdesc:a0faa3f9e5fb233d29d1e00390650febb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function similar to <a class="el" href="vk__mem__alloc_8h.html#a7fdf64415b6c3d83c454f28d2c53df7b">vmaAllocateMemoryForBuffer()</a>.  <a href="vk__mem__alloc_8h.html#a0faa3f9e5fb233d29d1e00390650febb">More...</a><br /></td></tr>
<tr class="separator:a0faa3f9e5fb233d29d1e00390650febb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fea5518972ae9094b1526cbcb19b05f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a5fea5518972ae9094b1526cbcb19b05f">vmaFreeMemory</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, const <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation)</td></tr>
<tr class="memdesc:a5fea5518972ae9094b1526cbcb19b05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory previously allocated using <a class="el" href="vk__mem__alloc_8h.html#abf28077dbf82d0908b8acbe8ee8dd9b8" title="General purpose memory allocation.">vmaAllocateMemory()</a>, <a class="el" href="vk__mem__alloc_8h.html#a7fdf64415b6c3d83c454f28d2c53df7b">vmaAllocateMemoryForBuffer()</a>, or <a class="el" href="vk__mem__alloc_8h.html#a0faa3f9e5fb233d29d1e00390650febb" title="Function similar to vmaAllocateMemoryForBuffer().">vmaAllocateMemoryForImage()</a>.  <a href="vk__mem__alloc_8h.html#a5fea5518972ae9094b1526cbcb19b05f">More...</a><br /></td></tr>
<tr class="separator:a5fea5518972ae9094b1526cbcb19b05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834b1e4aef395c0a1d56a28e69a4a17e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a834b1e4aef395c0a1d56a28e69a4a17e">vmaFreeMemoryPages</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, size_t allocationCount, const <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *pAllocations)</td></tr>
<tr class="memdesc:a834b1e4aef395c0a1d56a28e69a4a17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory and destroys multiple allocations.  <a href="vk__mem__alloc_8h.html#a834b1e4aef395c0a1d56a28e69a4a17e">More...</a><br /></td></tr>
<tr class="separator:a834b1e4aef395c0a1d56a28e69a4a17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff488958ca72b28e545880463cb8696"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a0ff488958ca72b28e545880463cb8696">vmaResizeAllocation</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation, VkDeviceSize newSize)</td></tr>
<tr class="memdesc:a0ff488958ca72b28e545880463cb8696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated.  <a href="vk__mem__alloc_8h.html#a0ff488958ca72b28e545880463cb8696">More...</a><br /></td></tr>
<tr class="separator:a0ff488958ca72b28e545880463cb8696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86dd08aba8633bfa4ad0df2e76481d8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a86dd08aba8633bfa4ad0df2e76481d8b">vmaGetAllocationInfo</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation, <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *pAllocationInfo)</td></tr>
<tr class="memdesc:a86dd08aba8633bfa4ad0df2e76481d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current information about specified allocation and atomically marks it as used in current frame.  <a href="vk__mem__alloc_8h.html#a86dd08aba8633bfa4ad0df2e76481d8b">More...</a><br /></td></tr>
<tr class="separator:a86dd08aba8633bfa4ad0df2e76481d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d8ba9673c846f049089a5029d5c73a"><td class="memItemLeft" align="right" valign="top">VkBool32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a43d8ba9673c846f049089a5029d5c73a">vmaTouchAllocation</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation)</td></tr>
<tr class="memdesc:a43d8ba9673c846f049089a5029d5c73a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>VK_TRUE</code> if allocation is not lost and atomically marks it as used in current frame.  <a href="vk__mem__alloc_8h.html#a43d8ba9673c846f049089a5029d5c73a">More...</a><br /></td></tr>
<tr class="separator:a43d8ba9673c846f049089a5029d5c73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9147d31ffc11d62fc187bde283ed14f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#af9147d31ffc11d62fc187bde283ed14f">vmaSetAllocationUserData</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation, void *pUserData)</td></tr>
<tr class="memdesc:af9147d31ffc11d62fc187bde283ed14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets pUserData in given allocation to new value.  <a href="vk__mem__alloc_8h.html#af9147d31ffc11d62fc187bde283ed14f">More...</a><br /></td></tr>
<tr class="separator:af9147d31ffc11d62fc187bde283ed14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c9657d9e94756269145b01c05d16f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#ae5c9657d9e94756269145b01c05d16f1">vmaCreateLostAllocation</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *pAllocation)</td></tr>
<tr class="memdesc:ae5c9657d9e94756269145b01c05d16f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new allocation that is in lost state from the beginning.  <a href="vk__mem__alloc_8h.html#ae5c9657d9e94756269145b01c05d16f1">More...</a><br /></td></tr>
<tr class="separator:ae5c9657d9e94756269145b01c05d16f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5bd1243512d099706de88168992f069"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#ad5bd1243512d099706de88168992f069">vmaMapMemory</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation, void **ppData)</td></tr>
<tr class="memdesc:ad5bd1243512d099706de88168992f069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps memory represented by given allocation and returns pointer to it.  <a href="vk__mem__alloc_8h.html#ad5bd1243512d099706de88168992f069">More...</a><br /></td></tr>
<tr class="separator:ad5bd1243512d099706de88168992f069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc268595cb33f6ec4d519cfce81ff45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a9bc268595cb33f6ec4d519cfce81ff45">vmaUnmapMemory</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation)</td></tr>
<tr class="memdesc:a9bc268595cb33f6ec4d519cfce81ff45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmaps memory represented by given allocation, mapped previously using <a class="el" href="vk__mem__alloc_8h.html#ad5bd1243512d099706de88168992f069" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a>.  <a href="vk__mem__alloc_8h.html#a9bc268595cb33f6ec4d519cfce81ff45">More...</a><br /></td></tr>
<tr class="separator:a9bc268595cb33f6ec4d519cfce81ff45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c37c1eec6025f397be41644f48490f"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a30c37c1eec6025f397be41644f48490f">vmaFlushAllocation</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation, VkDeviceSize offset, VkDeviceSize size)</td></tr>
<tr class="memdesc:a30c37c1eec6025f397be41644f48490f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes memory of given allocation.  <a href="vk__mem__alloc_8h.html#a30c37c1eec6025f397be41644f48490f">More...</a><br /></td></tr>
<tr class="separator:a30c37c1eec6025f397be41644f48490f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8412919139ef413a4215ac6a290fae"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#aaa8412919139ef413a4215ac6a290fae">vmaInvalidateAllocation</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation, VkDeviceSize offset, VkDeviceSize size)</td></tr>
<tr class="memdesc:aaa8412919139ef413a4215ac6a290fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates memory of given allocation.  <a href="vk__mem__alloc_8h.html#aaa8412919139ef413a4215ac6a290fae">More...</a><br /></td></tr>
<tr class="separator:aaa8412919139ef413a4215ac6a290fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3dd00da721875ed99fa8a881922bdfc"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#ac3dd00da721875ed99fa8a881922bdfc">vmaFlushAllocations</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, uint32_t allocationCount, const <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *allocations, const VkDeviceSize *offsets, const VkDeviceSize *sizes)</td></tr>
<tr class="memdesc:ac3dd00da721875ed99fa8a881922bdfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes memory of given set of allocations.  <a href="vk__mem__alloc_8h.html#ac3dd00da721875ed99fa8a881922bdfc">More...</a><br /></td></tr>
<tr class="separator:ac3dd00da721875ed99fa8a881922bdfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25b558d75f7378ec944a1522fdcc3c5"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#ab25b558d75f7378ec944a1522fdcc3c5">vmaInvalidateAllocations</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, uint32_t allocationCount, const <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *allocations, const VkDeviceSize *offsets, const VkDeviceSize *sizes)</td></tr>
<tr class="memdesc:ab25b558d75f7378ec944a1522fdcc3c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates memory of given set of allocations.  <a href="vk__mem__alloc_8h.html#ab25b558d75f7378ec944a1522fdcc3c5">More...</a><br /></td></tr>
<tr class="separator:ab25b558d75f7378ec944a1522fdcc3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49329a7f030dafcf82f7b73334c22e98"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a49329a7f030dafcf82f7b73334c22e98">vmaCheckCorruption</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, uint32_t memoryTypeBits)</td></tr>
<tr class="memdesc:a49329a7f030dafcf82f7b73334c22e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks magic number in margins around all allocations in given memory types (in both default and custom pools) in search for corruptions.  <a href="vk__mem__alloc_8h.html#a49329a7f030dafcf82f7b73334c22e98">More...</a><br /></td></tr>
<tr class="separator:a49329a7f030dafcf82f7b73334c22e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ba776fd7fd5cb1e9359fdc0d8e6e8a"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a36ba776fd7fd5cb1e9359fdc0d8e6e8a">vmaDefragmentationBegin</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, const <a class="el" href="struct_vma_defragmentation_info2.html">VmaDefragmentationInfo2</a> *pInfo, <a class="el" href="struct_vma_defragmentation_stats.html">VmaDefragmentationStats</a> *pStats, <a class="el" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a> *pContext)</td></tr>
<tr class="memdesc:a36ba776fd7fd5cb1e9359fdc0d8e6e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins defragmentation process.  <a href="vk__mem__alloc_8h.html#a36ba776fd7fd5cb1e9359fdc0d8e6e8a">More...</a><br /></td></tr>
<tr class="separator:a36ba776fd7fd5cb1e9359fdc0d8e6e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8774e20e91e245aae959ba63efa15dd2"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a8774e20e91e245aae959ba63efa15dd2">vmaDefragmentationEnd</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a> context)</td></tr>
<tr class="memdesc:a8774e20e91e245aae959ba63efa15dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends defragmentation process.  <a href="vk__mem__alloc_8h.html#a8774e20e91e245aae959ba63efa15dd2">More...</a><br /></td></tr>
<tr class="separator:a8774e20e91e245aae959ba63efa15dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f01545b6262f7d4d128fc8f8e5c77b"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#ac0f01545b6262f7d4d128fc8f8e5c77b">vmaBeginDefragmentationPass</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a> context, <a class="el" href="struct_vma_defragmentation_pass_info.html">VmaDefragmentationPassInfo</a> *pInfo)</td></tr>
<tr class="separator:ac0f01545b6262f7d4d128fc8f8e5c77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9ffa538bed905af55c747cc48963bd"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a1b9ffa538bed905af55c747cc48963bd">vmaEndDefragmentationPass</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a> context)</td></tr>
<tr class="separator:a1b9ffa538bed905af55c747cc48963bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0f8f56db5f7f57fe4454f465142dac"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a9f0f8f56db5f7f57fe4454f465142dac">vmaDefragment</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, const <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *pAllocations, size_t allocationCount, VkBool32 *pAllocationsChanged, const <a class="el" href="struct_vma_defragmentation_info.html">VmaDefragmentationInfo</a> *pDefragmentationInfo, <a class="el" href="struct_vma_defragmentation_stats.html">VmaDefragmentationStats</a> *pDefragmentationStats)</td></tr>
<tr class="memdesc:a9f0f8f56db5f7f57fe4454f465142dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated. Compacts memory by moving allocations.  <a href="vk__mem__alloc_8h.html#a9f0f8f56db5f7f57fe4454f465142dac">More...</a><br /></td></tr>
<tr class="separator:a9f0f8f56db5f7f57fe4454f465142dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0929b914b60cf2d45cac4bf3547470"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a6b0929b914b60cf2d45cac4bf3547470">vmaBindBufferMemory</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation, VkBuffer buffer)</td></tr>
<tr class="memdesc:a6b0929b914b60cf2d45cac4bf3547470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds buffer to allocation.  <a href="vk__mem__alloc_8h.html#a6b0929b914b60cf2d45cac4bf3547470">More...</a><br /></td></tr>
<tr class="separator:a6b0929b914b60cf2d45cac4bf3547470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927c944f45e0f2941182abb6f608e64a"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a927c944f45e0f2941182abb6f608e64a">vmaBindBufferMemory2</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation, VkDeviceSize allocationLocalOffset, VkBuffer buffer, const void *pNext)</td></tr>
<tr class="memdesc:a927c944f45e0f2941182abb6f608e64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds buffer to allocation with additional parameters.  <a href="vk__mem__alloc_8h.html#a927c944f45e0f2941182abb6f608e64a">More...</a><br /></td></tr>
<tr class="separator:a927c944f45e0f2941182abb6f608e64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3ca45799923aa5d138e9e5f9eb2da5"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a3d3ca45799923aa5d138e9e5f9eb2da5">vmaBindImageMemory</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation, VkImage image)</td></tr>
<tr class="memdesc:a3d3ca45799923aa5d138e9e5f9eb2da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds image to allocation.  <a href="vk__mem__alloc_8h.html#a3d3ca45799923aa5d138e9e5f9eb2da5">More...</a><br /></td></tr>
<tr class="separator:a3d3ca45799923aa5d138e9e5f9eb2da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8251ee81b0045a443e35b8e8aa021bc"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#aa8251ee81b0045a443e35b8e8aa021bc">vmaBindImageMemory2</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation, VkDeviceSize allocationLocalOffset, VkImage image, const void *pNext)</td></tr>
<tr class="memdesc:aa8251ee81b0045a443e35b8e8aa021bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds image to allocation with additional parameters.  <a href="vk__mem__alloc_8h.html#aa8251ee81b0045a443e35b8e8aa021bc">More...</a><br /></td></tr>
<tr class="separator:aa8251ee81b0045a443e35b8e8aa021bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72ee55598617e8eecca384e746bab51"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#ac72ee55598617e8eecca384e746bab51">vmaCreateBuffer</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, const VkBufferCreateInfo *pBufferCreateInfo, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *pAllocationCreateInfo, VkBuffer *pBuffer, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *pAllocation, <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *pAllocationInfo)</td></tr>
<tr class="separator:ac72ee55598617e8eecca384e746bab51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9f4e4ba5bf9aab1f1c746387753d77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a0d9f4e4ba5bf9aab1f1c746387753d77">vmaDestroyBuffer</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, VkBuffer buffer, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation)</td></tr>
<tr class="memdesc:a0d9f4e4ba5bf9aab1f1c746387753d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys Vulkan buffer and frees allocated memory.  <a href="vk__mem__alloc_8h.html#a0d9f4e4ba5bf9aab1f1c746387753d77">More...</a><br /></td></tr>
<tr class="separator:a0d9f4e4ba5bf9aab1f1c746387753d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a94f25679275851a53e82eacbcfc73"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#a02a94f25679275851a53e82eacbcfc73">vmaCreateImage</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, const VkImageCreateInfo *pImageCreateInfo, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *pAllocationCreateInfo, VkImage *pImage, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *pAllocation, <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *pAllocationInfo)</td></tr>
<tr class="memdesc:a02a94f25679275851a53e82eacbcfc73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function similar to <a class="el" href="vk__mem__alloc_8h.html#ac72ee55598617e8eecca384e746bab51">vmaCreateBuffer()</a>.  <a href="vk__mem__alloc_8h.html#a02a94f25679275851a53e82eacbcfc73">More...</a><br /></td></tr>
<tr class="separator:a02a94f25679275851a53e82eacbcfc73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50d2cb3b4a3bfd4dd40987234e50e7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vk__mem__alloc_8h.html#ae50d2cb3b4a3bfd4dd40987234e50e7e">vmaDestroyImage</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, VkImage image, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation)</td></tr>
<tr class="memdesc:ae50d2cb3b4a3bfd4dd40987234e50e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys Vulkan image and frees allocated memory.  <a href="vk__mem__alloc_8h.html#ae50d2cb3b4a3bfd4dd40987234e50e7e">More...</a><br /></td></tr>
<tr class="separator:ae50d2cb3b4a3bfd4dd40987234e50e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a9f918755b601cf4bffca775992e6fb90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f918755b601cf4bffca775992e6fb90">&#9670;&nbsp;</a></span>NOMINMAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NOMINMAX</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a88bef97f86d70a34a4c0746e09a2680d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88bef97f86d70a34a4c0746e09a2680d">&#9670;&nbsp;</a></span>VMA_BIND_MEMORY2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMA_BIND_MEMORY2&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f9d5e71b70dd1a137c303a8a8262c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f9d5e71b70dd1a137c303a8a8262c10">&#9670;&nbsp;</a></span>VMA_BUFFER_DEVICE_ADDRESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMA_BUFFER_DEVICE_ADDRESS&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7b860e63b96d11e44ae8587ba06bbf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b860e63b96d11e44ae8587ba06bbf4">&#9670;&nbsp;</a></span>VMA_DEDICATED_ALLOCATION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMA_DEDICATED_ALLOCATION&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05decf1cf4ebf767beba7acca6c1ec3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05decf1cf4ebf767beba7acca6c1ec3a">&#9670;&nbsp;</a></span>VMA_MEMORY_BUDGET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMA_MEMORY_BUDGET&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f0c126759fc96ccb6e2d23c101d770c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f0c126759fc96ccb6e2d23c101d770c">&#9670;&nbsp;</a></span>VMA_RECORDING_ENABLED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMA_RECORDING_ENABLED&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae25f0d55fd91cb166f002b63244800e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25f0d55fd91cb166f002b63244800e1">&#9670;&nbsp;</a></span>VMA_STATS_STRING_ENABLED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMA_STATS_STRING_ENABLED&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a2407c283893638cc039bb31fcd74b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2407c283893638cc039bb31fcd74b6">&#9670;&nbsp;</a></span>VMA_VULKAN_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMA_VULKAN_VERSION&#160;&#160;&#160;1000000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a7e1ed85f7799600b03ad51a77acc21f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e1ed85f7799600b03ad51a77acc21f3">&#9670;&nbsp;</a></span>PFN_vmaAllocateDeviceMemoryFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(VKAPI_PTR * PFN_vmaAllocateDeviceMemoryFunction) (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, uint32_t memoryType, VkDeviceMemory memory, VkDeviceSize size, void *pUserData)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function called after successful vkAllocateMemory. </p>

</div>
</div>
<a id="a154ccaaf53dc2c36378f80f0c4f3679b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154ccaaf53dc2c36378f80f0c4f3679b">&#9670;&nbsp;</a></span>PFN_vmaFreeDeviceMemoryFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(VKAPI_PTR * PFN_vmaFreeDeviceMemoryFunction) (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, uint32_t memoryType, VkDeviceMemory memory, VkDeviceSize size, void *pUserData)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function called before vkFreeMemory. </p>

</div>
</div>
<a id="a4fceecc301f4064dc808d3cd6c038941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fceecc301f4064dc808d3cd6c038941">&#9670;&nbsp;</a></span>VmaAllocationCreateFlagBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597">VmaAllocationCreateFlagBits</a> <a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597">VmaAllocationCreateFlagBits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags to be passed as <a class="el" href="struct_vma_allocation_create_info.html#add09658ac14fe290ace25470ddd6d41b" title="Use VmaAllocationCreateFlagBits enum.">VmaAllocationCreateInfo::flags</a>. </p>

</div>
</div>
<a id="a5225e5e11f8376f6a31a1791f3d6e817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5225e5e11f8376f6a31a1791f3d6e817">&#9670;&nbsp;</a></span>VmaAllocationCreateFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VkFlags <a class="el" href="vk__mem__alloc_8h.html#a5225e5e11f8376f6a31a1791f3d6e817">VmaAllocationCreateFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3bf110892ea2fb4649fedb68488d026a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf110892ea2fb4649fedb68488d026a">&#9670;&nbsp;</a></span>VmaAllocationCreateInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1cf7774606721026a68aabe3af2e5b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf7774606721026a68aabe3af2e5b50">&#9670;&nbsp;</a></span>VmaAllocationInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parameters of <a class="el" href="struct_vma_allocation.html" title="Represents single memory allocation.">VmaAllocation</a> objects, that can be retrieved using function <a class="el" href="vk__mem__alloc_8h.html#a86dd08aba8633bfa4ad0df2e76481d8b" title="Returns current information about specified allocation and atomically marks it as used in current fra...">vmaGetAllocationInfo()</a>. </p>

</div>
</div>
<a id="afd73b95e737ee7e76f827cb5472f559f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd73b95e737ee7e76f827cb5472f559f">&#9670;&nbsp;</a></span>VmaAllocatorCreateFlagBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="vk__mem__alloc_8h.html#a4f87c9100d154a65a4ad495f7763cf7c">VmaAllocatorCreateFlagBits</a> <a class="el" href="vk__mem__alloc_8h.html#a4f87c9100d154a65a4ad495f7763cf7c">VmaAllocatorCreateFlagBits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags for created <a class="el" href="struct_vma_allocator.html" title="Represents main object of this library initialized.">VmaAllocator</a>. </p>

</div>
</div>
<a id="acfe6863e160722c2c1bbcf7573fddc4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe6863e160722c2c1bbcf7573fddc4d">&#9670;&nbsp;</a></span>VmaAllocatorCreateFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VkFlags <a class="el" href="vk__mem__alloc_8h.html#acfe6863e160722c2c1bbcf7573fddc4d">VmaAllocatorCreateFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad9652301d33759b83e52d4f3605a14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad9652301d33759b83e52d4f3605a14a">&#9670;&nbsp;</a></span>VmaAllocatorCreateInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_vma_allocator_create_info.html">VmaAllocatorCreateInfo</a> <a class="el" href="struct_vma_allocator_create_info.html">VmaAllocatorCreateInfo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Description of a Allocator to be created. </p>

</div>
</div>
<a id="a1988031b0223fdbd564250fa1edd942c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1988031b0223fdbd564250fa1edd942c">&#9670;&nbsp;</a></span>VmaAllocatorInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_vma_allocator_info.html">VmaAllocatorInfo</a> <a class="el" href="struct_vma_allocator_info.html">VmaAllocatorInfo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Information about existing <a class="el" href="struct_vma_allocator.html" title="Represents main object of this library initialized.">VmaAllocator</a> object. </p>

</div>
</div>
<a id="aa078667e71b1ef24e87a6a30d128381d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa078667e71b1ef24e87a6a30d128381d">&#9670;&nbsp;</a></span>VmaBudget</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_vma_budget.html">VmaBudget</a> <a class="el" href="struct_vma_budget.html">VmaBudget</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statistics of current memory usage and available budget, in bytes, for specific memory heap. </p>

</div>
</div>
<a id="a13415cc0b443353a7b5abda300b833fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13415cc0b443353a7b5abda300b833fc">&#9670;&nbsp;</a></span>VmaDefragmentationFlagBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="vk__mem__alloc_8h.html#a6552a65b71d16f378c6994b3ceaef50c">VmaDefragmentationFlagBits</a> <a class="el" href="vk__mem__alloc_8h.html#a6552a65b71d16f378c6994b3ceaef50c">VmaDefragmentationFlagBits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags to be used in <a class="el" href="vk__mem__alloc_8h.html#a36ba776fd7fd5cb1e9359fdc0d8e6e8a" title="Begins defragmentation process.">vmaDefragmentationBegin()</a>. None at the moment. Reserved for future use. </p>

</div>
</div>
<a id="a88a77cef37e5d3c4fc9eb328885d048d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a77cef37e5d3c4fc9eb328885d048d">&#9670;&nbsp;</a></span>VmaDefragmentationFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VkFlags <a class="el" href="vk__mem__alloc_8h.html#a88a77cef37e5d3c4fc9eb328885d048d">VmaDefragmentationFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bf47f96bf92bed2a49461bd9af3acfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf47f96bf92bed2a49461bd9af3acfa">&#9670;&nbsp;</a></span>VmaDefragmentationInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_vma_defragmentation_info.html">VmaDefragmentationInfo</a> <a class="el" href="struct_vma_defragmentation_info.html">VmaDefragmentationInfo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated. Optional configuration parameters to be passed to function <a class="el" href="vk__mem__alloc_8h.html#a9f0f8f56db5f7f57fe4454f465142dac" title="Deprecated. Compacts memory by moving allocations.">vmaDefragment()</a>. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>This is a part of the old interface. It is recommended to use structure <a class="el" href="struct_vma_defragmentation_info2.html" title="Parameters for defragmentation.">VmaDefragmentationInfo2</a> and function <a class="el" href="vk__mem__alloc_8h.html#a36ba776fd7fd5cb1e9359fdc0d8e6e8a" title="Begins defragmentation process.">vmaDefragmentationBegin()</a> instead. </dd></dl>

</div>
</div>
<a id="ad6daeffaa670ce6d11a203a6224c9937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6daeffaa670ce6d11a203a6224c9937">&#9670;&nbsp;</a></span>VmaDefragmentationInfo2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_vma_defragmentation_info2.html">VmaDefragmentationInfo2</a> <a class="el" href="struct_vma_defragmentation_info2.html">VmaDefragmentationInfo2</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parameters for defragmentation. </p>
<p>To be used with function <a class="el" href="vk__mem__alloc_8h.html#a36ba776fd7fd5cb1e9359fdc0d8e6e8a" title="Begins defragmentation process.">vmaDefragmentationBegin()</a>. </p>

</div>
</div>
<a id="a72aebd522242d56abea67b4f47f6549e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72aebd522242d56abea67b4f47f6549e">&#9670;&nbsp;</a></span>VmaDefragmentationPassInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_vma_defragmentation_pass_info.html">VmaDefragmentationPassInfo</a> <a class="el" href="struct_vma_defragmentation_pass_info.html">VmaDefragmentationPassInfo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parameters for incremental defragmentation steps. </p>
<p>To be used with function <a class="el" href="vk__mem__alloc_8h.html#ac0f01545b6262f7d4d128fc8f8e5c77b">vmaBeginDefragmentationPass()</a>. </p>

</div>
</div>
<a id="ad6799e8e2b1527abfc84d33bc44aeaf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6799e8e2b1527abfc84d33bc44aeaf5">&#9670;&nbsp;</a></span>VmaDefragmentationPassMoveInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_vma_defragmentation_pass_move_info.html">VmaDefragmentationPassMoveInfo</a> <a class="el" href="struct_vma_defragmentation_pass_move_info.html">VmaDefragmentationPassMoveInfo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad94034192259c2e34a4d1c5e27810403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94034192259c2e34a4d1c5e27810403">&#9670;&nbsp;</a></span>VmaDefragmentationStats</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_vma_defragmentation_stats.html">VmaDefragmentationStats</a> <a class="el" href="struct_vma_defragmentation_stats.html">VmaDefragmentationStats</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statistics returned by function <a class="el" href="vk__mem__alloc_8h.html#a9f0f8f56db5f7f57fe4454f465142dac" title="Deprecated. Compacts memory by moving allocations.">vmaDefragment()</a>. </p>

</div>
</div>
<a id="a77692d3c8770ea8882d573206bd27b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77692d3c8770ea8882d573206bd27b2b">&#9670;&nbsp;</a></span>VmaDeviceMemoryCallbacks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_vma_device_memory_callbacks.html">VmaDeviceMemoryCallbacks</a> <a class="el" href="struct_vma_device_memory_callbacks.html">VmaDeviceMemoryCallbacks</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set of callbacks that the library will call for <code>vkAllocateMemory</code> and <code>vkFreeMemory</code>. </p>
<p>Provided for informative purpose, e.g. to gather statistics about number of allocations or total amount of memory allocated in Vulkan.</p>
<p>Used in <a class="el" href="struct_vma_allocator_create_info.html#af1380969b5e1ea4c3184a877892d260e" title="Informative callbacks for vkAllocateMemory, vkFreeMemory. Optional.">VmaAllocatorCreateInfo::pDeviceMemoryCallbacks</a>. </p>

</div>
</div>
<a id="a806e8499dde802e59eb72a1dc811c35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a806e8499dde802e59eb72a1dc811c35f">&#9670;&nbsp;</a></span>VmaMemoryUsage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="vk__mem__alloc_8h.html#aa5846affa1e9da3800e3e78fae2305cc">VmaMemoryUsage</a> <a class="el" href="vk__mem__alloc_8h.html#aa5846affa1e9da3800e3e78fae2305cc">VmaMemoryUsage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d4f2efc2509157a9e4ecd4fd7942303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4f2efc2509157a9e4ecd4fd7942303">&#9670;&nbsp;</a></span>VmaPoolCreateFlagBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="vk__mem__alloc_8h.html#a9a7c45f9c863695d98c83fa5ac940fe7">VmaPoolCreateFlagBits</a> <a class="el" href="vk__mem__alloc_8h.html#a9a7c45f9c863695d98c83fa5ac940fe7">VmaPoolCreateFlagBits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags to be passed as <a class="el" href="struct_vma_pool_create_info.html#a8405139f63d078340ae74513a59f5446" title="Use combination of VmaPoolCreateFlagBits.">VmaPoolCreateInfo::flags</a>. </p>

</div>
</div>
<a id="a2770e325ea42e087c1b91fdf46d0292a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2770e325ea42e087c1b91fdf46d0292a">&#9670;&nbsp;</a></span>VmaPoolCreateFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VkFlags <a class="el" href="vk__mem__alloc_8h.html#a2770e325ea42e087c1b91fdf46d0292a">VmaPoolCreateFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1017aa83489c0eee8d2163d2bf253f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1017aa83489c0eee8d2163d2bf253f67">&#9670;&nbsp;</a></span>VmaPoolCreateInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_vma_pool_create_info.html">VmaPoolCreateInfo</a> <a class="el" href="struct_vma_pool_create_info.html">VmaPoolCreateInfo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes parameter of created <a class="el" href="struct_vma_pool.html" title="Represents custom memory pool.">VmaPool</a>. </p>

</div>
</div>
<a id="a4759a2d9f99c19ba7627553c847132f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4759a2d9f99c19ba7627553c847132f1">&#9670;&nbsp;</a></span>VmaPoolStats</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_vma_pool_stats.html">VmaPoolStats</a> <a class="el" href="struct_vma_pool_stats.html">VmaPoolStats</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes parameter of existing <a class="el" href="struct_vma_pool.html" title="Represents custom memory pool.">VmaPool</a>. </p>

</div>
</div>
<a id="acd24d5eb58abff7e1f43cb32a1ba1413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd24d5eb58abff7e1f43cb32a1ba1413">&#9670;&nbsp;</a></span>VmaRecordFlagBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="vk__mem__alloc_8h.html#a4dd2c44642312a147a4e93373a6e64d2">VmaRecordFlagBits</a> <a class="el" href="vk__mem__alloc_8h.html#a4dd2c44642312a147a4e93373a6e64d2">VmaRecordFlagBits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags to be used in <a class="el" href="struct_vma_record_settings.html#ad8fdcc92119ae7a8c08c1a564c01d63a" title="Flags for recording. Use VmaRecordFlagBits enum.">VmaRecordSettings::flags</a>. </p>

</div>
</div>
<a id="af3929a1a4547c592fc0b0e55ef452828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3929a1a4547c592fc0b0e55ef452828">&#9670;&nbsp;</a></span>VmaRecordFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VkFlags <a class="el" href="vk__mem__alloc_8h.html#af3929a1a4547c592fc0b0e55ef452828">VmaRecordFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16e21c877101493fce582664cd8754fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e21c877101493fce582664cd8754fc">&#9670;&nbsp;</a></span>VmaRecordSettings</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_vma_record_settings.html">VmaRecordSettings</a> <a class="el" href="struct_vma_record_settings.html">VmaRecordSettings</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parameters for recording calls to VMA functions. To be used in <a class="el" href="struct_vma_allocator_create_info.html#ace2aa4877b16a42b0b7673d4e26000ee" title="Parameters for recording of VMA calls. Can be null.">VmaAllocatorCreateInfo::pRecordSettings</a>. </p>

</div>
</div>
<a id="aec5b57e29c97b5d69c6d5654d60df878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec5b57e29c97b5d69c6d5654d60df878">&#9670;&nbsp;</a></span>VmaStatInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_vma_stat_info.html">VmaStatInfo</a> <a class="el" href="struct_vma_stat_info.html">VmaStatInfo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculated statistics of memory usage in entire allocator. </p>

</div>
</div>
<a id="a21813b2efdf3836767a9058cd8a94034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21813b2efdf3836767a9058cd8a94034">&#9670;&nbsp;</a></span>VmaStats</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_vma_stats.html">VmaStats</a> <a class="el" href="struct_vma_stats.html">VmaStats</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General statistics from current state of Allocator. </p>

</div>
</div>
<a id="abb0a8e3b5040d847571cca6c7f9a8074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0a8e3b5040d847571cca6c7f9a8074">&#9670;&nbsp;</a></span>VmaVulkanFunctions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_vma_vulkan_functions.html">VmaVulkanFunctions</a> <a class="el" href="struct_vma_vulkan_functions.html">VmaVulkanFunctions</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointers to some Vulkan functions - a subset used by the library. </p>
<p>Used in <a class="el" href="struct_vma_allocator_create_info.html#a3dc197be3227da7338b1643f70db36bd" title="Pointers to Vulkan functions. Can be null.">VmaAllocatorCreateInfo::pVulkanFunctions</a>. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ad9889c10c798b040d59c92f257cae597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9889c10c798b040d59c92f257cae597">&#9670;&nbsp;</a></span>VmaAllocationCreateFlagBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597">VmaAllocationCreateFlagBits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags to be passed as <a class="el" href="struct_vma_allocation_create_info.html#add09658ac14fe290ace25470ddd6d41b" title="Use VmaAllocationCreateFlagBits enum.">VmaAllocationCreateInfo::flags</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f"></a>VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT&#160;</td><td class="fielddoc"><p>Set this flag if the allocation should have its own memory block. </p>
<p>Use it for special, big resources, like fullscreen images used as attachments.</p>
<p>You should not use this flag if <a class="el" href="struct_vma_allocation_create_info.html#a6272c0555cfd1fe28bff1afeb6190150" title="Pool that this allocation should be created in.">VmaAllocationCreateInfo::pool</a> is not null. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad9889c10c798b040d59c92f257cae597a89759603401014eb325eb22a3839f2ff"></a>VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT&#160;</td><td class="fielddoc"><p>Set this flag to only try to allocate from existing <code>VkDeviceMemory</code> blocks and never create new such block. </p>
<p>If new allocation cannot be placed in any of the existing blocks, allocation fails with <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> error.</p>
<p>You should not use <a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" title="Set this flag if the allocation should have its own memory block.">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</a> and <a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a89759603401014eb325eb22a3839f2ff" title="Set this flag to only try to allocate from existing VkDeviceMemory blocks and never create new such b...">VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</a> at the same time. It makes no sense.</p>
<p>If <a class="el" href="struct_vma_allocation_create_info.html#a6272c0555cfd1fe28bff1afeb6190150" title="Pool that this allocation should be created in.">VmaAllocationCreateInfo::pool</a> is not null, this flag is implied and ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f"></a>VMA_ALLOCATION_CREATE_MAPPED_BIT&#160;</td><td class="fielddoc"><p>Set this flag to use a memory that will be persistently mapped and retrieve pointer to it. </p>
<p>Pointer to mapped memory will be returned through <a class="el" href="struct_vma_allocation_info.html#a5eeffbe2d2f30f53370ff14aefbadbe2" title="Pointer to the beginning of this allocation as mapped data.">VmaAllocationInfo::pMappedData</a>.</p>
<p>Is it valid to use this flag for allocation made from memory type that is not <code>HOST_VISIBLE</code>. This flag is then ignored and memory is not mapped. This is useful if you need an allocation that is efficient to use on GPU (<code>DEVICE_LOCAL</code>) and still want to map it directly if possible on platforms that support it (e.g. Intel GPU).</p>
<p>You should not use this flag together with <a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a5f436af6c8fe8540573a6d22627a6fd2">VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad9889c10c798b040d59c92f257cae597a5f436af6c8fe8540573a6d22627a6fd2"></a>VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT&#160;</td><td class="fielddoc"><p>Allocation created with this flag can become lost as a result of another allocation with <a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a68686d0ce9beb0d4d1b9f2b8b1389a7e">VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT</a> flag, so you must check it before use.</p>
<p>To check if allocation is not lost, call <a class="el" href="vk__mem__alloc_8h.html#a86dd08aba8633bfa4ad0df2e76481d8b" title="Returns current information about specified allocation and atomically marks it as used in current fra...">vmaGetAllocationInfo()</a> and check if <a class="el" href="struct_vma_allocation_info.html#ae0bfb7dfdf79a76ffefc9a94677a2f67" title="Handle to Vulkan memory object.">VmaAllocationInfo::deviceMemory</a> is not <code>VK_NULL_HANDLE</code>.</p>
<p>For details about supporting lost allocations, see Lost Allocations chapter of User Guide on Main Page.</p>
<p>You should not use this flag together with <a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" title="Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.">VMA_ALLOCATION_CREATE_MAPPED_BIT</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad9889c10c798b040d59c92f257cae597a68686d0ce9beb0d4d1b9f2b8b1389a7e"></a>VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT&#160;</td><td class="fielddoc"><p>While creating allocation using this flag, other allocations that were created with flag <a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a5f436af6c8fe8540573a6d22627a6fd2">VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT</a> can become lost.</p>
<p>For details about supporting lost allocations, see Lost Allocations chapter of User Guide on Main Page. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad9889c10c798b040d59c92f257cae597aa6f24f821cd6a7c5e4a443f7bf59c520"></a>VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT&#160;</td><td class="fielddoc"><p>Set this flag to treat <a class="el" href="struct_vma_allocation_create_info.html#a8259e85c272683434f4abb4ddddffe19" title="Custom general-purpose pointer that will be stored in VmaAllocation, can be read as VmaAllocationInfo...">VmaAllocationCreateInfo::pUserData</a> as pointer to a null-terminated string. Instead of copying pointer value, a local copy of the string is made and stored in allocation's <code>pUserData</code>. The string is automatically freed together with the allocation. It is also used in <a class="el" href="vk__mem__alloc_8h.html#aa4fee7eb5253377599ef4fd38c93c2a0" title="Builds and returns statistics as string in JSON format.">vmaBuildStatsString()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad9889c10c798b040d59c92f257cae597a42ba3a2d2c7117953210b7c3ef8da0df"></a>VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT&#160;</td><td class="fielddoc"><p>Allocation will be created from upper stack in a double stack pool.</p>
<p>This flag is only allowed for custom pools created with <a class="el" href="vk__mem__alloc_8h.html#a9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726" title="Enables alternative, linear allocation algorithm in this pool.">VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</a> flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad9889c10c798b040d59c92f257cae597a2310568c62208af432724305fe29ccea"></a>VMA_ALLOCATION_CREATE_DONT_BIND_BIT&#160;</td><td class="fielddoc"><p>Create both buffer/image and allocation, but don't bind them together. It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions. The flag is meaningful only with functions that bind by default: <a class="el" href="vk__mem__alloc_8h.html#ac72ee55598617e8eecca384e746bab51">vmaCreateBuffer()</a>, <a class="el" href="vk__mem__alloc_8h.html#a02a94f25679275851a53e82eacbcfc73" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a>. Otherwise it is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad9889c10c798b040d59c92f257cae597ab8b1764f3e9022368e440c057783b92d"></a>VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT&#160;</td><td class="fielddoc"><p>Create allocation only if additional device memory required for it, if any, won't exceed memory budget. Otherwise return <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad9889c10c798b040d59c92f257cae597a839826775c62319466441f86496f036d"></a>VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT&#160;</td><td class="fielddoc"><p>Allocation strategy that chooses smallest possible free range for the allocation. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad9889c10c798b040d59c92f257cae597ad242a04f802e25fef0b880afe8bb0a62"></a>VMA_ALLOCATION_CREATE_STRATEGY_WORST_FIT_BIT&#160;</td><td class="fielddoc"><p>Allocation strategy that chooses biggest possible free range for the allocation. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad9889c10c798b040d59c92f257cae597a33eb2052674f3ad92386c714a65fb777"></a>VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT&#160;</td><td class="fielddoc"><p>Allocation strategy that chooses first suitable free range for the allocation.</p>
<p>"First" doesn't necessarily means the one with smallest offset in memory, but rather the one that is easiest and fastest to find. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad9889c10c798b040d59c92f257cae597a8af1210cf591784afa026d94998f735d"></a>VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT&#160;</td><td class="fielddoc"><p>Allocation strategy that tries to minimize memory usage. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad9889c10c798b040d59c92f257cae597a0729e932b7ea170e3a128cad96c5cf6d"></a>VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT&#160;</td><td class="fielddoc"><p>Allocation strategy that tries to minimize allocation time. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad9889c10c798b040d59c92f257cae597a621b704103eb3360230c860acf36e706"></a>VMA_ALLOCATION_CREATE_STRATEGY_MIN_FRAGMENTATION_BIT&#160;</td><td class="fielddoc"><p>Allocation strategy that tries to minimize memory fragmentation. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad9889c10c798b040d59c92f257cae597a8e16845d81ae3d27c47106d4770d5c7e"></a>VMA_ALLOCATION_CREATE_STRATEGY_MASK&#160;</td><td class="fielddoc"><p>A bit mask to extract only <code>STRATEGY</code> bits from entire set of flags. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad9889c10c798b040d59c92f257cae597ae5633ec569f4899cf8f29e7385b2f882"></a>VMA_ALLOCATION_CREATE_FLAG_BITS_MAX_ENUM&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a4f87c9100d154a65a4ad495f7763cf7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f87c9100d154a65a4ad495f7763cf7c">&#9670;&nbsp;</a></span>VmaAllocatorCreateFlagBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="vk__mem__alloc_8h.html#a4f87c9100d154a65a4ad495f7763cf7c">VmaAllocatorCreateFlagBits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags for created <a class="el" href="struct_vma_allocator.html" title="Represents main object of this library initialized.">VmaAllocator</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4f87c9100d154a65a4ad495f7763cf7ca4816ddaed324ba110172ca608a20f29d"></a>VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT&#160;</td><td class="fielddoc"><p>Allocator and all objects created from it will not be synchronized internally, so you must guarantee they are used from only one thread at a time or synchronized externally by you. </p>
<p>Using this flag may increase performance because internal mutexes are not used. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4f87c9100d154a65a4ad495f7763cf7cace7da7cc6e71a625dfa763c55a597878"></a>VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT&#160;</td><td class="fielddoc"><p>Enables usage of VK_KHR_dedicated_allocation extension. </p>
<p>The flag works only if <a class="el" href="struct_vma_allocator_create_info.html#ae0ffc55139b54520a6bb704b29ffc285" title="Optional. The highest version of Vulkan that the application is designed to use.">VmaAllocatorCreateInfo::vulkanApiVersion</a> <code>== VK_API_VERSION_1_0</code>. When it's <code>VK_API_VERSION_1_1</code>, the flag is ignored because the extension has been promoted to Vulkan 1.1.</p>
<p>Using this extenion will automatically allocate dedicated blocks of memory for some buffers and images instead of suballocating place for them out of bigger memory blocks (as if you explicitly used <a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" title="Set this flag if the allocation should have its own memory block.">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</a> flag) when it is recommended by the driver. It may improve performance on some GPUs.</p>
<p>You may set this flag only if you found out that following device extensions are supported, you enabled them while creating Vulkan device passed as <a class="el" href="struct_vma_allocator_create_info.html#ad924ddd77b04039c88d0c09b0ffcd500" title="Vulkan device.">VmaAllocatorCreateInfo::device</a>, and you want them to be used internally by this library:</p>
<ul>
<li>VK_KHR_get_memory_requirements2 (device extension)</li>
<li>VK_KHR_dedicated_allocation (device extension)</li>
</ul>
<p>When this flag is set, you can experience following warnings reported by Vulkan validation layer. You can ignore them.</p>
<blockquote class="doxtable">
<p>vkBindBufferMemory(): Binding memory to buffer 0x2d but vkGetBufferMemoryRequirements() has not been called on that buffer. </p>
</blockquote>
</td></tr>
<tr><td class="fieldname"><a id="a4f87c9100d154a65a4ad495f7763cf7ca8fb75bf07cd184ab903596295e863dee"></a>VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT&#160;</td><td class="fielddoc"><p>Enables usage of VK_KHR_bind_memory2 extension.</p>
<p>The flag works only if <a class="el" href="struct_vma_allocator_create_info.html#ae0ffc55139b54520a6bb704b29ffc285" title="Optional. The highest version of Vulkan that the application is designed to use.">VmaAllocatorCreateInfo::vulkanApiVersion</a> <code>== VK_API_VERSION_1_0</code>. When it's <code>VK_API_VERSION_1_1</code>, the flag is ignored because the extension has been promoted to Vulkan 1.1.</p>
<p>You may set this flag only if you found out that this device extension is supported, you enabled it while creating Vulkan device passed as <a class="el" href="struct_vma_allocator_create_info.html#ad924ddd77b04039c88d0c09b0ffcd500" title="Vulkan device.">VmaAllocatorCreateInfo::device</a>, and you want it to be used internally by this library.</p>
<p>The extension provides functions <code>vkBindBufferMemory2KHR</code> and <code>vkBindImageMemory2KHR</code>, which allow to pass a chain of <code>pNext</code> structures while binding. This flag is required if you use <code>pNext</code> parameter in <a class="el" href="vk__mem__alloc_8h.html#a927c944f45e0f2941182abb6f608e64a" title="Binds buffer to allocation with additional parameters.">vmaBindBufferMemory2()</a> or <a class="el" href="vk__mem__alloc_8h.html#aa8251ee81b0045a443e35b8e8aa021bc" title="Binds image to allocation with additional parameters.">vmaBindImageMemory2()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4f87c9100d154a65a4ad495f7763cf7ca4d4687863f7bd4b418c6006dc04400b0"></a>VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT&#160;</td><td class="fielddoc"><p>Enables usage of VK_EXT_memory_budget extension.</p>
<p>You may set this flag only if you found out that this device extension is supported, you enabled it while creating Vulkan device passed as <a class="el" href="struct_vma_allocator_create_info.html#ad924ddd77b04039c88d0c09b0ffcd500" title="Vulkan device.">VmaAllocatorCreateInfo::device</a>, and you want it to be used internally by this library, along with another instance extension VK_KHR_get_physical_device_properties2, which is required by it (or Vulkan 1.1, where this extension is promoted).</p>
<p>The extension provides query for current memory usage and budget, which will probably be more accurate than an estimation used by the library otherwise. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4f87c9100d154a65a4ad495f7763cf7ca2acce4886d8078552efa38878413970f"></a>VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT&#160;</td><td class="fielddoc"><p>Enables usage of VK_AMD_device_coherent_memory extension.</p>
<p>You may set this flag only if you:</p>
<ul>
<li>found out that this device extension is supported and enabled it while creating Vulkan device passed as <a class="el" href="struct_vma_allocator_create_info.html#ad924ddd77b04039c88d0c09b0ffcd500" title="Vulkan device.">VmaAllocatorCreateInfo::device</a>,</li>
<li>checked that <code>VkPhysicalDeviceCoherentMemoryFeaturesAMD::deviceCoherentMemory</code> is true and set it while creating the Vulkan device,</li>
<li>want it to be used internally by this library.</li>
</ul>
<p>The extension and accompanying device feature provide access to memory types with <code>VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD</code> and <code>VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD</code> flags. They are useful mostly for writing breadcrumb markers - a common method for debugging GPU crash/hang/TDR.</p>
<p>When the extension is not enabled, such memory types are still enumerated, but their usage is illegal. To protect from this error, if you don't create the allocator with this flag, it will refuse to allocate any memory or create a custom pool in such memory type, returning <code>VK_ERROR_FEATURE_NOT_PRESENT</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4f87c9100d154a65a4ad495f7763cf7ca5f1b28b0414319d1687e1f2b30ab0089"></a>VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT&#160;</td><td class="fielddoc"><p>Enables usage of "buffer device address" feature, which allows you to use function <code>vkGetBufferDeviceAddress*</code> to get raw GPU pointer to a buffer and pass it for usage inside a shader.</p>
<p>You may set this flag only if you:</p>
<ol type="1">
<li>(For Vulkan version &lt; 1.2) Found as available and enabled device extension VK_KHR_buffer_device_address. This extension is promoted to core Vulkan 1.2.</li>
<li>Found as available and enabled device feature <code>VkPhysicalDeviceBufferDeviceAddressFeatures*::bufferDeviceAddress</code>.</li>
</ol>
<p>When this flag is set, you can create buffers with <code>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT*</code> using VMA. The library automatically adds <code>VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT*</code> to allocated memory blocks wherever it might be needed.</p>
<p>For more information, see documentation chapter <a class="el" href="enabling_buffer_device_address.html">Enabling buffer device address</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4f87c9100d154a65a4ad495f7763cf7cae4d5ad929caba5f23eb502b13bd5286c"></a>VMA_ALLOCATOR_CREATE_FLAG_BITS_MAX_ENUM&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a6552a65b71d16f378c6994b3ceaef50c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6552a65b71d16f378c6994b3ceaef50c">&#9670;&nbsp;</a></span>VmaDefragmentationFlagBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="vk__mem__alloc_8h.html#a6552a65b71d16f378c6994b3ceaef50c">VmaDefragmentationFlagBits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags to be used in <a class="el" href="vk__mem__alloc_8h.html#a36ba776fd7fd5cb1e9359fdc0d8e6e8a" title="Begins defragmentation process.">vmaDefragmentationBegin()</a>. None at the moment. Reserved for future use. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6552a65b71d16f378c6994b3ceaef50ca31af49446af2459284a568ce2f3fdd33"></a>VMA_DEFRAGMENTATION_FLAG_INCREMENTAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6552a65b71d16f378c6994b3ceaef50cab87ec33154803bfeb5ac2b379f1d6a97"></a>VMA_DEFRAGMENTATION_FLAG_BITS_MAX_ENUM&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="aa5846affa1e9da3800e3e78fae2305cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5846affa1e9da3800e3e78fae2305cc">&#9670;&nbsp;</a></span>VmaMemoryUsage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="vk__mem__alloc_8h.html#aa5846affa1e9da3800e3e78fae2305cc">VmaMemoryUsage</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa5846affa1e9da3800e3e78fae2305ccaf50d27e34e0925cf3a63db8c839121dd"></a>VMA_MEMORY_USAGE_UNKNOWN&#160;</td><td class="fielddoc"><p>No intended memory usage specified. Use other members of <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> to specify your requirements. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa5846affa1e9da3800e3e78fae2305ccac6b5dc1432d88647aa4cd456246eadf7"></a>VMA_MEMORY_USAGE_GPU_ONLY&#160;</td><td class="fielddoc"><p>Memory will be used on device only, so fast access from the device is preferred. It usually means device-local GPU (video) memory. No need to be mappable on host. It is roughly equivalent of <code>D3D12_HEAP_TYPE_DEFAULT</code>.</p>
<p>Usage:</p>
<ul>
<li>Resources written and read by device, e.g. images used as attachments.</li>
<li>Resources transferred from host once (immutable) or infrequently and read by device multiple times, e.g. textures to be sampled, vertex buffers, uniform (constant) buffers, and majority of other types of resources used on GPU.</li>
</ul>
<p>Allocation may still end up in <code>HOST_VISIBLE</code> memory on some implementations. In such case, you are free to map it. You can use <a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" title="Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.">VMA_ALLOCATION_CREATE_MAPPED_BIT</a> with this usage type. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa5846affa1e9da3800e3e78fae2305cca40bdf4cddeffeb12f43d45ca1286e0a5"></a>VMA_MEMORY_USAGE_CPU_ONLY&#160;</td><td class="fielddoc"><p>Memory will be mappable on host. It usually means CPU (system) memory. Guarantees to be <code>HOST_VISIBLE</code> and <code>HOST_COHERENT</code>. CPU access is typically uncached. Writes may be write-combined. Resources created in this pool may still be accessible to the device, but access to them can be slow. It is roughly equivalent of <code>D3D12_HEAP_TYPE_UPLOAD</code>.</p>
<p>Usage: Staging copy of resources used as transfer source. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa5846affa1e9da3800e3e78fae2305cca9066b52c5a7079bb74a69aaf8b92ff67"></a>VMA_MEMORY_USAGE_CPU_TO_GPU&#160;</td><td class="fielddoc"><p>Memory that is both mappable on host (guarantees to be <code>HOST_VISIBLE</code>) and preferably fast to access by GPU. CPU access is typically uncached. Writes may be write-combined.</p>
<p>Usage: Resources written frequently by host (dynamic), read by device. E.g. textures, vertex buffers, uniform buffers updated every frame or every draw call. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa5846affa1e9da3800e3e78fae2305cca7b586d2fdaf82a463b58f581ed72be27"></a>VMA_MEMORY_USAGE_GPU_TO_CPU&#160;</td><td class="fielddoc"><p>Memory mappable on host (guarantees to be <code>HOST_VISIBLE</code>) and cached. It is roughly equivalent of <code>D3D12_HEAP_TYPE_READBACK</code>.</p>
<p>Usage:</p>
<ul>
<li>Resources written by device, read by host - results of some computations, e.g. screen capture, average scene luminance for HDR tone mapping.</li>
<li>Any resources read or accessed randomly on host, e.g. CPU-side copy of vertex buffer used as source of transfer, but also used for collision detection. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="aa5846affa1e9da3800e3e78fae2305cca416a444d4d0fc20067c3f76f32ff2500"></a>VMA_MEMORY_USAGE_CPU_COPY&#160;</td><td class="fielddoc"><p>CPU memory - memory that is preferably not <code>DEVICE_LOCAL</code>, but also not guaranteed to be <code>HOST_VISIBLE</code>.</p>
<p>Usage: Staging copy of resources moved from GPU memory to CPU memory as part of custom paging/residency mechanism, to be moved back to GPU memory when needed. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa5846affa1e9da3800e3e78fae2305cca835333d9072db63a653818030e17614d"></a>VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED&#160;</td><td class="fielddoc"><p>Lazily allocated GPU memory having <code>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code>. Exists mostly on mobile platforms. Using it on desktop PC or other GPUs with no such memory type present will fail the allocation.</p>
<p>Usage: Memory for transient attachment images (color attachments, depth attachments etc.), created with <code>VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</code>.</p>
<p>Allocations with this usage are always created as dedicated - it implies <a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" title="Set this flag if the allocation should have its own memory block.">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa5846affa1e9da3800e3e78fae2305cca091e69437ef693e8d0d287f1c719ba6e"></a>VMA_MEMORY_USAGE_MAX_ENUM&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a9a7c45f9c863695d98c83fa5ac940fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7c45f9c863695d98c83fa5ac940fe7">&#9670;&nbsp;</a></span>VmaPoolCreateFlagBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="vk__mem__alloc_8h.html#a9a7c45f9c863695d98c83fa5ac940fe7">VmaPoolCreateFlagBits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags to be passed as <a class="el" href="struct_vma_pool_create_info.html#a8405139f63d078340ae74513a59f5446" title="Use combination of VmaPoolCreateFlagBits.">VmaPoolCreateInfo::flags</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9a7c45f9c863695d98c83fa5ac940fe7a9f1a499508a8edb4e8ba40aa0290a3d2"></a>VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT&#160;</td><td class="fielddoc"><p>Use this flag if you always allocate only buffers and linear images or only optimal images out of this pool and so Buffer-Image Granularity can be ignored. </p>
<p>This is an optional optimization flag.</p>
<p>If you always allocate using <a class="el" href="vk__mem__alloc_8h.html#ac72ee55598617e8eecca384e746bab51">vmaCreateBuffer()</a>, <a class="el" href="vk__mem__alloc_8h.html#a02a94f25679275851a53e82eacbcfc73" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a>, <a class="el" href="vk__mem__alloc_8h.html#a7fdf64415b6c3d83c454f28d2c53df7b">vmaAllocateMemoryForBuffer()</a>, then you don't need to use it because allocator knows exact type of your allocations so it can handle Buffer-Image Granularity in the optimal way.</p>
<p>If you also allocate using <a class="el" href="vk__mem__alloc_8h.html#a0faa3f9e5fb233d29d1e00390650febb" title="Function similar to vmaAllocateMemoryForBuffer().">vmaAllocateMemoryForImage()</a> or <a class="el" href="vk__mem__alloc_8h.html#abf28077dbf82d0908b8acbe8ee8dd9b8" title="General purpose memory allocation.">vmaAllocateMemory()</a>, exact type of such allocations is not known, so allocator must be conservative in handling Buffer-Image Granularity, which can lead to suboptimal allocation (wasted memory). In that case, if you can make sure you always allocate only buffers and linear images or only optimal images out of this pool, use this flag to make allocator disregard Buffer-Image Granularity and so make allocations faster and more optimal. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726"></a>VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT&#160;</td><td class="fielddoc"><p>Enables alternative, linear allocation algorithm in this pool. </p>
<p>Specify this flag to enable linear allocation algorithm, which always creates new allocations after last one and doesn't reuse space from allocations freed in between. It trades memory consumption for simplified algorithm and data structure, which has better performance and uses less memory for metadata.</p>
<p>By using this flag, you can achieve behavior of free-at-once, stack, ring buffer, and double stack. For details, see documentation chapter <a class="el" href="custom_memory_pools.html#linear_algorithm">Linear allocation algorithm</a>.</p>
<p>When using this flag, you must specify <a class="el" href="struct_vma_pool_create_info.html#ae41142f2834fcdc82baa4883c187b75c" title="Maximum number of blocks that can be allocated in this pool. Optional.">VmaPoolCreateInfo::maxBlockCount</a> == 1 (or 0 for default).</p>
<p>For more details, see <a class="el" href="custom_memory_pools.html#linear_algorithm">Linear allocation algorithm</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9a7c45f9c863695d98c83fa5ac940fe7a97a0dc38e5161b780594d998d313d35e"></a>VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT&#160;</td><td class="fielddoc"><p>Enables alternative, buddy allocation algorithm in this pool. </p>
<p>It operates on a tree of blocks, each having size that is a power of two and a half of its parent's size. Comparing to default algorithm, this one provides faster allocation and deallocation and decreased external fragmentation, at the expense of more memory wasted (internal fragmentation).</p>
<p>For more details, see <a class="el" href="custom_memory_pools.html#buddy_algorithm">Buddy allocation algorithm</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9a7c45f9c863695d98c83fa5ac940fe7af4d270f8f42517a0f70037ceb6ac1d9c"></a>VMA_POOL_CREATE_ALGORITHM_MASK&#160;</td><td class="fielddoc"><p>Bit mask to extract only <code>ALGORITHM</code> bits from entire set of flags. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9a7c45f9c863695d98c83fa5ac940fe7a1c7312bea9ea246846b9054fd6bd6aec"></a>VMA_POOL_CREATE_FLAG_BITS_MAX_ENUM&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a4dd2c44642312a147a4e93373a6e64d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd2c44642312a147a4e93373a6e64d2">&#9670;&nbsp;</a></span>VmaRecordFlagBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="vk__mem__alloc_8h.html#a4dd2c44642312a147a4e93373a6e64d2">VmaRecordFlagBits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags to be used in <a class="el" href="struct_vma_record_settings.html#ad8fdcc92119ae7a8c08c1a564c01d63a" title="Flags for recording. Use VmaRecordFlagBits enum.">VmaRecordSettings::flags</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4dd2c44642312a147a4e93373a6e64d2a8e7ab322e8732654be627c4ea8f36cc7"></a>VMA_RECORD_FLUSH_AFTER_CALL_BIT&#160;</td><td class="fielddoc"><p>Enables flush after recording every function call. </p>
<p>Enable it if you expect your application to crash, which may leave recording file truncated. It may degrade performance though. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4dd2c44642312a147a4e93373a6e64d2a20dd17d69966dbffa054739d6090b85e"></a>VMA_RECORD_FLAG_BITS_MAX_ENUM&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="abf28077dbf82d0908b8acbe8ee8dd9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf28077dbf82d0908b8acbe8ee8dd9b8">&#9670;&nbsp;</a></span>vmaAllocateMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaAllocateMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkMemoryRequirements *&#160;</td>
          <td class="paramname"><em>pVkMemoryRequirements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *&#160;</td>
          <td class="paramname"><em>pCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *&#160;</td>
          <td class="paramname"><em>pAllocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *&#160;</td>
          <td class="paramname"><em>pAllocationInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General purpose memory allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocation</td><td>Handle to allocated memory. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocationInfo</td><td>Optional. Information about allocated memory. It can be later fetched using function <a class="el" href="vk__mem__alloc_8h.html#a86dd08aba8633bfa4ad0df2e76481d8b" title="Returns current information about specified allocation and atomically marks it as used in current fra...">vmaGetAllocationInfo()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>You should free the memory using <a class="el" href="vk__mem__alloc_8h.html#a5fea5518972ae9094b1526cbcb19b05f" title="Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(),...">vmaFreeMemory()</a> or <a class="el" href="vk__mem__alloc_8h.html#a834b1e4aef395c0a1d56a28e69a4a17e" title="Frees memory and destroys multiple allocations.">vmaFreeMemoryPages()</a>.</p>
<p>It is recommended to use <a class="el" href="vk__mem__alloc_8h.html#a7fdf64415b6c3d83c454f28d2c53df7b">vmaAllocateMemoryForBuffer()</a>, <a class="el" href="vk__mem__alloc_8h.html#a0faa3f9e5fb233d29d1e00390650febb" title="Function similar to vmaAllocateMemoryForBuffer().">vmaAllocateMemoryForImage()</a>, <a class="el" href="vk__mem__alloc_8h.html#ac72ee55598617e8eecca384e746bab51">vmaCreateBuffer()</a>, <a class="el" href="vk__mem__alloc_8h.html#a02a94f25679275851a53e82eacbcfc73" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a> instead whenever possible. </p>

</div>
</div>
<a id="a7fdf64415b6c3d83c454f28d2c53df7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fdf64415b6c3d83c454f28d2c53df7b">&#9670;&nbsp;</a></span>vmaAllocateMemoryForBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaAllocateMemoryForBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *&#160;</td>
          <td class="paramname"><em>pCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *&#160;</td>
          <td class="paramname"><em>pAllocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *&#160;</td>
          <td class="paramname"><em>pAllocationInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocation</td><td>Handle to allocated memory. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocationInfo</td><td>Optional. Information about allocated memory. It can be later fetched using function <a class="el" href="vk__mem__alloc_8h.html#a86dd08aba8633bfa4ad0df2e76481d8b" title="Returns current information about specified allocation and atomically marks it as used in current fra...">vmaGetAllocationInfo()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>You should free the memory using <a class="el" href="vk__mem__alloc_8h.html#a5fea5518972ae9094b1526cbcb19b05f" title="Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(),...">vmaFreeMemory()</a>. </p>

</div>
</div>
<a id="a0faa3f9e5fb233d29d1e00390650febb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0faa3f9e5fb233d29d1e00390650febb">&#9670;&nbsp;</a></span>vmaAllocateMemoryForImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaAllocateMemoryForImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *&#160;</td>
          <td class="paramname"><em>pCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *&#160;</td>
          <td class="paramname"><em>pAllocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *&#160;</td>
          <td class="paramname"><em>pAllocationInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function similar to <a class="el" href="vk__mem__alloc_8h.html#a7fdf64415b6c3d83c454f28d2c53df7b">vmaAllocateMemoryForBuffer()</a>. </p>

</div>
</div>
<a id="ad37e82e492b3de38fc3f4cffd9ad0ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37e82e492b3de38fc3f4cffd9ad0ae1">&#9670;&nbsp;</a></span>vmaAllocateMemoryPages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaAllocateMemoryPages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkMemoryRequirements *&#160;</td>
          <td class="paramname"><em>pVkMemoryRequirements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *&#160;</td>
          <td class="paramname"><em>pCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>allocationCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *&#160;</td>
          <td class="paramname"><em>pAllocations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *&#160;</td>
          <td class="paramname"><em>pAllocationInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General purpose memory allocation for multiple allocation objects at once. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td>Allocator object. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pVkMemoryRequirements</td><td>Memory requirements for each allocation. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pCreateInfo</td><td>Creation parameters for each alloction. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocationCount</td><td>Number of allocations to make. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocations</td><td>Pointer to array that will be filled with handles to created allocations. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocationInfo</td><td>Optional. Pointer to array that will be filled with parameters of created allocations.</td></tr>
  </table>
  </dd>
</dl>
<p>You should free the memory using <a class="el" href="vk__mem__alloc_8h.html#a5fea5518972ae9094b1526cbcb19b05f" title="Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(),...">vmaFreeMemory()</a> or <a class="el" href="vk__mem__alloc_8h.html#a834b1e4aef395c0a1d56a28e69a4a17e" title="Frees memory and destroys multiple allocations.">vmaFreeMemoryPages()</a>.</p>
<p>Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding. It is just a general purpose allocation function able to make multiple allocations at once. It may be internally optimized to be more efficient than calling <a class="el" href="vk__mem__alloc_8h.html#abf28077dbf82d0908b8acbe8ee8dd9b8" title="General purpose memory allocation.">vmaAllocateMemory()</a> <code>allocationCount</code> times.</p>
<p>All allocations are made using same parameters. All of them are created out of the same memory pool and type. If any allocation fails, all allocations already made within this function call are also freed, so that when returned result is not <code>VK_SUCCESS</code>, <code>pAllocation</code> array is always entirely filled with <code>VK_NULL_HANDLE</code>. </p>

</div>
</div>
<a id="ac0f01545b6262f7d4d128fc8f8e5c77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f01545b6262f7d4d128fc8f8e5c77b">&#9670;&nbsp;</a></span>vmaBeginDefragmentationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaBeginDefragmentationPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_defragmentation_pass_info.html">VmaDefragmentationPassInfo</a> *&#160;</td>
          <td class="paramname"><em>pInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b0929b914b60cf2d45cac4bf3547470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0929b914b60cf2d45cac4bf3547470">&#9670;&nbsp;</a></span>vmaBindBufferMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaBindBufferMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a>&#160;</td>
          <td class="paramname"><em>allocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds buffer to allocation. </p>
<p>Binds specified buffer to region of memory represented by specified allocation. Gets <code>VkDeviceMemory</code> handle and offset from the allocation. If you want to create a buffer, allocate memory for it and bind them together separately, you should use this function for binding instead of standard <code>vkBindBufferMemory()</code>, because it ensures proper synchronization so that when a <code>VkDeviceMemory</code> object is used by multiple allocations, calls to <code>vkBind*Memory()</code> or <code>vkMapMemory()</code> won't happen from multiple threads simultaneously (which is illegal in Vulkan).</p>
<p>It is recommended to use function <a class="el" href="vk__mem__alloc_8h.html#ac72ee55598617e8eecca384e746bab51">vmaCreateBuffer()</a> instead of this one. </p>

</div>
</div>
<a id="a927c944f45e0f2941182abb6f608e64a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a927c944f45e0f2941182abb6f608e64a">&#9670;&nbsp;</a></span>vmaBindBufferMemory2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaBindBufferMemory2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a>&#160;</td>
          <td class="paramname"><em>allocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>allocationLocalOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pNext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds buffer to allocation with additional parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocationLocalOffset</td><td>Additional offset to be added while binding, relative to the beginnig of the <code>allocation</code>. Normally it should be 0. </td></tr>
    <tr><td class="paramname">pNext</td><td>A chain of structures to be attached to <code>VkBindBufferMemoryInfoKHR</code> structure used internally. Normally it should be null.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is similar to <a class="el" href="vk__mem__alloc_8h.html#a6b0929b914b60cf2d45cac4bf3547470" title="Binds buffer to allocation.">vmaBindBufferMemory()</a>, but it provides additional parameters.</p>
<p>If <code>pNext</code> is not null, <a class="el" href="struct_vma_allocator.html" title="Represents main object of this library initialized.">VmaAllocator</a> object must have been created with <a class="el" href="vk__mem__alloc_8h.html#a4f87c9100d154a65a4ad495f7763cf7ca8fb75bf07cd184ab903596295e863dee">VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</a> flag or with <a class="el" href="struct_vma_allocator_create_info.html#ae0ffc55139b54520a6bb704b29ffc285" title="Optional. The highest version of Vulkan that the application is designed to use.">VmaAllocatorCreateInfo::vulkanApiVersion</a> <code>== VK_API_VERSION_1_1</code>. Otherwise the call fails. </p>

</div>
</div>
<a id="a3d3ca45799923aa5d138e9e5f9eb2da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3ca45799923aa5d138e9e5f9eb2da5">&#9670;&nbsp;</a></span>vmaBindImageMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaBindImageMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a>&#160;</td>
          <td class="paramname"><em>allocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds image to allocation. </p>
<p>Binds specified image to region of memory represented by specified allocation. Gets <code>VkDeviceMemory</code> handle and offset from the allocation. If you want to create an image, allocate memory for it and bind them together separately, you should use this function for binding instead of standard <code>vkBindImageMemory()</code>, because it ensures proper synchronization so that when a <code>VkDeviceMemory</code> object is used by multiple allocations, calls to <code>vkBind*Memory()</code> or <code>vkMapMemory()</code> won't happen from multiple threads simultaneously (which is illegal in Vulkan).</p>
<p>It is recommended to use function <a class="el" href="vk__mem__alloc_8h.html#a02a94f25679275851a53e82eacbcfc73" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a> instead of this one. </p>

</div>
</div>
<a id="aa8251ee81b0045a443e35b8e8aa021bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8251ee81b0045a443e35b8e8aa021bc">&#9670;&nbsp;</a></span>vmaBindImageMemory2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaBindImageMemory2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a>&#160;</td>
          <td class="paramname"><em>allocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>allocationLocalOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pNext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds image to allocation with additional parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocationLocalOffset</td><td>Additional offset to be added while binding, relative to the beginnig of the <code>allocation</code>. Normally it should be 0. </td></tr>
    <tr><td class="paramname">pNext</td><td>A chain of structures to be attached to <code>VkBindImageMemoryInfoKHR</code> structure used internally. Normally it should be null.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is similar to <a class="el" href="vk__mem__alloc_8h.html#a3d3ca45799923aa5d138e9e5f9eb2da5" title="Binds image to allocation.">vmaBindImageMemory()</a>, but it provides additional parameters.</p>
<p>If <code>pNext</code> is not null, <a class="el" href="struct_vma_allocator.html" title="Represents main object of this library initialized.">VmaAllocator</a> object must have been created with <a class="el" href="vk__mem__alloc_8h.html#a4f87c9100d154a65a4ad495f7763cf7ca8fb75bf07cd184ab903596295e863dee">VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</a> flag or with <a class="el" href="struct_vma_allocator_create_info.html#ae0ffc55139b54520a6bb704b29ffc285" title="Optional. The highest version of Vulkan that the application is designed to use.">VmaAllocatorCreateInfo::vulkanApiVersion</a> <code>== VK_API_VERSION_1_1</code>. Otherwise the call fails. </p>

</div>
</div>
<a id="aa4fee7eb5253377599ef4fd38c93c2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4fee7eb5253377599ef4fd38c93c2a0">&#9670;&nbsp;</a></span>vmaBuildStatsString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaBuildStatsString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppStatsString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBool32&#160;</td>
          <td class="paramname"><em>detailedMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds and returns statistics as string in JSON format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ppStatsString</td><td>Must be freed using <a class="el" href="vk__mem__alloc_8h.html#a3104eb30d8122c84dd8541063f145288">vmaFreeStatsString()</a> function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a333b61c1788cb23559177531e6a93ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333b61c1788cb23559177531e6a93ca3">&#9670;&nbsp;</a></span>vmaCalculateStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaCalculateStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_stats.html">VmaStats</a> *&#160;</td>
          <td class="paramname"><em>pStats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves statistics from current state of the Allocator. </p>
<p>This function is called "calculate" not "get" because it has to traverse all internal data structures, so it may be quite slow. For faster but more brief statistics suitable to be called every frame or every allocation, use <a class="el" href="vk__mem__alloc_8h.html#aec0ed24ebea2d0099eed5f801daaefba" title="Retrieves information about current memory budget for all memory heaps.">vmaGetBudget()</a>.</p>
<p>Note that when using allocator from multiple threads, returned information may immediately become outdated. </p>

</div>
</div>
<a id="a49329a7f030dafcf82f7b73334c22e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49329a7f030dafcf82f7b73334c22e98">&#9670;&nbsp;</a></span>vmaCheckCorruption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaCheckCorruption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>memoryTypeBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks magic number in margins around all allocations in given memory types (in both default and custom pools) in search for corruptions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memoryTypeBits</td><td>Bit mask, where each bit set means that a memory type with that index should be checked.</td></tr>
  </table>
  </dd>
</dl>
<p>Corruption detection is enabled only when <code>VMA_DEBUG_DETECT_CORRUPTION</code> macro is defined to nonzero, <code>VMA_DEBUG_MARGIN</code> is defined to nonzero and only for memory types that are <code>HOST_VISIBLE</code> and <code>HOST_COHERENT</code>. For more information, see <a class="el" href="debugging_memory_usage.html#debugging_memory_usage_corruption_detection">Corruption detection</a>.</p>
<p>Possible return values:</p>
<ul>
<li><code>VK_ERROR_FEATURE_NOT_PRESENT</code> - corruption detection is not enabled for any of specified memory types.</li>
<li><code>VK_SUCCESS</code> - corruption detection has been performed and succeeded.</li>
<li><code>VK_ERROR_VALIDATION_FAILED_EXT</code> - corruption detection has been performed and found memory corruptions around one of the allocations. <code>VMA_ASSERT</code> is also fired in that case.</li>
<li>Other value: Error returned by Vulkan, e.g. memory mapping failure. </li>
</ul>

</div>
</div>
<a id="ad535935619c7a549bf837e1bb0068f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad535935619c7a549bf837e1bb0068f89">&#9670;&nbsp;</a></span>vmaCheckPoolCorruption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaCheckPoolCorruption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_pool.html">VmaPool</a>&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks magic number in margins around all allocations in given memory pool in search for corruptions. </p>
<p>Corruption detection is enabled only when <code>VMA_DEBUG_DETECT_CORRUPTION</code> macro is defined to nonzero, <code>VMA_DEBUG_MARGIN</code> is defined to nonzero and the pool is created in memory type that is <code>HOST_VISIBLE</code> and <code>HOST_COHERENT</code>. For more information, see <a class="el" href="debugging_memory_usage.html#debugging_memory_usage_corruption_detection">Corruption detection</a>.</p>
<p>Possible return values:</p>
<ul>
<li><code>VK_ERROR_FEATURE_NOT_PRESENT</code> - corruption detection is not enabled for specified pool.</li>
<li><code>VK_SUCCESS</code> - corruption detection has been performed and succeeded.</li>
<li><code>VK_ERROR_VALIDATION_FAILED_EXT</code> - corruption detection has been performed and found memory corruptions around one of the allocations. <code>VMA_ASSERT</code> is also fired in that case.</li>
<li>Other value: Error returned by Vulkan, e.g. memory mapping failure. </li>
</ul>

</div>
</div>
<a id="a200692051ddb34240248234f5f4c17bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a200692051ddb34240248234f5f4c17bb">&#9670;&nbsp;</a></span>vmaCreateAllocator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaCreateAllocator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocator_create_info.html">VmaAllocatorCreateInfo</a> *&#160;</td>
          <td class="paramname"><em>pCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> *&#160;</td>
          <td class="paramname"><em>pAllocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates Allocator object. </p>

</div>
</div>
<a id="ac72ee55598617e8eecca384e746bab51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72ee55598617e8eecca384e746bab51">&#9670;&nbsp;</a></span>vmaCreateBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaCreateBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkBufferCreateInfo *&#160;</td>
          <td class="paramname"><em>pBufferCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *&#160;</td>
          <td class="paramname"><em>pAllocationCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *&#160;</td>
          <td class="paramname"><em>pAllocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *&#160;</td>
          <td class="paramname"><em>pAllocationInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pBuffer</td><td>Buffer that was created. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocation</td><td>Allocation that was created. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocationInfo</td><td>Optional. Information about allocated memory. It can be later fetched using function <a class="el" href="vk__mem__alloc_8h.html#a86dd08aba8633bfa4ad0df2e76481d8b" title="Returns current information about specified allocation and atomically marks it as used in current fra...">vmaGetAllocationInfo()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function automatically:</p>
<ol type="1">
<li>Creates buffer.</li>
<li>Allocates appropriate memory for it.</li>
<li>Binds the buffer with the memory.</li>
</ol>
<p>If any of these operations fail, buffer and allocation are not created, returned value is negative error code, *pBuffer and *pAllocation are null.</p>
<p>If the function succeeded, you must destroy both buffer and allocation when you no longer need them using either convenience function <a class="el" href="vk__mem__alloc_8h.html#a0d9f4e4ba5bf9aab1f1c746387753d77" title="Destroys Vulkan buffer and frees allocated memory.">vmaDestroyBuffer()</a> or separately, using <code>vkDestroyBuffer()</code> and <a class="el" href="vk__mem__alloc_8h.html#a5fea5518972ae9094b1526cbcb19b05f" title="Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(),...">vmaFreeMemory()</a>.</p>
<p>If VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used, VK_KHR_dedicated_allocation extension is used internally to query driver whether it requires or prefers the new buffer to have dedicated allocation. If yes, and if dedicated allocation is possible (<a class="el" href="struct_vma_allocation_create_info.html#a6272c0555cfd1fe28bff1afeb6190150" title="Pool that this allocation should be created in.">VmaAllocationCreateInfo::pool</a> is null and VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated allocation for this buffer, just like when using VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT. </p>

</div>
</div>
<a id="a02a94f25679275851a53e82eacbcfc73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a94f25679275851a53e82eacbcfc73">&#9670;&nbsp;</a></span>vmaCreateImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaCreateImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkImageCreateInfo *&#160;</td>
          <td class="paramname"><em>pImageCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *&#160;</td>
          <td class="paramname"><em>pAllocationCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage *&#160;</td>
          <td class="paramname"><em>pImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *&#160;</td>
          <td class="paramname"><em>pAllocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *&#160;</td>
          <td class="paramname"><em>pAllocationInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function similar to <a class="el" href="vk__mem__alloc_8h.html#ac72ee55598617e8eecca384e746bab51">vmaCreateBuffer()</a>. </p>

</div>
</div>
<a id="ae5c9657d9e94756269145b01c05d16f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c9657d9e94756269145b01c05d16f1">&#9670;&nbsp;</a></span>vmaCreateLostAllocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaCreateLostAllocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *&#160;</td>
          <td class="paramname"><em>pAllocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates new allocation that is in lost state from the beginning. </p>
<p>It can be useful if you need a dummy, non-null allocation.</p>
<p>You still need to destroy created object using <a class="el" href="vk__mem__alloc_8h.html#a5fea5518972ae9094b1526cbcb19b05f" title="Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(),...">vmaFreeMemory()</a>.</p>
<p>Returned allocation is not tied to any specific memory pool or memory type and not bound to any image or buffer. It has size = 0. It cannot be turned into a real, non-empty allocation. </p>

</div>
</div>
<a id="a5c8770ded7c59c8caac6de0c2cb00b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8770ded7c59c8caac6de0c2cb00b50">&#9670;&nbsp;</a></span>vmaCreatePool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaCreatePool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_pool_create_info.html">VmaPoolCreateInfo</a> *&#160;</td>
          <td class="paramname"><em>pCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_pool.html">VmaPool</a> *&#160;</td>
          <td class="paramname"><em>pPool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates Vulkan device memory and creates <a class="el" href="struct_vma_pool.html" title="Represents custom memory pool.">VmaPool</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td>Allocator object. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pCreateInfo</td><td>Parameters of pool to create. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pPool</td><td>Handle to created pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f0f8f56db5f7f57fe4454f465142dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0f8f56db5f7f57fe4454f465142dac">&#9670;&nbsp;</a></span>vmaDefragment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaDefragment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *&#160;</td>
          <td class="paramname"><em>pAllocations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>allocationCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBool32 *&#160;</td>
          <td class="paramname"><em>pAllocationsChanged</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_defragmentation_info.html">VmaDefragmentationInfo</a> *&#160;</td>
          <td class="paramname"><em>pDefragmentationInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_defragmentation_stats.html">VmaDefragmentationStats</a> *&#160;</td>
          <td class="paramname"><em>pDefragmentationStats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated. Compacts memory by moving allocations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pAllocations</td><td>Array of allocations that can be moved during this compation. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocationCount</td><td>Number of elements in pAllocations and pAllocationsChanged arrays. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocationsChanged</td><td>Array of boolean values that will indicate whether matching allocation in pAllocations array has been moved. This parameter is optional. Pass null if you don't need this information. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pDefragmentationInfo</td><td>Configuration parameters. Optional - pass null to use default values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDefragmentationStats</td><td>Statistics returned by the function. Optional - pass null if you don't need this information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>VK_SUCCESS</code> if completed, negative error code in case of error.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>This is a part of the old interface. It is recommended to use structure <a class="el" href="struct_vma_defragmentation_info2.html" title="Parameters for defragmentation.">VmaDefragmentationInfo2</a> and function <a class="el" href="vk__mem__alloc_8h.html#a36ba776fd7fd5cb1e9359fdc0d8e6e8a" title="Begins defragmentation process.">vmaDefragmentationBegin()</a> instead.</dd></dl>
<p>This function works by moving allocations to different places (different <code>VkDeviceMemory</code> objects and/or different offsets) in order to optimize memory usage. Only allocations that are in <code>pAllocations</code> array can be moved. All other allocations are considered nonmovable in this call. Basic rules:</p>
<ul>
<li>Only allocations made in memory types that have <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> and <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code> flags can be compacted. You may pass other allocations but it makes no sense - these will never be moved.</li>
<li>Custom pools created with <a class="el" href="vk__mem__alloc_8h.html#a9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726" title="Enables alternative, linear allocation algorithm in this pool.">VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</a> or <a class="el" href="vk__mem__alloc_8h.html#a9a7c45f9c863695d98c83fa5ac940fe7a97a0dc38e5161b780594d998d313d35e" title="Enables alternative, buddy allocation algorithm in this pool.">VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT</a> flag are not defragmented. Allocations passed to this function that come from such pools are ignored.</li>
<li>Allocations created with <a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" title="Set this flag if the allocation should have its own memory block.">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</a> or created as dedicated allocations for any other reason are also ignored.</li>
<li>Both allocations made with or without <a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" title="Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.">VMA_ALLOCATION_CREATE_MAPPED_BIT</a> flag can be compacted. If not persistently mapped, memory will be mapped temporarily inside this function if needed.</li>
<li>You must not pass same <a class="el" href="struct_vma_allocation.html" title="Represents single memory allocation.">VmaAllocation</a> object multiple times in <code>pAllocations</code> array.</li>
</ul>
<p>The function also frees empty <code>VkDeviceMemory</code> blocks.</p>
<p>Warning: This function may be time-consuming, so you shouldn't call it too often (like after every resource creation/destruction). You can call it on special occasions (like when reloading a game level or when you just destroyed a lot of objects). Calling it every frame may be OK, but you should measure that on your platform.</p>
<p>For more information, see <a class="el" href="defragmentation.html">Defragmentation</a> chapter. </p>

</div>
</div>
<a id="a36ba776fd7fd5cb1e9359fdc0d8e6e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ba776fd7fd5cb1e9359fdc0d8e6e8a">&#9670;&nbsp;</a></span>vmaDefragmentationBegin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaDefragmentationBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_defragmentation_info2.html">VmaDefragmentationInfo2</a> *&#160;</td>
          <td class="paramname"><em>pInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_defragmentation_stats.html">VmaDefragmentationStats</a> *&#160;</td>
          <td class="paramname"><em>pStats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begins defragmentation process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td>Allocator object. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pInfo</td><td>Structure filled with parameters of defragmentation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pStats</td><td>Optional. Statistics of defragmentation. You can pass null if you are not interested in this information. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pContext</td><td>Context object that must be passed to <a class="el" href="vk__mem__alloc_8h.html#a8774e20e91e245aae959ba63efa15dd2" title="Ends defragmentation process.">vmaDefragmentationEnd()</a> to finish defragmentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>VK_SUCCESS</code> and <code>*pContext == null</code> if defragmentation finished within this function call. <code>VK_NOT_READY</code> and <code>*pContext != null</code> if defragmentation has been started and you need to call <a class="el" href="vk__mem__alloc_8h.html#a8774e20e91e245aae959ba63efa15dd2" title="Ends defragmentation process.">vmaDefragmentationEnd()</a> to finish it. Negative value in case of error.</dd></dl>
<p>Use this function instead of old, deprecated <a class="el" href="vk__mem__alloc_8h.html#a9f0f8f56db5f7f57fe4454f465142dac" title="Deprecated. Compacts memory by moving allocations.">vmaDefragment()</a>.</p>
<p>Warning! Between the call to <a class="el" href="vk__mem__alloc_8h.html#a36ba776fd7fd5cb1e9359fdc0d8e6e8a" title="Begins defragmentation process.">vmaDefragmentationBegin()</a> and <a class="el" href="vk__mem__alloc_8h.html#a8774e20e91e245aae959ba63efa15dd2" title="Ends defragmentation process.">vmaDefragmentationEnd()</a>:</p>
<ul>
<li>You should not use any of allocations passed as <code>pInfo-&gt;pAllocations</code> or any allocations that belong to pools passed as <code>pInfo-&gt;pPools</code>, including calling <a class="el" href="vk__mem__alloc_8h.html#a86dd08aba8633bfa4ad0df2e76481d8b" title="Returns current information about specified allocation and atomically marks it as used in current fra...">vmaGetAllocationInfo()</a>, <a class="el" href="vk__mem__alloc_8h.html#a43d8ba9673c846f049089a5029d5c73a" title="Returns VK_TRUE if allocation is not lost and atomically marks it as used in current frame.">vmaTouchAllocation()</a>, or access their data.</li>
<li>Some mutexes protecting internal data structures may be locked, so trying to make or free any allocations, bind buffers or images, map memory, or launch another simultaneous defragmentation in between may cause stall (when done on another thread) or deadlock (when done on the same thread), unless you are 100% sure that defragmented allocations are in different pools.</li>
<li>Information returned via <code>pStats</code> and <code>pInfo-&gt;pAllocationsChanged</code> are undefined. They become valid after call to <a class="el" href="vk__mem__alloc_8h.html#a8774e20e91e245aae959ba63efa15dd2" title="Ends defragmentation process.">vmaDefragmentationEnd()</a>.</li>
<li>If <code>pInfo-&gt;commandBuffer</code> is not null, you must submit that command buffer and make sure it finished execution before calling <a class="el" href="vk__mem__alloc_8h.html#a8774e20e91e245aae959ba63efa15dd2" title="Ends defragmentation process.">vmaDefragmentationEnd()</a>.</li>
</ul>
<p>For more information and important limitations regarding defragmentation, see documentation chapter: <a class="el" href="defragmentation.html">Defragmentation</a>. </p>

</div>
</div>
<a id="a8774e20e91e245aae959ba63efa15dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8774e20e91e245aae959ba63efa15dd2">&#9670;&nbsp;</a></span>vmaDefragmentationEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaDefragmentationEnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ends defragmentation process. </p>
<p>Use this function to finish defragmentation started by <a class="el" href="vk__mem__alloc_8h.html#a36ba776fd7fd5cb1e9359fdc0d8e6e8a" title="Begins defragmentation process.">vmaDefragmentationBegin()</a>. It is safe to pass <code>context == null</code>. The function then does nothing. </p>

</div>
</div>
<a id="aa8d164061c88f22fb1fd3c8f3534bc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d164061c88f22fb1fd3c8f3534bc1d">&#9670;&nbsp;</a></span>vmaDestroyAllocator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaDestroyAllocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys allocator object. </p>

</div>
</div>
<a id="a0d9f4e4ba5bf9aab1f1c746387753d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9f4e4ba5bf9aab1f1c746387753d77">&#9670;&nbsp;</a></span>vmaDestroyBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaDestroyBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a>&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys Vulkan buffer and frees allocated memory. </p>
<p>This is just a convenience function equivalent to:</p>
<div class="fragment"><div class="line">vkDestroyBuffer(device, buffer, allocationCallbacks);</div>
<div class="line"><a class="code" href="vk__mem__alloc_8h.html#a5fea5518972ae9094b1526cbcb19b05f">vmaFreeMemory</a>(allocator, allocation);</div>
</div><!-- fragment --><p>It it safe to pass null as buffer and/or allocation. </p>

</div>
</div>
<a id="ae50d2cb3b4a3bfd4dd40987234e50e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50d2cb3b4a3bfd4dd40987234e50e7e">&#9670;&nbsp;</a></span>vmaDestroyImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaDestroyImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a>&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys Vulkan image and frees allocated memory. </p>
<p>This is just a convenience function equivalent to:</p>
<div class="fragment"><div class="line">vkDestroyImage(device, image, allocationCallbacks);</div>
<div class="line"><a class="code" href="vk__mem__alloc_8h.html#a5fea5518972ae9094b1526cbcb19b05f">vmaFreeMemory</a>(allocator, allocation);</div>
</div><!-- fragment --><p>It it safe to pass null as image and/or allocation. </p>

</div>
</div>
<a id="a5485779c8f1948238fc4e92232fa65e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5485779c8f1948238fc4e92232fa65e1">&#9670;&nbsp;</a></span>vmaDestroyPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaDestroyPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_pool.html">VmaPool</a>&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys <a class="el" href="struct_vma_pool.html" title="Represents custom memory pool.">VmaPool</a> object and frees Vulkan device memory. </p>

</div>
</div>
<a id="a1b9ffa538bed905af55c747cc48963bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9ffa538bed905af55c747cc48963bd">&#9670;&nbsp;</a></span>vmaEndDefragmentationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaEndDefragmentationPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aef15a94b58fbcb0fe706d5720e84a74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef15a94b58fbcb0fe706d5720e84a74a">&#9670;&nbsp;</a></span>vmaFindMemoryTypeIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaFindMemoryTypeIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>memoryTypeBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *&#160;</td>
          <td class="paramname"><em>pAllocationCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pMemoryTypeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helps to find memoryTypeIndex, given memoryTypeBits and <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a>. </p>
<p>This algorithm tries to find a memory type that:</p>
<ul>
<li>Is allowed by memoryTypeBits.</li>
<li>Contains all the flags from pAllocationCreateInfo-&gt;requiredFlags.</li>
<li>Matches intended usage.</li>
<li>Has as many flags from pAllocationCreateInfo-&gt;preferredFlags as possible.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Returns VK_ERROR_FEATURE_NOT_PRESENT if not found. Receiving such result from this function or any other allocating function probably means that your device doesn't support any memory type with requested features for the specific type of resource you want to use it for. Please check parameters of your resource, like image layout (OPTIMAL versus LINEAR) or mip level count. </dd></dl>

</div>
</div>
<a id="ae790ab9ffaf7667fb8f62523e6897888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae790ab9ffaf7667fb8f62523e6897888">&#9670;&nbsp;</a></span>vmaFindMemoryTypeIndexForBufferInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaFindMemoryTypeIndexForBufferInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkBufferCreateInfo *&#160;</td>
          <td class="paramname"><em>pBufferCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *&#160;</td>
          <td class="paramname"><em>pAllocationCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pMemoryTypeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helps to find memoryTypeIndex, given VkBufferCreateInfo and <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a>. </p>
<p>It can be useful e.g. to determine value to be used as <a class="el" href="struct_vma_pool_create_info.html#a596fa76b685d3f1f688f84a709a5b319" title="Vulkan memory type index to allocate this pool from.">VmaPoolCreateInfo::memoryTypeIndex</a>. It internally creates a temporary, dummy buffer that never has memory bound. It is just a convenience function, equivalent to calling:</p>
<ul>
<li><code>vkCreateBuffer</code></li>
<li><code>vkGetBufferMemoryRequirements</code></li>
<li><code>vmaFindMemoryTypeIndex</code></li>
<li><code>vkDestroyBuffer</code> </li>
</ul>

</div>
</div>
<a id="a088da83d8eaf3ce9056d9ea0b981d472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a088da83d8eaf3ce9056d9ea0b981d472">&#9670;&nbsp;</a></span>vmaFindMemoryTypeIndexForImageInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaFindMemoryTypeIndexForImageInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkImageCreateInfo *&#160;</td>
          <td class="paramname"><em>pImageCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *&#160;</td>
          <td class="paramname"><em>pAllocationCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pMemoryTypeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helps to find memoryTypeIndex, given VkImageCreateInfo and <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a>. </p>
<p>It can be useful e.g. to determine value to be used as <a class="el" href="struct_vma_pool_create_info.html#a596fa76b685d3f1f688f84a709a5b319" title="Vulkan memory type index to allocate this pool from.">VmaPoolCreateInfo::memoryTypeIndex</a>. It internally creates a temporary, dummy image that never has memory bound. It is just a convenience function, equivalent to calling:</p>
<ul>
<li><code>vkCreateImage</code></li>
<li><code>vkGetImageMemoryRequirements</code></li>
<li><code>vmaFindMemoryTypeIndex</code></li>
<li><code>vkDestroyImage</code> </li>
</ul>

</div>
</div>
<a id="a30c37c1eec6025f397be41644f48490f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c37c1eec6025f397be41644f48490f">&#9670;&nbsp;</a></span>vmaFlushAllocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaFlushAllocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a>&#160;</td>
          <td class="paramname"><em>allocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes memory of given allocation. </p>
<p>Calls <code>vkFlushMappedMemoryRanges()</code> for memory associated with given range of given allocation. It needs to be called after writing to a mapped memory for memory types that are not <code>HOST_COHERENT</code>. Unmap operation doesn't do that automatically.</p>
<ul>
<li><code>offset</code> must be relative to the beginning of allocation.</li>
<li><code>size</code> can be <code>VK_WHOLE_SIZE</code>. It means all memory from <code>offset</code> the the end of given allocation.</li>
<li><code>offset</code> and <code>size</code> don't have to be aligned. They are internally rounded down/up to multiply of <code>nonCoherentAtomSize</code>.</li>
<li>If <code>size</code> is 0, this call is ignored.</li>
<li>If memory type that the <code>allocation</code> belongs to is not <code>HOST_VISIBLE</code> or it is <code>HOST_COHERENT</code>, this call is ignored.</li>
</ul>
<p>Warning! <code>offset</code> and <code>size</code> are relative to the contents of given <code>allocation</code>. If you mean whole allocation, you can pass 0 and <code>VK_WHOLE_SIZE</code>, respectively. Do not pass allocation's offset as <code>offset</code>!!!</p>
<p>This function returns the <code>VkResult</code> from <code>vkFlushMappedMemoryRanges</code> if it is called, otherwise <code>VK_SUCCESS</code>. </p>

</div>
</div>
<a id="ac3dd00da721875ed99fa8a881922bdfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3dd00da721875ed99fa8a881922bdfc">&#9670;&nbsp;</a></span>vmaFlushAllocations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaFlushAllocations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>allocationCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *&#160;</td>
          <td class="paramname"><em>allocations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkDeviceSize *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkDeviceSize *&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes memory of given set of allocations. </p>
<p>Calls <code>vkFlushMappedMemoryRanges()</code> for memory associated with given ranges of given allocations. For more information, see documentation of <a class="el" href="vk__mem__alloc_8h.html#a30c37c1eec6025f397be41644f48490f" title="Flushes memory of given allocation.">vmaFlushAllocation()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td></td></tr>
    <tr><td class="paramname">allocationCount</td><td></td></tr>
    <tr><td class="paramname">allocations</td><td></td></tr>
    <tr><td class="paramname">offsets</td><td>If not null, it must point to an array of offsets of regions to flush, relative to the beginning of respective allocations. Null means all ofsets are zero. </td></tr>
    <tr><td class="paramname">sizes</td><td>If not null, it must point to an array of sizes of regions to flush in respective allocations. Null means <code>VK_WHOLE_SIZE</code> for all allocations.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the <code>VkResult</code> from <code>vkFlushMappedMemoryRanges</code> if it is called, otherwise <code>VK_SUCCESS</code>. </p>

</div>
</div>
<a id="a5fea5518972ae9094b1526cbcb19b05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fea5518972ae9094b1526cbcb19b05f">&#9670;&nbsp;</a></span>vmaFreeMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaFreeMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation.html">VmaAllocation</a>&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory previously allocated using <a class="el" href="vk__mem__alloc_8h.html#abf28077dbf82d0908b8acbe8ee8dd9b8" title="General purpose memory allocation.">vmaAllocateMemory()</a>, <a class="el" href="vk__mem__alloc_8h.html#a7fdf64415b6c3d83c454f28d2c53df7b">vmaAllocateMemoryForBuffer()</a>, or <a class="el" href="vk__mem__alloc_8h.html#a0faa3f9e5fb233d29d1e00390650febb" title="Function similar to vmaAllocateMemoryForBuffer().">vmaAllocateMemoryForImage()</a>. </p>
<p>Passing <code>VK_NULL_HANDLE</code> as <code>allocation</code> is valid. Such function call is just skipped. </p>

</div>
</div>
<a id="a834b1e4aef395c0a1d56a28e69a4a17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834b1e4aef395c0a1d56a28e69a4a17e">&#9670;&nbsp;</a></span>vmaFreeMemoryPages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaFreeMemoryPages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>allocationCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *&#160;</td>
          <td class="paramname"><em>pAllocations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory and destroys multiple allocations. </p>
<p>Word "pages" is just a suggestion to use this function to free pieces of memory used for sparse binding. It is just a general purpose function to free memory and destroy allocations made using e.g. <a class="el" href="vk__mem__alloc_8h.html#abf28077dbf82d0908b8acbe8ee8dd9b8" title="General purpose memory allocation.">vmaAllocateMemory()</a>, <a class="el" href="vk__mem__alloc_8h.html#ad37e82e492b3de38fc3f4cffd9ad0ae1" title="General purpose memory allocation for multiple allocation objects at once.">vmaAllocateMemoryPages()</a> and other functions. It may be internally optimized to be more efficient than calling <a class="el" href="vk__mem__alloc_8h.html#a5fea5518972ae9094b1526cbcb19b05f" title="Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(),...">vmaFreeMemory()</a> <code>allocationCount</code> times.</p>
<p>Allocations in <code>pAllocations</code> array can come from any memory pools and types. Passing <code>VK_NULL_HANDLE</code> as elements of <code>pAllocations</code> array is valid. Such entries are just skipped. </p>

</div>
</div>
<a id="a3104eb30d8122c84dd8541063f145288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3104eb30d8122c84dd8541063f145288">&#9670;&nbsp;</a></span>vmaFreeStatsString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaFreeStatsString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pStatsString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a86dd08aba8633bfa4ad0df2e76481d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86dd08aba8633bfa4ad0df2e76481d8b">&#9670;&nbsp;</a></span>vmaGetAllocationInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaGetAllocationInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a>&#160;</td>
          <td class="paramname"><em>allocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *&#160;</td>
          <td class="paramname"><em>pAllocationInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns current information about specified allocation and atomically marks it as used in current frame. </p>
<p>Current paramters of given allocation are returned in <code>pAllocationInfo</code>.</p>
<p>This function also atomically "touches" allocation - marks it as used in current frame, just like <a class="el" href="vk__mem__alloc_8h.html#a43d8ba9673c846f049089a5029d5c73a" title="Returns VK_TRUE if allocation is not lost and atomically marks it as used in current frame.">vmaTouchAllocation()</a>. If the allocation is in lost state, <code>pAllocationInfo-&gt;deviceMemory == VK_NULL_HANDLE</code>.</p>
<p>Although this function uses atomics and doesn't lock any mutex, so it should be quite efficient, you can avoid calling it too often.</p>
<ul>
<li>You can retrieve same <a class="el" href="struct_vma_allocation_info.html" title="Parameters of VmaAllocation objects, that can be retrieved using function vmaGetAllocationInfo().">VmaAllocationInfo</a> structure while creating your resource, from function <a class="el" href="vk__mem__alloc_8h.html#ac72ee55598617e8eecca384e746bab51">vmaCreateBuffer()</a>, <a class="el" href="vk__mem__alloc_8h.html#a02a94f25679275851a53e82eacbcfc73" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a>. You can remember it if you are sure parameters don't change (e.g. due to defragmentation or allocation becoming lost).</li>
<li>If you just want to check if allocation is not lost, <a class="el" href="vk__mem__alloc_8h.html#a43d8ba9673c846f049089a5029d5c73a" title="Returns VK_TRUE if allocation is not lost and atomically marks it as used in current frame.">vmaTouchAllocation()</a> will work faster. </li>
</ul>

</div>
</div>
<a id="afa02231a791b37255720d566a52683e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa02231a791b37255720d566a52683e7">&#9670;&nbsp;</a></span>vmaGetAllocatorInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaGetAllocatorInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator_info.html">VmaAllocatorInfo</a> *&#160;</td>
          <td class="paramname"><em>pAllocatorInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns information about existing <a class="el" href="struct_vma_allocator.html" title="Represents main object of this library initialized.">VmaAllocator</a> object - handle to Vulkan device etc. </p>
<p>It might be useful if you want to keep just the <a class="el" href="struct_vma_allocator.html" title="Represents main object of this library initialized.">VmaAllocator</a> handle and fetch other required handles to <code>VkPhysicalDevice</code>, <code>VkDevice</code> etc. every time using this function. </p>

</div>
</div>
<a id="aec0ed24ebea2d0099eed5f801daaefba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0ed24ebea2d0099eed5f801daaefba">&#9670;&nbsp;</a></span>vmaGetBudget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaGetBudget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_budget.html">VmaBudget</a> *&#160;</td>
          <td class="paramname"><em>pBudget</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves information about current memory budget for all memory heaps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pBudget</td><td>Must point to array with number of elements at least equal to number of memory heaps in physical device used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is called "get" not "calculate" because it is very fast, suitable to be called every frame or every allocation. For more detailed statistics use <a class="el" href="vk__mem__alloc_8h.html#a333b61c1788cb23559177531e6a93ca3" title="Retrieves statistics from current state of the Allocator.">vmaCalculateStats()</a>.</p>
<p>Note that when using allocator from multiple threads, returned information may immediately become outdated. </p>

</div>
</div>
<a id="ab88db292a17974f911182543fda52d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88db292a17974f911182543fda52d19">&#9670;&nbsp;</a></span>vmaGetMemoryProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaGetMemoryProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkPhysicalDeviceMemoryProperties **&#160;</td>
          <td class="paramname"><em>ppPhysicalDeviceMemoryProperties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>PhysicalDeviceMemoryProperties are fetched from physicalDevice by the allocator. You can access it here, without fetching it again on your own. </p>

</div>
</div>
<a id="a8701444752eb5de4464adb5a2b514bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8701444752eb5de4464adb5a2b514bca">&#9670;&nbsp;</a></span>vmaGetMemoryTypeProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaGetMemoryTypeProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>memoryTypeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkMemoryPropertyFlags *&#160;</td>
          <td class="paramname"><em>pFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given Memory Type Index, returns Property Flags of this memory type. </p>
<p>This is just a convenience function. Same information can be obtained using <a class="el" href="vk__mem__alloc_8h.html#ab88db292a17974f911182543fda52d19">vmaGetMemoryProperties()</a>. </p>

</div>
</div>
<a id="aecabf7b6e91ea87d0316fa0a9e014fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecabf7b6e91ea87d0316fa0a9e014fe0">&#9670;&nbsp;</a></span>vmaGetPhysicalDeviceProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaGetPhysicalDeviceProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkPhysicalDeviceProperties **&#160;</td>
          <td class="paramname"><em>ppPhysicalDeviceProperties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>PhysicalDeviceProperties are fetched from physicalDevice by the allocator. You can access it here, without fetching it again on your own. </p>

</div>
</div>
<a id="af09b4e4eafdbee812e8d73ddf960f030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09b4e4eafdbee812e8d73ddf960f030">&#9670;&nbsp;</a></span>vmaGetPoolName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaGetPoolName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_pool.html">VmaPool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>ppName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves name of a custom pool. </p>
<p>After the call <code>ppName</code> is either null or points to an internally-owned null-terminated string containing name of the pool that was previously set. The pointer becomes invalid when the pool is destroyed or its name is changed using <a class="el" href="vk__mem__alloc_8h.html#adbae3a0b4ab078024462fc85c37f3b58" title="Sets name of a custom pool.">vmaSetPoolName()</a>. </p>

</div>
</div>
<a id="ae8bf76997b234ef68aad922616df4153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8bf76997b234ef68aad922616df4153">&#9670;&nbsp;</a></span>vmaGetPoolStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaGetPoolStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_pool.html">VmaPool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_pool_stats.html">VmaPoolStats</a> *&#160;</td>
          <td class="paramname"><em>pPoolStats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves statistics of existing <a class="el" href="struct_vma_pool.html" title="Represents custom memory pool.">VmaPool</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td>Allocator object. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pool</td><td>Pool object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pPoolStats</td><td>Statistics of specified pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa8412919139ef413a4215ac6a290fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8412919139ef413a4215ac6a290fae">&#9670;&nbsp;</a></span>vmaInvalidateAllocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaInvalidateAllocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a>&#160;</td>
          <td class="paramname"><em>allocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidates memory of given allocation. </p>
<p>Calls <code>vkInvalidateMappedMemoryRanges()</code> for memory associated with given range of given allocation. It needs to be called before reading from a mapped memory for memory types that are not <code>HOST_COHERENT</code>. Map operation doesn't do that automatically.</p>
<ul>
<li><code>offset</code> must be relative to the beginning of allocation.</li>
<li><code>size</code> can be <code>VK_WHOLE_SIZE</code>. It means all memory from <code>offset</code> the the end of given allocation.</li>
<li><code>offset</code> and <code>size</code> don't have to be aligned. They are internally rounded down/up to multiply of <code>nonCoherentAtomSize</code>.</li>
<li>If <code>size</code> is 0, this call is ignored.</li>
<li>If memory type that the <code>allocation</code> belongs to is not <code>HOST_VISIBLE</code> or it is <code>HOST_COHERENT</code>, this call is ignored.</li>
</ul>
<p>Warning! <code>offset</code> and <code>size</code> are relative to the contents of given <code>allocation</code>. If you mean whole allocation, you can pass 0 and <code>VK_WHOLE_SIZE</code>, respectively. Do not pass allocation's offset as <code>offset</code>!!!</p>
<p>This function returns the <code>VkResult</code> from <code>vkInvalidateMappedMemoryRanges</code> if it is called, otherwise <code>VK_SUCCESS</code>. </p>

</div>
</div>
<a id="ab25b558d75f7378ec944a1522fdcc3c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab25b558d75f7378ec944a1522fdcc3c5">&#9670;&nbsp;</a></span>vmaInvalidateAllocations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaInvalidateAllocations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>allocationCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *&#160;</td>
          <td class="paramname"><em>allocations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkDeviceSize *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkDeviceSize *&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidates memory of given set of allocations. </p>
<p>Calls <code>vkInvalidateMappedMemoryRanges()</code> for memory associated with given ranges of given allocations. For more information, see documentation of <a class="el" href="vk__mem__alloc_8h.html#aaa8412919139ef413a4215ac6a290fae" title="Invalidates memory of given allocation.">vmaInvalidateAllocation()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td></td></tr>
    <tr><td class="paramname">allocationCount</td><td></td></tr>
    <tr><td class="paramname">allocations</td><td></td></tr>
    <tr><td class="paramname">offsets</td><td>If not null, it must point to an array of offsets of regions to flush, relative to the beginning of respective allocations. Null means all ofsets are zero. </td></tr>
    <tr><td class="paramname">sizes</td><td>If not null, it must point to an array of sizes of regions to flush in respective allocations. Null means <code>VK_WHOLE_SIZE</code> for all allocations.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the <code>VkResult</code> from <code>vkInvalidateMappedMemoryRanges</code> if it is called, otherwise <code>VK_SUCCESS</code>. </p>

</div>
</div>
<a id="a736bd6cbda886f36c891727e73bd4024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736bd6cbda886f36c891727e73bd4024">&#9670;&nbsp;</a></span>vmaMakePoolAllocationsLost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaMakePoolAllocationsLost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_pool.html">VmaPool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pLostAllocationCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks all allocations in given pool as lost if they are not used in current frame or <a class="el" href="struct_vma_pool_create_info.html#a9437e43ffbb644dbbf7fc4e50cfad6aa" title="Maximum number of additional frames that are in use at the same time as current frame.">VmaPoolCreateInfo::frameInUseCount</a> back from now. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td>Allocator object. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pool</td><td>Pool. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pLostAllocationCount</td><td>Number of allocations marked as lost. Optional - pass null if you don't need this information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5bd1243512d099706de88168992f069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5bd1243512d099706de88168992f069">&#9670;&nbsp;</a></span>vmaMapMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaMapMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a>&#160;</td>
          <td class="paramname"><em>allocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>ppData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps memory represented by given allocation and returns pointer to it. </p>
<p>Maps memory represented by given allocation to make it accessible to CPU code. When succeeded, <code>*ppData</code> contains pointer to first byte of this memory. If the allocation is part of bigger <code>VkDeviceMemory</code> block, the pointer is correctly offseted to the beginning of region assigned to this particular allocation.</p>
<p>Mapping is internally reference-counted and synchronized, so despite raw Vulkan function <code>vkMapMemory()</code> cannot be used to map same block of <code>VkDeviceMemory</code> multiple times simultaneously, it is safe to call this function on allocations assigned to the same memory block. Actual Vulkan memory will be mapped on first mapping and unmapped on last unmapping.</p>
<p>If the function succeeded, you must call <a class="el" href="vk__mem__alloc_8h.html#a9bc268595cb33f6ec4d519cfce81ff45" title="Unmaps memory represented by given allocation, mapped previously using vmaMapMemory().">vmaUnmapMemory()</a> to unmap the allocation when mapping is no longer needed or before freeing the allocation, at the latest.</p>
<p>It also safe to call this function multiple times on the same allocation. You must call <a class="el" href="vk__mem__alloc_8h.html#a9bc268595cb33f6ec4d519cfce81ff45" title="Unmaps memory represented by given allocation, mapped previously using vmaMapMemory().">vmaUnmapMemory()</a> same number of times as you called <a class="el" href="vk__mem__alloc_8h.html#ad5bd1243512d099706de88168992f069" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a>.</p>
<p>It is also safe to call this function on allocation created with <a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" title="Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.">VMA_ALLOCATION_CREATE_MAPPED_BIT</a> flag. Its memory stays mapped all the time. You must still call <a class="el" href="vk__mem__alloc_8h.html#a9bc268595cb33f6ec4d519cfce81ff45" title="Unmaps memory represented by given allocation, mapped previously using vmaMapMemory().">vmaUnmapMemory()</a> same number of times as you called <a class="el" href="vk__mem__alloc_8h.html#ad5bd1243512d099706de88168992f069" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a>. You must not call <a class="el" href="vk__mem__alloc_8h.html#a9bc268595cb33f6ec4d519cfce81ff45" title="Unmaps memory represented by given allocation, mapped previously using vmaMapMemory().">vmaUnmapMemory()</a> additional time to free the "0-th" mapping made automatically due to <a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" title="Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.">VMA_ALLOCATION_CREATE_MAPPED_BIT</a> flag.</p>
<p>This function fails when used on allocation made in memory type that is not <code>HOST_VISIBLE</code>.</p>
<p>This function always fails when called for allocation that was created with <a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a5f436af6c8fe8540573a6d22627a6fd2">VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT</a> flag. Such allocations cannot be mapped.</p>
<p>This function doesn't automatically flush or invalidate caches. If the allocation is made from a memory types that is not <code>HOST_COHERENT</code>, you also need to use <a class="el" href="vk__mem__alloc_8h.html#aaa8412919139ef413a4215ac6a290fae" title="Invalidates memory of given allocation.">vmaInvalidateAllocation()</a> / <a class="el" href="vk__mem__alloc_8h.html#a30c37c1eec6025f397be41644f48490f" title="Flushes memory of given allocation.">vmaFlushAllocation()</a>, as required by Vulkan specification. </p>

</div>
</div>
<a id="a0ff488958ca72b28e545880463cb8696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff488958ca72b28e545880463cb8696">&#9670;&nbsp;</a></span>vmaResizeAllocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaResizeAllocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a>&#160;</td>
          <td class="paramname"><em>allocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>newSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>In version 2.2.0 it used to try to change allocation's size without moving or reallocating it. In current version it returns <code>VK_SUCCESS</code> only if <code>newSize</code> equals current allocation's size. Otherwise returns <code>VK_ERROR_OUT_OF_POOL_MEMORY</code>, indicating that allocation's size could not be changed. </dd></dl>

</div>
</div>
<a id="af9147d31ffc11d62fc187bde283ed14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9147d31ffc11d62fc187bde283ed14f">&#9670;&nbsp;</a></span>vmaSetAllocationUserData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaSetAllocationUserData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a>&#160;</td>
          <td class="paramname"><em>allocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets pUserData in given allocation to new value. </p>
<p>If the allocation was created with VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT, pUserData must be either null, or pointer to a null-terminated string. The function makes local copy of the string and sets it as allocation's <code>pUserData</code>. String passed as pUserData doesn't need to be valid for whole lifetime of the allocation - you can free it after this call. String previously pointed by allocation's pUserData is freed from memory.</p>
<p>If the flag was not used, the value of pointer <code>pUserData</code> is just copied to allocation's <code>pUserData</code>. It is opaque, so you can use it however you want - e.g. as a pointer, ordinal number or some handle to you own data. </p>

</div>
</div>
<a id="ade56bf8dc9f5a5eaddf5f119ed525236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade56bf8dc9f5a5eaddf5f119ed525236">&#9670;&nbsp;</a></span>vmaSetCurrentFrameIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaSetCurrentFrameIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frameIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets index of the current frame. </p>
<p>This function must be used if you make allocations with <a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a5f436af6c8fe8540573a6d22627a6fd2">VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT</a> and <a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a68686d0ce9beb0d4d1b9f2b8b1389a7e">VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT</a> flags to inform the allocator when a new frame begins. Allocations queried using <a class="el" href="vk__mem__alloc_8h.html#a86dd08aba8633bfa4ad0df2e76481d8b" title="Returns current information about specified allocation and atomically marks it as used in current fra...">vmaGetAllocationInfo()</a> cannot become lost in the current frame. </p>

</div>
</div>
<a id="adbae3a0b4ab078024462fc85c37f3b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbae3a0b4ab078024462fc85c37f3b58">&#9670;&nbsp;</a></span>vmaSetPoolName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaSetPoolName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_pool.html">VmaPool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets name of a custom pool. </p>
<p><code>pName</code> can be either null or pointer to a null-terminated string with new name for the pool. Function makes internal copy of the string, so it can be changed or freed immediately after this call. </p>

</div>
</div>
<a id="a43d8ba9673c846f049089a5029d5c73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d8ba9673c846f049089a5029d5c73a">&#9670;&nbsp;</a></span>vmaTouchAllocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkBool32 vmaTouchAllocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a>&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>VK_TRUE</code> if allocation is not lost and atomically marks it as used in current frame. </p>
<p>If the allocation has been created with <a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a5f436af6c8fe8540573a6d22627a6fd2">VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT</a> flag, this function returns <code>VK_TRUE</code> if it's not in lost state, so it can still be used. It then also atomically "touches" the allocation - marks it as used in current frame, so that you can be sure it won't become lost in current frame or next <code>frameInUseCount</code> frames.</p>
<p>If the allocation is in lost state, the function returns <code>VK_FALSE</code>. Memory of such allocation, as well as buffer or image bound to it, should not be used. Lost allocation and the buffer/image still need to be destroyed.</p>
<p>If the allocation has been created without <a class="el" href="vk__mem__alloc_8h.html#ad9889c10c798b040d59c92f257cae597a5f436af6c8fe8540573a6d22627a6fd2">VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT</a> flag, this function always returns <code>VK_TRUE</code>. </p>

</div>
</div>
<a id="a9bc268595cb33f6ec4d519cfce81ff45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc268595cb33f6ec4d519cfce81ff45">&#9670;&nbsp;</a></span>vmaUnmapMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaUnmapMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a>&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmaps memory represented by given allocation, mapped previously using <a class="el" href="vk__mem__alloc_8h.html#ad5bd1243512d099706de88168992f069" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a>. </p>
<p>For details, see description of <a class="el" href="vk__mem__alloc_8h.html#ad5bd1243512d099706de88168992f069" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a>.</p>
<p>This function doesn't automatically flush or invalidate caches. If the allocation is made from a memory types that is not <code>HOST_COHERENT</code>, you also need to use <a class="el" href="vk__mem__alloc_8h.html#aaa8412919139ef413a4215ac6a290fae" title="Invalidates memory of given allocation.">vmaInvalidateAllocation()</a> / <a class="el" href="vk__mem__alloc_8h.html#a30c37c1eec6025f397be41644f48490f" title="Flushes memory of given allocation.">vmaFlushAllocation()</a>, as required by Vulkan specification. </p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="avk__mem__alloc_8h_html_a5fea5518972ae9094b1526cbcb19b05f"><div class="ttname"><a href="vk__mem__alloc_8h.html#a5fea5518972ae9094b1526cbcb19b05f">vmaFreeMemory</a></div><div class="ttdeci">void vmaFreeMemory(VmaAllocator allocator, const VmaAllocation allocation)</div><div class="ttdoc">Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(),...</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
