{	"access-new-vector-inside-if-condition.amber",	"access-new-vector-inside-if-condition","A shader that accesses a new vector within an if condition"							},
{	"always-discarding-function.amber",				"always-discarding-function",			"A fragment shader with an always discarding main function"								},
{	"always-false-if-in-do-while.amber",			"always-false-if-in-do-while",			"A fragment shader with an always false if."											},
{	"always-false-if-with-discard-return.amber",	"always-false-if-with-discard-return",	"A fragment shader with discard keyword and a return"									},
{	"arr-value-set-to-arr-value-squared.amber",													"arr-value-set-to-arr-value-squared",												"A fragment shader with an arr value set to itself squared"							},
{	"array-idx-multiplied-by-for-loop-idx.amber",												"array-idx-multiplied-by-for-loop-idx",												"A fragment shader with array index multiplied"										},
{	"assign-array-value-to-another-array.amber",												"assign-array-value-to-another-array",												"A fragment shader that assigns array values to other array"						},
{	"assign-array-value-to-another-array-2.amber",												"assign-array-value-to-another-array-2",											"A fragment shader that assigns array values to other array"						},
{	"barrier-in-loop-with-break.amber",				"barrier-in-loop-with-break",			"A compute shader with a barrier in a loop with a break"								},
{	"break-in-do-while-with-nested-if.amber",		"break-in-do-while-with-nested-if",		"A fragment shader with nested if"														},
{	"call-function-with-discard.amber",				"call-function-with-discard",			"Calls a function containing a discard"													},
{	"call-if-while-switch.amber",					"call-if-while-switch",					"A fragment shader with a call, if, while, switch"										},
{	"color-set-in-for-loop.amber",					"color-set-in-for-loop",				"A fragment shader with color set in for loop"											},
{	"color-write-in-loop.amber",					"color-write-in-loop",					"A fragment shader that writes to color in a loop"										},
{	"complex-nested-loops-and-call.amber",			"complex-nested-loops-and-call",		"A fragment shader with complex nested loops, breaks, etc."								},
{	"conditional-return-in-infinite-while.amber",	"conditional-return-in-infinite-while",	"A shader with conditional return inside an infinite loop"								},
{	"continue-and-merge.amber",						"continue-and-merge",					"A fragment shader with two nested loops"												},
{	"control-flow-in-function.amber",				"control-flow-in-function",				"A fragment shader with a lot of control flow"											},
{	"control-flow-switch.amber",					"control-flow-switch",					"A fragment shader with somewhat complex control flow and a switch"						},
{	"cosh-return-inf-unused.amber",																"cosh-return-inf-unused",															"Cosh returns inf for one component which is never used"							},
{	"cov-analysis-reachable-from-many.amber",		"cov-analysis-reachable-from-many",		"A fragment shader that covers a specific LLVM analysis code path."						},
{	"cov-apfloat-acos-ldexp.amber",					"cov-apfloat-acos-ldexp",				"A fragment shader that covers a specific AP float code path."							},
{	"cov-apfloat-determinant.amber",				"cov-apfloat-determinant",				"A fragment shader that covers a specific arbitrary precision float usage."				},
{	"cov-apfloat-tanh.amber",						"cov-apfloat-tanh",						"A fragment shader that covers a specific arbitrary precision float usage."				},
{	"cov-basic-block-discard-in-function.amber",	"cov-basic-block-discard-in-function",	"A fragment shader that covers a specific basic block code path"						},
{	"cov-blockfrequency-several-for-loops.amber",	"cov-blockfrequency-several-for-loops",	"A fragment shader that covers a specific block frequency info code path."				},
{	"cov-const-folding-clamp.amber",				"cov-const-folding-clamp",				"A fragment shader that covers a specific const folding rule path."						},
{	"cov-const-folding-clamp-inside-while.amber",	"cov-const-folding-clamp-inside-while",	"A fragment shader that covers a specific constant folding path"						},
{	"cov-const-folding-clamp-max.amber",			"cov-const-folding-clamp-max",			"A fragment shader that covers a specific const folding rule path."						},
{	"cov-const-folding-clamp-min.amber",			"cov-const-folding-clamp-min",			"A fragment shader that covers a specific const folding rule path."						},
{	"cov-const-folding-clamp-vs-original.amber",	"cov-const-folding-clamp-vs-original",	"A fragment shader that covers a specific constant folding path"						},
{	"cov-const-folding-dot-condition-true.amber",	"cov-const-folding-dot-condition-true",	"A fragment shader that covers a specific const folding rule path."						},
{	"cov-const-folding-dot-determinant.amber",		"cov-const-folding-dot-determinant",	"A fragment shader that covers a specific const folding rule path."						},
{	"cov-const-folding-gte-const-first.amber",		"cov-const-folding-gte-const-first",	"A fragment shader that covers a specific constant folding path"						},
{	"cov-const-folding-min-as-loop-range.amber",	"cov-const-folding-min-as-loop-range",	"A fragment shader that covers a specific constant folding path"						},
{	"cov-const-folding-vector-shuffle.amber",		"cov-const-folding-vector-shuffle",		"A fragment shader that covers a specific const folding rule path."						},
{	"cov-constant-folding-atan-over-tanh.amber",	"cov-constant-folding-atan-over-tanh",	"A fragment shader that covers a specific constant folding code path."					},
{	"cov-constants-mix-uniform.amber",				"cov-constants-mix-uniform",			"A fragment shader that covers a specific constant handling path."						},
{	"cov-copy-prop-arrays-func-argument.amber",		"cov-copy-prop-arrays-func-argument",	"A fragment shader that covers a specific propagate array copy path."					},
{	"cov-copy-prop-arrays-no-stores.amber",			"cov-copy-prop-arrays-no-stores",		"A fragment shader that covers a specific propagate array copy path."					},
{	"cov-copy-prop-arrays-param-uniform.amber",		"cov-copy-prop-arrays-param-uniform",	"A fragment shader that covers a specific propagate array copy path."					},
{	"cov-dead-branch-func-return-arg.amber",		"cov-dead-branch-func-return-arg",		"A fragment shader that covers a specific dead branch elimination path"					},
{	"cov-dead-code-unreachable-merge.amber",		"cov-dead-code-unreachable-merge",		"A fragment shader that covers a specific dead code elimination path."					},
{	"cov-fold-and-in-for-loop-range.amber",			"cov-fold-and-in-for-loop-range",		"A fragment shader that covers a specific folding path"									},
{	"cov-fold-bitwise-and-zero.amber",				"cov-fold-bitwise-and-zero",			"A fragment shader that covers a specific instruction folding path."					},
{	"cov-fold-bitwise-or-full-mask.amber",			"cov-fold-bitwise-or-full-mask",		"A fragment shader that covers a specific instruction folding path."					},
{	"cov-fold-bitwise-xor.amber",					"cov-fold-bitwise-xor",					"A fragment shader that covers a specific instruction folding path."					},
{	"cov-fold-div-uniform-by-zero.amber",			"cov-fold-div-uniform-by-zero",			"A fragment shader that covers a specific instruction folding path."					},
{	"cov-fold-div-variable-by-zero.amber",			"cov-fold-div-variable-by-zero",		"A fragment shader that covers a specific instruction folding path."					},
{	"cov-fold-logical-and-const-variable.amber",	"cov-fold-logical-and-const-variable",	"A fragment shader that covers a specific instruction folding path."					},
{	"cov-fold-logical-and-constant.amber",			"cov-fold-logical-and-constant",		"A fragment shader that covers a specific instruction folding path."					},
{	"cov-fold-logical-or-constant.amber",			"cov-fold-logical-or-constant",			"A fragment shader that covers a specific instruction folding path."					},
{	"cov-fold-negate-min-int-value.amber",			"cov-fold-negate-min-int-value",		"A fragment shader that covers a specific instruction folding path."					},
{	"cov-fold-negate-variable.amber",				"cov-fold-negate-variable",				"A fragment shader that covers a specific instruction folding path."					},
{	"cov-fold-shift-gte32.amber",					"cov-fold-shift-gte32",					"A fragment shader that covers a specific instruction folding path."					},
{	"cov-fold-shift-right-arithmetic.amber",		"cov-fold-shift-right-arithmetic",		"A fragment shader that covers a specific instruction folding path."					},
{	"cov-fold-switch-udiv.amber",					"cov-fold-switch-udiv",					"A fragment shader that covers a specific instruction folding path."					},
{	"cov-folding-clamp-cmp-const-first.amber",		"cov-folding-clamp-cmp-const-first",	"A fragment shader that covers a specific constant folding path"						},
{	"cov-folding-merge-add-sub-uniform.amber",		"cov-folding-merge-add-sub-uniform",	"A fragment shader that covers a specific instruction folding path."					},
{	"cov-folding-rules-construct-extract.amber",	"cov-folding-rules-construct-extract",	"A fragment shader that covers a specific instruction folding path."					},
{	"cov-folding-rules-dot-extract.amber",			"cov-folding-rules-dot-extract",		"A fragment shader that covers a specific instruction folding path."					},
{	"cov-folding-rules-dot-no-extract.amber",		"cov-folding-rules-dot-no-extract",		"A fragment shader that covers a specific instruction folding path."					},
{	"cov-folding-rules-merge-add-sub.amber",		"cov-folding-rules-merge-add-sub",		"A fragment shader that covers a specific instruction folding path."					},
{	"cov-folding-rules-merge-div-mul.amber",		"cov-folding-rules-merge-div-mul",		"A fragment shader that covers a specific instruction folding path."					},
{	"cov-folding-rules-merge-divs.amber",			"cov-folding-rules-merge-divs",			"A fragment shader that covers a specific instruction folding path."					},
{	"cov-folding-rules-merge-mul-div.amber",		"cov-folding-rules-merge-mul-div",		"A fragment shader that covers a specific instruction folding path."					},
{	"cov-folding-rules-merge-sub-add.amber",		"cov-folding-rules-merge-sub-add",		"A fragment shader that covers a specific instruction folding path."					},
{	"cov-folding-rules-merge-sub-sub.amber",		"cov-folding-rules-merge-sub-sub",		"A fragment shader that covers a specific instruction folding path."					},
{	"cov-folding-rules-merge-var-sub.amber",		"cov-folding-rules-merge-var-sub",		"A fragment shader that covers a specific instruction folding path."					},
{	"cov-folding-rules-mix-uniform-weight.amber",	"cov-folding-rules-mix-uniform-weight",	"A fragment shader that covers a specific instruction folding path."					},
{	"cov-folding-rules-negate-div.amber",			"cov-folding-rules-negate-div",			"A fragment shader that covers a specific instruction folding path."					},
{	"cov-folding-rules-negate-sub.amber",			"cov-folding-rules-negate-sub",			"A fragment shader that covers a specific instruction folding path."					},
{	"cov-folding-rules-redundant-mix.amber",		"cov-folding-rules-redundant-mix",		"A fragment shader that covers a specific instruction folding path."					},
{	"cov-folding-rules-shuffle-extract.amber",		"cov-folding-rules-shuffle-extract",	"A fragment shader that covers a specific instruction folding path."					},
{	"cov-folding-rules-shuffle-mix.amber",			"cov-folding-rules-shuffle-mix",		"A fragment shader that covers a specific instruction folding path."					},
{	"cov-folding-rules-split-vector-init.amber",	"cov-folding-rules-split-vector-init",	"A fragment shader that covers a specific instruction folding path."					},
{	"cov-folding-rules-vec-mix-uniform.amber",		"cov-folding-rules-vec-mix-uniform",	"A fragment shader that covers a specific instruction folding path."					},
{	"cov-if-conversion-identical-branches.amber",	"cov-if-conversion-identical-branches",	"A fragment shader that covers a specific if condition conversion path."				},
{	"cov-inc-inside-switch-and-for.amber",			"cov-inc-inside-switch-and-for",		"A fragment shader that covers a specific LLVM analysis code path."						},
{	"cov-inline-pass-empty-block.amber",			"cov-inline-pass-empty-block",			"A fragment shader that covers a specific inlining optimization path."					},
{	"cov-inline-pass-nested-loops.amber",			"cov-inline-pass-nested-loops",			"A fragment shader that covers a specific inlining optimization path."					},
{	"cov-inline-pass-return-in-loop.amber",			"cov-inline-pass-return-in-loop",		"A fragment shader that covers a specific inlining optimization path."					},
{	"cov-inline-pass-unreachable-func.amber",		"cov-inline-pass-unreachable-func",		"A fragment shader that covers a specific inlining optimization path."					},
{	"cov-intervalmap-set-stop.amber",				"cov-intervalmap-set-stop",				"A fragment shader that covers a specific interval map code path."						},
{	"cov-irbuilder-matrix-cell-uniform.amber",		"cov-irbuilder-matrix-cell-uniform",	"A fragment shader that covers a specific IR builder path."								},
{	"cov-liveinterval-different-dest.amber",		"cov-liveinterval-different-dest",		"A fragment shader that covers a specific live interval code path."						},
{	"cov-machinevaluetype-one-iter-loop.amber",		"cov-machinevaluetype-one-iter-loop",	"A fragment shader that covers a specific machine value type code path"					},
{	"cov-mem-pass-sum-struct-members.amber",		"cov-mem-pass-sum-struct-members",		"A fragment shader that covers a specific mem pass code path."							},
{	"cov-mem-pass-unused-component.amber",			"cov-mem-pass-unused-component",		"A fragment shader that covers a specific mem pass code path."							},
{	"cov-merge-return-condition-twice.amber",		"cov-merge-return-condition-twice",		"A fragment shader that covers a specific return merge path."							},
{	"cov-modf-integer-to-private.amber",			"cov-modf-integer-to-private",			"A fragment shader that covers a specific private to local path."						},
{	"cov-pattern-match-signum.amber",				"cov-pattern-match-signum",				"A fragment shader that covers a specific pattern matching path."						},
{	"cov-pattern-match-single-bit.amber",			"cov-pattern-match-single-bit",			"A fragment shader that covers a specific pattern matching path."						},
{	"cov-reduce-load-replace-extract.amber",		"cov-reduce-load-replace-extract",		"A fragment shader that covers a specific load size reduction path."					},
{	"cov-replace-copy-object.amber",				"cov-replace-copy-object",				"A fragment shader that covers a specific shader simplification path."					},
{	"cov-scaled-number-nested-loops.amber",			"cov-scaled-number-nested-loops",		"A fragment shader that covers a specific scaled number code path."						},
{	"cov-set-vector-cos-fragcoord.amber",			"cov-set-vector-cos-fragcoord",			"A fragment shader that covers a specific set vector code path."						},
{	"cov-simplification-unused-struct.amber",		"cov-simplification-unused-struct",		"A fragment shader that covers a specific shader simplification path."					},
{	"cov-simplification-while-inside-for.amber",	"cov-simplification-while-inside-for",	"A fragment shader that covers a specific code simplification path."					},
{	"cov-single-block-elim-self-assign.amber",		"cov-single-block-elim-self-assign",	"A fragment shader that covers a specific single block elimination path."				},
{	"cov-single-store-elim-assume-store.amber",		"cov-single-store-elim-assume-store",	"A fragment shader that covers a specific single store elimination path."				},
{	"cov-ssa-rewrite-case-with-default.amber",		"cov-ssa-rewrite-case-with-default",	"A fragment shader that covers a specific SSA rewrite path."							},
{	"cov-target-lowering-dfdx-cos.amber",			"cov-target-lowering-dfdx-cos",			"A fragment shader that covers a specific target lowering code path."					},
{	"cov-types-return-in-main-never-hit.amber",		"cov-types-return-in-main-never-hit",	"A fragment shader that covers a specific types optimization path."						},
{	"cov-val-cfg-case-fallthrough.amber",			"cov-val-cfg-case-fallthrough",			"A fragment shader that covers a specific shader validation path."						},
{	"cov-vector-dce-inc-unused-comp.amber",			"cov-vector-dce-inc-unused-comp",		"A fragment shader that covers a specific vector DCE path."								},
{	"cov-vector-dce-unused-component.amber",		"cov-vector-dce-unused-component",		"A fragment shader that covers a specific vector DCE path."								},
{	"cov-vector-log2-cosh.amber",					"cov-vector-log2-cosh",					"A fragment shader that covers a specific vector log2 and cosh code path."				},
{	"cov-wrap-op-kill-for-loop.amber",				"cov-wrap-op-kill-for-loop",			"A fragment shader that covers a specific OpKill wrapping code path"					},
{	"cov-wrap-op-kill-two-branches.amber",			"cov-wrap-op-kill-two-branches",		"A fragment shader that covers a specific OpKill wrapping path."						},
{	"create-color-in-do-while-for-loop.amber",													"create-color-in-do-while-for-loop",												"A fragment shader that creates the color inside two loops"							},
{	"dead-barriers-in-loops.amber",					"dead-barriers-in-loops",				"A compute shader with dead barriers"													},
{	"dead-struct-init.amber",						"dead-struct-init",						"A fragment shader that uses struct initializers"										},
{	"disc-and-add-in-func-in-loop.amber",			"disc-and-add-in-func-in-loop",			"A fragment shader with discard and add in function in loop"							},
{	"discard-continue-return.amber",				"discard-continue-return",				"A fragment shader with a discard, continue, and return"								},
{	"discard-in-array-manipulating-loop.amber",		"discard-in-array-manipulating-loop",	"An array-manipulating fragment shader with a discard"									},
{	"discard-in-loop.amber",						"discard-in-loop",						"A shader with a discard in a loop"														},
{	"discard-in-loop-in-function.amber",			"discard-in-loop-in-function",			"A shader with a discard nested in a loop in a function"								},
{	"discards-in-control-flow.amber",				"discards-in-control-flow",				"A fragment shader with discards in loops and conditionals"								},
{	"do-while-false-loops.amber",					"do-while-false-loops",					"Code wrapped in nested single iteration loops"											},
{	"do-while-loop-in-conditionals.amber",			"do-while-loop-in-conditionals",		"A fragment shader with do-while loop in conditional nest"								},
{	"do-while-with-always-true-if.amber",			"do-while-with-always-true-if",			"A fragment shader with a do while that always returns"									},
{	"do-while-with-if-condition.amber",															"do-while-with-if-condition",														"A fragment shader that has nested if condition in do while"						},
{	"early-return-and-barrier.amber",				"early-return-and-barrier",				"A compute shader with an early return and a barrier"									},
{	"find-msb-from-lsb.amber",																	"find-msb-from-lsb",																"A fragment shader that finds MSB from LSB"											},
{	"for-condition-always-false.amber",				"for-condition-always-false",			"A fragment shader that uses a for loop with condition always false"					},
{	"for-loop-with-return.amber",					"for-loop-with-return",					"A fragment shader with a for loop that loops only once"								},
{	"for-with-ifs-and-return.amber",				"for-with-ifs-and-return",				"A fragment shader with two ifs and return/continue inside a for loop"					},
{	"frag-coord-func-call-and-ifs.amber",														"frag-coord-func-call-and-ifs",														"A fragment shader with many uses of gl_FragCoord"									},
{	"fragcoord-control-flow.amber",					"fragcoord-control-flow",				"A fragment shader that uses FragCoord and somewhat complex control flow"				},
{	"fragcoord-control-flow-2.amber",				"fragcoord-control-flow-2",				"A fragment shader that uses FragCoord and somewhat complex control flow"				},
{	"function-with-float-comparison.amber",														"function-with-float-comparison",													"A fragment shader that compares a float and a coordinate"							},
{	"function-with-uniform-return.amber",			"function-with-uniform-return",			"A fragment shader with uniform value as a return"										},
{	"global-array-loops.amber",						"global-array-loops",					"A loop that writes then reads a global array"											},
{	"if-and-switch.amber",							"if-and-switch",						"A fragment shader with a switch and some data flow"									},
{	"increment-value-in-nested-for-loop.amber",													"increment-value-in-nested-for-loop",												"A frag. shader that increments a value in nested for loop"							},
{	"injection-switch-as-comparison.amber",			"injection-switch-as-comparison",		"A fragment shader with uniform comparison in loop"										},
{	"int-mat2-struct.amber",						"int-mat2-struct",						"Fragment shader using (int, mat2) struct"												},
{	"loop-call-discard.amber",						"loop-call-discard",					"A fragment shader with nested loops and a function call"								},
{	"loop-dead-if-loop.amber",						"loop-dead-if-loop",					"A fragment shader with a loop, dead if, and a loop"									},
{	"loop-nested-ifs.amber",						"loop-nested-ifs",						"A fragment shader with a for loop containing nested ifs"								},
{	"loops-breaks-returns.amber",					"loops-breaks-returns",					"A compute shader with loops, breaks, returns"											},
{	"loops-ifs-continues-call.amber",				"loops-ifs-continues-call",				"A fragment shader with nested control flow and a call"									},
{	"mat-array-deep-control-flow.amber",			"mat-array-deep-control-flow",			"A fragment shader that uses an array of matrices and has deep control flow"			},
{	"mat-array-distance.amber",						"mat-array-distance",					"A fragment shader that uses an array of matrices and distance"							},
{	"mat-mul-in-loop.amber",						"mat-mul-in-loop",						"Shader with matrix multiplication in loop"												},
{	"matrices-and-return-in-loop.amber",			"matrices-and-return-in-loop",			"A fragment shader with matrices and a return in a loop"								},
{	"max-mix-conditional-discard.amber",			"max-mix-conditional-discard",			"A fragment shader with an expression used in two discard guards"						},
{	"mix-floor-add.amber",							"mix-floor-add",						"A fragment shader with mix, uintBitsToFloat, and floor"								},
{	"modf-gl-color.amber",							"modf-gl-color",						"A fragment shader with modf of gl color"												},
{	"modf-temp-modf-color.amber",					"modf-temp-modf-color",					"A fragment shader that calls modf twice, once with color"								},
{	"nested-for-break-mat-color.amber",				"nested-for-break-mat-color",			"Two nested for loops modify a mat4 then writes red"									},
{	"nested-for-loops-switch-fallthrough.amber",												"nested-for-loops-switch-fallthrough",												"A fragment shader with few nested loops with fallthrough"							},
{	"nested-for-loops-with-return.amber",			"nested-for-loops-with-return",			"A fragment shader with two nested for loops with return"								},
{	"nested-ifs-and-return-in-for-loop.amber",		"nested-ifs-and-return-in-for-loop",	"A fragment shader with return in nest of ifs, inside loop"								},
{	"nested-loops-switch.amber",					"nested-loops-switch",					"A fragment shader with nested loops and a switch"										},
{	"nested-switch-break-discard.amber",			"nested-switch-break-discard",			"Nested switches with break and discard"												},
{	"one-sized-array.amber",						"one-sized-array",						"A fragment shader that uses a struct with an array of size one"						},
{	"pow-vec4.amber",								"pow-vec4",								"A fragment shader that uses pow"														},
{	"return-before-writing-wrong-color.amber",		"return-before-writing-wrong-color",	"A fragment shader with return before writing wrong color"								},
{	"return-float-from-while-loop.amber",			"return-float-from-while-loop",			"A fragment shader with unreachable while loop"											},
{	"return-in-loop-in-function.amber",				"return-in-loop-in-function",			"A fragment shader with early return from loop in function"								},
{	"return-inside-loop-in-function.amber",			"return-inside-loop-in-function",		"A fragment shader with return inside loop"												},
{	"return-mat2x3-value-from-func.amber",														"return-mat2x3-value-from-func",													"A fragment shader that has a function with mat2x3"									},
{	"returned-boolean-in-vector.amber",				"returned-boolean-in-vector",			"A fragment shader with returned boolean in vector"										},
{	"set-color-in-one-iteration-while-loop.amber",												"set-color-in-one-iteration-while-loop",											"A frag shader that sets the color in one iter while loop"							},
{	"similar-nested-ifs.amber",						"similar-nested-ifs",					"A fragment shader with similar nested ifs and loops"									},
{	"smoothstep-after-loop.amber",					"smoothstep-after-loop",				"Fragment shader with 1-iteration loop and smoothstep"									},
{	"stable-binarysearch-tree-with-loop-read-write-global.amber",								"stable-binarysearch-tree-with-loop-read-write-global",								"A pair of fragment shaders that both render red"									},
{	"struct-and-unreachable-infinite-loop.amber",	"struct-and-unreachable-infinite-loop",	"Fragment shader with struct and unreachable infinite loop"								},
{	"struct-array-data-as-loop-iterator.amber",													"struct-array-data-as-loop-iterator",												"A fragment shader that uses struct array data for loop iterator value"				},
{	"struct-controlled-loop.amber",					"struct-controlled-loop",				"Shader with loop controlled by struct"													},
{	"struct-used-as-temporary.amber",				"struct-used-as-temporary",				"A fragment shader that uses a temporary struct variable"								},
{	"switch-case-with-undefined-expression.amber",	"switch-case-with-undefined-expression","A fragment shader with undefined expression"											},
{	"switch-if-discard.amber",						"switch-if-discard",					"A fragment shader with a switch, if, and discard"										},
{	"switch-inside-while-always-return.amber",		"switch-inside-while-always-return",	"A fragment shader with a switch inside while always return"							},
{	"switch-loop-switch-if.amber",					"switch-loop-switch-if",				"A nested switch-loop-switch"															},
{	"switch-with-empty-if-false.amber",				"switch-with-empty-if-false",			"A fragment shader with always false if in switch statement"							},
{	"switch-with-fall-through-cases.amber",														"switch-with-fall-through-cases",													"A fragment shader with switch cases that fall through"								},
{	"swizzle-struct-init-min.amber",				"swizzle-struct-init-min",				"A fragment shader that uses vector swizzles, struct initializers, and min"				},
{	"transpose-rectangular-matrix.amber",			"transpose-rectangular-matrix",			"Fragment shader that uses 'transpose'"													},
{	"two-2-iteration-loops.amber",					"two-2-iteration-loops",				"Fragment shader with pair of outer loops"												},
{	"two-for-loops-with-barrier-function.amber",	"two-for-loops-with-barrier-function",	"A compute shader with two barrier functions"											},
{	"two-loops-mat-add.amber",						"two-loops-mat-add",					"A fragment shader with two for loops over a global matrix"								},
{	"two-loops-matrix.amber",						"two-loops-matrix",						"A fragment shader with two loops and some matrices"									},
{	"two-loops-set-struct.amber",					"two-loops-set-struct",					"A fragment shader with two loops that write to a struct"								},
{	"two-loops-with-break.amber",					"two-loops-with-break",					"A fragment shader with two loops with breaks"											},
{	"two-nested-do-whiles.amber",					"two-nested-do-whiles",					"A fragment shader with nested do while"												},
{	"two-nested-for-loops-with-returns.amber",		"two-nested-for-loops-with-returns",	"A compute shader with two nested for loops"											},
{	"two-nested-infinite-loops-discard.amber",		"two-nested-infinite-loops-discard",	"A fragment shader with an always false if function"									},
{	"undefined-integer-in-function.amber",			"undefined-integer-in-function",		"A fragment shader with nested do while and undefined int"								},
{	"uninit-element-cast-in-loop.amber",			"uninit-element-cast-in-loop",			"A fragment shader with uninitialized element cast in loop"								},
{	"uninitialized-var-decrement-and-add.amber",	"uninitialized-var-decrement-and-add",	"A fragment shader that uses an uninitialized variable"									},
{	"undefined-assign-in-infinite-loop.amber",		"undefined-assign-in-infinite-loop",	"A fragment shader with uninitialized read in infinite loop"							},
{	"unreachable-barrier-in-loops.amber",			"unreachable-barrier-in-loops",			"A compute shader with an unreachable barrier in a loop nest"							},
{	"unreachable-continue-statement.amber",			"unreachable-continue-statement",		"A fragment shader with unreachable continue statement"									},
{	"unreachable-discard-statement-in-if.amber",	"unreachable-discard-statement-in-if",	"A fragment shader with discard keyword and a return"									},
{	"unreachable-discard-statement.amber",			"unreachable-discard-statement",		"A fragment shader with unreachable discard statement"									},
{	"unreachable-loops.amber",						"unreachable-loops",					"Fragment shader that writes red despite unreachable loops"								},
{	"unreachable-loops-in-switch.amber",			"unreachable-loops-in-switch",			"A fragment shader with unreachable loops in a switch"									},
{	"unreachable-return-in-loop.amber",				"unreachable-return-in-loop",			"A fragment shader with an unreachable return in a loop"								},
{	"unreachable-switch-case-with-discards.amber",	"unreachable-switch-case-with-discards","A shader with a switch statement containing unreachable discards"						},
{	"uv-value-comparison-as-boolean.amber",			"uv-value-comparison-as-boolean",		"A fragment shader with uv value comparison as boolean"									},
{	"vector-values-multiplied-by-fragcoord.amber",												"vector-values-multiplied-by-fragcoord",											"A shader that multiplies a vector by fragcoord"									},
{	"vectors-and-discard-in-function.amber",		"vectors-and-discard-in-function",		"A fragment shader that assigns vector values"											},
{	"while-function-always-false.amber",			"while-function-always-false",			"A fragment shader with an always false while function"									},
{	"while-inside-switch.amber",					"while-inside-switch",					"A fragment shader that uses a while loop inside a switch"								},
{	"write-before-break.amber",						"write-before-break",					"Fragment shader that writes red before loop break"										},
{	"write-red-in-loop-nest.amber",					"write-red-in-loop-nest",				"A fragment shader that writes red in a nest of loops"									},
{	"wrong-color-in-always-false-if.amber",			"wrong-color-in-always-false-if",		"A fragment shader with wrong color write in false if"									},
