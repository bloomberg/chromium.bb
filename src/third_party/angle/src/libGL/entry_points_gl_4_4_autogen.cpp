// GENERATED FILE - DO NOT EDIT.
// Generated by generate_entry_points.py using data from gl.xml.
//
// Copyright 2019 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// entry_points_gl_4_4_autogen.cpp:
//   Defines the GL 4.4 entry points.

#include "libGL/entry_points_gl_4_4_autogen.h"

#include "libANGLE/Context.h"
#include "libANGLE/Context.inl.h"
#include "libANGLE/entry_points_utils.h"
#include "libANGLE/validationEGL.h"
#include "libANGLE/validationES.h"
#include "libANGLE/validationES1.h"
#include "libANGLE/validationES2.h"
#include "libANGLE/validationES3.h"
#include "libANGLE/validationES31.h"
#include "libANGLE/validationESEXT.h"
#include "libANGLE/validationGL44_autogen.h"
#include "libGLESv2/global_state.h"

namespace gl
{
void GL_APIENTRY BindBuffersBase(GLenum target, GLuint first, GLsizei count, const GLuint *buffers)
{
    EVENT(
        "(GLenum target = 0x%X, GLuint first = %u, GLsizei count = %d, const GLuint *buffers = "
        "0x%016" PRIxPTR ")",
        target, first, count, (uintptr_t)buffers);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        ANGLE_CAPTURE(BindBuffersBase, context, target, first, count, buffers);
        if (context->skipValidation() ||
            ValidateBindBuffersBase(context, target, first, count, buffers))
        {
            context->bindBuffersBase(target, first, count, buffers);
        }
    }
}

void GL_APIENTRY BindBuffersRange(GLenum target,
                                  GLuint first,
                                  GLsizei count,
                                  const GLuint *buffers,
                                  const GLintptr *offsets,
                                  const GLsizeiptr *sizes)
{
    EVENT(
        "(GLenum target = 0x%X, GLuint first = %u, GLsizei count = %d, const GLuint *buffers = "
        "0x%016" PRIxPTR ", const GLintptr *offsets = 0x%016" PRIxPTR
        ", const GLsizeiptr *sizes = 0x%016" PRIxPTR ")",
        target, first, count, (uintptr_t)buffers, (uintptr_t)offsets, (uintptr_t)sizes);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        ANGLE_CAPTURE(BindBuffersRange, context, target, first, count, buffers, offsets, sizes);
        if (context->skipValidation() ||
            ValidateBindBuffersRange(context, target, first, count, buffers, offsets, sizes))
        {
            context->bindBuffersRange(target, first, count, buffers, offsets, sizes);
        }
    }
}

void GL_APIENTRY BindImageTextures(GLuint first, GLsizei count, const GLuint *textures)
{
    EVENT("(GLuint first = %u, GLsizei count = %d, const GLuint *textures = 0x%016" PRIxPTR ")",
          first, count, (uintptr_t)textures);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        ANGLE_CAPTURE(BindImageTextures, context, first, count, textures);
        if (context->skipValidation() || ValidateBindImageTextures(context, first, count, textures))
        {
            context->bindImageTextures(first, count, textures);
        }
    }
}

void GL_APIENTRY BindSamplers(GLuint first, GLsizei count, const GLuint *samplers)
{
    EVENT("(GLuint first = %u, GLsizei count = %d, const GLuint *samplers = 0x%016" PRIxPTR ")",
          first, count, (uintptr_t)samplers);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        ANGLE_CAPTURE(BindSamplers, context, first, count, samplers);
        if (context->skipValidation() || ValidateBindSamplers(context, first, count, samplers))
        {
            context->bindSamplers(first, count, samplers);
        }
    }
}

void GL_APIENTRY BindTextures(GLuint first, GLsizei count, const GLuint *textures)
{
    EVENT("(GLuint first = %u, GLsizei count = %d, const GLuint *textures = 0x%016" PRIxPTR ")",
          first, count, (uintptr_t)textures);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        ANGLE_CAPTURE(BindTextures, context, first, count, textures);
        if (context->skipValidation() || ValidateBindTextures(context, first, count, textures))
        {
            context->bindTextures(first, count, textures);
        }
    }
}

void GL_APIENTRY BindVertexBuffers(GLuint first,
                                   GLsizei count,
                                   const GLuint *buffers,
                                   const GLintptr *offsets,
                                   const GLsizei *strides)
{
    EVENT("(GLuint first = %u, GLsizei count = %d, const GLuint *buffers = 0x%016" PRIxPTR
          ", const GLintptr *offsets = 0x%016" PRIxPTR ", const GLsizei *strides = 0x%016" PRIxPTR
          ")",
          first, count, (uintptr_t)buffers, (uintptr_t)offsets, (uintptr_t)strides);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        ANGLE_CAPTURE(BindVertexBuffers, context, first, count, buffers, offsets, strides);
        if (context->skipValidation() ||
            ValidateBindVertexBuffers(context, first, count, buffers, offsets, strides))
        {
            context->bindVertexBuffers(first, count, buffers, offsets, strides);
        }
    }
}

void GL_APIENTRY BufferStorage(GLenum target, GLsizeiptr size, const void *data, GLbitfield flags)
{
    EVENT("(GLenum target = 0x%X, GLsizeiptr size = %llu, const void *data = 0x%016" PRIxPTR
          ", GLbitfield flags = 0x%X)",
          target, static_cast<unsigned long long>(size), (uintptr_t)data, flags);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        ANGLE_CAPTURE(BufferStorage, context, target, size, data, flags);
        if (context->skipValidation() || ValidateBufferStorage(context, target, size, data, flags))
        {
            context->bufferStorage(target, size, data, flags);
        }
    }
}

void GL_APIENTRY
ClearTexImage(GLuint texture, GLint level, GLenum format, GLenum type, const void *data)
{
    EVENT(
        "(GLuint texture = %u, GLint level = %d, GLenum format = 0x%X, GLenum type = 0x%X, const "
        "void *data = 0x%016" PRIxPTR ")",
        texture, level, format, type, (uintptr_t)data);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        ANGLE_CAPTURE(ClearTexImage, context, texture, level, format, type, data);
        if (context->skipValidation() ||
            ValidateClearTexImage(context, texture, level, format, type, data))
        {
            context->clearTexImage(texture, level, format, type, data);
        }
    }
}

void GL_APIENTRY ClearTexSubImage(GLuint texture,
                                  GLint level,
                                  GLint xoffset,
                                  GLint yoffset,
                                  GLint zoffset,
                                  GLsizei width,
                                  GLsizei height,
                                  GLsizei depth,
                                  GLenum format,
                                  GLenum type,
                                  const void *data)
{
    EVENT(
        "(GLuint texture = %u, GLint level = %d, GLint xoffset = %d, GLint yoffset = %d, GLint "
        "zoffset = %d, GLsizei width = %d, GLsizei height = %d, GLsizei depth = %d, GLenum format "
        "= 0x%X, GLenum type = 0x%X, const void *data = 0x%016" PRIxPTR ")",
        texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type,
        (uintptr_t)data);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        ANGLE_CAPTURE(ClearTexSubImage, context, texture, level, xoffset, yoffset, zoffset, width,
                      height, depth, format, type, data);
        if (context->skipValidation() ||
            ValidateClearTexSubImage(context, texture, level, xoffset, yoffset, zoffset, width,
                                     height, depth, format, type, data))
        {
            context->clearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height,
                                      depth, format, type, data);
        }
    }
}
}  // namespace gl
