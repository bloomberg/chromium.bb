// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// The messages in this file comprise the DBus/Proto interface for
// the new set of Cryptohome interface after the refactor, and the
// associated messages that's used by those interfaces.
// All input parameter to a call is named with a "Request" suffix,
// and all output parameter to a call is named with a "Reply" suffix.

syntax = "proto3";

option optimize_for = LITE_RUNTIME;

package user_data_auth;

import "key.proto";

///////////////////////////////////////////////////////////////////////////////
// Messages that's used by the actual request/reply goes below
///////////////////////////////////////////////////////////////////////////////

// We still need the AccountIdentifier, KeyDelegate and AuthorizationRequest
// messages from the old interface.
import "rpc.proto";

// Error codes do not need to be sequential per-call.
// Prefixes by Request/Reply type should be used to help
// callers know if specialized errors apply.
enum CryptohomeErrorCode {
  // 0 is the default value of BaseReply::error. It
  // should never be used.
  CRYPTOHOME_ERROR_NOT_SET = 0;

  CRYPTOHOME_ERROR_ACCOUNT_NOT_FOUND = 1;
  CRYPTOHOME_ERROR_AUTHORIZATION_KEY_NOT_FOUND = 2;
  CRYPTOHOME_ERROR_AUTHORIZATION_KEY_FAILED = 3;
  CRYPTOHOME_ERROR_NOT_IMPLEMENTED = 4;
  CRYPTOHOME_ERROR_MOUNT_FATAL = 5;
  CRYPTOHOME_ERROR_MOUNT_MOUNT_POINT_BUSY = 6;
  CRYPTOHOME_ERROR_TPM_COMM_ERROR = 7;
  CRYPTOHOME_ERROR_TPM_DEFEND_LOCK = 8;
  CRYPTOHOME_ERROR_TPM_NEEDS_REBOOT = 9;
  CRYPTOHOME_ERROR_AUTHORIZATION_KEY_DENIED = 10;
  CRYPTOHOME_ERROR_KEY_QUOTA_EXCEEDED = 11;
  CRYPTOHOME_ERROR_KEY_LABEL_EXISTS = 12;
  CRYPTOHOME_ERROR_BACKING_STORE_FAILURE = 13;
  CRYPTOHOME_ERROR_UPDATE_SIGNATURE_INVALID = 14;
  CRYPTOHOME_ERROR_KEY_NOT_FOUND = 15;
  CRYPTOHOME_ERROR_LOCKBOX_SIGNATURE_INVALID = 16;
  CRYPTOHOME_ERROR_LOCKBOX_CANNOT_SIGN = 17;
  CRYPTOHOME_ERROR_BOOT_ATTRIBUTE_NOT_FOUND = 18;
  CRYPTOHOME_ERROR_BOOT_ATTRIBUTES_CANNOT_SIGN = 19;
  CRYPTOHOME_ERROR_TPM_EK_NOT_AVAILABLE = 20;
  CRYPTOHOME_ERROR_ATTESTATION_NOT_READY = 21;
  CRYPTOHOME_ERROR_CANNOT_CONNECT_TO_CA = 22;
  CRYPTOHOME_ERROR_CA_REFUSED_ENROLLMENT = 23;
  CRYPTOHOME_ERROR_CA_REFUSED_CERTIFICATE = 24;
  CRYPTOHOME_ERROR_INTERNAL_ATTESTATION_ERROR = 25;
  CRYPTOHOME_ERROR_FIRMWARE_MANAGEMENT_PARAMETERS_INVALID = 26;
  CRYPTOHOME_ERROR_FIRMWARE_MANAGEMENT_PARAMETERS_CANNOT_STORE = 27;
  CRYPTOHOME_ERROR_FIRMWARE_MANAGEMENT_PARAMETERS_CANNOT_REMOVE = 28;
  CRYPTOHOME_ERROR_MOUNT_OLD_ENCRYPTION = 29;
  CRYPTOHOME_ERROR_MOUNT_PREVIOUS_MIGRATION_INCOMPLETE = 30;
  CRYPTOHOME_ERROR_MIGRATE_KEY_FAILED = 31;
  CRYPTOHOME_ERROR_REMOVE_FAILED = 32;
}

// This is used by MountRequest to store details about the mount to create
message CreateRequest {
  // In the future, this will contain account-wide data like
  // the deletion priority or the IdP's origin.

  // keys contain the key data to add to the key for the mount that we
  // are creating. Currently, only one key is supported.
  // TODO(b/133212955): Change the name of this to "key".
  repeated cryptohome.Key keys = 1;
  // Explicitly use the |key| from the AuthorizationRequest.
  // Setting this value means that the KeyData is filled as it
  // would be with a Key above or in an AddKeyRequest.
  bool copy_authorization_key = 2;
  // If set to true, always use eCryptfs as the encryption method.
  bool force_ecryptfs = 3;
}

///////////////////////////////////////////////////////////////////////////////
// Actual request/reply goes below
///////////////////////////////////////////////////////////////////////////////

// Input parameters to IsMounted()
message IsMountedRequest {
  // If username is available, then it'll check if a specific user's home
  // directory is mounted. Otherwise, it'll check if any home directory is
  // mounted.
  string username = 1;
}

// Output parameters for IsMounted()
message IsMountedReply {
  // If the requested home directory is mounted.
  bool is_mounted = 1;
  // If the mount is ephemeral, that is, if the contents get cleared once
  // the user logs out.
  bool is_ephemeral_mount = 2;
}

// Input parameters to Unmount()
// Currently we only support unmounting all mounted cryptohomes but in the
// future we may implement per-user unmount, at which point we can extend this
// proto with the necessary information.
message UnmountRequest {
}

// Output parameters for Unmount()
message UnmountReply {
  // Indicates an error if |error| is not empty.
  CryptohomeErrorCode error = 1;
}

// Input parameters to Mount()
message MountRequest {
  // The account of the user whose home directory is requested for mounting.
  cryptohome.AccountIdentifier account = 1;
  // Authorization data from the user.
  cryptohome.AuthorizationRequest authorization = 2;

  // If set, then perform an ephemeral mount only.
  bool require_ephemeral = 3;
  // If defined, the account will be created if it does not exist.
  // Additionally, a failed AuthorizationRequest will be expected as
  // there will be no existing keys.
  CreateRequest create = 4;
  // If set to true, and cryptohomed supports the new "dircrypto" encryption,
  // forces to use the new encryption. That is, makes it an error to mount
  // an existing home directory encrypted in the old way (ecryptfs).
  bool force_dircrypto_if_available = 5;
  // If set to true, mounts the existing ecryptfs vault to a temporary location
  // while setting up a new dircrypto directory.
  bool to_migrate_from_ecryptfs = 6;
  // If set, then performs a public mount, which is used for a Kiosk session.
  // Credentials are not needed in the request; they are synthesized by
  // cryptohomed from id.
  bool public_mount = 7;
  // If set to true, mounts the vault to a temporary location. The mount is not
  // exposed to the usual locations (/home/user, /home/root).
  bool hidden_mount = 8;
  // If set to true, the mount will be for a guest session.
  bool guest_mount = 9;
}

// Output parameters for Mount()
message MountReply {
  // Indicate an error when |error| is not empty.
  CryptohomeErrorCode error = 1;
  // |recreated| is set when the cryptohome had to be wiped
  // because the key or data was an unrecoverable.  It does not imply
  // failure to Mount nor is it 'true' when a CreateRequest creates
  // a cryptohome for the first time.
  bool recreated = 2;
  // Returns the filesystem-sanitized username.
  string sanitized_username = 3;
}

// Input parameters to Remove()
message RemoveRequest {
  // Identifies the user, whose home directory to remove
  cryptohome.AccountIdentifier identifier = 1;
}

// Output parameters for Remove()
message RemoveReply {
  // Indicate an error when |error| is not empty.
  CryptohomeErrorCode error = 1;
}

// Input parameters to Rename()
message RenameRequest {
  // Identifies the user, whose home directory to rename
  cryptohome.AccountIdentifier id_from = 1;
  // After the Rename() operation the home directory will have a name that is
  // the same as if it is owned by |id_to|
  cryptohome.AccountIdentifier id_to = 2;
}

// Output parameters for Rename()
message RenameReply {
  // Indicate an error when |error| is not empty.
  CryptohomeErrorCode error = 1;
}

// Input parameters to ListKeys()
message ListKeysRequest {
  // The default behavior is by label so any extension here should honor that.

  // List the key(s) that is/are used to protect the home directory whose
  // owner is identified by account_id.
  cryptohome.AccountIdentifier account_id = 1;
  // Provide user authentication if necessary (currently not required).
  cryptohome.AuthorizationRequest authorization_request = 2;
}

// Output parameters for ListKeys()
message ListKeysReply {
  // Indicates an error if error is not empty.
  CryptohomeErrorCode error = 1;
  // The labels of the Vault Keyset. This will be empty on error.
  repeated string labels = 2;
}

// Input parameters to GetKeyData()
message GetKeyDataRequest {
  // The keys whose data to retrieve, is the key whose owner is identified
  // by account_id.
  cryptohome.AccountIdentifier account_id = 1;
  // Provide user authentication if necessary (currently not required).
  cryptohome.AuthorizationRequest authorization_request = 2;
  // |key| must supply at least one attribute and all others will be treated as
  // wildcards.  Currently only |key.data().label()| may be supplied.  Like
  // AuthorizationRequest, support can be added for queries by
  // |key.data().type()| to return all keys of a certain class, testing
  // |key.secret()|, or |key.data().provider_data()| entries.
  cryptohome.Key key = 3;
}

// Output parameters for GetKeyData()
message GetKeyDataReply {
  // Indicates an error if error is not empty.
  CryptohomeErrorCode error = 1;
  // The data associated with those keys.
  repeated cryptohome.KeyData key_data = 2;
}

// Input parameters to CheckKey()
message CheckKeyRequest {
  // We only check against keys that belongs to the user identified by
  // account_id.
  cryptohome.AccountIdentifier account_id = 1;
  // The authentication credentials to check against the keys
  cryptohome.AuthorizationRequest authorization_request = 2;
}

// Output parameters for CheckKey()
message CheckKeyReply {
  // Indicates an error if error is not empty.
  CryptohomeErrorCode error = 1;
}

// Input parameters to AddKey()
message AddKeyRequest {
  // The owner of the new key.
  cryptohome.AccountIdentifier account_id = 1;
  // The authentication data of the new key.
  cryptohome.AuthorizationRequest authorization_request = 2;
  // The key to add.
  cryptohome.Key key = 3;
  // Do we delete the existing key if it already exists?
  bool clobber_if_exists = 4;
}

// Output parameters for AddKey()
message AddKeyReply {
  // Indicates an error if error is not empty.
  CryptohomeErrorCode error = 1;
}

// Input parameters to UpdateKey()
message UpdateKeyRequest {
  // Whose key to update?
  cryptohome.AccountIdentifier account_id = 1;
  // The authentication data from user.
  cryptohome.AuthorizationRequest authorization_request = 2;
  // The changes to be made to the key.
  cryptohome.Key changes = 3;
  // Signature of the changes object above with the key itself.
  bytes authorization_signature = 4;
}

// Output parameters for UpdateKey()
message UpdateKeyReply {
  // Indicates an error if error is not empty.
  CryptohomeErrorCode error = 1;
}

// Input parameters to RemoveKey()
message RemoveKeyRequest {
  // The owner of the key to remove
  cryptohome.AccountIdentifier account_id = 1;
  // Authorization from the user
  cryptohome.AuthorizationRequest authorization_request = 2;
  // Only key.data().label() is used at present.
  cryptohome.Key key = 3;
}

// Output parameters for RemoveKey()
message RemoveKeyReply {
  // Indicates an error if error is not empty.
  CryptohomeErrorCode error = 1;
}

// Input parameters to MigrateKey()
message MigrateKeyRequest {
  // The owner whose key are going to migrate
  cryptohome.AccountIdentifier account_id = 1;
  // Authorization from the user
  cryptohome.AuthorizationRequest authorization_request = 2;
  // The new secret for the key.
  bytes secret = 3;
}

// Output parameters for MigrateKey()
message MigrateKeyReply {
  // Indicates an error if error is not empty.
  CryptohomeErrorCode error = 1;
}

// TODO(b/126307305): For the messages, below, we'll need to add the documentations
// for them.

message StartMigrateToDircryptoRequest {
  cryptohome.AccountIdentifier account_id = 1;
  // If true, only a few paths (specified in cryptohomed) that are necessary for
  // a working profile will be migrated. Most user data will be wiped.
  bool minimal_migration = 2;
}

message StartMigrateToDircryptoReply {
  CryptohomeErrorCode error = 1;
}

message NeedsDircryptoMigrationRequest {
  cryptohome.AccountIdentifier account_id = 1;
}

message NeedsDircryptoMigrationReply {
  bool needs_dircrypto_migration = 1;
}

message GetSupportedKeyPoliciesRequest {
}

// Response that informs the caller which KeyPolicy features are supported.
message GetSupportedKeyPoliciesReply {
  // Whether low entropy credentials is supported by the policies
  bool low_entropy_credentials_supported = 1;
}

message GetDiskFeaturesRequest {
}

message GetDiskFeaturesReply {
  bool quota_supported = 1;
}

message GetAccountDiskUsageRequest {
  cryptohome.AccountIdentifier identifier = 1;
}

message GetAccountDiskUsageReply {
  CryptohomeErrorCode error = 1;
  // The size of cryptohome in bytes.
  int64 size = 2;
}

message GetCurrentSpaceForUidRequest {
  uint32 uid = 1;
}

message GetCurrentSpaceForUidReply {
  int64 cur_space = 1;
}

message GetCurrentSpaceForGidRequest {
  uint32 gid = 1;
}

message GetCurrentSpaceForGidReply {
  int64 cur_space = 1;
}
