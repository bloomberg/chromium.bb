<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
                      "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>LLVM: Frequently Asked Questions</title>
  <style type="text/css">
    @import url("llvm.css");
    .question { font-weight: bold }
    .answer   { margin-left: 2em  }
  </style>
</head>
<body>

<h1>
  LLVM: Frequently Asked Questions
</h1>

<ol>
  <li><a href="#license">License</a>
  <ol>
    <li>Why are the LLVM source code and the front-end distributed under
        different licenses?</li>

    <li>Does the University of Illinois Open Source License really qualify as an
       "open source" license?</li>

    <li>Can I modify LLVM source code and redistribute the modified source?</li>

    <li>Can I modify LLVM source code and redistribute binaries or other tools
        based on it, without redistributing the source?</li>
  </ol></li>

  <li><a href="#source">Source code</a>
  <ol>
    <li>In what language is LLVM written?</li>

    <li>How portable is the LLVM source code?</li>
  </ol></li>

  <li><a href="#build">Build Problems</a>
  <ol>
    <li>When I run configure, it finds the wrong C compiler.</li>

    <li>The <tt>configure</tt> script finds the right C compiler, but it uses
        the LLVM linker from a previous build.  What do I do?</li>

    <li>When creating a dynamic library, I get a strange GLIBC error.</li>

    <li>I've updated my source tree from Subversion, and now my build is trying
        to use a file/directory that doesn't exist.</li>

    <li>I've modified a Makefile in my source tree, but my build tree keeps
        using the old version.  What do I do?</li>

    <li>I've upgraded to a new version of LLVM, and I get strange build
        errors.</li>

    <li>I've built LLVM and am testing it, but the tests freeze.</li>

    <li>Why do test results differ when I perform different types of
        builds?</li>

    <li>Compiling LLVM with GCC 3.3.2 fails, what should I do?</li>

    <li>Compiling LLVM with GCC succeeds, but the resulting tools do not work,
        what can be wrong?</li>

    <li>When I use the test suite, all of the C Backend tests fail.  What is
        wrong?</li>

    <li>After Subversion update, rebuilding gives the error "No rule to make
        target".</li>

    <li><a href="#srcdir-objdir">When I compile LLVM-GCC with srcdir == objdir,
        it fails. Why?</a></li>
  </ol></li>

  <li><a href="#felangs">Source Languages</a>
  <ol>
    <li><a href="#langs">What source languages are supported?</a></li>

    <li><a href="#langirgen">I'd like to write a self-hosting LLVM compiler. How
        should I interface with the LLVM middle-end optimizers and back-end code
        generators?</a></li>

    <li><a href="#langhlsupp">What support is there for higher level source
        language constructs for building a compiler?</a></li>

    <li><a href="GetElementPtr.html">I don't understand the GetElementPtr
      instruction. Help!</a></li>
  </ol>

  <li><a href="#cfe">Using the GCC Front End</a>
  <ol>
    <li>When I compile software that uses a configure script, the configure
        script thinks my system has all of the header files and libraries it is
        testing for.  How do I get configure to work correctly?</li>

    <li>When I compile code using the LLVM GCC front end, it complains that it
        cannot find libcrtend.a?</li>

    <li>How can I disable all optimizations when compiling code using the LLVM
        GCC front end?</li>

    <li><a href="#translatecxx">Can I use LLVM to convert C++ code to C
        code?</a></li>

    <li><a href="#platformindependent">Can I compile C or C++ code to
        platform-independent LLVM bitcode?</a></li>
  </ol>
  </li>

  <li><a href="#cfe_code">Questions about code generated by the GCC front-end</a>
  <ol>
     <li><a href="#iosinit">What is this <tt>llvm.global_ctors</tt> and
          <tt>_GLOBAL__I__tmp_webcompile...</tt> stuff that happens when I
          #include &lt;iostream&gt;?</a></li>

     <li><a href="#codedce">Where did all of my code go??</a></li>

     <li><a href="#undef">What is this "<tt>undef</tt>" thing that shows up in
         my code?</a></li>
         
      <li><a href="#callconvwrong">Why does instcombine + simplifycfg turn
   a call to a function with a mismatched calling convention into "unreachable"?
   Why not make the verifier reject it?</a></li>
  </ol>
  </li>
</ol>

<div class="doc_author">
  <p>Written by <a href="http://llvm.org/">The LLVM Team</a></p>
</div>


<!-- *********************************************************************** -->
<h2>
  <a name="license">License</a>
</h2>
<!-- *********************************************************************** -->

<div class="question">
<p>Why are the LLVM source code and the front-end distributed under different
   licenses?</p>
</div>
	
<div class="answer">
<p>The C/C++ front-ends are based on GCC and must be distributed under the GPL.
   Our aim is to distribute LLVM source code under a <em>much less
   restrictive</em> license, in particular one that does not compel users who
   distribute tools based on modifying the source to redistribute the modified
   source code as well.</p>
</div>

<div class="question">
<p>Does the University of Illinois Open Source License really qualify as an
   "open source" license?</p>
</div>

<div class="answer">
<p>Yes, the license
   is <a href="http://www.opensource.org/licenses/UoI-NCSA.php">certified</a> by
   the Open Source Initiative (OSI).</p>
</div>

<div class="question">
<p>Can I modify LLVM source code and redistribute the modified source?</p>
</div>

<div class="answer">
<p>Yes.  The modified source distribution must retain the copyright notice and
   follow the three bulletted conditions listed in
   the <a href="http://llvm.org/svn/llvm-project/llvm/trunk/LICENSE.TXT">LLVM
   license</a>.</p>
</div>

<div class="question">
<p>Can I modify LLVM source code and redistribute binaries or other tools based
   on it, without redistributing the source?</p>
</div>

<div class="answer">
<p>Yes. This is why we distribute LLVM under a less restrictive license than
   GPL, as explained in the first question above.</p>
</div>

<!-- *********************************************************************** -->
<h2>
  <a name="source">Source Code</a>
</h2>
<!-- *********************************************************************** -->

<div class="question">
<p>In what language is LLVM written?</p>
</div>

<div class="answer">
<p>All of the LLVM tools and libraries are written in C++ with extensive use of
   the STL.</p>
</div>

<div class="question">
<p>How portable is the LLVM source code?</p>
</div>

<div class="answer">
<p>The LLVM source code should be portable to most modern UNIX-like operating
systems.  Most of the code is written in standard C++ with operating system
services abstracted to a support library.  The tools required to build and test
LLVM have been ported to a plethora of platforms.</p>

<p>Some porting problems may exist in the following areas:</p>

<ul>
  <li>The GCC front end code is not as portable as the LLVM suite, so it may not
      compile as well on unsupported platforms.</li>

  <li>The LLVM build system relies heavily on UNIX shell tools, like the Bourne
      Shell and sed.  Porting to systems without these tools (MacOS 9, Plan 9)
      will require more effort.</li>
</ul>

</div>

<!-- *********************************************************************** -->
<h2>
  <a name="build">Build Problems</a>
</h2>
<!-- *********************************************************************** -->

<div class="question">
<p>When I run configure, it finds the wrong C compiler.</p>
</div>

<div class="answer">
<p>The <tt>configure</tt> script attempts to locate first <tt>gcc</tt> and then
   <tt>cc</tt>, unless it finds compiler paths set in <tt>CC</tt>
   and <tt>CXX</tt> for the C and C++ compiler, respectively.</p>

<p>If <tt>configure</tt> finds the wrong compiler, either adjust your
   <tt>PATH</tt> environment variable or set <tt>CC</tt> and <tt>CXX</tt>
   explicitly.</p>

</div>

<div class="question">
<p>The <tt>configure</tt> script finds the right C compiler, but it uses the
   LLVM linker from a previous build.  What do I do?</p>
</div>

<div class="answer">
<p>The <tt>configure</tt> script uses the <tt>PATH</tt> to find executables, so
   if it's grabbing the wrong linker/assembler/etc, there are two ways to fix
   it:</p>

<ol>
  <li><p>Adjust your <tt>PATH</tt> environment variable so that the correct
      program appears first in the <tt>PATH</tt>.  This may work, but may not be
      convenient when you want them <i>first</i> in your path for other
      work.</p></li>

  <li><p>Run <tt>configure</tt> with an alternative <tt>PATH</tt> that is
      correct. In a Borne compatible shell, the syntax would be:</p>

<pre class="doc_code">
% PATH=[the path without the bad program] ./configure ...
</pre>

      <p>This is still somewhat inconvenient, but it allows <tt>configure</tt>
         to do its work without having to adjust your <tt>PATH</tt>
         permanently.</p></li>
</ol>
</div>

<div class="question">
<p>When creating a dynamic library, I get a strange GLIBC error.</p>
</div>

<div class="answer">
<p>Under some operating systems (i.e. Linux), libtool does not work correctly if
   GCC was compiled with the --disable-shared option.  To work around this,
   install your own version of GCC that has shared libraries enabled by
   default.</p>
</div>

<div class="question">
<p>I've updated my source tree from Subversion, and now my build is trying to
   use a file/directory that doesn't exist.</p>
</div>

<div class="answer">
<p>You need to re-run configure in your object directory.  When new Makefiles
   are added to the source tree, they have to be copied over to the object tree
   in order to be used by the build.</p>
</div>

<div class="question">
<p>I've modified a Makefile in my source tree, but my build tree keeps using the
   old version.  What do I do?</p>
</div>

<div class="answer">
<p>If the Makefile already exists in your object tree, you can just run the
   following command in the top level directory of your object tree:</p>

<pre class="doc_code">
% ./config.status &lt;relative path to Makefile&gt;
</pre>

<p>If the Makefile is new, you will have to modify the configure script to copy
   it over.</p>
</div>

<div class="question">
<p>I've upgraded to a new version of LLVM, and I get strange build errors.</p>
</div>

<div class="answer">

<p>Sometimes, changes to the LLVM source code alters how the build system works.
   Changes in libtool, autoconf, or header file dependencies are especially
   prone to this sort of problem.</p>

<p>The best thing to try is to remove the old files and re-build.  In most
   cases, this takes care of the problem.  To do this, just type <tt>make
   clean</tt> and then <tt>make</tt> in the directory that fails to build.</p>
</div>

<div class="question">
<p>I've built LLVM and am testing it, but the tests freeze.</p>
</div>

<div class="answer">
<p>This is most likely occurring because you built a profile or release
   (optimized) build of LLVM and have not specified the same information on the
   <tt>gmake</tt> command line.</p>

<p>For example, if you built LLVM with the command:</p>

<pre class="doc_code">
% gmake ENABLE_PROFILING=1
</pre>

<p>...then you must run the tests with the following commands:</p>

<pre class="doc_code">
% cd llvm/test
% gmake ENABLE_PROFILING=1
</pre>
</div>

<div class="question">
<p>Why do test results differ when I perform different types of builds?</p>
</div>

<div class="answer">
<p>The LLVM test suite is dependent upon several features of the LLVM tools and
   libraries.</p>

<p>First, the debugging assertions in code are not enabled in optimized or
   profiling builds.  Hence, tests that used to fail may pass.</p>
	
<p>Second, some tests may rely upon debugging options or behavior that is only
   available in the debug build.  These tests will fail in an optimized or
   profile build.</p>
</div>

<div class="question">
<p>Compiling LLVM with GCC 3.3.2 fails, what should I do?</p>
</div>

<div class="answer">
<p>This is <a href="http://gcc.gnu.org/bugzilla/show_bug.cgi?id=13392">a bug in
   GCC</a>, and affects projects other than LLVM.  Try upgrading or downgrading
   your GCC.</p>
</div>

<div class="question">
<p>Compiling LLVM with GCC succeeds, but the resulting tools do not work, what
   can be wrong?</p>
</div>

<div class="answer">
<p>Several versions of GCC have shown a weakness in miscompiling the LLVM
   codebase. Please consult your compiler version (<tt>gcc --version</tt>) to
   find out whether it is <a href="GettingStarted.html#brokengcc">broken</a>.
   If so, your only option is to upgrade GCC to a known good version.</p>
</div>

<div class="question">
<p>After Subversion update, rebuilding gives the error "No rule to make
   target".</p>
</div>

<div class="answer">
<p>If the error is of the form:</p>

<pre class="doc_code">
gmake[2]: *** No rule to make target `/path/to/somefile', needed by
`/path/to/another/file.d'.<br>
Stop.
</pre>

<p>This may occur anytime files are moved within the Subversion repository or
   removed entirely.  In this case, the best solution is to erase all
   <tt>.d</tt> files, which list dependencies for source files, and rebuild:</p>

<pre class="doc_code">
% cd $LLVM_OBJ_DIR
% rm -f `find . -name \*\.d` 
% gmake 
</pre>

<p>In other cases, it may be necessary to run <tt>make clean</tt> before
   rebuilding.</p>
</div>

<div class="question">
<p><a name="srcdir-objdir">When I compile LLVM-GCC with srcdir == objdir, it
   fails. Why?</a></p>
</div>

<div class="answer">
<p>The <tt>GNUmakefile</tt> in the top-level directory of LLVM-GCC is a special
   <tt>Makefile</tt> used by Apple to invoke the <tt>build_gcc</tt> script after
   setting up a special environment. This has the unfortunate side-effect that
   trying to build LLVM-GCC with srcdir == objdir in a "non-Apple way" invokes
   the <tt>GNUmakefile</tt> instead of <tt>Makefile</tt>. Because the
   environment isn't set up correctly to do this, the build fails.</p>

<p>People not building LLVM-GCC the "Apple way" need to build LLVM-GCC with
   srcdir != objdir, or simply remove the GNUmakefile entirely.</p>

<p>We regret the inconvenience.</p>
</div>

<!-- *********************************************************************** -->
<h2>
  <a name="felangs">Source Languages</a>
</h2>

<div class="question">
<p><a name="langs">What source languages are supported?</a></p>
</div>

<div class="answer">
<p>LLVM currently has full support for C and C++ source languages. These are
   available through a special version of GCC that LLVM calls the
   <a href="#cfe">C Front End</a></p>

<p>There is an incomplete version of a Java front end available in the
   <tt>java</tt> module. There is no documentation on this yet so you'll need to
   download the code, compile it, and try it.</p>

<p>The PyPy developers are working on integrating LLVM into the PyPy backend so
   that PyPy language can translate to LLVM.</p>
</div>

<div class="question">
<p><a name="langirgen">I'd like to write a self-hosting LLVM compiler. How
   should I interface with the LLVM middle-end optimizers and back-end code
   generators?</a></p>
</div>

<div class="answer">
<p>Your compiler front-end will communicate with LLVM by creating a module in
   the LLVM intermediate representation (IR) format. Assuming you want to write
   your language's compiler in the language itself (rather than C++), there are
   3 major ways to tackle generating LLVM IR from a front-end:</p>

<ul>
  <li><strong>Call into the LLVM libraries code using your language's FFI
      (foreign function interface).</strong>

    <ul>
      <li><em>for:</em> best tracks changes to the LLVM IR, .ll syntax, and .bc
          format</li>

      <li><em>for:</em> enables running LLVM optimization passes without a
          emit/parse overhead</li>

      <li><em>for:</em> adapts well to a JIT context</li>

      <li><em>against:</em> lots of ugly glue code to write</li>
    </ul></li>

  <li>  <strong>Emit LLVM assembly from your compiler's native language.</strong>
    <ul>
      <li><em>for:</em> very straightforward to get started</li>

      <li><em>against:</em> the .ll parser is slower than the bitcode reader
          when interfacing to the middle end</li>

      <li><em>against:</em> you'll have to re-engineer the LLVM IR object model
          and asm writer in your language</li>

      <li><em>against:</em> it may be harder to track changes to the IR</li>
    </ul></li>

  <li><strong>Emit LLVM bitcode from your compiler's native language.</strong>

    <ul>
      <li><em>for:</em> can use the more-efficient bitcode reader when
          interfacing to the middle end</li>

      <li><em>against:</em> you'll have to re-engineer the LLVM IR object 
          model and bitcode writer in your language</li>

      <li><em>against:</em> it may be harder to track changes to the IR</li>
    </ul></li>
</ul>

<p>If you go with the first option, the C bindings in include/llvm-c should help
   a lot, since most languages have strong support for interfacing with C. The
   most common hurdle with calling C from managed code is interfacing with the
   garbage collector. The C interface was designed to require very little memory
   management, and so is straightforward in this regard.</p>
</div>

<div class="question">
<p><a name="langhlsupp">What support is there for a higher level source language
   constructs for building a compiler?</a></p>
</div>

<div class="answer">
<p>Currently, there isn't much. LLVM supports an intermediate representation
   which is useful for code representation but will not support the high level
   (abstract syntax tree) representation needed by most compilers. There are no
   facilities for lexical nor semantic analysis.</p>
</div>

<div class="question">
<p><a name="getelementptr">I don't understand the GetElementPtr
   instruction. Help!</a></p>
</div>

<div class="answer">
<p>See <a href="GetElementPtr.html">The Often Misunderstood GEP
   Instruction</a>.</p>
</div>

<!-- *********************************************************************** -->
<h2>
  <a name="cfe">Using the GCC Front End</a>
</h2>

<div class="question">
<p>When I compile software that uses a configure script, the configure script
   thinks my system has all of the header files and libraries it is testing for.
   How do I get configure to work correctly?</p>
</div>

<div class="answer">
<p>The configure script is getting things wrong because the LLVM linker allows
   symbols to be undefined at link time (so that they can be resolved during JIT
   or translation to the C back end).  That is why configure thinks your system
   "has everything."</p>

<p>To work around this, perform the following steps:</p>

<ol>
  <li>Make sure the CC and CXX environment variables contains the full path to
      the LLVM GCC front end.</li>

  <li>Make sure that the regular C compiler is first in your PATH. </li>

  <li>Add the string "-Wl,-native" to your CFLAGS environment variable.</li>
</ol>

<p>This will allow the <tt>llvm-ld</tt> linker to create a native code
   executable instead of shell script that runs the JIT.  Creating native code
   requires standard linkage, which in turn will allow the configure script to
   find out if code is not linking on your system because the feature isn't
   available on your system.</p>
</div>

<div class="question">
<p>When I compile code using the LLVM GCC front end, it complains that it cannot
   find libcrtend.a.
</p>
</div>

<div class="answer">
<p>The only way this can happen is if you haven't installed the runtime
   library. To correct this, do:</p>

<pre class="doc_code">
% cd llvm/runtime
% make clean ; make install-bytecode
</pre>
</div>

<div class="question">
<p>How can I disable all optimizations when compiling code using the LLVM GCC
   front end?</p>
</div>

<div class="answer">
<p>Passing "-Wa,-disable-opt -Wl,-disable-opt" will disable *all* cleanup and
   optimizations done at the llvm level, leaving you with the truly horrible
   code that you desire.</p>
</div>


<div class="question">
<p><a name="translatecxx">Can I use LLVM to convert C++ code to C code?</a></p>
</div>

<div class="answer">
<p>Yes, you can use LLVM to convert code from any language LLVM supports to C.
   Note that the generated C code will be very low level (all loops are lowered
   to gotos, etc) and not very pretty (comments are stripped, original source
   formatting is totally lost, variables are renamed, expressions are
   regrouped), so this may not be what you're looking for. Also, there are
   several limitations noted below.<p>

<p>Use commands like this:</p>

<ol>
  <li><p>Compile your program with llvm-g++:</p>

<pre class="doc_code">
% llvm-g++ -emit-llvm x.cpp -o program.bc -c
</pre>

      <p>or:</p>

<pre class="doc_code">
% llvm-g++ a.cpp -c -emit-llvm
% llvm-g++ b.cpp -c -emit-llvm
% llvm-ld a.o b.o -o program
</pre>

   <p>This will generate program and program.bc.  The .bc
      file is the LLVM version of the program all linked together.</p></li>

  <li><p>Convert the LLVM code to C code, using the LLC tool with the C
      backend:</p>

<pre class="doc_code">
% llc -march=c program.bc -o program.c
</pre></li>

  <li><p>Finally, compile the C file:</p>

<pre class="doc_code">
% cc x.c -lstdc++
</pre></li>

</ol>

<p>Using LLVM does not eliminate the need for C++ library support.  If you use
   the llvm-g++ front-end, the generated code will depend on g++'s C++ support
   libraries in the same way that code generated from g++ would.  If you use
   another C++ front-end, the generated code will depend on whatever library
   that front-end would normally require.</p>

<p>If you are working on a platform that does not provide any C++ libraries, you
   may be able to manually compile libstdc++ to LLVM bitcode, statically link it
   into your program, then use the commands above to convert the whole result
   into C code.  Alternatively, you might compile the libraries and your
   application into two different chunks of C code and link them.</p>

<p>Note that, by default, the C back end does not support exception handling.
   If you want/need it for a certain program, you can enable it by passing
   "-enable-correct-eh-support" to the llc program.  The resultant code will use
   setjmp/longjmp to implement exception support that is relatively slow, and
   not C++-ABI-conforming on most platforms, but otherwise correct.</p>

<p>Also, there are a number of other limitations of the C backend that cause it
   to produce code that does not fully conform to the C++ ABI on most
   platforms. Some of the C++ programs in LLVM's test suite are known to fail
   when compiled with the C back end because of ABI incompatibilities with
   standard C++ libraries.</p>
</div>

<div class="question">
<p><a name="platformindependent">Can I compile C or C++ code to
   platform-independent LLVM bitcode?</a></p>
</div>

<div class="answer">
<p>No. C and C++ are inherently platform-dependent languages. The most obvious
   example of this is the preprocessor. A very common way that C code is made
   portable is by using the preprocessor to include platform-specific code. In
   practice, information about other platforms is lost after preprocessing, so
   the result is inherently dependent on the platform that the preprocessing was
   targeting.</p>

<p>Another example is <tt>sizeof</tt>. It's common for <tt>sizeof(long)</tt> to
   vary between platforms. In most C front-ends, <tt>sizeof</tt> is expanded to
   a constant immediately, thus hard-wiring a platform-specific detail.</p>

<p>Also, since many platforms define their ABIs in terms of C, and since LLVM is
   lower-level than C, front-ends currently must emit platform-specific IR in
   order to have the result conform to the platform ABI.</p>
</div>

<!-- *********************************************************************** -->
<h2>
  <a name="cfe_code">Questions about code generated by the GCC front-end</a>
</h2>

<div class="question">
<p><a name="iosinit">What is this <tt>llvm.global_ctors</tt> and
   <tt>_GLOBAL__I__tmp_webcompile...</tt> stuff that happens when I <tt>#include
   &lt;iostream&gt;</tt>?</a></p>
</div>

<div class="answer">
<p>If you <tt>#include</tt> the <tt>&lt;iostream&gt;</tt> header into a C++
   translation unit, the file will probably use
   the <tt>std::cin</tt>/<tt>std::cout</tt>/... global objects.  However, C++
   does not guarantee an order of initialization between static objects in
   different translation units, so if a static ctor/dtor in your .cpp file
   used <tt>std::cout</tt>, for example, the object would not necessarily be
   automatically initialized before your use.</p>

<p>To make <tt>std::cout</tt> and friends work correctly in these scenarios, the
   STL that we use declares a static object that gets created in every
   translation unit that includes <tt>&lt;iostream&gt;</tt>.  This object has a
   static constructor and destructor that initializes and destroys the global
   iostream objects before they could possibly be used in the file.  The code
   that you see in the .ll file corresponds to the constructor and destructor
   registration code.
</p>

<p>If you would like to make it easier to <b>understand</b> the LLVM code
   generated by the compiler in the demo page, consider using <tt>printf()</tt>
   instead of <tt>iostream</tt>s to print values.</p>
</div>

<!--=========================================================================-->

<div class="question">
<p><a name="codedce">Where did all of my code go??</a></p>
</div>

<div class="answer">
<p>If you are using the LLVM demo page, you may often wonder what happened to
   all of the code that you typed in.  Remember that the demo script is running
   the code through the LLVM optimizers, so if your code doesn't actually do
   anything useful, it might all be deleted.</p>

<p>To prevent this, make sure that the code is actually needed.  For example, if
   you are computing some expression, return the value from the function instead
   of leaving it in a local variable.  If you really want to constrain the
   optimizer, you can read from and assign to <tt>volatile</tt> global
   variables.</p>
</div>

<!--=========================================================================-->

<div class="question">
<p><a name="undef">What is this "<tt>undef</tt>" thing that shows up in my
   code?</a></p>
</div>

<div class="answer">
<p><a href="LangRef.html#undef"><tt>undef</tt></a> is the LLVM way of
   representing a value that is not defined.  You can get these if you do not
   initialize a variable before you use it.  For example, the C function:</p>

<pre class="doc_code">
int X() { int i; return i; }
</pre>

<p>Is compiled to "<tt>ret i32 undef</tt>" because "<tt>i</tt>" never has a
   value specified for it.</p>
</div>

<!--=========================================================================-->

<div class="question">
<p><a name="callconvwrong">Why does instcombine + simplifycfg turn
   a call to a function with a mismatched calling convention into "unreachable"?
   Why not make the verifier reject it?</a></p>
</div>

<div class="answer">
<p>This is a common problem run into by authors of front-ends that are using
custom calling conventions: you need to make sure to set the right calling
convention on both the function and on each call to the function.  For example,
this code:</p>

<pre class="doc_code">
define fastcc void @foo() {
        ret void
}
define void @bar() {
        call void @foo()
        ret void
}
</pre>

<p>Is optimized to:</p>

<pre class="doc_code">
define fastcc void @foo() {
	ret void
}
define void @bar() {
	unreachable
}
</pre>

<p>... with "opt -instcombine -simplifycfg".  This often bites people because
"all their code disappears".  Setting the calling convention on the caller and
callee is required for indirect calls to work, so people often ask why not make
the verifier reject this sort of thing.</p>

<p>The answer is that this code has undefined behavior, but it is not illegal.
If we made it illegal, then every transformation that could potentially create
this would have to ensure that it doesn't, and there is valid code that can
create this sort of construct (in dead code).  The sorts of things that can
cause this to happen are fairly contrived, but we still need to accept them.
Here's an example:</p>

<pre class="doc_code">
define fastcc void @foo() {
        ret void
}
define internal void @bar(void()* %FP, i1 %cond) {
        br i1 %cond, label %T, label %F
T:  
        call void %FP()
        ret void
F:
        call fastcc void %FP()
        ret void
}
define void @test() {
        %X = or i1 false, false
        call void @bar(void()* @foo, i1 %X)
        ret void
} 
</pre>

<p>In this example, "test" always passes @foo/false into bar, which ensures that
   it is dynamically called with the right calling conv (thus, the code is
   perfectly well defined).  If you run this through the inliner, you get this
   (the explicit "or" is there so that the inliner doesn't dead code eliminate
   a bunch of stuff):
</p>

<pre class="doc_code">
define fastcc void @foo() {
	ret void
}
define void @test() {
	%X = or i1 false, false
	br i1 %X, label %T.i, label %F.i
T.i:
	call void @foo()
	br label %bar.exit
F.i:
	call fastcc void @foo()
	br label %bar.exit
bar.exit:
	ret void
}
</pre>

<p>Here you can see that the inlining pass made an undefined call to @foo with
  the wrong calling convention.  We really don't want to make the inliner have
  to know about this sort of thing, so it needs to be valid code.  In this case,
  dead code elimination can trivially remove the undefined code.  However, if %X
  was an input argument to @test, the inliner would produce this:
</p>

<pre class="doc_code">
define fastcc void @foo() {
	ret void
}

define void @test(i1 %X) {
	br i1 %X, label %T.i, label %F.i
T.i:
	call void @foo()
	br label %bar.exit
F.i:
	call fastcc void @foo()
	br label %bar.exit
bar.exit:
	ret void
}
</pre>

<p>The interesting thing about this is that %X <em>must</em> be false for the
code to be well-defined, but no amount of dead code elimination will be able to
delete the broken call as unreachable.  However, since instcombine/simplifycfg
turns the undefined call into unreachable, we end up with a branch on a
condition that goes to unreachable: a branch to unreachable can never happen, so
"-inline -instcombine -simplifycfg" is able to produce:</p>

<pre class="doc_code">
define fastcc void @foo() {
	ret void
}
define void @test(i1 %X) {
F.i:
	call fastcc void @foo()
	ret void
}
</pre>

</div>

<!-- *********************************************************************** -->

<hr>
<address>
  <a href="http://jigsaw.w3.org/css-validator/check/referer"><img
  src="http://jigsaw.w3.org/css-validator/images/vcss-blue" alt="Valid CSS"></a>
  <a href="http://validator.w3.org/check/referer"><img
  src="http://www.w3.org/Icons/valid-html401-blue" alt="Valid HTML 4.01"></a>

  <a href="http://llvm.org/">LLVM Compiler Infrastructure</a><br>
  Last modified: $Date: 2011-09-19 20:42:28 -0400 (Mon, 19 Sep 2011) $
</address>

</body>
</html>
