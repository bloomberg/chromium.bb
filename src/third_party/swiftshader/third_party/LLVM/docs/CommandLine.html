<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
                      "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>CommandLine 2.0 Library Manual</title>
  <link rel="stylesheet" href="llvm.css" type="text/css">
</head>
<body>

<h1>
  CommandLine 2.0 Library Manual
</h1>

<ol>
  <li><a href="#introduction">Introduction</a></li>

  <li><a href="#quickstart">Quick Start Guide</a>
    <ol>
      <li><a href="#bool">Boolean Arguments</a></li>
      <li><a href="#alias">Argument Aliases</a></li>
      <li><a href="#onealternative">Selecting an alternative from a
                                    set of possibilities</a></li>
      <li><a href="#namedalternatives">Named alternatives</a></li>
      <li><a href="#list">Parsing a list of options</a></li>
      <li><a href="#bits">Collecting options as a set of flags</a></li>
      <li><a href="#description">Adding freeform text to help output</a></li>
    </ol></li>

  <li><a href="#referenceguide">Reference Guide</a>
    <ol>
      <li><a href="#positional">Positional Arguments</a>
        <ul>
        <li><a href="#--">Specifying positional options with hyphens</a></li>
        <li><a href="#getPosition">Determining absolute position with
          getPosition</a></li>
        <li><a href="#cl::ConsumeAfter">The <tt>cl::ConsumeAfter</tt>
             modifier</a></li>
        </ul></li>

      <li><a href="#storage">Internal vs External Storage</a></li>

      <li><a href="#attributes">Option Attributes</a></li>

      <li><a href="#modifiers">Option Modifiers</a>
        <ul>
        <li><a href="#hiding">Hiding an option from <tt>-help</tt>
            output</a></li>
        <li><a href="#numoccurrences">Controlling the number of occurrences
                                     required and allowed</a></li>
        <li><a href="#valrequired">Controlling whether or not a value must be
                                   specified</a></li>
        <li><a href="#formatting">Controlling other formatting options</a></li>
        <li><a href="#misc">Miscellaneous option modifiers</a></li>
        <li><a href="#response">Response files</a></li>
        </ul></li>

      <li><a href="#toplevel">Top-Level Classes and Functions</a>
        <ul>
        <li><a href="#cl::ParseCommandLineOptions">The
            <tt>cl::ParseCommandLineOptions</tt> function</a></li>
        <li><a href="#cl::ParseEnvironmentOptions">The
            <tt>cl::ParseEnvironmentOptions</tt> function</a></li>
        <li><a href="#cl::SetVersionPrinter">The <tt>cl::SetVersionPrinter</tt>
          function</a></li>
        <li><a href="#cl::opt">The <tt>cl::opt</tt> class</a></li>
        <li><a href="#cl::list">The <tt>cl::list</tt> class</a></li>
        <li><a href="#cl::bits">The <tt>cl::bits</tt> class</a></li>
        <li><a href="#cl::alias">The <tt>cl::alias</tt> class</a></li>
        <li><a href="#cl::extrahelp">The <tt>cl::extrahelp</tt> class</a></li>
        </ul></li>

      <li><a href="#builtinparsers">Builtin parsers</a>
        <ul>
        <li><a href="#genericparser">The Generic <tt>parser&lt;t&gt;</tt>
            parser</a></li>
        <li><a href="#boolparser">The <tt>parser&lt;bool&gt;</tt>
            specialization</a></li>
        <li><a href="#boolOrDefaultparser">The <tt>parser&lt;boolOrDefault&gt;</tt>
            specialization</a></li>
        <li><a href="#stringparser">The <tt>parser&lt;string&gt;</tt>
            specialization</a></li>
        <li><a href="#intparser">The <tt>parser&lt;int&gt;</tt>
            specialization</a></li>
        <li><a href="#doubleparser">The <tt>parser&lt;double&gt;</tt> and
            <tt>parser&lt;float&gt;</tt> specializations</a></li>
        </ul></li>
    </ol></li>
  <li><a href="#extensionguide">Extension Guide</a>
    <ol>
      <li><a href="#customparser">Writing a custom parser</a></li>
      <li><a href="#explotingexternal">Exploiting external storage</a></li>
      <li><a href="#dynamicopts">Dynamically adding command line
          options</a></li>
    </ol></li>
</ol>

<div class="doc_author">
  <p>Written by <a href="mailto:sabre@nondot.org">Chris Lattner</a></p>
</div>

<!-- *********************************************************************** -->
<h2>
  <a name="introduction">Introduction</a>
</h2>
<!-- *********************************************************************** -->

<div>

<p>This document describes the CommandLine argument processing library.  It will
show you how to use it, and what it can do.  The CommandLine library uses a
declarative approach to specifying the command line options that your program
takes.  By default, these options declarations implicitly hold the value parsed
for the option declared (of course this <a href="#storage">can be
changed</a>).</p>

<p>Although there are a <b>lot</b> of command line argument parsing libraries
out there in many different languages, none of them fit well with what I needed.
By looking at the features and problems of other libraries, I designed the
CommandLine library to have the following features:</p>

<ol>
<li>Speed: The CommandLine library is very quick and uses little resources.  The
parsing time of the library is directly proportional to the number of arguments
parsed, not the the number of options recognized.  Additionally, command line
argument values are captured transparently into user defined global variables,
which can be accessed like any other variable (and with the same
performance).</li>

<li>Type Safe: As a user of CommandLine, you don't have to worry about
remembering the type of arguments that you want (is it an int?  a string? a
bool? an enum?) and keep casting it around.  Not only does this help prevent
error prone constructs, it also leads to dramatically cleaner source code.</li>

<li>No subclasses required: To use CommandLine, you instantiate variables that
correspond to the arguments that you would like to capture, you don't subclass a
parser.  This means that you don't have to write <b>any</b> boilerplate
code.</li>

<li>Globally accessible: Libraries can specify command line arguments that are
automatically enabled in any tool that links to the library.  This is possible
because the application doesn't have to keep a list of arguments to pass to
the parser.  This also makes supporting <a href="#dynamicopts">dynamically
loaded options</a> trivial.</li>

<li>Cleaner: CommandLine supports enum and other types directly, meaning that
there is less error and more security built into the library.  You don't have to
worry about whether your integral command line argument accidentally got
assigned a value that is not valid for your enum type.</li>

<li>Powerful: The CommandLine library supports many different types of
arguments, from simple <a href="#boolparser">boolean flags</a> to <a
href="#cl::opt">scalars arguments</a> (<a href="#stringparser">strings</a>, <a
href="#intparser">integers</a>, <a href="#genericparser">enums</a>, <a
href="#doubleparser">doubles</a>), to <a href="#cl::list">lists of
arguments</a>.  This is possible because CommandLine is...</li>

<li>Extensible: It is very simple to add a new argument type to CommandLine.
Simply specify the parser that you want to use with the command line option when
you declare it.  <a href="#customparser">Custom parsers</a> are no problem.</li>

<li>Labor Saving: The CommandLine library cuts down on the amount of grunt work
that you, the user, have to do.  For example, it automatically provides a
<tt>-help</tt> option that shows the available command line options for your
tool.  Additionally, it does most of the basic correctness checking for
you.</li>

<li>Capable: The CommandLine library can handle lots of different forms of
options often found in real programs.  For example, <a
href="#positional">positional</a> arguments, <tt>ls</tt> style <a
href="#cl::Grouping">grouping</a> options (to allow processing '<tt>ls
-lad</tt>' naturally), <tt>ld</tt> style <a href="#cl::Prefix">prefix</a>
options (to parse '<tt>-lmalloc -L/usr/lib</tt>'), and <a
href="#cl::ConsumeAfter">interpreter style options</a>.</li>

</ol>

<p>This document will hopefully let you jump in and start using CommandLine in
your utility quickly and painlessly.  Additionally it should be a simple
reference manual to figure out how stuff works.  If it is failing in some area
(or you want an extension to the library), nag the author, <a
href="mailto:sabre@nondot.org">Chris Lattner</a>.</p>

</div>

<!-- *********************************************************************** -->
<h2>
  <a name="quickstart">Quick Start Guide</a>
</h2>
<!-- *********************************************************************** -->

<div>

<p>This section of the manual runs through a simple CommandLine'ification of a
basic compiler tool.  This is intended to show you how to jump into using the
CommandLine library in your own program, and show you some of the cool things it
can do.</p>

<p>To start out, you need to include the CommandLine header file into your
program:</p>

<div class="doc_code"><pre>
  #include "llvm/Support/CommandLine.h"
</pre></div>

<p>Additionally, you need to add this as the first line of your main
program:</p>

<div class="doc_code"><pre>
int main(int argc, char **argv) {
  <a href="#cl::ParseCommandLineOptions">cl::ParseCommandLineOptions</a>(argc, argv);
  ...
}
</pre></div>

<p>... which actually parses the arguments and fills in the variable
declarations.</p>

<p>Now that you are ready to support command line arguments, we need to tell the
system which ones we want, and what type of arguments they are.  The CommandLine
library uses a declarative syntax to model command line arguments with the
global variable declarations that capture the parsed values.  This means that
for every command line option that you would like to support, there should be a
global variable declaration to capture the result.  For example, in a compiler,
we would like to support the Unix-standard '<tt>-o &lt;filename&gt;</tt>' option
to specify where to put the output.  With the CommandLine library, this is
represented like this:</p>

<a name="value_desc_example"></a>
<div class="doc_code"><pre>
<a href="#cl::opt">cl::opt</a>&lt;string&gt; OutputFilename("<i>o</i>", <a href="#cl::desc">cl::desc</a>("<i>Specify output filename</i>"), <a href="#cl::value_desc">cl::value_desc</a>("<i>filename</i>"));
</pre></div>

<p>This declares a global variable &quot;<tt>OutputFilename</tt>&quot; that is used to
capture the result of the &quot;<tt>o</tt>&quot; argument (first parameter).  We specify
that this is a simple scalar option by using the &quot;<tt><a
href="#cl::opt">cl::opt</a></tt>&quot; template (as opposed to the <a
href="#list">&quot;<tt>cl::list</tt> template</a>), and tell the CommandLine library
that the data type that we are parsing is a string.</p>

<p>The second and third parameters (which are optional) are used to specify what
to output for the "<tt>-help</tt>" option.  In this case, we get a line that
looks like this:</p>

<div class="doc_code"><pre>
USAGE: compiler [options]

OPTIONS:
  -help             - display available options (-help-hidden for more)
  <b>-o &lt;filename&gt;     - Specify output filename</b>
</pre></div>

<p>Because we specified that the command line option should parse using the
<tt>string</tt> data type, the variable declared is automatically usable as a
real string in all contexts that a normal C++ string object may be used.  For
example:</p>

<div class="doc_code"><pre>
  ...
  std::ofstream Output(OutputFilename.c_str());
  if (Output.good()) ...
  ...
</pre></div>

<p>There are many different options that you can use to customize the command
line option handling library, but the above example shows the general interface
to these options.  The options can be specified in any order, and are specified
with helper functions like <a href="#cl::desc"><tt>cl::desc(...)</tt></a>, so
there are no positional dependencies to remember.  The available options are
discussed in detail in the <a href="#referenceguide">Reference Guide</a>.</p>

<p>Continuing the example, we would like to have our compiler take an input
filename as well as an output filename, but we do not want the input filename to
be specified with a hyphen (ie, not <tt>-filename.c</tt>).  To support this
style of argument, the CommandLine library allows for <a
href="#positional">positional</a> arguments to be specified for the program.
These positional arguments are filled with command line parameters that are not
in option form.  We use this feature like this:</p>

<div class="doc_code"><pre>
<a href="#cl::opt">cl::opt</a>&lt;string&gt; InputFilename(<a href="#cl::Positional">cl::Positional</a>, <a href="#cl::desc">cl::desc</a>("<i>&lt;input file&gt;</i>"), <a href="#cl::init">cl::init</a>("<i>-</i>"));
</pre></div>

<p>This declaration indicates that the first positional argument should be
treated as the input filename.  Here we use the <tt><a
href="#cl::init">cl::init</a></tt> option to specify an initial value for the
command line option, which is used if the option is not specified (if you do not
specify a <tt><a href="#cl::init">cl::init</a></tt> modifier for an option, then
the default constructor for the data type is used to initialize the value).
Command line options default to being optional, so if we would like to require
that the user always specify an input filename, we would add the <tt><a
href="#cl::Required">cl::Required</a></tt> flag, and we could eliminate the
<tt><a href="#cl::init">cl::init</a></tt> modifier, like this:</p>

<div class="doc_code"><pre>
<a href="#cl::opt">cl::opt</a>&lt;string&gt; InputFilename(<a href="#cl::Positional">cl::Positional</a>, <a href="#cl::desc">cl::desc</a>("<i>&lt;input file&gt;</i>"), <b><a href="#cl::Required">cl::Required</a></b>);
</pre></div>

<p>Again, the CommandLine library does not require the options to be specified
in any particular order, so the above declaration is equivalent to:</p>

<div class="doc_code"><pre>
<a href="#cl::opt">cl::opt</a>&lt;string&gt; InputFilename(<a href="#cl::Positional">cl::Positional</a>, <a href="#cl::Required">cl::Required</a>, <a href="#cl::desc">cl::desc</a>("<i>&lt;input file&gt;</i>"));
</pre></div>

<p>By simply adding the <tt><a href="#cl::Required">cl::Required</a></tt> flag,
the CommandLine library will automatically issue an error if the argument is not
specified, which shifts all of the command line option verification code out of
your application into the library.  This is just one example of how using flags
can alter the default behaviour of the library, on a per-option basis.  By
adding one of the declarations above, the <tt>-help</tt> option synopsis is now
extended to:</p>

<div class="doc_code"><pre>
USAGE: compiler [options] <b>&lt;input file&gt;</b>

OPTIONS:
  -help             - display available options (-help-hidden for more)
  -o &lt;filename&gt;     - Specify output filename
</pre></div>

<p>... indicating that an input filename is expected.</p>

<!-- ======================================================================= -->
<h3>
  <a name="bool">Boolean Arguments</a>
</h3>

<div>

<p>In addition to input and output filenames, we would like the compiler example
to support three boolean flags: "<tt>-f</tt>" to force writing binary output to
a terminal, "<tt>--quiet</tt>" to enable quiet mode, and "<tt>-q</tt>" for
backwards compatibility with some of our users.  We can support these by
declaring options of boolean type like this:</p>

<div class="doc_code"><pre>
<a href="#cl::opt">cl::opt</a>&lt;bool&gt; Force ("<i>f</i>", <a href="#cl::desc">cl::desc</a>("<i>Enable binary output on terminals</i>"));
<a href="#cl::opt">cl::opt</a>&lt;bool&gt; Quiet ("<i>quiet</i>", <a href="#cl::desc">cl::desc</a>("<i>Don't print informational messages</i>"));
<a href="#cl::opt">cl::opt</a>&lt;bool&gt; Quiet2("<i>q</i>", <a href="#cl::desc">cl::desc</a>("<i>Don't print informational messages</i>"), <a href="#cl::Hidden">cl::Hidden</a>);
</pre></div>

<p>This does what you would expect: it declares three boolean variables
("<tt>Force</tt>", "<tt>Quiet</tt>", and "<tt>Quiet2</tt>") to recognize these
options.  Note that the "<tt>-q</tt>" option is specified with the "<a
href="#cl::Hidden"><tt>cl::Hidden</tt></a>" flag.  This modifier prevents it
from being shown by the standard "<tt>-help</tt>" output (note that it is still
shown in the "<tt>-help-hidden</tt>" output).</p>

<p>The CommandLine library uses a <a href="#builtinparsers">different parser</a>
for different data types.  For example, in the string case, the argument passed
to the option is copied literally into the content of the string variable... we
obviously cannot do that in the boolean case, however, so we must use a smarter
parser.  In the case of the boolean parser, it allows no options (in which case
it assigns the value of true to the variable), or it allows the values
"<tt>true</tt>" or "<tt>false</tt>" to be specified, allowing any of the
following inputs:</p>

<div class="doc_code"><pre>
 compiler -f          # No value, 'Force' == true
 compiler -f=true     # Value specified, 'Force' == true
 compiler -f=TRUE     # Value specified, 'Force' == true
 compiler -f=FALSE    # Value specified, 'Force' == false
</pre></div>

<p>... you get the idea.  The <a href="#boolparser">bool parser</a> just turns
the string values into boolean values, and rejects things like '<tt>compiler
-f=foo</tt>'.  Similarly, the <a href="#doubleparser">float</a>, <a
href="#doubleparser">double</a>, and <a href="#intparser">int</a> parsers work
like you would expect, using the '<tt>strtol</tt>' and '<tt>strtod</tt>' C
library calls to parse the string value into the specified data type.</p>

<p>With the declarations above, "<tt>compiler -help</tt>" emits this:</p>

<div class="doc_code"><pre>
USAGE: compiler [options] &lt;input file&gt;

OPTIONS:
  <b>-f     - Enable binary output on terminals</b>
  -o     - Override output filename
  <b>-quiet - Don't print informational messages</b>
  -help  - display available options (-help-hidden for more)
</pre></div>

<p>and "<tt>compiler -help-hidden</tt>" prints this:</p>

<div class="doc_code"><pre>
USAGE: compiler [options] &lt;input file&gt;

OPTIONS:
  -f     - Enable binary output on terminals
  -o     - Override output filename
  <b>-q     - Don't print informational messages</b>
  -quiet - Don't print informational messages
  -help  - display available options (-help-hidden for more)
</pre></div>

<p>This brief example has shown you how to use the '<tt><a
href="#cl::opt">cl::opt</a></tt>' class to parse simple scalar command line
arguments.  In addition to simple scalar arguments, the CommandLine library also
provides primitives to support CommandLine option <a href="#alias">aliases</a>,
and <a href="#list">lists</a> of options.</p>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="alias">Argument Aliases</a>
</h3>

<div>

<p>So far, the example works well, except for the fact that we need to check the
quiet condition like this now:</p>

<div class="doc_code"><pre>
...
  if (!Quiet &amp;&amp; !Quiet2) printInformationalMessage(...);
...
</pre></div>

<p>... which is a real pain!  Instead of defining two values for the same
condition, we can use the "<tt><a href="#cl::alias">cl::alias</a></tt>" class to make the "<tt>-q</tt>"
option an <b>alias</b> for the "<tt>-quiet</tt>" option, instead of providing
a value itself:</p>

<div class="doc_code"><pre>
<a href="#cl::opt">cl::opt</a>&lt;bool&gt; Force ("<i>f</i>", <a href="#cl::desc">cl::desc</a>("<i>Overwrite output files</i>"));
<a href="#cl::opt">cl::opt</a>&lt;bool&gt; Quiet ("<i>quiet</i>", <a href="#cl::desc">cl::desc</a>("<i>Don't print informational messages</i>"));
<a href="#cl::alias">cl::alias</a>     QuietA("<i>q</i>", <a href="#cl::desc">cl::desc</a>("<i>Alias for -quiet</i>"), <a href="#cl::aliasopt">cl::aliasopt</a>(Quiet));
</pre></div>

<p>The third line (which is the only one we modified from above) defines a
"<tt>-q</tt>" alias that updates the "<tt>Quiet</tt>" variable (as specified by
the <tt><a href="#cl::aliasopt">cl::aliasopt</a></tt> modifier) whenever it is
specified.  Because aliases do not hold state, the only thing the program has to
query is the <tt>Quiet</tt> variable now.  Another nice feature of aliases is
that they automatically hide themselves from the <tt>-help</tt> output
(although, again, they are still visible in the <tt>-help-hidden
output</tt>).</p>

<p>Now the application code can simply use:</p>

<div class="doc_code"><pre>
...
  if (!Quiet) printInformationalMessage(...);
...
</pre></div>

<p>... which is much nicer!  The "<tt><a href="#cl::alias">cl::alias</a></tt>"
can be used to specify an alternative name for any variable type, and has many
uses.</p>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="onealternative">Selecting an alternative from a set of
  possibilities</a>
</h3>

<div>

<p>So far we have seen how the CommandLine library handles builtin types like
<tt>std::string</tt>, <tt>bool</tt> and <tt>int</tt>, but how does it handle
things it doesn't know about, like enums or '<tt>int*</tt>'s?</p>

<p>The answer is that it uses a table-driven generic parser (unless you specify
your own parser, as described in the <a href="#extensionguide">Extension
Guide</a>).  This parser maps literal strings to whatever type is required, and
requires you to tell it what this mapping should be.</p>

<p>Let's say that we would like to add four optimization levels to our
optimizer, using the standard flags "<tt>-g</tt>", "<tt>-O0</tt>",
"<tt>-O1</tt>", and "<tt>-O2</tt>".  We could easily implement this with boolean
options like above, but there are several problems with this strategy:</p>

<ol>
<li>A user could specify more than one of the options at a time, for example,
"<tt>compiler -O3 -O2</tt>".  The CommandLine library would not be able to
catch this erroneous input for us.</li>

<li>We would have to test 4 different variables to see which ones are set.</li>

<li>This doesn't map to the numeric levels that we want... so we cannot easily
see if some level &gt;= "<tt>-O1</tt>" is enabled.</li>

</ol>

<p>To cope with these problems, we can use an enum value, and have the
CommandLine library fill it in with the appropriate level directly, which is
used like this:</p>

<div class="doc_code"><pre>
enum OptLevel {
  g, O1, O2, O3
};

<a href="#cl::opt">cl::opt</a>&lt;OptLevel&gt; OptimizationLevel(<a href="#cl::desc">cl::desc</a>("<i>Choose optimization level:</i>"),
  <a href="#cl::values">cl::values</a>(
    clEnumVal(g , "<i>No optimizations, enable debugging</i>"),
    clEnumVal(O1, "<i>Enable trivial optimizations</i>"),
    clEnumVal(O2, "<i>Enable default optimizations</i>"),
    clEnumVal(O3, "<i>Enable expensive optimizations</i>"),
   clEnumValEnd));

...
  if (OptimizationLevel &gt;= O2) doPartialRedundancyElimination(...);
...
</pre></div>

<p>This declaration defines a variable "<tt>OptimizationLevel</tt>" of the
"<tt>OptLevel</tt>" enum type.  This variable can be assigned any of the values
that are listed in the declaration (Note that the declaration list must be
terminated with the "<tt>clEnumValEnd</tt>" argument!).  The CommandLine
library enforces
that the user can only specify one of the options, and it ensure that only valid
enum values can be specified.  The "<tt>clEnumVal</tt>" macros ensure that the
command line arguments matched the enum values.  With this option added, our
help output now is:</p>

<div class="doc_code"><pre>
USAGE: compiler [options] &lt;input file&gt;

OPTIONS:
  <b>Choose optimization level:
    -g          - No optimizations, enable debugging
    -O1         - Enable trivial optimizations
    -O2         - Enable default optimizations
    -O3         - Enable expensive optimizations</b>
  -f            - Enable binary output on terminals
  -help         - display available options (-help-hidden for more)
  -o &lt;filename&gt; - Specify output filename
  -quiet        - Don't print informational messages
</pre></div>

<p>In this case, it is sort of awkward that flag names correspond directly to
enum names, because we probably don't want a enum definition named "<tt>g</tt>"
in our program.  Because of this, we can alternatively write this example like
this:</p>

<div class="doc_code"><pre>
enum OptLevel {
  Debug, O1, O2, O3
};

<a href="#cl::opt">cl::opt</a>&lt;OptLevel&gt; OptimizationLevel(<a href="#cl::desc">cl::desc</a>("<i>Choose optimization level:</i>"),
  <a href="#cl::values">cl::values</a>(
   clEnumValN(Debug, "g", "<i>No optimizations, enable debugging</i>"),
    clEnumVal(O1        , "<i>Enable trivial optimizations</i>"),
    clEnumVal(O2        , "<i>Enable default optimizations</i>"),
    clEnumVal(O3        , "<i>Enable expensive optimizations</i>"),
   clEnumValEnd));

...
  if (OptimizationLevel == Debug) outputDebugInfo(...);
...
</pre></div>

<p>By using the "<tt>clEnumValN</tt>" macro instead of "<tt>clEnumVal</tt>", we
can directly specify the name that the flag should get.  In general a direct
mapping is nice, but sometimes you can't or don't want to preserve the mapping,
which is when you would use it.</p>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="namedalternatives">Named Alternatives</a>
</h3>

<div>

<p>Another useful argument form is a named alternative style.  We shall use this
style in our compiler to specify different debug levels that can be used.
Instead of each debug level being its own switch, we want to support the
following options, of which only one can be specified at a time:
"<tt>--debug-level=none</tt>", "<tt>--debug-level=quick</tt>",
"<tt>--debug-level=detailed</tt>".  To do this, we use the exact same format as
our optimization level flags, but we also specify an option name.  For this
case, the code looks like this:</p>

<div class="doc_code"><pre>
enum DebugLev {
  nodebuginfo, quick, detailed
};

// Enable Debug Options to be specified on the command line
<a href="#cl::opt">cl::opt</a>&lt;DebugLev&gt; DebugLevel("<i>debug_level</i>", <a href="#cl::desc">cl::desc</a>("<i>Set the debugging level:</i>"),
  <a href="#cl::values">cl::values</a>(
    clEnumValN(nodebuginfo, "none", "<i>disable debug information</i>"),
     clEnumVal(quick,               "<i>enable quick debug information</i>"),
     clEnumVal(detailed,            "<i>enable detailed debug information</i>"),
    clEnumValEnd));
</pre></div>

<p>This definition defines an enumerated command line variable of type "<tt>enum
DebugLev</tt>", which works exactly the same way as before.  The difference here
is just the interface exposed to the user of your program and the help output by
the "<tt>-help</tt>" option:</p>

<div class="doc_code"><pre>
USAGE: compiler [options] &lt;input file&gt;

OPTIONS:
  Choose optimization level:
    -g          - No optimizations, enable debugging
    -O1         - Enable trivial optimizations
    -O2         - Enable default optimizations
    -O3         - Enable expensive optimizations
  <b>-debug_level  - Set the debugging level:
    =none       - disable debug information
    =quick      - enable quick debug information
    =detailed   - enable detailed debug information</b>
  -f            - Enable binary output on terminals
  -help         - display available options (-help-hidden for more)
  -o &lt;filename&gt; - Specify output filename
  -quiet        - Don't print informational messages
</pre></div>

<p>Again, the only structural difference between the debug level declaration and
the optimization level declaration is that the debug level declaration includes
an option name (<tt>"debug_level"</tt>), which automatically changes how the
library processes the argument.  The CommandLine library supports both forms so
that you can choose the form most appropriate for your application.</p>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="list">Parsing a list of options</a>
</h3>

<div>

<p>Now that we have the standard run-of-the-mill argument types out of the way,
lets get a little wild and crazy.  Lets say that we want our optimizer to accept
a <b>list</b> of optimizations to perform, allowing duplicates.  For example, we
might want to run: "<tt>compiler -dce -constprop -inline -dce -strip</tt>".  In
this case, the order of the arguments and the number of appearances is very
important.  This is what the "<tt><a href="#cl::list">cl::list</a></tt>"
template is for.  First, start by defining an enum of the optimizations that you
would like to perform:</p>

<div class="doc_code"><pre>
enum Opts {
  // 'inline' is a C++ keyword, so name it 'inlining'
  dce, constprop, inlining, strip
};
</pre></div>

<p>Then define your "<tt><a href="#cl::list">cl::list</a></tt>" variable:</p>

<div class="doc_code"><pre>
<a href="#cl::list">cl::list</a>&lt;Opts&gt; OptimizationList(<a href="#cl::desc">cl::desc</a>("<i>Available Optimizations:</i>"),
  <a href="#cl::values">cl::values</a>(
    clEnumVal(dce               , "<i>Dead Code Elimination</i>"),
    clEnumVal(constprop         , "<i>Constant Propagation</i>"),
   clEnumValN(inlining, "<i>inline</i>", "<i>Procedure Integration</i>"),
    clEnumVal(strip             , "<i>Strip Symbols</i>"),
  clEnumValEnd));
</pre></div>

<p>This defines a variable that is conceptually of the type
"<tt>std::vector&lt;enum Opts&gt;</tt>".  Thus, you can access it with standard
vector methods:</p>

<div class="doc_code"><pre>
  for (unsigned i = 0; i != OptimizationList.size(); ++i)
    switch (OptimizationList[i])
       ...
</pre></div>

<p>... to iterate through the list of options specified.</p>

<p>Note that the "<tt><a href="#cl::list">cl::list</a></tt>" template is
completely general and may be used with any data types or other arguments that
you can use with the "<tt><a href="#cl::opt">cl::opt</a></tt>" template.  One
especially useful way to use a list is to capture all of the positional
arguments together if there may be more than one specified.  In the case of a
linker, for example, the linker takes several '<tt>.o</tt>' files, and needs to
capture them into a list.  This is naturally specified as:</p>

<div class="doc_code"><pre>
...
<a href="#cl::list">cl::list</a>&lt;std::string&gt; InputFilenames(<a href="#cl::Positional">cl::Positional</a>, <a href="#cl::desc">cl::desc</a>("&lt;Input files&gt;"), <a href="#cl::OneOrMore">cl::OneOrMore</a>);
...
</pre></div>

<p>This variable works just like a "<tt>vector&lt;string&gt;</tt>" object.  As
such, accessing the list is simple, just like above.  In this example, we used
the <tt><a href="#cl::OneOrMore">cl::OneOrMore</a></tt> modifier to inform the
CommandLine library that it is an error if the user does not specify any
<tt>.o</tt> files on our command line.  Again, this just reduces the amount of
checking we have to do.</p>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="bits">Collecting options as a set of flags</a>
</h3>

<div>

<p>Instead of collecting sets of options in a list, it is also possible to
gather information for enum values in a <b>bit vector</b>.  The representation used by
the <a href="#bits"><tt>cl::bits</tt></a> class is an <tt>unsigned</tt>
integer.  An enum value is represented by a 0/1 in the enum's ordinal value bit
position. 1 indicating that the enum was specified, 0 otherwise.  As each
specified value is parsed, the resulting enum's bit is set in the option's bit
vector:</p>

<div class="doc_code"><pre>
  <i>bits</i> |= 1 << (unsigned)<i>enum</i>;
</pre></div>

<p>Options that are specified multiple times are redundant.  Any instances after
the first are discarded.</p>

<p>Reworking the above list example, we could replace <a href="#list">
<tt>cl::list</tt></a> with <a href="#bits"><tt>cl::bits</tt></a>:</p>

<div class="doc_code"><pre>
<a href="#cl::bits">cl::bits</a>&lt;Opts&gt; OptimizationBits(<a href="#cl::desc">cl::desc</a>("<i>Available Optimizations:</i>"),
  <a href="#cl::values">cl::values</a>(
    clEnumVal(dce               , "<i>Dead Code Elimination</i>"),
    clEnumVal(constprop         , "<i>Constant Propagation</i>"),
   clEnumValN(inlining, "<i>inline</i>", "<i>Procedure Integration</i>"),
    clEnumVal(strip             , "<i>Strip Symbols</i>"),
  clEnumValEnd));
</pre></div>

<p>To test to see if <tt>constprop</tt> was specified, we can use the
<tt>cl:bits::isSet</tt> function:</p>

<div class="doc_code"><pre>
  if (OptimizationBits.isSet(constprop)) {
    ...
  }
</pre></div>

<p>It's also possible to get the raw bit vector using the
<tt>cl::bits::getBits</tt> function:</p>

<div class="doc_code"><pre>
  unsigned bits = OptimizationBits.getBits();
</pre></div>

<p>Finally, if external storage is used, then the location specified must be of
<b>type</b> <tt>unsigned</tt>. In all other ways a <a
href="#bits"><tt>cl::bits</tt></a> option is equivalent to a <a
href="#list"> <tt>cl::list</tt></a> option.</p>

</div>


<!-- ======================================================================= -->
<h3>
  <a name="description">Adding freeform text to help output</a>
</h3>

<div>

<p>As our program grows and becomes more mature, we may decide to put summary
information about what it does into the help output.  The help output is styled
to look similar to a Unix <tt>man</tt> page, providing concise information about
a program.  Unix <tt>man</tt> pages, however often have a description about what
the program does.  To add this to your CommandLine program, simply pass a third
argument to the <a
href="#cl::ParseCommandLineOptions"><tt>cl::ParseCommandLineOptions</tt></a>
call in main.  This additional argument is then printed as the overview
information for your program, allowing you to include any additional information
that you want.  For example:</p>

<div class="doc_code"><pre>
int main(int argc, char **argv) {
  <a href="#cl::ParseCommandLineOptions">cl::ParseCommandLineOptions</a>(argc, argv, " CommandLine compiler example\n\n"
                              "  This program blah blah blah...\n");
  ...
}
</pre></div>

<p>would yield the help output:</p>

<div class="doc_code"><pre>
<b>OVERVIEW: CommandLine compiler example

  This program blah blah blah...</b>

USAGE: compiler [options] &lt;input file&gt;

OPTIONS:
  ...
  -help             - display available options (-help-hidden for more)
  -o &lt;filename&gt;     - Specify output filename
</pre></div>

</div>

</div>

<!-- *********************************************************************** -->
<h2>
  <a name="referenceguide">Reference Guide</a>
</h2>
<!-- *********************************************************************** -->

<div>

<p>Now that you know the basics of how to use the CommandLine library, this
section will give you the detailed information you need to tune how command line
options work, as well as information on more "advanced" command line option
processing capabilities.</p>

<!-- ======================================================================= -->
<h3>
  <a name="positional">Positional Arguments</a>
</h3>

<div>

<p>Positional arguments are those arguments that are not named, and are not
specified with a hyphen.  Positional arguments should be used when an option is
specified by its position alone.  For example, the standard Unix <tt>grep</tt>
tool takes a regular expression argument, and an optional filename to search
through (which defaults to standard input if a filename is not specified).
Using the CommandLine library, this would be specified as:</p>

<div class="doc_code"><pre>
<a href="#cl::opt">cl::opt</a>&lt;string&gt; Regex   (<a href="#cl::Positional">cl::Positional</a>, <a href="#cl::desc">cl::desc</a>("<i>&lt;regular expression&gt;</i>"), <a href="#cl::Required">cl::Required</a>);
<a href="#cl::opt">cl::opt</a>&lt;string&gt; Filename(<a href="#cl::Positional">cl::Positional</a>, <a href="#cl::desc">cl::desc</a>("<i>&lt;input file&gt;</i>"), <a href="#cl::init">cl::init</a>("<i>-</i>"));
</pre></div>

<p>Given these two option declarations, the <tt>-help</tt> output for our grep
replacement would look like this:</p>

<div class="doc_code"><pre>
USAGE: spiffygrep [options] <b>&lt;regular expression&gt; &lt;input file&gt;</b>

OPTIONS:
  -help - display available options (-help-hidden for more)
</pre></div>

<p>... and the resultant program could be used just like the standard
<tt>grep</tt> tool.</p>

<p>Positional arguments are sorted by their order of construction.  This means
that command line options will be ordered according to how they are listed in a
.cpp file, but will not have an ordering defined if the positional arguments
are defined in multiple .cpp files.  The fix for this problem is simply to
define all of your positional arguments in one .cpp file.</p>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="--">Specifying positional options with hyphens</a>
</h4>

<div>

<p>Sometimes you may want to specify a value to your positional argument that
starts with a hyphen (for example, searching for '<tt>-foo</tt>' in a file).  At
first, you will have trouble doing this, because it will try to find an argument
named '<tt>-foo</tt>', and will fail (and single quotes will not save you).
Note that the system <tt>grep</tt> has the same problem:</p>

<div class="doc_code"><pre>
  $ spiffygrep '-foo' test.txt
  Unknown command line argument '-foo'.  Try: spiffygrep -help'

  $ grep '-foo' test.txt
  grep: illegal option -- f
  grep: illegal option -- o
  grep: illegal option -- o
  Usage: grep -hblcnsviw pattern file . . .
</pre></div>

<p>The solution for this problem is the same for both your tool and the system
version: use the '<tt>--</tt>' marker.  When the user specifies '<tt>--</tt>' on
the command line, it is telling the program that all options after the
'<tt>--</tt>' should be treated as positional arguments, not options.  Thus, we
can use it like this:</p>

<div class="doc_code"><pre>
  $ spiffygrep -- -foo test.txt
    ...output...
</pre></div>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="getPosition">Determining absolute position with getPosition()</a>
</h4>
<div>
  <p>Sometimes an option can affect or modify the meaning of another option. For
  example, consider <tt>gcc</tt>'s <tt>-x LANG</tt> option. This tells
  <tt>gcc</tt> to ignore the suffix of subsequent positional arguments and force
  the file to be interpreted as if it contained source code in language
  <tt>LANG</tt>. In order to handle this properly, you need to know the
  absolute position of each argument, especially those in lists, so their
  interaction(s) can be applied correctly. This is also useful for options like
  <tt>-llibname</tt> which is actually a positional argument that starts with
  a dash.</p>
  <p>So, generally, the problem is that you have two <tt>cl::list</tt> variables
  that interact in some way. To ensure the correct interaction, you can use the
  <tt>cl::list::getPosition(optnum)</tt> method. This method returns the
  absolute position (as found on the command line) of the <tt>optnum</tt>
  item in the <tt>cl::list</tt>.</p>
  <p>The idiom for usage is like this:</p>

  <div class="doc_code"><pre>
  static cl::list&lt;std::string&gt; Files(cl::Positional, cl::OneOrMore);
  static cl::list&lt;std::string&gt; Libraries("l", cl::ZeroOrMore);

  int main(int argc, char**argv) {
    // ...
    std::vector&lt;std::string&gt;::iterator fileIt = Files.begin();
    std::vector&lt;std::string&gt;::iterator libIt  = Libraries.begin();
    unsigned libPos = 0, filePos = 0;
    while ( 1 ) {
      if ( libIt != Libraries.end() )
        libPos = Libraries.getPosition( libIt - Libraries.begin() );
      else
        libPos = 0;
      if ( fileIt != Files.end() )
        filePos = Files.getPosition( fileIt - Files.begin() );
      else
        filePos = 0;

      if ( filePos != 0 &amp;&amp; (libPos == 0 || filePos &lt; libPos) ) {
        // Source File Is next
        ++fileIt;
      }
      else if ( libPos != 0 &amp;&amp; (filePos == 0 || libPos &lt; filePos) ) {
        // Library is next
        ++libIt;
      }
      else
        break; // we're done with the list
    }
  }</pre></div>

  <p>Note that, for compatibility reasons, the <tt>cl::opt</tt> also supports an
  <tt>unsigned getPosition()</tt> option that will provide the absolute position
  of that option. You can apply the same approach as above with a
  <tt>cl::opt</tt> and a <tt>cl::list</tt> option as you can with two lists.</p>
</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="cl::ConsumeAfter">The <tt>cl::ConsumeAfter</tt> modifier</a>
</h4>

<div>

<p>The <tt>cl::ConsumeAfter</tt> <a href="#formatting">formatting option</a> is
used to construct programs that use "interpreter style" option processing.  With
this style of option processing, all arguments specified after the last
positional argument are treated as special interpreter arguments that are not
interpreted by the command line argument.</p>

<p>As a concrete example, lets say we are developing a replacement for the
standard Unix Bourne shell (<tt>/bin/sh</tt>).  To run <tt>/bin/sh</tt>, first
you specify options to the shell itself (like <tt>-x</tt> which turns on trace
output), then you specify the name of the script to run, then you specify
arguments to the script.  These arguments to the script are parsed by the Bourne
shell command line option processor, but are not interpreted as options to the
shell itself.  Using the CommandLine library, we would specify this as:</p>

<div class="doc_code"><pre>
<a href="#cl::opt">cl::opt</a>&lt;string&gt; Script(<a href="#cl::Positional">cl::Positional</a>, <a href="#cl::desc">cl::desc</a>("<i>&lt;input script&gt;</i>"), <a href="#cl::init">cl::init</a>("-"));
<a href="#cl::list">cl::list</a>&lt;string&gt;  Argv(<a href="#cl::ConsumeAfter">cl::ConsumeAfter</a>, <a href="#cl::desc">cl::desc</a>("<i>&lt;program arguments&gt;...</i>"));
<a href="#cl::opt">cl::opt</a>&lt;bool&gt;    Trace("<i>x</i>", <a href="#cl::desc">cl::desc</a>("<i>Enable trace output</i>"));
</pre></div>

<p>which automatically provides the help output:</p>

<div class="doc_code"><pre>
USAGE: spiffysh [options] <b>&lt;input script&gt; &lt;program arguments&gt;...</b>

OPTIONS:
  -help - display available options (-help-hidden for more)
  <b>-x    - Enable trace output</b>
</pre></div>

<p>At runtime, if we run our new shell replacement as `<tt>spiffysh -x test.sh
-a -x -y bar</tt>', the <tt>Trace</tt> variable will be set to true, the
<tt>Script</tt> variable will be set to "<tt>test.sh</tt>", and the
<tt>Argv</tt> list will contain <tt>["-a", "-x", "-y", "bar"]</tt>, because they
were specified after the last positional argument (which is the script
name).</p>

<p>There are several limitations to when <tt>cl::ConsumeAfter</tt> options can
be specified.  For example, only one <tt>cl::ConsumeAfter</tt> can be specified
per program, there must be at least one <a href="#positional">positional
argument</a> specified, there must not be any <a href="#cl::list">cl::list</a>
positional arguments, and the <tt>cl::ConsumeAfter</tt> option should be a <a
href="#cl::list">cl::list</a> option.</p>

</div>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="storage">Internal vs External Storage</a>
</h3>

<div>

<p>By default, all command line options automatically hold the value that they
parse from the command line.  This is very convenient in the common case,
especially when combined with the ability to define command line options in the
files that use them.  This is called the internal storage model.</p>

<p>Sometimes, however, it is nice to separate the command line option processing
code from the storage of the value parsed.  For example, lets say that we have a
'<tt>-debug</tt>' option that we would like to use to enable debug information
across the entire body of our program.  In this case, the boolean value
controlling the debug code should be globally accessible (in a header file, for
example) yet the command line option processing code should not be exposed to
all of these clients (requiring lots of .cpp files to #include
<tt>CommandLine.h</tt>).</p>

<p>To do this, set up your .h file with your option, like this for example:</p>

<div class="doc_code">
<pre>
<i>// DebugFlag.h - Get access to the '-debug' command line option
//

// DebugFlag - This boolean is set to true if the '-debug' command line option
// is specified.  This should probably not be referenced directly, instead, use
// the DEBUG macro below.
//</i>
extern bool DebugFlag;

<i>// DEBUG macro - This macro should be used by code to emit debug information.
// In the '-debug' option is specified on the command line, and if this is a
// debug build, then the code specified as the option to the macro will be
// executed.  Otherwise it will not be.</i>
<span class="doc_hilite">#ifdef NDEBUG
#define DEBUG(X)
#else
#define DEBUG(X)</span> do { if (DebugFlag) { X; } } while (0)
<span class="doc_hilite">#endif</span>
</pre>
</div>

<p>This allows clients to blissfully use the <tt>DEBUG()</tt> macro, or the
<tt>DebugFlag</tt> explicitly if they want to.  Now we just need to be able to
set the <tt>DebugFlag</tt> boolean when the option is set.  To do this, we pass
an additional argument to our command line argument processor, and we specify
where to fill in with the <a href="#cl::location">cl::location</a>
attribute:</p>

<div class="doc_code">
<pre>
bool DebugFlag;                  <i>// the actual value</i>
static <a href="#cl::opt">cl::opt</a>&lt;bool, true&gt;       <i>// The parser</i>
Debug("<i>debug</i>", <a href="#cl::desc">cl::desc</a>("<i>Enable debug output</i>"), <a href="#cl::Hidden">cl::Hidden</a>, <a href="#cl::location">cl::location</a>(DebugFlag));
</pre>
</div>

<p>In the above example, we specify "<tt>true</tt>" as the second argument to
the <tt><a href="#cl::opt">cl::opt</a></tt> template, indicating that the
template should not maintain a copy of the value itself.  In addition to this,
we specify the <tt><a href="#cl::location">cl::location</a></tt> attribute, so
that <tt>DebugFlag</tt> is automatically set.</p>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="attributes">Option Attributes</a>
</h3>

<div>

<p>This section describes the basic attributes that you can specify on
options.</p>

<ul>

<li>The option name attribute (which is required for all options, except <a
href="#positional">positional options</a>) specifies what the option name is.
This option is specified in simple double quotes:

<pre>
<a href="#cl::opt">cl::opt</a>&lt;<b>bool</b>&gt; Quiet("<i>quiet</i>");
</pre>

</li>

<li><a name="cl::desc">The <b><tt>cl::desc</tt></b></a> attribute specifies a
description for the option to be shown in the <tt>-help</tt> output for the
program.</li>

<li><a name="cl::value_desc">The <b><tt>cl::value_desc</tt></b></a> attribute
specifies a string that can be used to fine tune the <tt>-help</tt> output for
a command line option.  Look <a href="#value_desc_example">here</a> for an
example.</li>

<li><a name="cl::init">The <b><tt>cl::init</tt></b></a> attribute specifies an
initial value for a <a href="#cl::opt">scalar</a> option.  If this attribute is
not specified then the command line option value defaults to the value created
by the default constructor for the type. <b>Warning</b>: If you specify both
<b><tt>cl::init</tt></b> and <b><tt>cl::location</tt></b> for an option,
you must specify <b><tt>cl::location</tt></b> first, so that when the
command-line parser sees <b><tt>cl::init</tt></b>, it knows where to put the
initial value. (You will get an error at runtime if you don't put them in
the right order.)</li>

<li><a name="cl::location">The <b><tt>cl::location</tt></b></a> attribute where
to store the value for a parsed command line option if using external storage.
See the section on <a href="#storage">Internal vs External Storage</a> for more
information.</li>

<li><a name="cl::aliasopt">The <b><tt>cl::aliasopt</tt></b></a> attribute
specifies which option a <tt><a href="#cl::alias">cl::alias</a></tt> option is
an alias for.</li>

<li><a name="cl::values">The <b><tt>cl::values</tt></b></a> attribute specifies
the string-to-value mapping to be used by the generic parser.  It takes a
<b>clEnumValEnd terminated</b> list of (option, value, description) triplets
that
specify the option name, the value mapped to, and the description shown in the
<tt>-help</tt> for the tool.  Because the generic parser is used most
frequently with enum values, two macros are often useful:

<ol>

<li><a name="clEnumVal">The <b><tt>clEnumVal</tt></b></a> macro is used as a
nice simple way to specify a triplet for an enum.  This macro automatically
makes the option name be the same as the enum name.  The first option to the
macro is the enum, the second is the description for the command line
option.</li>

<li><a name="clEnumValN">The <b><tt>clEnumValN</tt></b></a> macro is used to
specify macro options where the option name doesn't equal the enum name.  For
this macro, the first argument is the enum value, the second is the flag name,
and the second is the description.</li>

</ol>

You will get a compile time error if you try to use cl::values with a parser
that does not support it.</li>

<li><a name="cl::multi_val">The <b><tt>cl::multi_val</tt></b></a>
attribute specifies that this option takes has multiple values
(example: <tt>-sectalign segname sectname sectvalue</tt>). This
attribute takes one unsigned argument - the number of values for the
option. This attribute is valid only on <tt>cl::list</tt> options (and
will fail with compile error if you try to use it with other option
types). It is allowed to use all of the usual modifiers on
multi-valued options (besides <tt>cl::ValueDisallowed</tt>,
obviously).</li>

</ul>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="modifiers">Option Modifiers</a>
</h3>

<div>

<p>Option modifiers are the flags and expressions that you pass into the
constructors for <tt><a href="#cl::opt">cl::opt</a></tt> and <tt><a
href="#cl::list">cl::list</a></tt>.  These modifiers give you the ability to
tweak how options are parsed and how <tt>-help</tt> output is generated to fit
your application well.</p>

<p>These options fall into five main categories:</p>

<ol>
<li><a href="#hiding">Hiding an option from <tt>-help</tt> output</a></li>
<li><a href="#numoccurrences">Controlling the number of occurrences
                             required and allowed</a></li>
<li><a href="#valrequired">Controlling whether or not a value must be
                           specified</a></li>
<li><a href="#formatting">Controlling other formatting options</a></li>
<li><a href="#misc">Miscellaneous option modifiers</a></li>
</ol>

<p>It is not possible to specify two options from the same category (you'll get
a runtime error) to a single option, except for options in the miscellaneous
category.  The CommandLine library specifies defaults for all of these settings
that are the most useful in practice and the most common, which mean that you
usually shouldn't have to worry about these.</p>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="hiding">Hiding an option from <tt>-help</tt> output</a>
</h4>

<div>

<p>The <tt>cl::NotHidden</tt>, <tt>cl::Hidden</tt>, and
<tt>cl::ReallyHidden</tt> modifiers are used to control whether or not an option
appears in the <tt>-help</tt> and <tt>-help-hidden</tt> output for the
compiled program:</p>

<ul>

<li><a name="cl::NotHidden">The <b><tt>cl::NotHidden</tt></b></a> modifier
(which is the default for <tt><a href="#cl::opt">cl::opt</a></tt> and <tt><a
href="#cl::list">cl::list</a></tt> options) indicates the option is to appear
in both help listings.</li>

<li><a name="cl::Hidden">The <b><tt>cl::Hidden</tt></b></a> modifier (which is the
default for <tt><a href="#cl::alias">cl::alias</a></tt> options) indicates that
the option should not appear in the <tt>-help</tt> output, but should appear in
the <tt>-help-hidden</tt> output.</li>

<li><a name="cl::ReallyHidden">The <b><tt>cl::ReallyHidden</tt></b></a> modifier
indicates that the option should not appear in any help output.</li>

</ul>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="numoccurrences">Controlling the number of occurrences required and
  allowed</a>
</h4>

<div>

<p>This group of options is used to control how many time an option is allowed
(or required) to be specified on the command line of your program.  Specifying a
value for this setting allows the CommandLine library to do error checking for
you.</p>

<p>The allowed values for this option group are:</p>

<ul>

<li><a name="cl::Optional">The <b><tt>cl::Optional</tt></b></a> modifier (which
is the default for the <tt><a href="#cl::opt">cl::opt</a></tt> and <tt><a
href="#cl::alias">cl::alias</a></tt> classes) indicates that your program will
allow either zero or one occurrence of the option to be specified.</li>

<li><a name="cl::ZeroOrMore">The <b><tt>cl::ZeroOrMore</tt></b></a> modifier
(which is the default for the <tt><a href="#cl::list">cl::list</a></tt> class)
indicates that your program will allow the option to be specified zero or more
times.</li>

<li><a name="cl::Required">The <b><tt>cl::Required</tt></b></a> modifier
indicates that the specified option must be specified exactly one time.</li>

<li><a name="cl::OneOrMore">The <b><tt>cl::OneOrMore</tt></b></a> modifier
indicates that the option must be specified at least one time.</li>

<li>The <b><tt>cl::ConsumeAfter</tt></b> modifier is described in the <a
href="#positional">Positional arguments section</a>.</li>

</ul>

<p>If an option is not specified, then the value of the option is equal to the
value specified by the <tt><a href="#cl::init">cl::init</a></tt> attribute.  If
the <tt><a href="#cl::init">cl::init</a></tt> attribute is not specified, the
option value is initialized with the default constructor for the data type.</p>

<p>If an option is specified multiple times for an option of the <tt><a
href="#cl::opt">cl::opt</a></tt> class, only the last value will be
retained.</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="valrequired">Controlling whether or not a value must be specified</a>
</h4>

<div>

<p>This group of options is used to control whether or not the option allows a
value to be present.  In the case of the CommandLine library, a value is either
specified with an equal sign (e.g. '<tt>-index-depth=17</tt>') or as a trailing
string (e.g. '<tt>-o a.out</tt>').</p>

<p>The allowed values for this option group are:</p>

<ul>

<li><a name="cl::ValueOptional">The <b><tt>cl::ValueOptional</tt></b></a> modifier
(which is the default for <tt>bool</tt> typed options) specifies that it is
acceptable to have a value, or not.  A boolean argument can be enabled just by
appearing on the command line, or it can have an explicit '<tt>-foo=true</tt>'.
If an option is specified with this mode, it is illegal for the value to be
provided without the equal sign.  Therefore '<tt>-foo true</tt>' is illegal.  To
get this behavior, you must use the <a
href="#cl::ValueRequired">cl::ValueRequired</a> modifier.</li>

<li><a name="cl::ValueRequired">The <b><tt>cl::ValueRequired</tt></b></a> modifier
(which is the default for all other types except for <a
href="#onealternative">unnamed alternatives using the generic parser</a>)
specifies that a value must be provided.  This mode informs the command line
library that if an option is not provides with an equal sign, that the next
argument provided must be the value.  This allows things like '<tt>-o
a.out</tt>' to work.</li>

<li><a name="cl::ValueDisallowed">The <b><tt>cl::ValueDisallowed</tt></b></a>
modifier (which is the default for <a href="#onealternative">unnamed
alternatives using the generic parser</a>) indicates that it is a runtime error
for the user to specify a value.  This can be provided to disallow users from
providing options to boolean options (like '<tt>-foo=true</tt>').</li>

</ul>

<p>In general, the default values for this option group work just like you would
want them to.  As mentioned above, you can specify the <a
href="#cl::ValueDisallowed">cl::ValueDisallowed</a> modifier to a boolean
argument to restrict your command line parser.  These options are mostly useful
when <a href="#extensionguide">extending the library</a>.</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="formatting">Controlling other formatting options</a>
</h4>

<div>

<p>The formatting option group is used to specify that the command line option
has special abilities and is otherwise different from other command line
arguments.  As usual, you can only specify one of these arguments at most.</p>

<ul>

<li><a name="cl::NormalFormatting">The <b><tt>cl::NormalFormatting</tt></b></a>
modifier (which is the default all options) specifies that this option is
"normal".</li>

<li><a name="cl::Positional">The <b><tt>cl::Positional</tt></b></a> modifier
specifies that this is a positional argument that does not have a command line
option associated with it.  See the <a href="#positional">Positional
Arguments</a> section for more information.</li>

<li>The <b><a href="#cl::ConsumeAfter"><tt>cl::ConsumeAfter</tt></a></b> modifier
specifies that this option is used to capture "interpreter style" arguments.  See <a href="#cl::ConsumeAfter">this section for more information</a>.</li>

<li><a name="cl::Prefix">The <b><tt>cl::Prefix</tt></b></a> modifier specifies
that this option prefixes its value.  With 'Prefix' options, the equal sign does
not separate the value from the option name specified. Instead, the value is
everything after the prefix, including any equal sign if present. This is useful
for processing odd arguments like <tt>-lmalloc</tt> and <tt>-L/usr/lib</tt> in a
linker tool or <tt>-DNAME=value</tt> in a compiler tool.   Here, the
'<tt>l</tt>', '<tt>D</tt>' and '<tt>L</tt>' options are normal string (or list)
options, that have the <b><tt><a href="#cl::Prefix">cl::Prefix</a></tt></b>
modifier added to allow the CommandLine library to recognize them.  Note that
<b><tt><a href="#cl::Prefix">cl::Prefix</a></tt></b> options must not have the
<b><tt><a href="#cl::ValueDisallowed">cl::ValueDisallowed</a></tt></b> modifier
specified.</li>

<li><a name="cl::Grouping">The <b><tt>cl::Grouping</tt></b></a> modifier is used
to implement Unix-style tools (like <tt>ls</tt>) that have lots of single letter
arguments, but only require a single dash.  For example, the '<tt>ls -labF</tt>'
command actually enables four different options, all of which are single
letters.  Note that <b><tt><a href="#cl::Grouping">cl::Grouping</a></tt></b>
options cannot have values.</li>

</ul>

<p>The CommandLine library does not restrict how you use the <b><tt><a
href="#cl::Prefix">cl::Prefix</a></tt></b> or <b><tt><a
href="#cl::Grouping">cl::Grouping</a></tt></b> modifiers, but it is possible to
specify ambiguous argument settings.  Thus, it is possible to have multiple
letter options that are prefix or grouping options, and they will still work as
designed.</p>

<p>To do this, the CommandLine library uses a greedy algorithm to parse the
input option into (potentially multiple) prefix and grouping options.  The
strategy basically looks like this:</p>

<div class="doc_code"><tt>parse(string OrigInput) {</tt>

<ol>
<li><tt>string input = OrigInput;</tt>
<li><tt>if (isOption(input)) return getOption(input).parse();</tt>&nbsp;&nbsp;&nbsp;&nbsp;<i>// Normal option</i>
<li><tt>while (!isOption(input) &amp;&amp; !input.empty()) input.pop_back();</tt>&nbsp;&nbsp;&nbsp;&nbsp;<i>// Remove the last letter</i>
<li><tt>if (input.empty()) return error();</tt>&nbsp;&nbsp;&nbsp;&nbsp;<i>// No matching option</i>
<li><tt>if (getOption(input).isPrefix())<br>
&nbsp;&nbsp;return getOption(input).parse(input);</tt>
<li><tt>while (!input.empty()) {&nbsp;&nbsp;&nbsp;&nbsp;<i>// Must be grouping options</i><br>
&nbsp;&nbsp;getOption(input).parse();<br>
&nbsp;&nbsp;OrigInput.erase(OrigInput.begin(), OrigInput.begin()+input.length());<br>
&nbsp;&nbsp;input = OrigInput;<br>
&nbsp;&nbsp;while (!isOption(input) &amp;&amp; !input.empty()) input.pop_back();<br>
}</tt>
<li><tt>if (!OrigInput.empty()) error();</tt></li>
</ol>

<p><tt>}</tt></p>
</div>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="misc">Miscellaneous option modifiers</a>
</h4>

<div>

<p>The miscellaneous option modifiers are the only flags where you can specify
more than one flag from the set: they are not mutually exclusive.  These flags
specify boolean properties that modify the option.</p>

<ul>

<li><a name="cl::CommaSeparated">The <b><tt>cl::CommaSeparated</tt></b></a> modifier
indicates that any commas specified for an option's value should be used to
split the value up into multiple values for the option.  For example, these two
options are equivalent when <tt>cl::CommaSeparated</tt> is specified:
"<tt>-foo=a -foo=b -foo=c</tt>" and "<tt>-foo=a,b,c</tt>".  This option only
makes sense to be used in a case where the option is allowed to accept one or
more values (i.e. it is a <a href="#cl::list">cl::list</a> option).</li>

<li><a name="cl::PositionalEatsArgs">The
<b><tt>cl::PositionalEatsArgs</tt></b></a> modifier (which only applies to
positional arguments, and only makes sense for lists) indicates that positional
argument should consume any strings after it (including strings that start with
a "-") up until another recognized positional argument.  For example, if you
have two "eating" positional arguments, "<tt>pos1</tt>" and "<tt>pos2</tt>", the
string "<tt>-pos1 -foo -bar baz -pos2 -bork</tt>" would cause the "<tt>-foo -bar
-baz</tt>" strings to be applied to the "<tt>-pos1</tt>" option and the
"<tt>-bork</tt>" string to be applied to the "<tt>-pos2</tt>" option.</li>

<li><a name="cl::Sink">The <b><tt>cl::Sink</tt></b></a> modifier is
used to handle unknown options. If there is at least one option with
<tt>cl::Sink</tt> modifier specified, the parser passes
unrecognized option strings to it as values instead of signaling an
error. As with <tt>cl::CommaSeparated</tt>, this modifier
only makes sense with a <a href="#cl::list">cl::list</a> option.</li>

</ul>

<p>So far, these are the only three miscellaneous option modifiers.</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="response">Response files</a>
</h4>

<div>

<p>Some systems, such as certain variants of Microsoft Windows and
some older Unices have a relatively low limit on command-line
length. It is therefore customary to use the so-called 'response
files' to circumvent this restriction. These files are mentioned on
the command-line (using the "@file") syntax. The program reads these
files and inserts the contents into argv, thereby working around the
command-line length limits. Response files are enabled by an optional
fourth argument to
<a href="#cl::ParseEnvironmentOptions"><tt>cl::ParseEnvironmentOptions</tt></a>
and
<a href="#cl::ParseCommandLineOptions"><tt>cl::ParseCommandLineOptions</tt></a>.
</p>

</div>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="toplevel">Top-Level Classes and Functions</a>
</h3>

<div>

<p>Despite all of the built-in flexibility, the CommandLine option library
really only consists of one function (<a
href="#cl::ParseCommandLineOptions"><tt>cl::ParseCommandLineOptions</tt></a>)
and three main classes: <a href="#cl::opt"><tt>cl::opt</tt></a>, <a
href="#cl::list"><tt>cl::list</tt></a>, and <a
href="#cl::alias"><tt>cl::alias</tt></a>.  This section describes these three
classes in detail.</p>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="cl::ParseCommandLineOptions">The <tt>cl::ParseCommandLineOptions</tt>
  function</a>
</h4>

<div>

<p>The <tt>cl::ParseCommandLineOptions</tt> function is designed to be called
directly from <tt>main</tt>, and is used to fill in the values of all of the
command line option variables once <tt>argc</tt> and <tt>argv</tt> are
available.</p>

<p>The <tt>cl::ParseCommandLineOptions</tt> function requires two parameters
(<tt>argc</tt> and <tt>argv</tt>), but may also take an optional third parameter
which holds <a href="#description">additional extra text</a> to emit when the
<tt>-help</tt> option is invoked, and a fourth boolean parameter that enables
<a href="#response">response files</a>.</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="cl::ParseEnvironmentOptions">The <tt>cl::ParseEnvironmentOptions</tt>
  function</a>
</h4>

<div>

<p>The <tt>cl::ParseEnvironmentOptions</tt> function has mostly the same effects
as <a
href="#cl::ParseCommandLineOptions"><tt>cl::ParseCommandLineOptions</tt></a>,
except that it is designed to take values for options from an environment
variable, for those cases in which reading the command line is not convenient or
desired. It fills in the values of all the command line option variables just
like <a
href="#cl::ParseCommandLineOptions"><tt>cl::ParseCommandLineOptions</tt></a>
does.</p>

<p>It takes four parameters: the name of the program (since <tt>argv</tt> may
not be available, it can't just look in <tt>argv[0]</tt>), the name of the
environment variable to examine, the optional
<a href="#description">additional extra text</a> to emit when the
<tt>-help</tt> option is invoked, and the boolean
switch that controls whether <a href="#response">response files</a>
should be read.</p>

<p><tt>cl::ParseEnvironmentOptions</tt> will break the environment
variable's value up into words and then process them using
<a href="#cl::ParseCommandLineOptions"><tt>cl::ParseCommandLineOptions</tt></a>.
<b>Note:</b> Currently <tt>cl::ParseEnvironmentOptions</tt> does not support
quoting, so an environment variable containing <tt>-option "foo bar"</tt> will
be parsed as three words, <tt>-option</tt>, <tt>"foo</tt>, and <tt>bar"</tt>,
which is different from what you would get from the shell with the same
input.</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="cl::SetVersionPrinter">The <tt>cl::SetVersionPrinter</tt>
  function</a>
</h4>

<div>

<p>The <tt>cl::SetVersionPrinter</tt> function is designed to be called
directly from <tt>main</tt> and <i>before</i>
<tt>cl::ParseCommandLineOptions</tt>. Its use is optional. It simply arranges
for a function to be called in response to the <tt>--version</tt> option instead
of having the <tt>CommandLine</tt> library print out the usual version string
for LLVM. This is useful for programs that are not part of LLVM but wish to use
the <tt>CommandLine</tt> facilities. Such programs should just define a small
function that takes no arguments and returns <tt>void</tt> and that prints out
whatever version information is appropriate for the program. Pass the address
of that function to <tt>cl::SetVersionPrinter</tt> to arrange for it to be
called when the <tt>--version</tt> option is given by the user.</p>

</div>
<!-- _______________________________________________________________________ -->
<h4>
  <a name="cl::opt">The <tt>cl::opt</tt> class</a>
</h4>

<div>

<p>The <tt>cl::opt</tt> class is the class used to represent scalar command line
options, and is the one used most of the time.  It is a templated class which
can take up to three arguments (all except for the first have default values
though):</p>

<div class="doc_code"><pre>
<b>namespace</b> cl {
  <b>template</b> &lt;<b>class</b> DataType, <b>bool</b> ExternalStorage = <b>false</b>,
            <b>class</b> ParserClass = parser&lt;DataType&gt; &gt;
  <b>class</b> opt;
}
</pre></div>

<p>The first template argument specifies what underlying data type the command
line argument is, and is used to select a default parser implementation.  The
second template argument is used to specify whether the option should contain
the storage for the option (the default) or whether external storage should be
used to contain the value parsed for the option (see <a href="#storage">Internal
vs External Storage</a> for more information).</p>

<p>The third template argument specifies which parser to use.  The default value
selects an instantiation of the <tt>parser</tt> class based on the underlying
data type of the option.  In general, this default works well for most
applications, so this option is only used when using a <a
href="#customparser">custom parser</a>.</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="cl::list">The <tt>cl::list</tt> class</a>
</h4>

<div>

<p>The <tt>cl::list</tt> class is the class used to represent a list of command
line options.  It too is a templated class which can take up to three
arguments:</p>

<div class="doc_code"><pre>
<b>namespace</b> cl {
  <b>template</b> &lt;<b>class</b> DataType, <b>class</b> Storage = <b>bool</b>,
            <b>class</b> ParserClass = parser&lt;DataType&gt; &gt;
  <b>class</b> list;
}
</pre></div>

<p>This class works the exact same as the <a
href="#cl::opt"><tt>cl::opt</tt></a> class, except that the second argument is
the <b>type</b> of the external storage, not a boolean value.  For this class,
the marker type '<tt>bool</tt>' is used to indicate that internal storage should
be used.</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="cl::bits">The <tt>cl::bits</tt> class</a>
</h4>

<div>

<p>The <tt>cl::bits</tt> class is the class used to represent a list of command
line options in the form of a bit vector.  It is also a templated class which
can take up to three arguments:</p>

<div class="doc_code"><pre>
<b>namespace</b> cl {
  <b>template</b> &lt;<b>class</b> DataType, <b>class</b> Storage = <b>bool</b>,
            <b>class</b> ParserClass = parser&lt;DataType&gt; &gt;
  <b>class</b> bits;
}
</pre></div>

<p>This class works the exact same as the <a
href="#cl::opt"><tt>cl::lists</tt></a> class, except that the second argument
must be of <b>type</b> <tt>unsigned</tt> if external storage is used.</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="cl::alias">The <tt>cl::alias</tt> class</a>
</h4>

<div>

<p>The <tt>cl::alias</tt> class is a nontemplated class that is used to form
aliases for other arguments.</p>

<div class="doc_code"><pre>
<b>namespace</b> cl {
  <b>class</b> alias;
}
</pre></div>

<p>The <a href="#cl::aliasopt"><tt>cl::aliasopt</tt></a> attribute should be
used to specify which option this is an alias for.  Alias arguments default to
being <a href="#cl::Hidden">Hidden</a>, and use the aliased options parser to do
the conversion from string to data.</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="cl::extrahelp">The <tt>cl::extrahelp</tt> class</a>
</h4>

<div>

<p>The <tt>cl::extrahelp</tt> class is a nontemplated class that allows extra
help text to be printed out for the <tt>-help</tt> option.</p>

<div class="doc_code"><pre>
<b>namespace</b> cl {
  <b>struct</b> extrahelp;
}
</pre></div>

<p>To use the extrahelp, simply construct one with a <tt>const char*</tt>
parameter to the constructor. The text passed to the constructor will be printed
at the bottom of the help message, verbatim. Note that multiple
<tt>cl::extrahelp</tt> <b>can</b> be used, but this practice is discouraged. If
your tool needs to print additional help information, put all that help into a
single <tt>cl::extrahelp</tt> instance.</p>
<p>For example:</p>
<div class="doc_code"><pre>
  cl::extrahelp("\nADDITIONAL HELP:\n\n  This is the extra help\n");
</pre></div>
</div>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="builtinparsers">Builtin parsers</a>
</h3>

<div>

<p>Parsers control how the string value taken from the command line is
translated into a typed value, suitable for use in a C++ program.  By default,
the CommandLine library uses an instance of <tt>parser&lt;type&gt;</tt> if the
command line option specifies that it uses values of type '<tt>type</tt>'.
Because of this, custom option processing is specified with specializations of
the '<tt>parser</tt>' class.</p>

<p>The CommandLine library provides the following builtin parser
specializations, which are sufficient for most applications. It can, however,
also be extended to work with new data types and new ways of interpreting the
same data.  See the <a href="#customparser">Writing a Custom Parser</a> for more
details on this type of library extension.</p>

<ul>

<li><a name="genericparser">The <b>generic <tt>parser&lt;t&gt;</tt> parser</b></a>
can be used to map strings values to any data type, through the use of the <a
href="#cl::values">cl::values</a> property, which specifies the mapping
information.  The most common use of this parser is for parsing enum values,
which allows you to use the CommandLine library for all of the error checking to
make sure that only valid enum values are specified (as opposed to accepting
arbitrary strings).  Despite this, however, the generic parser class can be used
for any data type.</li>

<li><a name="boolparser">The <b><tt>parser&lt;bool&gt;</tt> specialization</b></a>
is used to convert boolean strings to a boolean value.  Currently accepted
strings are "<tt>true</tt>", "<tt>TRUE</tt>", "<tt>True</tt>", "<tt>1</tt>",
"<tt>false</tt>", "<tt>FALSE</tt>", "<tt>False</tt>", and "<tt>0</tt>".</li>

<li><a name="boolOrDefaultparser">The <b><tt>parser&lt;boolOrDefault&gt;</tt>
 specialization</b></a> is used for cases where the value is boolean,
but we also need to know whether the option was specified at all.  boolOrDefault
is an enum with 3 values, BOU_UNSET, BOU_TRUE and BOU_FALSE.  This parser accepts
the same strings as <b><tt>parser&lt;bool&gt;</tt></b>.</li>

<li><a name="stringparser">The <b><tt>parser&lt;string&gt;</tt>
specialization</b></a> simply stores the parsed string into the string value
specified.  No conversion or modification of the data is performed.</li>

<li><a name="intparser">The <b><tt>parser&lt;int&gt;</tt> specialization</b></a>
uses the C <tt>strtol</tt> function to parse the string input.  As such, it will
accept a decimal number (with an optional '+' or '-' prefix) which must start
with a non-zero digit.  It accepts octal numbers, which are identified with a
'<tt>0</tt>' prefix digit, and hexadecimal numbers with a prefix of
'<tt>0x</tt>' or '<tt>0X</tt>'.</li>

<li><a name="doubleparser">The <b><tt>parser&lt;double&gt;</tt></b></a> and
<b><tt>parser&lt;float&gt;</tt> specializations</b> use the standard C
<tt>strtod</tt> function to convert floating point strings into floating point
values.  As such, a broad range of string formats is supported, including
exponential notation (ex: <tt>1.7e15</tt>) and properly supports locales.
</li>

</ul>

</div>

</div>

<!-- *********************************************************************** -->
<h2>
  <a name="extensionguide">Extension Guide</a>
</h2>
<!-- *********************************************************************** -->

<div>

<p>Although the CommandLine library has a lot of functionality built into it
already (as discussed previously), one of its true strengths lie in its
extensibility.  This section discusses how the CommandLine library works under
the covers and illustrates how to do some simple, common, extensions.</p>

<!-- ======================================================================= -->
<h3>
  <a name="customparser">Writing a custom parser</a>
</h3>

<div>

<p>One of the simplest and most common extensions is the use of a custom parser.
As <a href="#builtinparsers">discussed previously</a>, parsers are the portion
of the CommandLine library that turns string input from the user into a
particular parsed data type, validating the input in the process.</p>

<p>There are two ways to use a new parser:</p>

<ol>

<li>

<p>Specialize the <a href="#genericparser"><tt>cl::parser</tt></a> template for
your custom data type.<p>

<p>This approach has the advantage that users of your custom data type will
automatically use your custom parser whenever they define an option with a value
type of your data type.  The disadvantage of this approach is that it doesn't
work if your fundamental data type is something that is already supported.</p>

</li>

<li>

<p>Write an independent class, using it explicitly from options that need
it.</p>

<p>This approach works well in situations where you would line to parse an
option using special syntax for a not-very-special data-type.  The drawback of
this approach is that users of your parser have to be aware that they are using
your parser instead of the builtin ones.</p>

</li>

</ol>

<p>To guide the discussion, we will discuss a custom parser that accepts file
sizes, specified with an optional unit after the numeric size.  For example, we
would like to parse "102kb", "41M", "1G" into the appropriate integer value.  In
this case, the underlying data type we want to parse into is
'<tt>unsigned</tt>'.  We choose approach #2 above because we don't want to make
this the default for all <tt>unsigned</tt> options.</p>

<p>To start out, we declare our new <tt>FileSizeParser</tt> class:</p>

<div class="doc_code"><pre>
<b>struct</b> FileSizeParser : <b>public</b> cl::basic_parser&lt;<b>unsigned</b>&gt; {
  <i>// parse - Return true on error.</i>
  <b>bool</b> parse(cl::Option &amp;O, <b>const char</b> *ArgName, <b>const</b> std::string &amp;ArgValue,
             <b>unsigned</b> &amp;Val);
};
</pre></div>

<p>Our new class inherits from the <tt>cl::basic_parser</tt> template class to
fill in the default, boiler plate code for us.  We give it the data type that
we parse into, the last argument to the <tt>parse</tt> method, so that clients of
our custom parser know what object type to pass in to the parse method.  (Here we
declare that we parse into '<tt>unsigned</tt>' variables.)</p>

<p>For most purposes, the only method that must be implemented in a custom
parser is the <tt>parse</tt> method.  The <tt>parse</tt> method is called
whenever the option is invoked, passing in the option itself, the option name,
the string to parse, and a reference to a return value.  If the string to parse
is not well-formed, the parser should output an error message and return true.
Otherwise it should return false and set '<tt>Val</tt>' to the parsed value.  In
our example, we implement <tt>parse</tt> as:</p>

<div class="doc_code"><pre>
<b>bool</b> FileSizeParser::parse(cl::Option &amp;O, <b>const char</b> *ArgName,
                           <b>const</b> std::string &amp;Arg, <b>unsigned</b> &amp;Val) {
  <b>const char</b> *ArgStart = Arg.c_str();
  <b>char</b> *End;

  <i>// Parse integer part, leaving 'End' pointing to the first non-integer char</i>
  Val = (unsigned)strtol(ArgStart, &amp;End, 0);

  <b>while</b> (1) {
    <b>switch</b> (*End++) {
    <b>case</b> 0: <b>return</b> false;   <i>// No error</i>
    <b>case</b> 'i':               <i>// Ignore the 'i' in KiB if people use that</i>
    <b>case</b> 'b': <b>case</b> 'B':     <i>// Ignore B suffix</i>
      <b>break</b>;

    <b>case</b> 'g': <b>case</b> 'G': Val *= 1024*1024*1024; <b>break</b>;
    <b>case</b> 'm': <b>case</b> 'M': Val *= 1024*1024;      <b>break</b>;
    <b>case</b> 'k': <b>case</b> 'K': Val *= 1024;           <b>break</b>;

    default:
      <i>// Print an error message if unrecognized character!</i>
      <b>return</b> O.error("'" + Arg + "' value invalid for file size argument!");
    }
  }
}
</pre></div>

<p>This function implements a very simple parser for the kinds of strings we are
interested in.  Although it has some holes (it allows "<tt>123KKK</tt>" for
example), it is good enough for this example.  Note that we use the option
itself to print out the error message (the <tt>error</tt> method always returns
true) in order to get a nice error message (shown below).  Now that we have our
parser class, we can use it like this:</p>

<div class="doc_code"><pre>
<b>static</b> <a href="#cl::opt">cl::opt</a>&lt;<b>unsigned</b>, <b>false</b>, FileSizeParser&gt;
MFS(<i>"max-file-size"</i>, <a href="#cl::desc">cl::desc</a>(<i>"Maximum file size to accept"</i>),
    <a href="#cl::value_desc">cl::value_desc</a>("<i>size</i>"));
</pre></div>

<p>Which adds this to the output of our program:</p>

<div class="doc_code"><pre>
OPTIONS:
  -help                 - display available options (-help-hidden for more)
  ...
  <b>-max-file-size=&lt;size&gt; - Maximum file size to accept</b>
</pre></div>

<p>And we can test that our parse works correctly now (the test program just
prints out the max-file-size argument value):</p>

<div class="doc_code"><pre>
$ ./test
MFS: 0
$ ./test -max-file-size=123MB
MFS: 128974848
$ ./test -max-file-size=3G
MFS: 3221225472
$ ./test -max-file-size=dog
-max-file-size option: 'dog' value invalid for file size argument!
</pre></div>

<p>It looks like it works.  The error message that we get is nice and helpful,
and we seem to accept reasonable file sizes.  This wraps up the "custom parser"
tutorial.</p>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="explotingexternal">Exploiting external storage</a>
</h3>

<div>
  <p>Several of the LLVM libraries define static <tt>cl::opt</tt> instances that
  will automatically be included in any program that links with that library.
  This is a feature. However, sometimes it is necessary to know the value of the
  command line option outside of the library. In these cases the library does or
  should provide an external storage location that is accessible to users of the
  library. Examples of this include the <tt>llvm::DebugFlag</tt> exported by the
  <tt>lib/Support/Debug.cpp</tt> file and the <tt>llvm::TimePassesIsEnabled</tt>
  flag exported by the <tt>lib/VMCore/Pass.cpp</tt> file.</p>

<p>TODO: complete this section</p>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="dynamicopts">Dynamically adding command line options</a>
</h3>

<div>

<p>TODO: fill in this section</p>

</div>

</div>

<!-- *********************************************************************** -->

<hr>
<address>
  <a href="http://jigsaw.w3.org/css-validator/check/referer"><img
  src="http://jigsaw.w3.org/css-validator/images/vcss-blue" alt="Valid CSS"></a>
  <a href="http://validator.w3.org/check/referer"><img
  src="http://www.w3.org/Icons/valid-html401-blue" alt="Valid HTML 4.01"></a>

  <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
  <a href="http://llvm.org/">LLVM Compiler Infrastructure</a><br>
  Last modified: $Date: 2011-04-22 20:30:22 -0400 (Fri, 22 Apr 2011) $
</address>

</body>
</html>
