<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
                      "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
  <title>Kaleidoscope: Extending the Language: User-defined Operators</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="author" content="Chris Lattner">
  <meta name="author" content="Erick Tryzelaar">
  <link rel="stylesheet" href="../llvm.css" type="text/css">
</head>

<body>

<h1>Kaleidoscope: Extending the Language: User-defined Operators</h1>

<ul>
<li><a href="index.html">Up to Tutorial Index</a></li>
<li>Chapter 6
  <ol>
    <li><a href="#intro">Chapter 6 Introduction</a></li>
    <li><a href="#idea">User-defined Operators: the Idea</a></li>
    <li><a href="#binary">User-defined Binary Operators</a></li>
    <li><a href="#unary">User-defined Unary Operators</a></li>
    <li><a href="#example">Kicking the Tires</a></li>
    <li><a href="#code">Full Code Listing</a></li>
  </ol>
</li>
<li><a href="OCamlLangImpl7.html">Chapter 7</a>: Extending the Language: Mutable
Variables / SSA Construction</li>
</ul>

<div class="doc_author">
	<p>
		Written by <a href="mailto:sabre@nondot.org">Chris Lattner</a>
		and <a href="mailto:idadesub@users.sourceforge.net">Erick Tryzelaar</a>
	</p>
</div>

<!-- *********************************************************************** -->
<h2><a name="intro">Chapter 6 Introduction</a></h2>
<!-- *********************************************************************** -->

<div>

<p>Welcome to Chapter 6 of the "<a href="index.html">Implementing a language
with LLVM</a>" tutorial.  At this point in our tutorial, we now have a fully
functional language that is fairly minimal, but also useful.  There
is still one big problem with it, however. Our language doesn't have many
useful operators (like division, logical negation, or even any comparisons
besides less-than).</p>

<p>This chapter of the tutorial takes a wild digression into adding user-defined
operators to the simple and beautiful Kaleidoscope language. This digression now
gives us a simple and ugly language in some ways, but also a powerful one at the
same time.  One of the great things about creating your own language is that you
get to decide what is good or bad.  In this tutorial we'll assume that it is
okay to use this as a way to show some interesting parsing techniques.</p>

<p>At the end of this tutorial, we'll run through an example Kaleidoscope
application that <a href="#example">renders the Mandelbrot set</a>.  This gives
an example of what you can build with Kaleidoscope and its feature set.</p>

</div>

<!-- *********************************************************************** -->
<h2><a name="idea">User-defined Operators: the Idea</a></h2>
<!-- *********************************************************************** -->

<div>

<p>
The "operator overloading" that we will add to Kaleidoscope is more general than
languages like C++.  In C++, you are only allowed to redefine existing
operators: you can't programatically change the grammar, introduce new
operators, change precedence levels, etc.  In this chapter, we will add this
capability to Kaleidoscope, which will let the user round out the set of
operators that are supported.</p>

<p>The point of going into user-defined operators in a tutorial like this is to
show the power and flexibility of using a hand-written parser.  Thus far, the parser
we have been implementing uses recursive descent for most parts of the grammar and
operator precedence parsing for the expressions.  See <a
href="OCamlLangImpl2.html">Chapter 2</a> for details.  Without using operator
precedence parsing, it would be very difficult to allow the programmer to
introduce new operators into the grammar: the grammar is dynamically extensible
as the JIT runs.</p>

<p>The two specific features we'll add are programmable unary operators (right
now, Kaleidoscope has no unary operators at all) as well as binary operators.
An example of this is:</p>

<div class="doc_code">
<pre>
# Logical unary not.
def unary!(v)
  if v then
    0
  else
    1;

# Define &gt; with the same precedence as &lt;.
def binary&gt; 10 (LHS RHS)
  RHS &lt; LHS;

# Binary "logical or", (note that it does not "short circuit")
def binary| 5 (LHS RHS)
  if LHS then
    1
  else if RHS then
    1
  else
    0;

# Define = with slightly lower precedence than relationals.
def binary= 9 (LHS RHS)
  !(LHS &lt; RHS | LHS &gt; RHS);
</pre>
</div>

<p>Many languages aspire to being able to implement their standard runtime
library in the language itself.  In Kaleidoscope, we can implement significant
parts of the language in the library!</p>

<p>We will break down implementation of these features into two parts:
implementing support for user-defined binary operators and adding unary
operators.</p>

</div>

<!-- *********************************************************************** -->
<h2><a name="binary">User-defined Binary Operators</a></h2>
<!-- *********************************************************************** -->

<div>

<p>Adding support for user-defined binary operators is pretty simple with our
current framework.  We'll first add support for the unary/binary keywords:</p>

<div class="doc_code">
<pre>
type token =
  ...
  <b>(* operators *)
  | Binary | Unary</b>

...

and lex_ident buffer = parser
  ...
      | "for" -&gt; [&lt; 'Token.For; stream &gt;]
      | "in" -&gt; [&lt; 'Token.In; stream &gt;]
      <b>| "binary" -&gt; [&lt; 'Token.Binary; stream &gt;]
      | "unary" -&gt; [&lt; 'Token.Unary; stream &gt;]</b>
</pre>
</div>

<p>This just adds lexer support for the unary and binary keywords, like we
did in <a href="OCamlLangImpl5.html#iflexer">previous chapters</a>.  One nice
thing about our current AST, is that we represent binary operators with full
generalisation by using their ASCII code as the opcode.  For our extended
operators, we'll use this same representation, so we don't need any new AST or
parser support.</p>

<p>On the other hand, we have to be able to represent the definitions of these
new operators, in the "def binary| 5" part of the function definition.  In our
grammar so far, the "name" for the function definition is parsed as the
"prototype" production and into the <tt>Ast.Prototype</tt> AST node.  To
represent our new user-defined operators as prototypes, we have to extend
the  <tt>Ast.Prototype</tt> AST node like this:</p>

<div class="doc_code">
<pre>
(* proto - This type represents the "prototype" for a function, which captures
 * its name, and its argument names (thus implicitly the number of arguments the
 * function takes). *)
type proto =
  | Prototype of string * string array
  <b>| BinOpPrototype of string * string array * int</b>
</pre>
</div>

<p>Basically, in addition to knowing a name for the prototype, we now keep track
of whether it was an operator, and if it was, what precedence level the operator
is at.  The precedence is only used for binary operators (as you'll see below,
it just doesn't apply for unary operators).  Now that we have a way to represent
the prototype for a user-defined operator, we need to parse it:</p>

<div class="doc_code">
<pre>
(* prototype
 *   ::= id '(' id* ')'
 <b>*   ::= binary LETTER number? (id, id)
 *   ::= unary LETTER number? (id) *)</b>
let parse_prototype =
  let rec parse_args accumulator = parser
    | [&lt; 'Token.Ident id; e=parse_args (id::accumulator) &gt;] -&gt; e
    | [&lt; &gt;] -&gt; accumulator
  in
  let parse_operator = parser
    | [&lt; 'Token.Unary &gt;] -&gt; "unary", 1
    | [&lt; 'Token.Binary &gt;] -&gt; "binary", 2
  in
  let parse_binary_precedence = parser
    | [&lt; 'Token.Number n &gt;] -&gt; int_of_float n
    | [&lt; &gt;] -&gt; 30
  in
  parser
  | [&lt; 'Token.Ident id;
       'Token.Kwd '(' ?? "expected '(' in prototype";
       args=parse_args [];
       'Token.Kwd ')' ?? "expected ')' in prototype" &gt;] -&gt;
      (* success. *)
      Ast.Prototype (id, Array.of_list (List.rev args))
  <b>| [&lt; (prefix, kind)=parse_operator;
       'Token.Kwd op ?? "expected an operator";
       (* Read the precedence if present. *)
       binary_precedence=parse_binary_precedence;
       'Token.Kwd '(' ?? "expected '(' in prototype";
        args=parse_args [];
       'Token.Kwd ')' ?? "expected ')' in prototype" &gt;] -&gt;
      let name = prefix ^ (String.make 1 op) in
      let args = Array.of_list (List.rev args) in

      (* Verify right number of arguments for operator. *)
      if Array.length args != kind
      then raise (Stream.Error "invalid number of operands for operator")
      else
        if kind == 1 then
          Ast.Prototype (name, args)
        else
          Ast.BinOpPrototype (name, args, binary_precedence)</b>
  | [&lt; &gt;] -&gt;
      raise (Stream.Error "expected function name in prototype")
</pre>
</div>

<p>This is all fairly straightforward parsing code, and we have already seen
a lot of similar code in the past.  One interesting part about the code above is
the couple lines that set up <tt>name</tt> for binary operators.  This builds
names like "binary@" for a newly defined "@" operator.  This then takes
advantage of the fact that symbol names in the LLVM symbol table are allowed to
have any character in them, including embedded nul characters.</p>

<p>The next interesting thing to add, is codegen support for these binary
operators.  Given our current structure, this is a simple addition of a default
case for our existing binary operator node:</p>

<div class="doc_code">
<pre>
let codegen_expr = function
  ...
  | Ast.Binary (op, lhs, rhs) -&gt;
      let lhs_val = codegen_expr lhs in
      let rhs_val = codegen_expr rhs in
      begin
        match op with
        | '+' -&gt; build_add lhs_val rhs_val "addtmp" builder
        | '-' -&gt; build_sub lhs_val rhs_val "subtmp" builder
        | '*' -&gt; build_mul lhs_val rhs_val "multmp" builder
        | '&lt;' -&gt;
            (* Convert bool 0/1 to double 0.0 or 1.0 *)
            let i = build_fcmp Fcmp.Ult lhs_val rhs_val "cmptmp" builder in
            build_uitofp i double_type "booltmp" builder
        <b>| _ -&gt;
            (* If it wasn't a builtin binary operator, it must be a user defined
             * one. Emit a call to it. *)
            let callee = "binary" ^ (String.make 1 op) in
            let callee =
              match lookup_function callee the_module with
              | Some callee -&gt; callee
              | None -&gt; raise (Error "binary operator not found!")
            in
            build_call callee [|lhs_val; rhs_val|] "binop" builder</b>
      end
</pre>
</div>

<p>As you can see above, the new code is actually really simple.  It just does
a lookup for the appropriate operator in the symbol table and generates a
function call to it.  Since user-defined operators are just built as normal
functions (because the "prototype" boils down to a function with the right
name) everything falls into place.</p>

<p>The final piece of code we are missing, is a bit of top level magic:</p>

<div class="doc_code">
<pre>
let codegen_func the_fpm = function
  | Ast.Function (proto, body) -&gt;
      Hashtbl.clear named_values;
      let the_function = codegen_proto proto in

      <b>(* If this is an operator, install it. *)
      begin match proto with
      | Ast.BinOpPrototype (name, args, prec) -&gt;
          let op = name.[String.length name - 1] in
          Hashtbl.add Parser.binop_precedence op prec;
      | _ -&gt; ()
      end;</b>

      (* Create a new basic block to start insertion into. *)
      let bb = append_block context "entry" the_function in
      position_at_end bb builder;
      ...
</pre>
</div>

<p>Basically, before codegening a function, if it is a user-defined operator, we
register it in the precedence table.  This allows the binary operator parsing
logic we already have in place to handle it.  Since we are working on a
fully-general operator precedence parser, this is all we need to do to "extend
the grammar".</p>

<p>Now we have useful user-defined binary operators.  This builds a lot
on the previous framework we built for other operators.  Adding unary operators
is a bit more challenging, because we don't have any framework for it yet - lets
see what it takes.</p>

</div>

<!-- *********************************************************************** -->
<h2><a name="unary">User-defined Unary Operators</a></h2>
<!-- *********************************************************************** -->

<div>

<p>Since we don't currently support unary operators in the Kaleidoscope
language, we'll need to add everything to support them.  Above, we added simple
support for the 'unary' keyword to the lexer.  In addition to that, we need an
AST node:</p>

<div class="doc_code">
<pre>
type expr =
  ...
  (* variant for a unary operator. *)
  | Unary of char * expr
  ...
</pre>
</div>

<p>This AST node is very simple and obvious by now.  It directly mirrors the
binary operator AST node, except that it only has one child.  With this, we
need to add the parsing logic.  Parsing a unary operator is pretty simple: we'll
add a new function to do it:</p>

<div class="doc_code">
<pre>
(* unary
 *   ::= primary
 *   ::= '!' unary *)
and parse_unary = parser
  (* If this is a unary operator, read it. *)
  | [&lt; 'Token.Kwd op when op != '(' &amp;&amp; op != ')'; operand=parse_expr &gt;] -&gt;
      Ast.Unary (op, operand)

  (* If the current token is not an operator, it must be a primary expr. *)
  | [&lt; stream &gt;] -&gt; parse_primary stream
</pre>
</div>

<p>The grammar we add is pretty straightforward here.  If we see a unary
operator when parsing a primary operator, we eat the operator as a prefix and
parse the remaining piece as another unary operator.  This allows us to handle
multiple unary operators (e.g. "!!x").  Note that unary operators can't have
ambiguous parses like binary operators can, so there is no need for precedence
information.</p>

<p>The problem with this function, is that we need to call ParseUnary from
somewhere.  To do this, we change previous callers of ParsePrimary to call
<tt>parse_unary</tt> instead:</p>

<div class="doc_code">
<pre>
(* binoprhs
 *   ::= ('+' primary)* *)
and parse_bin_rhs expr_prec lhs stream =
        ...
        <b>(* Parse the unary expression after the binary operator. *)
        let rhs = parse_unary stream in</b>
        ...

...

(* expression
 *   ::= primary binoprhs *)
and parse_expr = parser
  | [&lt; lhs=<b>parse_unary</b>; stream &gt;] -&gt; parse_bin_rhs 0 lhs stream
</pre>
</div>

<p>With these two simple changes, we are now able to parse unary operators and build the
AST for them.  Next up, we need to add parser support for prototypes, to parse
the unary operator prototype.  We extend the binary operator code above
with:</p>

<div class="doc_code">
<pre>
(* prototype
 *   ::= id '(' id* ')'
 *   ::= binary LETTER number? (id, id)
 <b>*   ::= unary LETTER number? (id)</b> *)
let parse_prototype =
  let rec parse_args accumulator = parser
    | [&lt; 'Token.Ident id; e=parse_args (id::accumulator) &gt;] -&gt; e
    | [&lt; &gt;] -&gt; accumulator
  in
  <b>let parse_operator = parser
    | [&lt; 'Token.Unary &gt;] -&gt; "unary", 1
    | [&lt; 'Token.Binary &gt;] -&gt; "binary", 2
  in</b>
  let parse_binary_precedence = parser
    | [&lt; 'Token.Number n &gt;] -&gt; int_of_float n
    | [&lt; &gt;] -&gt; 30
  in
  parser
  | [&lt; 'Token.Ident id;
       'Token.Kwd '(' ?? "expected '(' in prototype";
       args=parse_args [];
       'Token.Kwd ')' ?? "expected ')' in prototype" &gt;] -&gt;
      (* success. *)
      Ast.Prototype (id, Array.of_list (List.rev args))
  <b>| [&lt; (prefix, kind)=parse_operator;
       'Token.Kwd op ?? "expected an operator";
       (* Read the precedence if present. *)
       binary_precedence=parse_binary_precedence;
       'Token.Kwd '(' ?? "expected '(' in prototype";
        args=parse_args [];
       'Token.Kwd ')' ?? "expected ')' in prototype" &gt;] -&gt;
      let name = prefix ^ (String.make 1 op) in
      let args = Array.of_list (List.rev args) in

      (* Verify right number of arguments for operator. *)
      if Array.length args != kind
      then raise (Stream.Error "invalid number of operands for operator")
      else
        if kind == 1 then
          Ast.Prototype (name, args)
        else
          Ast.BinOpPrototype (name, args, binary_precedence)</b>
  | [&lt; &gt;] -&gt;
      raise (Stream.Error "expected function name in prototype")
</pre>
</div>

<p>As with binary operators, we name unary operators with a name that includes
the operator character.  This assists us at code generation time.  Speaking of,
the final piece we need to add is codegen support for unary operators.  It looks
like this:</p>

<div class="doc_code">
<pre>
let rec codegen_expr = function
  ...
  | Ast.Unary (op, operand) -&gt;
      let operand = codegen_expr operand in
      let callee = "unary" ^ (String.make 1 op) in
      let callee =
        match lookup_function callee the_module with
        | Some callee -&gt; callee
        | None -&gt; raise (Error "unknown unary operator")
      in
      build_call callee [|operand|] "unop" builder
</pre>
</div>

<p>This code is similar to, but simpler than, the code for binary operators.  It
is simpler primarily because it doesn't need to handle any predefined operators.
</p>

</div>

<!-- *********************************************************************** -->
<h2><a name="example">Kicking the Tires</a></h2>
<!-- *********************************************************************** -->

<div>

<p>It is somewhat hard to believe, but with a few simple extensions we've
covered in the last chapters, we have grown a real-ish language.  With this, we
can do a lot of interesting things, including I/O, math, and a bunch of other
things.  For example, we can now add a nice sequencing operator (printd is
defined to print out the specified value and a newline):</p>

<div class="doc_code">
<pre>
ready&gt; <b>extern printd(x);</b>
Read extern: declare double @printd(double)
ready&gt; <b>def binary : 1 (x y) 0;  # Low-precedence operator that ignores operands.</b>
..
ready&gt; <b>printd(123) : printd(456) : printd(789);</b>
123.000000
456.000000
789.000000
Evaluated to 0.000000
</pre>
</div>

<p>We can also define a bunch of other "primitive" operations, such as:</p>

<div class="doc_code">
<pre>
# Logical unary not.
def unary!(v)
  if v then
    0
  else
    1;

# Unary negate.
def unary-(v)
  0-v;

# Define &gt; with the same precedence as &lt;.
def binary&gt; 10 (LHS RHS)
  RHS &lt; LHS;

# Binary logical or, which does not short circuit.
def binary| 5 (LHS RHS)
  if LHS then
    1
  else if RHS then
    1
  else
    0;

# Binary logical and, which does not short circuit.
def binary&amp; 6 (LHS RHS)
  if !LHS then
    0
  else
    !!RHS;

# Define = with slightly lower precedence than relationals.
def binary = 9 (LHS RHS)
  !(LHS &lt; RHS | LHS &gt; RHS);

</pre>
</div>


<p>Given the previous if/then/else support, we can also define interesting
functions for I/O.  For example, the following prints out a character whose
"density" reflects the value passed in: the lower the value, the denser the
character:</p>

<div class="doc_code">
<pre>
ready&gt;
<b>
extern putchard(char)
def printdensity(d)
  if d &gt; 8 then
    putchard(32)  # ' '
  else if d &gt; 4 then
    putchard(46)  # '.'
  else if d &gt; 2 then
    putchard(43)  # '+'
  else
    putchard(42); # '*'</b>
...
ready&gt; <b>printdensity(1): printdensity(2): printdensity(3) :
          printdensity(4): printdensity(5): printdensity(9): putchard(10);</b>
*++..
Evaluated to 0.000000
</pre>
</div>

<p>Based on these simple primitive operations, we can start to define more
interesting things.  For example, here's a little function that solves for the
number of iterations it takes a function in the complex plane to
converge:</p>

<div class="doc_code">
<pre>
# determine whether the specific location diverges.
# Solve for z = z^2 + c in the complex plane.
def mandleconverger(real imag iters creal cimag)
  if iters &gt; 255 | (real*real + imag*imag &gt; 4) then
    iters
  else
    mandleconverger(real*real - imag*imag + creal,
                    2*real*imag + cimag,
                    iters+1, creal, cimag);

# return the number of iterations required for the iteration to escape
def mandleconverge(real imag)
  mandleconverger(real, imag, 0, real, imag);
</pre>
</div>

<p>This "z = z<sup>2</sup> + c" function is a beautiful little creature that is the basis
for computation of the <a
href="http://en.wikipedia.org/wiki/Mandelbrot_set">Mandelbrot Set</a>.  Our
<tt>mandelconverge</tt> function returns the number of iterations that it takes
for a complex orbit to escape, saturating to 255.  This is not a very useful
function by itself, but if you plot its value over a two-dimensional plane,
you can see the Mandelbrot set.  Given that we are limited to using putchard
here, our amazing graphical output is limited, but we can whip together
something using the density plotter above:</p>

<div class="doc_code">
<pre>
# compute and plot the mandlebrot set with the specified 2 dimensional range
# info.
def mandelhelp(xmin xmax xstep   ymin ymax ystep)
  for y = ymin, y &lt; ymax, ystep in (
    (for x = xmin, x &lt; xmax, xstep in
       printdensity(mandleconverge(x,y)))
    : putchard(10)
  )

# mandel - This is a convenient helper function for ploting the mandelbrot set
# from the specified position with the specified Magnification.
def mandel(realstart imagstart realmag imagmag)
  mandelhelp(realstart, realstart+realmag*78, realmag,
             imagstart, imagstart+imagmag*40, imagmag);
</pre>
</div>

<p>Given this, we can try plotting out the mandlebrot set!  Lets try it out:</p>

<div class="doc_code">
<pre>
ready&gt; <b>mandel(-2.3, -1.3, 0.05, 0.07);</b>
*******************************+++++++++++*************************************
*************************+++++++++++++++++++++++*******************************
**********************+++++++++++++++++++++++++++++****************************
*******************+++++++++++++++++++++.. ...++++++++*************************
*****************++++++++++++++++++++++.... ...+++++++++***********************
***************+++++++++++++++++++++++.....   ...+++++++++*********************
**************+++++++++++++++++++++++....     ....+++++++++********************
*************++++++++++++++++++++++......      .....++++++++*******************
************+++++++++++++++++++++.......       .......+++++++******************
***********+++++++++++++++++++....                ... .+++++++*****************
**********+++++++++++++++++.......                     .+++++++****************
*********++++++++++++++...........                    ...+++++++***************
********++++++++++++............                      ...++++++++**************
********++++++++++... ..........                        .++++++++**************
*******+++++++++.....                                   .+++++++++*************
*******++++++++......                                  ..+++++++++*************
*******++++++.......                                   ..+++++++++*************
*******+++++......                                     ..+++++++++*************
*******.... ....                                      ...+++++++++*************
*******.... .                                         ...+++++++++*************
*******+++++......                                    ...+++++++++*************
*******++++++.......                                   ..+++++++++*************
*******++++++++......                                   .+++++++++*************
*******+++++++++.....                                  ..+++++++++*************
********++++++++++... ..........                        .++++++++**************
********++++++++++++............                      ...++++++++**************
*********++++++++++++++..........                     ...+++++++***************
**********++++++++++++++++........                     .+++++++****************
**********++++++++++++++++++++....                ... ..+++++++****************
***********++++++++++++++++++++++.......       .......++++++++*****************
************+++++++++++++++++++++++......      ......++++++++******************
**************+++++++++++++++++++++++....      ....++++++++********************
***************+++++++++++++++++++++++.....   ...+++++++++*********************
*****************++++++++++++++++++++++....  ...++++++++***********************
*******************+++++++++++++++++++++......++++++++*************************
*********************++++++++++++++++++++++.++++++++***************************
*************************+++++++++++++++++++++++*******************************
******************************+++++++++++++************************************
*******************************************************************************
*******************************************************************************
*******************************************************************************
Evaluated to 0.000000
ready&gt; <b>mandel(-2, -1, 0.02, 0.04);</b>
**************************+++++++++++++++++++++++++++++++++++++++++++++++++++++
***********************++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*********************+++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
*******************+++++++++++++++++++++++++++++++++++++++++++++++++++++++++...
*****************+++++++++++++++++++++++++++++++++++++++++++++++++++++++++.....
***************++++++++++++++++++++++++++++++++++++++++++++++++++++++++........
**************++++++++++++++++++++++++++++++++++++++++++++++++++++++...........
************+++++++++++++++++++++++++++++++++++++++++++++++++++++..............
***********++++++++++++++++++++++++++++++++++++++++++++++++++........        .
**********++++++++++++++++++++++++++++++++++++++++++++++.............
********+++++++++++++++++++++++++++++++++++++++++++..................
*******+++++++++++++++++++++++++++++++++++++++.......................
******+++++++++++++++++++++++++++++++++++...........................
*****++++++++++++++++++++++++++++++++............................
*****++++++++++++++++++++++++++++...............................
****++++++++++++++++++++++++++......   .........................
***++++++++++++++++++++++++.........     ......    ...........
***++++++++++++++++++++++............
**+++++++++++++++++++++..............
**+++++++++++++++++++................
*++++++++++++++++++.................
*++++++++++++++++............ ...
*++++++++++++++..............
*+++....++++................
*..........  ...........
*
*..........  ...........
*+++....++++................
*++++++++++++++..............
*++++++++++++++++............ ...
*++++++++++++++++++.................
**+++++++++++++++++++................
**+++++++++++++++++++++..............
***++++++++++++++++++++++............
***++++++++++++++++++++++++.........     ......    ...........
****++++++++++++++++++++++++++......   .........................
*****++++++++++++++++++++++++++++...............................
*****++++++++++++++++++++++++++++++++............................
******+++++++++++++++++++++++++++++++++++...........................
*******+++++++++++++++++++++++++++++++++++++++.......................
********+++++++++++++++++++++++++++++++++++++++++++..................
Evaluated to 0.000000
ready&gt; <b>mandel(-0.9, -1.4, 0.02, 0.03);</b>
*******************************************************************************
*******************************************************************************
*******************************************************************************
**********+++++++++++++++++++++************************************************
*+++++++++++++++++++++++++++++++++++++++***************************************
+++++++++++++++++++++++++++++++++++++++++++++**********************************
++++++++++++++++++++++++++++++++++++++++++++++++++*****************************
++++++++++++++++++++++++++++++++++++++++++++++++++++++*************************
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++**********************
+++++++++++++++++++++++++++++++++.........++++++++++++++++++*******************
+++++++++++++++++++++++++++++++....   ......+++++++++++++++++++****************
+++++++++++++++++++++++++++++.......  ........+++++++++++++++++++**************
++++++++++++++++++++++++++++........   ........++++++++++++++++++++************
+++++++++++++++++++++++++++.........     ..  ...+++++++++++++++++++++**********
++++++++++++++++++++++++++...........        ....++++++++++++++++++++++********
++++++++++++++++++++++++.............       .......++++++++++++++++++++++******
+++++++++++++++++++++++.............        ........+++++++++++++++++++++++****
++++++++++++++++++++++...........           ..........++++++++++++++++++++++***
++++++++++++++++++++...........                .........++++++++++++++++++++++*
++++++++++++++++++............                  ...........++++++++++++++++++++
++++++++++++++++...............                 .............++++++++++++++++++
++++++++++++++.................                 ...............++++++++++++++++
++++++++++++..................                  .................++++++++++++++
+++++++++..................                      .................+++++++++++++
++++++........        .                               .........  ..++++++++++++
++............                                         ......    ....++++++++++
..............                                                    ...++++++++++
..............                                                    ....+++++++++
..............                                                    .....++++++++
.............                                                    ......++++++++
...........                                                     .......++++++++
.........                                                       ........+++++++
.........                                                       ........+++++++
.........                                                           ....+++++++
........                                                             ...+++++++
.......                                                              ...+++++++
                                                                    ....+++++++
                                                                   .....+++++++
                                                                    ....+++++++
                                                                    ....+++++++
                                                                    ....+++++++
Evaluated to 0.000000
ready&gt; <b>^D</b>
</pre>
</div>

<p>At this point, you may be starting to realize that Kaleidoscope is a real
and powerful language.  It may not be self-similar :), but it can be used to
plot things that are!</p>

<p>With this, we conclude the "adding user-defined operators" chapter of the
tutorial.  We have successfully augmented our language, adding the ability to
extend the language in the library, and we have shown how this can be used to
build a simple but interesting end-user application in Kaleidoscope.  At this
point, Kaleidoscope can build a variety of applications that are functional and
can call functions with side-effects, but it can't actually define and mutate a
variable itself.</p>

<p>Strikingly, variable mutation is an important feature of some
languages, and it is not at all obvious how to <a href="OCamlLangImpl7.html">add
support for mutable variables</a> without having to add an "SSA construction"
phase to your front-end.  In the next chapter, we will describe how you can
add variable mutation without building SSA in your front-end.</p>

</div>


<!-- *********************************************************************** -->
<h2><a name="code">Full Code Listing</a></h2>
<!-- *********************************************************************** -->

<div>

<p>
Here is the complete code listing for our running example, enhanced with the
if/then/else and for expressions..  To build this example, use:
</p>

<div class="doc_code">
<pre>
# Compile
ocamlbuild toy.byte
# Run
./toy.byte
</pre>
</div>

<p>Here is the code:</p>

<dl>
<dt>_tags:</dt>
<dd class="doc_code">
<pre>
&lt;{lexer,parser}.ml&gt;: use_camlp4, pp(camlp4of)
&lt;*.{byte,native}&gt;: g++, use_llvm, use_llvm_analysis
&lt;*.{byte,native}&gt;: use_llvm_executionengine, use_llvm_target
&lt;*.{byte,native}&gt;: use_llvm_scalar_opts, use_bindings
</pre>
</dd>

<dt>myocamlbuild.ml:</dt>
<dd class="doc_code">
<pre>
open Ocamlbuild_plugin;;

ocaml_lib ~extern:true "llvm";;
ocaml_lib ~extern:true "llvm_analysis";;
ocaml_lib ~extern:true "llvm_executionengine";;
ocaml_lib ~extern:true "llvm_target";;
ocaml_lib ~extern:true "llvm_scalar_opts";;

flag ["link"; "ocaml"; "g++"] (S[A"-cc"; A"g++"; A"-cclib"; A"-rdynamic"]);;
dep ["link"; "ocaml"; "use_bindings"] ["bindings.o"];;
</pre>
</dd>

<dt>token.ml:</dt>
<dd class="doc_code">
<pre>
(*===----------------------------------------------------------------------===
 * Lexer Tokens
 *===----------------------------------------------------------------------===*)

(* The lexer returns these 'Kwd' if it is an unknown character, otherwise one of
 * these others for known things. *)
type token =
  (* commands *)
  | Def | Extern

  (* primary *)
  | Ident of string | Number of float

  (* unknown *)
  | Kwd of char

  (* control *)
  | If | Then | Else
  | For | In

  (* operators *)
  | Binary | Unary
</pre>
</dd>

<dt>lexer.ml:</dt>
<dd class="doc_code">
<pre>
(*===----------------------------------------------------------------------===
 * Lexer
 *===----------------------------------------------------------------------===*)

let rec lex = parser
  (* Skip any whitespace. *)
  | [&lt; ' (' ' | '\n' | '\r' | '\t'); stream &gt;] -&gt; lex stream

  (* identifier: [a-zA-Z][a-zA-Z0-9] *)
  | [&lt; ' ('A' .. 'Z' | 'a' .. 'z' as c); stream &gt;] -&gt;
      let buffer = Buffer.create 1 in
      Buffer.add_char buffer c;
      lex_ident buffer stream

  (* number: [0-9.]+ *)
  | [&lt; ' ('0' .. '9' as c); stream &gt;] -&gt;
      let buffer = Buffer.create 1 in
      Buffer.add_char buffer c;
      lex_number buffer stream

  (* Comment until end of line. *)
  | [&lt; ' ('#'); stream &gt;] -&gt;
      lex_comment stream

  (* Otherwise, just return the character as its ascii value. *)
  | [&lt; 'c; stream &gt;] -&gt;
      [&lt; 'Token.Kwd c; lex stream &gt;]

  (* end of stream. *)
  | [&lt; &gt;] -&gt; [&lt; &gt;]

and lex_number buffer = parser
  | [&lt; ' ('0' .. '9' | '.' as c); stream &gt;] -&gt;
      Buffer.add_char buffer c;
      lex_number buffer stream
  | [&lt; stream=lex &gt;] -&gt;
      [&lt; 'Token.Number (float_of_string (Buffer.contents buffer)); stream &gt;]

and lex_ident buffer = parser
  | [&lt; ' ('A' .. 'Z' | 'a' .. 'z' | '0' .. '9' as c); stream &gt;] -&gt;
      Buffer.add_char buffer c;
      lex_ident buffer stream
  | [&lt; stream=lex &gt;] -&gt;
      match Buffer.contents buffer with
      | "def" -&gt; [&lt; 'Token.Def; stream &gt;]
      | "extern" -&gt; [&lt; 'Token.Extern; stream &gt;]
      | "if" -&gt; [&lt; 'Token.If; stream &gt;]
      | "then" -&gt; [&lt; 'Token.Then; stream &gt;]
      | "else" -&gt; [&lt; 'Token.Else; stream &gt;]
      | "for" -&gt; [&lt; 'Token.For; stream &gt;]
      | "in" -&gt; [&lt; 'Token.In; stream &gt;]
      | "binary" -&gt; [&lt; 'Token.Binary; stream &gt;]
      | "unary" -&gt; [&lt; 'Token.Unary; stream &gt;]
      | id -&gt; [&lt; 'Token.Ident id; stream &gt;]

and lex_comment = parser
  | [&lt; ' ('\n'); stream=lex &gt;] -&gt; stream
  | [&lt; 'c; e=lex_comment &gt;] -&gt; e
  | [&lt; &gt;] -&gt; [&lt; &gt;]
</pre>
</dd>

<dt>ast.ml:</dt>
<dd class="doc_code">
<pre>
(*===----------------------------------------------------------------------===
 * Abstract Syntax Tree (aka Parse Tree)
 *===----------------------------------------------------------------------===*)

(* expr - Base type for all expression nodes. *)
type expr =
  (* variant for numeric literals like "1.0". *)
  | Number of float

  (* variant for referencing a variable, like "a". *)
  | Variable of string

  (* variant for a unary operator. *)
  | Unary of char * expr

  (* variant for a binary operator. *)
  | Binary of char * expr * expr

  (* variant for function calls. *)
  | Call of string * expr array

  (* variant for if/then/else. *)
  | If of expr * expr * expr

  (* variant for for/in. *)
  | For of string * expr * expr * expr option * expr

(* proto - This type represents the "prototype" for a function, which captures
 * its name, and its argument names (thus implicitly the number of arguments the
 * function takes). *)
type proto =
  | Prototype of string * string array
  | BinOpPrototype of string * string array * int

(* func - This type represents a function definition itself. *)
type func = Function of proto * expr
</pre>
</dd>

<dt>parser.ml:</dt>
<dd class="doc_code">
<pre>
(*===---------------------------------------------------------------------===
 * Parser
 *===---------------------------------------------------------------------===*)

(* binop_precedence - This holds the precedence for each binary operator that is
 * defined *)
let binop_precedence:(char, int) Hashtbl.t = Hashtbl.create 10

(* precedence - Get the precedence of the pending binary operator token. *)
let precedence c = try Hashtbl.find binop_precedence c with Not_found -&gt; -1

(* primary
 *   ::= identifier
 *   ::= numberexpr
 *   ::= parenexpr
 *   ::= ifexpr
 *   ::= forexpr *)
let rec parse_primary = parser
  (* numberexpr ::= number *)
  | [&lt; 'Token.Number n &gt;] -&gt; Ast.Number n

  (* parenexpr ::= '(' expression ')' *)
  | [&lt; 'Token.Kwd '('; e=parse_expr; 'Token.Kwd ')' ?? "expected ')'" &gt;] -&gt; e

  (* identifierexpr
   *   ::= identifier
   *   ::= identifier '(' argumentexpr ')' *)
  | [&lt; 'Token.Ident id; stream &gt;] -&gt;
      let rec parse_args accumulator = parser
        | [&lt; e=parse_expr; stream &gt;] -&gt;
            begin parser
              | [&lt; 'Token.Kwd ','; e=parse_args (e :: accumulator) &gt;] -&gt; e
              | [&lt; &gt;] -&gt; e :: accumulator
            end stream
        | [&lt; &gt;] -&gt; accumulator
      in
      let rec parse_ident id = parser
        (* Call. *)
        | [&lt; 'Token.Kwd '(';
             args=parse_args [];
             'Token.Kwd ')' ?? "expected ')'"&gt;] -&gt;
            Ast.Call (id, Array.of_list (List.rev args))

        (* Simple variable ref. *)
        | [&lt; &gt;] -&gt; Ast.Variable id
      in
      parse_ident id stream

  (* ifexpr ::= 'if' expr 'then' expr 'else' expr *)
  | [&lt; 'Token.If; c=parse_expr;
       'Token.Then ?? "expected 'then'"; t=parse_expr;
       'Token.Else ?? "expected 'else'"; e=parse_expr &gt;] -&gt;
      Ast.If (c, t, e)

  (* forexpr
        ::= 'for' identifier '=' expr ',' expr (',' expr)? 'in' expression *)
  | [&lt; 'Token.For;
       'Token.Ident id ?? "expected identifier after for";
       'Token.Kwd '=' ?? "expected '=' after for";
       stream &gt;] -&gt;
      begin parser
        | [&lt;
             start=parse_expr;
             'Token.Kwd ',' ?? "expected ',' after for";
             end_=parse_expr;
             stream &gt;] -&gt;
            let step =
              begin parser
              | [&lt; 'Token.Kwd ','; step=parse_expr &gt;] -&gt; Some step
              | [&lt; &gt;] -&gt; None
              end stream
            in
            begin parser
            | [&lt; 'Token.In; body=parse_expr &gt;] -&gt;
                Ast.For (id, start, end_, step, body)
            | [&lt; &gt;] -&gt;
                raise (Stream.Error "expected 'in' after for")
            end stream
        | [&lt; &gt;] -&gt;
            raise (Stream.Error "expected '=' after for")
      end stream

  | [&lt; &gt;] -&gt; raise (Stream.Error "unknown token when expecting an expression.")

(* unary
 *   ::= primary
 *   ::= '!' unary *)
and parse_unary = parser
  (* If this is a unary operator, read it. *)
  | [&lt; 'Token.Kwd op when op != '(' &amp;&amp; op != ')'; operand=parse_expr &gt;] -&gt;
      Ast.Unary (op, operand)

  (* If the current token is not an operator, it must be a primary expr. *)
  | [&lt; stream &gt;] -&gt; parse_primary stream

(* binoprhs
 *   ::= ('+' primary)* *)
and parse_bin_rhs expr_prec lhs stream =
  match Stream.peek stream with
  (* If this is a binop, find its precedence. *)
  | Some (Token.Kwd c) when Hashtbl.mem binop_precedence c -&gt;
      let token_prec = precedence c in

      (* If this is a binop that binds at least as tightly as the current binop,
       * consume it, otherwise we are done. *)
      if token_prec &lt; expr_prec then lhs else begin
        (* Eat the binop. *)
        Stream.junk stream;

        (* Parse the unary expression after the binary operator. *)
        let rhs = parse_unary stream in

        (* Okay, we know this is a binop. *)
        let rhs =
          match Stream.peek stream with
          | Some (Token.Kwd c2) -&gt;
              (* If BinOp binds less tightly with rhs than the operator after
               * rhs, let the pending operator take rhs as its lhs. *)
              let next_prec = precedence c2 in
              if token_prec &lt; next_prec
              then parse_bin_rhs (token_prec + 1) rhs stream
              else rhs
          | _ -&gt; rhs
        in

        (* Merge lhs/rhs. *)
        let lhs = Ast.Binary (c, lhs, rhs) in
        parse_bin_rhs expr_prec lhs stream
      end
  | _ -&gt; lhs

(* expression
 *   ::= primary binoprhs *)
and parse_expr = parser
  | [&lt; lhs=parse_unary; stream &gt;] -&gt; parse_bin_rhs 0 lhs stream

(* prototype
 *   ::= id '(' id* ')'
 *   ::= binary LETTER number? (id, id)
 *   ::= unary LETTER number? (id) *)
let parse_prototype =
  let rec parse_args accumulator = parser
    | [&lt; 'Token.Ident id; e=parse_args (id::accumulator) &gt;] -&gt; e
    | [&lt; &gt;] -&gt; accumulator
  in
  let parse_operator = parser
    | [&lt; 'Token.Unary &gt;] -&gt; "unary", 1
    | [&lt; 'Token.Binary &gt;] -&gt; "binary", 2
  in
  let parse_binary_precedence = parser
    | [&lt; 'Token.Number n &gt;] -&gt; int_of_float n
    | [&lt; &gt;] -&gt; 30
  in
  parser
  | [&lt; 'Token.Ident id;
       'Token.Kwd '(' ?? "expected '(' in prototype";
       args=parse_args [];
       'Token.Kwd ')' ?? "expected ')' in prototype" &gt;] -&gt;
      (* success. *)
      Ast.Prototype (id, Array.of_list (List.rev args))
  | [&lt; (prefix, kind)=parse_operator;
       'Token.Kwd op ?? "expected an operator";
       (* Read the precedence if present. *)
       binary_precedence=parse_binary_precedence;
       'Token.Kwd '(' ?? "expected '(' in prototype";
        args=parse_args [];
       'Token.Kwd ')' ?? "expected ')' in prototype" &gt;] -&gt;
      let name = prefix ^ (String.make 1 op) in
      let args = Array.of_list (List.rev args) in

      (* Verify right number of arguments for operator. *)
      if Array.length args != kind
      then raise (Stream.Error "invalid number of operands for operator")
      else
        if kind == 1 then
          Ast.Prototype (name, args)
        else
          Ast.BinOpPrototype (name, args, binary_precedence)
  | [&lt; &gt;] -&gt;
      raise (Stream.Error "expected function name in prototype")

(* definition ::= 'def' prototype expression *)
let parse_definition = parser
  | [&lt; 'Token.Def; p=parse_prototype; e=parse_expr &gt;] -&gt;
      Ast.Function (p, e)

(* toplevelexpr ::= expression *)
let parse_toplevel = parser
  | [&lt; e=parse_expr &gt;] -&gt;
      (* Make an anonymous proto. *)
      Ast.Function (Ast.Prototype ("", [||]), e)

(*  external ::= 'extern' prototype *)
let parse_extern = parser
  | [&lt; 'Token.Extern; e=parse_prototype &gt;] -&gt; e
</pre>
</dd>

<dt>codegen.ml:</dt>
<dd class="doc_code">
<pre>
(*===----------------------------------------------------------------------===
 * Code Generation
 *===----------------------------------------------------------------------===*)

open Llvm

exception Error of string

let context = global_context ()
let the_module = create_module context "my cool jit"
let builder = builder context
let named_values:(string, llvalue) Hashtbl.t = Hashtbl.create 10
let double_type = double_type context

let rec codegen_expr = function
  | Ast.Number n -&gt; const_float double_type n
  | Ast.Variable name -&gt;
      (try Hashtbl.find named_values name with
        | Not_found -&gt; raise (Error "unknown variable name"))
  | Ast.Unary (op, operand) -&gt;
      let operand = codegen_expr operand in
      let callee = "unary" ^ (String.make 1 op) in
      let callee =
        match lookup_function callee the_module with
        | Some callee -&gt; callee
        | None -&gt; raise (Error "unknown unary operator")
      in
      build_call callee [|operand|] "unop" builder
  | Ast.Binary (op, lhs, rhs) -&gt;
      let lhs_val = codegen_expr lhs in
      let rhs_val = codegen_expr rhs in
      begin
        match op with
        | '+' -&gt; build_add lhs_val rhs_val "addtmp" builder
        | '-' -&gt; build_sub lhs_val rhs_val "subtmp" builder
        | '*' -&gt; build_mul lhs_val rhs_val "multmp" builder
        | '&lt;' -&gt;
            (* Convert bool 0/1 to double 0.0 or 1.0 *)
            let i = build_fcmp Fcmp.Ult lhs_val rhs_val "cmptmp" builder in
            build_uitofp i double_type "booltmp" builder
        | _ -&gt;
            (* If it wasn't a builtin binary operator, it must be a user defined
             * one. Emit a call to it. *)
            let callee = "binary" ^ (String.make 1 op) in
            let callee =
              match lookup_function callee the_module with
              | Some callee -&gt; callee
              | None -&gt; raise (Error "binary operator not found!")
            in
            build_call callee [|lhs_val; rhs_val|] "binop" builder
      end
  | Ast.Call (callee, args) -&gt;
      (* Look up the name in the module table. *)
      let callee =
        match lookup_function callee the_module with
        | Some callee -&gt; callee
        | None -&gt; raise (Error "unknown function referenced")
      in
      let params = params callee in

      (* If argument mismatch error. *)
      if Array.length params == Array.length args then () else
        raise (Error "incorrect # arguments passed");
      let args = Array.map codegen_expr args in
      build_call callee args "calltmp" builder
  | Ast.If (cond, then_, else_) -&gt;
      let cond = codegen_expr cond in

      (* Convert condition to a bool by comparing equal to 0.0 *)
      let zero = const_float double_type 0.0 in
      let cond_val = build_fcmp Fcmp.One cond zero "ifcond" builder in

      (* Grab the first block so that we might later add the conditional branch
       * to it at the end of the function. *)
      let start_bb = insertion_block builder in
      let the_function = block_parent start_bb in

      let then_bb = append_block context "then" the_function in

      (* Emit 'then' value. *)
      position_at_end then_bb builder;
      let then_val = codegen_expr then_ in

      (* Codegen of 'then' can change the current block, update then_bb for the
       * phi. We create a new name because one is used for the phi node, and the
       * other is used for the conditional branch. *)
      let new_then_bb = insertion_block builder in

      (* Emit 'else' value. *)
      let else_bb = append_block context "else" the_function in
      position_at_end else_bb builder;
      let else_val = codegen_expr else_ in

      (* Codegen of 'else' can change the current block, update else_bb for the
       * phi. *)
      let new_else_bb = insertion_block builder in

      (* Emit merge block. *)
      let merge_bb = append_block context "ifcont" the_function in
      position_at_end merge_bb builder;
      let incoming = [(then_val, new_then_bb); (else_val, new_else_bb)] in
      let phi = build_phi incoming "iftmp" builder in

      (* Return to the start block to add the conditional branch. *)
      position_at_end start_bb builder;
      ignore (build_cond_br cond_val then_bb else_bb builder);

      (* Set a unconditional branch at the end of the 'then' block and the
       * 'else' block to the 'merge' block. *)
      position_at_end new_then_bb builder; ignore (build_br merge_bb builder);
      position_at_end new_else_bb builder; ignore (build_br merge_bb builder);

      (* Finally, set the builder to the end of the merge block. *)
      position_at_end merge_bb builder;

      phi
  | Ast.For (var_name, start, end_, step, body) -&gt;
      (* Emit the start code first, without 'variable' in scope. *)
      let start_val = codegen_expr start in

      (* Make the new basic block for the loop header, inserting after current
       * block. *)
      let preheader_bb = insertion_block builder in
      let the_function = block_parent preheader_bb in
      let loop_bb = append_block context "loop" the_function in

      (* Insert an explicit fall through from the current block to the
       * loop_bb. *)
      ignore (build_br loop_bb builder);

      (* Start insertion in loop_bb. *)
      position_at_end loop_bb builder;

      (* Start the PHI node with an entry for start. *)
      let variable = build_phi [(start_val, preheader_bb)] var_name builder in

      (* Within the loop, the variable is defined equal to the PHI node. If it
       * shadows an existing variable, we have to restore it, so save it
       * now. *)
      let old_val =
        try Some (Hashtbl.find named_values var_name) with Not_found -&gt; None
      in
      Hashtbl.add named_values var_name variable;

      (* Emit the body of the loop.  This, like any other expr, can change the
       * current BB.  Note that we ignore the value computed by the body, but
       * don't allow an error *)
      ignore (codegen_expr body);

      (* Emit the step value. *)
      let step_val =
        match step with
        | Some step -&gt; codegen_expr step
        (* If not specified, use 1.0. *)
        | None -&gt; const_float double_type 1.0
      in

      let next_var = build_add variable step_val "nextvar" builder in

      (* Compute the end condition. *)
      let end_cond = codegen_expr end_ in

      (* Convert condition to a bool by comparing equal to 0.0. *)
      let zero = const_float double_type 0.0 in
      let end_cond = build_fcmp Fcmp.One end_cond zero "loopcond" builder in

      (* Create the "after loop" block and insert it. *)
      let loop_end_bb = insertion_block builder in
      let after_bb = append_block context "afterloop" the_function in

      (* Insert the conditional branch into the end of loop_end_bb. *)
      ignore (build_cond_br end_cond loop_bb after_bb builder);

      (* Any new code will be inserted in after_bb. *)
      position_at_end after_bb builder;

      (* Add a new entry to the PHI node for the backedge. *)
      add_incoming (next_var, loop_end_bb) variable;

      (* Restore the unshadowed variable. *)
      begin match old_val with
      | Some old_val -&gt; Hashtbl.add named_values var_name old_val
      | None -&gt; ()
      end;

      (* for expr always returns 0.0. *)
      const_null double_type

let codegen_proto = function
  | Ast.Prototype (name, args) | Ast.BinOpPrototype (name, args, _) -&gt;
      (* Make the function type: double(double,double) etc. *)
      let doubles = Array.make (Array.length args) double_type in
      let ft = function_type double_type doubles in
      let f =
        match lookup_function name the_module with
        | None -&gt; declare_function name ft the_module

        (* If 'f' conflicted, there was already something named 'name'. If it
         * has a body, don't allow redefinition or reextern. *)
        | Some f -&gt;
            (* If 'f' already has a body, reject this. *)
            if block_begin f &lt;&gt; At_end f then
              raise (Error "redefinition of function");

            (* If 'f' took a different number of arguments, reject. *)
            if element_type (type_of f) &lt;&gt; ft then
              raise (Error "redefinition of function with different # args");
            f
      in

      (* Set names for all arguments. *)
      Array.iteri (fun i a -&gt;
        let n = args.(i) in
        set_value_name n a;
        Hashtbl.add named_values n a;
      ) (params f);
      f

let codegen_func the_fpm = function
  | Ast.Function (proto, body) -&gt;
      Hashtbl.clear named_values;
      let the_function = codegen_proto proto in

      (* If this is an operator, install it. *)
      begin match proto with
      | Ast.BinOpPrototype (name, args, prec) -&gt;
          let op = name.[String.length name - 1] in
          Hashtbl.add Parser.binop_precedence op prec;
      | _ -&gt; ()
      end;

      (* Create a new basic block to start insertion into. *)
      let bb = append_block context "entry" the_function in
      position_at_end bb builder;

      try
        let ret_val = codegen_expr body in

        (* Finish off the function. *)
        let _ = build_ret ret_val builder in

        (* Validate the generated code, checking for consistency. *)
        Llvm_analysis.assert_valid_function the_function;

        (* Optimize the function. *)
        let _ = PassManager.run_function the_function the_fpm in

        the_function
      with e -&gt;
        delete_function the_function;
        raise e
</pre>
</dd>

<dt>toplevel.ml:</dt>
<dd class="doc_code">
<pre>
(*===----------------------------------------------------------------------===
 * Top-Level parsing and JIT Driver
 *===----------------------------------------------------------------------===*)

open Llvm
open Llvm_executionengine

(* top ::= definition | external | expression | ';' *)
let rec main_loop the_fpm the_execution_engine stream =
  match Stream.peek stream with
  | None -&gt; ()

  (* ignore top-level semicolons. *)
  | Some (Token.Kwd ';') -&gt;
      Stream.junk stream;
      main_loop the_fpm the_execution_engine stream

  | Some token -&gt;
      begin
        try match token with
        | Token.Def -&gt;
            let e = Parser.parse_definition stream in
            print_endline "parsed a function definition.";
            dump_value (Codegen.codegen_func the_fpm e);
        | Token.Extern -&gt;
            let e = Parser.parse_extern stream in
            print_endline "parsed an extern.";
            dump_value (Codegen.codegen_proto e);
        | _ -&gt;
            (* Evaluate a top-level expression into an anonymous function. *)
            let e = Parser.parse_toplevel stream in
            print_endline "parsed a top-level expr";
            let the_function = Codegen.codegen_func the_fpm e in
            dump_value the_function;

            (* JIT the function, returning a function pointer. *)
            let result = ExecutionEngine.run_function the_function [||]
              the_execution_engine in

            print_string "Evaluated to ";
            print_float (GenericValue.as_float Codegen.double_type result);
            print_newline ();
        with Stream.Error s | Codegen.Error s -&gt;
          (* Skip token for error recovery. *)
          Stream.junk stream;
          print_endline s;
      end;
      print_string "ready&gt; "; flush stdout;
      main_loop the_fpm the_execution_engine stream
</pre>
</dd>

<dt>toy.ml:</dt>
<dd class="doc_code">
<pre>
(*===----------------------------------------------------------------------===
 * Main driver code.
 *===----------------------------------------------------------------------===*)

open Llvm
open Llvm_executionengine
open Llvm_target
open Llvm_scalar_opts

let main () =
  ignore (initialize_native_target ());

  (* Install standard binary operators.
   * 1 is the lowest precedence. *)
  Hashtbl.add Parser.binop_precedence '&lt;' 10;
  Hashtbl.add Parser.binop_precedence '+' 20;
  Hashtbl.add Parser.binop_precedence '-' 20;
  Hashtbl.add Parser.binop_precedence '*' 40;    (* highest. *)

  (* Prime the first token. *)
  print_string "ready&gt; "; flush stdout;
  let stream = Lexer.lex (Stream.of_channel stdin) in

  (* Create the JIT. *)
  let the_execution_engine = ExecutionEngine.create Codegen.the_module in
  let the_fpm = PassManager.create_function Codegen.the_module in

  (* Set up the optimizer pipeline.  Start with registering info about how the
   * target lays out data structures. *)
  TargetData.add (ExecutionEngine.target_data the_execution_engine) the_fpm;

  (* Do simple "peephole" optimizations and bit-twiddling optzn. *)
  add_instruction_combination the_fpm;

  (* reassociate expressions. *)
  add_reassociation the_fpm;

  (* Eliminate Common SubExpressions. *)
  add_gvn the_fpm;

  (* Simplify the control flow graph (deleting unreachable blocks, etc). *)
  add_cfg_simplification the_fpm;

  ignore (PassManager.initialize the_fpm);

  (* Run the main "interpreter loop" now. *)
  Toplevel.main_loop the_fpm the_execution_engine stream;

  (* Print out all the generated code. *)
  dump_module Codegen.the_module
;;

main ()
</pre>
</dd>

<dt>bindings.c</dt>
<dd class="doc_code">
<pre>
#include &lt;stdio.h&gt;

/* putchard - putchar that takes a double and returns 0. */
extern double putchard(double X) {
  putchar((char)X);
  return 0;
}

/* printd - printf that takes a double prints it as "%f\n", returning 0. */
extern double printd(double X) {
  printf("%f\n", X);
  return 0;
}
</pre>
</dd>
</dl>

<a href="OCamlLangImpl7.html">Next: Extending the language: mutable variables /
SSA construction</a>
</div>

<!-- *********************************************************************** -->
<hr>
<address>
  <a href="http://jigsaw.w3.org/css-validator/check/referer"><img
  src="http://jigsaw.w3.org/css-validator/images/vcss" alt="Valid CSS!"></a>
  <a href="http://validator.w3.org/check/referer"><img
  src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01!"></a>

  <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
  <a href="mailto:idadesub@users.sourceforge.net">Erick Tryzelaar</a><br>
  <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
  Last modified: $Date: 2011-04-22 20:30:22 -0400 (Fri, 22 Apr 2011) $
</address>
</body>
</html>
