// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include <vector>
#include "base/bind.h"
#include "base/stl_util.h"
#include "base/test/scoped_feature_list.h"
#include "testing/gtest/include/gtest/gtest.h"
#include "third_party/blink/public/common/features.h"
#include "third_party/blink/public/common/origin_trials/origin_trial_policy.h"
#include "third_party/blink/public/common/origin_trials/trial_token_validator.h"
#include "third_party/blink/renderer/core/frame/local_dom_window.h"
#include "third_party/blink/renderer/core/frame/local_frame.h"
#include "third_party/blink/renderer/core/frame/settings.h"
#include "third_party/blink/renderer/core/html/html_head_element.h"
#include "third_party/blink/renderer/core/html/html_meta_element.h"
#include "third_party/blink/renderer/core/html/html_script_element.h"
#include "third_party/blink/renderer/core/html_names.h"
#include "third_party/blink/renderer/core/speculation_rules/document_speculation_rules.h"
#include "third_party/blink/renderer/core/testing/dummy_page_holder.h"
#include "third_party/blink/renderer/platform/wtf/functional.h"

namespace blink {
namespace {

constexpr char kOriginTrialPublicKey[] = {
    0x75, 0x10, 0xac, 0xf9, 0x3a, 0x1c, 0xb8, 0xa9, 0x28, 0x70, 0xd2,
    0x9a, 0xd0, 0x0b, 0x59, 0xe1, 0xac, 0x2b, 0xb7, 0xd5, 0xca, 0x1f,
    0x64, 0x90, 0x08, 0x8e, 0xa8, 0xe0, 0x56, 0x3a, 0x04, 0xd0,
};

// Generated by:
//  tools/origin_trials/generate_token.py --version 3 --expire-days 3650 \
//      https://speculationrules.test SpeculationRulesPrefetchProxy
// Token details:
//   Version: 3
//   Origin: https://speculationrules.test:443
//   Is Subdomain: None
//   Is Third Party: None
//   Usage Restriction: None
//   Feature: SpeculationRulesPrefetchProxy
//   Expiry: 1931530579 (2031-03-17 16:16:19 UTC)
//   Signature (Base64):
//   wi1W6f/KsmwaJn7GrnT8LrPRtGPkcRHwkgf6goMPozWlsFFM6tZq/jaTZCe34llBgwy2YYqzc58s3oz3sIFmAw==

constexpr char kSpeculationRulesPrefetchProxyToken[] =
    "A8ItVun/yrJsGiZ+xq50/C6z0bRj5HER8JIH+oKDD6M1pbBRTOrWav42k2Qnt+JZQY"
    "MMtmGKs3OfLN6M97CBZgMAAABxeyJvcmlnaW4iOiAiaHR0cHM6Ly9zcGVjdWxhdGlv"
    "bnJ1bGVzLnRlc3Q6NDQzIiwgImZlYXR1cmUiOiAiU3BlY3VsYXRpb25SdWxlc1ByZW"
    "ZldGNoUHJveHkiLCAiZXhwaXJ5IjogMTkzMTUzMDU3OX0=";

constexpr char kSimplePrefetchProxyRuleSet[] =
    R"({
        "prefetch": [{
          "source": "list",
          "urls": ["//example.com/index2.html"],
          "requires": ["anonymous-client-ip-when-cross-origin"]
        }]
      })";

class ScopedOriginTrialPolicy : public OriginTrialPolicy {
 public:
  ScopedOriginTrialPolicy() {
    TrialTokenValidator::SetOriginTrialPolicyGetter(WTF::BindRepeating(
        [](OriginTrialPolicy* self) { return self; }, base::Unretained(this)));
  }
  ~ScopedOriginTrialPolicy() override {
    TrialTokenValidator::ResetOriginTrialPolicyGetter();
  }
  bool IsOriginTrialsSupported() const override { return true; }
  std::vector<base::StringPiece> GetPublicKeys() const override {
    return {{kOriginTrialPublicKey, base::size(kOriginTrialPublicKey)}};
  }
  bool IsOriginSecure(const GURL& url) const override { return true; }
};

// Similar to SpeculationRuleSettest.PropagatesToDocument.
::testing::AssertionResult DocumentAcceptsRuleSet(const char* trial_token,
                                                  const char* json) {
  DummyPageHolder page_holder;
  Document& document = page_holder.GetDocument();

  // Clear the security origin and set a secure one, recomputing the security
  // state.
  SecurityContext& security_context =
      page_holder.GetFrame().DomWindow()->GetSecurityContext();
  security_context.SetSecurityOriginForTesting(nullptr);
  security_context.SetSecurityOrigin(
      SecurityOrigin::CreateFromString("https://speculationrules.test"));
  EXPECT_EQ(security_context.GetSecureContextMode(),
            SecureContextMode::kSecureContext);

  // Enable scripts so that <script> is not ignored.
  page_holder.GetFrame().GetSettings()->SetScriptEnabled(true);

  HTMLMetaElement* meta = MakeGarbageCollected<HTMLMetaElement>(document);
  meta->setAttribute(html_names::kHttpEquivAttr, "Origin-Trial");
  meta->setAttribute(html_names::kContentAttr, trial_token);
  document.head()->appendChild(meta);

  HTMLScriptElement* script =
      MakeGarbageCollected<HTMLScriptElement>(document, CreateElementFlags());
  script->setAttribute(html_names::kTypeAttr, "speculationrules");
  script->setText(json);
  document.head()->appendChild(script);

  auto* supplement = DocumentSpeculationRules::FromIfExists(document);
  return (supplement && !supplement->rule_sets().IsEmpty())
             ? ::testing::AssertionSuccess() << "a rule set was found"
             : ::testing::AssertionFailure() << "no rule set was found";
}

// Without the corresponding base::Feature, this trial token should not be
// accepted.
TEST(SpeculationRulesOriginTrialTest, RequiresBaseFeature) {
  base::test::ScopedFeatureList scoped_features;
  scoped_features.InitAndDisableFeature(
      features::kSpeculationRulesPrefetchProxy);
  ScopedOriginTrialPolicy using_test_keys;

  EXPECT_FALSE(DocumentAcceptsRuleSet(kSpeculationRulesPrefetchProxyToken,
                                      kSimplePrefetchProxyRuleSet));
}

// Without a valid origin trial token, this feature should not be exposed.
TEST(SpeculationRulesOriginTrialTest, RequiresValidToken) {
  base::test::ScopedFeatureList scoped_features;
  scoped_features.InitAndEnableFeature(
      features::kSpeculationRulesPrefetchProxy);
  ScopedOriginTrialPolicy using_test_keys;

  EXPECT_FALSE(
      DocumentAcceptsRuleSet("invalid token", kSimplePrefetchProxyRuleSet));
}

// With the feature and a matching token, speculation rules should be turned on.
TEST(SpeculationRulesOriginTrialTest, BaseFeatureAndValidTokenSuffice) {
  base::test::ScopedFeatureList scoped_features;
  scoped_features.InitAndEnableFeature(
      features::kSpeculationRulesPrefetchProxy);
  ScopedOriginTrialPolicy using_test_keys;

  EXPECT_TRUE(DocumentAcceptsRuleSet(kSpeculationRulesPrefetchProxyToken,
                                     kSimplePrefetchProxyRuleSet));
}

}  // namespace
}  // namespace blink
