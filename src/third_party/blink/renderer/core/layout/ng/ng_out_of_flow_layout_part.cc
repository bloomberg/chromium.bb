// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "third_party/blink/renderer/core/layout/ng/ng_out_of_flow_layout_part.h"

#include <math.h>

#include "third_party/blink/renderer/core/layout/deferred_shaping.h"
#include "third_party/blink/renderer/core/layout/layout_block.h"
#include "third_party/blink/renderer/core/layout/layout_box.h"
#include "third_party/blink/renderer/core/layout/layout_flexible_box.h"
#include "third_party/blink/renderer/core/layout/layout_inline.h"
#include "third_party/blink/renderer/core/layout/layout_object.h"
#include "third_party/blink/renderer/core/layout/ng/grid/ng_grid_layout_algorithm.h"
#include "third_party/blink/renderer/core/layout/ng/grid/ng_grid_placement.h"
#include "third_party/blink/renderer/core/layout/ng/inline/ng_physical_line_box_fragment.h"
#include "third_party/blink/renderer/core/layout/ng/layout_box_utils.h"
#include "third_party/blink/renderer/core/layout/ng/legacy_layout_tree_walking.h"
#include "third_party/blink/renderer/core/layout/ng/ng_absolute_utils.h"
#include "third_party/blink/renderer/core/layout/ng/ng_box_fragment_builder.h"
#include "third_party/blink/renderer/core/layout/ng/ng_constraint_space_builder.h"
#include "third_party/blink/renderer/core/layout/ng/ng_fragment.h"
#include "third_party/blink/renderer/core/layout/ng/ng_layout_result.h"
#include "third_party/blink/renderer/core/layout/ng/ng_out_of_flow_positioned_node.h"
#include "third_party/blink/renderer/core/layout/ng/ng_physical_box_fragment.h"
#include "third_party/blink/renderer/core/layout/ng/ng_physical_fragment.h"
#include "third_party/blink/renderer/core/layout/ng/ng_simplified_layout_algorithm.h"
#include "third_party/blink/renderer/core/layout/ng/ng_simplified_oof_layout_algorithm.h"
#include "third_party/blink/renderer/core/paint/paint_layer.h"
#include "third_party/blink/renderer/core/paint/paint_layer_scrollable_area.h"
#include "third_party/blink/renderer/core/style/computed_style.h"
#include "third_party/blink/renderer/platform/heap/collection_support/clear_collection_scope.h"

namespace blink {

namespace {

bool IsAnonymousContainer(const LayoutObject* layout_object) {
  const bool result = layout_object->IsAnonymousBlock() &&
                      layout_object->CanContainAbsolutePositionObjects();
  // There shouldn't be any anonymous container in `NGBlockInInline`.
  DCHECK(!(RuntimeEnabledFeatures::LayoutNGBlockInInlineEnabled() && result));
  return result;
}

// When the containing block is a split inline, Legacy and NG use different
// containers to place the OOF-positioned nodes:
//  - Legacy uses the anonymous block generated by inline.
//  - NG uses the anonymous' parent block, that contains all the anonymous
//    continuations.
// This function finds the correct anonymous parent block.
const LayoutInline* GetOOFContainingBlockFromAnonymous(
    const LayoutObject* anonymous_block,
    EPosition child_position) {
  DCHECK(IsAnonymousContainer(anonymous_block));
  DCHECK(anonymous_block->IsBox());

  // Comments and code copied from
  // LayoutBox::ContainingBlockLogicalWidthForPositioned.
  // Ensure we compute our width based on the width of our rel-pos inline
  // container rather than any anonymous block created to manage a block-flow
  // ancestor of ours in the rel-pos inline's inline flow.
  LayoutBoxModelObject* absolute_containing_block =
      To<LayoutBox>(anonymous_block)->Continuation();
  // There may be nested parallel inline continuations. We have now found the
  // innermost inline (which may not be relatively positioned). Locate the
  // inline that serves as the containing block of this box.
  while (!absolute_containing_block->CanContainOutOfFlowPositionedElement(
      child_position)) {
    absolute_containing_block =
        To<LayoutBoxModelObject>(absolute_containing_block->Container());
  }
  // Make absolute_containing_block continuation root.
  return To<LayoutInline>(absolute_containing_block->ContinuationRoot());
}

}  // namespace

NGOutOfFlowLayoutPart::NGOutOfFlowLayoutPart(
    const NGBlockNode& container_node,
    const NGConstraintSpace& container_space,
    NGBoxFragmentBuilder* container_builder)
    : NGOutOfFlowLayoutPart(container_node.IsAbsoluteContainer(),
                            container_node.IsFixedContainer(),
                            container_node.IsGrid(),
                            container_node.Style(),
                            container_space,
                            container_builder) {}

NGOutOfFlowLayoutPart::NGOutOfFlowLayoutPart(
    bool is_absolute_container,
    bool is_fixed_container,
    bool is_grid_container,
    const ComputedStyle& container_style,
    const NGConstraintSpace& container_space,
    NGBoxFragmentBuilder* container_builder,
    absl::optional<LogicalSize> initial_containing_block_fixed_size)
    : container_builder_(container_builder),
      writing_mode_(container_style.GetWritingMode()),
      default_writing_direction_(container_style.GetWritingDirection()),
      is_absolute_container_(is_absolute_container),
      is_fixed_container_(is_fixed_container),
      has_block_fragmentation_(container_space.HasBlockFragmentation()) {
  // TODO(almaher): Should we early return here in the case of block
  // fragmentation? If not, what should |allow_first_tier_oof_cache_| be set to
  // in this case?
  if (!container_builder->HasOutOfFlowPositionedCandidates() &&
      !To<LayoutBlock>(container_builder_->GetLayoutObject())
           ->HasPositionedObjects())
    return;

  // Disable first tier cache for grid layouts, as grid allows for out-of-flow
  // items to be placed in grid areas, which is complex to maintain a cache for.
  const NGBoxStrut border_scrollbar =
      container_builder->Borders() + container_builder->Scrollbar();
  allow_first_tier_oof_cache_ = border_scrollbar.IsEmpty() &&
                                !is_grid_container && !has_block_fragmentation_;
  default_containing_block_info_for_absolute_.writing_direction =
      default_writing_direction_;
  default_containing_block_info_for_fixed_.writing_direction =
      default_writing_direction_;
  if (container_builder_->HasBlockSize()) {
    default_containing_block_info_for_absolute_.rect.size =
        ShrinkLogicalSize(container_builder_->Size(), border_scrollbar);
    default_containing_block_info_for_fixed_.rect.size =
        initial_containing_block_fixed_size
            ? *initial_containing_block_fixed_size
            : default_containing_block_info_for_absolute_.rect.size;
  }
  LogicalOffset container_offset = {border_scrollbar.inline_start,
                                    border_scrollbar.block_start};
  default_containing_block_info_for_absolute_.rect.offset = container_offset;
  default_containing_block_info_for_fixed_.rect.offset = container_offset;
}

void NGOutOfFlowLayoutPart::Run(const LayoutBox* only_layout) {
  HandleFragmentation();
  const LayoutObject* current_container = container_builder_->GetLayoutObject();
  if (!container_builder_->HasOutOfFlowPositionedCandidates() &&
      !To<LayoutBlock>(current_container)->HasPositionedObjects()) {
    container_builder_
        ->AdjustFixedposContainingBlockForFragmentainerDescendants();
    container_builder_->AdjustFixedposContainingBlockForInnerMulticols();
    return;
  }

  // If the container is display-locked, then we skip the layout of descendants,
  // so we can early out immediately.
  if (current_container->ChildLayoutBlockedByDisplayLock())
    return;

  HeapVector<NGLogicalOutOfFlowPositionedNode> candidates;
  ClearCollectionScope<HeapVector<NGLogicalOutOfFlowPositionedNode>>
      clear_scope(&candidates);
  container_builder_->SwapOutOfFlowPositionedCandidates(&candidates);

  // Special case: containing block is a split inline.
  // If current container was generated by a split inline, do not position
  // OOF-positioned nodes inside this container. Let its non-anonymous parent
  // handle it. Only the parent has geometry information needed to compute
  // containing block geometry.
  // See "Special case: oof css container" comment for detailed description.
  if (candidates.size() > 0 && current_container && !only_layout &&
      IsAnonymousContainer(current_container)) {
    const LayoutInline* absolute_containing_block =
        is_absolute_container_ ? GetOOFContainingBlockFromAnonymous(
                                     current_container, EPosition::kAbsolute)
                               : nullptr;
    const LayoutInline* fixed_containing_block =
        is_fixed_container_ ? GetOOFContainingBlockFromAnonymous(
                                  current_container, EPosition::kFixed)
                            : nullptr;
    for (auto& candidate : candidates) {
      if (absolute_containing_block &&
          absolute_containing_block->CanContainOutOfFlowPositionedElement(
              candidate.Node().Style().GetPosition())) {
        candidate.inline_container.container = absolute_containing_block;
      } else if (fixed_containing_block &&
                 fixed_containing_block->CanContainOutOfFlowPositionedElement(
                     candidate.Node().Style().GetPosition())) {
        candidate.inline_container.container = fixed_containing_block;
      }
      container_builder_->AddOutOfFlowDescendant(candidate);
    }
    return;
  }

  HeapHashSet<Member<const LayoutObject>> placed_objects;
  LayoutCandidates(&candidates, only_layout, &placed_objects);

  if (only_layout)
    return;

  // If we're in a block fragmentation context, we've already ruled out the
  // possibility of having legacy objects in here. The code below would pick up
  // every OOF candidate not in placed_objects, and treat them as a legacy
  // object (even if they aren't one), while in fact it could be an NG object
  // that we have finished laying out in an earlier fragmentainer. Just bail.
  if (has_block_fragmentation_)
    return;

  wtf_size_t prev_placed_objects_size = placed_objects.size();
  bool did_get_same_object_count_once = false;
  while (SweepLegacyCandidates(&placed_objects)) {
    container_builder_->SwapOutOfFlowPositionedCandidates(&candidates);

    // We must have at least one new candidate, otherwise we shouldn't have
    // entered this branch.
    DCHECK_GT(candidates.size(), 0u);

    LayoutCandidates(&candidates, only_layout, &placed_objects);

    // Legacy currently has a bug where an OOF-positioned node is present
    // within the current node's |LayoutBlock::PositionedObjects|, however it
    // is not the containing-block for this node.
    //
    // This results in |LayoutDescendantCandidates| never performing layout on
    // any additional objects.
    wtf_size_t placed_objects_size = placed_objects.size();
    if (prev_placed_objects_size == placed_objects_size) {
      if (did_get_same_object_count_once || !has_legacy_flex_box_) {
        NOTREACHED();
        break;
      }
      // If we have an OOF legacy flex container with an (uncontained;
      // e.g. fixed inside absolute positioned) OOF flex item inside, we'll
      // allow one additional iteration, even if the object count is the
      // same. In the first iteration the objects in
      // LayoutBlock::PositionedObjects() were not in document order, and then
      // corrected afterwards (before we get here). Only allow this to happen
      // once, to avoid infinite loops for whatever reason, and good fortune.
      did_get_same_object_count_once = true;
    }
    prev_placed_objects_size = placed_objects_size;
  }
}

// Gather candidates that weren't present in the OOF candidates list.
// This occurs when a candidate is separated from container by a legacy node.
// E.g.
// <div style="position: relative;">
//   <div style="display: flex;">
//     <div style="position: absolute;"></div>
//   </div>
// </div>
// Returns false if no new candidates were found.
bool NGOutOfFlowLayoutPart::SweepLegacyCandidates(
    HeapHashSet<Member<const LayoutObject>>* placed_objects) {
  const auto* container_block =
      DynamicTo<LayoutBlock>(container_builder_->GetLayoutObject());
  if (!container_block)
    return false;
  TrackedLayoutBoxLinkedHashSet* legacy_objects =
      container_block->PositionedObjects();

  bool are_legacy_objects_already_placed = true;
  if (legacy_objects) {
    for (LayoutObject* legacy_object : *legacy_objects) {
      if (!placed_objects->Contains(legacy_object)) {
        are_legacy_objects_already_placed = false;
        break;
      }
    }
  }

  if (!legacy_objects || are_legacy_objects_already_placed) {
    if (!has_legacy_flex_box_ || performing_extra_legacy_check_)
      return false;
    // If there is an OOF legacy flex container, and PositionedObjects() are out
    // of document order (which is something that can happen in the legacy
    // engine when there's a fixed-positioned object inside an absolute-
    // positioned object - and we should just live with that and eventually get
    // rid of the legacy engine), we'll allow one more pass, in case there's a
    // fixed-positioend OOF flex item inside an absolutely-positioned OOF flex
    // container. Because at this point, PositionedObjects() should finally be
    // in correct document order. Only allow one more additional pass, though,
    // since we might get stuck in an infinite loop otherwise (for reasons
    // currently unknown).
    performing_extra_legacy_check_ = true;
  }
  bool candidate_added = false;
  for (LayoutObject* legacy_object : *legacy_objects) {
    if (placed_objects->Contains(legacy_object)) {
      if (!performing_extra_legacy_check_ || !legacy_object->NeedsLayout())
        continue;
      container_builder_->RemoveOldLegacyOOFFlexItem(*legacy_object);
    }

    // Flex OOF children may have center alignment or similar, and in order
    // to determine their static position correctly need to have a valid
    // size first.
    // We perform a pre-layout to correctly determine the static position.
    // Copied from LayoutBlock::LayoutPositionedObject
    // TODO(layout-dev): Remove this once LayoutFlexibleBox is removed.
    LayoutBox* layout_box = To<LayoutBox>(legacy_object);
    if (layout_box->Parent()->IsFlexibleBox()) {
      auto* parent = To<LayoutFlexibleBox>(layout_box->Parent());
      if (parent->SetStaticPositionForPositionedLayout(*layout_box)) {
        NGLogicalOutOfFlowPositionedNode candidate((NGBlockNode(layout_box)),
                                                   NGLogicalStaticPosition());
        NodeInfo node_info = SetupNodeInfo(candidate);
        NodeToLayout node_to_layout = {
            node_info, CalculateOffset(node_info, /* only_layout */ nullptr)};
        LayoutOOFNode(node_to_layout,
                      /* only_layout */ nullptr);
        parent->SetStaticPositionForPositionedLayout(*layout_box);
      }
    }

    // If we have a legacy OOF flex container, we'll allow some rocket science
    // to take place, as an attempt to get things laid out in correct document
    // order, or we might otherwise leave behind objects (OOF flex items)
    // needing layout.
    if (!has_legacy_flex_box_)
      has_legacy_flex_box_ = layout_box->IsFlexibleBox();

    NGLogicalStaticPosition static_position =
        LayoutBoxUtils::ComputeStaticPositionFromLegacy(
            *layout_box,
            container_builder_->Borders() + container_builder_->Scrollbar(),
            container_builder_);

    const LayoutObject* css_container = layout_box->Container();
    if (IsAnonymousContainer(css_container)) {
      css_container = GetOOFContainingBlockFromAnonymous(
          css_container, layout_box->Style()->GetPosition());
    }

    container_builder_->AddOutOfFlowLegacyCandidate(
        NGBlockNode(layout_box), static_position,
        DynamicTo<LayoutInline>(css_container));
    candidate_added = true;
  }
  return candidate_added;
}

void NGOutOfFlowLayoutPart::HandleFragmentation() {
  if (!container_builder_->IsBlockFragmentationContextRoot() ||
      has_block_fragmentation_)
    return;

  // Don't use the cache if we are handling fragmentation.
  allow_first_tier_oof_cache_ = false;

  while (container_builder_->HasOutOfFlowFragmentainerDescendants() ||
         container_builder_->HasMulticolsWithPendingOOFs()) {
    HandleMulticolsWithPendingOOFs(container_builder_);
    if (container_builder_->HasOutOfFlowFragmentainerDescendants()) {
      HeapVector<NGLogicalOutOfFlowPositionedNode> fragmentainer_descendants;
      ClearCollectionScope<HeapVector<NGLogicalOutOfFlowPositionedNode>> scope(
          &fragmentainer_descendants);
      container_builder_->SwapOutOfFlowFragmentainerDescendants(
          &fragmentainer_descendants);
      DCHECK(!fragmentainer_descendants.IsEmpty());
      LayoutUnit column_inline_progression = ColumnInlineProgression(
          container_builder_->ChildAvailableSize().inline_size,
          container_builder_->Style());
      LayoutFragmentainerDescendants(&fragmentainer_descendants,
                                     column_inline_progression);
    }
  }
  for (auto& descendant : delayed_descendants_)
    container_builder_->AddOutOfFlowFragmentainerDescendant(descendant);
}

// Retrieve the stored ContainingBlockInfo needed for placing positioned nodes.
// When fragmenting, the ContainingBlockInfo is not stored ahead of time and
// must be generated on demand. The reason being that during fragmentation, we
// wait to place positioned nodes until they've reached the fragmentation
// context root. In such cases, we cannot use default |ContainingBlockInfo|
// since the fragmentation root is not the containing block of the positioned
// nodes. Rather, we must generate their ContainingBlockInfo based on the
// |candidate.containing_block.fragment|.
const NGOutOfFlowLayoutPart::ContainingBlockInfo
NGOutOfFlowLayoutPart::GetContainingBlockInfo(
    const NGLogicalOutOfFlowPositionedNode& candidate) {
  const auto* container_object = container_builder_->GetLayoutObject();
  const auto& node_style = candidate.Node().Style();

  if (container_object->IsLayoutNGGrid()) {
    // If the out of flow item has the grid container as a containing block,
    // then we don't need to go through placement.
    const bool requires_grid_placement =
        !node_style.GridColumnStart().IsAuto() ||
        !node_style.GridColumnEnd().IsAuto() ||
        !node_style.GridRowStart().IsAuto() ||
        !node_style.GridRowEnd().IsAuto();

    if (requires_grid_placement) {
      const auto& container_style = container_builder_->Style();
      const auto& placement_data =
          To<LayoutNGGrid>(container_object)->CachedPlacementData();

      GridItemData grid_item(candidate.Node(), container_style,
                             default_writing_direction_.GetWritingMode());

      return {default_writing_direction_,
              NGGridLayoutAlgorithm::ComputeOutOfFlowItemContainingRect(
                  NGGridPlacement(container_style, placement_data),
                  container_builder_->GridLayoutData(),
                  container_builder_->Borders(),
                  {container_builder_->InlineSize(),
                   container_builder_->FragmentsTotalBlockSize()},
                  &grid_item)};
    }
  }

  if (candidate.inline_container.container) {
    const auto it =
        containing_blocks_map_.find(candidate.inline_container.container);
    DCHECK(it != containing_blocks_map_.end());
    return it->value;
  }

  if (candidate.containing_block.fragment) {
    DCHECK(container_builder_->IsBlockFragmentationContextRoot());

    const NGPhysicalFragment* containing_block_fragment =
        candidate.containing_block.fragment;
    const LayoutObject* containing_block =
        containing_block_fragment->GetLayoutObject();
    DCHECK(containing_block);
    auto it = containing_blocks_map_.find(containing_block);
    if (it != containing_blocks_map_.end())
      return it->value;

    const auto writing_direction =
        containing_block->StyleRef().GetWritingDirection();
    LogicalSize size = containing_block_fragment->Size().ConvertToLogical(
        writing_direction.GetWritingMode());
    size.block_size =
        LayoutBoxUtils::TotalBlockSize(*To<LayoutBox>(containing_block));

    const NGPhysicalBoxFragment* fragment =
        To<NGPhysicalBoxFragment>(containing_block_fragment);

    // TODO(1079031): This should eventually include scrollbar and border.
    NGBoxStrut border = fragment->Borders().ConvertToLogical(writing_direction);
    LogicalSize content_size = ShrinkLogicalSize(size, border);
    LogicalOffset container_offset =
        LogicalOffset(border.inline_start, border.block_start);
    container_offset += candidate.containing_block.offset;

    ContainingBlockInfo containing_block_info{
        writing_direction, LogicalRect(container_offset, content_size),
        candidate.containing_block.relative_offset,
        candidate.containing_block.offset};

    return containing_blocks_map_
        .insert(containing_block, containing_block_info)
        .stored_value->value;
  }

  return node_style.GetPosition() == EPosition::kAbsolute
             ? default_containing_block_info_for_absolute_
             : default_containing_block_info_for_fixed_;
}

void NGOutOfFlowLayoutPart::ComputeInlineContainingBlocks(
    const HeapVector<NGLogicalOutOfFlowPositionedNode>& candidates) {
  InlineContainingBlockUtils::InlineContainingBlockMap
      inline_container_fragments;

  for (auto& candidate : candidates) {
    if (candidate.inline_container.container &&
        !inline_container_fragments.Contains(
            candidate.inline_container.container)) {
      InlineContainingBlockUtils::InlineContainingBlockGeometry
          inline_geometry = {};
      inline_container_fragments.insert(
          candidate.inline_container.container.Get(), inline_geometry);
    }
  }

  // Fetch the inline start/end fragment geometry.
  InlineContainingBlockUtils::ComputeInlineContainerGeometry(
      &inline_container_fragments, container_builder_);

  LogicalSize container_builder_size = container_builder_->Size();
  PhysicalSize container_builder_physical_size =
      ToPhysicalSize(container_builder_size, writing_mode_);
  AddInlineContainingBlockInfo(
      inline_container_fragments,
      default_containing_block_info_for_absolute_.writing_direction,
      container_builder_physical_size);
}

void NGOutOfFlowLayoutPart::ComputeInlineContainingBlocksForFragmentainer(
    const HeapVector<NGLogicalOutOfFlowPositionedNode>& descendants) {
  struct InlineContainingBlockInfo {
    InlineContainingBlockUtils::InlineContainingBlockMap map;
    // The relative offset of the inline's containing block to the
    // fragmentation context root.
    LogicalOffset relative_offset;
    // The offset of the containing block relative to the fragmentation context
    // root (not including any relative offset).
    LogicalOffset offset_to_fragmentation_context;
  };

  HeapHashMap<Member<const LayoutBox>, InlineContainingBlockInfo>
      inline_containg_blocks;

  // Collect the inline containers by shared containing block.
  for (auto& descendant : descendants) {
    if (descendant.inline_container.container) {
      DCHECK(descendant.containing_block.fragment);
      const LayoutBox* containing_block = To<LayoutBox>(
          descendant.containing_block.fragment->GetLayoutObject());

      InlineContainingBlockUtils::InlineContainingBlockGeometry
          inline_geometry = {};
      inline_geometry.relative_offset =
          descendant.inline_container.relative_offset;
      auto it = inline_containg_blocks.find(containing_block);
      if (it != inline_containg_blocks.end()) {
        if (!it->value.map.Contains(descendant.inline_container.container)) {
          it->value.map.insert(descendant.inline_container.container.Get(),
                               inline_geometry);
        }
        continue;
      }
      InlineContainingBlockUtils::InlineContainingBlockMap inline_containers;
      inline_containers.insert(descendant.inline_container.container.Get(),
                               inline_geometry);
      InlineContainingBlockInfo inline_info{
          inline_containers,
          descendant.containing_block.relative_offset,
          descendant.containing_block.offset};
      inline_containg_blocks.insert(containing_block, inline_info);
    }
  }

  for (auto& inline_containg_block : inline_containg_blocks) {
    const LayoutBox* containing_block = inline_containg_block.key;
    InlineContainingBlockInfo& inline_info = inline_containg_block.value;

    LogicalSize size(LayoutBoxUtils::InlineSize(*containing_block),
                     LayoutBoxUtils::TotalBlockSize(*containing_block));
    PhysicalSize container_builder_physical_size =
        ToPhysicalSize(size, containing_block->StyleRef().GetWritingMode());

    // Fetch the inline start/end fragment geometry.
    InlineContainingBlockUtils::ComputeInlineContainerGeometryForFragmentainer(
        containing_block, container_builder_physical_size, &inline_info.map);

    AddInlineContainingBlockInfo(
        inline_info.map, containing_block->StyleRef().GetWritingDirection(),
        container_builder_physical_size, inline_info.relative_offset,
        inline_info.offset_to_fragmentation_context,
        /* adjust_for_fragmentation */ true);
  }
}

void NGOutOfFlowLayoutPart::AddInlineContainingBlockInfo(
    const InlineContainingBlockUtils::InlineContainingBlockMap&
        inline_container_fragments,
    const WritingDirectionMode container_writing_direction,
    PhysicalSize container_builder_size,
    LogicalOffset containing_block_relative_offset,
    LogicalOffset containing_block_offset,
    bool adjust_for_fragmentation) {
  // Transform the start/end fragments into a ContainingBlockInfo.
  for (const auto& block_info : inline_container_fragments) {
    DCHECK(block_info.value.has_value());

    // The calculation below determines the size of the inline containing block
    // rect.
    //
    // To perform this calculation we:
    // 1. Determine the start_offset "^", this is at the logical-start (wrt.
    //    default containing block), of the start fragment rect.
    // 2. Determine the end_offset "$", this is at the logical-end (wrt.
    //    default containing block), of the end  fragment rect.
    // 3. Determine the logical rectangle defined by these two offsets.
    //
    // Case 1a: Same direction, overlapping fragments.
    //      +---------------
    // ---> |^*****-------->
    //      +*----*---------
    //       *    *
    // ------*----*+
    // ----> *****$| --->
    // ------------+
    //
    // Case 1b: Different direction, overlapping fragments.
    //      +---------------
    // ---> ^******* <-----|
    //      *------*--------
    //      *      *
    // -----*------*
    // |<-- *******$ --->
    // ------------+
    //
    // Case 2a: Same direction, non-overlapping fragments.
    //             +--------
    // --------->  |^ ----->
    //             +*-------
    //              *
    // --------+    *
    // ------->|    $ --->
    // --------+
    //
    // Case 2b: Same direction, non-overlapping fragments.
    //             +--------
    // --------->  ^ <-----|
    //             *--------
    //             *
    // --------+   *
    // | <------   $  --->
    // --------+
    //
    // Note in cases [1a, 2a] we need to account for the inline borders of the
    // rectangles, where-as in [1b, 2b] we do not. This is handled by the
    // is_same_direction check(s).
    //
    // Note in cases [2a, 2b] we don't allow a "negative" containing block size,
    // we clamp negative sizes to zero.
    const ComputedStyle* inline_cb_style = block_info.key->Style();
    DCHECK(inline_cb_style);

    const auto inline_writing_direction =
        inline_cb_style->GetWritingDirection();
    NGBoxStrut inline_cb_borders = ComputeBordersForInline(*inline_cb_style);
    DCHECK_EQ(container_writing_direction.GetWritingMode(),
              inline_writing_direction.GetWritingMode());

    bool is_same_direction =
        container_writing_direction == inline_writing_direction;

    // Step 1 - determine the start_offset.
    const PhysicalRect& start_rect =
        block_info.value->start_fragment_union_rect;
    LogicalOffset start_offset = start_rect.offset.ConvertToLogical(
        container_writing_direction, container_builder_size, start_rect.size);

    // Make sure we add the inline borders, we don't need to do this in the
    // inline direction if the blocks are in opposite directions.
    start_offset.block_offset += inline_cb_borders.block_start;
    if (is_same_direction)
      start_offset.inline_offset += inline_cb_borders.inline_start;

    // Step 2 - determine the end_offset.
    const PhysicalRect& end_rect = block_info.value->end_fragment_union_rect;
    LogicalOffset end_offset = end_rect.offset.ConvertToLogical(
        container_writing_direction, container_builder_size, end_rect.size);

    // Add in the size of the fragment to get the logical end of the fragment.
    end_offset += end_rect.size.ConvertToLogical(
        container_writing_direction.GetWritingMode());

    // Make sure we subtract the inline borders, we don't need to do this in the
    // inline direction if the blocks are in opposite directions.
    end_offset.block_offset -= inline_cb_borders.block_end;
    if (is_same_direction)
      end_offset.inline_offset -= inline_cb_borders.inline_end;

    // Make sure we don't end up with a rectangle with "negative" size.
    end_offset.inline_offset =
        std::max(end_offset.inline_offset, start_offset.inline_offset);
    end_offset.block_offset =
        std::max(end_offset.block_offset, start_offset.block_offset);

    // Step 3 - determine the logical rectangle.

    // Determine the logical size of the containing block.
    LogicalSize inline_cb_size = {
        end_offset.inline_offset - start_offset.inline_offset,
        end_offset.block_offset - start_offset.block_offset};
    DCHECK_GE(inline_cb_size.inline_size, LayoutUnit());
    DCHECK_GE(inline_cb_size.block_size, LayoutUnit());

    if (adjust_for_fragmentation) {
      // When fragmenting, the containing block will not be associated with the
      // current builder. Thus, we need to adjust the start offset to take the
      // writing mode of the builder into account.
      PhysicalSize physical_size =
          ToPhysicalSize(inline_cb_size, writing_mode_);
      start_offset =
          start_offset
              .ConvertToPhysical(container_writing_direction,
                                 container_builder_size, physical_size)
              .ConvertToLogical(default_writing_direction_,
                                container_builder_size, physical_size);
    }

    // Subtract out the inline relative offset, if set, so that it can be
    // applied after fragmentation is performed on the fragmentainer
    // descendants.
    DCHECK((block_info.value->relative_offset == LogicalOffset() &&
            containing_block_relative_offset == LogicalOffset() &&
            containing_block_offset == LogicalOffset()) ||
           container_builder_->IsBlockFragmentationContextRoot());
    LogicalOffset container_offset =
        start_offset - block_info.value->relative_offset;
    LogicalOffset total_relative_offset =
        containing_block_relative_offset + block_info.value->relative_offset;

    // The offset of the container is currently relative to the containing
    // block. Add the offset of the containng block to the fragmentation context
    // root so that it is relative to the fragmentation context root, instead.
    container_offset += containing_block_offset;

    // If an OOF has an inline containing block, the OOF offset that is written
    // back to legacy is relative to the containing block of the inline rather
    // than the inline itself. |containing_block_offset| will be used when
    // calculating this OOF offset. However, there may be some relative offset
    // between the containing block and the inline container that should be
    // included in the final OOF offset that is written back to legacy. Adjust
    // for that relative offset here.
    containing_blocks_map_.insert(
        block_info.key.Get(),
        ContainingBlockInfo{
            inline_writing_direction,
            LogicalRect(container_offset, inline_cb_size),
            total_relative_offset,
            containing_block_offset - block_info.value->relative_offset});
  }
}

void NGOutOfFlowLayoutPart::LayoutCandidates(
    HeapVector<NGLogicalOutOfFlowPositionedNode>* candidates,
    const LayoutBox* only_layout,
    HeapHashSet<Member<const LayoutObject>>* placed_objects) {
  while (candidates->size() > 0) {
    if (!has_block_fragmentation_ ||
        container_builder_->IsInitialColumnBalancingPass())
      ComputeInlineContainingBlocks(*candidates);
    for (auto& candidate : *candidates) {
      LayoutBox* layout_box = candidate.box;
      if (!container_builder_->IsBlockFragmentationContextRoot())
        SaveStaticPositionOnPaintLayer(layout_box, candidate.static_position);
      if (IsContainingBlockForCandidate(candidate) &&
          (!only_layout || layout_box == only_layout)) {
        if (has_block_fragmentation_ &&
            !container_builder_->IsInitialColumnBalancingPass()) {
          // As an optimization, only populate legacy positioned objects lists
          // when inside a fragmentation context root, since otherwise we can
          // just look at the children in the fragment tree.
          if (layout_box != only_layout)
            container_builder_->InsertLegacyPositionedObject(candidate.Node());
          container_builder_->AdjustOffsetsForFragmentainerDescendant(
              candidate);
          container_builder_->AdjustFixedposContainingBlockForInnerMulticols();
          container_builder_->AddOutOfFlowFragmentainerDescendant(candidate);
          continue;
        }
        NodeInfo node_info = SetupNodeInfo(candidate);
        NodeToLayout node_to_layout = {node_info,
                                       CalculateOffset(node_info, only_layout)};
        const NGLayoutResult* result =
            LayoutOOFNode(node_to_layout, only_layout);
        container_builder_->AddResult(
            *result, result->OutOfFlowPositionedOffset(),
            /* relative_offset */ absl::nullopt, &candidate.inline_container);
        container_builder_->SetHasOutOfFlowFragmentChild(true);
        if (container_builder_->IsInitialColumnBalancingPass()) {
          container_builder_->PropagateTallestUnbreakableBlockSize(
              result->TallestUnbreakableBlockSize());
        }
        placed_objects->insert(layout_box);
      } else {
        container_builder_->AddOutOfFlowDescendant(candidate);
      }
    }
    // Sweep any candidates that might have been added.
    // This happens when an absolute container has a fixed child.
    candidates->Shrink(0);
    container_builder_->SwapOutOfFlowPositionedCandidates(candidates);
  }
}

void NGOutOfFlowLayoutPart::HandleMulticolsWithPendingOOFs(
    NGBoxFragmentBuilder* container_builder) {
  if (!container_builder->HasMulticolsWithPendingOOFs())
    return;

  NGContainerFragmentBuilder::MulticolCollection multicols_with_pending_oofs;
  container_builder->SwapMulticolsWithPendingOOFs(&multicols_with_pending_oofs);
  DCHECK(!multicols_with_pending_oofs.IsEmpty());

  while (!multicols_with_pending_oofs.IsEmpty()) {
    for (auto& multicol : multicols_with_pending_oofs)
      LayoutOOFsInMulticol(NGBlockNode(multicol.key), multicol.value);
    multicols_with_pending_oofs.clear();
    container_builder->SwapMulticolsWithPendingOOFs(
        &multicols_with_pending_oofs);
  }
}

void NGOutOfFlowLayoutPart::LayoutOOFsInMulticol(
    const NGBlockNode& multicol,
    const NGMulticolWithPendingOOFs<LogicalOffset>* multicol_info) {
  HeapVector<NGLogicalOutOfFlowPositionedNode> oof_nodes_to_layout;
  ClearCollectionScope<HeapVector<NGLogicalOutOfFlowPositionedNode>>
      oof_nodes_scope(&oof_nodes_to_layout);
  HeapVector<MulticolChildInfo> multicol_children;
  ClearCollectionScope<HeapVector<MulticolChildInfo>> multicol_scope(
      &multicol_children);

  const NGBlockBreakToken* current_column_break_token = nullptr;
  const NGBlockBreakToken* previous_multicol_break_token = nullptr;

  LayoutUnit column_inline_progression = kIndefiniteSize;
  LogicalOffset multicol_offset = multicol_info->multicol_offset;

  // Create a simplified container builder for multicol children. It cannot be
  // used to generate a fragment (since no size has been set, for one), but is
  // suitable for holding child fragmentainers while we're cloning them.
  NGConstraintSpace limited_multicol_constraint_space =
      CreateConstraintSpaceForMulticol(multicol);
  NGFragmentGeometry limited_fragment_geometry =
      CalculateInitialFragmentGeometry(limited_multicol_constraint_space,
                                       multicol);
  NGBoxFragmentBuilder limited_multicol_container_builder =
      CreateContainerBuilderForMulticol(multicol,
                                        limited_multicol_constraint_space,
                                        limited_fragment_geometry);
  // The block size that we set on the multicol builder doesn't matter since
  // we only care about the size of the fragmentainer children when laying out
  // the remaining OOFs.
  limited_multicol_container_builder.SetFragmentsTotalBlockSize(LayoutUnit());

  limited_multicol_container_builder.SetDisableOOFDescendantsPropagation();

  WritingDirectionMode writing_direction =
      multicol.Style().GetWritingDirection();
  const NGPhysicalBoxFragment* last_fragment_with_fragmentainer = nullptr;

  // Accumulate all of the pending OOF positioned nodes that are stored inside
  // |multicol|.
  for (auto& multicol_fragment : multicol.GetLayoutBox()->PhysicalFragments()) {
    const NGPhysicalBoxFragment* multicol_box_fragment =
        To<NGPhysicalBoxFragment>(&multicol_fragment);

    const ComputedStyle& style = multicol_box_fragment->Style();
    const WritingModeConverter converter(writing_direction,
                                         multicol_box_fragment->Size());
    wtf_size_t current_column_index = 0;

    if (column_inline_progression == kIndefiniteSize) {
      // TODO(almaher): This should eventually include scrollbar, as well.
      NGBoxStrut border_padding =
          multicol_box_fragment->Borders().ConvertToLogical(writing_direction) +
          multicol_box_fragment->Padding().ConvertToLogical(writing_direction);
      LayoutUnit available_inline_size =
          multicol_box_fragment->Size()
              .ConvertToLogical(writing_direction.GetWritingMode())
              .inline_size -
          border_padding.InlineSum();
      column_inline_progression =
          ColumnInlineProgression(available_inline_size, style);
    }

    // Collect the children of the multicol fragments.
    for (auto& child :
         multicol_box_fragment->GetMutableChildrenForOutOfFlow().Children()) {
      const auto* fragment = child.get();
      LogicalOffset offset =
          converter.ToLogical(child.Offset(), fragment->Size());
      if (fragment->IsFragmentainerBox()) {
        current_column_break_token =
            To<NGBlockBreakToken>(fragment->BreakToken());
        current_column_index = multicol_children.size();
        last_fragment_with_fragmentainer = multicol_box_fragment;
      }

      limited_multicol_container_builder.AddChild(
          *fragment, offset, /* margin_strut */ nullptr,
          /* is_self_collapsing */ false, /* relative_offset */ absl::nullopt,
          /* inline_container */ nullptr,
          /* adjustment_for_oof_propagation */ absl::nullopt);
      multicol_children.emplace_back(MulticolChildInfo(&child));
    }

    // If a column fragment is updated with OOF children, we may need to update
    // the reference to its break token in its parent's break token. There
    // should be at most one column break token per parent break token
    // (representing the last column laid out in that fragment). Thus, search
    // for |current_column_break_token| in |multicol_box_fragment|'s list of
    // child break tokens and update the stored MulticolChildInfo if found.
    const NGBlockBreakToken* break_token =
        To<NGBlockBreakToken>(multicol_box_fragment->BreakToken());
    if (break_token && break_token->ChildBreakTokens().size()) {
      // If there is a column break token, it will be the last item in its
      // parent's list of break tokens.
      const auto children = break_token->ChildBreakTokens();
      const NGBlockBreakToken* child_token =
          To<NGBlockBreakToken>(children[children.size() - 1].Get());
      if (child_token == current_column_break_token) {
        MulticolChildInfo& child_info = multicol_children[current_column_index];
        child_info.parent_break_token = break_token;
      }
    }

    // Convert the OOF fragmentainer descendants to the logical coordinate space
    // and store the resulting nodes inside |oof_nodes_to_layout|.
    for (const auto& descendant :
         NGFragmentedOutOfFlowData::OutOfFlowPositionedFragmentainerDescendants(
             *multicol_box_fragment)) {
      if (oof_nodes_to_layout.IsEmpty() &&
          multicol_info->fixedpos_containing_block.fragment &&
          previous_multicol_break_token) {
        // At this point, the multicol offset is the offset from the fixedpos
        // containing block to the first multicol fragment holding OOF
        // fragmentainer descendants. Update this offset such that it is the
        // offset from the fixedpos containing block to the top of the first
        // multicol fragment.
        multicol_offset.block_offset -=
            previous_multicol_break_token->ConsumedBlockSize();
      }
      const NGPhysicalFragment* containing_block_fragment =
          descendant.containing_block.fragment;
      // If the containing block is not set, that means that the inner multicol
      // was its containing block, and the OOF will be laid out elsewhere.
      if (!containing_block_fragment)
        continue;
      LogicalOffset containing_block_offset =
          converter.ToLogical(descendant.containing_block.offset,
                              containing_block_fragment->Size());
      LogicalOffset containing_block_rel_offset =
          converter.ToLogical(descendant.containing_block.relative_offset,
                              containing_block_fragment->Size());

      const NGPhysicalFragment* fixedpos_containing_block_fragment =
          descendant.fixedpos_containing_block.fragment;
      LogicalOffset fixedpos_containing_block_offset;
      LogicalOffset fixedpos_containing_block_rel_offset;
      if (fixedpos_containing_block_fragment) {
        fixedpos_containing_block_offset =
            converter.ToLogical(descendant.fixedpos_containing_block.offset,
                                fixedpos_containing_block_fragment->Size());
        fixedpos_containing_block_rel_offset = converter.ToLogical(
            descendant.fixedpos_containing_block.relative_offset,
            fixedpos_containing_block_fragment->Size());
      }

      NGInlineContainer<LogicalOffset> inline_container(
          descendant.inline_container.container,
          converter.ToLogical(descendant.inline_container.relative_offset,
                              PhysicalSize()));

      // The static position should remain relative to its containing block
      // fragment.
      const WritingModeConverter containing_block_converter(
          writing_direction, containing_block_fragment->Size());
      NGLogicalStaticPosition static_position =
          descendant.StaticPosition().ConvertToLogical(
              containing_block_converter);

      NGLogicalOutOfFlowPositionedNode node = {
          descendant.Node(),
          static_position,
          inline_container,
          /* needs_block_offset_adjustment */ false,
          NGContainingBlock<LogicalOffset>(
              containing_block_offset, containing_block_rel_offset,
              containing_block_fragment,
              descendant.containing_block.is_inside_column_spanner),
          NGContainingBlock<LogicalOffset>(
              fixedpos_containing_block_offset,
              fixedpos_containing_block_rel_offset,
              fixedpos_containing_block_fragment,
              descendant.fixedpos_containing_block.is_inside_column_spanner)};
      oof_nodes_to_layout.push_back(node);
    }
    previous_multicol_break_token = break_token;
  }
  // When an OOF's CB is a spanner (or a descendant of a spanner), we will lay
  // out the OOF at the next fragmentation context root ancestor. As such, we
  // remove any such OOF nodes from the nearest multicol's list of OOF
  // descendants during OOF node propagation, which may cause
  // |oof_nodes_to_layout| to be empty. Return early if this is the case.
  if (oof_nodes_to_layout.IsEmpty())
    return;

  DCHECK(!limited_multicol_container_builder
              .HasOutOfFlowFragmentainerDescendants());

  wtf_size_t old_fragment_count =
      limited_multicol_container_builder.Children().size();

  // Layout the OOF positioned elements inside the inner multicol.
  NGOutOfFlowLayoutPart inner_part(multicol, limited_multicol_constraint_space,
                                   &limited_multicol_container_builder);
  inner_part.allow_first_tier_oof_cache_ = false;
  inner_part.LayoutFragmentainerDescendants(
      &oof_nodes_to_layout, column_inline_progression,
      multicol_info->fixedpos_containing_block.fragment, &multicol_children);

  wtf_size_t new_fragment_count =
      limited_multicol_container_builder.Children().size();

  if (old_fragment_count != new_fragment_count) {
    DCHECK_GT(new_fragment_count, old_fragment_count);
    // We created additional fragmentainers to hold OOFs, and this is in a
    // nested fragmentation context. This means that the multicol fragment has
    // already been created, and we will therefore need to replace one of those
    // fragments. Locate the last multicol container fragment that already has
    // fragmentainers, and append all new fragmentainers there. Note that this
    // means that we may end up with more inner fragmentainers than what we
    // actually have room for (so that they'll overflow in the inline
    // direction), because we don't attempt to put fragmentainers into
    // additional multicol fragments in outer fragmentainers. This is an
    // implementation limitation which we can hopefully live with.
    DCHECK(last_fragment_with_fragmentainer);
    LayoutBox& box = *last_fragment_with_fragmentainer->MutableOwnerLayoutBox();
    wtf_size_t fragment_count = box.PhysicalFragmentCount();
    DCHECK_GE(fragment_count, 1u);
    const NGLayoutResult* old_result = nullptr;
    wtf_size_t fragment_idx = fragment_count - 1;
    do {
      old_result = box.GetLayoutResult(fragment_idx);
      if (&old_result->PhysicalFragment() == last_fragment_with_fragmentainer)
        break;
      DCHECK_GT(fragment_idx, 0u);
      fragment_idx--;
    } while (true);

    // We have located the right multicol fragment to replace. Re-use its old
    // constraint space and establish a layout algorithm to regenerate the
    // fragment.
    const NGConstraintSpace& constraint_space =
        old_result->GetConstraintSpaceForCaching();
    NGFragmentGeometry fragment_geometry =
        CalculateInitialFragmentGeometry(constraint_space, multicol);
    NGLayoutAlgorithmParams params(multicol, fragment_geometry,
                                   constraint_space);
    NGSimplifiedLayoutAlgorithm algorithm(params, *old_result,
                                          /* keep_old_size */ true);

    // First copy the fragmentainers (and other child fragments) that we already
    // had.
    algorithm.CloneOldChildren();

    WritingModeConverter converter(constraint_space.GetWritingDirection(),
                                   old_result->PhysicalFragment().Size());
    LayoutUnit additional_column_block_size;
    // Then append the new fragmentainers.
    for (wtf_size_t i = old_fragment_count; i < new_fragment_count; i++) {
      NGContainerFragmentBuilder::ChildWithOffset child =
          limited_multicol_container_builder.Children()[i];
      algorithm.AppendNewChildFragment(*child.fragment, child.offset);
      additional_column_block_size +=
          converter.ToLogical(child.fragment->Size()).block_size;
    }

    // We've already written back to legacy for |multicol|, but if we added
    // new columns to hold any OOF descendants, we need to extend the final
    // size of the legacy flow thread to encompass those new columns.
    multicol.MakeRoomForExtraColumns(additional_column_block_size);

    // Create a new multicol container fragment and replace all references to
    // the old one with this new one.
    const NGLayoutResult* new_result =
        algorithm.CreateResultAfterManualChildLayout();
    ReplaceFragment(std::move(new_result), *last_fragment_with_fragmentainer,
                    fragment_idx);
  }

  // Any descendants should have been handled in
  // LayoutFragmentainerDescendants(). However, if there were any candidates
  // found, pass them back to |container_builder_| so they can continue
  // propagating up the tree.
  DCHECK(
      !limited_multicol_container_builder.HasOutOfFlowPositionedDescendants());
  DCHECK(!limited_multicol_container_builder
              .HasOutOfFlowFragmentainerDescendants());
  limited_multicol_container_builder.TransferOutOfFlowCandidates(
      container_builder_, multicol_offset, multicol_info);

  // Handle any inner multicols with OOF descendants that may have propagated up
  // while laying out the direct OOF descendants of the current multicol.
  HandleMulticolsWithPendingOOFs(&limited_multicol_container_builder);
}

void NGOutOfFlowLayoutPart::LayoutFragmentainerDescendants(
    HeapVector<NGLogicalOutOfFlowPositionedNode>* descendants,
    LayoutUnit column_inline_progression,
    bool outer_context_has_fixedpos_container,
    HeapVector<MulticolChildInfo>* multicol_children) {
  multicol_children_ = multicol_children;
  outer_context_has_fixedpos_container_ = outer_context_has_fixedpos_container;
  DCHECK(multicol_children_ || !outer_context_has_fixedpos_container_);

  original_column_block_size_ =
      ShrinkLogicalSize(container_builder_->InitialBorderBoxSize(),
                        container_builder_->BorderScrollbarPadding())
          .block_size;

  HeapVector<HeapVector<NodeToLayout>> descendants_to_layout;
  ClearCollectionScope<HeapVector<HeapVector<NodeToLayout>>>
      descendants_to_layout_scope(&descendants_to_layout);
  while (descendants->size() > 0) {
    ComputeInlineContainingBlocksForFragmentainer(*descendants);

    // Sort the descendants by fragmentainer index in |descendants_to_layout|.
    // This will ensure that the descendants are laid out in the correct order.
    for (auto& descendant : *descendants) {
      auto* containing_block = To<LayoutBox>(
          descendant.containing_block.fragment->GetLayoutObject());
      DCHECK(containing_block);

      // We may try to lay out an OOF once we reach a column spanner. However,
      // if the containing block has not finished lay out, we should wait to
      // lay out the OOF in case its position is dependent on its containing
      // block's final size.
      if (containing_block
              ->GetPhysicalFragment(containing_block->PhysicalFragmentCount() -
                                    1)
              ->BreakToken()) {
        delayed_descendants_.push_back(descendant);
        continue;
      }
      NodeInfo node_info = SetupNodeInfo(descendant);
      NodeToLayout node_to_layout = {
          node_info, CalculateOffset(node_info, /* only_layout */ nullptr)};
      node_to_layout.containing_block_fragment =
          descendant.containing_block.fragment;
      node_to_layout.offset_info.original_offset =
          node_to_layout.offset_info.offset;

      DCHECK(node_to_layout.offset_info.block_estimate);

      // Determine in which fragmentainer this OOF element will start its layout
      // and adjust the offset to be relative to that fragmentainer.
      wtf_size_t start_index = 0;
      ComputeStartFragmentIndexAndRelativeOffset(
          node_info.default_writing_direction.GetWritingMode(),
          *node_to_layout.offset_info.block_estimate, &start_index,
          &node_to_layout.offset_info.offset);
      if (start_index >= descendants_to_layout.size())
        descendants_to_layout.resize(start_index + 1);
      descendants_to_layout[start_index].emplace_back(node_to_layout);
    }

    HeapVector<NodeToLayout> fragmented_descendants;
    ClearCollectionScope<HeapVector<NodeToLayout>> fragmented_descendants_scope(
        &fragmented_descendants);
    fragmentainer_consumed_block_size_ = LayoutUnit();
    wtf_size_t num_children = container_builder_->Children().size();

    // Layout the OOF descendants in order of fragmentainer index.
    for (wtf_size_t index = 0; index < descendants_to_layout.size(); index++) {
      const NGPhysicalFragment* fragment = nullptr;
      if (index < num_children)
        fragment = container_builder_->Children()[index].fragment;

      // Skip over any column spanners.
      if (!fragment || fragment->IsFragmentainerBox()) {
        HeapVector<NodeToLayout>& pending_descendants =
            descendants_to_layout[index];
        LayoutOOFsInFragmentainer(pending_descendants, index,
                                  column_inline_progression,
                                  &fragmented_descendants);
        // Retrieve the updated or newly added fragmentainer, and add its block
        // contribution to the consumed block size.
        fragment = container_builder_->Children()[index].fragment;
        fragmentainer_consumed_block_size_ +=
            fragment->Size()
                .ConvertToLogical(container_builder_->Style().GetWritingMode())
                .block_size;
      }

      // Extend |descendants_to_layout| if an OOF element fragments into a
      // fragmentainer at an index that does not yet exist in
      // |descendants_to_layout|.
      if (index == descendants_to_layout.size() - 1 &&
          !fragmented_descendants.IsEmpty())
        descendants_to_layout.resize(index + 2);
    }
    // Sweep any descendants that might have been bubbled up from the fragment
    // to the |container_builder_|. This happens when we have nested absolute
    // position elements.
    descendants->Shrink(0);
    descendants_to_layout.Shrink(0);
    container_builder_->SwapOutOfFlowFragmentainerDescendants(descendants);
  }
}

NGOutOfFlowLayoutPart::NodeInfo NGOutOfFlowLayoutPart::SetupNodeInfo(
    const NGLogicalOutOfFlowPositionedNode& oof_node) {
  NGBlockNode node = oof_node.Node();
  const NGPhysicalFragment* containing_block_fragment =
      oof_node.containing_block.fragment;

#if DCHECK_IS_ON()
  const LayoutObject* container =
      containing_block_fragment ? containing_block_fragment->GetLayoutObject()
                                : container_builder_->GetLayoutObject();

  // "NGOutOfFlowLayoutPart container is ContainingBlock" invariant cannot
  // be enforced for tables. Tables are special, in that the ContainingBlock
  // is TABLE, but constraint space is generated by TBODY/TR/. This happens
  // because TBODY/TR are not LayoutBlocks, but LayoutBoxModelObjects.
  DCHECK((container == node.GetLayoutBox()->ContainingBlock()) ||
         node.GetLayoutBox()->ContainingBlock()->IsTable());
#endif

  const ContainingBlockInfo container_info = GetContainingBlockInfo(oof_node);
  const ComputedStyle& oof_style = node.Style();
  const auto oof_writing_direction = oof_style.GetWritingDirection();

  LogicalSize container_content_size = container_info.rect.size;
  PhysicalSize container_physical_content_size = ToPhysicalSize(
      container_content_size, default_writing_direction_.GetWritingMode());

  // Adjust the |static_position| (which is currently relative to the default
  // container's border-box). ng_absolute_utils expects the static position to
  // be relative to the container's padding-box. Since
  // |container_info.rect.offset| is relative to its fragmentainer in this
  // case, we also need to adjust the offset to account for this.
  DCHECK(oof_node.containing_block.offset == LogicalOffset() ||
         containing_block_fragment);
  NGLogicalStaticPosition static_position = oof_node.static_position;
  static_position.offset -=
      container_info.rect.offset - oof_node.containing_block.offset;

  NGLogicalStaticPosition oof_static_position =
      static_position
          .ConvertToPhysical(
              {default_writing_direction_, container_physical_content_size})
          .ConvertToLogical(
              {oof_writing_direction, container_physical_content_size});

  // Need a constraint space to resolve offsets.
  NGConstraintSpaceBuilder builder(default_writing_direction_.GetWritingMode(),
                                   oof_writing_direction,
                                   /* is_new_fc */ true);
  builder.SetAvailableSize(container_content_size);
  builder.SetPercentageResolutionSize(container_content_size);

  if (container_builder_->IsInitialColumnBalancingPass()) {
    // The |fragmentainer_offset_delta| will not make a difference in the
    // initial column balancing pass.
    SetupSpaceBuilderForFragmentation(
        *container_builder_->ConstraintSpace(), node,
        /* fragmentainer_offset_delta */ LayoutUnit(), &builder,
        /* is_new_fc */ true,
        /* requires_content_before_breaking */ false);
  }

  DCHECK(!oof_node.fixedpos_containing_block.fragment ||
         containing_block_fragment);
  DCHECK(oof_node.fixedpos_containing_block.offset == LogicalOffset() ||
         oof_node.fixedpos_containing_block.fragment);

  return NodeInfo(node, builder.ToConstraintSpace(), oof_static_position,
                  container_physical_content_size, container_info,
                  default_writing_direction_,
                  /* is_fragmentainer_descendant */ containing_block_fragment,
                  oof_node.fixedpos_containing_block,
                  oof_node.inline_container.container);
}

const NGLayoutResult* NGOutOfFlowLayoutPart::LayoutOOFNode(
    NodeToLayout& oof_node_to_layout,
    const LayoutBox* only_layout,
    const NGConstraintSpace* fragmentainer_constraint_space) {
  const NodeInfo& node_info = oof_node_to_layout.node_info;
  OffsetInfo& offset_info = oof_node_to_layout.offset_info;
  if (offset_info.has_cached_layout_result) {
    DCHECK(offset_info.initial_layout_result);
    return offset_info.initial_layout_result;
  }

  NGBoxStrut scrollbars_before =
      ComputeScrollbarsForNonAnonymous(node_info.node);
  const NGLayoutResult* layout_result =
      Layout(oof_node_to_layout, fragmentainer_constraint_space);
  NGBoxStrut scrollbars_after =
      ComputeScrollbarsForNonAnonymous(node_info.node);

  // Since out-of-flow positioning sets up a constraint space with fixed
  // inline-size, the regular layout code (|NGBlockNode::Layout()|) cannot
  // re-layout if it discovers that a scrollbar was added or removed. Handle
  // that situation here. The assumption is that if intrinsic logical widths are
  // dirty after layout, AND its inline-size depends on the intrinsic logical
  // widths, it means that scrollbars appeared or disappeared.
  if (node_info.node.GetLayoutBox()->IntrinsicLogicalWidthsDirty() &&
      offset_info.inline_size_depends_on_min_max_sizes) {
    WritingDirectionMode writing_mode_direction =
        node_info.node.Style().GetWritingDirection();
    bool freeze_horizontal = false, freeze_vertical = false;
    // If we're in a measure pass, freeze both scrollbars right away, to avoid
    // quadratic time complexity for deeply nested flexboxes.
    if (container_builder_->ConstraintSpace() &&
        container_builder_->ConstraintSpace()->CacheSlot() ==
            NGCacheSlot::kMeasure)
      freeze_horizontal = freeze_vertical = true;
    do {
      // Freeze any scrollbars that appeared, and relayout. Repeat until both
      // have appeared, or until the scrollbar situation doesn't change,
      // whichever comes first.
      AddScrollbarFreeze(scrollbars_before, scrollbars_after,
                         writing_mode_direction, &freeze_horizontal,
                         &freeze_vertical);
      scrollbars_before = scrollbars_after;
      PaintLayerScrollableArea::FreezeScrollbarsRootScope freezer(
          *node_info.node.GetLayoutBox(), freeze_horizontal, freeze_vertical);

      if (!IsResumingLayout(oof_node_to_layout.break_token)) {
        // The offset itself does not need to be recalculated. However, the
        // |node_dimensions| and |initial_layout_result| may need to be updated,
        // so recompute the OffsetInfo.
        //
        // Only do this if we're currently building the first fragment of the
        // OOF. If we're resuming after a fragmentainer break, we can't update
        // our intrinsic inline-size. First of all, the intrinsic inline-size
        // should be the same across all fragments [1], and besides, this
        // operation would lead to performing a non-fragmented layout pass (to
        // measure intrinsic block-size; see IntrinsicBlockSizeFunc in
        // ComputeOutOfFlowBlockDimensions()), which in turn would overwrite the
        // result of the first fragment entry in LayoutBox without a break
        // token, causing major confusion everywhere.
        //
        // [1] https://drafts.csswg.org/css-break/#varying-size-boxes
        offset_info = CalculateOffset(node_info, only_layout,
                                      /* is_first_run */ false);
      }

      layout_result =
          Layout(oof_node_to_layout, fragmentainer_constraint_space);

      scrollbars_after = ComputeScrollbarsForNonAnonymous(node_info.node);
      DCHECK(!freeze_horizontal || !freeze_vertical ||
             scrollbars_after == scrollbars_before);
    } while (scrollbars_after != scrollbars_before);
  }

  return layout_result;
}

NGOutOfFlowLayoutPart::OffsetInfo NGOutOfFlowLayoutPart::CalculateOffset(
    const NodeInfo& node_info,
    const LayoutBox* only_layout,
    bool is_first_run) {
  OffsetInfo offset_info;
  const ComputedStyle& candidate_style = node_info.node.Style();
  const WritingDirectionMode candidate_writing_direction =
      candidate_style.GetWritingDirection();
  const auto container_writing_direction =
      node_info.container_info.writing_direction;
  const LogicalSize container_content_size_in_candidate_writing_mode =
      node_info.container_physical_content_size.ConvertToLogical(
          candidate_writing_direction.GetWritingMode());

  // Determine if we need to actually run the full OOF-positioned sizing, and
  // positioning algorithm.
  //
  // The first-tier cache compares the given available-size. However we can't
  // reuse the result if the |ContainingBlockInfo::container_offset| may change.
  // This can occur when:
  //  - The default containing-block has borders and/or scrollbars.
  //  - The candidate has an inline container (instead of the default
  //    containing-block).
  // Note: Only check for cache results if this is our first layout pass.
  if (is_first_run && allow_first_tier_oof_cache_ &&
      !node_info.inline_container) {
    if (const NGLayoutResult* cached_result =
            node_info.node.CachedLayoutResultForOutOfFlowPositioned(
                container_content_size_in_candidate_writing_mode)) {
      offset_info.initial_layout_result = cached_result;
      offset_info.has_cached_layout_result = true;
      return offset_info;
    }
  }

  const NGBoxStrut border_padding =
      ComputeBorders(node_info.constraint_space, node_info.node) +
      ComputePadding(node_info.constraint_space, candidate_style);

  absl::optional<LogicalSize> replaced_size;
  if (node_info.node.IsReplaced()) {
    replaced_size = ComputeReplacedSize(
        node_info.node, node_info.constraint_space, border_padding);
  }

  offset_info.inline_size_depends_on_min_max_sizes =
      ComputeOutOfFlowInlineDimensions(
          node_info.node, node_info.constraint_space, border_padding,
          node_info.static_position, replaced_size, container_writing_direction,
          &offset_info.node_dimensions);

  // We may have already pre-computed our block-dimensions when determining
  // our min/max sizes, only run if needed.
  if (offset_info.node_dimensions.size.block_size == kIndefiniteSize) {
    offset_info.initial_layout_result = ComputeOutOfFlowBlockDimensions(
        node_info.node, node_info.constraint_space, border_padding,
        node_info.static_position, replaced_size, container_writing_direction,
        &offset_info.node_dimensions);
  }
  offset_info.block_estimate = offset_info.node_dimensions.size.block_size;

  // In some cases we will need the fragment size in order to calculate the
  // offset. We may have to lay out to get the fragment size. For block
  // fragmentation, we *need* to know the block-offset before layout. In other
  // words, in that case, we may have to lay out, calculate the offset, and
  // then lay out again at the correct block-offset.
  offset_info.block_size_depends_on_layout = offset_info.initial_layout_result;

  // Calculate the offsets.
  NGBoxStrut inset = offset_info.node_dimensions.inset
                         .ConvertToPhysical(candidate_writing_direction)
                         .ConvertToLogical(node_info.default_writing_direction);

  // |inset| is relative to the container's padding-box. Convert this to being
  // relative to the default container's border-box.
  offset_info.offset = node_info.container_info.rect.offset;
  offset_info.offset.inline_offset += inset.inline_start;
  offset_info.offset.block_offset += inset.block_start;

  if (!only_layout && !container_builder_->IsBlockFragmentationContextRoot()) {
    // OOFs contained by an inline that's been split into continuations are
    // special, as their offset is relative to a fragment that's not the same as
    // their containing NG fragment; take a look inside
    // AdjustOffsetForSplitInline() for further details. This doesn't apply if
    // block fragmentation is involved, though, since all OOFs are then child
    // fragments of the nearest fragmentainer.
    AdjustOffsetForSplitInline(node_info.node, container_builder_,
                               offset_info.offset);
  }

  return offset_info;
}

const NGLayoutResult* NGOutOfFlowLayoutPart::Layout(
    const NodeToLayout& oof_node_to_layout,
    const NGConstraintSpace* fragmentainer_constraint_space) {
  const NodeInfo& node_info = oof_node_to_layout.node_info;
  const WritingDirectionMode candidate_writing_direction =
      node_info.node.Style().GetWritingDirection();
  LogicalSize container_content_size_in_candidate_writing_mode =
      node_info.container_physical_content_size.ConvertToLogical(
          candidate_writing_direction.GetWritingMode());
  const OffsetInfo& offset_info = oof_node_to_layout.offset_info;
  LogicalOffset offset = offset_info.offset;

  // Reset the |layout_result| computed earlier to allow fragmentation in the
  // next layout pass, if needed.
  const NGLayoutResult* layout_result = !fragmentainer_constraint_space
                                            ? offset_info.initial_layout_result
                                            : nullptr;

  // Skip this step if we produced a fragment that can be reused when
  // estimating the block-size.
  if (!layout_result) {
    bool should_use_fixed_block_size = !!offset_info.block_estimate;
    if (fragmentainer_constraint_space)
      should_use_fixed_block_size &= !offset_info.block_size_depends_on_layout;

    layout_result = GenerateFragment(
        node_info.node, container_content_size_in_candidate_writing_mode,
        offset_info.block_estimate, offset_info.node_dimensions,
        offset.block_offset, oof_node_to_layout.break_token,
        fragmentainer_constraint_space, should_use_fixed_block_size);
  }

  if (layout_result->Status() != NGLayoutResult::kSuccess) {
    DCHECK_EQ(layout_result->Status(),
              NGLayoutResult::kOutOfFragmentainerSpace);
    return layout_result;
  }

  if (node_info.node.GetLayoutBox()->IsLayoutNGObject()) {
    To<LayoutBlock>(node_info.node.GetLayoutBox())
        ->SetIsLegacyInitiatedOutOfFlowLayout(false);
  }
  // Legacy grid and flexbox handle OOF-positioned margins on their own, and
  // break if we set them here.
  if (!container_builder_->GetLayoutObject()
           ->Style()
           ->IsDisplayFlexibleOrGridBox()) {
    node_info.node.GetLayoutBox()->SetMargin(
        offset_info.node_dimensions.margins.ConvertToPhysical(
            candidate_writing_direction));
  }

  layout_result->GetMutableForOutOfFlow().SetOutOfFlowPositionedOffset(
      offset, allow_first_tier_oof_cache_);

  return layout_result;
}

bool NGOutOfFlowLayoutPart::IsContainingBlockForCandidate(
    const NGLogicalOutOfFlowPositionedNode& candidate) {
  // Column boxes are not allowed to be containing blocks.
  if (container_builder_->IsFragmentainerBoxType())
    return false;

  EPosition position = candidate.Node().Style().GetPosition();

  // Candidates whose containing block is inline are always positioned inside
  // closest parent block flow.
  if (candidate.inline_container.container) {
    DCHECK(candidate.inline_container.container
               ->CanContainOutOfFlowPositionedElement(position));
    return container_builder_->GetLayoutObject() ==
           candidate.box->ContainingBlock();
  }
  return (is_absolute_container_ && position == EPosition::kAbsolute) ||
         (is_fixed_container_ && position == EPosition::kFixed);
}

// The fragment is generated in one of these two scenarios:
// 1. To estimate candidate's block size, in this case block_size is
//    container's available size.
// 2. To compute final fragment, when block size is known from the absolute
//    position calculation.
const NGLayoutResult* NGOutOfFlowLayoutPart::GenerateFragment(
    NGBlockNode node,
    const LogicalSize& container_content_size_in_candidate_writing_mode,
    const absl::optional<LayoutUnit>& block_estimate,
    const NGLogicalOutOfFlowDimensions& node_dimensions,
    const LayoutUnit block_offset,
    const NGBlockBreakToken* break_token,
    const NGConstraintSpace* fragmentainer_constraint_space,
    bool should_use_fixed_block_size) {
  const auto& style = node.Style();

  LayoutUnit inline_size = node_dimensions.size.inline_size;
  LayoutUnit block_size = block_estimate.value_or(
      container_content_size_in_candidate_writing_mode.block_size);

  LogicalSize available_size(inline_size, block_size);

  // As the |block_estimate| is always in the node's writing mode, we build the
  // constraint space in the node's writing mode.
  NGConstraintSpaceBuilder builder(
      style.GetWritingMode(), style.GetWritingDirection(),
      /* is_new_fc */ true,
      /* requires_content_before_breaking */ false);
  builder.SetAvailableSize(available_size);
  builder.SetPercentageResolutionSize(
      container_content_size_in_candidate_writing_mode);
  builder.SetIsFixedInlineSize(true);
  if (should_use_fixed_block_size)
    builder.SetIsFixedBlockSize(true);
  if (fragmentainer_constraint_space) {
    // Unlike in-flow elements, OOFs are never pushed to the next fragmentainer
    // even if there's monolithic content that doesn't fit inside. See
    // RequiresContentBeforeBreaking(), which we need to call for in-flow
    // elements. For OOFs we can just pass true unconditionally.
    bool requires_content_before_breaking = true;

    SetupSpaceBuilderForFragmentation(
        *fragmentainer_constraint_space, node, block_offset, &builder,
        /* is_new_fc */ true, requires_content_before_breaking);
  } else if (container_builder_->IsInitialColumnBalancingPass()) {
    SetupSpaceBuilderForFragmentation(
        *container_builder_->ConstraintSpace(), node, block_offset, &builder,
        /* is_new_fc */ true,
        /* requires_content_before_breaking */ false);
  }
  DeferredShapingMinimumTopScope minimum_top_scope(node, block_offset);
  NGConstraintSpace space = builder.ToConstraintSpace();

  return node.Layout(space, break_token);
}

void NGOutOfFlowLayoutPart::LayoutOOFsInFragmentainer(
    HeapVector<NodeToLayout>& pending_descendants,
    wtf_size_t index,
    LayoutUnit column_inline_progression,
    HeapVector<NodeToLayout>* fragmented_descendants) {
  wtf_size_t num_children = container_builder_->Children().size();
  bool is_new_fragment = index >= num_children;

  DCHECK(fragmented_descendants);
  HeapVector<NodeToLayout> descendants_continued;
  ClearCollectionScope<HeapVector<NodeToLayout>> descendants_continued_scope(
      &descendants_continued);
  std::swap(*fragmented_descendants, descendants_continued);

  // If |index| is greater than the number of current children, and there are
  // no OOF children to be added, we will still need to add an empty
  // fragmentainer in its place. Otherwise, return early since there is no work
  // to do.
  if (pending_descendants.IsEmpty() && descendants_continued.IsEmpty() &&
      !is_new_fragment)
    return;

  const NGConstraintSpace& space = GetFragmentainerConstraintSpace(index);

  // If we are a new fragment, find a non-spanner fragmentainer as a basis.
  wtf_size_t original_index = index;
  while (
      index >= num_children ||
      !container_builder_->Children()[index].fragment->IsFragmentainerBox()) {
    DCHECK_GT(num_children, 0u);
    index--;
  }

  const auto& fragmentainer = container_builder_->Children()[index];
  DCHECK(fragmentainer.fragment->IsFragmentainerBox());
  const NGBlockNode& node = container_builder_->Node();
  const auto* fragment =
      To<NGPhysicalBoxFragment>(fragmentainer.fragment.Get());
  NGFragmentGeometry fragment_geometry =
      CalculateInitialFragmentGeometry(space, node);

  // If the last existing fragmentainer does not have a break token, and we will
  // need to add a new subsequent fragmentainer to hold an OOF, create a break
  // token for the old fragmentainer now.
  if (is_new_fragment && !fragment->BreakToken()) {
    const NGBlockBreakToken* previous_break_token =
        PreviousFragmentainerBreakToken(*container_builder_, index);
    NGLayoutAlgorithmParams params(node, fragment_geometry, space,
                                   previous_break_token,
                                   /* early_break */ nullptr);
    NGSimplifiedOOFLayoutAlgorithm algorithm(params, *fragment,
                                             /* is_new_fragment */ false,
                                             /* should_break_for_oof */ true);
    ReplaceFragmentainer(index, fragmentainer.offset,
                         /* create_new_fragment */ false, &algorithm);
    fragment = To<NGPhysicalBoxFragment>(
        container_builder_->Children()[index].fragment.Get());
  }

  LogicalOffset fragmentainer_offset = UpdatedFragmentainerOffset(
      fragmentainer.offset, index, column_inline_progression, is_new_fragment);

  const NGBlockBreakToken* previous_break_token =
      PreviousFragmentainerBreakToken(*container_builder_, original_index);
  NGLayoutAlgorithmParams params(node, fragment_geometry, space,
                                 previous_break_token,
                                 /* early_break */ nullptr);

  // |algorithm| corresponds to the "mutable copy" of our original
  // fragmentainer. As long as this "copy" hasn't been laid out via
  // NGSimplifiedOOFLayoutAlgorithm::Layout, we can append new items to it.
  NGSimplifiedOOFLayoutAlgorithm algorithm(params, *fragment, is_new_fragment);

  // Layout any OOF elements that are a continuation of layout first.
  for (auto& descendant : descendants_continued) {
    AddOOFToFragmentainer(descendant, &space, fragmentainer_offset, index,
                          &algorithm, fragmented_descendants);
  }
  // Once we've laid out the OOF elements that are a continuation of layout, we
  // can layout the OOF elements that start layout in the current fragmentainer.
  for (auto& descendant : pending_descendants) {
    AddOOFToFragmentainer(descendant, &space, fragmentainer_offset, index,
                          &algorithm, fragmented_descendants);
  }

  // Finalize layout on the cloned fragmentainer and replace all existing
  // references to the old result.
  ReplaceFragmentainer(index, fragmentainer_offset, is_new_fragment,
                       &algorithm);
}

void NGOutOfFlowLayoutPart::AddOOFToFragmentainer(
    NodeToLayout& descendant,
    const NGConstraintSpace* fragmentainer_space,
    LogicalOffset fragmentainer_offset,
    wtf_size_t index,
    NGSimplifiedOOFLayoutAlgorithm* algorithm,
    HeapVector<NodeToLayout>* fragmented_descendants) {
  const NGLayoutResult* result =
      LayoutOOFNode(descendant, /* only_layout */ nullptr, fragmentainer_space);

  if (result->Status() != NGLayoutResult::kSuccess) {
    DCHECK_EQ(result->Status(), NGLayoutResult::kOutOfFragmentainerSpace);
    // If we're out of space, continue layout in the next fragmentainer.
    NodeToLayout fragmented_descendant = descendant;
    fragmented_descendant.offset_info.offset.block_offset = LayoutUnit();
    fragmented_descendants->emplace_back(fragmented_descendant);
    return;
  }

  // Apply the relative positioned offset now that fragmentation is complete.
  LogicalOffset oof_offset = result->OutOfFlowPositionedOffset();
  LogicalOffset relative_offset =
      descendant.node_info.container_info.relative_offset;
  LogicalOffset adjusted_offset = oof_offset + relative_offset;

  // In the case where an OOF descendant of |descendant| has its containing
  // block outside the current fragmentation context, we will want to apply an
  // additional offset to |oof_offset| in PropagateOOFPositionedInfo() such that
  // it's the offset relative to the current builder rather than the offset such
  // that all fragmentainers are stacked on top of each other.
  LogicalOffset offset_adjustment = fragmentainer_offset;

  result->GetMutableForOutOfFlow().SetOutOfFlowPositionedOffset(
      adjusted_offset, allow_first_tier_oof_cache_);

  LogicalOffset additional_fixedpos_offset;
  if (descendant.node_info.fixedpos_containing_block.fragment) {
    additional_fixedpos_offset =
        descendant.offset_info.original_offset -
        descendant.node_info.fixedpos_containing_block.offset;
    // Currently, |additional_fixedpos_offset| is the offset from the top of
    // |descendant| to the fixedpos containing block. Adjust this so that it
    // includes the block contribution of |descendant| from previous
    // fragmentainers. This ensures that any fixedpos descendants in the current
    // fragmentainer have the correct static position.
    if (descendant.break_token) {
      additional_fixedpos_offset.block_offset +=
          descendant.break_token->ConsumedBlockSize();
    }
  } else if (outer_context_has_fixedpos_container_) {
    // If the fixedpos containing block is in an outer fragmentation context,
    // we should adjust any fixedpos static positions such that they are
    // relative to the top of the inner multicol. These will eventually be
    // updated again with the offset from the multicol to the fixedpos
    // containing block such that the static positions are relative to the
    // containing block.
    DCHECK(multicol_children_);
    for (wtf_size_t i = std::min(index, multicol_children_->size()); i > 0u;
         i--) {
      MulticolChildInfo& column_info = (*multicol_children_)[i - 1];
      if (column_info.parent_break_token) {
        additional_fixedpos_offset.block_offset +=
            column_info.parent_break_token->ConsumedBlockSize();
        break;
      }
    }
  }

  LayoutUnit containing_block_adjustment =
      container_builder_->BlockOffsetAdjustmentForFragmentainer(
          fragmentainer_consumed_block_size_);
  if (result->PhysicalFragment().NeedsOOFPositionedInfoPropagation()) {
    container_builder_->PropagateOOFPositionedInfo(
        result->PhysicalFragment(), oof_offset, relative_offset,
        offset_adjustment,
        /* inline_container */ nullptr, containing_block_adjustment,
        &descendant.node_info.fixedpos_containing_block,
        additional_fixedpos_offset);
  }
  algorithm->AppendOutOfFlowResult(result);

  const auto& physical_fragment =
      To<NGPhysicalBoxFragment>(result->PhysicalFragment());

  // Copy the offset of the OOF node back to legacy such that it is relative
  // to its containing block rather than the fragmentainer that it is being
  // added to.
  if (!descendant.break_token) {
    const NGPhysicalBoxFragment& container =
        To<NGPhysicalBoxFragment>(*descendant.containing_block_fragment);
    LogicalOffset legacy_offset =
        descendant.offset_info.original_offset -
        descendant.node_info.container_info.offset_to_border_box;
    descendant.node_info.node.CopyChildFragmentPosition(
        physical_fragment,
        legacy_offset.ConvertToPhysical(container.Style().GetWritingDirection(),
                                        container.Size(),
                                        physical_fragment.Size()),
        container, /* previous_container_break_token */ nullptr);
  }

  const NGBlockBreakToken* break_token =
      To<NGBlockBreakToken>(physical_fragment.BreakToken());
  if (break_token) {
    // We must continue layout in the next fragmentainer. Update any information
    // in NodeToLayout, and add the node to |fragmented_descendants|.
    NodeToLayout fragmented_descendant = descendant;
    fragmented_descendant.break_token = break_token;
    fragmented_descendant.offset_info.offset.block_offset = LayoutUnit();
    fragmented_descendants->emplace_back(fragmented_descendant);
  }
}

void NGOutOfFlowLayoutPart::ReplaceFragmentainer(
    wtf_size_t index,
    LogicalOffset offset,
    bool create_new_fragment,
    NGSimplifiedOOFLayoutAlgorithm* algorithm) {
  if (create_new_fragment) {
    const NGLayoutResult* new_result = algorithm->Layout();
    container_builder_->AddChild(
        new_result->PhysicalFragment(), offset,
        /* margin_strut */ nullptr, /* is_self_collapsing */ false,
        /* relative_offset */ absl::nullopt,
        /* inline_container */ nullptr,
        /* adjustment_for_oof_propagation */ absl::nullopt);
  } else {
    const NGLayoutResult* new_result = algorithm->Layout();
    const NGPhysicalFragment* new_fragment = &new_result->PhysicalFragment();
    container_builder_->ReplaceChild(index, *new_fragment, offset);

    if (multicol_children_ && index < multicol_children_->size()) {
      // We are in a nested fragmentation context. Replace the column entry
      // (that already existed) and break token directly in the existing
      // multicol fragment. If there any new columns, they will be appended as
      // part of regenerating the multicol fragment.
      MulticolChildInfo& column_info = (*multicol_children_)[index];
      if (auto& parent_break_token = column_info.parent_break_token) {
        DCHECK_GT(parent_break_token->ChildBreakTokens().size(), 0u);
        parent_break_token->GetMutableForOutOfFlow().ReplaceChildBreakToken(
            new_fragment->BreakToken(),
            base::checked_cast<wtf_size_t>(
                parent_break_token->ChildBreakTokens().size()) -
                1);
      }
      column_info.mutable_link->fragment = new_fragment;
    }
  }
}

LogicalOffset NGOutOfFlowLayoutPart::UpdatedFragmentainerOffset(
    LogicalOffset offset,
    wtf_size_t index,
    LayoutUnit column_inline_progression,
    bool create_new_fragment) {
  if (create_new_fragment) {
    wtf_size_t num_children = container_builder_->Children().size();
    if (index != num_children - 1 && !container_builder_->Children()[index + 1]
                                          .fragment->IsFragmentainerBox()) {
      // If we are a new fragment and are separated from other columns by a
      // spanner, compute the correct column offset to use.
      const auto& spanner = container_builder_->Children()[index + 1];
      DCHECK(spanner.fragment->IsColumnSpanAll());

      offset = spanner.offset;
      LogicalSize spanner_size = spanner.fragment->Size().ConvertToLogical(
          container_builder_->Style().GetWritingMode());
      // TODO(almaher): Include trailing spanner margin.
      offset.block_offset += spanner_size.block_size;
    } else {
      offset.inline_offset += column_inline_progression;
    }
  }
  return offset;
}

NGConstraintSpace NGOutOfFlowLayoutPart::GetFragmentainerConstraintSpace(
    wtf_size_t index) {
  wtf_size_t num_children = container_builder_->Children().size();
  bool is_new_fragment = index >= num_children;
  // Allow margins to be discarded if this is not the first column in the
  // multicol container, and we're not right after a spanner.
  //
  // TODO(layout-dev): This check is incorrect in nested multicol. If the
  // previous outer fragmentainer ended with regular column content (i.e. not a
  // spanner), and this is the first column in the next outer fragmentainer, we
  // should still discard margins, since there is no explicit break involved.
  bool allow_discard_start_margin =
      is_new_fragment || (index > 0 && container_builder_->Children()[index - 1]
                                           .fragment->IsFragmentainerBox());

  // If we are a new fragment, find a non-spanner fragmentainer to base our
  // constraint space off of.
  while (
      index >= num_children ||
      !container_builder_->Children()[index].fragment->IsFragmentainerBox()) {
    DCHECK_GT(num_children, 0u);
    index--;
  }

  const auto& fragmentainer = container_builder_->Children()[index];
  DCHECK(fragmentainer.fragment->IsFragmentainerBox());
  const auto& fragment = To<NGPhysicalBoxFragment>(*fragmentainer.fragment);
  const WritingMode container_writing_mode =
      container_builder_->Style().GetWritingMode();
  LogicalSize column_size =
      fragment.Size().ConvertToLogical(container_writing_mode);

  // If we are a new fragment and are separated from other columns by a
  // spanner, compute the correct column block size to use.
  if (is_new_fragment && index != num_children - 1 &&
      original_column_block_size_ != kIndefiniteSize &&
      !container_builder_->Children()[index + 1]
           .fragment->IsFragmentainerBox()) {
    column_size.block_size =
        original_column_block_size_ -
        container_builder_->BlockOffsetForAdditionalColumns();
    column_size.block_size = column_size.block_size.ClampNegativeToZero();
  }

  LogicalSize percentage_resolution_size =
      LogicalSize(column_size.inline_size,
                  container_builder_->ChildAvailableSize().block_size);

  // In the current implementation it doesn't make sense to restrict imperfect
  // breaks inside OOFs, since we never break and resume OOFs in a subsequent
  // outer fragmentainer anyway (we'll always stay in the current outer
  // fragmentainer and just create overflowing columns in the current row,
  // rather than moving to the next one).
  NGBreakAppeal min_break_appeal = kBreakAppealLastResort;

  // TODO(bebeaudr): Need to handle different fragmentation types. It won't
  // always be multi-column.
  return CreateConstraintSpaceForColumns(
      *container_builder_->ConstraintSpace(), column_size,
      percentage_resolution_size, allow_discard_start_margin,
      /* balance_columns */ false, min_break_appeal);
}

// Compute in which fragmentainer the OOF element will start its layout and
// position the offset relative to that fragmentainer.
void NGOutOfFlowLayoutPart::ComputeStartFragmentIndexAndRelativeOffset(
    WritingMode default_writing_mode,
    LayoutUnit block_estimate,
    wtf_size_t* start_index,
    LogicalOffset* offset) const {
  wtf_size_t child_index = 0;
  // The sum of all previous fragmentainers' block size.
  LayoutUnit used_block_size;
  // The sum of all previous fragmentainers' block size + the current one.
  LayoutUnit current_max_block_size;
  // The block size for the last fragmentainer we encountered.
  LayoutUnit fragmentainer_block_size;
  // TODO(bebeaudr): There is a possible performance improvement here as we'll
  // repeat this for each abspos in a same fragmentainer.
  for (auto& child : container_builder_->Children()) {
    if (child.fragment->IsFragmentainerBox()) {
      fragmentainer_block_size = child.fragment->Size()
                                     .ConvertToLogical(default_writing_mode)
                                     .block_size;
      fragmentainer_block_size =
          ClampedToValidFragmentainerCapacity(fragmentainer_block_size);
      current_max_block_size += fragmentainer_block_size;

      // Edge case: an abspos with an height of 0 positioned exactly at the
      // |current_max_block_size| won't be fragmented, so no break token will be
      // produced - as we'd expect. However, the break token is used to compute
      // the |fragmentainer_consumed_block_size_| stored on the
      // |container_builder_| when we have a nested abspos. Because we use that
      // value to position the nested abspos, its start offset would be off by
      // exactly one fragmentainer block size.
      if (offset->block_offset < current_max_block_size ||
          (offset->block_offset == current_max_block_size &&
           block_estimate == 0)) {
        *start_index = child_index;
        offset->block_offset -= used_block_size;
        return;
      }
      used_block_size = current_max_block_size;
    }
    child_index++;
  }
  // If the right fragmentainer hasn't been found yet, the OOF element will
  // start its layout in a proxy fragment.
  LayoutUnit remaining_block_offset = offset->block_offset - used_block_size;

  // If we are a new fragment and are separated from other columns by a
  // spanner, compute the correct fragmentainer_block_size.
  if (original_column_block_size_ != kIndefiniteSize &&
      !container_builder_->Children()[child_index - 1]
           .fragment->IsFragmentainerBox()) {
    fragmentainer_block_size =
        original_column_block_size_ -
        container_builder_->BlockOffsetForAdditionalColumns();
    fragmentainer_block_size =
        ClampedToValidFragmentainerCapacity(fragmentainer_block_size);
  }

  wtf_size_t additional_fragment_count =
      int(floorf(remaining_block_offset / fragmentainer_block_size));
  *start_index = child_index + additional_fragment_count;
  offset->block_offset = remaining_block_offset -
                         additional_fragment_count * fragmentainer_block_size;
}

void NGOutOfFlowLayoutPart::ReplaceFragment(
    const NGLayoutResult* new_result,
    const NGPhysicalBoxFragment& old_fragment,
    wtf_size_t index) {
  // Replace the LayoutBox entry.
  LayoutBox& box = *old_fragment.MutableOwnerLayoutBox();
  box.ReplaceLayoutResult(new_result, index);

  // Replace the entry in the parent fragment. Locating the parent fragment
  // isn't straight-forward if the containing block is a multicol container.
  LayoutBlock* containing_block = box.ContainingNGBlock();

  if (box.IsOutOfFlowPositioned()) {
    // If the inner multicol is out-of-flow positioned, its fragments will be
    // found as direct children of fragmentainers in the nearest ancestor
    // fragmentation context.
    containing_block = containing_block->ContainingFragmentationContextRoot();

    // Since this is treated as a nested multicol container, we should always
    // find an outer fragmentation context.
    DCHECK(containing_block);
  }

  // Replace the old fragment with the new one, if it's inside |parent|.
  auto ReplaceChild = [&new_result, &old_fragment](
                          const NGPhysicalBoxFragment& parent) -> bool {
    for (NGLink& child_link :
         parent.GetMutableChildrenForOutOfFlow().Children()) {
      if (child_link.fragment != &old_fragment)
        continue;
      child_link.fragment = &new_result->PhysicalFragment();
      return true;
    }
    return false;
  };

  // Replace the old fragment with the new one, if |multicol_child| is a
  // fragmentainer and has the old fragment as a child.
  auto ReplaceFragmentainerChild =
      [ReplaceChild](const NGPhysicalFragment& multicol_child) -> bool {
    // We're going to replace a child of a fragmentainer. First check if it's a
    // fragmentainer at all.
    if (!multicol_child.IsFragmentainerBox())
      return false;
    const auto& fragmentainer = To<NGPhysicalBoxFragment>(multicol_child);
    // Then search and replace inside the fragmentainer.
    return ReplaceChild(fragmentainer);
  };

  if (!containing_block->IsFragmentationContextRoot()) {
    // Simply search inside child fragments of the containing block.
    DCHECK_NE(containing_block, container_builder_->GetLayoutObject());
    for (const auto& parent_fragment : containing_block->PhysicalFragments()) {
      if (ReplaceChild(parent_fragment))
        return;
    }
  } else if (containing_block == container_builder_->GetLayoutObject()) {
    // We're currently laying out |containing_block|, and it's a multicol
    // container. Search inside fragmentainer children in the builder.
    for (const NGContainerFragmentBuilder::ChildWithOffset& child :
         container_builder_->Children()) {
      if (ReplaceFragmentainerChild(*child.fragment))
        return;
    }
  } else {
    // |containing_block| has already been laid out, and it's a multicol
    // container. Search inside fragmentainer children of the fragments
    // generated for the containing block.
    for (const auto& multicol : containing_block->PhysicalFragments()) {
      for (const auto& child : multicol.Children()) {
        if (ReplaceFragmentainerChild(*child.fragment))
          return;
      }
    }
  }
  NOTREACHED();
}

void NGOutOfFlowLayoutPart::SaveStaticPositionOnPaintLayer(
    LayoutBox* layout_box,
    const NGLogicalStaticPosition& position) const {
  const LayoutObject* parent =
      GetLayoutObjectForParentNode<const LayoutObject*>(layout_box);
  const LayoutObject* container = container_builder_->GetLayoutObject();
  if (parent == container ||
      (parent->IsLayoutInline() && parent->ContainingBlock() == container)) {
    DCHECK(layout_box->Layer());
    layout_box->Layer()->SetStaticPositionFromNG(
        ToStaticPositionForLegacy(position));
  }
}

NGLogicalStaticPosition NGOutOfFlowLayoutPart::ToStaticPositionForLegacy(
    NGLogicalStaticPosition position) const {
  // Legacy expects the static position to include the block contribution from
  // previous columns.
  if (const auto* break_token = container_builder_->PreviousBreakToken())
    position.offset.block_offset += break_token->ConsumedBlockSizeForLegacy();
  return position;
}

void NGOutOfFlowLayoutPart::MulticolChildInfo::Trace(Visitor* visitor) const {
  visitor->Trace(parent_break_token);
}

void NGOutOfFlowLayoutPart::NodeInfo::Trace(Visitor* visitor) const {
  visitor->Trace(node);
}

void NGOutOfFlowLayoutPart::OffsetInfo::Trace(Visitor* visitor) const {
  visitor->Trace(initial_layout_result);
}

void NGOutOfFlowLayoutPart::NodeToLayout::Trace(Visitor* visitor) const {
  visitor->Trace(node_info);
  visitor->Trace(offset_info);
  visitor->Trace(break_token);
  visitor->Trace(containing_block_fragment);
}

}  // namespace blink
