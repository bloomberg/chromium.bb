<!DOCTYPE html>
<title>Test fenced frame data: URL navigation</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="resources/utils.js"></script>
<script src="/common/utils.js"></script>

<body>

<script>
promise_test(async () => {
  const window_data_key = token();
  const key2 = token();

  const fenced_frame_nested_iframe_url =
      generateURL('resources/frame-navigation-inner-simple.https.html',
                  [window_data_key, key2]);
  // Inside the data: fenced frame, we have to use a nested iframe to report
  // back to the outermost page, instead of just having the fenced frame itself
  // report back. This is because "reporting back" to the outermost page
  // involves fetching the `utils.js` resource which lives in a "local" IP
  // address on the WPT server, as per [1]. The data: fenced frame cannot fetch
  // this resource because it is not considered a secure context, and it lives
  // in a less-restricted IP address space than the WPT resource [2].
  // It can however, load an iframe which points at a "private" resource, which
  // itself can load "private" resources and report back to the outermost page.
  //
  // [1]: https://wicg.github.io/private-network-access/#ip-address-space-local
  // [2]: https://wicg.github.io/private-network-access/#secure-context-restriction
  const source = `
    <iframe src="${fenced_frame_nested_iframe_url}"><\/iframe>
  `;

  attachFencedFrame(`data:text/html,${source}`);

  const actual_result  = await nextValueFromServer(window_data_key);
  assert_equals(actual_result, "pass",
                "The fenced frame has the right value for `data: URL` upon " +
                "data URL navigation");

}, "Fenced frames can navigate to data: URLs");
</script>

</body>
