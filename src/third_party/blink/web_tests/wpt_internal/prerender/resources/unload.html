<!DOCTYPE html>
<script src="/common/get-host-info.sub.js"></script>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="utils.js"></script>
<body>
<script>
const params = new URLSearchParams(location.search);
const testcase = params.get('testcase');
const state = params.get('state');

function createTestUrl(nextState) {
  const params = new URLSearchParams();
  params.set('state', nextState);
  params.set('testcase', testcase);
  return 'unload.html?' + params.toString();
}

function createCrossOriginTestUrl(nextState) {
  const path = createTestUrl(nextState);
  const url = new URL(path, location.href);
  url.host = get_host_info().REMOTE_HOST;
  return url.href;
}

function openChannel() {
  return new BroadcastChannel('prerender-' + testcase);
}

function addFrame(url) {
  const frame = document.createElement('iframe');
  frame.src = url;
  document.body.appendChild(frame);
  return frame;
}

function addEventListeners(name, checkPrerenderingState) {
  ['unload', 'pagehide', 'pageshow', 'visibilitychange'].forEach(eventName => {
    window.addEventListener(eventName, e => {
      const bc = openChannel();
      bc.postMessage(eventName + ' ' + name +
          (checkPrerenderingState && document.prerendering ? ' in prerendering'
                                                             : ''));
      bc.close();
    });
  });
}

function waitPostMessage() {
  return new Promise(resolve => {
    window.addEventListener('message', e => resolve(e.data), { once: true });
  });
}

function waitMessage(message) {
  return new Promise(resolve => {
    const bc = openChannel();
    bc.addEventListener('message', e => {
      if (e.data == message) {
        bc.close();
        resolve();
      }
    });
  });
}

async function sameOriginSubframeNavigation() {
  const bc = new openChannel();

  // Test steps:
  //   1. `start` page starts prerendering `prerendering` page.
  //   2. `prerendering` page adds `same-origin-frame1`.
  //   3. `same-origin-frame1` navigates to `same-origin-frame2`.
  //   4. `pagehide` and `unload` events are handled.
  bc.postMessage('load ' + state);
  if (state === 'start') {
    startPrerendering(createTestUrl('prerendering'));
  } else if (state === 'prerendering') {
    addFrame(createTestUrl('same-origin-frame1'));
  } else if (state === 'same-origin-frame1') {
    // unload handler should be triggered after the frame navigation.
    addEventListeners('same-origin-frame1', true);

    // Run a same-origin navigation.
    document.location = createTestUrl('same-origin-frame2');
  } else if (state === 'same-origin-frame2') {
    bc.postMessage('Done');
  }

  bc.close();
}

async function crossOriginSubframeNavigation() {
  const bc = new openChannel();

  // Test steps:
  //   1. `start` page starts prerendering `prerendering` page.
  //   2. `prerendering` page adds `same-origin-frame`.
  //   3. `same-origin-frame' navigates to `cross-origin-frame`.
  //   4. `same-origin-frame` asks `start` page to activate `prerendering`.
  //   5. `visibilitychange` event is handled in `same-origin-frame` due to the
  //       activation.
  //   6. `pagehide`, `visibilitychange`, and `unload` events are handled in
  //      `same-origin-frame` for the resumed navigation.
  //   7. `cross-origin-frame` is loaded, then `prerendering` quits the test.
  bc.postMessage('load ' + state);
  if (state === 'start') {
    const url = createTestUrl('prerendering');
    startPrerendering(url);

    // Wait for a message from 'same-origin-frame' that is sent after triggering
    // cross-origin navigation.
    await waitMessage('request activation');

    // Activate the 'prerendering' page.
    document.location = url;
  } else if (state === 'prerendering') {
    const frame = addFrame(createTestUrl('same-origin-frame'));

    // Complete the test when the `cross-origin-frame` is loaded.
    const message = await waitPostMessage();
    bc.postMessage(message);
    bc.postMessage('Done');
  } else if (state === 'same-origin-frame') {
    // unload handler should be triggered after the frame navigation.
    // The deferred cross-origin navigation resumes when the browser process
    // starts activation, and when Blink handles the unload event handler,
    // document.prerendering state is unstable.
    // TODO(https://crbug.com/1222547): Fix this unstable state by waiting for
    // DidActivateForPrerendering() before proceeding with the subframe
    // navigation.
    addEventListeners('same-origin-frame', false);

    // Run a cross-origin navigation.
    document.location = createCrossOriginTestUrl('cross-origin-frame');

    // Ask the 'start' page to activate the prerendering page.
    bc.postMessage('request activation');
  } else if (state === 'cross-origin-frame') {
    // Let the 'prerendering' page know this frame is loaded.
    window.parent.postMessage('load ' + state, '*');
  }

  bc.close();
}

async function removeSubframe() {
  const bc = new openChannel();

  // Test steps:
  //   1. `start` page starts prerendering `prerendering` page.
  //   2. `prerendering` page adds `frame`.
  //   3. `prerendering` page removes `frame`.
  //   4. `pageshow`, `pagehide` and `unload` are handled in `frame`.
  bc.postMessage('load ' + state);
  if (state == 'start') {
    startPrerendering(createTestUrl('prerendering'));
  } else if (state === 'prerendering') {
    const frame = addFrame(createTestUrl('frame'));

    // Wait until the frame is loaded and requests removal.
    await waitMessage('request removal');

    // Set up for waiting the unload message from `frame` and get a promise to
    // wait it, then remove the frame. Once the promise is resolved, complete
    // the test.
    promise = waitMessage('unload frame in prerendering');
    frame.remove();
    await promise;
    bc.postMessage('Done');
  } else if (state == 'frame') {
    addEventListeners('frame', true);
    bc.postMessage('request removal');
  }
  bc.close();
}

async function mainFrameNavigation() {
  const bc = new openChannel();

  // Test steps:
  //   1. `start` page starts prerendering `prerendering` page.
  //   2. `prerendering` page navigates to `another-page`.
  //   3. `prerendering` page asks the `start` page to navigate.
  //   4. ``pagehide` and unload` may not be handled as the prerendering is
  //      cancelled.
  //   5. `start` does a fallback navigation as the prerendering is cancelled.
  //   6. `prerendering` page loads again with document.prerendering == false.
  //   7. `prerendering` page navigates to `another-page` again.
  //   8. `pagehide`, `visibilitychange`, and `unload` are handled this time.
  //   9. `another-page` finishes the test.
  bc.postMessage('load ' + state +
                 (document.prerendering ? ' in prerendering' : ''));
  if (state === 'start') {
    const url = createTestUrl('prerendering');
    startPrerendering(url);

    // Wait for a message from `prerendering` to navigate that results in
    // fallback network navigation as the prerendering is cancelled.
    await waitMessage('request fallback');

    // Navigate.
    document.location = url;
  } else if (state === 'prerendering') {
    // unload handler may not be triggered for cancellation.
    addEventListeners('main-frame', true);

    // Trigger a main frame navigation that will cancel the prerendering.
    // This navigates successfully if the page isn't prerendered.
    document.location = createTestUrl('another-page');

    // Ask the `start` page to navigate if on prerendering. Otherwise, finish
    // the test.
    if (document.prerendering)
      bc.postMessage('request fallback');
  } else if (state === 'another-page') {
    // Reach here after the prerendering is cancelled and fallback request loads
    // the `prerendering` page with document.prerendering == false. The main
    // frame navigation will succeed this time.
    bc.postMessage('Done');
  }

  bc.close();
}

if (testcase === 'same-origin-subframe-navigation')
  sameOriginSubframeNavigation();
else if (testcase === 'cross-origin-subframe-navigation')
  crossOriginSubframeNavigation();
else if (testcase === 'remove-subframe')
  removeSubframe();
else if (testcase === 'main-frame-navigation')
  mainFrameNavigation();

</script>
</body>
