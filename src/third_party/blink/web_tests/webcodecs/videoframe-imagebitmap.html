<!DOCTYPE html>
<script src="../resources/testharness.js"></script>
<script src="../resources/testharnessreport.js"></script>
<script>
  'use strict';
  // Reference values generated by:
  // https://fiddle.skia.org/c/f100d4d5f085a9e09896aabcbc463868

  const kSRGBPixel = [50, 100, 150, 255];
  const kP3Pixel = [62, 99, 146, 255];
  const kRec2020Pixel = [87, 106, 151, 255];

  const kCanvasOptionsP3Uint8 = {
    colorSpace: 'p3',
    pixelFormat: 'uint8'
  };
  const kCanvasOptionsRec2020Uint8 = {
    colorSpace: 'rec2020',
    pixelFormat: 'uint8'
  };

  function testCanvas(ctx, width, height, expected_pixel, assert_compares) {
    // The dup getImageData is to workaournd crbug.com/1100233
    let imageData = ctx.getImageData(0, 0, width, height);
    let colorData = ctx.getImageData(0, 0, width, height).data;
    const kMaxPixelToCheck = 128 * 96;
    let step = width * height / kMaxPixelToCheck;
    step = Math.round(step);
    step = (step < 1) ? 1 : step;
    for (let i = 0; i < 4 * width * height; i += (4 * step)) {
      assert_compares(colorData[i], expected_pixel[0]);
      assert_compares(colorData[i + 1], expected_pixel[1]);
      assert_compares(colorData[i + 2], expected_pixel[2]);
      assert_compares(colorData[i + 3], expected_pixel[3]);
    }
  }

  function testImageBitmapToAndFromVideoFrame(width, height, expectedPixel,
    canvasOptions, imageBitmapOptions) {
    let canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    let ctx = canvas.getContext('2d', canvasOptions);
    ctx.fillStyle = 'rgb(50, 100, 150)';
    ctx.fillRect(0, 0, width, height);
    testCanvas(ctx, width, height, expectedPixel, assert_equals);

    return createImageBitmap(canvas, imageBitmapOptions)
      .then((fromImageBitmap) => {
        let videoFrame = new VideoFrame(fromImageBitmap, {
          timestamp: 0
        });
        return videoFrame.createImageBitmap(imageBitmapOptions);
      })
      .then((toImageBitmap) => {
        let myCanvas = document.createElement('canvas');
        myCanvas.width = width;
        myCanvas.height = height;
        let myCtx = myCanvas.getContext('2d', canvasOptions);
        myCtx.drawImage(toImageBitmap, 0, 0);
        let tolerance = 2;
        testCanvas(myCtx, width, height, expectedPixel, (actual, expected) => {
          assert_approx_equals(actual, expected, tolerance);
        });
      });
  }

  promise_test(() => {
    return testImageBitmapToAndFromVideoFrame(48, 36, kSRGBPixel);
  }, 'ImageBitmap<->VideoFrame with canvas(48x36 srgb uint8).');
  promise_test(() => {
    return testImageBitmapToAndFromVideoFrame(480, 360, kSRGBPixel);
  }, 'ImageBitmap<->VideoFrame with canvas(480x360 srgb uint8).');

  promise_test(() => {
    return testImageBitmapToAndFromVideoFrame(48, 36, kP3Pixel,
      kCanvasOptionsP3Uint8, {
        colorSpaceConversion: "none"
      });
  }, 'ImageBitmap<->VideoFrame with canvas(48x36 p3 uint8).');
  promise_test(() => {
    return testImageBitmapToAndFromVideoFrame(480, 360, kP3Pixel,
      kCanvasOptionsP3Uint8, {
        colorSpaceConversion: "none"
      });
  }, 'ImageBitmap<->VideoFrame with canvas(480x360 p3 uint8).');

  promise_test(() => {
    return testImageBitmapToAndFromVideoFrame(48, 36, kRec2020Pixel,
      kCanvasOptionsRec2020Uint8, {
        colorSpaceConversion: "none"
      });
  }, 'ImageBitmap<->VideoFrame with canvas(48x36 rec2020 uint8).');
  promise_test(() => {
    return testImageBitmapToAndFromVideoFrame(480, 360, kRec2020Pixel,
      kCanvasOptionsRec2020Uint8, {
        colorSpaceConversion: "none"
      });
  }, 'ImageBitmap<->VideoFrame with canvas(480x360 rec2020 uint8).');


  function testCreateImageBitmapFromVideoFrameVP9Decoder() {
    // Prefers hardware decoders by setting video size as large as 720p.
    const width = 1280;
    const height = 720;

    let canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    let ctx = canvas.getContext('2d');
    ctx.fillStyle = 'rgb(50, 100, 150)';
    ctx.fillRect(0, 0, width, height);

    return createImageBitmap(canvas).then((fromImageBitmap) => {
      let videoFrame = new VideoFrame(fromImageBitmap, {
        timestamp: 0
      });
      return new Promise((resolve, reject) => {
        let processVideoFrame = (frame) => {
          frame.createImageBitmap().then((toImageBitmap) => {
            let myCanvas = document.createElement('canvas');
            myCanvas.width = width;
            myCanvas.height = height;
            let myCtx = myCanvas.getContext('2d');
            myCtx.drawImage(toImageBitmap, 0, 0);
            let tolerance = 6;
            try {
              testCanvas(myCtx, width, height, kSRGBPixel,
                (actual, expected) => {
                  assert_approx_equals(actual, expected, tolerance);
                }
              );
            } catch (error) {
              reject(error);
            }
            resolve('Done.');
          });
        };

        const decoderInit = {
          output: processVideoFrame,
          error: (e) => {
            console.log(e.message);
          }
        };

        const encodedVideoConfig = {
          codec: "vp09.00.10.08",
        };

        let decoder = new VideoDecoder(decoderInit);
        decoder.configure(encodedVideoConfig);

        let processVideoChunk = (chunk) => {
          decoder.decode(chunk);
          decoder.flush();
        };

        const encoderInit = {
          output: processVideoChunk,
          error: (e) => {
            console.log(e.message);
          }
        };

        const videoEncoderConfig = {
          codec: "vp09.00.10.08",
          width: width,
          height: height,
          bitrate: 10e6,
          framerate: 30,
        };

        let encoder = new VideoEncoder(encoderInit);
        encoder.configure(videoEncoderConfig);
        encoder.encode(videoFrame, {
          keyFrame: true
        });
        encoder.flush();
      });
    });
  }

  promise_test(() => {
    return testCreateImageBitmapFromVideoFrameVP9Decoder();
  }, 'Create ImageBitmap for a VideoFrame from VP9 decoder.');
</script>
