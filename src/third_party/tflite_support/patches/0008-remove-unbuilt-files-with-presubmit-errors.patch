From b545fb0077fc975480b8504b805464a41c6ae30f Mon Sep 17 00:00:00 2001
From: Robert Ogden <robertogden@chromium.org>
Date: Wed, 13 Apr 2022 11:15:48 -0700
Subject: [PATCH 8/9] remove unbuilt files with presubmit errors

---
 .../cc/port/benchmark.h                       |  21 -
 .../cc/port/default/status_matchers.h         |  55 --
 .../tensorflow_lite_support/cc/port/gmock.h   |  21 -
 .../tensorflow_lite_support/cc/port/gtest.h   |  21 -
 .../tensorflow_lite_support/cc/port/proto2.h  |  32 --
 .../cc/task/processor/search_postprocessor.cc | 362 ------------
 .../cc/task/processor/search_postprocessor.h  | 112 ----
 .../ios/utils/Sources/TFLStringUtil.mm        |  26 -
 .../metadata/cc/metadata_populator.cc         | 150 -----
 .../metadata/cc/utils/zip_mem_file.cc         | 134 -----
 .../metadata/cc/utils/zip_mem_file.h          |  75 ---
 .../audio/pybinds/_pywrap_audio_classifier.cc |  84 ---
 .../audio/pybinds/_pywrap_audio_embedder.cc   |  78 ---
 .../text/pybinds/_pywrap_text_embedder.cc     |  68 ---
 .../task/vision/core/pybinds/image_utils.cc   |  68 ---
 .../pybinds/_pywrap_image_classifier.cc       | 108 ----
 .../vision/pybinds/_pywrap_image_embedder.cc  | 145 -----
 .../vision/pybinds/_pywrap_image_segmenter.cc |  73 ---
 .../vision/pybinds/_pywrap_object_detector.cc |  84 ---
 .../scann_ondevice/cc/core/index_table_sum.h  | 256 ---------
 .../scann_ondevice/cc/core/partitioner.h      |  76 ---
 .../scann_ondevice/cc/core/processor.h        | 101 ----
 .../scann_ondevice/cc/core/searcher.h         | 256 ---------
 .../scann_ondevice/cc/core/searcher_test.cc   | 532 ------------------
 .../scann_ondevice/cc/core/simd_utils.h       | 303 ----------
 .../scann_ondevice/cc/index.cc                | 138 -----
 .../scann_ondevice/cc/index.h                 |  91 ---
 .../scann_ondevice/cc/index_builder.cc        | 177 ------
 .../scann_ondevice/cc/index_builder.h         |  68 ---
 .../cc/mem_random_access_file.cc              |  52 --
 .../cc/mem_random_access_file.h               |  61 --
 .../scann_ondevice/cc/mem_writable_file.h     |  64 ---
 .../cc/python/index_builder_py_wrapper.cc     |  64 ---
 .../cc/test/index_builder_test.cc             | 363 ------------
 .../cc/test/mem_random_access_file_test.cc    |  64 ---
 .../leveldb_testing_utils_py_wrapper.cc       |  76 ---
 .../tools/ci_build/common_win.bat             |  29 -
 37 files changed, 4488 deletions(-)
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/cc/port/benchmark.h
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/cc/port/default/status_matchers.h
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/cc/port/gmock.h
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/cc/port/gtest.h
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/cc/port/proto2.h
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/search_postprocessor.cc
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/search_postprocessor.h
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/ios/utils/Sources/TFLStringUtil.mm
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/metadata_populator.cc
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/utils/zip_mem_file.cc
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/utils/zip_mem_file.h
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/python/task/audio/pybinds/_pywrap_audio_classifier.cc
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/python/task/audio/pybinds/_pywrap_audio_embedder.cc
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/python/task/text/pybinds/_pywrap_text_embedder.cc
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/python/task/vision/core/pybinds/image_utils.cc
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/python/task/vision/pybinds/_pywrap_image_classifier.cc
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/python/task/vision/pybinds/_pywrap_image_embedder.cc
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/python/task/vision/pybinds/_pywrap_image_segmenter.cc
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/python/task/vision/pybinds/_pywrap_object_detector.cc
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/core/index_table_sum.h
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/core/partitioner.h
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/core/processor.h
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/core/searcher.h
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/core/searcher_test.cc
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/core/simd_utils.h
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/index.cc
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/index.h
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/index_builder.cc
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/index_builder.h
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/mem_random_access_file.cc
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/mem_random_access_file.h
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/mem_writable_file.h
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/python/index_builder_py_wrapper.cc
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/test/index_builder_test.cc
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/test/mem_random_access_file_test.cc
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/test/python/leveldb_testing_utils_py_wrapper.cc
 delete mode 100644 third_party/tflite_support/src/tensorflow_lite_support/tools/ci_build/common_win.bat

diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/port/benchmark.h b/third_party/tflite_support/src/tensorflow_lite_support/cc/port/benchmark.h
deleted file mode 100644
index 74bc1a6857664..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/port/benchmark.h
+++ /dev/null
@@ -1,21 +0,0 @@
-/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#ifndef TENSORFLOW_LITE_SUPPORT_CC_PORT_BENCHMARK_H_
-#define TENSORFLOW_LITE_SUPPORT_CC_PORT_BENCHMARK_H_
-
-#include "gtest/benchmark.h"
-
-#endif  // TENSORFLOW_LITE_SUPPORT_CC_PORT_BENCHMARK_H_
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/port/default/status_matchers.h b/third_party/tflite_support/src/tensorflow_lite_support/cc/port/default/status_matchers.h
deleted file mode 100644
index 6d9668043c183..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/port/default/status_matchers.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/* Copyright 2021 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#ifndef TENSORFLOW_LITE_SUPPORT_CC_PORT_DEFAULT_STATUS_MATCHERS_H_
-#define TENSORFLOW_LITE_SUPPORT_CC_PORT_DEFAULT_STATUS_MATCHERS_H_
-
-#include "gmock/gmock.h"
-#include "gtest/gtest.h"
-
-#define SUPPORT_STATUS_MACROS_IMPL_CONCAT_INNER_(x, y) x##y
-#define SUPPORT_STATUS_MACROS_IMPL_CONCAT_(x, y) \
-  SUPPORT_STATUS_MACROS_IMPL_CONCAT_INNER_(x, y)
-
-#undef SUPPORT_ASSERT_OK
-#define SUPPORT_ASSERT_OK(expr) \
-  SUPPORT_ASSERT_OK_IMPL_(      \
-      SUPPORT_STATUS_MACROS_IMPL_CONCAT_(_status, __LINE__), expr)
-
-#define SUPPORT_ASSERT_OK_IMPL_(status, expr) \
-  auto status = (expr);                       \
-  ASSERT_TRUE(status.ok());
-
-#undef SUPPORT_EXPECT_OK
-#define SUPPORT_EXPECT_OK(expr) \
-  SUPPORT_EXPECT_OK_IMPL_(      \
-      SUPPORT_STATUS_MACROS_IMPL_CONCAT_(_status, __LINE__), expr)
-
-#define SUPPORT_EXPECT_OK_IMPL_(status, expr) \
-  auto status = (expr);                       \
-  EXPECT_TRUE(status.ok());
-
-#undef SUPPORT_ASSERT_OK_AND_ASSIGN
-#define SUPPORT_ASSERT_OK_AND_ASSIGN(lhs, rexpr)                           \
-  SUPPORT_ASSERT_OK_AND_ASSIGN_IMPL_(                                      \
-      SUPPORT_STATUS_MACROS_IMPL_CONCAT_(_status_or_value, __LINE__), lhs, \
-      rexpr)
-
-#define SUPPORT_ASSERT_OK_AND_ASSIGN_IMPL_(statusor, lhs, rexpr) \
-  auto statusor = (rexpr);                                       \
-  ASSERT_TRUE(statusor.ok());                                    \
-  lhs = std::move(statusor.value())
-
-#endif  // TENSORFLOW_LITE_SUPPORT_CC_PORT_DEFAULT_STATUS_MATCHERS_H_
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/port/gmock.h b/third_party/tflite_support/src/tensorflow_lite_support/cc/port/gmock.h
deleted file mode 100644
index 5e4334db323d6..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/port/gmock.h
+++ /dev/null
@@ -1,21 +0,0 @@
-/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#ifndef TENSORFLOW_LITE_SUPPORT_CC_PORT_GMOCK_H_
-#define TENSORFLOW_LITE_SUPPORT_CC_PORT_GMOCK_H_
-
-#include "gmock/gmock.h"
-
-#endif  // TENSORFLOW_LITE_SUPPORT_CC_PORT_GMOCK_H_
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/port/gtest.h b/third_party/tflite_support/src/tensorflow_lite_support/cc/port/gtest.h
deleted file mode 100644
index dbe2e5e6f9d7c..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/port/gtest.h
+++ /dev/null
@@ -1,21 +0,0 @@
-/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#ifndef TENSORFLOW_LITE_SUPPORT_CC_PORT_GTEST_H_
-#define TENSORFLOW_LITE_SUPPORT_CC_PORT_GTEST_H_
-
-#include "gtest/gtest.h"
-
-#endif  // TENSORFLOW_LITE_SUPPORT_CC_PORT_GTEST_H_
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/port/proto2.h b/third_party/tflite_support/src/tensorflow_lite_support/cc/port/proto2.h
deleted file mode 100644
index 3cde2ab81d6ee..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/port/proto2.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/* Copyright 2021 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-#ifndef TENSORFLOW_LITE_SUPPORT_CC_PORT_PROTO_NS_H_
-#define TENSORFLOW_LITE_SUPPORT_CC_PORT_PROTO_NS_H_
-
-#include "google/protobuf/message_lite.h"
-#include "google/protobuf/text_format.h"
-
-namespace tflite {
-namespace support {
-namespace proto {
-
-using TextFormat = ::google::protobuf::TextFormat;
-using MessageLite = ::google::protobuf::MessageLite;
-
-}  // namespace proto
-}  // namespace support
-}  // namespace tflite
-
-#endif  // TENSORFLOW_LITE_SUPPORT_CC_PORT_PROTO_NS_H_
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/search_postprocessor.cc b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/search_postprocessor.cc
deleted file mode 100644
index e3bc2688caf3a..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/search_postprocessor.cc
+++ /dev/null
@@ -1,362 +0,0 @@
-/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#include "tensorflow_lite_support/cc/task/processor/search_postprocessor.h"
-
-#include <algorithm>
-#include <cstdint>
-#include <initializer_list>
-#include <limits>
-#include <memory>
-#include <vector>
-
-#include "Eigen/Core"                 // from @eigen
-#include "absl/memory/memory.h"       // from @com_google_absl
-#include "absl/status/status.h"       // from @com_google_absl
-#include "absl/strings/str_format.h"  // from @com_google_absl
-#include "absl/types/span.h"          // from @com_google_absl
-#include "tensorflow_lite_support/cc/common.h"
-#include "tensorflow_lite_support/cc/port/status_macros.h"
-#include "tensorflow_lite_support/cc/port/statusor.h"
-#include "tensorflow_lite_support/cc/task/core/external_file_handler.h"
-#include "tensorflow_lite_support/cc/task/core/tflite_engine.h"
-#include "tensorflow_lite_support/cc/task/processor/embedding_postprocessor.h"
-#include "tensorflow_lite_support/cc/task/processor/proto/embedding.pb.h"
-#include "tensorflow_lite_support/cc/task/processor/proto/embedding_options.pb.h"
-#include "tensorflow_lite_support/cc/task/processor/proto/search_options.pb.h"
-#include "tensorflow_lite_support/cc/task/processor/proto/search_result.pb.h"
-#include "tensorflow_lite_support/scann_ondevice/cc/core/partitioner.h"
-#include "tensorflow_lite_support/scann_ondevice/cc/core/processor.h"
-#include "tensorflow_lite_support/scann_ondevice/cc/core/searcher.h"
-#include "tensorflow_lite_support/scann_ondevice/cc/core/serialized_searcher.pb.h"
-#include "tensorflow_lite_support/scann_ondevice/cc/core/top_n_amortized_constant.h"
-#include "tensorflow_lite_support/scann_ondevice/cc/index.h"
-#include "tensorflow_lite_support/scann_ondevice/proto/index_config.pb.h"
-
-namespace tflite {
-namespace task {
-namespace processor {
-
-namespace {
-
-constexpr int kNoNeighborId = -1;
-
-using ::tflite::scann_ondevice::Index;
-using ::tflite::scann_ondevice::IndexConfig;
-using ::tflite::scann_ondevice::core::AsymmetricHashFindNeighbors;
-using ::tflite::scann_ondevice::core::DistanceMeasure;
-using ::tflite::scann_ondevice::core::FloatFindNeighbors;
-using ::tflite::scann_ondevice::core::QueryInfo;
-using ::tflite::scann_ondevice::core::ScannOnDeviceConfig;
-using ::tflite::scann_ondevice::core::TopN;
-using ::tflite::support::CreateStatusWithPayload;
-using ::tflite::support::StatusOr;
-using ::tflite::support::TfLiteSupportStatus;
-using ::tflite::task::core::ExternalFileHandler;
-using ::tflite::task::core::TfLiteEngine;
-using ::tflite::task::processor::Embedding;
-
-using Matrix8u =
-    Eigen::Matrix<uint8_t, Eigen::Dynamic, Eigen::Dynamic, Eigen::ColMajor>;
-
-absl::StatusOr<std::unique_ptr<EmbeddingPostprocessor>>
-CreateEmbeddingPostprocessor(TfLiteEngine* engine,
-                             const std::initializer_list<int> output_indices,
-                             std::unique_ptr<EmbeddingOptions> options) {
-  if (options->quantize()) {
-    // ScaNN only supports searching from float embeddings.
-    return CreateStatusWithPayload(absl::StatusCode::kInvalidArgument,
-                                   "Setting EmbeddingOptions.normalize = true "
-                                   "is not allowed in searchers.",
-                                   TfLiteSupportStatus::kInvalidArgumentError);
-  }
-  return EmbeddingPostprocessor::Create(engine, output_indices,
-                                        std::move(options));
-}
-
-absl::Status SanityCheckOptions(const SearchOptions& options) {
-  if (options.num_results() < 1) {
-    return CreateStatusWithPayload(
-        absl::StatusCode::kInvalidArgument,
-        absl::StrFormat("SearchOptions.num_results must be > 0, found %d.",
-                        options.num_results()),
-        TfLiteSupportStatus::kInvalidArgumentError);
-  }
-  return absl::OkStatus();
-}
-
-absl::Status SanityCheckIndexConfig(const IndexConfig& config) {
-  switch (config.embedding_type()) {
-    case IndexConfig::UNSPECIFIED:
-      return CreateStatusWithPayload(
-          absl::StatusCode::kInvalidArgument,
-          "Invalid IndexConfig: embedding_type must not be left UNSPECIFIED.",
-          TfLiteSupportStatus::kInvalidArgumentError);
-    case IndexConfig::FLOAT:
-      if (config.scann_config().has_indexer()) {
-        return CreateStatusWithPayload(
-            absl::StatusCode::kInvalidArgument,
-            "Invalid IndexConfig: embedding_type is set to FLOAT but ScaNN "
-            "config specifies a product quantization codebook.",
-            TfLiteSupportStatus::kInvalidArgumentError);
-      }
-      break;
-    case IndexConfig::UINT8:
-      if (!config.scann_config().has_indexer()) {
-        return CreateStatusWithPayload(
-            absl::StatusCode::kInvalidArgument,
-            "Invalid IndexConfig: embedding_type is set to UINT8 but ScaNN "
-            "config doesn't specify a product quantization codebook.",
-            TfLiteSupportStatus::kInvalidArgumentError);
-      }
-      break;
-    default:
-      return CreateStatusWithPayload(
-          absl::StatusCode::kInternal,
-          "Invalid IndexConfig: unexpected value for embedding_type.",
-          TfLiteSupportStatus::kError);
-  }
-  return absl::OkStatus();
-}
-
-absl::StatusOr<DistanceMeasure> GetDistanceMeasure(
-    const ScannOnDeviceConfig& config) {
-  DistanceMeasure measure = config.query_distance();
-  if (measure == tflite::scann_ondevice::core::UNSPECIFIED) {
-    if (config.has_indexer() && config.indexer().has_asymmetric_hashing()) {
-      measure = config.indexer().asymmetric_hashing().query_distance();
-    } else if (config.has_partitioner()) {
-      measure = config.partitioner().query_distance();
-    } else {
-      return CreateStatusWithPayload(
-          absl::StatusCode::kInvalidArgument,
-          "ScaNN config does not provide mandatory DistanceMeasure.",
-          TfLiteSupportStatus::kInvalidArgumentError);
-    }
-
-    if (measure == tflite::scann_ondevice::core::UNSPECIFIED) {
-      return CreateStatusWithPayload(
-          absl::StatusCode::kInvalidArgument,
-          "UNSPECIFIED is not a valid value for ScaNN config DistanceMeasure.",
-          TfLiteSupportStatus::kInvalidArgumentError);
-    }
-
-    // Make sure the query distance in different places are consistent.
-    if (config.has_partitioner()) {
-      DistanceMeasure partitioner_measure =
-          config.partitioner().query_distance();
-      if (measure != partitioner_measure) {
-        return CreateStatusWithPayload(
-            absl::StatusCode::kInvalidArgument,
-            absl::StrFormat("DistanceMeasure %s is different from "
-                            "DistanceMeasure %s found in partitioner config.",
-                            DistanceMeasure_Name(measure),
-                            DistanceMeasure_Name(partitioner_measure)),
-            TfLiteSupportStatus::kInvalidArgumentError);
-      }
-    }
-  }
-  return measure;
-}
-
-absl::Status ConvertEmbeddingToEigenMatrix(const Embedding& embedding,
-                                           Eigen::MatrixXf* matrix) {
-  if (embedding.feature_vector().value_float().empty()) {
-    // This should be caught upstream at EmbeddingPostprocessor creation.
-    return CreateStatusWithPayload(absl::StatusCode::kInternal,
-                                   "Float query embedding is empty.",
-                                   TfLiteSupportStatus::kError);
-  }
-  Eigen::Map<const Eigen::VectorXf> query_ptr(
-      embedding.feature_vector().value_float().data(),
-      embedding.feature_vector().value_float().size());
-  matrix->resize(embedding.feature_vector().value_float().size(), 1);
-  matrix->col(0) = query_ptr;
-  return absl::OkStatus();
-}
-
-}  // namespace
-
-/* static */
-StatusOr<std::unique_ptr<SearchPostprocessor>> SearchPostprocessor::Create(
-    TfLiteEngine* engine,
-    int output_index,
-    std::unique_ptr<SearchOptions> search_options,
-    std::unique_ptr<EmbeddingOptions> embedding_options) {
-  ASSIGN_OR_RETURN(auto embedding_postprocessor,
-                   CreateEmbeddingPostprocessor(engine, {output_index},
-                                                std::move(embedding_options)));
-
-  ASSIGN_OR_RETURN(auto search_processor,
-                   Processor::Create<SearchPostprocessor>(
-                       /* num_expected_tensors =*/1, engine, {output_index},
-                       /* requires_metadata =*/false));
-
-  RETURN_IF_ERROR(search_processor->Init(std::move(embedding_postprocessor),
-                                         std::move(search_options)));
-  return search_processor;
-}
-
-StatusOr<SearchResult> SearchPostprocessor::Postprocess() {
-  // Extract embedding.
-  Embedding embedding;
-  RETURN_IF_ERROR(embedding_postprocessor_->Postprocess(&embedding));
-  // Convert embedding to Eigen matrix, as expected by ScaNN.
-  Eigen::MatrixXf query;
-  RETURN_IF_ERROR(ConvertEmbeddingToEigenMatrix(embedding, &query));
-
-  // Identify partitions to search.
-  std::vector<std::vector<int>> leaves_to_search(
-      1, std::vector<int>(num_leaves_to_search_, -1));
-  if (!partitioner_->Partition(query, &leaves_to_search)) {
-    return CreateStatusWithPayload(absl::StatusCode::kInternal,
-                                   "Partitioning failed.",
-                                   TfLiteSupportStatus::kError);
-  }
-
-  // Prepare search results.
-  std::vector<TopN> top_n;
-  top_n.emplace_back(
-      options_->num_results(),
-      std::make_pair(std::numeric_limits<float>::max(), kNoNeighborId));
-  // Perform search.
-  if (quantizer_) {
-    RETURN_IF_ERROR(
-        QuantizedSearch(query, leaves_to_search[0], absl::MakeSpan(top_n)));
-  } else {
-    RETURN_IF_ERROR(
-        LinearSearch(query, leaves_to_search[0], absl::MakeSpan(top_n)));
-  }
-
-  // Build results.
-  SearchResult search_result;
-  for (const auto& [distance, id] : top_n[0].Take()) {
-    if (id == kNoNeighborId) {
-      break;
-    }
-    ASSIGN_OR_RETURN(auto metadata, index_->GetMetadataAtIndex(id));
-    NearestNeighbor* nearest_neighbor = search_result.add_nearest_neighbors();
-    nearest_neighbor->set_distance(distance);
-    nearest_neighbor->set_metadata(std::string(metadata));
-  }
-  return search_result;
-}
-
-StatusOr<absl::string_view> SearchPostprocessor::GetUserInfo() {
-  return index_->GetUserInfo();
-}
-
-absl::Status SearchPostprocessor::Init(
-    std::unique_ptr<EmbeddingPostprocessor> embedding_postprocessor,
-    std::unique_ptr<SearchOptions> options) {
-  embedding_postprocessor_ = std::move(embedding_postprocessor);
-  RETURN_IF_ERROR(SanityCheckOptions(*options));
-  options_ = std::move(options);
-
-  // Initialize index.
-  ASSIGN_OR_RETURN(
-      index_file_handler_,
-      ExternalFileHandler::CreateFromExternalFile(&options_->index_file()));
-  auto index_file_content = index_file_handler_->GetFileContent();
-  ASSIGN_OR_RETURN(index_,
-                   Index::CreateFromIndexBuffer(index_file_content.data(),
-                                                index_file_content.size()));
-  ASSIGN_OR_RETURN(index_config_, index_->GetIndexConfig());
-  RETURN_IF_ERROR(SanityCheckIndexConfig(index_config_));
-  // Get distance measure once and for all.
-  ASSIGN_OR_RETURN(distance_measure_,
-                   GetDistanceMeasure(index_config_.scann_config()));
-
-  // Initialize partitioner.
-  if (index_config_.scann_config().has_partitioner()) {
-    partitioner_ = tflite::scann_ondevice::core::Partitioner::Create(
-        index_config_.scann_config().partitioner());
-    num_leaves_to_search_ = std::min(
-        static_cast<int>(ceilf(
-            partitioner_->NumPartitions() *
-            index_config_.scann_config().partitioner().search_fraction())),
-        partitioner_->NumPartitions());
-  } else {
-    partitioner_ =
-        absl::make_unique<tflite::scann_ondevice::core::NoOpPartitioner>();
-    num_leaves_to_search_ = partitioner_->NumPartitions();
-  }
-
-  // Initialize product quantizer if needed.
-  if (index_config_.scann_config().has_indexer()) {
-    quantizer_ = tflite::scann_ondevice::core::AsymmetricHashQuerier::Create(
-        index_config_.scann_config().indexer().asymmetric_hashing());
-  }
-
-  return absl::OkStatus();
-}
-
-absl::Status SearchPostprocessor::QuantizedSearch(
-    Eigen::Ref<Eigen::MatrixXf> query,
-    std::vector<int> leaves_to_search,
-    absl::Span<TopN> top_n) {
-  int dim = index_config_.embedding_dim();
-  // Prepare QueryInfo used for all leaves.
-  QueryInfo query_info;
-  if (!quantizer_->Process(query, &query_info)) {
-    return CreateStatusWithPayload(absl::StatusCode::kInternal,
-                                   "Query quantization failed.",
-                                   TfLiteSupportStatus::kError);
-  }
-  for (int leaf_id : leaves_to_search) {
-    // Load partition into Eigen matrix.
-    ASSIGN_OR_RETURN(auto partition, index_->GetPartitionAtIndex(leaf_id));
-    int partition_size = partition.size() / dim;
-    Eigen::Map<const Matrix8u> database(
-        reinterpret_cast<const uint8_t*>(partition.data()), dim,
-        partition_size);
-    // Perform search.
-    int global_offset = index_config_.global_partition_offsets(leaf_id);
-    if (!AsymmetricHashFindNeighbors(query_info, database, global_offset,
-                                     top_n)) {
-      return CreateStatusWithPayload(absl::StatusCode::kInternal,
-                                     "Nearest neighbor search failed.",
-                                     TfLiteSupportStatus::kError);
-    }
-  }
-  return absl::OkStatus();
-}
-
-absl::Status SearchPostprocessor::LinearSearch(
-    Eigen::Ref<Eigen::MatrixXf> query,
-    std::vector<int> leaves_to_search,
-    absl::Span<TopN> top_n) {
-  int dim = index_config_.embedding_dim();
-  for (int leaf_id : leaves_to_search) {
-    // Load partition into Eigen matrix.
-    ASSIGN_OR_RETURN(auto partition, index_->GetPartitionAtIndex(leaf_id));
-    int partition_size = partition.size() / (dim * sizeof(float));
-    Eigen::Map<const Eigen::MatrixXf> database(
-        reinterpret_cast<const float*>(partition.data()), dim, partition_size);
-    // Perform search.
-    int global_offset = index_config_.global_partition_offsets(leaf_id);
-    if (!FloatFindNeighbors(query, database, global_offset, distance_measure_,
-                            top_n)) {
-      return CreateStatusWithPayload(absl::StatusCode::kInternal,
-                                     "Nearest neighbor search failed.",
-                                     TfLiteSupportStatus::kError);
-    }
-  }
-  return absl::OkStatus();
-}
-
-}  // namespace processor
-}  // namespace task
-}  // namespace tflite
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/search_postprocessor.h b/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/search_postprocessor.h
deleted file mode 100644
index d79bc853148a9..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/cc/task/processor/search_postprocessor.h
+++ /dev/null
@@ -1,112 +0,0 @@
-/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#ifndef TENSORFLOW_LITE_SUPPORT_CC_TASK_PROCESSOR_SEARCH_POSTPROCESSOR_H_
-#define TENSORFLOW_LITE_SUPPORT_CC_TASK_PROCESSOR_SEARCH_POSTPROCESSOR_H_
-
-#include <cstdint>
-#include <initializer_list>
-#include <memory>
-#include <vector>
-
-#include "Eigen/Core"                  // from @eigen
-#include "absl/strings/string_view.h"  // from @com_google_absl
-#include "absl/types/span.h"           // from @com_google_absl
-#include "tensorflow_lite_support/cc/port/statusor.h"
-#include "tensorflow_lite_support/cc/task/core/external_file_handler.h"
-#include "tensorflow_lite_support/cc/task/core/tflite_engine.h"
-#include "tensorflow_lite_support/cc/task/processor/embedding_postprocessor.h"
-#include "tensorflow_lite_support/cc/task/processor/processor.h"
-#include "tensorflow_lite_support/cc/task/processor/proto/embedding_options.pb.h"
-#include "tensorflow_lite_support/cc/task/processor/proto/search_options.pb.h"
-#include "tensorflow_lite_support/cc/task/processor/proto/search_result.pb.h"
-#include "tensorflow_lite_support/scann_ondevice/cc/core/partitioner.h"
-#include "tensorflow_lite_support/scann_ondevice/cc/core/processor.h"
-#include "tensorflow_lite_support/scann_ondevice/cc/core/searcher.h"
-#include "tensorflow_lite_support/scann_ondevice/cc/core/serialized_searcher.pb.h"
-#include "tensorflow_lite_support/scann_ondevice/cc/core/top_n_amortized_constant.h"
-#include "tensorflow_lite_support/scann_ondevice/cc/index.h"
-#include "tensorflow_lite_support/scann_ondevice/proto/index_config.pb.h"
-
-namespace tflite {
-namespace task {
-namespace processor {
-
-// Postprocessor in charge of performing embedding extraction followed by
-// nearest-neighbor search.
-//
-// This postprocessor works with the following output tensor:
-//   (kTfLiteUInt8/kTfLiteFloat32)
-//    - `N` components corresponding to the `N` dimensions of the returned
-//      feature vector for this output layer.
-//    - Either 2 or 4 dimensions, i.e. `[1 x N]` or `[1 x 1 x 1 x N]`.
-class SearchPostprocessor : public Postprocessor {
- public:
-  static tflite::support::StatusOr<std::unique_ptr<SearchPostprocessor>> Create(
-      tflite::task::core::TfLiteEngine* engine,
-      int output_index,
-      std::unique_ptr<SearchOptions> search_options,
-      std::unique_ptr<EmbeddingOptions> embedding_options =
-          std::make_unique<EmbeddingOptions>());
-
-  // Converts the tensor outputs to embeddings, then performs a nearest-neighbor
-  // search in the index.
-  tflite::support::StatusOr<SearchResult> Postprocess();
-
-  // Provides access to the opaque user info stored in the index file (if any),
-  // in raw binary form. Returns an empty string if the index doesn't contain
-  // user info.
-  tflite::support::StatusOr<absl::string_view> GetUserInfo();
-
- private:
-  using Postprocessor::Postprocessor;
-
-  absl::Status Init(
-      std::unique_ptr<EmbeddingPostprocessor> embedding_postprocessor,
-      std::unique_ptr<SearchOptions> options);
-
-  absl::Status QuantizedSearch(
-      Eigen::Ref<Eigen::MatrixXf> query,
-      std::vector<int> leaves_to_search,
-      absl::Span<tflite::scann_ondevice::core::TopN> top_n);
-  absl::Status LinearSearch(
-      Eigen::Ref<Eigen::MatrixXf> query,
-      std::vector<int> leaves_to_search,
-      absl::Span<tflite::scann_ondevice::core::TopN> top_n);
-
-  std::unique_ptr<SearchOptions> options_;
-
-  // Encapsulated EmbeddingPostprocessor converting raw tensors to embeddings.
-  std::unique_ptr<EmbeddingPostprocessor> embedding_postprocessor_;
-
-  // Index management.
-  std::unique_ptr<tflite::task::core::ExternalFileHandler> index_file_handler_;
-  std::unique_ptr<tflite::scann_ondevice::Index> index_;
-  tflite::scann_ondevice::IndexConfig index_config_;
-
-  // ScaNN management.
-  int num_leaves_to_search_;
-  tflite::scann_ondevice::core::DistanceMeasure distance_measure_;
-  std::unique_ptr<tflite::scann_ondevice::core::PartitionerInterface>
-      partitioner_;
-  std::shared_ptr<tflite::scann_ondevice::core::AsymmetricHashQuerier>
-      quantizer_;
-};
-
-}  // namespace processor
-}  // namespace task
-}  // namespace tflite
-
-#endif  // TENSORFLOW_LITE_SUPPORT_CC_TASK_PROCESSOR_SEARCH_POSTPROCESSOR_H_
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/ios/utils/Sources/TFLStringUtil.mm b/third_party/tflite_support/src/tensorflow_lite_support/ios/utils/Sources/TFLStringUtil.mm
deleted file mode 100644
index 2a11bb6730474..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/ios/utils/Sources/TFLStringUtil.mm
+++ /dev/null
@@ -1,26 +0,0 @@
-/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-#import "third_party/tensorflow_lite_support/ios/utils/Sources/TFLStringUtil.h"
-
-std::string MakeString(NSString* str) {
-  return std::string([str UTF8String]);
-}
-
-NSString* MakeNSString(const std::string& str) {
-  return [[NSString alloc]
-      initWithBytes:const_cast<void*>(static_cast<const void*>(str.data()))
-             length:str.length()
-           encoding:NSUTF8StringEncoding];
-}
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/metadata_populator.cc b/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/metadata_populator.cc
deleted file mode 100644
index 2841c730adfd1..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/metadata_populator.cc
+++ /dev/null
@@ -1,150 +0,0 @@
-/* Copyright 2021 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#include "tensorflow_lite_support/metadata/cc/metadata_populator.h"
-
-#include <cstdlib>
-#include <cstring>
-#include <functional>
-
-#include "contrib/minizip/ioapi.h"
-#include "contrib/minizip/zip.h"
-#include "flatbuffers/flatbuffers.h"  // from @flatbuffers
-#include "tensorflow/lite/schema/schema_generated.h"
-#include "tensorflow_lite_support/cc/common.h"
-#include "tensorflow_lite_support/cc/port/status_macros.h"
-#include "tensorflow_lite_support/cc/port/statusor.h"
-#include "tensorflow_lite_support/metadata/cc/utils/zip_mem_file.h"
-#include "tensorflow_lite_support/metadata/metadata_schema_generated.h"
-
-namespace tflite {
-namespace metadata {
-
-namespace {
-constexpr char kMetadataBufferName[] = "TFLITE_METADATA";
-
-using ::absl::StatusCode;
-using ::tflite::support::CreateStatusWithPayload;
-using ::tflite::support::TfLiteSupportStatus;
-
-}  // namespace
-
-ModelMetadataPopulator::ModelMetadataPopulator(const tflite::Model& model) {
-  model.UnPackTo(&model_t_);
-}
-
-/* static */
-tflite::support::StatusOr<std::unique_ptr<ModelMetadataPopulator>>
-ModelMetadataPopulator::CreateFromModelBuffer(const char* buffer_data,
-                                              size_t buffer_size) {
-  // Rely on the simplest, base flatbuffers verifier. Here is not the place to
-  // e.g. use an OpResolver: we just want to make sure the buffer is valid to
-  // access the metadata.
-  flatbuffers::Verifier verifier = flatbuffers::Verifier(
-      reinterpret_cast<const uint8_t*>(buffer_data), buffer_size);
-  if (!tflite::VerifyModelBuffer(verifier)) {
-    return CreateStatusWithPayload(
-        StatusCode::kInvalidArgument,
-        "The model is not a valid FlatBuffer buffer.",
-        TfLiteSupportStatus::kInvalidFlatBufferError);
-  }
-  // Use absl::WrapUnique() to call private constructor:
-  // https://abseil.io/tips/126.
-  return absl::WrapUnique(
-      new ModelMetadataPopulator(*tflite::GetModel(buffer_data)));
-}
-
-void ModelMetadataPopulator::LoadMetadata(const char* metadata_buffer_data,
-                                          size_t metadata_buffer_size) {
-  // Pack the model metadata in a buffer.
-  auto model_metadata_buffer = std::make_unique<tflite::BufferT>();
-  model_metadata_buffer->data = {metadata_buffer_data,
-                                 metadata_buffer_data + metadata_buffer_size};
-  // Check if the model already has metadata. If so, just override the buffer
-  // and exit.
-  for (const auto& metadata_t : model_t_.metadata) {
-    if (metadata_t->name == kMetadataBufferName) {
-      model_t_.buffers[metadata_t->buffer] = std::move(model_metadata_buffer);
-      return;
-    }
-  }
-  // Model doesn't already have metadata: add metadata buffer and pointer to the
-  // buffer in the model metadata section.
-  model_t_.buffers.push_back(std::move(model_metadata_buffer));
-  auto metadata_t = std::make_unique<tflite::MetadataT>();
-  metadata_t->name = kMetadataBufferName;
-  metadata_t->buffer = model_t_.buffers.size() - 1;
-  model_t_.metadata.push_back(std::move(metadata_t));
-}
-
-void ModelMetadataPopulator::LoadAssociatedFiles(
-    const absl::flat_hash_map<std::string, std::string>& associated_files) {
-  associated_files_ = associated_files;
-}
-
-tflite::support::StatusOr<std::string>
-ModelMetadataPopulator::AppendAssociatedFiles(const char* model_buffer_data,
-                                              size_t model_buffer_size) {
-  // Create in-memory zip file.
-  ZipMemFile mem_file = ZipMemFile(model_buffer_data, model_buffer_size);
-  // Open zip.
-  zipFile zf = zipOpen2(/*pathname=*/nullptr, APPEND_STATUS_CREATEAFTER,
-                        /*globalcomment=*/nullptr, &mem_file.GetFileFuncDef());
-  if (zf == nullptr) {
-    return CreateStatusWithPayload(
-        StatusCode::kUnknown, "Unable to open zip archive",
-        TfLiteSupportStatus::kMetadataAssociatedFileZipError);
-  }
-  // Write associated files.
-  for (const auto& [name, contents] : associated_files_) {
-    if ((zipOpenNewFileInZip(zf, name.c_str(),
-                             /*zipfi=*/nullptr,
-                             /*extrafield_local=*/nullptr,
-                             /*size_extrafield_local=*/0,
-                             /*extrafield_global=*/nullptr,
-                             /*size_extrafield_global=*/0,
-                             /*comment=*/nullptr,
-                             /*method=*/0,
-                             /*level=*/Z_DEFAULT_COMPRESSION) != ZIP_OK) ||
-        (zipWriteInFileInZip(zf, contents.data(), contents.length()) !=
-         ZIP_OK) ||
-        (zipCloseFileInZip(zf) != ZIP_OK)) {
-      return CreateStatusWithPayload(
-          StatusCode::kUnknown, "Unable to write file to zip archive",
-          TfLiteSupportStatus::kMetadataAssociatedFileZipError);
-    }
-  }
-  // Close zip.
-  if (zipClose(zf, /*global_comment=*/nullptr) != ZIP_OK) {
-    return CreateStatusWithPayload(
-        StatusCode::kUnknown, "Unable to close zip archive",
-        TfLiteSupportStatus::kMetadataAssociatedFileZipError);
-  }
-  // Return as a string.
-  return std::string(mem_file.GetFileContent());
-}
-
-tflite::support::StatusOr<std::string> ModelMetadataPopulator::Populate() {
-  // Build model.
-  flatbuffers::FlatBufferBuilder model_fbb;
-  model_fbb.Finish(tflite::Model::Pack(model_fbb, &model_t_),
-                   tflite::ModelIdentifier());
-  return AppendAssociatedFiles(
-      reinterpret_cast<char*>(model_fbb.GetBufferPointer()),
-      model_fbb.GetSize());
-}
-
-}  // namespace metadata
-}  // namespace tflite
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/utils/zip_mem_file.cc b/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/utils/zip_mem_file.cc
deleted file mode 100644
index f2b07e2054dfb..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/utils/zip_mem_file.cc
+++ /dev/null
@@ -1,134 +0,0 @@
-/* Copyright 2021 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#include "tensorflow_lite_support/metadata/cc/utils/zip_mem_file.h"
-
-#include <algorithm>
-#include <cstdio>
-
-#include "absl/strings/string_view.h"  // from @com_google_absl
-#include "contrib/minizip/ioapi.h"
-
-namespace tflite {
-namespace metadata {
-
-ZipMemFile::ZipMemFile(const char* buffer, size_t size)
-    : data_(buffer, size), offset_(0) {
-  zlib_filefunc_def_.zopen_file = OpenFile;
-  zlib_filefunc_def_.zread_file = ReadFile;
-  zlib_filefunc_def_.zwrite_file = WriteFile;
-  zlib_filefunc_def_.ztell_file = TellFile;
-  zlib_filefunc_def_.zseek_file = SeekFile;
-  zlib_filefunc_def_.zclose_file = CloseFile;
-  zlib_filefunc_def_.zerror_file = ErrorFile;
-  zlib_filefunc_def_.opaque = this;
-}
-
-zlib_filefunc_def& ZipMemFile::GetFileFuncDef() {
-  return zlib_filefunc_def_;
-}
-
-absl::string_view ZipMemFile::GetFileContent() const {
-  return data_;
-}
-
-/* static */
-voidpf ZipMemFile::OpenFile(voidpf opaque, const char* filename, int mode) {
-  // Result is never used, but needs to be non-null for `zipOpen2` not to fail.
-  return opaque;
-}
-
-/* static */
-size_t ZipMemFile::ReadFile(voidpf opaque,
-                            voidpf stream,
-                            void* buf,
-                            size_t size) {
-  auto* mem_file = static_cast<ZipMemFile*>(opaque);
-  if (mem_file->offset_ < 0 || mem_file->Size() < mem_file->offset_) {
-    return 0;
-  }
-  if (mem_file->offset_ + size > mem_file->Size()) {
-    size = mem_file->Size() - mem_file->offset_;
-  }
-  memcpy(buf,
-         static_cast<const char*>(mem_file->data_.c_str()) + mem_file->offset_,
-         size);
-  mem_file->offset_ += size;
-  return size;
-}
-
-/* static */
-size_t ZipMemFile::WriteFile(voidpf opaque,
-                             voidpf stream,
-                             const void* buf,
-                             size_t size) {
-  auto* mem_file = static_cast<ZipMemFile*>(opaque);
-  if (mem_file->offset_ + size > mem_file->Size()) {
-    mem_file->data_.resize(mem_file->offset_ + size);
-  }
-  mem_file->data_.replace(mem_file->offset_, size,
-                          static_cast<const char*>(buf), size);
-  mem_file->offset_ += size;
-  return size;
-}
-
-/* static */
-ptrdiff_t ZipMemFile::TellFile(voidpf opaque, voidpf stream) {
-  return static_cast<ZipMemFile*>(opaque)->offset_;
-}
-
-/* static */
-ptrdiff_t ZipMemFile::SeekFile(voidpf opaque,
-                               voidpf stream,
-                               size_t offset,
-                               int origin) {
-  auto* mem_file = static_cast<ZipMemFile*>(opaque);
-  switch (origin) {
-    case SEEK_SET:
-      mem_file->offset_ = offset;
-      return 0;
-    case SEEK_CUR:
-      if (mem_file->offset_ + offset < 0 ||
-          mem_file->offset_ + offset > mem_file->Size()) {
-        return -1;
-      }
-      mem_file->offset_ += offset;
-      return 0;
-    case SEEK_END:
-      if (mem_file->Size() - offset < 0 ||
-          mem_file->Size() - offset > mem_file->Size()) {
-        return -1;
-      }
-      mem_file->offset_ = offset + mem_file->Size();
-      return 0;
-    default:
-      return -1;
-  }
-}
-
-/* static */
-int ZipMemFile::CloseFile(voidpf opaque, voidpf stream) {
-  // Nothing to do.
-  return 0;
-}
-
-/* static */
-int ZipMemFile::ErrorFile(voidpf opaque, voidpf stream) {
-  // Unused.
-  return 0;
-}
-
-}  // namespace metadata
-}  // namespace tflite
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/utils/zip_mem_file.h b/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/utils/zip_mem_file.h
deleted file mode 100644
index d6748fcbe9ee1..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/metadata/cc/utils/zip_mem_file.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/* Copyright 2021 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#ifndef TENSORFLOW_LITE_SUPPORT_METADATA_CC_UTILS_ZIP_MEM_FILE_H_
-#define TENSORFLOW_LITE_SUPPORT_METADATA_CC_UTILS_ZIP_MEM_FILE_H_
-
-#include <cstdlib>
-
-#include "absl/strings/string_view.h"  // from @com_google_absl
-#include "contrib/minizip/ioapi.h"
-
-namespace tflite {
-namespace metadata {
-
-// In-memory zip file implementation.
-//
-// Adapted from [1], with a few key differences:
-// * backed by an `std::string` instead of malloc-ed C buffers,
-// * supports opening the file for writing through `zipOpen2`.
-//
-// [1]:
-// https://github.com/google/libkml/blob/master/third_party/zlib-1.2.3/contrib/minizip/iomem_simple.c
-class ZipMemFile {
- public:
-  // Constructs an in-memory zip file from a buffer.
-  ZipMemFile(const char* buffer, size_t size);
-  // Provides access to the `zlib_filefunc_def` implementation for the in-memory
-  // zip file.
-  zlib_filefunc_def& GetFileFuncDef();
-  // Provides access to the file contents.
-  absl::string_view GetFileContent() const;
-
- private:
-  // The string backing the in-memory file.
-  std::string data_;
-  // The current offset in the file.
-  size_t offset_;
-  // The `zlib_filefunc_def` implementation for this in-memory zip file.
-  zlib_filefunc_def zlib_filefunc_def_;
-
-  // Convenience function to access the current data size.
-  size_t Size() const { return data_.size(); }
-
-  // The file function implementations used in the `zlib_filefunc_def`.
-  static voidpf OpenFile(voidpf opaque, const char* filename, int mode);
-  static size_t ReadFile(voidpf opaque, voidpf stream, void* buf, size_t size);
-  static size_t WriteFile(voidpf opaque,
-                          voidpf stream,
-                          const void* buf,
-                          size_t size);
-  static ptrdiff_t TellFile(voidpf opaque, voidpf stream);
-  static ptrdiff_t SeekFile(voidpf opaque,
-                            voidpf stream,
-                            size_t offset,
-                            int origin);
-  static int CloseFile(voidpf opaque, voidpf stream);
-  static int ErrorFile(voidpf opaque, voidpf stream);
-};
-
-}  // namespace metadata
-}  // namespace tflite
-
-#endif  // TENSORFLOW_LITE_SUPPORT_METADATA_CC_UTILS_ZIP_MEM_FILE_H_
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/python/task/audio/pybinds/_pywrap_audio_classifier.cc b/third_party/tflite_support/src/tensorflow_lite_support/python/task/audio/pybinds/_pywrap_audio_classifier.cc
deleted file mode 100644
index b5969e4e82bf8..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/python/task/audio/pybinds/_pywrap_audio_classifier.cc
+++ /dev/null
@@ -1,84 +0,0 @@
-/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#include "pybind11/pybind11.h"
-#include "pybind11_protobuf/native_proto_caster.h"  // from @pybind11_protobuf
-#include "tensorflow_lite_support/cc/task/audio/audio_classifier.h"
-#include "tensorflow_lite_support/cc/task/audio/core/audio_buffer.h"
-#include "tensorflow_lite_support/cc/task/processor/proto/classification_options.pb.h"
-#include "tensorflow_lite_support/python/task/core/pybinds/task_utils.h"
-
-namespace tflite {
-namespace task {
-namespace audio {
-
-namespace {
-namespace py = ::pybind11;
-using PythonBaseOptions = ::tflite::python::task::core::BaseOptions;
-using CppBaseOptions = ::tflite::task::core::BaseOptions;
-}  // namespace
-
-PYBIND11_MODULE(_pywrap_audio_classifier, m) {
-  // python wrapper for C++ AudioClassifier class which shouldn't be directly
-  // used by the users.
-  pybind11_protobuf::ImportNativeProtoCasters();
-
-  py::class_<AudioClassifier>(m, "AudioClassifier")
-      .def_static(
-          "create_from_options",
-          [](const PythonBaseOptions& base_options,
-             const processor::ClassificationOptions& classification_options) {
-            AudioClassifierOptions options;
-            auto cpp_base_options =
-                core::convert_to_cpp_base_options(base_options);
-            options.set_allocated_base_options(cpp_base_options.release());
-
-            if (classification_options.has_display_names_locale()) {
-              options.set_display_names_locale(
-                  classification_options.display_names_locale());
-            }
-            if (classification_options.has_max_results()) {
-              options.set_max_results(classification_options.max_results());
-            }
-            if (classification_options.has_score_threshold()) {
-              options.set_score_threshold(
-                  classification_options.score_threshold());
-            }
-            options.mutable_class_name_allowlist()->CopyFrom(
-                classification_options.class_name_allowlist());
-            options.mutable_class_name_denylist()->CopyFrom(
-                classification_options.class_name_denylist());
-
-            auto classifier = AudioClassifier::CreateFromOptions(options);
-            return core::get_value(classifier);
-          })
-      .def("classify",
-           [](AudioClassifier& self,
-              const AudioBuffer& audio_buffer) -> ClassificationResult {
-             auto classification_result = self.Classify(audio_buffer);
-             return core::get_value(classification_result);
-           })
-      .def("get_required_audio_format",
-           [](AudioClassifier& self) -> AudioBuffer::AudioFormat {
-             auto audio_format = self.GetRequiredAudioFormat();
-             return core::get_value(audio_format);
-           })
-      .def("get_required_input_buffer_size",
-           &AudioClassifier::GetRequiredInputBufferSize);
-}
-
-}  // namespace audio
-}  // namespace task
-}  // namespace tflite
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/python/task/audio/pybinds/_pywrap_audio_embedder.cc b/third_party/tflite_support/src/tensorflow_lite_support/python/task/audio/pybinds/_pywrap_audio_embedder.cc
deleted file mode 100644
index 8b1d67d9f8e05..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/python/task/audio/pybinds/_pywrap_audio_embedder.cc
+++ /dev/null
@@ -1,78 +0,0 @@
-/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#include "pybind11/pybind11.h"
-#include "pybind11_protobuf/native_proto_caster.h"  // from @pybind11_protobuf
-#include "tensorflow_lite_support/cc/task/audio/audio_embedder.h"
-#include "tensorflow_lite_support/cc/task/audio/core/audio_buffer.h"
-#include "tensorflow_lite_support/cc/task/processor/proto/embedding.pb.h"
-#include "tensorflow_lite_support/python/task/core/pybinds/task_utils.h"
-
-namespace tflite {
-namespace task {
-namespace audio {
-
-namespace {
-namespace py = ::pybind11;
-using PythonBaseOptions = ::tflite::python::task::core::BaseOptions;
-using CppBaseOptions = ::tflite::task::core::BaseOptions;
-}  // namespace
-
-PYBIND11_MODULE(_pywrap_audio_embedder, m) {
-  // python wrapper for C++ AudioEmbedder class which shouldn't be directly used
-  // by the users.
-  pybind11_protobuf::ImportNativeProtoCasters();
-
-  py::class_<AudioEmbedder>(m, "AudioEmbedder")
-      .def_static(
-          "create_from_options",
-          [](const PythonBaseOptions& base_options,
-             const processor::EmbeddingOptions& embedding_options) {
-            AudioEmbedderOptions options;
-            auto cpp_base_options =
-                core::convert_to_cpp_base_options(base_options);
-
-            options.set_allocated_base_options(cpp_base_options.release());
-            options.add_embedding_options()->CopyFrom(embedding_options);
-            auto embedder = AudioEmbedder::CreateFromOptions(options);
-            return core::get_value(embedder);
-          })
-      .def_static("cosine_similarity",
-                  [](const processor::FeatureVector& u,
-                     const processor::FeatureVector& v) -> double {
-                    auto similarity = AudioEmbedder::CosineSimilarity(u, v);
-                    return core::get_value(similarity);
-                  })
-      .def("embed",
-           [](AudioEmbedder& self,
-              const AudioBuffer& audio_buffer) -> processor::EmbeddingResult {
-             auto embedding_result = self.Embed(audio_buffer);
-             return core::get_value(embedding_result);
-           })
-      .def("get_embedding_dimension", &AudioEmbedder::GetEmbeddingDimension)
-      .def("get_number_of_output_layers",
-           &AudioEmbedder::GetNumberOfOutputLayers)
-      .def("get_required_audio_format",
-           [](AudioEmbedder& self) -> AudioBuffer::AudioFormat {
-             auto audio_format = self.GetRequiredAudioFormat();
-             return core::get_value(audio_format);
-           })
-      .def("get_required_input_buffer_size",
-           &AudioEmbedder::GetRequiredInputBufferSize);
-}
-
-}  // namespace audio
-}  // namespace task
-}  // namespace tflite
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/python/task/text/pybinds/_pywrap_text_embedder.cc b/third_party/tflite_support/src/tensorflow_lite_support/python/task/text/pybinds/_pywrap_text_embedder.cc
deleted file mode 100644
index e148bdb773655..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/python/task/text/pybinds/_pywrap_text_embedder.cc
+++ /dev/null
@@ -1,68 +0,0 @@
-/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#include "pybind11/pybind11.h"
-#include "pybind11_protobuf/native_proto_caster.h"  // from @pybind11_protobuf
-#include "tensorflow_lite_support/cc/task/text/text_embedder.h"
-#include "tensorflow_lite_support/python/task/core/pybinds/task_utils.h"
-
-namespace tflite {
-namespace task {
-namespace text {
-
-namespace {
-using PythonBaseOptions = ::tflite::python::task::core::BaseOptions;
-using CppBaseOptions = ::tflite::task::core::BaseOptions;
-}  // namespace
-
-PYBIND11_MODULE(_pywrap_text_embedder, m) {
-  // python wrapper for C++ TextEmbeder class which shouldn't be directly used
-  // by the users.
-  pybind11_protobuf::ImportNativeProtoCasters();
-
-  pybind11::class_<TextEmbedder>(m, "TextEmbedder")
-      .def_static(
-          "create_from_options",
-          [](const PythonBaseOptions& base_options,
-             const processor::EmbeddingOptions& embedding_options) {
-            TextEmbedderOptions options;
-            auto cpp_base_options =
-                core::convert_to_cpp_base_options(base_options);
-
-            options.set_allocated_base_options(cpp_base_options.release());
-            options.add_embedding_options()->CopyFrom(embedding_options);
-            auto embedder = TextEmbedder::CreateFromOptions(options);
-            return core::get_value(embedder);
-          })
-      .def("embed",
-           [](TextEmbedder& self,
-              const std::string& text) -> processor::EmbeddingResult {
-             auto embedding_result = self.Embed(text);
-             return core::get_value(embedding_result);
-           })
-      .def("get_embedding_dimension", &TextEmbedder::GetEmbeddingDimension)
-      .def("get_number_of_output_layers",
-           &TextEmbedder::GetNumberOfOutputLayers)
-      .def_static("cosine_similarity",
-                  [](const processor::FeatureVector& u,
-                     const processor::FeatureVector& v) -> double {
-                    auto similarity = TextEmbedder::CosineSimilarity(u, v);
-                    return core::get_value(similarity);
-                  });
-}
-
-}  // namespace text
-}  // namespace task
-}  // namespace tflite
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/python/task/vision/core/pybinds/image_utils.cc b/third_party/tflite_support/src/tensorflow_lite_support/python/task/vision/core/pybinds/image_utils.cc
deleted file mode 100644
index 3b6bf2fc44dc5..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/python/task/vision/core/pybinds/image_utils.cc
+++ /dev/null
@@ -1,68 +0,0 @@
-/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-#include "tensorflow_lite_support/examples/task/vision/desktop/utils/image_utils.h"
-
-#include "pybind11/pybind11.h"
-#include "pybind11_abseil/status_casters.h"  // from @pybind11_abseil
-
-namespace tflite {
-namespace task {
-namespace vision {
-
-namespace {
-namespace py = ::pybind11;
-
-}  //  namespace
-
-PYBIND11_MODULE(image_utils, m) {
-  // python wrapper for ImageData class which shouldn't be directly used by
-  // the users.
-  pybind11::google::ImportStatusModule();
-
-  py::class_<ImageData>(m, "ImageData", py::buffer_protocol())
-      .def(py::init([](py::buffer buffer) {
-        py::buffer_info info = buffer.request();
-
-        if (info.ndim != 2 && info.ndim != 3) {
-          throw py::value_error("Incompatible buffer dimension!");
-        }
-
-        int height = info.shape[0];
-        int width = info.shape[1];
-        int channels = info.ndim == 3 ? info.shape[2] : 1;
-
-        return ImageData{static_cast<uint8*>(info.ptr), width, height,
-                         channels};
-      }))
-      .def_readonly("width", &ImageData::width)
-      .def_readonly("height", &ImageData::height)
-      .def_readonly("channels", &ImageData::channels)
-      .def_buffer([](ImageData& data) -> py::buffer_info {
-        return py::buffer_info(
-            data.pixel_data, sizeof(uint8),
-            py::format_descriptor<uint8>::format(), 3,
-            {data.height, data.width, data.channels},
-            {sizeof(uint8) * size_t(data.width) * size_t(data.channels),
-             sizeof(uint8) * size_t(data.channels), sizeof(uint8)});
-      });
-
-  m.def("DecodeImageFromFile", &DecodeImageFromFile);
-  m.def("EncodeImageToPngFile", &EncodeImageToPngFile);
-  m.def("ImageDataFree", &ImageDataFree);
-}
-
-}  // namespace vision
-}  // namespace task
-}  // namespace tflite
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/python/task/vision/pybinds/_pywrap_image_classifier.cc b/third_party/tflite_support/src/tensorflow_lite_support/python/task/vision/pybinds/_pywrap_image_classifier.cc
deleted file mode 100644
index f3f478d6f4f74..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/python/task/vision/pybinds/_pywrap_image_classifier.cc
+++ /dev/null
@@ -1,108 +0,0 @@
-/* Copyright 2021 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#include "pybind11/pybind11.h"
-#include "pybind11_protobuf/native_proto_caster.h"  // from @pybind11_protobuf
-#include "tensorflow_lite_support/cc/task/processor/proto/bounding_box.pb.h"
-#include "tensorflow_lite_support/cc/task/processor/proto/classification_options.pb.h"
-#include "tensorflow_lite_support/cc/task/processor/proto/classifications.pb.h"
-#include "tensorflow_lite_support/cc/task/vision/image_classifier.h"
-#include "tensorflow_lite_support/examples/task/vision/desktop/utils/image_utils.h"
-#include "tensorflow_lite_support/python/task/core/pybinds/task_utils.h"
-
-namespace tflite {
-namespace task {
-namespace vision {
-
-namespace {
-namespace py = ::pybind11;
-using PythonBaseOptions = ::tflite::python::task::core::BaseOptions;
-using CppBaseOptions = ::tflite::task::core::BaseOptions;
-}  // namespace
-
-PYBIND11_MODULE(_pywrap_image_classifier, m) {
-  // python wrapper for C++ ImageClassifier class which shouldn't be directly
-  // used by the users.
-  pybind11_protobuf::ImportNativeProtoCasters();
-
-  py::class_<ImageClassifier>(m, "ImageClassifier")
-      .def_static(
-          "create_from_options",
-          [](const PythonBaseOptions& base_options,
-             const processor::ClassificationOptions& classification_options) {
-            ImageClassifierOptions options;
-            auto cpp_base_options =
-                core::convert_to_cpp_base_options(base_options);
-            options.set_allocated_base_options(cpp_base_options.release());
-
-            if (classification_options.has_display_names_locale()) {
-              options.set_display_names_locale(
-                  classification_options.display_names_locale());
-            }
-            if (classification_options.has_max_results()) {
-              options.set_max_results(classification_options.max_results());
-            }
-            if (classification_options.has_score_threshold()) {
-              options.set_score_threshold(
-                  classification_options.score_threshold());
-            }
-            options.mutable_class_name_whitelist()->CopyFrom(
-                classification_options.class_name_allowlist());
-            options.mutable_class_name_blacklist()->CopyFrom(
-                classification_options.class_name_denylist());
-
-            auto classifier = ImageClassifier::CreateFromOptions(options);
-            return core::get_value(classifier);
-          })
-      .def("classify",
-           [](ImageClassifier& self,
-              const ImageData& image_data) -> processor::ClassificationResult {
-             auto frame_buffer = CreateFrameBufferFromImageData(image_data);
-             auto vision_classification_result =
-                 self.Classify(*core::get_value(frame_buffer));
-             // Convert from vision::ClassificationResult to
-             // processor::ClassificationResult as required by the Python layer.
-             processor::ClassificationResult classification_result;
-             classification_result.ParseFromString(
-                 core::get_value(vision_classification_result)
-                     .SerializeAsString());
-             return classification_result;
-           })
-      .def("classify",
-           [](ImageClassifier& self, const ImageData& image_data,
-              const processor::BoundingBox& bounding_box)
-               -> processor::ClassificationResult {
-             // Convert from processor::BoundingBox to vision::BoundingBox as
-             // the latter is used in the C++ layer.
-             BoundingBox vision_bounding_box;
-             vision_bounding_box.ParseFromString(
-                 bounding_box.SerializeAsString());
-
-             auto frame_buffer = CreateFrameBufferFromImageData(image_data);
-             auto vision_classification_result = self.Classify(
-                 *core::get_value(frame_buffer), vision_bounding_box);
-             // Convert from vision::ClassificationResult to
-             // processor::ClassificationResult as required by the Python layer.
-             processor::ClassificationResult classification_result;
-             classification_result.ParseFromString(
-                 core::get_value(vision_classification_result)
-                     .SerializeAsString());
-             return classification_result;
-           });
-}
-
-}  // namespace vision
-}  // namespace task
-}  // namespace tflite
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/python/task/vision/pybinds/_pywrap_image_embedder.cc b/third_party/tflite_support/src/tensorflow_lite_support/python/task/vision/pybinds/_pywrap_image_embedder.cc
deleted file mode 100644
index 91c8db80ffaba..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/python/task/vision/pybinds/_pywrap_image_embedder.cc
+++ /dev/null
@@ -1,145 +0,0 @@
-/* Copyright 2021 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#include <stdexcept>
-
-#include "pybind11/pybind11.h"
-#include "pybind11_protobuf/native_proto_caster.h"  // from @pybind11_protobuf
-#include "tensorflow_lite_support/cc/task/processor/proto/bounding_box.pb.h"
-#include "tensorflow_lite_support/cc/task/processor/proto/embedding.pb.h"
-#include "tensorflow_lite_support/cc/task/vision/image_embedder.h"
-#include "tensorflow_lite_support/examples/task/vision/desktop/utils/image_utils.h"
-#include "tensorflow_lite_support/python/task/core/pybinds/task_utils.h"
-
-namespace tflite {
-namespace task {
-namespace vision {
-
-namespace {
-namespace py = ::pybind11;
-using PythonBaseOptions = ::tflite::python::task::core::BaseOptions;
-using CppBaseOptions = ::tflite::task::core::BaseOptions;
-}  // namespace
-
-PYBIND11_MODULE(_pywrap_image_embedder, m) {
-  // python wrapper for C++ ImageEmbeder class which shouldn't be directly used
-  // by the users.
-  pybind11_protobuf::ImportNativeProtoCasters();
-
-  py::class_<ImageEmbedder>(m, "ImageEmbedder")
-      .def_static(
-          "create_from_options",
-          [](const PythonBaseOptions& base_options,
-             const processor::EmbeddingOptions& embedding_options) {
-            ImageEmbedderOptions options;
-            if (base_options.has_file_content()) {
-              options.mutable_model_file_with_metadata()->set_file_content(
-                  base_options.file_content());
-            }
-            if (base_options.has_file_name()) {
-              options.mutable_model_file_with_metadata()->set_file_name(
-                  base_options.file_name());
-            }
-
-            options.set_num_threads(base_options.num_threads());
-            if (base_options.use_coral()) {
-              options.mutable_compute_settings()
-                  ->mutable_tflite_settings()
-                  ->set_delegate(tflite::proto::Delegate::EDGETPU_CORAL);
-            }
-
-            if (embedding_options.has_l2_normalize()) {
-              options.set_l2_normalize(embedding_options.l2_normalize());
-            }
-            if (embedding_options.has_quantize()) {
-              options.set_quantize(embedding_options.quantize());
-            }
-            auto embedder = ImageEmbedder::CreateFromOptions(options);
-            return get_value(embedder);
-          })
-      .def("embed",
-           [](ImageEmbedder& self,
-              const ImageData& image_data) -> processor::EmbeddingResult {
-             auto frame_buffer = CreateFrameBufferFromImageData(image_data);
-             auto vision_embedding_result =
-                 self.Embed(*core::get_value(frame_buffer));
-             // Convert from vision::EmbeddingResult to
-             // processor::EmbeddingResult
-             processor::EmbeddingResult embedding_result;
-             embedding_result.ParseFromString(
-                 core::get_value(vision_embedding_result).SerializeAsString());
-             return embedding_result;
-           })
-      .def("embed",
-           [](ImageEmbedder& self, const ImageData& image_data,
-              const processor::BoundingBox& bounding_box)
-               -> processor::EmbeddingResult {
-             // Convert from processor::BoundingBox to vision::BoundingBox as
-             // the later is used in the C++ layer.
-             BoundingBox vision_bounding_box;
-             vision_bounding_box.ParseFromString(
-                 bounding_box.SerializeAsString());
-
-             auto frame_buffer = CreateFrameBufferFromImageData(image_data);
-             auto vision_embedding_result = self.Embed(
-                 *core::get_value(frame_buffer), vision_bounding_box);
-             // Convert from vision::EmbeddingResult to
-             // processor::EmbeddingResult as required by the Python layer.
-             processor::EmbeddingResult embedding_result;
-             embedding_result.ParseFromString(
-                 core::get_value(vision_embedding_result).SerializeAsString());
-             return embedding_result;
-           })
-      .def("get_embedding_by_index",
-           [](ImageEmbedder& self,
-              const processor::EmbeddingResult& embedding_result,
-              const int index) -> processor::Embedding {
-             // Convert from processor::EmbeddingResult to
-             // vision::EmbeddingResult as the latter is used in the C++ API.
-             EmbeddingResult vision_embedding_result;
-             vision_embedding_result.ParseFromString(
-                 embedding_result.SerializeAsString());
-
-             Embedding vision_embedding{
-                 self.GetEmbeddingByIndex(vision_embedding_result, index)};
-             // Convert from vision::Embedding to processor::Embedding
-             // as required by the Python layer.
-             processor::Embedding embedding;
-             embedding.ParseFromString(vision_embedding.SerializeAsString());
-             return embedding;
-           })
-      .def("get_number_of_output_layers",
-           &ImageEmbedder::GetNumberOfOutputLayers)
-      .def("get_embedding_dimension", &ImageEmbedder::GetEmbeddingDimension)
-      .def_static(
-          "cosine_similarity",
-          [](const processor::FeatureVector& u,
-             const processor::FeatureVector& v) -> double {
-            // Convert from processor::FeatureVector to
-            // vision::FeatureVector as the latter is used in the C++
-            // layer.
-            FeatureVector vision_feature_vector_u;
-            vision_feature_vector_u.ParseFromString(u.SerializeAsString());
-            FeatureVector vision_feature_vector_v;
-            vision_feature_vector_v.ParseFromString(v.SerializeAsString());
-            auto similarity = ImageEmbedder::CosineSimilarity(
-                vision_feature_vector_u, vision_feature_vector_v);
-            return core::get_value(similarity);
-          });
-}
-
-}  // namespace vision
-}  // namespace task
-}  // namespace tflite
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/python/task/vision/pybinds/_pywrap_image_segmenter.cc b/third_party/tflite_support/src/tensorflow_lite_support/python/task/vision/pybinds/_pywrap_image_segmenter.cc
deleted file mode 100644
index 19d1f31b2e78c..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/python/task/vision/pybinds/_pywrap_image_segmenter.cc
+++ /dev/null
@@ -1,73 +0,0 @@
-/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#include "pybind11/pybind11.h"
-#include "pybind11_protobuf/native_proto_caster.h"  // from @pybind11_protobuf
-#include "tensorflow_lite_support/cc/task/processor/proto/segmentation_options.pb.h"
-#include "tensorflow_lite_support/cc/task/vision/image_segmenter.h"
-#include "tensorflow_lite_support/examples/task/vision/desktop/utils/image_utils.h"
-#include "tensorflow_lite_support/python/task/core/pybinds/task_utils.h"
-
-namespace tflite {
-namespace task {
-namespace vision {
-
-namespace {
-namespace py = ::pybind11;
-using PythonBaseOptions = ::tflite::python::task::core::BaseOptions;
-using CppBaseOptions = ::tflite::task::core::BaseOptions;
-}  // namespace
-
-PYBIND11_MODULE(_pywrap_image_segmenter, m) {
-  // python wrapper for C++ ImageSegmenter class which shouldn't be directly
-  // used by the users.
-  pybind11_protobuf::ImportNativeProtoCasters();
-
-  py::class_<ImageSegmenter>(m, "ImageSegmenter")
-      .def_static(
-          "create_from_options",
-          [](const PythonBaseOptions& base_options,
-             const processor::SegmentationOptions& segmentation_options) {
-            ImageSegmenterOptions options;
-            auto cpp_base_options =
-                core::convert_to_cpp_base_options(base_options);
-            options.set_allocated_base_options(cpp_base_options.release());
-
-            if (segmentation_options.has_display_names_locale()) {
-              options.set_display_names_locale(
-                  segmentation_options.display_names_locale());
-            }
-            if (segmentation_options.has_output_type()) {
-              options.set_output_type(
-                  static_cast<ImageSegmenterOptions::OutputType>(
-                      segmentation_options.output_type()));
-            }
-
-            auto segmenter = ImageSegmenter::CreateFromOptions(options);
-            return core::get_value(segmenter);
-          })
-      .def("segment",
-           [](ImageSegmenter& self,
-              const ImageData& image_data) -> SegmentationResult {
-             auto frame_buffer = CreateFrameBufferFromImageData(image_data);
-             auto vision_segmentation_result =
-                 self.Segment(*core::get_value(frame_buffer));
-             return core::get_value(vision_segmentation_result);
-           });
-}
-
-}  // namespace vision
-}  // namespace task
-}  // namespace tflite
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/python/task/vision/pybinds/_pywrap_object_detector.cc b/third_party/tflite_support/src/tensorflow_lite_support/python/task/vision/pybinds/_pywrap_object_detector.cc
deleted file mode 100644
index 36fa2372e60af..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/python/task/vision/pybinds/_pywrap_object_detector.cc
+++ /dev/null
@@ -1,84 +0,0 @@
-/* Copyright 2021 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#include "pybind11/pybind11.h"
-#include "pybind11_protobuf/native_proto_caster.h"  // from @pybind11_protobuf
-#include "tensorflow_lite_support/cc/task/processor/proto/detection_options.pb.h"
-#include "tensorflow_lite_support/cc/task/processor/proto/detections.pb.h"
-#include "tensorflow_lite_support/cc/task/vision/object_detector.h"
-#include "tensorflow_lite_support/examples/task/vision/desktop/utils/image_utils.h"
-#include "tensorflow_lite_support/python/task/core/pybinds/task_utils.h"
-
-namespace tflite {
-namespace task {
-namespace vision {
-
-namespace {
-namespace py = ::pybind11;
-using PythonBaseOptions = ::tflite::python::task::core::BaseOptions;
-using CppBaseOptions = ::tflite::task::core::BaseOptions;
-}  // namespace
-
-PYBIND11_MODULE(_pywrap_object_detector, m) {
-  // python wrapper for C++ ObjectDetector class which shouldn't be directly
-  // used by the users.
-  pybind11_protobuf::ImportNativeProtoCasters();
-
-  py::class_<ObjectDetector>(m, "ObjectDetector")
-      .def_static(
-          "create_from_options",
-          [](const PythonBaseOptions& base_options,
-             const processor::DetectionOptions& detection_options) {
-            ObjectDetectorOptions options;
-            auto cpp_base_options =
-                core::convert_to_cpp_base_options(base_options);
-            options.set_allocated_base_options(cpp_base_options.release());
-
-            if (detection_options.has_display_names_locale()) {
-              options.set_display_names_locale(
-                  detection_options.display_names_locale());
-            }
-            if (detection_options.has_max_results()) {
-              options.set_max_results(detection_options.max_results());
-            }
-            if (detection_options.has_score_threshold()) {
-              options.set_score_threshold(detection_options.score_threshold());
-            }
-            options.mutable_class_name_whitelist()->CopyFrom(
-                detection_options.class_name_allowlist());
-            options.mutable_class_name_blacklist()->CopyFrom(
-                detection_options.class_name_denylist());
-
-            auto detector = ObjectDetector::CreateFromOptions(options);
-            return core::get_value(detector);
-          })
-      .def("detect",
-           [](ObjectDetector& self,
-              const ImageData& image_data) -> processor::DetectionResult {
-             auto frame_buffer = CreateFrameBufferFromImageData(image_data);
-             auto vision_detection_result =
-                 self.Detect(*core::get_value(frame_buffer));
-             // Convert from vision::DetectionResult to
-             // processor::DetectionResult as required by the Python layer.
-             processor::DetectionResult detection_result;
-             detection_result.ParseFromString(
-                 core::get_value(vision_detection_result).SerializeAsString());
-             return detection_result;
-           });
-}
-
-}  // namespace vision
-}  // namespace task
-}  // namespace tflite
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/core/index_table_sum.h b/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/core/index_table_sum.h
deleted file mode 100644
index 67e0e303d4231..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/core/index_table_sum.h
+++ /dev/null
@@ -1,256 +0,0 @@
-/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-#ifndef TENSORFLOW_LITE_SUPPORT_SCANN_ONDEVICE_CC_CORE_INDEX_TABLE_SUM_H_
-#define TENSORFLOW_LITE_SUPPORT_SCANN_ONDEVICE_CC_CORE_INDEX_TABLE_SUM_H_
-
-#include <array>
-#include <cstddef>
-#include <cstdint>
-#include <type_traits>
-#include <vector>
-
-#include "Eigen/Core"  // from @eigen
-#include "tensorflow_lite_support/scann_ondevice/cc/core/simd_utils.h"
-
-namespace tflite {
-namespace scann_ondevice {
-namespace core {
-
-template <typename LutType>
-void RearrangeLUT(const LutType* input_data,
-                  int batch_elems,
-                  int batch_size,
-                  LutType* const output_data) {
-  std::vector<int64_t> simd_sizes;
-  if (std::is_same<LutType, float>::value) {
-#ifdef __AVX__
-    simd_sizes = {8, 4};
-#elif defined __SSE__
-    simd_sizes = {4};
-#elif defined __ARM_NEON__
-    simd_sizes = {4};
-#endif
-  } else {
-#ifdef __AVX2__
-    simd_sizes = {16, 8};
-#elif defined __SSE4_1__
-    simd_sizes = {8};
-#elif defined __ARM_NEON__
-    simd_sizes = {8};
-#endif
-  }
-
-  int64_t offset = 0;
-  for (int64_t simd_size : simd_sizes) {
-    const int64_t num_simds = batch_size / simd_size;
-    const int64_t simd_batch_elems = simd_size * batch_elems;
-    for (; offset < num_simds * simd_batch_elems; offset += simd_batch_elems) {
-      using RowMajorMatrix = Eigen::Matrix<LutType, Eigen::Dynamic,
-                                           Eigen::Dynamic, Eigen::RowMajor>;
-      Eigen::Map<const RowMajorMatrix> input_map(input_data + offset, simd_size,
-                                                 batch_elems);
-      Eigen::Map<RowMajorMatrix> output_map(output_data + offset, batch_elems,
-                                            simd_size);
-      output_map = input_map.transpose();
-    }
-  }
-  std::copy(input_data + offset, input_data + batch_elems * batch_size,
-            output_data + offset);
-}
-const int kDefaultChunksPerBlock = 32;
-const int k16CentersUint8LutChunksPerBlock = 256;
-const int kUnrollSteps = 6;
-
-template <typename T>
-struct MaxQuantizationValue {
-  static_assert(std::is_same<T, float>::value, "Invalid lookup table type.");
-  static constexpr size_t value = 0;
-};
-
-template <>
-struct MaxQuantizationValue<uint8_t> {
-  static constexpr size_t value = 255;
-};
-
-template <>
-struct MaxQuantizationValue<uint16_t> {
-  static constexpr size_t value = (1 << 16) / kDefaultChunksPerBlock - 1;
-};
-
-template <typename SimdType, typename LutType, size_t NumCenters = 0>
-size_t IndexTableSumSimdBatch(const uint8_t* indices,
-                              size_t num_chunks,
-                              size_t num_outputs,
-                              const LutType* lookup_table,
-                              size_t batch_size,
-                              size_t num_centers,
-                              float min,
-                              float max,
-                              size_t batch_index,
-                              float* const output) {
-  if (num_centers == 256) {
-    return IndexTableSumSimdBatch<SimdType, LutType, 256>(
-        indices, num_chunks, num_outputs, lookup_table, batch_size, 0, min, max,
-        batch_index, output);
-  }
-  const size_t lut_chunk_stride = NumCenters ? NumCenters * SimdType::size()
-                                             : num_centers * SimdType::size();
-  const size_t lut_item_stride =
-      NumCenters ? NumCenters * num_chunks : num_chunks * num_centers;
-  constexpr bool must_dequantize = !std::is_same<LutType, float>::value;
-  constexpr size_t max_qval = MaxQuantizationValue<LutType>::value;
-  const float dq_scale = must_dequantize ? (max - min) / max_qval : 0.0f;
-  const float dq_offset_1 = must_dequantize ? min + dq_scale / 2 : 0.0f;
-
-  const size_t chunks_per_block =
-      std::is_same<LutType, uint8_t>::value &&
-              (NumCenters ? NumCenters : num_centers) == 16
-          ? k16CentersUint8LutChunksPerBlock
-          : kDefaultChunksPerBlock;
-
-  for (; batch_index + SimdType::size() <= batch_size;
-       batch_index += SimdType::size()) {
-    const LutType* batch_lut = lookup_table + batch_index * lut_item_stride;
-    float* const batch_output = output + batch_index;
-    for (size_t block_start = 0; block_start < num_chunks;
-         block_start += chunks_per_block) {
-      const size_t block_end =
-          std::min(block_start + chunks_per_block, num_chunks);
-      const float dq_offset_n = (block_end - block_start) * dq_offset_1;
-      size_t output_index;
-      for (output_index = 0; output_index + kUnrollSteps <= num_outputs;
-           output_index += kUnrollSteps) {
-        const uint8_t* indices_base = indices + output_index * num_chunks;
-        size_t chunk_index = block_start;
-        const LutType* chunk_lut = batch_lut + chunk_index * lut_chunk_stride;
-        std::array<SimdType, kUnrollSteps> accums;
-        for (size_t i = 0; i < kUnrollSteps; ++i) {
-          const size_t center_index =
-              indices_base[i * num_chunks + chunk_index];
-          accums[i].load(chunk_lut + center_index * SimdType::size());
-        }
-        ++chunk_index;
-        chunk_lut += lut_chunk_stride;
-        for (; chunk_index < block_end; ++chunk_index) {
-          for (size_t i = 0; i < kUnrollSteps; ++i) {
-            SimdType simd;
-            const size_t center_index =
-                indices_base[i * num_chunks + chunk_index];
-            simd.load(chunk_lut + center_index * SimdType::size());
-            accums[i] += simd;
-          }
-          chunk_lut += lut_chunk_stride;
-        }
-        for (size_t i = 0; i < kUnrollSteps; ++i) {
-          accums[i].dequantize_accum_storeu(
-              batch_output + (output_index + i) * batch_size, dq_scale,
-              dq_offset_n);
-        }
-      }
-      for (; output_index < num_outputs; ++output_index) {
-        const uint8_t* vector_indices = indices + output_index * num_chunks;
-
-        SimdType accum;
-        accum.setzero();
-        size_t chunk_index = block_start;
-        const LutType* chunk_lut = batch_lut + chunk_index * lut_chunk_stride;
-        for (; chunk_index < block_end; ++chunk_index) {
-          SimdType simd;
-          simd.load(chunk_lut + vector_indices[chunk_index] * SimdType::size());
-          accum += simd;
-          chunk_lut += lut_chunk_stride;
-        }
-
-        accum.dequantize_accum_storeu(batch_output + output_index * batch_size,
-                                      dq_scale, dq_offset_n);
-      }
-    }
-  }
-
-  return batch_index;
-}
-
-template <typename LutType>
-void IndexTableSum(const uint8_t* indices,
-                   size_t num_chunks,
-                   size_t num_outputs,
-                   const LutType* lookup_table,
-                   size_t batch_size,
-                   size_t num_centers,
-                   float min,
-                   float max,
-                   float* const output) {
-  static_assert(std::is_same<LutType, uint8_t>::value ||
-                    std::is_same<LutType, uint16_t>::value,
-                "Invalid lookup table type.");
-  std::fill(output, output + batch_size * num_outputs, 0.0f);
-  size_t i = 0;
-#ifdef __AVX2__
-  i = IndexTableSumSimdBatch<SimdInt16x16, LutType>(
-      indices, num_chunks, num_outputs, lookup_table, batch_size, num_centers,
-      min, max, i, output);
-#endif
-#ifdef __SSE4_1__
-  i = IndexTableSumSimdBatch<SimdInt16x8, LutType>(
-      indices, num_chunks, num_outputs, lookup_table, batch_size, num_centers,
-      min, max, i, output);
-#endif
-#ifdef __ARM_NEON__
-  i = IndexTableSumSimdBatch<SimdInt16x8, LutType>(
-      indices, num_chunks, num_outputs, lookup_table, batch_size, num_centers,
-      min, max, i, output);
-#endif
-  i = IndexTableSumSimdBatch<SimdInt16x1, LutType>(
-      indices, num_chunks, num_outputs, lookup_table, batch_size, num_centers,
-      min, max, i, output);
-}
-
-template <>
-inline void IndexTableSum<float>(const uint8_t* indices,
-                                 size_t num_chunks,
-                                 size_t num_outputs,
-                                 const float* lookup_table,
-                                 size_t batch_size,
-                                 size_t num_centers,
-                                 float min,
-                                 float max,
-                                 float* const output) {
-  std::fill(output, output + batch_size * num_outputs, 0.0f);
-  size_t i = 0;
-#ifdef __AVX__
-  i = IndexTableSumSimdBatch<SimdFloat32x8, float>(
-      indices, num_chunks, num_outputs, lookup_table, batch_size, num_centers,
-      min, max, i, output);
-#endif
-#ifdef __SSE__
-  i = IndexTableSumSimdBatch<SimdFloat32x4, float>(
-      indices, num_chunks, num_outputs, lookup_table, batch_size, num_centers,
-      min, max, i, output);
-#endif
-#ifdef __ARM_NEON__
-  i = IndexTableSumSimdBatch<SimdFloat32x4, float>(
-      indices, num_chunks, num_outputs, lookup_table, batch_size, num_centers,
-      min, max, i, output);
-#endif
-  i = IndexTableSumSimdBatch<SimdFloat32x1, float>(
-      indices, num_chunks, num_outputs, lookup_table, batch_size, num_centers,
-      min, max, i, output);
-}
-
-}  // namespace core
-}  // namespace scann_ondevice
-}  // namespace tflite
-
-#endif  // TENSORFLOW_LITE_SUPPORT_SCANN_ONDEVICE_CC_CORE_INDEX_TABLE_SUM_H_
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/core/partitioner.h b/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/core/partitioner.h
deleted file mode 100644
index f4e9eb9e34804..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/core/partitioner.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-#ifndef TENSORFLOW_LITE_SUPPORT_SCANN_ONDEVICE_CC_CORE_PARTITIONER_H_
-#define TENSORFLOW_LITE_SUPPORT_SCANN_ONDEVICE_CC_CORE_PARTITIONER_H_
-
-#include <utility>
-
-#include "Eigen/Core"             // from @eigen
-#include "absl/types/optional.h"  // from @com_google_absl
-#include "tensorflow_lite_support/scann_ondevice/cc/core/serialized_searcher.pb.h"
-
-namespace tflite {
-namespace scann_ondevice {
-namespace core {
-class PartitionerInterface {
- public:
-  virtual ~PartitionerInterface() {}
-  virtual bool Partition(const Eigen::Ref<const Eigen::MatrixXf>& queries,
-                         std::vector<std::vector<int>>* tokens) const = 0;
-
-  virtual int NumPartitions() const = 0;
-  virtual absl::optional<int> get_vector_dimension() const = 0;
-};
-class Partitioner : public PartitionerInterface {
- public:
-  static std::unique_ptr<Partitioner> Create(const PartitionerProto& proto);
-  bool Partition(const Eigen::Ref<const Eigen::MatrixXf>& queries,
-                 std::vector<std::vector<int>>* tokens) const override;
-  int NumPartitions() const override;
-
-  inline absl::optional<int> get_vector_dimension() const override {
-    return leaves_.cols();
-  }
-
- private:
-  Partitioner(Eigen::MatrixXf leaves,
-              Eigen::VectorXf leaf_norms,
-              DistanceMeasure distance)
-      : leaves_(std::move(leaves)),
-        leaf_norms_(std::move(leaf_norms)),
-        distance_(distance) {}
-
-  Eigen::MatrixXf leaves_;
-  Eigen::VectorXf leaf_norms_;
-  DistanceMeasure distance_;
-};
-class NoOpPartitioner : public PartitionerInterface {
- public:
-  ~NoOpPartitioner() override {}
-
-  bool Partition(const Eigen::Ref<const Eigen::MatrixXf>& queries,
-                 std::vector<std::vector<int>>* tokens) const override;
-
-  int NumPartitions() const override;
-  inline absl::optional<int> get_vector_dimension() const override {
-    return absl::optional<int>();
-  }
-};
-
-}  // namespace core
-}  // namespace scann_ondevice
-}  // namespace tflite
-
-#endif  // TENSORFLOW_LITE_SUPPORT_SCANN_ONDEVICE_CC_CORE_PARTITIONER_H_
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/core/processor.h b/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/core/processor.h
deleted file mode 100644
index 97206f4ba1aa6..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/core/processor.h
+++ /dev/null
@@ -1,101 +0,0 @@
-/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-#ifndef TENSORFLOW_LITE_SUPPORT_SCANN_ONDEVICE_CC_CORE_PROCESSOR_H_
-#define TENSORFLOW_LITE_SUPPORT_SCANN_ONDEVICE_CC_CORE_PROCESSOR_H_
-
-#include <cstdint>
-#include <utility>
-#include <vector>
-
-#include "Eigen/Core"  // from @eigen
-#include "tensorflow_lite_support/scann_ondevice/cc/core/serialized_searcher.pb.h"
-#include "tensorflow_lite_support/scann_ondevice/cc/core/top_n_amortized_constant.h"
-
-namespace tflite {
-namespace scann_ondevice {
-namespace core {
-struct QueryInfo {
-  template <typename T>
-  using Matrix =
-      Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic, Eigen::ColMajor>;
-
-  float fixed_point_min = NAN;
-  float fixed_point_max = NAN;
-  float fixed_point_offset = NAN;
-  float fixed_point_scale = NAN;
-
-  std::shared_ptr<Matrix<float>> query_lut;
-  std::shared_ptr<Matrix<uint16_t>> query_lut_uint16;
-  std::shared_ptr<Matrix<uint8_t>> query_lut_uint8;
-  template <typename T>
-  std::shared_ptr<Matrix<T>> QueryLUT();
-
-  std::shared_ptr<Matrix<float>> transposed_query_lut;
-  std::shared_ptr<Matrix<uint16_t>> transposed_query_lut_uint16;
-  std::shared_ptr<Matrix<uint8_t>> transposed_query_lut_uint8;
-  template <typename T>
-  std::shared_ptr<Matrix<T>> TransposedQueryLUT();
-};
-class PreProcessorInterface {
- public:
-  virtual ~PreProcessorInterface() {}
-
-  virtual bool Process(const Eigen::Ref<const Eigen::MatrixXf>& queries,
-                       QueryInfo* query_info) const = 0;
-  virtual int num_database_dims() const = 0;
-  virtual int num_query_dims() const = 0;
-};
-class PostProcessorInterface {
- public:
-  virtual ~PostProcessorInterface() {}
-
-  virtual bool Process(std::vector<TopN>* top_n) const = 0;
-};
-class AsymmetricHashQuerier : public PreProcessorInterface {
- public:
-  static std::unique_ptr<AsymmetricHashQuerier> Create(
-      const AsymmetricHashingProto& proto);
-  bool Process(const Eigen::Ref<const Eigen::MatrixXf>& queries,
-               QueryInfo* query_info) const override;
-
-  inline int num_database_dims() const override { return codebooks_.size(); }
-
-  inline int num_query_dims() const override { return dims_; }
-
- private:
-  AsymmetricHashQuerier(std::vector<Eigen::MatrixXf> codebooks,
-                        std::vector<Eigen::VectorXf> codebook_norms,
-                        DistanceMeasure query_distance,
-                        AsymmetricHashingProto::LookupType lookup_type,
-                        int dims)
-      : dims_(dims),
-        lookup_type_(lookup_type),
-        query_distance_(query_distance),
-        codebooks_(std::move(codebooks)),
-        codebook_norms_(std::move(codebook_norms)) {}
-  void RearrangeLUT(QueryInfo* query_info) const;
-
-  int dims_;
-  AsymmetricHashingProto::LookupType lookup_type_;
-  DistanceMeasure query_distance_;
-  std::vector<Eigen::MatrixXf> codebooks_;
-  std::vector<Eigen::VectorXf> codebook_norms_;
-};
-
-}  // namespace core
-}  // namespace scann_ondevice
-}  // namespace tflite
-
-#endif  // TENSORFLOW_LITE_SUPPORT_SCANN_ONDEVICE_CC_CORE_PROCESSOR_H_
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/core/searcher.h b/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/core/searcher.h
deleted file mode 100644
index 419681b829b1d..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/core/searcher.h
+++ /dev/null
@@ -1,256 +0,0 @@
-/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-#ifndef TENSORFLOW_LITE_SUPPORT_SCANN_ONDEVICE_CC_CORE_SEARCHER_H_
-#define TENSORFLOW_LITE_SUPPORT_SCANN_ONDEVICE_CC_CORE_SEARCHER_H_
-
-#include <algorithm>
-#include <cstdint>
-#include <limits>
-#include <utility>
-#include <vector>
-
-#include <glog/logging.h>
-#include "Eigen/Core"         // from @eigen
-#include "absl/types/span.h"  // from @com_google_absl
-#include "tensorflow_lite_support/cc/port/integral_types.h"
-#include "tensorflow_lite_support/scann_ondevice/cc/core/index_table_sum.h"
-#include "tensorflow_lite_support/scann_ondevice/cc/core/processor.h"
-#include "tensorflow_lite_support/scann_ondevice/cc/core/serialized_searcher.pb.h"
-#include "tensorflow_lite_support/scann_ondevice/cc/core/simd_utils.h"
-#include "tensorflow_lite_support/scann_ondevice/cc/core/top_n_amortized_constant.h"
-
-namespace tflite {
-namespace scann_ondevice {
-namespace core {
-
-using Matrix8u =
-    Eigen::Matrix<uint8_t, Eigen::Dynamic, Eigen::Dynamic, Eigen::ColMajor>;
-
-namespace internal {
-void ComputeAHDistance(const QueryInfo& query_info,
-                       Eigen::Ref<const Matrix8u> database,
-                       Eigen::Ref<Eigen::MatrixXf> output);
-
-}
-template <class T>
-bool AsymmetricHashFindNeighbors(const QueryInfo& query_info,
-                                 Eigen::Ref<const Matrix8u> database,
-                                 size_t global_offset,
-                                 absl::Span<T> topn) {
-  const int batch_size = query_info.query_lut->cols();
-  if (topn.size() != batch_size) {
-    return false;
-  }
-  int database_size = database.cols();
-  Eigen::MatrixXf output(batch_size, database_size);
-  internal::ComputeAHDistance(query_info, database, output);
-
-  for (int i = 0; i < database_size; i++) {
-    for (int j = 0; j < topn.size(); ++j) {
-      topn[j].emplace(output(j, i), i + global_offset);
-    }
-  }
-  return true;
-}
-template <class T>
-bool AsymmetricHashFindNeighbors(Eigen::Ref<const Eigen::MatrixXf> queries,
-                                 const PreProcessorInterface& preprocessor,
-                                 Eigen::Ref<const Matrix8u> database,
-                                 size_t global_offset,
-                                 absl::Span<T> topn) {
-  if (queries.cols() != topn.size()) {
-    return false;
-  }
-  QueryInfo query_info;
-  return preprocessor.Process(queries, &query_info) &&
-         AsymmetricHashFindNeighbors(query_info, database, global_offset, topn);
-}
-template <class T>
-bool FloatFindNeighbors(Eigen::Ref<const Eigen::MatrixXf> queries,
-                        Eigen::Ref<const Eigen::MatrixXf> database,
-                        const size_t global_offset,
-                        const DistanceMeasure distance_measure,
-                        absl::Span<T> topn) {
-  int query_size = queries.cols();
-  int database_size = database.cols();
-  Eigen::MatrixXf pairwise_distances(query_size, database_size);
-
-  if (distance_measure == SQUARED_L2_DISTANCE) {
-    pairwise_distances.colwise() = queries.colwise().squaredNorm().transpose();
-    pairwise_distances.rowwise() += database.colwise().squaredNorm();
-    pairwise_distances -= 2 * queries.transpose() * database;
-  } else if (distance_measure == DOT_PRODUCT) {
-    pairwise_distances = -1 * queries.transpose() * database;
-  } else {
-    LOG(ERROR) << "Unsupported distance measure: "
-               << DistanceMeasure_Name(distance_measure);
-    return false;
-  }
-
-  for (int i = 0; i < database_size; ++i) {
-    for (int j = 0; j < query_size; ++j) {
-      topn[j].emplace(pairwise_distances(j, i), i + global_offset);
-    }
-  }
-  return true;
-}
-template <class T>
-class SearcherInterfaceT {
- public:
-  virtual ~SearcherInterfaceT() {}
-
-  virtual bool FindNeighbors(const Eigen::Ref<const Eigen::MatrixXf>& queries,
-                             std::vector<T>* topn) const = 0;
-};
-template <class T>
-class AsymmetricHashLeafSearcherT : public SearcherInterfaceT<T> {
- public:
-  static std::unique_ptr<AsymmetricHashLeafSearcherT<T>> Create(
-      std::shared_ptr<QueryInfo::Matrix<uint8_t>> database,
-      int global_offset,
-      std::shared_ptr<PreProcessorInterface> preprocessor);
-  static std::unique_ptr<AsymmetricHashLeafSearcherT<T>> Create(
-      std::shared_ptr<QueryInfo::Matrix<uint8_t>> database,
-      int global_offset,
-      std::shared_ptr<PreProcessorInterface> preprocessor,
-      size_t mini_batch_size);
-  bool FindNeighbors(const Eigen::Ref<const Eigen::MatrixXf>& queries,
-                     std::vector<T>* topn) const override;
-  bool FindNeighbors(const QueryInfo& query_info, std::vector<T>* topn) const;
-
- private:
-  AsymmetricHashLeafSearcherT(
-      std::shared_ptr<QueryInfo::Matrix<uint8_t>> database,
-      int global_offset,
-      std::shared_ptr<PreProcessorInterface> preprocessor,
-      size_t mini_batch_size)
-      : database_(std::move(database)),
-        global_offset_(global_offset),
-        preprocessor_(std::move(preprocessor)),
-        mini_batch_size_(mini_batch_size) {}
-  std::shared_ptr<QueryInfo::Matrix<uint8_t>> database_ = nullptr;
-  int global_offset_;
-  std::shared_ptr<PreProcessorInterface> preprocessor_ = nullptr;
-  const size_t mini_batch_size_;
-};
-template <class T>
-class LinearLeafSearcherT : public SearcherInterfaceT<T> {
- public:
-  ~LinearLeafSearcherT() override {}
-  static std::unique_ptr<LinearLeafSearcherT<T>> Create(
-      std::shared_ptr<Eigen::MatrixXf> database,
-      DistanceMeasure distance_measure = SQUARED_L2_DISTANCE,
-      int global_offset = 0);
-
-  bool FindNeighbors(const Eigen::Ref<const Eigen::MatrixXf>& queries,
-                     std::vector<T>* topn) const override;
-
- private:
-  LinearLeafSearcherT(std::shared_ptr<Eigen::MatrixXf> database,
-                      DistanceMeasure distance_measure,
-                      int global_offset)
-      : database_(std::move(database)),
-        distance_measure_(distance_measure),
-        global_offset_(global_offset) {}
-
-  std::shared_ptr<Eigen::MatrixXf> database_ = nullptr;
-  const DistanceMeasure distance_measure_;
-  int global_offset_;
-};
-
-template <class T>
-std::unique_ptr<AsymmetricHashLeafSearcherT<T>>
-AsymmetricHashLeafSearcherT<T>::Create(
-    std::shared_ptr<Matrix8u> database,
-    int global_offset,
-    std::shared_ptr<PreProcessorInterface> preprocessor) {
-  return AsymmetricHashLeafSearcherT<T>::Create(
-      database, global_offset, preprocessor,
-      std::numeric_limits<size_t>::max());
-}
-
-template <class T>
-std::unique_ptr<AsymmetricHashLeafSearcherT<T>>
-AsymmetricHashLeafSearcherT<T>::Create(
-    std::shared_ptr<Matrix8u> database,
-    int global_offset,
-    std::shared_ptr<PreProcessorInterface> preprocessor,
-    size_t mini_batch_size) {
-  if (mini_batch_size == 0 || global_offset < 0) {
-    return nullptr;
-  }
-  return std::unique_ptr<AsymmetricHashLeafSearcherT<T>>(
-      new AsymmetricHashLeafSearcherT<T>(std::move(database), global_offset,
-                                         std::move(preprocessor),
-                                         mini_batch_size));
-}
-
-template <class T>
-bool AsymmetricHashLeafSearcherT<T>::FindNeighbors(
-    const Eigen::Ref<const Eigen::MatrixXf>& queries,
-    std::vector<T>* topn) const {
-  if (queries.cols() != topn->size()) {
-    return false;
-  }
-
-  absl::Span<T> topn_span = absl::MakeSpan(*topn);
-  for (size_t i = 0; i < queries.cols(); i += mini_batch_size_) {
-    const size_t num_queries_in_batch =
-        std::min(mini_batch_size_, queries.cols() - i);
-    if (!AsymmetricHashFindNeighbors<T>(
-            queries.middleCols(i, num_queries_in_batch), *preprocessor_,
-            *database_, global_offset_,
-            topn_span.subspan(i, num_queries_in_batch))) {
-      return false;
-    }
-  }
-  return true;
-}
-
-template <class T>
-bool AsymmetricHashLeafSearcherT<T>::FindNeighbors(const QueryInfo& query_info,
-                                                   std::vector<T>* topn) const {
-  return AsymmetricHashFindNeighbors<T>(query_info, *database_, global_offset_,
-                                        absl::MakeSpan(*topn));
-}
-
-template <class T>
-std::unique_ptr<LinearLeafSearcherT<T>> LinearLeafSearcherT<T>::Create(
-    std::shared_ptr<Eigen::MatrixXf> database,
-    DistanceMeasure distance_measure,
-    int global_offset) {
-  if (global_offset < 0) {
-    return nullptr;
-  }
-  return std::unique_ptr<LinearLeafSearcherT<T>>(new LinearLeafSearcherT<T>(
-      std::move(database), distance_measure, global_offset));
-}
-
-template <class T>
-bool LinearLeafSearcherT<T>::FindNeighbors(
-    const Eigen::Ref<const Eigen::MatrixXf>& queries,
-    std::vector<T>* topn) const {
-  return FloatFindNeighbors<T>(queries, *database_, global_offset_,
-                               distance_measure_, absl::MakeSpan(*topn));
-}
-
-using SearcherInterface = SearcherInterfaceT<TopN>;
-using AsymmetricHashLeafSearcher = AsymmetricHashLeafSearcherT<TopN>;
-using LinearLeafSearcher = LinearLeafSearcherT<TopN>;
-}  // namespace core
-}  // namespace scann_ondevice
-}  // namespace tflite
-
-#endif  // TENSORFLOW_LITE_SUPPORT_SCANN_ONDEVICE_CC_CORE_SEARCHER_H_
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/core/searcher_test.cc b/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/core/searcher_test.cc
deleted file mode 100644
index f3931f3619b8d..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/core/searcher_test.cc
+++ /dev/null
@@ -1,532 +0,0 @@
-/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-#include "tensorflow_lite_support/scann_ondevice/cc/core/searcher.h"
-
-#include <algorithm>
-#include <cstdint>
-#include <limits>
-#include <memory>
-#include <utility>
-
-#include <glog/logging.h>
-#include "Eigen/Core"                    // from @eigen
-#include "absl/synchronization/mutex.h"  // from @com_google_absl
-#include "tensorflow_lite_support/cc/port/gmock.h"
-#include "tensorflow_lite_support/cc/port/gtest.h"
-#include "tensorflow_lite_support/cc/port/integral_types.h"
-#include "tensorflow_lite_support/cc/port/proto2.h"
-#include "tensorflow_lite_support/scann_ondevice/cc/core/partitioner.h"
-#include "tensorflow_lite_support/scann_ondevice/cc/core/processor.h"
-#include "tensorflow_lite_support/scann_ondevice/cc/core/serialized_searcher.pb.h"
-using TextFormat = ::tflite::support::proto::TextFormat;
-
-using Eigen::MatrixXf;
-using ::testing::ElementsAre;
-using ::testing::Pair;
-using ::testing::TestWithParam;
-using ::testing::Values;
-using Matrix8u =
-    Eigen::Matrix<uint8_t, Eigen::Dynamic, Eigen::Dynamic, Eigen::ColMajor>;
-using tflite::scann_ondevice::core::TopN;
-
-const char kExampleAsymmetricHashingProtoString[] =
-    R"(
-      subspace: {
-        entry {
-          dimension: 0.1;
-          dimension: 0.2;
-        }
-        entry: {
-          dimension: 0.2;
-          dimension: 0.1;
-        }
-        entry: {
-          dimension: 0.9;
-          dimension: 0.8;
-        }
-      }
-      subspace: {
-        entry {
-          dimension: -0.1;
-          dimension: -0.2;
-          dimension: -0.3;
-        }
-        entry: {
-          dimension: -0.3;
-          dimension: -0.2;
-          dimension: -0.1;
-        }
-        entry: {
-          dimension: -0.9;
-          dimension: -0.8;
-          dimension: -0.7;
-        }
-      })";
-
-const char kExamplePartitionerProtoString[] =
-    R"(
-      leaf: {
-        dimension: 0.1;
-        dimension: 0.2;
-      }
-      leaf: {
-        dimension: 0.2;
-        dimension: 0.1;
-      }
-      leaf: {
-        dimension: 0.9;
-        dimension: 0.7;
-      }
-      leaf: {
-        dimension: 0.3;
-        dimension: 0.3;
-      })";
-namespace tflite {
-namespace scann_ondevice {
-namespace core {
-namespace {
-TEST(PartitionerTest, Partition) {
-  PartitionerProto proto;
-  TextFormat::ParseFromString(kExamplePartitionerProtoString, &proto);
-  proto.set_query_distance(SQUARED_L2_DISTANCE);
-  auto partitioner = Partitioner::Create(proto);
-  MatrixXf query(2, 3);
-  query << 0.3, 0.9, -1, 0.2, 0.9, -1;
-
-  std::vector<std::vector<int>> tokens(3, std::vector<int>(2, -1));
-  ASSERT_TRUE(partitioner->Partition(query, &tokens));
-  for (int i = 0; i < 3; ++i) {
-    std::sort(tokens[i].begin(), tokens[i].end());
-  }
-  EXPECT_EQ((std::vector<int>{1, 3}), tokens[0]);
-  EXPECT_EQ((std::vector<int>{2, 3}), tokens[1]);
-  EXPECT_EQ((std::vector<int>{0, 1}), tokens[2]);
-}
-
-TEST(PartitionerTest, PartitionDotProductDistance) {
-  PartitionerProto proto;
-  TextFormat::ParseFromString(kExamplePartitionerProtoString, &proto);
-  proto.set_query_distance(DOT_PRODUCT);
-  auto partitioner = Partitioner::Create(proto);
-  MatrixXf query(2, 3);
-  query << 0.3, 0.9, -1, 0.2, 0.9, -1;
-
-  std::vector<std::vector<int>> tokens(3, std::vector<int>(2, -1));
-  ASSERT_TRUE(partitioner->Partition(query, &tokens));
-  for (int i = 0; i < 3; ++i) {
-    std::sort(tokens[i].begin(), tokens[i].end());
-  }
-  EXPECT_EQ((std::vector<int>{2, 3}), tokens[0]);
-  EXPECT_EQ((std::vector<int>{2, 3}), tokens[1]);
-  EXPECT_EQ((std::vector<int>{0, 1}), tokens[2]);
-}
-
-TEST(ProcessorTest, AsymmetricHashQuerierNonSimd) {
-  AsymmetricHashingProto proto;
-  TextFormat::ParseFromString(kExampleAsymmetricHashingProtoString, &proto);
-  auto querier = AsymmetricHashQuerier::Create(proto);
-  CHECK(querier);
-
-  MatrixXf query(5, 2);
-  query << 0, 1, 0, 1, 0, 1, 0, 1, 0, 1;
-  QueryInfo query_info;
-  ASSERT_TRUE(querier->Process(query, &query_info));
-  MatrixXf expected_lut(6, 2);
-  expected_lut << 0.05, 1.45, 0.05, 1.45, 1.45, 0.05, 0.14, 4.34, 0.14, 4.34,
-      1.94, 9.74;
-  ASSERT_TRUE(query_info.query_lut->isApprox(expected_lut, 1e-5));
-}
-
-TEST(ProcessorTest, AsymmetricHashQuerierNonSimdDotProduct) {
-  AsymmetricHashingProto proto;
-  TextFormat::ParseFromString(kExampleAsymmetricHashingProtoString, &proto);
-  proto.set_query_distance(DOT_PRODUCT);
-  auto querier = AsymmetricHashQuerier::Create(proto);
-  ASSERT_NE(querier, nullptr);
-
-  MatrixXf query(5, 2);
-  query << 0, 1, 0, 1, 0, 1, 0, 1, 0, 1;
-  QueryInfo query_info;
-  ASSERT_TRUE(querier->Process(query, &query_info));
-
-  const auto& query_lut = query_info.query_lut;
-  const float* lut_raw = query_lut->data();
-  EXPECT_THAT(std::vector<float>(lut_raw, lut_raw + query_lut->rows()),
-              ElementsAre(0, 0, 0, 0, 0, 0));
-  EXPECT_THAT(std::vector<float>(lut_raw + query_lut->rows(),
-                                 lut_raw + query_lut->rows() * 2),
-              ElementsAre(-0.3, -0.3, -1.7, 0.6, 0.6, 2.4));
-}
-
-TEST(ProcessorTest, AsymmetricHashQuerierSimd) {
-  AsymmetricHashingProto proto;
-  TextFormat::ParseFromString(kExampleAsymmetricHashingProtoString, &proto);
-  auto querier = AsymmetricHashQuerier::Create(proto);
-  MatrixXf query(5, 6);
-  query << 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0,
-      1, 0, 1, 0, 0, 1, 1;
-  QueryInfo query_info;
-  ASSERT_TRUE(querier->Process(query, &query_info));
-  MatrixXf expected_lut(6, 6);
-  expected_lut << 0.05, 0.05, 1.45, 0.65, 0.85, 1.45, 0.05, 0.05, 1.45, 0.85,
-      0.65, 1.45, 1.45, 1.45, 0.05, 0.85, 0.65, 0.05, 0.14, 4.34, 0.14, 1.54,
-      2.94, 4.34, 0.14, 4.34, 0.14, 1.54, 2.94, 4.34, 1.94, 9.74, 1.94, 4.54,
-      7.14, 9.74;
-  ASSERT_TRUE(query_info.query_lut->isApprox(expected_lut, 1e-5));
-  expected_lut << 0.05, 1.45, 0.14, 0.14, 0.85, 1.45, 0.05, 0.85, 4.34, 1.54,
-      0.65, 1.45, 1.45, 1.45, 0.14, 1.94, 0.65, 0.05, 0.65, 1.45, 1.54, 9.74,
-      2.94, 4.34, 0.05, 0.05, 0.14, 1.94, 2.94, 4.34, 0.05, 0.85, 4.34, 4.54,
-      7.14, 9.74;
-  ASSERT_TRUE(query_info.transposed_query_lut->isApprox(expected_lut, 1e-5));
-}
-
-TEST(ProcessorTest, AsymmetricHashPreprocessingLazyMemoryAllocation) {
-  AsymmetricHashingProto proto;
-  TextFormat::ParseFromString(kExampleAsymmetricHashingProtoString, &proto);
-  auto querier = AsymmetricHashQuerier::Create(proto);
-  QueryInfo query_info;
-  {
-    MatrixXf query(5, 2);
-    query << 0, 0, 0, 0, 0, 1, 0, 1, 0, 1;
-    ASSERT_TRUE(querier->Process(query, &query_info));
-    MatrixXf expected_lut(6, 2);
-    expected_lut << 0.05, 0.05, 0.05, 0.05, 1.45, 1.45, 0.14, 4.34, 0.14, 4.34,
-        1.94, 9.74;
-    EXPECT_TRUE(query_info.query_lut->isApprox(expected_lut, 1e-5));
-    EXPECT_TRUE(query_info.transposed_query_lut->isApprox(expected_lut, 1e-5));
-  }
-  {
-    MatrixXf query(5, 6);
-    query << 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1,
-        0, 1, 0, 1, 0, 0, 1, 1;
-    ASSERT_TRUE(querier->Process(query, &query_info));
-    MatrixXf expected_lut(6, 6);
-    expected_lut << 0.05, 0.05, 1.45, 0.65, 0.85, 1.45, 0.05, 0.05, 1.45, 0.85,
-        0.65, 1.45, 1.45, 1.45, 0.05, 0.85, 0.65, 0.05, 0.14, 4.34, 0.14, 1.54,
-        2.94, 4.34, 0.14, 4.34, 0.14, 1.54, 2.94, 4.34, 1.94, 9.74, 1.94, 4.54,
-        7.14, 9.74;
-    EXPECT_TRUE(query_info.query_lut->isApprox(expected_lut, 1e-5));
-    expected_lut << 0.05, 1.45, 0.14, 0.14, 0.85, 1.45, 0.05, 0.85, 4.34, 1.54,
-        0.65, 1.45, 1.45, 1.45, 0.14, 1.94, 0.65, 0.05, 0.65, 1.45, 1.54, 9.74,
-        2.94, 4.34, 0.05, 0.05, 0.14, 1.94, 2.94, 4.34, 0.05, 0.85, 4.34, 4.54,
-        7.14, 9.74;
-    EXPECT_TRUE(query_info.transposed_query_lut->isApprox(expected_lut, 1e-5));
-  }
-  {
-    MatrixXf query(5, 4);
-    query << 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1;
-    ASSERT_TRUE(querier->Process(query, &query_info));
-    MatrixXf expected_lut(6, 6);
-    expected_lut << 1.45, 0.65, 0.85, 1.45, 0.85, 1.45, 1.45, 0.85, 0.65, 1.45,
-        0.65, 1.45, 0.05, 0.85, 0.65, 0.05, 0.65, 0.05, 0.14, 1.54, 2.94, 4.34,
-        2.94, 4.34, 0.14, 1.54, 2.94, 4.34, 2.94, 4.34, 1.94, 4.54, 7.14, 9.74,
-        7.14, 9.74;
-    EXPECT_TRUE(query_info.query_lut->isApprox(expected_lut, 1e-5));
-    expected_lut << 1.45, 0.65, 0.14, 2.94, 0.85, 1.45, 0.65, 1.45, 1.54, 4.34,
-        0.65, 1.45, 0.85, 0.05, 2.94, 1.94, 0.65, 0.05, 1.45, 0.85, 4.34, 4.54,
-        2.94, 4.34, 1.45, 0.65, 0.14, 7.14, 2.94, 4.34, 0.85, 0.05, 1.54, 9.74,
-        7.14, 9.74;
-    EXPECT_TRUE(query_info.transposed_query_lut->isApprox(expected_lut, 1e-5));
-  }
-}
-
-TEST(ProcessorTest, AsymmetricHashQuerierUint16) {
-  AsymmetricHashingProto proto;
-  TextFormat::ParseFromString(kExampleAsymmetricHashingProtoString, &proto);
-  proto.set_lookup_type(AsymmetricHashingProto::INT16);
-  auto querier = AsymmetricHashQuerier::Create(proto);
-  CHECK(querier);
-
-  MatrixXf query(5, 2);
-  query << 0, 1, 0, 1, 0, 1, 0, 1, 0, 1;
-  QueryInfo query_info;
-  ASSERT_TRUE(querier->Process(query, &query_info));
-  QueryInfo::Matrix<uint16_t> expected_lut(6, 2);
-  expected_lut << 0, 295, 0, 295, 295, 0, 19, 906, 19, 906, 399, 2047;
-
-  LOG(INFO) << *(query_info.query_lut_uint16);
-
-  ASSERT_EQ(*(query_info.query_lut_uint16), expected_lut);
-  EXPECT_NEAR(query_info.fixed_point_min, 0.05, 1e-4);
-  EXPECT_NEAR(query_info.fixed_point_max, 9.74, 1e-4);
-}
-
-TEST(ProcessorTest, AsymmetricHashQuerierUint8) {
-  AsymmetricHashingProto proto;
-  TextFormat::ParseFromString(kExampleAsymmetricHashingProtoString, &proto);
-  proto.set_lookup_type(AsymmetricHashingProto::INT8);
-  auto querier = AsymmetricHashQuerier::Create(proto);
-  CHECK(querier);
-
-  MatrixXf query(5, 2);
-  query << 0, 1, 0, 1, 0, 1, 0, 1, 0, 1;
-  QueryInfo query_info;
-  ASSERT_TRUE(querier->Process(query, &query_info));
-  QueryInfo::Matrix<uint8_t> expected_lut(6, 2);
-  expected_lut << 0, 36, 0, 36, 36, 0, 2, 112, 2, 112, 49, 255;
-  ASSERT_EQ(*(query_info.query_lut_uint8), expected_lut);
-  EXPECT_NEAR(query_info.fixed_point_min, 0.05, 1e-4);
-  EXPECT_NEAR(query_info.fixed_point_max, 9.74, 1e-4);
-}
-
-class SearcherTest : public TestWithParam<size_t> {};
-
-TEST_P(SearcherTest, LinearLeafSearcherNonSimd) {
-  MatrixXf query(3, 2);
-  query << 0, 1, 2, 3, 3, 1;
-  std::shared_ptr<MatrixXf> database(new MatrixXf(3, 5));
-  *database << 0, 1, 2, 2, 1, 1, 0, 1, 2, 2, 2, 2, 5, 6, 1;
-  std::vector<TopN> top_n;
-  for (int i = 0; i < 2; ++i) {
-    top_n.emplace_back(
-        TopN(3, std::make_pair(std::numeric_limits<float>::max(), -1)));
-  }
-  auto leaf_searcher = LinearLeafSearcher::Create(database);
-  ASSERT_TRUE(leaf_searcher->FindNeighbors(query, &top_n));
-
-  constexpr float kEps = 1e-5;
-  auto extracted = top_n[0].Take();
-  EXPECT_NEAR(2.0, extracted[0].first, kEps);
-  EXPECT_NEAR(5.0, extracted[1].first, kEps);
-  EXPECT_NEAR(6.0, extracted[2].first, kEps);
-  EXPECT_EQ(0, extracted[0].second);
-  EXPECT_EQ(4, extracted[1].second);
-  EXPECT_EQ(1, extracted[2].second);
-
-  extracted = top_n[1].Take();
-  EXPECT_NEAR(1.0, extracted[0].first, kEps);
-  EXPECT_NEAR(6.0, extracted[1].first, kEps);
-  EXPECT_NEAR(10.0, extracted[2].first, kEps);
-  EXPECT_EQ(4, extracted[0].second);
-  EXPECT_EQ(0, extracted[1].second);
-  EXPECT_EQ(1, extracted[2].second);
-}
-
-TEST_P(SearcherTest, LinearLeafSearcherNonSimdDotProduct) {
-  MatrixXf query(3, 2);
-  query << 0, 1, 2, 3, 3, 1;
-  auto database = std::make_shared<MatrixXf>(3, 5);
-  *database << 0, 1, 2, 2, 1, 1, 0, 1, 2, 2, 2, 2, 5, 6, 1;
-
-  std::vector<TopN> top_n(
-      2, TopN(3, std::make_pair(std::numeric_limits<float>::max(), -1)));
-
-  auto leaf_searcher = LinearLeafSearcher::Create(database, DOT_PRODUCT);
-  ASSERT_TRUE(leaf_searcher->FindNeighbors(query, &top_n));
-
-  auto extracted = top_n[0].Take();
-  EXPECT_THAT(extracted, ElementsAre(Pair(-22, 3), Pair(-17, 2), Pair(-8, 0)));
-
-  extracted = top_n[1].Take();
-  EXPECT_THAT(extracted, ElementsAre(Pair(-14, 3), Pair(-10, 2), Pair(-8, 4)));
-}
-
-TEST_P(SearcherTest, AsymmetricHashNonSimd) {
-  MatrixXf query(5, 2);
-  query << 0, 1, 0, 1, 0, 1, 0, 1, 0, 1;
-  std::shared_ptr<Matrix8u> database(new Matrix8u(2, 6));
-  *database << 0, 1, 2, 2, 1, 0, 1, 0, 1, 2, 2, 0;
-  AsymmetricHashingProto proto;
-  TextFormat::ParseFromString(kExampleAsymmetricHashingProtoString, &proto);
-  auto querier = AsymmetricHashQuerier::Create(proto);
-  auto leaf_searcher =
-      AsymmetricHashLeafSearcher::Create(database, 0, std::move(querier));
-  std::vector<TopN> top_n;
-  for (int i = 0; i < 2; ++i) {
-    top_n.emplace_back(
-        TopN(3, std::make_pair(std::numeric_limits<float>::max(), -1)));
-  }
-  ASSERT_TRUE(leaf_searcher->FindNeighbors(query, &top_n));
-
-  constexpr float kEps = 1e-5;
-  auto extracted = top_n[0].Take();
-  EXPECT_NEAR(0.19, extracted[0].first, kEps);
-  EXPECT_NEAR(0.19, extracted[1].first, kEps);
-  EXPECT_NEAR(0.19, extracted[2].first, kEps);
-
-  extracted = top_n[1].Take();
-  EXPECT_NEAR(4.39, extracted[0].first, kEps);
-  EXPECT_NEAR(5.79, extracted[1].first, kEps);
-  EXPECT_NEAR(5.79, extracted[2].first, kEps);
-}
-
-#if defined(__ARM_NEON__) || defined(__SSE__)
-TEST_P(SearcherTest, AsymmetricHashSimdFloat32x4) {
-  MatrixXf query(5, 6);
-  query << 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0,
-      1, 0, 1, 0, 0, 1, 1;
-  std::shared_ptr<Matrix8u> database(new Matrix8u(2, 9));
-  *database << 0, 0, 0, 1, 1, 1, 2, 2, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2;
-  AsymmetricHashingProto proto;
-  TextFormat::ParseFromString(kExampleAsymmetricHashingProtoString, &proto);
-  auto querier = AsymmetricHashQuerier::Create(proto);
-  auto leaf_searcher = AsymmetricHashLeafSearcher::Create(
-      database, 0, std::move(querier), GetParam());
-  std::vector<TopN> top_n;
-  for (int i = 0; i < 6; ++i) {
-    top_n.emplace_back(
-        TopN(3, std::make_pair(std::numeric_limits<float>::max(), -1)));
-  }
-  ASSERT_TRUE(leaf_searcher->FindNeighbors(query, &top_n));
-
-  constexpr float kEps = 1e-5;
-  auto extracted = top_n[0].Take();
-  EXPECT_NEAR(0.19, extracted[0].first, kEps);
-  EXPECT_NEAR(0.19, extracted[1].first, kEps);
-  EXPECT_NEAR(0.19, extracted[2].first, kEps);
-
-  extracted = top_n[1].Take();
-  EXPECT_NEAR(4.39, extracted[0].first, kEps);
-  EXPECT_NEAR(4.39, extracted[1].first, kEps);
-  EXPECT_NEAR(4.39, extracted[2].first, kEps);
-
-  extracted = top_n[2].Take();
-  EXPECT_NEAR(0.19, extracted[0].first, kEps);
-  EXPECT_NEAR(0.19, extracted[1].first, kEps);
-  EXPECT_NEAR(1.59, extracted[2].first, kEps);
-
-  extracted = top_n[3].Take();
-  EXPECT_NEAR(2.19, extracted[0].first, kEps);
-  EXPECT_NEAR(2.19, extracted[1].first, kEps);
-  EXPECT_NEAR(2.39, extracted[2].first, kEps);
-
-  extracted = top_n[4].Take();
-  EXPECT_NEAR(3.59, extracted[0].first, kEps);
-  EXPECT_NEAR(3.59, extracted[1].first, kEps);
-  EXPECT_NEAR(3.59, extracted[2].first, kEps);
-
-  extracted = top_n[5].Take();
-  EXPECT_NEAR(4.39, extracted[0].first, kEps);
-  EXPECT_NEAR(4.39, extracted[1].first, kEps);
-  EXPECT_NEAR(5.79, extracted[2].first, kEps);
-}
-#endif
-
-#if defined(__ARM_NEON__) || defined(__SSE__)
-TEST_P(SearcherTest, AsymmetricHashSimdInt16x8) {
-  MatrixXf query(5, 11);
-  query << 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0,
-      1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0,
-      1, 1, 1, 0, 0, 0, 0;
-  std::shared_ptr<Matrix8u> database(new Matrix8u(2, 9));
-  *database << 0, 0, 0, 1, 1, 1, 2, 2, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2;
-  AsymmetricHashingProto proto;
-  TextFormat::ParseFromString(kExampleAsymmetricHashingProtoString, &proto);
-  proto.set_lookup_type(AsymmetricHashingProto::INT16);
-  auto querier = AsymmetricHashQuerier::Create(proto);
-  QueryInfo query_info;
-  ASSERT_TRUE(querier->Process(query, &query_info));
-
-  auto leaf_searcher = AsymmetricHashLeafSearcher::Create(
-      database, 0, std::move(querier), GetParam());
-  std::vector<TopN> top_n;
-  for (int i = 0; i < 11; ++i) {
-    top_n.emplace_back(
-        TopN(3, std::make_pair(std::numeric_limits<float>::max(), -1)));
-  }
-  ASSERT_TRUE(leaf_searcher->FindNeighbors(query, &top_n));
-
-  auto extracted = top_n[0].Take();
-  constexpr float kEps = 5e-2;
-  EXPECT_NEAR(0.19, extracted[0].first, kEps);
-  EXPECT_NEAR(0.19, extracted[1].first, kEps);
-  EXPECT_NEAR(0.19, extracted[2].first, kEps);
-
-  extracted = top_n[1].Take();
-  EXPECT_NEAR(4.39, extracted[0].first, kEps);
-  EXPECT_NEAR(4.39, extracted[1].first, kEps);
-  EXPECT_NEAR(4.39, extracted[2].first, kEps);
-
-  extracted = top_n[2].Take();
-  EXPECT_NEAR(0.19, extracted[0].first, kEps);
-  EXPECT_NEAR(0.19, extracted[1].first, kEps);
-  EXPECT_NEAR(1.59, extracted[2].first, kEps);
-
-  extracted = top_n[3].Take();
-  EXPECT_NEAR(2.19, extracted[0].first, kEps);
-  EXPECT_NEAR(2.19, extracted[1].first, kEps);
-  EXPECT_NEAR(2.39, extracted[2].first, kEps);
-
-  extracted = top_n[4].Take();
-  EXPECT_NEAR(3.59, extracted[0].first, kEps);
-  EXPECT_NEAR(3.59, extracted[1].first, kEps);
-  EXPECT_NEAR(3.59, extracted[2].first, kEps);
-
-  extracted = top_n[5].Take();
-  EXPECT_NEAR(4.39, extracted[0].first, kEps);
-  EXPECT_NEAR(4.39, extracted[1].first, kEps);
-  EXPECT_NEAR(5.79, extracted[2].first, kEps);
-
-  extracted = top_n[6].Take();
-  EXPECT_NEAR(1.39, extracted[0].first, kEps);
-  EXPECT_NEAR(1.39, extracted[1].first, kEps);
-  EXPECT_NEAR(1.79, extracted[2].first, kEps);
-
-  extracted = top_n[7].Take();
-  EXPECT_NEAR(1.59, extracted[0].first, kEps);
-  EXPECT_NEAR(1.59, extracted[1].first, kEps);
-  EXPECT_NEAR(1.59, extracted[2].first, kEps);
-
-  extracted = top_n[8].Take();
-  EXPECT_NEAR(1.39, extracted[0].first, kEps);
-  EXPECT_NEAR(1.39, extracted[1].first, kEps);
-  EXPECT_NEAR(1.79, extracted[2].first, kEps);
-
-  extracted = top_n[9].Take();
-  EXPECT_NEAR(0.79, extracted[0].first, kEps);
-  EXPECT_NEAR(0.79, extracted[1].first, kEps);
-  EXPECT_NEAR(0.99, extracted[2].first, kEps);
-
-  extracted = top_n[10].Take();
-  EXPECT_NEAR(0.79, extracted[0].first, kEps);
-  EXPECT_NEAR(0.79, extracted[1].first, kEps);
-  EXPECT_NEAR(0.79, extracted[2].first, kEps);
-}
-#endif
-
-#if defined(__ARM_NEON__) || defined(__SSE__)
-TEST_P(SearcherTest, AsymmetricHashMiniBatchedSimdFail) {
-  std::shared_ptr<Matrix8u> database(new Matrix8u(2, 9));
-  *database << 0, 0, 0, 1, 1, 1, 2, 2, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2;
-  AsymmetricHashingProto proto;
-  TextFormat::ParseFromString(kExampleAsymmetricHashingProtoString, &proto);
-  proto.set_lookup_type(AsymmetricHashingProto::FLOAT);
-  proto.set_query_distance(DistanceMeasure::UNSPECIFIED);
-  auto querier = AsymmetricHashQuerier::Create(proto);
-  auto leaf_searcher = AsymmetricHashLeafSearcher::Create(
-      database, 0, std::move(querier), GetParam());
-
-  MatrixXf queries(6, 6);
-  queries << 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0,
-      1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0;
-  std::vector<TopN> top_n;
-  for (int i = 0; i < queries.cols(); ++i) {
-    top_n.emplace_back(
-        TopN(3, std::make_pair(std::numeric_limits<float>::max(), -1)));
-  }
-  EXPECT_FALSE(leaf_searcher->FindNeighbors(queries, &top_n));
-}
-#endif
-
-INSTANTIATE_TEST_SUITE_P(
-    SearcherTest,
-    SearcherTest,
-    Values(std::numeric_limits<size_t>::max(), 1, 2, 3, 7, 23));
-
-}  // namespace
-
-}  // namespace core
-}  // namespace scann_ondevice
-}  // namespace tflite
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/core/simd_utils.h b/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/core/simd_utils.h
deleted file mode 100644
index f239ec482382e..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/core/simd_utils.h
+++ /dev/null
@@ -1,303 +0,0 @@
-/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#ifndef TENSORFLOW_LITE_SUPPORT_SCANN_ONDEVICE_CC_CORE_SIMD_UTILS_H_
-#define TENSORFLOW_LITE_SUPPORT_SCANN_ONDEVICE_CC_CORE_SIMD_UTILS_H_
-
-#include <cstdint>
-#ifdef __SSE__
-#include <x86intrin.h>
-#endif
-#ifdef __ARM_NEON__
-#include <arm_neon.h>
-#endif
-
-#include <cmath>
-#include <memory>
-
-#include "tensorflow_lite_support/cc/port/integral_types.h"
-
-namespace tflite {
-namespace scann_ondevice {
-namespace core {
-class SimdFloat32x1 {
-  float value_;
-
- public:
-  static constexpr size_t size() { return 1; }
-
-  void setzero() { value_ = 0.0f; }
-
-  void load(const float* mem) { value_ = *mem; }
-  void dequantize_accum_storeu(float* mem, float, float) const {
-    *mem += value_;
-  }
-  SimdFloat32x1& operator+=(const SimdFloat32x1& rhs) {
-    value_ += rhs.value_;
-    return *this;
-  }
-};
-#ifdef __SSE__
-class SimdFloat32x4 {
-  __m128 value_;
-
- public:
-  static constexpr size_t size() { return 4; }
-
-  void setzero() { value_ = _mm_setzero_ps(); }
-  void load(const float* mem) { value_ = _mm_load_ps(mem); }
-  void loadu(const float* mem) { value_ = _mm_loadu_ps(mem); }
-  void storeu(float* mem) const { _mm_storeu_ps(mem, value_); }
-
-  void dequantize_accum_storeu(float* mem, float, float) const {
-    SimdFloat32x4 simd;
-    simd.loadu(mem);
-    simd += *this;
-    simd.storeu(mem);
-  }
-
-  SimdFloat32x4& operator+=(const SimdFloat32x4& rhs) {
-    value_ = _mm_add_ps(rhs.value_, value_);
-    return *this;
-  }
-};
-#endif
-#ifdef __AVX__
-class SimdFloat32x8 {
-  __m256 value_;
-
- public:
-  static constexpr size_t size() { return 8; }
-
-  void setzero() { value_ = _mm256_setzero_ps(); }
-  void load(const float* mem) { value_ = _mm256_load_ps(mem); }
-
-  void loadu(const float* mem) { value_ = _mm256_loadu_ps(mem); }
-
-  void storeu(float* mem) { _mm256_storeu_ps(mem, value_); }
-
-  void dequantize_accum_storeu(float* mem, float, float) const {
-    SimdFloat32x8 simd;
-    simd.loadu(mem);
-    simd += *this;
-    simd.storeu(mem);
-  }
-
-  SimdFloat32x8& operator+=(const SimdFloat32x8& rhs) {
-    value_ = _mm256_add_ps(rhs.value_, value_);
-    return *this;
-  }
-};
-#endif
-#ifdef __ARM_NEON__
-class SimdFloat32x4 {
-  float32x4_t value_;
-
- public:
-  static constexpr size_t size() { return 4; }
-
-  void setzero() { value_ = vmovq_n_f32(0); }
-  void load(const float* mem) { value_ = vld1q_f32(mem); }
-  void loadu(const float* mem) { value_ = vld1q_f32(mem); }
-  void storeu(float* mem) const { vst1q_f32(mem, value_); }
-
-  void dequantize_accum_storeu(float* mem, float, float) const {
-    SimdFloat32x4 simd;
-    simd.loadu(mem);
-    simd += *this;
-    simd.storeu(mem);
-  }
-
-  SimdFloat32x4& operator+=(const SimdFloat32x4& rhs) {
-    value_ = vaddq_f32(rhs.value_, value_);
-    return *this;
-  }
-};
-#endif
-
-class SimdInt16x1 {
-  uint16_t value_;
-
- public:
-  static constexpr size_t size() { return 1; }
-
-  void setzero() { value_ = 0; }
-
-  void load(const uint16_t* mem) { value_ = *mem; }
-
-  void load(const uint8_t* mem) { value_ = *mem; }
-  void dequantize_accum_storeu(float* mem, float scale, float offset) const {
-    *mem += scale * value_ + offset;
-  }
-
-  SimdInt16x1& operator+=(const SimdInt16x1& rhs) {
-    value_ += rhs.value_;
-    return *this;
-  }
-};
-#ifdef __SSE4_1__
-class SimdInt16x8 {
-  __m128i value_;
-
- public:
-  static constexpr size_t size() { return 8; }
-
-  void setzero() { value_ = _mm_setzero_si128(); }
-  void load(const uint16_t* mem) {
-    value_ = _mm_load_si128(reinterpret_cast<const __m128i*>(mem));
-  }
-
-  void loadu(const uint16_t* mem) {
-    value_ = _mm_loadu_si128(reinterpret_cast<const __m128i*>(mem));
-  }
-  void load(const uint8_t* mem) {
-    __m128i tmp = _mm_loadl_epi64(reinterpret_cast<const __m128i*>(mem));
-    value_ = _mm_cvtepu8_epi16(tmp);
-  }
-
-  void loadu(const uint8_t* mem) {
-    __m128i tmp = _mm_loadl_epi64(reinterpret_cast<const __m128i*>(mem));
-    value_ = _mm_cvtepu8_epi16(tmp);
-  }
-  void dequantize_accum_storeu(float* mem, float scale, float offset) const {
-    __m128 dst0 = _mm_loadu_ps(mem);
-    __m128 dst1 = _mm_loadu_ps(mem + 4);
-    __m128i lo_i16 = value_;
-    __m128i hi_i16 = _mm_unpackhi_epi64(value_, value_);
-    __m128i lo_i32 = _mm_cvtepu16_epi32(lo_i16);
-    __m128i hi_i32 = _mm_cvtepu16_epi32(hi_i16);
-    __m128 lo_f32 = _mm_cvtepi32_ps(lo_i32);
-    __m128 hi_f32 = _mm_cvtepi32_ps(hi_i32);
-    __m128 offset_simd = _mm_set1_ps(offset);
-    __m128 scale_simd = _mm_set1_ps(scale);
-    lo_f32 = _mm_mul_ps(scale_simd, lo_f32);
-    hi_f32 = _mm_mul_ps(scale_simd, hi_f32);
-    lo_f32 = _mm_add_ps(lo_f32, offset_simd);
-    hi_f32 = _mm_add_ps(hi_f32, offset_simd);
-    dst0 = _mm_add_ps(dst0, lo_f32);
-    dst1 = _mm_add_ps(dst1, hi_f32);
-    _mm_storeu_ps(mem, dst0);
-    _mm_storeu_ps(mem + 4, dst1);
-  }
-
-  SimdInt16x8& operator+=(const SimdInt16x8& rhs) {
-    value_ = _mm_add_epi16(rhs.value_, value_);
-    return *this;
-  }
-};
-#endif
-#ifdef __ARM_NEON__
-class SimdInt16x8 {
-  uint16x8_t value_;
-
- public:
-  static constexpr size_t size() { return 8; }
-
-  void setzero() { value_ = vmovq_n_u16(0); }
-  void load(const uint16* mem) { value_ = vld1q_u16(mem); }
-
-  void loadu(const uint16* mem) { value_ = vld1q_u16(mem); }
-  void load(const uint8* mem) {
-    uint8x8_t tmp = vld1_u8(mem);
-    value_ = vmovl_u8(tmp);
-  }
-
-  void loadu(const uint8* mem) {
-    uint8x8_t tmp = vld1_u8(mem);
-    value_ = vmovl_u8(tmp);
-  }
-  void dequantize_accum_storeu(float* mem, float scale, float offset) const {
-    float32x4_t dst0 = vld1q_f32(mem);
-    float32x4_t dst1 = vld1q_f32(mem + 4);
-    uint16x4_t lo_i16 = vget_low_u16(value_);
-    uint16x4_t hi_i16 = vget_high_u16(value_);
-    uint32x4_t lo_i32 = vmovl_u16(lo_i16);
-    uint32x4_t hi_i32 = vmovl_u16(hi_i16);
-    float32x4_t lo_f32 = vcvtq_f32_u32(lo_i32);
-    float32x4_t hi_f32 = vcvtq_f32_u32(hi_i32);
-    float32x4_t offset_simd = vdupq_n_f32(offset);
-    float32x4_t scale_simd = vdupq_n_f32(scale);
-    lo_f32 = vmlaq_f32(offset_simd, scale_simd, lo_f32);
-    hi_f32 = vmlaq_f32(offset_simd, scale_simd, hi_f32);
-    dst0 = vaddq_f32(dst0, lo_f32);
-    dst1 = vaddq_f32(dst1, hi_f32);
-    vst1q_f32(mem, dst0);
-    vst1q_f32(mem + 4, dst1);
-  }
-
-  SimdInt16x8& operator+=(const SimdInt16x8& rhs) {
-    value_ = vaddq_u16(rhs.value_, value_);
-    return *this;
-  }
-};
-#endif
-#ifdef __AVX2__
-class SimdInt16x16 {
-  __m256i value_;
-
- public:
-  static constexpr size_t size() { return 16; }
-
-  void setzero() { value_ = _mm256_setzero_si256(); }
-
-  void load(const uint16* mem) {
-    value_ = _mm256_load_si256(reinterpret_cast<const __m256i*>(mem));
-  }
-
-  void loadu(const uint16* mem) {
-    value_ = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(mem));
-  }
-
-  void load(const uint8* mem) {
-    __m128i tmp = _mm_load_si128(reinterpret_cast<const __m128i*>(mem));
-    value_ = _mm256_cvtepu8_epi16(tmp);
-  }
-
-  void loadu(const uint8* mem) {
-    __m128i tmp = _mm_loadu_si128(reinterpret_cast<const __m128i*>(mem));
-    value_ = _mm256_cvtepu8_epi16(tmp);
-  }
-
-  void dequantize_accum_storeu(float* mem, float scale, float offset) const {
-    __m256 dst0 = _mm256_loadu_ps(mem);
-    __m256 dst1 = _mm256_loadu_ps(mem + 8);
-    __m128i lo_i16 = _mm256_castsi256_si128(value_);
-    __m128i hi_i16 = _mm256_extractf128_si256(value_, 1);
-    __m256i lo_i32 = _mm256_cvtepu16_epi32(lo_i16);
-    __m256i hi_i32 = _mm256_cvtepu16_epi32(hi_i16);
-    __m256 lo_f32 = _mm256_cvtepi32_ps(lo_i32);
-    __m256 hi_f32 = _mm256_cvtepi32_ps(hi_i32);
-    __m256 offset_simd = _mm256_set1_ps(offset);
-    __m256 scale_simd = _mm256_set1_ps(scale);
-    lo_f32 = _mm256_fmadd_ps(scale_simd, lo_f32, offset_simd);
-    hi_f32 = _mm256_fmadd_ps(scale_simd, hi_f32, offset_simd);
-    dst0 = _mm256_add_ps(dst0, lo_f32);
-    dst1 = _mm256_add_ps(dst1, hi_f32);
-    _mm256_storeu_ps(mem, dst0);
-    _mm256_storeu_ps(mem + 8, dst1);
-  }
-
-  SimdInt16x16& operator+=(const SimdInt16x16& rhs) {
-    value_ = _mm256_add_epi16(rhs.value_, value_);
-    return *this;
-  }
-};
-#endif
-
-}  // namespace core
-}  // namespace scann_ondevice
-}  // namespace tflite
-
-#endif  // TENSORFLOW_LITE_SUPPORT_SCANN_ONDEVICE_CC_CORE_SIMD_UTILS_H_
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/index.cc b/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/index.cc
deleted file mode 100644
index e8be5f6572f17..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/index.cc
+++ /dev/null
@@ -1,138 +0,0 @@
-/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#include "tensorflow_lite_support/scann_ondevice/cc/index.h"
-
-#include <cstddef>
-#include <memory>
-
-#include "absl/memory/memory.h"        // from @com_google_absl
-#include "absl/status/status.h"        // from @com_google_absl
-#include "absl/status/statusor.h"      // from @com_google_absl
-#include "absl/strings/str_format.h"   // from @com_google_absl
-#include "absl/strings/string_view.h"  // from @com_google_absl
-#include "leveldb/cache.h"             // from @com_google_leveldb
-#include "leveldb/iterator.h"          // from @com_google_leveldb
-#include "leveldb/options.h"           // from @com_google_leveldb
-#include "leveldb/slice.h"             // from @com_google_leveldb
-#include "leveldb/status.h"            // from @com_google_leveldb
-#include "leveldb/table.h"             // from @com_google_leveldb
-#include "tensorflow_lite_support/cc/port/status_macros.h"
-#include "tensorflow_lite_support/scann_ondevice/cc/mem_random_access_file.h"
-#include "tensorflow_lite_support/scann_ondevice/cc/utils.h"
-#include "tensorflow_lite_support/scann_ondevice/proto/index_config.pb.h"
-
-namespace tflite {
-namespace scann_ondevice {
-
-namespace {
-
-// Helper function to get the iterator value associated to the provided key.
-//
-// Important: the underlying storage for the returned string view is owned by
-// the provided iterator, and only valid until this iterator is used again with
-// a different key. See:
-// https://github.com/google/leveldb/blob/main/include/leveldb/iterator.h
-absl::StatusOr<absl::string_view> GetValueForKey(leveldb::Iterator* iterator,
-                                                 std::string& key) {
-  iterator->Seek(key);
-  if (!iterator->Valid() || iterator->key() != key ||
-      !iterator->status().ok()) {
-    return absl::NotFoundError(
-        absl::StrFormat("Unable to find key in the index: %s", key));
-  }
-  leveldb::Slice value = iterator->value();
-  return absl::string_view(value.data(), value.size());
-}
-}  // namespace
-
-/* static */
-absl::StatusOr<std::unique_ptr<Index>> Index::CreateFromIndexBuffer(
-    const char* buffer_data,
-    size_t buffer_size) {
-  // Use absl::WrapUnique() to call private constructor:
-  // https://abseil.io/tips/126.
-  std::unique_ptr<Index> index = absl::WrapUnique(new Index());
-  RETURN_IF_ERROR(index->InitFromBuffer(buffer_data, buffer_size));
-  return index;
-}
-
-absl::StatusOr<IndexConfig> Index::GetIndexConfig() const {
-  std::string key(kIndexConfigKey);
-  ASSIGN_OR_RETURN(absl::string_view value,
-                   GetValueForKey(config_iterator_.get(), key));
-  IndexConfig config;
-  if (!config.ParseFromString(std::string(value))) {
-    return absl::InternalError("Unable to parse IndexConfig proto");
-  }
-  return config;
-}
-
-absl::StatusOr<absl::string_view> Index::GetUserInfo() const {
-  std::string key(kUserInfoKey);
-  // Intercept NotFound errors and return empty string instead.
-  auto user_info_or = GetValueForKey(info_iterator_.get(), key);
-  if (user_info_or.status().code() == absl::StatusCode::kNotFound) {
-    return "";
-  }
-  return user_info_or;
-}
-
-absl::StatusOr<absl::string_view> Index::GetPartitionAtIndex(uint32_t i) const {
-  std::string key(GetPartitionKey(i));
-  return GetValueForKey(embedding_iterator_.get(), key);
-}
-
-absl::StatusOr<absl::string_view> Index::GetMetadataAtIndex(uint32_t i) const {
-  std::string key(GetMetadataKey(i));
-  return GetValueForKey(metadata_iterator_.get(), key);
-}
-
-absl::Status Index::InitFromBuffer(const char* buffer_data,
-                                   size_t buffer_size) {
-  // Sanity check.
-  if (buffer_data == nullptr) {
-    return absl::InvalidArgumentError("Buffer cannot be null");
-  }
-  // Create file from buffer.
-  file_ = absl::make_unique<MemRandomAccessFile>(buffer_data, buffer_size);
-  // Create options with cache disabled, as this saves memory and has negligible
-  // impact on performance in this setup as any key can be accessed anytime.
-  leveldb::Options options;
-  cache_ = absl::WrapUnique(leveldb::NewLRUCache(0));
-  options.block_cache = cache_.get();
-  // Build Table from file and options.
-  leveldb::Table* table;
-  leveldb::Status status =
-      leveldb::Table::Open(options, file_.get(), buffer_size, &table);
-  if (!status.ok()) {
-    return absl::InternalError(
-        absl::StrFormat("Unable to open levelDB table: %s", status.ToString()));
-  }
-  table_ = absl::WrapUnique(table);
-  // Create iterators.
-  config_iterator_ =
-      absl::WrapUnique(table_->NewIterator(leveldb::ReadOptions()));
-  info_iterator_ =
-      absl::WrapUnique(table_->NewIterator(leveldb::ReadOptions()));
-  embedding_iterator_ =
-      absl::WrapUnique(table_->NewIterator(leveldb::ReadOptions()));
-  metadata_iterator_ =
-      absl::WrapUnique(table_->NewIterator(leveldb::ReadOptions()));
-  return absl::OkStatus();
-}
-
-}  // namespace scann_ondevice
-}  // namespace tflite
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/index.h b/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/index.h
deleted file mode 100644
index 15e709183a606..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/index.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#ifndef TENSORFLOW_LITE_SUPPORT_SCANN_ONDEVICE_CC_INDEX_H_
-#define TENSORFLOW_LITE_SUPPORT_SCANN_ONDEVICE_CC_INDEX_H_
-
-#include <memory>
-
-#include "absl/status/status.h"        // from @com_google_absl
-#include "absl/status/statusor.h"      // from @com_google_absl
-#include "absl/strings/string_view.h"  // from @com_google_absl
-#include "leveldb/cache.h"             // from @com_google_leveldb
-#include "leveldb/iterator.h"          // from @com_google_leveldb
-#include "leveldb/table.h"             // from @com_google_leveldb
-#include "tensorflow_lite_support/scann_ondevice/cc/mem_random_access_file.h"
-#include "tensorflow_lite_support/scann_ondevice/proto/index_config.pb.h"
-
-namespace tflite {
-namespace scann_ondevice {
-
-// Helper class for getting access to the data contained in the LevelDB index
-// file.
-//
-// This class is NOT thread-safe.
-class Index {
- public:
-  // Creates an Index from the provided buffer. Ownership is transferred to the
-  // caller. Returns an error if the creation failed, which may happen e.g. if
-  // the provided buffer is not a valid LevelDB index file.
-  //
-  // Warning: Does not take ownership of the provided buffer, which must outlive
-  // this object.
-  static absl::StatusOr<std::unique_ptr<Index>> CreateFromIndexBuffer(
-      const char* buffer_data,
-      size_t buffer_size);
-
-  // Parses and returns the `IndexConfig` stored in the index file.
-  absl::StatusOr<IndexConfig> GetIndexConfig() const;
-
-  // Provides access to the opaque user info stored in the index file (if any),
-  // in raw binary form. Returns an empty string if the index doesn't contain
-  // user info.
-  absl::StatusOr<absl::string_view> GetUserInfo() const;
-
-  // Provides access to the partition data corresponding to the i-th leaf in the
-  // order specified in the `IndexConfig`, in raw binary form.
-  //
-  // Warning: In order to avoid unnecessary copies, the underlying pointer for
-  // the returned string view is only valid until next call to this method.
-  absl::StatusOr<absl::string_view> GetPartitionAtIndex(uint32_t i) const;
-
-  // Provides access to the metadata associated with the i-th embedding in the
-  // index, in raw binary form.
-  //
-  // Warning: In order to avoid unnecessary copies, the underlying pointer for
-  // the returned string view is only valid until next call to this method.
-  absl::StatusOr<absl::string_view> GetMetadataAtIndex(uint32_t i) const;
-
- private:
-  // Private default constructor, called from CreateFromBuffer().
-  Index() = default;
-  // Initializes the Index from the provided buffer.
-  absl::Status InitFromBuffer(const char* buffer_data, size_t buffer_size);
-
-  std::unique_ptr<leveldb::Table> table_;
-  std::unique_ptr<MemRandomAccessFile> file_;
-  std::unique_ptr<leveldb::Cache> cache_;
-  // One iterator per getter, so that calls from one getter don't invalidate
-  // results from another one.
-  std::unique_ptr<leveldb::Iterator> config_iterator_;
-  std::unique_ptr<leveldb::Iterator> info_iterator_;
-  std::unique_ptr<leveldb::Iterator> embedding_iterator_;
-  std::unique_ptr<leveldb::Iterator> metadata_iterator_;
-};
-
-}  // namespace scann_ondevice
-}  // namespace tflite
-
-#endif  // TENSORFLOW_LITE_SUPPORT_SCANN_ONDEVICE_CC_INDEX_H_
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/index_builder.cc b/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/index_builder.cc
deleted file mode 100644
index c77f7299e64a6..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/index_builder.cc
+++ /dev/null
@@ -1,177 +0,0 @@
-/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#include "tensorflow_lite_support/scann_ondevice/cc/index_builder.h"
-
-#include <string>
-#include <tuple>
-#include <vector>
-
-#include "absl/container/btree_map.h"  // from @com_google_absl
-#include "absl/status/status.h"        // from @com_google_absl
-#include "absl/strings/str_format.h"   // from @com_google_absl
-#include "leveldb/options.h"           // from @com_google_leveldb
-#include "leveldb/slice.h"             // from @com_google_leveldb
-#include "leveldb/status.h"            // from @com_google_leveldb
-#include "leveldb/table_builder.h"     // from @com_google_leveldb
-#include "leveldb/write_batch.h"       // from @com_google_leveldb
-#include "tensorflow_lite_support/cc/port/status_macros.h"
-#include "tensorflow_lite_support/scann_ondevice/cc/mem_writable_file.h"
-#include "tensorflow_lite_support/scann_ondevice/cc/utils.h"
-#include "tensorflow_lite_support/scann_ondevice/proto/index_config.pb.h"
-
-namespace tflite {
-namespace scann_ondevice {
-
-namespace {
-
-absl::Status LevelDBStatusToAbsl(leveldb::Status leveldb_status) {
-  if (leveldb_status.ok()) {
-    return absl::OkStatus();
-  } else if (leveldb_status.IsInvalidArgument()) {
-    return absl::InvalidArgumentError(leveldb_status.ToString());
-  } else if (leveldb_status.IsNotFound()) {
-    return absl::NotFoundError(leveldb_status.ToString());
-  } else if (leveldb_status.IsNotSupportedError()) {
-    return absl::UnimplementedError(leveldb_status.ToString());
-  } else {
-    return absl::InternalError(leveldb_status.ToString());
-  }
-}
-
-template <typename T>
-absl::StatusOr<std::string> CreateIndexBufferImpl(
-    absl::Span<const T> database,
-    absl::Span<const uint32_t> partition_assignment,
-    absl::Span<const std::string> metadata,
-    const std::string& userinfo,
-    IndexConfig index_config,
-    bool compression) {
-  if (partition_assignment.size() != metadata.size()) {
-    return absl::InvalidArgumentError(
-        "Size of partition assignment and metadata mismatch");
-  }
-
-  if (database.size() / index_config.embedding_dim() != metadata.size()) {
-    return absl::InvalidArgumentError(
-        "Number of embeddings differs from number of metadata");
-  }
-
-  const size_t num_partitions =
-      index_config.scann_config().partitioner().leaf_size();
-
-  std::vector<std::vector<char>> partition_bytes(num_partitions);
-  std::vector<std::vector<std::string>> partition_metadata(num_partitions);
-
-  const size_t per_embedding_bytes = sizeof(T) * index_config.embedding_dim();
-  const char* database_bytes = reinterpret_cast<const char*>(database.data());
-  for (size_t i = 0; i < partition_assignment.size(); ++i) {
-    const size_t partition_idx = partition_assignment[i];
-    if (partition_idx >= num_partitions) {
-      return absl::InvalidArgumentError(absl::StrFormat(
-          "Partition index %d is larger than number of partitions: %d",
-          partition_idx, num_partitions));
-    }
-    partition_bytes[partition_idx].insert(
-        partition_bytes[partition_idx].end(),
-        database_bytes + i * per_embedding_bytes,
-        database_bytes + (i + 1) * per_embedding_bytes);
-    partition_metadata[partition_idx].push_back(metadata[i]);
-  }
-
-  std::vector<std::string> flatten_metadata;
-  flatten_metadata.reserve(metadata.size());
-  for (auto partition : partition_metadata) {
-    const size_t offset = flatten_metadata.size();
-    index_config.mutable_global_partition_offsets()->Add(offset);
-    flatten_metadata.insert(flatten_metadata.end(), partition.begin(),
-                            partition.end());
-    partition.clear();
-    partition.shrink_to_fit();
-  }
-
-  std::string buffer;
-  ASSIGN_OR_RETURN(auto mem_writable_file, MemWritableFile::Create(&buffer));
-
-  leveldb::Options options;
-  options.compression =
-      compression ? leveldb::kSnappyCompression : leveldb::kNoCompression;
-  leveldb::TableBuilder table_builder(options, mem_writable_file.get());
-
-  // Keys must be added in ascending *lexical* order, e.g:
-  // E_0, E_1, E_10, E_11, [...], E_18, E_19, E_2, E_20, E_21, [...]
-  // We're using btree_map to reorder partition and metadata keys.
-  absl::btree_map<std::string, size_t> ordered_partition_key_to_index;
-  for (size_t i = 0; i < partition_bytes.size(); ++i) {
-    ordered_partition_key_to_index[GetPartitionKey(i)] = i;
-  }
-  for (auto [key, index] : ordered_partition_key_to_index) {
-    table_builder.Add(leveldb::Slice(key),
-                      leveldb::Slice(partition_bytes[index].data(),
-                                     partition_bytes[index].size()));
-  }
-  table_builder.Add(leveldb::Slice(kIndexConfigKey),
-                    leveldb::Slice(index_config.SerializeAsString()));
-  absl::btree_map<std::string, size_t> ordered_metadata_key_to_index;
-  for (size_t i = 0; i < flatten_metadata.size(); ++i) {
-    ordered_metadata_key_to_index[GetMetadataKey(i)] = i;
-  }
-  for (auto [key, index] : ordered_metadata_key_to_index) {
-    table_builder.Add(leveldb::Slice(key),
-                      leveldb::Slice(flatten_metadata[index]));
-  }
-  table_builder.Add(leveldb::Slice(kUserInfoKey), leveldb::Slice(userinfo));
-
-  const auto status = table_builder.Finish();
-  if (!status.ok()) {
-    return LevelDBStatusToAbsl(status);
-  }
-
-  return buffer;
-}
-
-}  // namespace
-
-absl::StatusOr<std::string> CreateIndexBuffer(const IndexedArtifacts& artifacts,
-                                              bool compression) {
-  if (artifacts.hashed_database.has_value() &&
-      artifacts.float_database.has_value()) {
-    return absl::InvalidArgumentError(
-        "Can not have both float database and hashed database");
-  }
-
-  IndexConfig index_config;
-  *index_config.mutable_scann_config() = artifacts.config;
-  index_config.set_embedding_dim(artifacts.embedding_dim);
-  if (artifacts.hashed_database.has_value()) {
-    index_config.set_embedding_type(index_config.UINT8);
-    return CreateIndexBufferImpl(artifacts.hashed_database.value(),
-                                 artifacts.partition_assignment,
-                                 artifacts.metadata, artifacts.userinfo,
-                                 std::move(index_config), compression);
-  } else if (artifacts.float_database.has_value()) {
-    index_config.set_embedding_type(index_config.FLOAT);
-    return CreateIndexBufferImpl(artifacts.float_database.value(),
-                                 artifacts.partition_assignment,
-                                 artifacts.metadata, artifacts.userinfo,
-                                 std::move(index_config), compression);
-  } else {
-    return absl::InvalidArgumentError(
-        "Need either hashed_database or float_database");
-  }
-}
-
-}  // namespace scann_ondevice
-}  // namespace tflite
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/index_builder.h b/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/index_builder.h
deleted file mode 100644
index 5701796943e28..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/index_builder.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#ifndef TENSORFLOW_LITE_SUPPORT_SCANN_ONDEVICE_CC_INDEX_FILE_MUTATOR_H_
-#define TENSORFLOW_LITE_SUPPORT_SCANN_ONDEVICE_CC_INDEX_FILE_MUTATOR_H_
-
-#include "absl/status/statusor.h"      // from @com_google_absl
-#include "absl/strings/string_view.h"  // from @com_google_absl
-#include "absl/types/optional.h"       // from @com_google_absl
-#include "absl/types/span.h"           // from @com_google_absl
-#include "leveldb/db.h"                // from @com_google_leveldb
-#include "tensorflow_lite_support/scann_ondevice/cc/core/serialized_searcher.pb.h"
-#include "tensorflow_lite_support/scann_ondevice/proto/index_config.pb.h"
-
-namespace tflite {
-namespace scann_ondevice {
-
-struct IndexedArtifacts {
-  // Config for on-device scam. Contains pretrained parts such as partition
-  // centroids, compression codebook.
-  tflite::scann_ondevice::core::ScannOnDeviceConfig config;
-
-  // The dimension of each processed embedding in either hashed_database or
-  // float_database. Note that if hashing is enabled, it can be different from
-  // the original embedding dimension depending on the config.
-  uint32_t embedding_dim;
-
-  // Flattened database embeddings. The embeddings should be stored
-  // consecutively in row major layout. Exactly one of the hashed_database and
-  // float_database is expected. hashed_database can be either AH compressed or
-  // 8-bit quantized. In the case of 8-bit quantization, it's casted to uint8_t.
-  absl::optional<absl::Span<const uint8_t>> hashed_database;
-  absl::optional<absl::Span<const float>> float_database;
-
-  // The partition each of the database point belongs to. The size should be the
-  // same as how many database points there are.
-  absl::Span<const uint32_t> partition_assignment;
-
-  // The metadata (label) for each database point. It should have the same size
-  // as partition_assignment.
-  absl::Span<const std::string> metadata;
-
-  // An arbitrary user supplied string for storing custom information.
-  std::string userinfo;
-};
-
-// Creates a byte buffer for the index file from the artifacts. Returns errors
-// when there are not exactly one database specified, or other issues with input
-// such as shape mismatch, invalid partition indices etc.
-absl::StatusOr<std::string> CreateIndexBuffer(const IndexedArtifacts& artifacts,
-                                              bool compression);
-
-}  // namespace scann_ondevice
-}  // namespace tflite
-
-#endif  // TENSORFLOW_LITE_SUPPORT_SCANN_ONDEVICE_CC_INDEX_FILE_MUTATOR_H_
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/mem_random_access_file.cc b/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/mem_random_access_file.cc
deleted file mode 100644
index 59b9deb8e8682..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/mem_random_access_file.cc
+++ /dev/null
@@ -1,52 +0,0 @@
-/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#include "tensorflow_lite_support/scann_ondevice/cc/mem_random_access_file.h"
-
-#include <algorithm>
-#include <cstddef>
-#include <cstdint>
-
-#include "leveldb/env.h"     // from @com_google_leveldb
-#include "leveldb/slice.h"   // from @com_google_leveldb
-#include "leveldb/status.h"  // from @com_google_leveldb
-
-namespace tflite {
-namespace scann_ondevice {
-
-MemRandomAccessFile::MemRandomAccessFile(const char* buffer_data,
-                                         size_t buffer_size)
-    : buffer_data_(buffer_data), buffer_size_(buffer_size) {}
-
-MemRandomAccessFile::~MemRandomAccessFile() {}
-
-leveldb::Status MemRandomAccessFile::Read(uint64_t offset,
-                                          size_t n,
-                                          leveldb::Slice* result,
-                                          char* scratch) const {
-  // Sanity check.
-  if (offset > buffer_size_) {
-    return leveldb::Status::InvalidArgument(
-        "Read offset is beyond buffer size");
-  }
-  // Truncate result if the requested chunk extends beyond the buffer.
-  const size_t result_size =
-      std::min(n, buffer_size_ - static_cast<size_t>(offset));
-  *result = leveldb::Slice(buffer_data_ + offset, result_size);
-  return leveldb::Status::OK();
-}
-
-}  // namespace scann_ondevice
-}  // namespace tflite
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/mem_random_access_file.h b/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/mem_random_access_file.h
deleted file mode 100644
index 5ca68f2e2c91e..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/mem_random_access_file.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#ifndef TENSORFLOW_LITE_SUPPORT_SCANN_ONDEVICE_CC_MEM_RANDOM_ACCESS_FILE_H_
-#define TENSORFLOW_LITE_SUPPORT_SCANN_ONDEVICE_CC_MEM_RANDOM_ACCESS_FILE_H_
-
-#include <cstddef>
-#include <cstdint>
-
-#include "leveldb/env.h"     // from @com_google_leveldb
-#include "leveldb/slice.h"   // from @com_google_leveldb
-#include "leveldb/status.h"  // from @com_google_leveldb
-
-namespace tflite {
-namespace scann_ondevice {
-
-// An implementation of LevelDB's RandomAccessFile [1] that wraps an in-memory
-// buffer.
-//
-// [1]: https://github.com/google/leveldb/blob/main/include/leveldb/env.h
-class MemRandomAccessFile : public leveldb::RandomAccessFile {
- public:
-  // Constructor does not take ownership of the provided buffer, which must
-  // outlive this object.
-  MemRandomAccessFile(const char* buffer_data, size_t buffer_size);
-  ~MemRandomAccessFile() override;
-
-  // Override of the `Read` function. Note that `scratch` is unused in the
-  // implementation.
-  leveldb::Status Read(uint64_t offset,
-                       size_t n,
-                       leveldb::Slice* result,
-                       char* scratch) const override;
-
-  // Class is movable and non-copyable.
-  MemRandomAccessFile(MemRandomAccessFile&& rhs) = default;
-  MemRandomAccessFile& operator=(MemRandomAccessFile&& rhs) = default;
-  MemRandomAccessFile(const MemRandomAccessFile& rhs) = delete;
-  MemRandomAccessFile& operator=(const MemRandomAccessFile& rhs) = delete;
-
- private:
-  const char* buffer_data_;
-  size_t buffer_size_;
-};
-
-}  // namespace scann_ondevice
-}  // namespace tflite
-
-#endif  // TENSORFLOW_LITE_SUPPORT_SCANN_ONDEVICE_CC_MEM_RANDOM_ACCESS_FILE_H_
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/mem_writable_file.h b/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/mem_writable_file.h
deleted file mode 100644
index 842e837927d4e..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/mem_writable_file.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#ifndef TENSORFLOW_LITE_SUPPORT_SCANN_ONDEVICE_CC_MEM_WRITABLE_FILE_H_
-#define TENSORFLOW_LITE_SUPPORT_SCANN_ONDEVICE_CC_MEM_WRITABLE_FILE_H_
-
-#include <memory>
-#include <string>
-
-#include "absl/status/statusor.h"  // from @com_google_absl
-#include "absl/strings/cord.h"     // from @com_google_absl
-#include "leveldb/env.h"           // from @com_google_leveldb
-#include "leveldb/slice.h"         // from @com_google_leveldb
-#include "leveldb/status.h"        // from @com_google_leveldb
-
-namespace tflite {
-namespace scann_ondevice {
-
-// An implementation of LevelDB's WritableFile [1] that wraps an in-memory
-// buffer.
-//
-// [1]: https://github.com/google/leveldb/blob/main/include/leveldb/env.h
-class MemWritableFile : public leveldb::WritableFile {
- public:
-  // Creates a MemWritableFile from a given buffer. Returns
-  // InvalidArgumentError if pointer is null.
-  static absl::StatusOr<std::unique_ptr<MemWritableFile>> Create(
-      std::string* buffer);
-
-  ~MemWritableFile() override = default;
-
-  // Allow moves. Disallow copies.
-  MemWritableFile(MemWritableFile&& rhs) = default;
-  MemWritableFile& operator=(MemWritableFile&& rhs) = default;
-  MemWritableFile(const MemWritableFile& rhs) = delete;
-  MemWritableFile& operator=(const MemWritableFile& rhs) = delete;
-
-  leveldb::Status Append(const leveldb::Slice& data) override;
-  leveldb::Status Close() override;
-  leveldb::Status Flush() override;
-  leveldb::Status Sync() override;
-
- private:
-  MemWritableFile(std::string* buffer);
-
-  std::string* buffer_;
-};
-
-}  // namespace scann_ondevice
-}  // namespace tflite
-
-#endif  // TENSORFLOW_LITE_SUPPORT_SCANN_ONDEVICE_CC_MEM_WRITABLE_FILE_H_
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/python/index_builder_py_wrapper.cc b/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/python/index_builder_py_wrapper.cc
deleted file mode 100644
index 709564035ff1f..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/python/index_builder_py_wrapper.cc
+++ /dev/null
@@ -1,64 +0,0 @@
-/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#include <string>
-
-#include "absl/types/optional.h"  // from @com_google_absl
-#include "absl/types/span.h"      // from @com_google_absl
-#include "pybind11/cast.h"
-#include "pybind11/pybind11.h"
-#include "pybind11/pytypes.h"
-#include "pybind11_abseil/absl_casters.h"    // from @pybind11_abseil
-#include "pybind11_abseil/status_casters.h"  // from @pybind11_abseil
-#include "tensorflow_lite_support/scann_ondevice/cc/core/serialized_searcher.pb.h"
-#include "tensorflow_lite_support/scann_ondevice/cc/index_builder.h"
-
-namespace pybind11 {
-
-PYBIND11_MODULE(index_builder, m) {
-  google::ImportStatusModule();
-
-  m.def(
-      "create_serialized_index_file",
-      [](const uint32_t embedding_dim, const std::string& serialized_config,
-         const std::string userinfo,
-         absl::Span<const uint32_t> partition_assignment,
-         absl::Span<const std::string> metadata, bool compression,
-         absl::optional<absl::Span<const uint8_t>> hashed_database,
-         absl::optional<absl::Span<const float>> float_database)
-          -> absl::StatusOr<bytes> {
-        tflite::scann_ondevice::core::ScannOnDeviceConfig config;
-        config.ParseFromString(serialized_config);
-        const auto status_or_bytes = tflite::scann_ondevice::CreateIndexBuffer(
-            {.config = config,
-             .embedding_dim = embedding_dim,
-             .hashed_database = hashed_database,
-             .float_database = float_database,
-             .partition_assignment = partition_assignment,
-             .metadata = metadata,
-             .userinfo = userinfo},
-            compression);
-        if (!status_or_bytes.ok()) {
-          return status_or_bytes.status();
-        }
-        return bytes(status_or_bytes.value());
-      },
-      arg("embedding_dim"), arg("serialized_config"), arg("userinfo"),
-      arg("partition_assignment"), arg("metadata"), arg("compression") = true,
-      arg("hashed_database") = absl::nullopt,
-      arg("float_database") = absl::nullopt);
-}
-
-}  // namespace pybind11
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/test/index_builder_test.cc b/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/test/index_builder_test.cc
deleted file mode 100644
index 68830a9976e41..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/test/index_builder_test.cc
+++ /dev/null
@@ -1,363 +0,0 @@
-/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#include "tensorflow_lite_support/scann_ondevice/cc/index_builder.h"
-
-#include <cstdint>
-#include <string>
-
-#include "absl/flags/flag.h"           // from @com_google_absl
-#include "absl/memory/memory.h"        // from @com_google_absl
-#include "absl/status/status.h"        // from @com_google_absl
-#include "absl/strings/str_format.h"   // from @com_google_absl
-#include "absl/strings/string_view.h"  // from @com_google_absl
-#include "absl/types/span.h"           // from @com_google_absl
-#include "leveldb/env.h"               // from @com_google_leveldb
-#include "leveldb/iterator.h"          // from @com_google_leveldb
-#include "leveldb/options.h"           // from @com_google_leveldb
-#include "leveldb/slice.h"             // from @com_google_leveldb
-#include "leveldb/status.h"            // from @com_google_leveldb
-#include "leveldb/table.h"             // from @com_google_leveldb
-#include "tensorflow_lite_support/cc/port/gmock.h"
-#include "tensorflow_lite_support/cc/port/gtest.h"
-#include "tensorflow_lite_support/cc/port/status_matchers.h"
-#include "tensorflow_lite_support/cc/test/message_matchers.h"
-#include "tensorflow_lite_support/cc/test/test_utils.h"
-#include "tensorflow_lite_support/scann_ondevice/proto/index_config.pb.h"
-
-namespace tflite {
-namespace scann_ondevice {
-namespace {
-
-using ::testing::Bool;
-using ::testing::ElementsAreArray;
-using ::testing::TestWithParam;
-using ::tflite::support::EqualsProto;
-using ::tflite::task::ParseTextProtoOrDie;
-
-absl::Status SetContents(absl::string_view file_name,
-                         absl::string_view content) {
-  FILE* fp = fopen(file_name.data(), "w");
-  if (fp == NULL) {
-    return absl::InternalError(
-        absl::StrFormat("Can't open file: %s", file_name));
-  }
-
-  fwrite(content.data(), sizeof(char), content.size(), fp);
-  size_t write_error = ferror(fp);
-  if (fclose(fp) != 0 || write_error) {
-    return absl::InternalError(
-        absl::StrFormat("Error while writing file: %s. Error message: %s",
-                        file_name, strerror(write_error)));
-  }
-  return absl::OkStatus();
-}
-
-absl::StatusOr<std::string> LookupKey(leveldb::Iterator* iterator,
-                                      absl::string_view key) {
-  iterator->Seek({key.data(), key.size()});
-  if (!iterator->Valid() || iterator->key().ToString() != key ||
-      !iterator->status().ok()) {
-    return absl::NotFoundError("Failed to lookup key");
-  }
-  return iterator->value().ToString();
-}
-
-constexpr size_t kDimensions = 2;
-constexpr size_t kNumEmbeddings = 24;
-constexpr size_t kNumPartitions = 12;
-
-IndexConfig CreateExpectedConfig(IndexConfig::Type embedding_type) {
-  IndexConfig config = ParseTextProtoOrDie<IndexConfig>(R"pb(
-    scann_config {
-      partitioner {
-        leaf { dimension: 0 dimension: 0 }
-        leaf { dimension: 1 dimension: 1 }
-        leaf { dimension: 2 dimension: 2 }
-        leaf { dimension: 3 dimension: 3 }
-        leaf { dimension: 4 dimension: 4 }
-        leaf { dimension: 5 dimension: 5 }
-        leaf { dimension: 6 dimension: 6 }
-        leaf { dimension: 7 dimension: 7 }
-        leaf { dimension: 8 dimension: 8 }
-        leaf { dimension: 9 dimension: 9 }
-        leaf { dimension: 10 dimension: 10 }
-        leaf { dimension: 11 dimension: 11 }
-      }
-    }
-    embedding_dim: 2
-    embedding_type: UINT8
-    global_partition_offsets: 0
-    global_partition_offsets: 2
-    global_partition_offsets: 4
-    global_partition_offsets: 6
-    global_partition_offsets: 8
-    global_partition_offsets: 10
-    global_partition_offsets: 12
-    global_partition_offsets: 14
-    global_partition_offsets: 16
-    global_partition_offsets: 18
-    global_partition_offsets: 20
-    global_partition_offsets: 22
-  )pb");
-  config.set_embedding_type(embedding_type);
-  return config;
-}
-
-class PopulateIndexFileTest : public TestWithParam<bool /*compression*/> {};
-
-TEST_P(PopulateIndexFileTest, WritesHashedDatabase) {
-  const std::string db_path =
-      tflite::task::JoinPath(getenv("TEST_TMPDIR"), "hashed");
-  const bool compression = GetParam();
-
-  {
-    tflite::scann_ondevice::core::ScannOnDeviceConfig config =
-        ParseTextProtoOrDie<tflite::scann_ondevice::core::ScannOnDeviceConfig>(
-            R"pb(
-              partitioner: {
-                leaf { dimension: 0 dimension: 0 }
-                leaf { dimension: 1 dimension: 1 }
-                leaf { dimension: 2 dimension: 2 }
-                leaf { dimension: 3 dimension: 3 }
-                leaf { dimension: 4 dimension: 4 }
-                leaf { dimension: 5 dimension: 5 }
-                leaf { dimension: 6 dimension: 6 }
-                leaf { dimension: 7 dimension: 7 }
-                leaf { dimension: 8 dimension: 8 }
-                leaf { dimension: 9 dimension: 9 }
-                leaf { dimension: 10 dimension: 10 }
-                leaf { dimension: 11 dimension: 11 }
-              }
-            )pb");
-    std::vector<uint8_t> hashed_database;
-    hashed_database.reserve(kNumEmbeddings * kDimensions);
-    for (int i = 0; i < kNumEmbeddings; ++i) {
-      for (int j = 0; j < kDimensions; ++j) {
-        hashed_database.push_back(i);
-      }
-    }
-    std::vector<uint32_t> partition_assignment;
-    partition_assignment.reserve(kNumEmbeddings);
-    for (int i = 0; i < kNumEmbeddings; ++i) {
-      partition_assignment.push_back(i % kNumPartitions);
-    }
-    std::vector<std::string> metadata;
-    metadata.reserve(kNumEmbeddings);
-    for (int i = 0; i < kNumEmbeddings; ++i) {
-      metadata.push_back(absl::StrFormat("%d", i));
-    }
-    SUPPORT_ASSERT_OK_AND_ASSIGN(
-        const std::string buffer,
-        CreateIndexBuffer(
-            {.config = config,
-             .embedding_dim = kDimensions,
-             .hashed_database = absl::Span<uint8_t>(hashed_database),
-             .partition_assignment = absl::Span<uint32_t>(partition_assignment),
-             .metadata = absl::Span<std::string>(metadata),
-             .userinfo = "hashed_userinfo"},
-            compression));
-    SUPPORT_ASSERT_OK(SetContents(db_path, buffer));
-  }
-
-  auto* env = leveldb::Env::Default();
-  leveldb::RandomAccessFile* hash_file;
-  size_t hash_file_size;
-  ASSERT_TRUE(env->NewRandomAccessFile(db_path, &hash_file).ok());
-  auto hashed_file_unique = absl::WrapUnique(hash_file);
-  ASSERT_TRUE(env->GetFileSize(db_path, &hash_file_size).ok());
-
-  leveldb::Options options;
-  options.compression =
-      compression ? leveldb::kSnappyCompression : leveldb::kNoCompression;
-
-  leveldb::Table* hashed_table;
-  ASSERT_TRUE(
-      leveldb::Table::Open(options, hash_file, hash_file_size, &hashed_table)
-          .ok());
-  auto hashed_table_unique = absl::WrapUnique(hashed_table);
-  auto hashed_table_iterator =
-      absl::WrapUnique(hashed_table->NewIterator(leveldb::ReadOptions()));
-
-  SUPPORT_ASSERT_OK_AND_ASSIGN(
-      std::string serialized_config,
-      LookupKey(hashed_table_iterator.get(), "INDEX_CONFIG"));
-  IndexConfig index_config;
-  EXPECT_TRUE(index_config.ParseFromString(serialized_config));
-  EXPECT_THAT(index_config,
-              EqualsProto(CreateExpectedConfig(IndexConfig::UINT8)));
-
-  SUPPORT_ASSERT_OK_AND_ASSIGN(
-      std::string userinfo,
-      LookupKey(hashed_table_iterator.get(), "USER_INFO"));
-  EXPECT_EQ(userinfo, "hashed_userinfo");
-
-  // Partition assignment is based on i % kNumPartitions, so:
-  // * partition 0 contains embeddings 0 and 12,
-  // * partition 1 contains embeddings 1 and 13,
-  // * etc
-  for (int i = 0; i < kNumPartitions; ++i) {
-    SUPPORT_ASSERT_OK_AND_ASSIGN(
-        std::string raw_partition_hashed,
-        LookupKey(hashed_table_iterator.get(), absl::StrFormat("E_%d", i)));
-    std::vector<char> hashed_partition(raw_partition_hashed.begin(),
-                                       raw_partition_hashed.end());
-    std::vector<char> expected = {static_cast<char>(i), static_cast<char>(i),
-                                  static_cast<char>(i + kNumPartitions),
-                                  static_cast<char>(i + kNumPartitions)};
-    EXPECT_THAT(hashed_partition, ElementsAreArray(expected));
-  }
-
-  // Similarly:
-  // * metadata 0 contains metadata 0,
-  // * metadata 1 contains metadata 12,
-  // * metadata 2 contains metadata 1,
-  // * metadata 3 contains metadata 13,
-  // * etc
-  // Hence the `i / 2 + (i % 2 ? kNumPartitions : 0)` formula here.
-  for (int i = 0; i < kNumEmbeddings; ++i) {
-    SUPPORT_ASSERT_OK_AND_ASSIGN(
-        std::string metadata,
-        LookupKey(hashed_table_iterator.get(), absl::StrFormat("M_%d", i)));
-    EXPECT_EQ(metadata,
-              absl::StrFormat("%d", i / 2 + (i % 2 ? kNumPartitions : 0)));
-  }
-}
-
-TEST_P(PopulateIndexFileTest, WritesFloatDatabase) {
-  const std::string db_path =
-      tflite::task::JoinPath(getenv("TEST_TMPDIR"), "float");
-  const bool compression = GetParam();
-
-  {
-    tflite::scann_ondevice::core::ScannOnDeviceConfig config =
-        ParseTextProtoOrDie<tflite::scann_ondevice::core::ScannOnDeviceConfig>(
-            R"pb(
-              partitioner: {
-                leaf { dimension: 0 dimension: 0 }
-                leaf { dimension: 1 dimension: 1 }
-                leaf { dimension: 2 dimension: 2 }
-                leaf { dimension: 3 dimension: 3 }
-                leaf { dimension: 4 dimension: 4 }
-                leaf { dimension: 5 dimension: 5 }
-                leaf { dimension: 6 dimension: 6 }
-                leaf { dimension: 7 dimension: 7 }
-                leaf { dimension: 8 dimension: 8 }
-                leaf { dimension: 9 dimension: 9 }
-                leaf { dimension: 10 dimension: 10 }
-                leaf { dimension: 11 dimension: 11 }
-              }
-            )pb");
-    std::vector<float> float_database;
-    float_database.reserve(kNumEmbeddings * kDimensions);
-    for (int i = 0; i < kNumEmbeddings; ++i) {
-      for (int j = 0; j < kDimensions; ++j) {
-        float_database.push_back(i);
-      }
-    }
-    std::vector<uint32_t> partition_assignment;
-    partition_assignment.reserve(kNumEmbeddings);
-    for (int i = 0; i < kNumEmbeddings; ++i) {
-      partition_assignment.push_back(i % kNumPartitions);
-    }
-    std::vector<std::string> metadata;
-    metadata.reserve(kNumEmbeddings);
-    for (int i = 0; i < kNumEmbeddings; ++i) {
-      metadata.push_back(absl::StrFormat("%d", i));
-    }
-    SUPPORT_ASSERT_OK_AND_ASSIGN(
-        const std::string buffer,
-        CreateIndexBuffer(
-            {.config = config,
-             .embedding_dim = kDimensions,
-             .float_database = absl::Span<float>(float_database),
-             .partition_assignment = absl::Span<uint32_t>(partition_assignment),
-             .metadata = absl::Span<std::string>(metadata),
-             .userinfo = "float_userinfo"},
-            compression));
-    SUPPORT_ASSERT_OK(SetContents(db_path, buffer));
-  }
-
-  auto* env = leveldb::Env::Default();
-  leveldb::RandomAccessFile* float_file;
-  size_t float_file_size;
-  ASSERT_TRUE(env->NewRandomAccessFile(db_path, &float_file).ok());
-  auto float_file_unique = absl::WrapUnique(float_file);
-  ASSERT_TRUE(env->GetFileSize(db_path, &float_file_size).ok());
-
-  leveldb::Options options;
-  options.compression =
-      compression ? leveldb::kSnappyCompression : leveldb::kNoCompression;
-
-  leveldb::Table* float_table;
-  ASSERT_TRUE(
-      leveldb::Table::Open(options, float_file, float_file_size, &float_table)
-          .ok());
-  auto float_table_unique = absl::WrapUnique(float_table);
-  auto float_table_iterator =
-      absl::WrapUnique(float_table->NewIterator(leveldb::ReadOptions()));
-
-  SUPPORT_ASSERT_OK_AND_ASSIGN(
-      std::string serialized_config,
-      LookupKey(float_table_iterator.get(), "INDEX_CONFIG"));
-  IndexConfig index_config;
-  EXPECT_TRUE(index_config.ParseFromString(serialized_config));
-  EXPECT_THAT(index_config,
-              EqualsProto(CreateExpectedConfig(IndexConfig::FLOAT)));
-
-  SUPPORT_ASSERT_OK_AND_ASSIGN(
-      std::string userinfo, LookupKey(float_table_iterator.get(), "USER_INFO"));
-  EXPECT_EQ(userinfo, "float_userinfo");
-
-  // Partition assignment is based on i % kNumPartitions, so:
-  // * partition 0 contains embeddings 0 and 12,
-  // * partition 1 contains embeddings 1 and 13,
-  // * etc
-  for (int i = 0; i < kNumPartitions; ++i) {
-    SUPPORT_ASSERT_OK_AND_ASSIGN(
-        std::string raw_partition_float,
-        LookupKey(float_table_iterator.get(), absl::StrFormat("E_%d", i)));
-    const float* raw_partition_float_ptr =
-        reinterpret_cast<const float*>(raw_partition_float.data());
-    std::vector<float> float_partition(
-        raw_partition_float_ptr,
-        raw_partition_float_ptr + raw_partition_float.size() / sizeof(float));
-    std::vector<float> expected = {static_cast<float>(i), static_cast<float>(i),
-                                   static_cast<float>(i + kNumPartitions),
-                                   static_cast<float>(i + kNumPartitions)};
-    EXPECT_THAT(float_partition, ElementsAreArray(expected));
-  }
-
-  // Similarly:
-  // * metadata 0 contains metadata 0,
-  // * metadata 1 contains metadata 12,
-  // * metadata 2 contains metadata 1,
-  // * metadata 3 contains metadata 13,
-  // * etc
-  // Hence the `i / 2 + (i % 2 ? kNumPartitions : 0)` formula here.
-  for (int i = 0; i < kNumEmbeddings; ++i) {
-    SUPPORT_ASSERT_OK_AND_ASSIGN(
-        std::string metadata,
-        LookupKey(float_table_iterator.get(), absl::StrFormat("M_%d", i)));
-    EXPECT_EQ(metadata,
-              absl::StrFormat("%d", i / 2 + (i % 2 ? kNumPartitions : 0)));
-  }
-}
-
-INSTANTIATE_TEST_SUITE_P(PopulateIndexFileTest, PopulateIndexFileTest, Bool());
-
-}  // namespace
-}  // namespace scann_ondevice
-}  // namespace tflite
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/test/mem_random_access_file_test.cc b/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/test/mem_random_access_file_test.cc
deleted file mode 100644
index 2d1efb10e2b6c..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/test/mem_random_access_file_test.cc
+++ /dev/null
@@ -1,64 +0,0 @@
-/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#include "tensorflow_lite_support/scann_ondevice/cc/mem_random_access_file.h"
-
-#include "leveldb/slice.h"  // from @com_google_leveldb
-#include "tensorflow/lite/core/shims/cc/shims_test_util.h"
-#include "tensorflow_lite_support/cc/port/gmock.h"
-#include "tensorflow_lite_support/cc/port/gtest.h"
-
-namespace tflite {
-namespace scann_ondevice {
-namespace {
-
-constexpr char kBufferData[] = "abcdef";
-constexpr size_t kBufferSize = 6;
-
-class MemRandomAccessFileTest : public tflite_shims::testing::Test {
- public:
-  MemRandomAccessFileTest() : file_(kBufferData, kBufferSize) {}
-
- protected:
-  MemRandomAccessFile file_;
-  leveldb::Slice result_;
-};
-
-TEST_F(MemRandomAccessFileTest, ReadFailsWithOutOfBoundsOffset) {
-  EXPECT_TRUE(file_.Read(/*offset=*/7, /*n=*/1, &result_, /*scratch=*/nullptr)
-                  .IsInvalidArgument());
-}
-
-TEST_F(MemRandomAccessFileTest, ReadSucceedsWithoutTruncation) {
-  EXPECT_TRUE(
-      file_.Read(/*offset=*/1, /*n=*/5, &result_, /*scratch=*/nullptr).ok());
-  EXPECT_EQ("bcdef", result_.ToString());
-}
-
-TEST_F(MemRandomAccessFileTest, ReadSucceedsWithTruncation) {
-  EXPECT_TRUE(
-      file_.Read(/*offset=*/1, /*n=*/6, &result_, /*scratch=*/nullptr).ok());
-  EXPECT_EQ("bcdef", result_.ToString());
-}
-
-TEST_F(MemRandomAccessFileTest, ReadSucceedsWithZeroLength) {
-  EXPECT_TRUE(
-      file_.Read(/*offset=*/1, /*n=*/0, &result_, /*scratch=*/nullptr).ok());
-  EXPECT_EQ("", result_.ToString());
-}
-
-}  // namespace
-}  // namespace scann_ondevice
-}  // namespace tflite
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/test/python/leveldb_testing_utils_py_wrapper.cc b/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/test/python/leveldb_testing_utils_py_wrapper.cc
deleted file mode 100644
index 1b6906bf49bc2..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/scann_ondevice/cc/test/python/leveldb_testing_utils_py_wrapper.cc
+++ /dev/null
@@ -1,76 +0,0 @@
-/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#include <vector>
-
-#include "absl/memory/memory.h"       // from @com_google_absl
-#include "absl/status/status.h"       // from @com_google_absl
-#include "absl/status/statusor.h"     // from @com_google_absl
-#include "absl/strings/str_format.h"  // from @com_google_absl
-#include "leveldb/env.h"              // from @com_google_leveldb
-#include "leveldb/options.h"          // from @com_google_leveldb
-#include "leveldb/table.h"            // from @com_google_leveldb
-#include "pybind11/cast.h"
-#include "pybind11/pybind11.h"
-#include "pybind11/pytypes.h"
-#include "pybind11_abseil/absl_casters.h"    // from @pybind11_abseil
-#include "pybind11_abseil/status_casters.h"  // from @pybind11_abseil
-
-namespace pybind11 {
-
-PYBIND11_MODULE(leveldb_testing_utils, m) {
-  google::ImportStatusModule();
-
-  m.def(
-      "leveldb_table_to_pair_list",
-      [](const std::string fname, bool compressed)
-          -> absl::StatusOr<std::vector<std::pair<bytes, bytes>>> {
-        auto* env = leveldb::Env::Default();
-        leveldb::RandomAccessFile* file;
-        if (!env->NewRandomAccessFile(fname, &file).ok()) {
-          return absl::InternalError(absl::StrFormat(
-              "Failed to create RandomAccessFile at %s", fname));
-        }
-        auto unique_file = absl::WrapUnique(file);
-        size_t file_size;
-        if (!env->GetFileSize(fname, &file_size).ok()) {
-          return absl::InternalError(
-              absl::StrFormat("Failed to get file size at %s", fname));
-        }
-        leveldb::Options options;
-        options.compression =
-            compressed ? leveldb::kSnappyCompression : leveldb::kNoCompression;
-
-        leveldb::Table* table;
-        if (!leveldb::Table::Open(options, file, file_size, &table).ok()) {
-          return absl::InternalError("Failed to open table");
-        }
-        auto unique_table = absl::WrapUnique(table);
-        auto table_iterator =
-            absl::WrapUnique(table->NewIterator(leveldb::ReadOptions()));
-        table_iterator->SeekToFirst();
-
-        std::vector<std::pair<bytes, bytes>> result;
-        for (; table_iterator->Valid(); table_iterator->Next()) {
-          result.push_back(
-              std::make_pair(bytes(table_iterator->key().ToString()),
-                             bytes(table_iterator->value().ToString())));
-        }
-        return result;
-      },
-      arg("buffer"), arg("compressed"));
-}
-
-}  // namespace pybind11
diff --git a/third_party/tflite_support/src/tensorflow_lite_support/tools/ci_build/common_win.bat b/third_party/tflite_support/src/tensorflow_lite_support/tools/ci_build/common_win.bat
deleted file mode 100644
index 324a1953de706..0000000000000
--- a/third_party/tflite_support/src/tensorflow_lite_support/tools/ci_build/common_win.bat
+++ /dev/null
@@ -1,29 +0,0 @@
-:: Copyright 2019 The TensorFlow Authors. All Rights Reserved.
-::
-:: Licensed under the Apache License, Version 2.0 (the "License");
-:: you may not use this file except in compliance with the License.
-:: You may obtain a copy of the License at
-::
-::     http://www.apache.org/licenses/LICENSE-2.0
-::
-:: Unless required by applicable law or agreed to in writing, software
-:: distributed under the License is distributed on an "AS IS" BASIS,
-:: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-:: See the License for the specific language governing permissions and
-:: limitations under the License.
-:: =============================================================================
-
-:: This script is shamefully borrowed from:
-:: //third_party/tensorflow/tools/ci_build/release/common_win.bat.oss
-
-echo on
-
-@REM
-@REM Setup Bazel
-@REM
-:: Download Bazel from github and make sure its found in PATH.
-SET BAZEL_VERSION=4.2.2
-md C:\tools\bazel\
-wget -q https://github.com/bazelbuild/bazel/releases/download/%BAZEL_VERSION%/bazel-%BAZEL_VERSION%-windows-x86_64.exe -O C:/tools/bazel/bazel.exe
-SET PATH=C:\tools\bazel;%PATH%
-bazel version
-- 
2.35.1.1178.g4f1659d476-goog

