// AUTOGENERATED - DO NOT EDIT
// ---------------------------
// This file has been generated by
// AOSP://external/perfetto/tools/gen_merged_protos
// merging the perfetto config protos.
// This fused proto is intended to be copied in:
//  - Android tree, for statsd.
//  - Google internal repos.

syntax = "proto2";

package perfetto.protos;

// Begin of protos/perfetto/common/android_log_constants.proto

// Values from NDK's android/log.h.
enum AndroidLogId {
  LID_DEFAULT = 0;  // MAIN.
  LID_RADIO = 1;
  LID_EVENTS = 2;
  LID_SYSTEM = 3;
  LID_CRASH = 4;
  LID_STATS = 5;
  LID_SECURITY = 6;
  LID_KERNEL = 7;
}

enum AndroidLogPriority {
  PRIO_UNSPECIFIED = 0;
  PRIO_UNUSED = 1;  // _DEFAULT, but should never be seen in logs.
  PRIO_VERBOSE = 2;
  PRIO_DEBUG = 3;
  PRIO_INFO = 4;
  PRIO_WARN = 5;
  PRIO_ERROR = 6;
  PRIO_FATAL = 7;
}

// End of protos/perfetto/common/android_log_constants.proto

// Begin of protos/perfetto/common/sys_stats_counters.proto

// When editing entries here remember also to update "sys_stats_counters.h" with
// the corresponding string definitions for the actual /proc files parser.

// Counter definitions for Linux's /proc/meminfo.
enum MeminfoCounters {
  MEMINFO_UNSPECIFIED = 0;
  MEMINFO_MEM_TOTAL = 1;
  MEMINFO_MEM_FREE = 2;
  MEMINFO_MEM_AVAILABLE = 3;
  MEMINFO_BUFFERS = 4;
  MEMINFO_CACHED = 5;
  MEMINFO_SWAP_CACHED = 6;
  MEMINFO_ACTIVE = 7;
  MEMINFO_INACTIVE = 8;
  MEMINFO_ACTIVE_ANON = 9;
  MEMINFO_INACTIVE_ANON = 10;
  MEMINFO_ACTIVE_FILE = 11;
  MEMINFO_INACTIVE_FILE = 12;
  MEMINFO_UNEVICTABLE = 13;
  MEMINFO_MLOCKED = 14;
  MEMINFO_SWAP_TOTAL = 15;
  MEMINFO_SWAP_FREE = 16;
  MEMINFO_DIRTY = 17;
  MEMINFO_WRITEBACK = 18;
  MEMINFO_ANON_PAGES = 19;
  MEMINFO_MAPPED = 20;
  MEMINFO_SHMEM = 21;
  MEMINFO_SLAB = 22;
  MEMINFO_SLAB_RECLAIMABLE = 23;
  MEMINFO_SLAB_UNRECLAIMABLE = 24;
  MEMINFO_KERNEL_STACK = 25;
  MEMINFO_PAGE_TABLES = 26;
  MEMINFO_COMMIT_LIMIT = 27;
  MEMINFO_COMMITED_AS = 28;
  MEMINFO_VMALLOC_TOTAL = 29;
  MEMINFO_VMALLOC_USED = 30;
  MEMINFO_VMALLOC_CHUNK = 31;
  MEMINFO_CMA_TOTAL = 32;
  MEMINFO_CMA_FREE = 33;
}

// Counter definitions for Linux's /proc/vmstat.
enum VmstatCounters {
  VMSTAT_UNSPECIFIED = 0;
  VMSTAT_NR_FREE_PAGES = 1;
  VMSTAT_NR_ALLOC_BATCH = 2;
  VMSTAT_NR_INACTIVE_ANON = 3;
  VMSTAT_NR_ACTIVE_ANON = 4;
  VMSTAT_NR_INACTIVE_FILE = 5;
  VMSTAT_NR_ACTIVE_FILE = 6;
  VMSTAT_NR_UNEVICTABLE = 7;
  VMSTAT_NR_MLOCK = 8;
  VMSTAT_NR_ANON_PAGES = 9;
  VMSTAT_NR_MAPPED = 10;
  VMSTAT_NR_FILE_PAGES = 11;
  VMSTAT_NR_DIRTY = 12;
  VMSTAT_NR_WRITEBACK = 13;
  VMSTAT_NR_SLAB_RECLAIMABLE = 14;
  VMSTAT_NR_SLAB_UNRECLAIMABLE = 15;
  VMSTAT_NR_PAGE_TABLE_PAGES = 16;
  VMSTAT_NR_KERNEL_STACK = 17;
  VMSTAT_NR_OVERHEAD = 18;
  VMSTAT_NR_UNSTABLE = 19;
  VMSTAT_NR_BOUNCE = 20;
  VMSTAT_NR_VMSCAN_WRITE = 21;
  VMSTAT_NR_VMSCAN_IMMEDIATE_RECLAIM = 22;
  VMSTAT_NR_WRITEBACK_TEMP = 23;
  VMSTAT_NR_ISOLATED_ANON = 24;
  VMSTAT_NR_ISOLATED_FILE = 25;
  VMSTAT_NR_SHMEM = 26;
  VMSTAT_NR_DIRTIED = 27;
  VMSTAT_NR_WRITTEN = 28;
  VMSTAT_NR_PAGES_SCANNED = 29;
  VMSTAT_WORKINGSET_REFAULT = 30;
  VMSTAT_WORKINGSET_ACTIVATE = 31;
  VMSTAT_WORKINGSET_NODERECLAIM = 32;
  VMSTAT_NR_ANON_TRANSPARENT_HUGEPAGES = 33;
  VMSTAT_NR_FREE_CMA = 34;
  VMSTAT_NR_SWAPCACHE = 35;
  VMSTAT_NR_DIRTY_THRESHOLD = 36;
  VMSTAT_NR_DIRTY_BACKGROUND_THRESHOLD = 37;
  VMSTAT_PGPGIN = 38;
  VMSTAT_PGPGOUT = 39;
  VMSTAT_PGPGOUTCLEAN = 40;
  VMSTAT_PSWPIN = 41;
  VMSTAT_PSWPOUT = 42;
  VMSTAT_PGALLOC_DMA = 43;
  VMSTAT_PGALLOC_NORMAL = 44;
  VMSTAT_PGALLOC_MOVABLE = 45;
  VMSTAT_PGFREE = 46;
  VMSTAT_PGACTIVATE = 47;
  VMSTAT_PGDEACTIVATE = 48;
  VMSTAT_PGFAULT = 49;
  VMSTAT_PGMAJFAULT = 50;
  VMSTAT_PGREFILL_DMA = 51;
  VMSTAT_PGREFILL_NORMAL = 52;
  VMSTAT_PGREFILL_MOVABLE = 53;
  VMSTAT_PGSTEAL_KSWAPD_DMA = 54;
  VMSTAT_PGSTEAL_KSWAPD_NORMAL = 55;
  VMSTAT_PGSTEAL_KSWAPD_MOVABLE = 56;
  VMSTAT_PGSTEAL_DIRECT_DMA = 57;
  VMSTAT_PGSTEAL_DIRECT_NORMAL = 58;
  VMSTAT_PGSTEAL_DIRECT_MOVABLE = 59;
  VMSTAT_PGSCAN_KSWAPD_DMA = 60;
  VMSTAT_PGSCAN_KSWAPD_NORMAL = 61;
  VMSTAT_PGSCAN_KSWAPD_MOVABLE = 62;
  VMSTAT_PGSCAN_DIRECT_DMA = 63;
  VMSTAT_PGSCAN_DIRECT_NORMAL = 64;
  VMSTAT_PGSCAN_DIRECT_MOVABLE = 65;
  VMSTAT_PGSCAN_DIRECT_THROTTLE = 66;
  VMSTAT_PGINODESTEAL = 67;
  VMSTAT_SLABS_SCANNED = 68;
  VMSTAT_KSWAPD_INODESTEAL = 69;
  VMSTAT_KSWAPD_LOW_WMARK_HIT_QUICKLY = 70;
  VMSTAT_KSWAPD_HIGH_WMARK_HIT_QUICKLY = 71;
  VMSTAT_PAGEOUTRUN = 72;
  VMSTAT_ALLOCSTALL = 73;
  VMSTAT_PGROTATED = 74;
  VMSTAT_DROP_PAGECACHE = 75;
  VMSTAT_DROP_SLAB = 76;
  VMSTAT_PGMIGRATE_SUCCESS = 77;
  VMSTAT_PGMIGRATE_FAIL = 78;
  VMSTAT_COMPACT_MIGRATE_SCANNED = 79;
  VMSTAT_COMPACT_FREE_SCANNED = 80;
  VMSTAT_COMPACT_ISOLATED = 81;
  VMSTAT_COMPACT_STALL = 82;
  VMSTAT_COMPACT_FAIL = 83;
  VMSTAT_COMPACT_SUCCESS = 84;
  VMSTAT_COMPACT_DAEMON_WAKE = 85;
  VMSTAT_UNEVICTABLE_PGS_CULLED = 86;
  VMSTAT_UNEVICTABLE_PGS_SCANNED = 87;
  VMSTAT_UNEVICTABLE_PGS_RESCUED = 88;
  VMSTAT_UNEVICTABLE_PGS_MLOCKED = 89;
  VMSTAT_UNEVICTABLE_PGS_MUNLOCKED = 90;
  VMSTAT_UNEVICTABLE_PGS_CLEARED = 91;
  VMSTAT_UNEVICTABLE_PGS_STRANDED = 92;
}
// End of protos/perfetto/common/sys_stats_counters.proto

// Begin of protos/perfetto/common/trace_stats.proto

// Statistics for the internals of the tracing service.
//
// Next id: 10.
message TraceStats {
  // From TraceBuffer::Stats.
  //
  // Next id: 19.
  message BufferStats {
    // Size of the circular buffer in bytes.
    optional uint64 buffer_size = 12;

    // Num. bytes written into the circular buffer, including chunk headers.
    optional uint64 bytes_written = 1;

    // Num. bytes overwritten before they have been read (i.e. loss of data).
    optional uint64 bytes_overwritten = 13;

    // Total size of chunks that were fully read from the circular buffer by the
    // consumer. This may not be equal to |bytes_written| either in the middle
    // of tracing, or if |chunks_overwritten| is non-zero. Note that this is the
    // size of the chunks read from the buffer, including chunk headers, which
    // will be different from the total size of packets returned to the
    // consumer.
    //
    // The current utilization of the trace buffer (mid-tracing) can be obtained
    // by subtracting |bytes_read| and |bytes_overwritten| from |bytes_written|,
    // adding the difference of |padding_bytes_written| and
    // |padding_bytes_cleared|, and comparing this sum to the |buffer_size|.
    // Note that this represents the total size of buffered data in the buffer,
    // yet this data may be spread non-contiguously through the buffer and may
    // be overridden before the utilization reaches 100%.
    optional uint64 bytes_read = 14;

    // Num. bytes that were allocated as padding between chunks in the circular
    // buffer.
    optional uint64 padding_bytes_written = 15;

    // Num. of padding bytes that were removed from the circular buffer when
    // they were overwritten.
    //
    // The difference between |padding_bytes_written| and
    // |padding_bytes_cleared| denotes the total size of padding currently
    // present in the buffer.
    optional uint64 padding_bytes_cleared = 16;

    // Num. chunks (!= packets) written into the buffer.
    optional uint64 chunks_written = 2;

    // Num. chunks (!= packets) rewritten into the buffer. This means we rewrote
    // the same chunk with additional packets appended to the end.
    optional uint64 chunks_rewritten = 10;

    // Num. chunks overwritten before they have been read (i.e. loss of data).
    optional uint64 chunks_overwritten = 3;

    // Num. chunks discarded (i.e. loss of data). Can be > 0 only when a buffer
    // is configured with FillPolicy == DISCARD.
    optional uint64 chunks_discarded = 18;

    // Num. chunks (!= packets) that were fully read from the circular buffer by
    // the consumer. This may not be equal to |chunks_written| either in the
    // middle of tracing, or if |chunks_overwritten| is non-zero.
    optional uint64 chunks_read = 17;

    // Num. chunks that were committed out of order.
    optional uint64 chunks_committed_out_of_order = 11;

    // Num. times the ring buffer wrapped around.
    optional uint64 write_wrap_count = 4;

    // Num. out-of-band (OOB) patches that succeeded.
    optional uint64 patches_succeeded = 5;

    // Num. OOB patches that failed (e.g., the chunk to patch was gone).
    optional uint64 patches_failed = 6;

    // Num. readaheads (for large multi-chunk packet reads) that ended up in a
    // successful packet read.
    optional uint64 readaheads_succeeded = 7;

    // Num. readaheads aborted because of missing chunks in the sequence stream.
    // Note that a small number > 0 is totally expected: occasionally, when
    // issuing a read, the very last packet in a sequence might be incomplete
    // (because the producer is still writing it while we read). The read will
    // stop at that point, for that sequence, increasing this counter.
    optional uint64 readaheads_failed = 8;

    // Num. of violations of the SharedMemoryABI found while writing or reading
    // the buffer. This is an indication of either a bug in the producer(s) or
    // malicious producer(s).
    optional uint64 abi_violations = 9;
  }

  // Stats for the TraceBuffer(s) of the current trace session.
  repeated BufferStats buffer_stats = 1;

  // Num. producers connected (whether they are involved in the current tracing
  // session or not).
  optional uint32 producers_connected = 2;

  // Num. producers ever seen for all trace sessions since startup (it's a good
  // proxy for inferring num. producers crashed / killed).
  optional uint64 producers_seen = 3;

  // Num. data sources registered for all trace sessions.
  optional uint32 data_sources_registered = 4;

  // Num. data sources ever seen for all trace sessions since startup.
  optional uint64 data_sources_seen = 5;

  // Num. concurrently active tracing sessions.
  optional uint32 tracing_sessions = 6;

  // Num. buffers for all tracing session (not just the current one). This will
  // be >= buffer_stats.size(), because the latter is only about the current
  // session.
  optional uint32 total_buffers = 7;

  // The fields below have been introduced in Android Q.

  // Num. chunks that were discarded by the service before attempting to commit
  // them to a buffer, e.g. because the producer specified an invalid buffer ID.
  optional uint64 chunks_discarded = 8;

  // Num. patches that were discarded by the service before attempting to apply
  // them to a buffer, e.g. because the producer specified an invalid buffer ID.
  optional uint64 patches_discarded = 9;
}

// End of protos/perfetto/common/trace_stats.proto

// Begin of protos/perfetto/trace/android/android_log.proto

message AndroidLogPacket {
  message LogEvent {
    // The log buffer (e.g. MAIN, SYSTEM, RADIO) the event comes from.
    optional AndroidLogId log_id = 1;

    // PID (TGID), TID and UID of the task that emitted the event.
    optional int32 pid = 2;
    optional int32 tid = 3;
    optional int32 uid = 4;

    // Timestamp [ns]. The clock source is CLOCK_REALTIME, unlike many other
    // Perfetto trace events that instead use CLOCK_BOOTTIME. The trace
    // processor will take care of realigning clocks using the ClockSnapshot(s).
    optional uint64 timestamp = 5;

    // When log_id == LID_EVENTS, |tag| corresponds to the event name defined in
    // the second column of /system/etc/event-log-tags. For all other events,
    // |tag| is the app-specified argument passed to __android_log_write().
    optional string tag = 6;

    // Empty when log_id == LID_EVENTS.
    optional AndroidLogPriority prio = 7;

    // Empty when log_id == LID_EVENTS.
    optional string message = 8;

    message Arg {
      optional string name = 1;
      oneof value {
        int64 int_value = 2;
        float float_value = 3;
        string string_value = 4;
      }
    }
    // Only populated when log_id == LID_EVENTS.
    repeated Arg args = 9;
  }

  repeated LogEvent events = 1;

  // Stats are emitted only upon Flush() and are monotonic (i.e. they are
  // absolute counters since the beginning of the lifetime of the tracing
  // session and NOT relative to the previous Stats snapshot).
  message Stats {
    // Total number of log events seen, including errors and skipped entries
    // (num of events stored in the trace = total - failed - skipped).
    optional uint64 num_total = 1;

    // Parser failures.
    optional uint64 num_failed = 2;

    // Messages skipped due to filters.
    optional uint64 num_skipped = 3;
  }
  optional Stats stats = 2;
}

// End of protos/perfetto/trace/android/android_log.proto

// Begin of protos/perfetto/trace/android/packages_list.proto

message PackagesList {
  message PackageInfo {
    optional string name = 1;
    optional uint64 uid = 2;
    optional bool debuggable = 3;
    optional bool profileable_from_shell = 4;
    optional int64 version_code = 5;
  }

  repeated PackageInfo packages = 1;

  // At least one error occurred parsing the packages.list.
  optional bool parse_error = 2;

  // Failed to open / read packages.list.
  optional bool read_error = 3;
}

// End of protos/perfetto/trace/android/packages_list.proto

// Begin of protos/perfetto/trace/chrome/chrome_benchmark_metadata.proto

// This message is not intended to be written by the chrome on the device.
// It's emitted on the host by the telemetry benchmark infrastructure (it's a
// part of the trace that's written by the telemetry tracing agent).
message ChromeBenchmarkMetadata {
  // Time when the benchmark execution started (host unixtime in microseconds).
  optional int64 benchmark_start_time_us = 1;

  // Time when this particular story was run (host unixtime in microseconds).
  optional int64 story_run_time_us = 2;

  // Name of benchmark.
  optional string benchmark_name = 3;

  // Description of benchmark.
  optional string benchmark_description = 4;

  // Optional label.
  optional string label = 5;

  // Name of story.
  optional string story_name = 6;

  // List of story tags.
  repeated string story_tags = 7;

  // Index of the story run (>0 if the same story was run several times).
  optional int32 story_run_index = 8;

  // Whether this run failed.
  optional bool had_failures = 9;
}

// End of protos/perfetto/trace/chrome/chrome_benchmark_metadata.proto

// Begin of protos/perfetto/trace/clock_snapshot.proto

// A snapshot of clock readings to allow for trace alignment.
message ClockSnapshot {
  message Clock {
    enum Type {
      UNKNOWN = 0;
      REALTIME = 1;
      REALTIME_COARSE = 2;
      MONOTONIC = 3;
      MONOTONIC_COARSE = 4;
      MONOTONIC_RAW = 5;
      BOOTTIME = 6;
      PROCESS_CPUTIME = 7;
      THREAD_CPUTIME = 8;
    }
    optional Type type = 1;
    optional uint64 timestamp = 2;
  }
  repeated Clock clocks = 1;
}

// End of protos/perfetto/trace/clock_snapshot.proto

// Begin of protos/perfetto/trace/filesystem/inode_file_map.proto

// Represents the mapping between inode numbers in a block device and their path
// on the filesystem
message InodeFileMap {
  // Representation of Entry
  message Entry {
    optional uint64 inode_number = 1;

    // The path to the file, e.g. "etc/file.xml"
    // List of strings for multiple hardlinks
    repeated string paths = 2;

    // The file type
    enum Type {
      UNKNOWN = 0;
      FILE = 1;
      DIRECTORY = 2;
    }
    optional Type type = 3;
  }

  optional uint64 block_device_id = 1;

  // The mount points of the block device, e.g. ["system"].
  repeated string mount_points = 2;

  // The list of all the entries from the block device
  repeated Entry entries = 3;
}

// End of protos/perfetto/trace/filesystem/inode_file_map.proto

// Begin of protos/perfetto/trace/ftrace/binder.proto

message BinderTransactionFtraceEvent {
  optional int32 debug_id = 1;
  optional int32 target_node = 2;
  optional int32 to_proc = 3;
  optional int32 to_thread = 4;
  optional int32 reply = 5;
  optional uint32 code = 6;
  optional uint32 flags = 7;
}
message BinderTransactionReceivedFtraceEvent {
  optional int32 debug_id = 1;
}
message BinderSetPriorityFtraceEvent {
  optional int32 proc = 1;
  optional int32 thread = 2;
  optional uint32 old_prio = 3;
  optional uint32 new_prio = 4;
  optional uint32 desired_prio = 5;
}
message BinderLockFtraceEvent {
  optional string tag = 1;
}
message BinderLockedFtraceEvent {
  optional string tag = 1;
}
message BinderUnlockFtraceEvent {
  optional string tag = 1;
}
message BinderTransactionAllocBufFtraceEvent {
  optional uint64 data_size = 1;
  optional int32 debug_id = 2;
  optional uint64 offsets_size = 3;
}

// End of protos/perfetto/trace/ftrace/binder.proto

// Begin of protos/perfetto/trace/ftrace/block.proto

message BlockRqIssueFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional uint32 bytes = 4;
  optional string rwbs = 5;
  optional string comm = 6;
  optional string cmd = 7;
}
message BlockBioBackmergeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional string rwbs = 4;
  optional string comm = 5;
}
message BlockBioBounceFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional string rwbs = 4;
  optional string comm = 5;
}
message BlockBioCompleteFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional int32 error = 4;
  optional string rwbs = 5;
}
message BlockBioFrontmergeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional string rwbs = 4;
  optional string comm = 5;
}
message BlockBioQueueFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional string rwbs = 4;
  optional string comm = 5;
}
message BlockBioRemapFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional uint64 old_dev = 4;
  optional uint64 old_sector = 5;
  optional string rwbs = 6;
}
message BlockDirtyBufferFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint64 size = 3;
}
message BlockGetrqFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional string rwbs = 4;
  optional string comm = 5;
}
message BlockPlugFtraceEvent {
  optional string comm = 1;
}
message BlockRqAbortFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional int32 errors = 4;
  optional string rwbs = 5;
  optional string cmd = 6;
}
message BlockRqCompleteFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional int32 errors = 4;
  optional string rwbs = 5;
  optional string cmd = 6;
}
message BlockRqInsertFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional uint32 bytes = 4;
  optional string rwbs = 5;
  optional string comm = 6;
  optional string cmd = 7;
}
message BlockRqRemapFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional uint64 old_dev = 4;
  optional uint64 old_sector = 5;
  optional uint32 nr_bios = 6;
  optional string rwbs = 7;
}
message BlockRqRequeueFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional int32 errors = 4;
  optional string rwbs = 5;
  optional string cmd = 6;
}
message BlockSleeprqFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional string rwbs = 4;
  optional string comm = 5;
}
message BlockSplitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint64 new_sector = 3;
  optional string rwbs = 4;
  optional string comm = 5;
}
message BlockTouchBufferFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint64 size = 3;
}
message BlockUnplugFtraceEvent {
  optional int32 nr_rq = 1;
  optional string comm = 2;
}

// End of protos/perfetto/trace/ftrace/block.proto

// Begin of protos/perfetto/trace/ftrace/clk.proto

message ClkEnableFtraceEvent {
  optional string name = 1;
}
message ClkDisableFtraceEvent {
  optional string name = 1;
}
message ClkSetRateFtraceEvent {
  optional string name = 1;
  optional uint64 rate = 2;
}

// End of protos/perfetto/trace/ftrace/clk.proto

// Begin of protos/perfetto/trace/ftrace/ext4.proto

message Ext4DaWriteBeginFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint32 len = 4;
  optional uint32 flags = 5;
}
message Ext4DaWriteEndFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint32 len = 4;
  optional uint32 copied = 5;
}
message Ext4SyncFileEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 parent = 3;
  optional int32 datasync = 4;
}
message Ext4SyncFileExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 ret = 3;
}
message Ext4AllocDaBlocksFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 data_blocks = 3;
  optional uint32 meta_blocks = 4;
}
message Ext4AllocateBlocksFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 block = 3;
  optional uint32 len = 4;
  optional uint32 logical = 5;
  optional uint32 lleft = 6;
  optional uint32 lright = 7;
  optional uint64 goal = 8;
  optional uint64 pleft = 9;
  optional uint64 pright = 10;
  optional uint32 flags = 11;
}
message Ext4AllocateInodeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 dir = 3;
  optional uint32 mode = 4;
}
message Ext4BeginOrderedTruncateFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 new_size = 3;
}
message Ext4CollapseRangeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 offset = 3;
  optional int64 len = 4;
}
message Ext4DaReleaseSpaceFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 i_blocks = 3;
  optional int32 freed_blocks = 4;
  optional int32 reserved_data_blocks = 5;
  optional int32 reserved_meta_blocks = 6;
  optional int32 allocated_meta_blocks = 7;
  optional uint32 mode = 8;
}
message Ext4DaReserveSpaceFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 i_blocks = 3;
  optional int32 reserved_data_blocks = 4;
  optional int32 reserved_meta_blocks = 5;
  optional uint32 mode = 6;
  optional int32 md_needed = 7;
}
message Ext4DaUpdateReserveSpaceFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 i_blocks = 3;
  optional int32 used_blocks = 4;
  optional int32 reserved_data_blocks = 5;
  optional int32 reserved_meta_blocks = 6;
  optional int32 allocated_meta_blocks = 7;
  optional int32 quota_claim = 8;
  optional uint32 mode = 9;
}
message Ext4DaWritePagesFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 first_page = 3;
  optional int64 nr_to_write = 4;
  optional int32 sync_mode = 5;
  optional uint64 b_blocknr = 6;
  optional uint32 b_size = 7;
  optional uint32 b_state = 8;
  optional int32 io_done = 9;
  optional int32 pages_written = 10;
}
message Ext4DaWritePagesExtentFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 lblk = 3;
  optional uint32 len = 4;
  optional uint32 flags = 5;
}
message Ext4DirectIOEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint64 len = 4;
  optional int32 rw = 5;
}
message Ext4DirectIOExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint64 len = 4;
  optional int32 rw = 5;
  optional int32 ret = 6;
}
message Ext4DiscardBlocksFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 blk = 2;
  optional uint64 count = 3;
}
message Ext4DiscardPreallocationsFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
}
message Ext4DropInodeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 drop = 3;
}
message Ext4EsCacheExtentFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
  optional uint32 len = 4;
  optional uint64 pblk = 5;
  optional uint32 status = 6;
}
message Ext4EsFindDelayedExtentRangeEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
}
message Ext4EsFindDelayedExtentRangeExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
  optional uint32 len = 4;
  optional uint64 pblk = 5;
  optional uint64 status = 6;
}
message Ext4EsInsertExtentFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
  optional uint32 len = 4;
  optional uint64 pblk = 5;
  optional uint64 status = 6;
}
message Ext4EsLookupExtentEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
}
message Ext4EsLookupExtentExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
  optional uint32 len = 4;
  optional uint64 pblk = 5;
  optional uint64 status = 6;
  optional int32 found = 7;
}
message Ext4EsRemoveExtentFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 lblk = 3;
  optional int64 len = 4;
}
message Ext4EsShrinkFtraceEvent {
  optional uint64 dev = 1;
  optional int32 nr_shrunk = 2;
  optional uint64 scan_time = 3;
  optional int32 nr_skipped = 4;
  optional int32 retried = 5;
}
message Ext4EsShrinkCountFtraceEvent {
  optional uint64 dev = 1;
  optional int32 nr_to_scan = 2;
  optional int32 cache_cnt = 3;
}
message Ext4EsShrinkScanEnterFtraceEvent {
  optional uint64 dev = 1;
  optional int32 nr_to_scan = 2;
  optional int32 cache_cnt = 3;
}
message Ext4EsShrinkScanExitFtraceEvent {
  optional uint64 dev = 1;
  optional int32 nr_shrunk = 2;
  optional int32 cache_cnt = 3;
}
message Ext4EvictInodeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 nlink = 3;
}
message Ext4ExtConvertToInitializedEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 m_lblk = 3;
  optional uint32 m_len = 4;
  optional uint32 u_lblk = 5;
  optional uint32 u_len = 6;
  optional uint64 u_pblk = 7;
}
message Ext4ExtConvertToInitializedFastpathFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 m_lblk = 3;
  optional uint32 m_len = 4;
  optional uint32 u_lblk = 5;
  optional uint32 u_len = 6;
  optional uint64 u_pblk = 7;
  optional uint32 i_lblk = 8;
  optional uint32 i_len = 9;
  optional uint64 i_pblk = 10;
}
message Ext4ExtHandleUnwrittenExtentsFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 flags = 3;
  optional uint32 lblk = 4;
  optional uint64 pblk = 5;
  optional uint32 len = 6;
  optional uint32 allocated = 7;
  optional uint64 newblk = 8;
}
message Ext4ExtInCacheFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
  optional int32 ret = 4;
}
message Ext4ExtLoadExtentFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 pblk = 3;
  optional uint32 lblk = 4;
}
message Ext4ExtMapBlocksEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
  optional uint32 len = 4;
  optional uint32 flags = 5;
}
message Ext4ExtMapBlocksExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 flags = 3;
  optional uint64 pblk = 4;
  optional uint32 lblk = 5;
  optional uint32 len = 6;
  optional uint32 mflags = 7;
  optional int32 ret = 8;
}
message Ext4ExtPutInCacheFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
  optional uint32 len = 4;
  optional uint64 start = 5;
}
message Ext4ExtRemoveSpaceFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 start = 3;
  optional uint32 end = 4;
  optional int32 depth = 5;
}
message Ext4ExtRemoveSpaceDoneFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 start = 3;
  optional uint32 end = 4;
  optional int32 depth = 5;
  optional int64 partial = 6;
  optional uint32 eh_entries = 7;
}
message Ext4ExtRmIdxFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 pblk = 3;
}
message Ext4ExtRmLeafFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 partial = 3;
  optional uint32 start = 4;
  optional uint32 ee_lblk = 5;
  optional uint64 ee_pblk = 6;
  optional int32 ee_len = 7;
}
message Ext4ExtShowExtentFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 pblk = 3;
  optional uint32 lblk = 4;
  optional uint32 len = 5;
}
message Ext4FallocateEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 offset = 3;
  optional int64 len = 4;
  optional int32 mode = 5;
  optional int64 pos = 6;
}
message Ext4FallocateExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint32 blocks = 4;
  optional int32 ret = 5;
}
message Ext4FindDelallocRangeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 from = 3;
  optional uint32 to = 4;
  optional int32 reverse = 5;
  optional int32 found = 6;
  optional uint32 found_blk = 7;
}
message Ext4ForgetFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 block = 3;
  optional int32 is_metadata = 4;
  optional uint32 mode = 5;
}
message Ext4FreeBlocksFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 block = 3;
  optional uint64 count = 4;
  optional int32 flags = 5;
  optional uint32 mode = 6;
}
message Ext4FreeInodeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 uid = 3;
  optional uint32 gid = 4;
  optional uint64 blocks = 5;
  optional uint32 mode = 6;
}
message Ext4GetImpliedClusterAllocExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint32 flags = 2;
  optional uint32 lblk = 3;
  optional uint64 pblk = 4;
  optional uint32 len = 5;
  optional int32 ret = 6;
}
message Ext4GetReservedClusterAllocFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
  optional uint32 len = 4;
}
message Ext4IndMapBlocksEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
  optional uint32 len = 4;
  optional uint32 flags = 5;
}
message Ext4IndMapBlocksExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 flags = 3;
  optional uint64 pblk = 4;
  optional uint32 lblk = 5;
  optional uint32 len = 6;
  optional uint32 mflags = 7;
  optional int32 ret = 8;
}
message Ext4InsertRangeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 offset = 3;
  optional int64 len = 4;
}
message Ext4InvalidatepageFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 index = 3;
  optional uint64 offset = 4;
  optional uint32 length = 5;
}
message Ext4JournalStartFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ip = 2;
  optional int32 blocks = 3;
  optional int32 rsv_blocks = 4;
  optional int32 nblocks = 5;
}
message Ext4JournalStartReservedFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ip = 2;
  optional int32 blocks = 3;
}
message Ext4JournalledInvalidatepageFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 index = 3;
  optional uint64 offset = 4;
  optional uint32 length = 5;
}
message Ext4JournalledWriteEndFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint32 len = 4;
  optional uint32 copied = 5;
}
message Ext4LoadInodeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
}
message Ext4LoadInodeBitmapFtraceEvent {
  optional uint64 dev = 1;
  optional uint32 group = 2;
}
message Ext4MarkInodeDirtyFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 ip = 3;
}
message Ext4MbBitmapLoadFtraceEvent {
  optional uint64 dev = 1;
  optional uint32 group = 2;
}
message Ext4MbBuddyBitmapLoadFtraceEvent {
  optional uint64 dev = 1;
  optional uint32 group = 2;
}
message Ext4MbDiscardPreallocationsFtraceEvent {
  optional uint64 dev = 1;
  optional int32 needed = 2;
}
message Ext4MbNewGroupPaFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 pa_pstart = 3;
  optional uint64 pa_lstart = 4;
  optional uint32 pa_len = 5;
}
message Ext4MbNewInodePaFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 pa_pstart = 3;
  optional uint64 pa_lstart = 4;
  optional uint32 pa_len = 5;
}
message Ext4MbReleaseGroupPaFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 pa_pstart = 2;
  optional uint32 pa_len = 3;
}
message Ext4MbReleaseInodePaFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 block = 3;
  optional uint32 count = 4;
}
message Ext4MballocAllocFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 orig_logical = 3;
  optional int32 orig_start = 4;
  optional uint32 orig_group = 5;
  optional int32 orig_len = 6;
  optional uint32 goal_logical = 7;
  optional int32 goal_start = 8;
  optional uint32 goal_group = 9;
  optional int32 goal_len = 10;
  optional uint32 result_logical = 11;
  optional int32 result_start = 12;
  optional uint32 result_group = 13;
  optional int32 result_len = 14;
  optional uint32 found = 15;
  optional uint32 groups = 16;
  optional uint32 buddy = 17;
  optional uint32 flags = 18;
  optional uint32 tail = 19;
  optional uint32 cr = 20;
}
message Ext4MballocDiscardFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 result_start = 3;
  optional uint32 result_group = 4;
  optional int32 result_len = 5;
}
message Ext4MballocFreeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 result_start = 3;
  optional uint32 result_group = 4;
  optional int32 result_len = 5;
}
message Ext4MballocPreallocFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 orig_logical = 3;
  optional int32 orig_start = 4;
  optional uint32 orig_group = 5;
  optional int32 orig_len = 6;
  optional uint32 result_logical = 7;
  optional int32 result_start = 8;
  optional uint32 result_group = 9;
  optional int32 result_len = 10;
}
message Ext4OtherInodeUpdateTimeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 orig_ino = 3;
  optional uint32 uid = 4;
  optional uint32 gid = 5;
  optional uint32 mode = 6;
}
message Ext4PunchHoleFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 offset = 3;
  optional int64 len = 4;
  optional int32 mode = 5;
}
message Ext4ReadBlockBitmapLoadFtraceEvent {
  optional uint64 dev = 1;
  optional uint32 group = 2;
}
message Ext4ReadpageFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 index = 3;
}
message Ext4ReleasepageFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 index = 3;
}
message Ext4RemoveBlocksFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 from = 3;
  optional uint32 to = 4;
  optional int64 partial = 5;
  optional uint64 ee_pblk = 6;
  optional uint32 ee_lblk = 7;
  optional uint32 ee_len = 8;
}
message Ext4RequestBlocksFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 len = 3;
  optional uint32 logical = 4;
  optional uint32 lleft = 5;
  optional uint32 lright = 6;
  optional uint64 goal = 7;
  optional uint64 pleft = 8;
  optional uint64 pright = 9;
  optional uint32 flags = 10;
}
message Ext4RequestInodeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 dir = 2;
  optional uint32 mode = 3;
}
message Ext4SyncFsFtraceEvent {
  optional uint64 dev = 1;
  optional int32 wait = 2;
}
message Ext4TrimAllFreeFtraceEvent {
  optional int32 dev_major = 1;
  optional int32 dev_minor = 2;
  optional uint32 group = 3;
  optional int32 start = 4;
  optional int32 len = 5;
}
message Ext4TrimExtentFtraceEvent {
  optional int32 dev_major = 1;
  optional int32 dev_minor = 2;
  optional uint32 group = 3;
  optional int32 start = 4;
  optional int32 len = 5;
}
message Ext4TruncateEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 blocks = 3;
}
message Ext4TruncateExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 blocks = 3;
}
message Ext4UnlinkEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 parent = 3;
  optional int64 size = 4;
}
message Ext4UnlinkExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 ret = 3;
}
message Ext4WriteBeginFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint32 len = 4;
  optional uint32 flags = 5;
}
message Ext4WriteEndFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint32 len = 4;
  optional uint32 copied = 5;
}
message Ext4WritepageFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 index = 3;
}
message Ext4WritepagesFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 nr_to_write = 3;
  optional int64 pages_skipped = 4;
  optional int64 range_start = 5;
  optional int64 range_end = 6;
  optional uint64 writeback_index = 7;
  optional int32 sync_mode = 8;
  optional uint32 for_kupdate = 9;
  optional uint32 range_cyclic = 10;
}
message Ext4WritepagesResultFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 ret = 3;
  optional int32 pages_written = 4;
  optional int64 pages_skipped = 5;
  optional uint64 writeback_index = 6;
  optional int32 sync_mode = 7;
}
message Ext4ZeroRangeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 offset = 3;
  optional int64 len = 4;
  optional int32 mode = 5;
}

// End of protos/perfetto/trace/ftrace/ext4.proto

// Begin of protos/perfetto/trace/ftrace/f2fs.proto

message F2fsDoSubmitBioFtraceEvent {
  optional uint64 dev = 1;
  optional int32 btype = 2;
  optional uint32 sync = 3;
  optional uint64 sector = 4;
  optional uint32 size = 5;
}
message F2fsEvictInodeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 pino = 3;
  optional uint32 mode = 4;
  optional int64 size = 5;
  optional uint32 nlink = 6;
  optional uint64 blocks = 7;
  optional uint32 advise = 8;
}
message F2fsFallocateFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 mode = 3;
  optional int64 offset = 4;
  optional int64 len = 5;
  optional int64 size = 6;
  optional uint64 blocks = 7;
  optional int32 ret = 8;
}
message F2fsGetDataBlockFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 iblock = 3;
  optional uint64 bh_start = 4;
  optional uint64 bh_size = 5;
  optional int32 ret = 6;
}
message F2fsGetVictimFtraceEvent {
  optional uint64 dev = 1;
  optional int32 type = 2;
  optional int32 gc_type = 3;
  optional int32 alloc_mode = 4;
  optional int32 gc_mode = 5;
  optional uint32 victim = 6;
  optional uint32 ofs_unit = 7;
  optional uint32 pre_victim = 8;
  optional uint32 prefree = 9;
  optional uint32 free = 10;
}
message F2fsIgetFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 pino = 3;
  optional uint32 mode = 4;
  optional int64 size = 5;
  optional uint32 nlink = 6;
  optional uint64 blocks = 7;
  optional uint32 advise = 8;
}
message F2fsIgetExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 ret = 3;
}
message F2fsNewInodeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 ret = 3;
}
message F2fsReadpageFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 index = 3;
  optional uint64 blkaddr = 4;
  optional int32 type = 5;
}
message F2fsReserveNewBlockFtraceEvent {
  optional uint64 dev = 1;
  optional uint32 nid = 2;
  optional uint32 ofs_in_node = 3;
}
message F2fsSetPageDirtyFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 type = 3;
  optional int32 dir = 4;
  optional uint64 index = 5;
  optional int32 dirty = 6;
}
message F2fsSubmitWritePageFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 type = 3;
  optional uint64 index = 4;
  optional uint32 block = 5;
}
message F2fsSyncFileEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 pino = 3;
  optional uint32 mode = 4;
  optional int64 size = 5;
  optional uint32 nlink = 6;
  optional uint64 blocks = 7;
  optional uint32 advise = 8;
}
message F2fsSyncFileExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 need_cp = 3;
  optional int32 datasync = 4;
  optional int32 ret = 5;
}
message F2fsSyncFsFtraceEvent {
  optional uint64 dev = 1;
  optional int32 dirty = 2;
  optional int32 wait = 3;
}
message F2fsTruncateFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 pino = 3;
  optional uint32 mode = 4;
  optional int64 size = 5;
  optional uint32 nlink = 6;
  optional uint64 blocks = 7;
  optional uint32 advise = 8;
}
message F2fsTruncateBlocksEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 size = 3;
  optional uint64 blocks = 4;
  optional uint64 from = 5;
}
message F2fsTruncateBlocksExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 ret = 3;
}
message F2fsTruncateDataBlocksRangeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 nid = 3;
  optional uint32 ofs = 4;
  optional int32 free = 5;
}
message F2fsTruncateInodeBlocksEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 size = 3;
  optional uint64 blocks = 4;
  optional uint64 from = 5;
}
message F2fsTruncateInodeBlocksExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 ret = 3;
}
message F2fsTruncateNodeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 nid = 3;
  optional uint32 blk_addr = 4;
}
message F2fsTruncateNodesEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 nid = 3;
  optional uint32 blk_addr = 4;
}
message F2fsTruncateNodesExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 ret = 3;
}
message F2fsTruncatePartialNodesFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 nid = 3;
  optional int32 depth = 4;
  optional int32 err = 5;
}
message F2fsUnlinkEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 size = 3;
  optional uint64 blocks = 4;
  optional string name = 5;
}
message F2fsUnlinkExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 ret = 3;
}
message F2fsVmPageMkwriteFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 type = 3;
  optional int32 dir = 4;
  optional uint64 index = 5;
  optional int32 dirty = 6;
}
message F2fsWriteBeginFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint32 len = 4;
  optional uint32 flags = 5;
}
message F2fsWriteCheckpointFtraceEvent {
  optional uint64 dev = 1;
  optional uint32 is_umount = 2;
  optional string msg = 3;
}
message F2fsWriteEndFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint32 len = 4;
  optional uint32 copied = 5;
}

// End of protos/perfetto/trace/ftrace/f2fs.proto

// Begin of protos/perfetto/trace/ftrace/filemap.proto

message MmFilemapAddToPageCacheFtraceEvent {
  optional uint64 pfn = 1;
  optional uint64 i_ino = 2;
  optional uint64 index = 3;
  optional uint64 s_dev = 4;
  optional uint64 page = 5;
}
message MmFilemapDeleteFromPageCacheFtraceEvent {
  optional uint64 pfn = 1;
  optional uint64 i_ino = 2;
  optional uint64 index = 3;
  optional uint64 s_dev = 4;
  optional uint64 page = 5;
}

// End of protos/perfetto/trace/ftrace/filemap.proto

// Begin of protos/perfetto/trace/ftrace/ftrace.proto

message PrintFtraceEvent {
  optional uint64 ip = 1;
  optional string buf = 2;
}

// End of protos/perfetto/trace/ftrace/ftrace.proto

// Begin of protos/perfetto/trace/ftrace/ftrace_event.proto

message FtraceEvent {
  // Nanoseconds since an epoch.
  // Epoch is configurable by writing into trace_clock.
  // By default this timestamp is CPU local.
  // TODO: Figure out a story for reconciling the various clocks.
  optional uint64 timestamp = 1;

  // Kernel pid (do not confuse with userspace pid aka tgid)
  optional uint32 pid = 2;

  oneof event {
    PrintFtraceEvent print = 3;
    SchedSwitchFtraceEvent sched_switch = 4;
    // removed field with id 5;
    // removed field with id 6;
    // removed field with id 7;
    // removed field with id 8;
    // removed field with id 9;
    // removed field with id 10;
    CpuFrequencyFtraceEvent cpu_frequency = 11;
    CpuFrequencyLimitsFtraceEvent cpu_frequency_limits = 12;
    CpuIdleFtraceEvent cpu_idle = 13;
    ClockEnableFtraceEvent clock_enable = 14;
    ClockDisableFtraceEvent clock_disable = 15;
    ClockSetRateFtraceEvent clock_set_rate = 16;
    SchedWakeupFtraceEvent sched_wakeup = 17;
    SchedBlockedReasonFtraceEvent sched_blocked_reason = 18;
    SchedCpuHotplugFtraceEvent sched_cpu_hotplug = 19;
    SchedWakingFtraceEvent sched_waking = 20;
    // removed field with id 21
    // removed field with id 22
    // removed field with id 23
    // removed field with id 24
    // removed field with id 25
    // removed field with id 26
    // removed field with id 27
    // removed field with id 28
    // removed field with id 29
    // removed field with id 30
    // removed field with id 31
    // removed field with id 32
    // removed field with id 33
    // removed field with id 34
    LowmemoryKillFtraceEvent lowmemory_kill = 35;
    // removed field with id 36
    // removed field with id 37
    // removed field with id 38
    // removed field with id 39
    // removed field with id 40
    Ext4DaWriteBeginFtraceEvent ext4_da_write_begin = 41;
    Ext4DaWriteEndFtraceEvent ext4_da_write_end = 42;
    Ext4SyncFileEnterFtraceEvent ext4_sync_file_enter = 43;
    Ext4SyncFileExitFtraceEvent ext4_sync_file_exit = 44;
    BlockRqIssueFtraceEvent block_rq_issue = 45;
    MmVmscanDirectReclaimBeginFtraceEvent mm_vmscan_direct_reclaim_begin = 46;
    MmVmscanDirectReclaimEndFtraceEvent mm_vmscan_direct_reclaim_end = 47;
    MmVmscanKswapdWakeFtraceEvent mm_vmscan_kswapd_wake = 48;
    MmVmscanKswapdSleepFtraceEvent mm_vmscan_kswapd_sleep = 49;
    BinderTransactionFtraceEvent binder_transaction = 50;
    BinderTransactionReceivedFtraceEvent binder_transaction_received = 51;
    BinderSetPriorityFtraceEvent binder_set_priority = 52;
    BinderLockFtraceEvent binder_lock = 53;
    BinderLockedFtraceEvent binder_locked = 54;
    BinderUnlockFtraceEvent binder_unlock = 55;
    // removed field with id 56
    // removed field with id 57
    // removed field with id 58
    // removed field with id 59
    // removed field with id 60
    // removed field with id 61
    // removed field with id 62
    // removed field with id 63
    // removed field with id 64
    // removed field with id 65
    // removed field with id 66
    // removed field with id 67
    // removed field with id 68
    // removed field with id 69
    // removed field with id 70
    // removed field with id 71
    // removed field with id 72
    // removed field with id 73
    // removed field with id 74
    // removed field with id 75
    // removed field with id 76
    // removed field with id 77
    // removed field with id 78
    // removed field with id 79
    // removed field with id 80
    // removed field with id 81
    // removed field with id 82
    // removed field with id 83
    // removed field with id 84
    // removed field with id 85
    // removed field with id 86
    // removed field with id 87
    // removed field with id 88
    // removed field with id 89
    // removed field with id 90
    // removed field with id 91
    // removed field with id 92
    // removed field with id 93
    // removed field with id 94
    // removed field with id 95
    // removed field with id 96
    MmFilemapAddToPageCacheFtraceEvent mm_filemap_add_to_page_cache = 97;
    MmFilemapDeleteFromPageCacheFtraceEvent mm_filemap_delete_from_page_cache =
        98;
    // removed field with id 99
    // removed field with id 100
    // removed field with id 101
    // removed field with id 102
    // removed field with id 103
    // removed field with id 104
    // removed field with id 105
    // removed field with id 106
    // removed field with id 107
    // removed field with id 108
    // removed field with id 109
    // removed field with id 110
    // removed field with id 111
    // removed field with id 112
    SuspendResumeFtraceEvent suspend_resume = 113;
    SchedWakeupNewFtraceEvent sched_wakeup_new = 114;
    BlockBioBackmergeFtraceEvent block_bio_backmerge = 115;
    BlockBioBounceFtraceEvent block_bio_bounce = 116;
    BlockBioCompleteFtraceEvent block_bio_complete = 117;
    BlockBioFrontmergeFtraceEvent block_bio_frontmerge = 118;
    BlockBioQueueFtraceEvent block_bio_queue = 119;
    BlockBioRemapFtraceEvent block_bio_remap = 120;
    BlockDirtyBufferFtraceEvent block_dirty_buffer = 121;
    BlockGetrqFtraceEvent block_getrq = 122;
    BlockPlugFtraceEvent block_plug = 123;
    BlockRqAbortFtraceEvent block_rq_abort = 124;
    BlockRqCompleteFtraceEvent block_rq_complete = 125;
    BlockRqInsertFtraceEvent block_rq_insert = 126;
    // removed field with id 127;
    BlockRqRemapFtraceEvent block_rq_remap = 128;
    BlockRqRequeueFtraceEvent block_rq_requeue = 129;
    BlockSleeprqFtraceEvent block_sleeprq = 130;
    BlockSplitFtraceEvent block_split = 131;
    BlockTouchBufferFtraceEvent block_touch_buffer = 132;
    BlockUnplugFtraceEvent block_unplug = 133;
    Ext4AllocDaBlocksFtraceEvent ext4_alloc_da_blocks = 134;
    Ext4AllocateBlocksFtraceEvent ext4_allocate_blocks = 135;
    Ext4AllocateInodeFtraceEvent ext4_allocate_inode = 136;
    Ext4BeginOrderedTruncateFtraceEvent ext4_begin_ordered_truncate = 137;
    Ext4CollapseRangeFtraceEvent ext4_collapse_range = 138;
    Ext4DaReleaseSpaceFtraceEvent ext4_da_release_space = 139;
    Ext4DaReserveSpaceFtraceEvent ext4_da_reserve_space = 140;
    Ext4DaUpdateReserveSpaceFtraceEvent ext4_da_update_reserve_space = 141;
    Ext4DaWritePagesFtraceEvent ext4_da_write_pages = 142;
    Ext4DaWritePagesExtentFtraceEvent ext4_da_write_pages_extent = 143;
    Ext4DirectIOEnterFtraceEvent ext4_direct_IO_enter = 144;
    Ext4DirectIOExitFtraceEvent ext4_direct_IO_exit = 145;
    Ext4DiscardBlocksFtraceEvent ext4_discard_blocks = 146;
    Ext4DiscardPreallocationsFtraceEvent ext4_discard_preallocations = 147;
    Ext4DropInodeFtraceEvent ext4_drop_inode = 148;
    Ext4EsCacheExtentFtraceEvent ext4_es_cache_extent = 149;
    Ext4EsFindDelayedExtentRangeEnterFtraceEvent
        ext4_es_find_delayed_extent_range_enter = 150;
    Ext4EsFindDelayedExtentRangeExitFtraceEvent
        ext4_es_find_delayed_extent_range_exit = 151;
    Ext4EsInsertExtentFtraceEvent ext4_es_insert_extent = 152;
    Ext4EsLookupExtentEnterFtraceEvent ext4_es_lookup_extent_enter = 153;
    Ext4EsLookupExtentExitFtraceEvent ext4_es_lookup_extent_exit = 154;
    Ext4EsRemoveExtentFtraceEvent ext4_es_remove_extent = 155;
    Ext4EsShrinkFtraceEvent ext4_es_shrink = 156;
    Ext4EsShrinkCountFtraceEvent ext4_es_shrink_count = 157;
    Ext4EsShrinkScanEnterFtraceEvent ext4_es_shrink_scan_enter = 158;
    Ext4EsShrinkScanExitFtraceEvent ext4_es_shrink_scan_exit = 159;
    Ext4EvictInodeFtraceEvent ext4_evict_inode = 160;
    Ext4ExtConvertToInitializedEnterFtraceEvent
        ext4_ext_convert_to_initialized_enter = 161;
    Ext4ExtConvertToInitializedFastpathFtraceEvent
        ext4_ext_convert_to_initialized_fastpath = 162;
    Ext4ExtHandleUnwrittenExtentsFtraceEvent ext4_ext_handle_unwritten_extents =
        163;
    Ext4ExtInCacheFtraceEvent ext4_ext_in_cache = 164;
    Ext4ExtLoadExtentFtraceEvent ext4_ext_load_extent = 165;
    Ext4ExtMapBlocksEnterFtraceEvent ext4_ext_map_blocks_enter = 166;
    Ext4ExtMapBlocksExitFtraceEvent ext4_ext_map_blocks_exit = 167;
    Ext4ExtPutInCacheFtraceEvent ext4_ext_put_in_cache = 168;
    Ext4ExtRemoveSpaceFtraceEvent ext4_ext_remove_space = 169;
    Ext4ExtRemoveSpaceDoneFtraceEvent ext4_ext_remove_space_done = 170;
    Ext4ExtRmIdxFtraceEvent ext4_ext_rm_idx = 171;
    Ext4ExtRmLeafFtraceEvent ext4_ext_rm_leaf = 172;
    Ext4ExtShowExtentFtraceEvent ext4_ext_show_extent = 173;
    Ext4FallocateEnterFtraceEvent ext4_fallocate_enter = 174;
    Ext4FallocateExitFtraceEvent ext4_fallocate_exit = 175;
    Ext4FindDelallocRangeFtraceEvent ext4_find_delalloc_range = 176;
    Ext4ForgetFtraceEvent ext4_forget = 177;
    Ext4FreeBlocksFtraceEvent ext4_free_blocks = 178;
    Ext4FreeInodeFtraceEvent ext4_free_inode = 179;
    Ext4GetImpliedClusterAllocExitFtraceEvent
        ext4_get_implied_cluster_alloc_exit = 180;
    Ext4GetReservedClusterAllocFtraceEvent ext4_get_reserved_cluster_alloc =
        181;
    Ext4IndMapBlocksEnterFtraceEvent ext4_ind_map_blocks_enter = 182;
    Ext4IndMapBlocksExitFtraceEvent ext4_ind_map_blocks_exit = 183;
    Ext4InsertRangeFtraceEvent ext4_insert_range = 184;
    Ext4InvalidatepageFtraceEvent ext4_invalidatepage = 185;
    Ext4JournalStartFtraceEvent ext4_journal_start = 186;
    Ext4JournalStartReservedFtraceEvent ext4_journal_start_reserved = 187;
    Ext4JournalledInvalidatepageFtraceEvent ext4_journalled_invalidatepage =
        188;
    Ext4JournalledWriteEndFtraceEvent ext4_journalled_write_end = 189;
    Ext4LoadInodeFtraceEvent ext4_load_inode = 190;
    Ext4LoadInodeBitmapFtraceEvent ext4_load_inode_bitmap = 191;
    Ext4MarkInodeDirtyFtraceEvent ext4_mark_inode_dirty = 192;
    Ext4MbBitmapLoadFtraceEvent ext4_mb_bitmap_load = 193;
    Ext4MbBuddyBitmapLoadFtraceEvent ext4_mb_buddy_bitmap_load = 194;
    Ext4MbDiscardPreallocationsFtraceEvent ext4_mb_discard_preallocations = 195;
    Ext4MbNewGroupPaFtraceEvent ext4_mb_new_group_pa = 196;
    Ext4MbNewInodePaFtraceEvent ext4_mb_new_inode_pa = 197;
    Ext4MbReleaseGroupPaFtraceEvent ext4_mb_release_group_pa = 198;
    Ext4MbReleaseInodePaFtraceEvent ext4_mb_release_inode_pa = 199;
    Ext4MballocAllocFtraceEvent ext4_mballoc_alloc = 200;
    Ext4MballocDiscardFtraceEvent ext4_mballoc_discard = 201;
    Ext4MballocFreeFtraceEvent ext4_mballoc_free = 202;
    Ext4MballocPreallocFtraceEvent ext4_mballoc_prealloc = 203;
    Ext4OtherInodeUpdateTimeFtraceEvent ext4_other_inode_update_time = 204;
    Ext4PunchHoleFtraceEvent ext4_punch_hole = 205;
    Ext4ReadBlockBitmapLoadFtraceEvent ext4_read_block_bitmap_load = 206;
    Ext4ReadpageFtraceEvent ext4_readpage = 207;
    Ext4ReleasepageFtraceEvent ext4_releasepage = 208;
    Ext4RemoveBlocksFtraceEvent ext4_remove_blocks = 209;
    Ext4RequestBlocksFtraceEvent ext4_request_blocks = 210;
    Ext4RequestInodeFtraceEvent ext4_request_inode = 211;
    Ext4SyncFsFtraceEvent ext4_sync_fs = 212;
    Ext4TrimAllFreeFtraceEvent ext4_trim_all_free = 213;
    Ext4TrimExtentFtraceEvent ext4_trim_extent = 214;
    Ext4TruncateEnterFtraceEvent ext4_truncate_enter = 215;
    Ext4TruncateExitFtraceEvent ext4_truncate_exit = 216;
    Ext4UnlinkEnterFtraceEvent ext4_unlink_enter = 217;
    Ext4UnlinkExitFtraceEvent ext4_unlink_exit = 218;
    Ext4WriteBeginFtraceEvent ext4_write_begin = 219;
    // removed field with id 220;
    // removed field with id 221;
    // removed field with id 222;
    // removed field with id 223;
    // removed field with id 224;
    // removed field with id 225;
    // removed field with id 226;
    // removed field with id 227;
    // removed field with id 228;
    // removed field with id 229;
    Ext4WriteEndFtraceEvent ext4_write_end = 230;
    Ext4WritepageFtraceEvent ext4_writepage = 231;
    Ext4WritepagesFtraceEvent ext4_writepages = 232;
    Ext4WritepagesResultFtraceEvent ext4_writepages_result = 233;
    Ext4ZeroRangeFtraceEvent ext4_zero_range = 234;
    TaskNewtaskFtraceEvent task_newtask = 235;
    TaskRenameFtraceEvent task_rename = 236;
    SchedProcessExecFtraceEvent sched_process_exec = 237;
    SchedProcessExitFtraceEvent sched_process_exit = 238;
    SchedProcessForkFtraceEvent sched_process_fork = 239;
    SchedProcessFreeFtraceEvent sched_process_free = 240;
    SchedProcessHangFtraceEvent sched_process_hang = 241;
    SchedProcessWaitFtraceEvent sched_process_wait = 242;
    F2fsDoSubmitBioFtraceEvent f2fs_do_submit_bio = 243;
    F2fsEvictInodeFtraceEvent f2fs_evict_inode = 244;
    F2fsFallocateFtraceEvent f2fs_fallocate = 245;
    F2fsGetDataBlockFtraceEvent f2fs_get_data_block = 246;
    F2fsGetVictimFtraceEvent f2fs_get_victim = 247;
    F2fsIgetFtraceEvent f2fs_iget = 248;
    F2fsIgetExitFtraceEvent f2fs_iget_exit = 249;
    F2fsNewInodeFtraceEvent f2fs_new_inode = 250;
    F2fsReadpageFtraceEvent f2fs_readpage = 251;
    F2fsReserveNewBlockFtraceEvent f2fs_reserve_new_block = 252;
    F2fsSetPageDirtyFtraceEvent f2fs_set_page_dirty = 253;
    F2fsSubmitWritePageFtraceEvent f2fs_submit_write_page = 254;
    F2fsSyncFileEnterFtraceEvent f2fs_sync_file_enter = 255;
    F2fsSyncFileExitFtraceEvent f2fs_sync_file_exit = 256;
    F2fsSyncFsFtraceEvent f2fs_sync_fs = 257;
    F2fsTruncateFtraceEvent f2fs_truncate = 258;
    F2fsTruncateBlocksEnterFtraceEvent f2fs_truncate_blocks_enter = 259;
    F2fsTruncateBlocksExitFtraceEvent f2fs_truncate_blocks_exit = 260;
    F2fsTruncateDataBlocksRangeFtraceEvent f2fs_truncate_data_blocks_range =
        261;
    F2fsTruncateInodeBlocksEnterFtraceEvent f2fs_truncate_inode_blocks_enter =
        262;
    F2fsTruncateInodeBlocksExitFtraceEvent f2fs_truncate_inode_blocks_exit =
        263;
    F2fsTruncateNodeFtraceEvent f2fs_truncate_node = 264;
    F2fsTruncateNodesEnterFtraceEvent f2fs_truncate_nodes_enter = 265;
    F2fsTruncateNodesExitFtraceEvent f2fs_truncate_nodes_exit = 266;
    F2fsTruncatePartialNodesFtraceEvent f2fs_truncate_partial_nodes = 267;
    F2fsUnlinkEnterFtraceEvent f2fs_unlink_enter = 268;
    F2fsUnlinkExitFtraceEvent f2fs_unlink_exit = 269;
    F2fsVmPageMkwriteFtraceEvent f2fs_vm_page_mkwrite = 270;
    F2fsWriteBeginFtraceEvent f2fs_write_begin = 271;
    F2fsWriteCheckpointFtraceEvent f2fs_write_checkpoint = 272;
    F2fsWriteEndFtraceEvent f2fs_write_end = 273;
    AllocPagesIommuEndFtraceEvent alloc_pages_iommu_end = 274;
    AllocPagesIommuFailFtraceEvent alloc_pages_iommu_fail = 275;
    AllocPagesIommuStartFtraceEvent alloc_pages_iommu_start = 276;
    AllocPagesSysEndFtraceEvent alloc_pages_sys_end = 277;
    AllocPagesSysFailFtraceEvent alloc_pages_sys_fail = 278;
    AllocPagesSysStartFtraceEvent alloc_pages_sys_start = 279;
    DmaAllocContiguousRetryFtraceEvent dma_alloc_contiguous_retry = 280;
    IommuMapRangeFtraceEvent iommu_map_range = 281;
    IommuSecPtblMapRangeEndFtraceEvent iommu_sec_ptbl_map_range_end = 282;
    IommuSecPtblMapRangeStartFtraceEvent iommu_sec_ptbl_map_range_start = 283;
    IonAllocBufferEndFtraceEvent ion_alloc_buffer_end = 284;
    IonAllocBufferFailFtraceEvent ion_alloc_buffer_fail = 285;
    IonAllocBufferFallbackFtraceEvent ion_alloc_buffer_fallback = 286;
    IonAllocBufferStartFtraceEvent ion_alloc_buffer_start = 287;
    IonCpAllocRetryFtraceEvent ion_cp_alloc_retry = 288;
    IonCpSecureBufferEndFtraceEvent ion_cp_secure_buffer_end = 289;
    IonCpSecureBufferStartFtraceEvent ion_cp_secure_buffer_start = 290;
    IonPrefetchingFtraceEvent ion_prefetching = 291;
    IonSecureCmaAddToPoolEndFtraceEvent ion_secure_cma_add_to_pool_end = 292;
    IonSecureCmaAddToPoolStartFtraceEvent ion_secure_cma_add_to_pool_start =
        293;
    IonSecureCmaAllocateEndFtraceEvent ion_secure_cma_allocate_end = 294;
    IonSecureCmaAllocateStartFtraceEvent ion_secure_cma_allocate_start = 295;
    IonSecureCmaShrinkPoolEndFtraceEvent ion_secure_cma_shrink_pool_end = 296;
    IonSecureCmaShrinkPoolStartFtraceEvent ion_secure_cma_shrink_pool_start =
        297;
    KfreeFtraceEvent kfree = 298;
    KmallocFtraceEvent kmalloc = 299;
    KmallocNodeFtraceEvent kmalloc_node = 300;
    KmemCacheAllocFtraceEvent kmem_cache_alloc = 301;
    KmemCacheAllocNodeFtraceEvent kmem_cache_alloc_node = 302;
    KmemCacheFreeFtraceEvent kmem_cache_free = 303;
    MigratePagesEndFtraceEvent migrate_pages_end = 304;
    MigratePagesStartFtraceEvent migrate_pages_start = 305;
    MigrateRetryFtraceEvent migrate_retry = 306;
    MmPageAllocFtraceEvent mm_page_alloc = 307;
    MmPageAllocExtfragFtraceEvent mm_page_alloc_extfrag = 308;
    MmPageAllocZoneLockedFtraceEvent mm_page_alloc_zone_locked = 309;
    MmPageFreeFtraceEvent mm_page_free = 310;
    MmPageFreeBatchedFtraceEvent mm_page_free_batched = 311;
    MmPagePcpuDrainFtraceEvent mm_page_pcpu_drain = 312;
    RssStatFtraceEvent rss_stat = 313;
    IonHeapShrinkFtraceEvent ion_heap_shrink = 314;
    IonHeapGrowFtraceEvent ion_heap_grow = 315;
    // removed field with id 316
    // removed field with id 317
    // removed field with id 318
    // removed field with id 319
    ClkEnableFtraceEvent clk_enable = 320;
    ClkDisableFtraceEvent clk_disable = 321;
    ClkSetRateFtraceEvent clk_set_rate = 322;
    BinderTransactionAllocBufFtraceEvent binder_transaction_alloc_buf = 323;
    SignalDeliverFtraceEvent signal_deliver = 324;
    SignalGenerateFtraceEvent signal_generate = 325;
    // removed field with id 326
    GenericFtraceEvent generic = 327;
    MmEventRecordFtraceEvent mm_event_record = 328;
    SysEnterFtraceEvent sys_enter = 329;
    SysExitFtraceEvent sys_exit = 330;
  }
}

// End of protos/perfetto/trace/ftrace/ftrace_event.proto

// Begin of protos/perfetto/trace/ftrace/ftrace_event_bundle.proto

message FtraceEventBundle {
  optional uint32 cpu = 1;
  repeated FtraceEvent event = 2;
  // Total of all overwrite fields from the headers of all kernel
  // ftrace pages we parsed into this FtraceEventBundle. Zero if
  // no overwriting occurred, a number larger than zero if some overwriting
  // occurred.
  optional uint32 overwrite_count = 3;
}

// End of protos/perfetto/trace/ftrace/ftrace_event_bundle.proto

// Begin of protos/perfetto/trace/ftrace/ftrace_stats.proto

// Per-CPU stats for the ftrace data source gathered from the kernel from
// /sys/kernel/debug/tracing/per_cpu/cpuX/stats.
message FtraceCpuStats {
  // CPU index.
  optional uint64 cpu = 1;

  // Number of entries still in the kernel buffer. Ideally this should be close
  // to zero, as events are consumed regularly and moved into the userspace
  // buffers (or file).
  optional uint64 entries = 2;

  // Number of events lost in kernel buffers due to overwriting of old events
  // before userspace had a chance to drain them.
  optional uint64 overrun = 3;

  // This should always be zero. If not the buffer size is way too small or
  // something went wrong with the tracer.
  optional uint64 commit_overrun = 4;

  // Bytes actually read (not overwritten).
  optional uint64 bytes_read = 5;

  // The timestamp for the oldest event still in the ring buffer.
  optional double oldest_event_ts = 6;

  // The current timestamp.
  optional double now_ts = 7;

  // If the kernel buffer has overwrite mode disabled, this will show the number
  // of new events that were lost because the buffer was full. This is similar
  // to |overrun| but only for the overwrite=false case.
  optional uint64 dropped_events = 8;

  // The number of events read.
  optional uint64 read_events = 9;
}

// Ftrace stats for all CPUs.
message FtraceStats {
  enum Phase {
    UNSPECIFIED = 0;
    START_OF_TRACE = 1;
    END_OF_TRACE = 2;
  }

  // Tells when stats were sampled. There should be one sample at the beginning
  // of the trace and one sample at the end.
  optional Phase phase = 1;

  // Per-CPU stats (one entry for each CPU).
  repeated FtraceCpuStats cpu_stats = 2;
}

// End of protos/perfetto/trace/ftrace/ftrace_stats.proto

// Begin of protos/perfetto/trace/ftrace/generic.proto

// This generic proto is used to output events in the trace
// when a specific proto for that event does not exist.
message GenericFtraceEvent {
  message Field {
    optional string name = 1;
    oneof value {
      string str_value = 3;
      int64 int_value = 4;
      uint64 uint_value = 5;
    }
  }

  optional string event_name = 1;
  repeated Field field = 2;
}

// End of protos/perfetto/trace/ftrace/generic.proto

// Begin of protos/perfetto/trace/ftrace/kmem.proto

message AllocPagesIommuEndFtraceEvent {
  optional uint32 gfp_flags = 1;
  optional uint32 order = 2;
}
message AllocPagesIommuFailFtraceEvent {
  optional uint32 gfp_flags = 1;
  optional uint32 order = 2;
}
message AllocPagesIommuStartFtraceEvent {
  optional uint32 gfp_flags = 1;
  optional uint32 order = 2;
}
message AllocPagesSysEndFtraceEvent {
  optional uint32 gfp_flags = 1;
  optional uint32 order = 2;
}
message AllocPagesSysFailFtraceEvent {
  optional uint32 gfp_flags = 1;
  optional uint32 order = 2;
}
message AllocPagesSysStartFtraceEvent {
  optional uint32 gfp_flags = 1;
  optional uint32 order = 2;
}
message DmaAllocContiguousRetryFtraceEvent {
  optional int32 tries = 1;
}
message IommuMapRangeFtraceEvent {
  optional uint64 chunk_size = 1;
  optional uint64 len = 2;
  optional uint64 pa = 3;
  optional uint64 va = 4;
}
message IommuSecPtblMapRangeEndFtraceEvent {
  optional uint64 len = 1;
  optional int32 num = 2;
  optional uint32 pa = 3;
  optional int32 sec_id = 4;
  optional uint64 va = 5;
}
message IommuSecPtblMapRangeStartFtraceEvent {
  optional uint64 len = 1;
  optional int32 num = 2;
  optional uint32 pa = 3;
  optional int32 sec_id = 4;
  optional uint64 va = 5;
}
message IonAllocBufferEndFtraceEvent {
  optional string client_name = 1;
  optional uint32 flags = 2;
  optional string heap_name = 3;
  optional uint64 len = 4;
  optional uint32 mask = 5;
}
message IonAllocBufferFailFtraceEvent {
  optional string client_name = 1;
  optional int64 error = 2;
  optional uint32 flags = 3;
  optional string heap_name = 4;
  optional uint64 len = 5;
  optional uint32 mask = 6;
}
message IonAllocBufferFallbackFtraceEvent {
  optional string client_name = 1;
  optional int64 error = 2;
  optional uint32 flags = 3;
  optional string heap_name = 4;
  optional uint64 len = 5;
  optional uint32 mask = 6;
}
message IonAllocBufferStartFtraceEvent {
  optional string client_name = 1;
  optional uint32 flags = 2;
  optional string heap_name = 3;
  optional uint64 len = 4;
  optional uint32 mask = 5;
}
message IonCpAllocRetryFtraceEvent {
  optional int32 tries = 1;
}
message IonCpSecureBufferEndFtraceEvent {
  optional uint64 align = 1;
  optional uint64 flags = 2;
  optional string heap_name = 3;
  optional uint64 len = 4;
}
message IonCpSecureBufferStartFtraceEvent {
  optional uint64 align = 1;
  optional uint64 flags = 2;
  optional string heap_name = 3;
  optional uint64 len = 4;
}
message IonPrefetchingFtraceEvent {
  optional uint64 len = 1;
}
message IonSecureCmaAddToPoolEndFtraceEvent {
  optional uint32 is_prefetch = 1;
  optional uint64 len = 2;
  optional int32 pool_total = 3;
}
message IonSecureCmaAddToPoolStartFtraceEvent {
  optional uint32 is_prefetch = 1;
  optional uint64 len = 2;
  optional int32 pool_total = 3;
}
message IonSecureCmaAllocateEndFtraceEvent {
  optional uint64 align = 1;
  optional uint64 flags = 2;
  optional string heap_name = 3;
  optional uint64 len = 4;
}
message IonSecureCmaAllocateStartFtraceEvent {
  optional uint64 align = 1;
  optional uint64 flags = 2;
  optional string heap_name = 3;
  optional uint64 len = 4;
}
message IonSecureCmaShrinkPoolEndFtraceEvent {
  optional uint64 drained_size = 1;
  optional uint64 skipped_size = 2;
}
message IonSecureCmaShrinkPoolStartFtraceEvent {
  optional uint64 drained_size = 1;
  optional uint64 skipped_size = 2;
}
message KfreeFtraceEvent {
  optional uint64 call_site = 1;
  optional uint64 ptr = 2;
}
message KmallocFtraceEvent {
  optional uint64 bytes_alloc = 1;
  optional uint64 bytes_req = 2;
  optional uint64 call_site = 3;
  optional uint32 gfp_flags = 4;
  optional uint64 ptr = 5;
}
message KmallocNodeFtraceEvent {
  optional uint64 bytes_alloc = 1;
  optional uint64 bytes_req = 2;
  optional uint64 call_site = 3;
  optional uint32 gfp_flags = 4;
  optional int32 node = 5;
  optional uint64 ptr = 6;
}
message KmemCacheAllocFtraceEvent {
  optional uint64 bytes_alloc = 1;
  optional uint64 bytes_req = 2;
  optional uint64 call_site = 3;
  optional uint32 gfp_flags = 4;
  optional uint64 ptr = 5;
}
message KmemCacheAllocNodeFtraceEvent {
  optional uint64 bytes_alloc = 1;
  optional uint64 bytes_req = 2;
  optional uint64 call_site = 3;
  optional uint32 gfp_flags = 4;
  optional int32 node = 5;
  optional uint64 ptr = 6;
}
message KmemCacheFreeFtraceEvent {
  optional uint64 call_site = 1;
  optional uint64 ptr = 2;
}
message MigratePagesEndFtraceEvent {
  optional int32 mode = 1;
}
message MigratePagesStartFtraceEvent {
  optional int32 mode = 1;
}
message MigrateRetryFtraceEvent {
  optional int32 tries = 1;
}
message MmPageAllocFtraceEvent {
  optional uint32 gfp_flags = 1;
  optional int32 migratetype = 2;
  optional uint32 order = 3;
  optional uint64 page = 4;
  optional uint64 pfn = 5;
}
message MmPageAllocExtfragFtraceEvent {
  optional int32 alloc_migratetype = 1;
  optional int32 alloc_order = 2;
  optional int32 fallback_migratetype = 3;
  optional int32 fallback_order = 4;
  optional uint64 page = 5;
  optional int32 change_ownership = 6;
  optional uint64 pfn = 7;
}
message MmPageAllocZoneLockedFtraceEvent {
  optional int32 migratetype = 1;
  optional uint32 order = 2;
  optional uint64 page = 3;
  optional uint64 pfn = 4;
}
message MmPageFreeFtraceEvent {
  optional uint32 order = 1;
  optional uint64 page = 2;
  optional uint64 pfn = 3;
}
message MmPageFreeBatchedFtraceEvent {
  optional int32 cold = 1;
  optional uint64 page = 2;
  optional uint64 pfn = 3;
}
message MmPagePcpuDrainFtraceEvent {
  optional int32 migratetype = 1;
  optional uint32 order = 2;
  optional uint64 page = 3;
  optional uint64 pfn = 4;
}
message RssStatFtraceEvent {
  optional int32 member = 1;
  optional int64 size = 2;
}
message IonHeapShrinkFtraceEvent {
  optional string heap_name = 1;
  optional uint64 len = 2;
  optional int64 total_allocated = 3;
}
message IonHeapGrowFtraceEvent {
  optional string heap_name = 1;
  optional uint64 len = 2;
  optional int64 total_allocated = 3;
}

// End of protos/perfetto/trace/ftrace/kmem.proto

// Begin of protos/perfetto/trace/ftrace/lowmemorykiller.proto

message LowmemoryKillFtraceEvent {
  optional string comm = 1;
  optional int32 pid = 2;
  optional int64 pagecache_size = 3;
  optional int64 pagecache_limit = 4;
  optional int64 free = 5;
}

// End of protos/perfetto/trace/ftrace/lowmemorykiller.proto

// Begin of protos/perfetto/trace/ftrace/mm_event.proto

message MmEventRecordFtraceEvent {
  optional uint32 avg_lat = 1;
  optional uint32 count = 2;
  optional uint32 max_lat = 3;
  optional uint32 type = 4;
}

// End of protos/perfetto/trace/ftrace/mm_event.proto

// Begin of protos/perfetto/trace/ftrace/power.proto

message CpuFrequencyFtraceEvent {
  optional uint32 state = 1;
  optional uint32 cpu_id = 2;
}
message CpuFrequencyLimitsFtraceEvent {
  optional uint32 min_freq = 1;
  optional uint32 max_freq = 2;
  optional uint32 cpu_id = 3;
}
message CpuIdleFtraceEvent {
  optional uint32 state = 1;
  optional uint32 cpu_id = 2;
}
message ClockEnableFtraceEvent {
  optional string name = 1;
  optional uint64 state = 2;
  optional uint64 cpu_id = 3;
}
message ClockDisableFtraceEvent {
  optional string name = 1;
  optional uint64 state = 2;
  optional uint64 cpu_id = 3;
}
message ClockSetRateFtraceEvent {
  optional string name = 1;
  optional uint64 state = 2;
  optional uint64 cpu_id = 3;
}
message SuspendResumeFtraceEvent {
  optional string action = 1;
  optional int32 val = 2;
  optional uint32 start = 3;
}

// End of protos/perfetto/trace/ftrace/power.proto

// Begin of protos/perfetto/trace/ftrace/raw_syscalls.proto

message SysEnterFtraceEvent {
  optional int64 id = 1;
}
message SysExitFtraceEvent {
  optional int64 id = 1;
  optional int64 ret = 2;
}

// End of protos/perfetto/trace/ftrace/raw_syscalls.proto

// Begin of protos/perfetto/trace/ftrace/sched.proto

message SchedSwitchFtraceEvent {
  optional string prev_comm = 1;
  optional int32 prev_pid = 2;
  optional int32 prev_prio = 3;
  optional int64 prev_state = 4;
  optional string next_comm = 5;
  optional int32 next_pid = 6;
  optional int32 next_prio = 7;
}
message SchedWakeupFtraceEvent {
  optional string comm = 1;
  optional int32 pid = 2;
  optional int32 prio = 3;
  optional int32 success = 4;
  optional int32 target_cpu = 5;
}
message SchedBlockedReasonFtraceEvent {
  optional int32 pid = 1;
  optional uint64 caller = 2;
  optional uint32 io_wait = 3;
}
message SchedCpuHotplugFtraceEvent {
  optional int32 affected_cpu = 1;
  optional int32 error = 2;
  optional int32 status = 3;
}
message SchedWakingFtraceEvent {
  optional string comm = 1;
  optional int32 pid = 2;
  optional int32 prio = 3;
  optional int32 success = 4;
  optional int32 target_cpu = 5;
}
message SchedWakeupNewFtraceEvent {
  optional string comm = 1;
  optional int32 pid = 2;
  optional int32 prio = 3;
  optional int32 success = 4;
  optional int32 target_cpu = 5;
}
message SchedProcessExecFtraceEvent {
  optional string filename = 1;
  optional int32 pid = 2;
  optional int32 old_pid = 3;
}
message SchedProcessExitFtraceEvent {
  optional string comm = 1;
  optional int32 pid = 2;
  optional int32 tgid = 3;
  optional int32 prio = 4;
}
message SchedProcessForkFtraceEvent {
  optional string parent_comm = 1;
  optional int32 parent_pid = 2;
  optional string child_comm = 3;
  optional int32 child_pid = 4;
}
message SchedProcessFreeFtraceEvent {
  optional string comm = 1;
  optional int32 pid = 2;
  optional int32 prio = 3;
}
message SchedProcessHangFtraceEvent {
  optional string comm = 1;
  optional int32 pid = 2;
}
message SchedProcessWaitFtraceEvent {
  optional string comm = 1;
  optional int32 pid = 2;
  optional int32 prio = 3;
}

// End of protos/perfetto/trace/ftrace/sched.proto

// Begin of protos/perfetto/trace/ftrace/signal.proto

message SignalDeliverFtraceEvent {
  optional int32 code = 1;
  optional uint64 sa_flags = 2;
  optional int32 sig = 3;
}
message SignalGenerateFtraceEvent {
  optional int32 code = 1;
  optional string comm = 2;
  optional int32 group = 3;
  optional int32 pid = 4;
  optional int32 result = 5;
  optional int32 sig = 6;
}

// End of protos/perfetto/trace/ftrace/signal.proto

// Begin of protos/perfetto/trace/ftrace/task.proto

message TaskNewtaskFtraceEvent {
  optional int32 pid = 1;
  optional string comm = 2;
  optional uint64 clone_flags = 3;
  optional int32 oom_score_adj = 4;
}
message TaskRenameFtraceEvent {
  optional int32 pid = 1;
  optional string oldcomm = 2;
  optional string newcomm = 3;
  optional int32 oom_score_adj = 4;
}

// End of protos/perfetto/trace/ftrace/task.proto

// Begin of protos/perfetto/trace/ftrace/vmscan.proto

message MmVmscanDirectReclaimBeginFtraceEvent {
  optional int32 order = 1;
  optional int32 may_writepage = 2;
  optional uint32 gfp_flags = 3;
}
message MmVmscanDirectReclaimEndFtraceEvent {
  optional uint64 nr_reclaimed = 1;
}
message MmVmscanKswapdWakeFtraceEvent {
  optional int32 nid = 1;
  optional int32 order = 2;
}
message MmVmscanKswapdSleepFtraceEvent {
  optional int32 nid = 1;
}

// End of protos/perfetto/trace/ftrace/vmscan.proto

// Begin of protos/perfetto/trace/interned_data/interned_data.proto

// ------------------------------ DATA INTERNING: ------------------------------
// Interning indexes are built up gradually by adding the entries contained in
// each TracePacket of the same packet sequence (packets emitted by the same
// producer and TraceWriter, see |trusted_packet_sequence_id|). Thus, packets
// can only refer to interned data from other packets in the same sequence.
//
// The writer will emit new entries when it encounters new internable values
// that aren't yet in the index. Data in current and subsequent TracePackets can
// then refer to the entry by its position (interning ID, abbreviated "iid") in
// its index. An interning ID with value 0 is considered invalid (not set).
//
// Because of the incremental build-up, the interning index will miss data when
// TracePackets are lost, e.g. because a chunk was overridden in the central
// ring buffer. To avoid invalidation of the whole trace in such a case, the
// index is periodically reset (see |incremental_state_cleared| in TracePacket).
// When packet loss occurs, the reader will only lose interning data up to the
// next reset.
// -----------------------------------------------------------------------------

// Message that contains new entries for the interning indices of a packet
// sequence.
//
// The writer will usually emit new entries in the same TracePacket that first
// refers to them (since the last reset of interning state). They may also be
// emitted proactively in advance of referring to them in later packets.
//
// Next id: 5.
message InternedData {
  // Each field's message type needs to specify an |iid| field, which is the ID
  // of the entry in the field's interning index. Each field constructs its own
  // index, thus interning IDs are scoped to the tracing session and field
  // (usually as a counter for efficient var-int encoding). It is illegal to
  // override entries in an index (using the same iid for two different values)
  // within the same tracing session, even after a reset of the emitted
  // interning state.
  repeated EventCategory event_categories = 1;
  repeated LegacyEventName legacy_event_names = 2;
  repeated DebugAnnotationName debug_annotation_names = 3;
  repeated SourceLocation source_locations = 4;
  // Note: field IDs up to 15 should be used for frequent data only.
}

// End of protos/perfetto/trace/interned_data/interned_data.proto

// Begin of protos/perfetto/trace/power/battery_counters.proto

message BatteryCounters {
  // Battery capacity in microampere-hours(µAh). Also known as Coulomb counter.
  optional int64 charge_counter_uah = 1;

  // Remaining battery capacity percentage of total capacity
  optional float capacity_percent = 2;

  // Instantaneous battery current in microamperes(µA).
  // Positive values indicate net current entering the battery from a charge
  // source, negative values indicate net current discharging from the battery.
  optional int64 current_ua = 3;

  // Instantaneous battery current in microamperes(µA).
  optional int64 current_avg_ua = 4;
}

// End of protos/perfetto/trace/power/battery_counters.proto

// Begin of protos/perfetto/trace/power/power_rails.proto

message PowerRails {

  message RailDescriptor {
    // Index corresponding to the rail
    optional uint32 index = 1;
    // Name of the rail
    optional string rail_name = 2;
    // Name of the subsystem to which this rail belongs
    optional string subsys_name = 3;
    // Hardware sampling rate
    optional uint32 sampling_rate = 4;
  }

  // This is only emitted at the beginning of the trace.
  repeated RailDescriptor rail_descriptor = 1;

  message EnergyData {
    // Index corresponding to RailDescriptor.index
    optional uint32 index = 1;
    // Time since device boot(CLOCK_BOOTTIME) in milli-seconds
    optional uint64 timestamp_ms = 2;
    // Accumulated energy since device boot in microwatt-seconds (uWs)
    optional uint64 energy = 3;
  }

  repeated EnergyData energy_data = 2;
}

// End of protos/perfetto/trace/power/power_rails.proto

// Begin of protos/perfetto/trace/profiling/profile_packet.proto

message ProfilePacket {
  repeated InternedString strings = 1;
  message InternedString {
    optional uint64 id = 1;
    optional bytes str = 2;
  }

  repeated Mapping mappings = 4;
  message Mapping {
    optional uint64 id = 1;        // Interning key.
    optional uint64 build_id = 2;  // Interning key.
    optional uint64 offset = 3;
    optional uint64 start = 4;
    optional uint64 end = 5;
    optional uint64 load_bias = 6;
    // E.g. ["system", "lib64", "libc.so"]
    repeated uint64 path_string_ids = 7;  // id of string.
  }

  repeated Frame frames = 2;
  message Frame {
    optional uint64 id = 1;  // Interning key
    // E.g. "fopen"
    optional uint64 function_name_id = 2;  // id of string.
    optional uint64 mapping_id = 3;
    optional uint64 rel_pc = 4;
  }

  repeated Callstack callstacks = 3;
  message Callstack {
    optional uint64 id = 1;
    // Frames of this callstack. Bottom frame first.
    repeated uint64 frame_ids = 2;
  }

  message HeapSample {
    optional uint64 callstack_id = 1;
    // bytes allocated at this callstack.
    optional uint64 self_allocated = 2;
    // bytes allocated at this callstack that have been freed.
    optional uint64 self_freed = 3;
    // bytes allocated at this callstack but not used since the last
    // clear_refs.
    // See documentation of idle_allocations in HeapprofdConfig for more
    // details.
    optional uint64 self_idle = 7;
    optional uint64 timestamp = 4;  // timestamp [opt]
    // Number of allocations that were sampled at this callstack.
    optional uint64 alloc_count = 5;
    // Number of allocations that were sampled at this callstack that have been
    // freed.
    optional uint64 free_count = 6;
  }

  message Histogram {
    message Bucket {
      // This bucket counts values from the previous bucket's (or -infinity if
      // this is the first bucket) upper_limit (inclusive) to this upper_limit
      // (exclusive).
      optional uint64 upper_limit = 1;
      // This is the highest bucket. This is set instead of the upper_limit. Any
      // values larger or equal to the previous bucket's upper_limit are counted
      // in this bucket.
      optional bool max_bucket = 2;
      // Number of values that fall into this range.
      optional uint64 count = 3;
    }
    repeated Bucket buckets = 1;
  }

  message ProcessStats {
    optional uint64 unwinding_errors = 1;
    optional uint64 heap_samples = 2;
    optional uint64 map_reparses = 3;
    optional Histogram unwinding_time_us = 4;
    optional uint64 total_unwinding_time_us = 5;
  }

  repeated ProcessHeapSamples process_dumps = 5;
  message ProcessHeapSamples {
    optional uint64 pid = 1;

    // This process was profiled from startup.
    // If false, this process was already running when profiling started.
    optional bool from_startup = 3;

    // This process was not profiled because a concurrent session was active.
    // If this is true, samples will be empty.
    optional bool rejected_concurrent = 4;

    // This process disconnected while it was profiled.
    // If false, the process outlived the profiling session.
    optional bool disconnected = 6;

    // If disconnected, this disconnect was caused by the client overrunning
    // the buffer.
    optional bool buffer_overran = 7;

    // If disconnected, this disconnected was caused by the shared memory
    // buffer being corrupted. THIS IS ALWAYS A BUG IN HEAPPROFD OR CLIENT
    // MEMORY CORRUPTION.
    optional bool buffer_corrupted = 8;

    // Timestamp of the state of the target process that this dump represents.
    // This can be different to the timestamp of the TracePackets for various
    // reasons:
    // * If disconnected is set above, this is the timestamp of last state
    //   heapprofd had of the process before it disconnected.
    // * Otherwise, if the rate of events produced by the process is high,
    //   heapprofd might be behind.
    //
    // TODO(fmayer): This is MONOTONIC_COARSE. Refactor ClockSnapshot::Clock
    //               to have a type enum that we can reuse here.
    optional uint64 timestamp = 9;

    optional ProcessStats stats = 5;

    repeated HeapSample samples = 2;
  }

  optional bool continued = 6;
  optional uint64 index = 7;
}

// End of protos/perfetto/trace/profiling/profile_packet.proto

// Begin of protos/perfetto/trace/ps/process_stats.proto

// Per-process periodically sampled stats. These samples are wrapped in a
// dedicated message (as opposite to be fields in process_tree.proto) because
// they are dumped at a different rate than cmdline and thread list.
// Note: not all of these stats will be present in every ProcessStats message
// and sometimes processes may be missing . This is because counters are
// cached to reduce emission of counters which do not change.
message ProcessStats {
  message Process {
    optional int32 pid = 1;

    // See /proc/[pid]/status in `man 5 proc` for a description of these fields.
    optional uint64 vm_size_kb = 2;
    optional uint64 vm_rss_kb = 3;
    optional uint64 rss_anon_kb = 4;
    optional uint64 rss_file_kb = 5;
    optional uint64 rss_shmem_kb = 6;
    optional uint64 vm_swap_kb = 7;
    optional uint64 vm_locked_kb = 8;
    optional uint64 vm_hwm_kb = 9;
    // When adding a new field remember to update kProcMemCounterSize in
    // the trace processor.

    optional int64 oom_score_adj = 10;
  }
  repeated Process processes = 1;
}

// End of protos/perfetto/trace/ps/process_stats.proto

// Begin of protos/perfetto/trace/ps/process_tree.proto

message ProcessTree {
  // Representation of a thread.
  message Thread {
    // The thread id (as per gettid())
    optional int32 tid = 1;

    // Thread group id (i.e. the PID of the process, == TID of the main thread)
    optional int32 tgid = 3;

    // The name of the thread.
    optional string name = 2;
  }

  // Representation of a process.
  message Process {
    // The UNIX process ID, aka thread group ID (as per getpid()).
    optional int32 pid = 1;

    // The parent process ID, as per getppid().
    optional int32 ppid = 2;

    // The command line for the process, as per /proc/pid/cmdline.
    // If it is a kernel thread there will only be one cmdline field
    // and it will contain /proc/pid/comm.
    repeated string cmdline = 3;

    // No longer used as of Apr 2018, when the dedicated |threads| field was
    // introduced in ProcessTree.
    repeated Thread threads_deprecated = 4 [deprecated = true];
  }

  // List of processes and threads in the client. These lists are incremental
  // and not exhaustive. A process and its threads might show up separately in
  // different ProcessTree messages. A thread might event not show up at all, if
  // no sched_switch activity was detected, for instance:
  // #0 { processes: [{pid: 10, ...}], threads: [{pid: 11, tgid: 10}] }
  // #1 { threads: [{pid: 12, tgid: 10}] }
  // #2 { processes: [{pid: 20, ...}], threads: [{pid: 13, tgid: 10}] }
  repeated Process processes = 1;
  repeated Thread threads = 2;
}

// End of protos/perfetto/trace/ps/process_tree.proto

// Begin of protos/perfetto/trace/sys_stats/sys_stats.proto

// Various Linux system stat counters from /proc.
// The fields in this message can be reported at different rates and with
// different granularity. See sys_stats_config.proto.
message SysStats {
  // Counters from /proc/meminfo. Values are in KB.
  message MeminfoValue {
    optional MeminfoCounters key = 1;
    optional uint64 value = 2;
  };
  repeated MeminfoValue meminfo = 1;

  // Counter from /proc/vmstat. Units are often pages, not KB.
  message VmstatValue {
    optional VmstatCounters key = 1;
    optional uint64 value = 2;
  };
  repeated VmstatValue vmstat = 2;

  // Times in each mode, since boot. Unit: nanoseconds.
  message CpuTimes {
    optional uint32 cpu_id = 1;
    optional uint64 user_ns = 2;         // Time spent in user mode.
    optional uint64 user_ice_ns = 3;     // Time spent in user mode (low prio).
    optional uint64 system_mode_ns = 4;  // Time spent in system mode.
    optional uint64 idle_ns = 5;         // Time spent in the idle task.
    optional uint64 io_wait_ns = 6;      // Time spent waiting for I/O.
    optional uint64 irq_ns = 7;          // Time spent servicing interrupts.
    optional uint64 softirq_ns = 8;      // Time spent servicing softirqs.
  }
  repeated CpuTimes cpu_stat = 3;  // One entry per cpu.

  // Num processes forked since boot.
  // Populated only if FORK_COUNT in config.stat_counters.
  optional uint64 num_forks = 4;

  message InterruptCount {
    optional int32 irq = 1;
    optional uint64 count = 2;
  }

  // Number of interrupts, broken by IRQ number.
  // Populated only if IRQ_COUNTS in config.stat_counters.
  optional uint64 num_irq_total = 5;  // Total num of irqs serviced since boot.
  repeated InterruptCount num_irq = 6;

  // Number of softirqs, broken by softirq number.
  // Populated only if SOFTIRQ_COUNTS in config.stat_counters.
  optional uint64 num_softirq_total = 7;    // Total num of softirqs since boot.
  repeated InterruptCount num_softirq = 8;  // Per-softirq count.
}

// End of protos/perfetto/trace/sys_stats/sys_stats.proto

// Begin of protos/perfetto/trace/system_info.proto

message Utsname {
  optional string sysname = 1;
  optional string version = 2;
  optional string release = 3;
  optional string machine = 4;
}

message SystemInfo {
  optional Utsname utsname = 1;
}

// End of protos/perfetto/trace/system_info.proto

// Begin of protos/perfetto/trace/trace.proto

message Trace {
  repeated TracePacket packet = 1;

  // Do NOT add any other field here. This is just a convenience wrapper for
  // the use case of a trace being saved to a file. There are other cases
  // (streaming) where TracePacket are directly streamed without being wrapped
  // in a Trace proto. Nothing should ever rely on the full trace, all the
  // logic should be based on TracePacket(s).
}

// End of protos/perfetto/trace/trace.proto

// Begin of protos/perfetto/trace/trace_packet.proto

// The root object emitted by Perfetto. A perfetto trace is just a stream of
// TracePacket(s).
//
// Next reserved id: 13 (up to 15).
// Next id: 49.
message TracePacket {
  // TODO(primiano): in future we should add a timestamp_clock_domain field to
  // allow mixing timestamps from different clock domains.
  optional uint64 timestamp = 8;  // Timestamp [ns].

  oneof data {
    FtraceEventBundle ftrace_events = 1;
    ProcessTree process_tree = 2;
    ProcessStats process_stats = 9;
    InodeFileMap inode_file_map = 4;
    // removed field with id 5
    ClockSnapshot clock_snapshot = 6;
    SysStats sys_stats = 7;
    TrackEvent track_event = 11;

    // IDs up to 15 are reserved. They take only one byte to encode their
    // preamble so should be used for freqeuent events.

    TraceConfig trace_config = 33;
    FtraceStats ftrace_stats = 34;
    TraceStats trace_stats = 35;
    ProfilePacket profile_packet = 37;
    BatteryCounters battery = 38;
    PowerRails power_rails = 40;
    AndroidLogPacket android_log = 39;
    SystemInfo system_info = 45;
    Trigger trigger = 46;
    PackagesList packages_list = 47;
    ChromeBenchmarkMetadata chrome_benchmark_metadata = 48;

    // Only used by TrackEvent.
    ProcessDescriptor process_descriptor = 43;
    ThreadDescriptor thread_descriptor = 44;

    // This field is emitted at periodic intervals (~10s) and
    // contains always the binary representation of the UUID
    // {82477a76-b28d-42ba-81dc-33326d57a079}. This is used to be able to
    // efficiently partition long traces without having to fully parse them.
    bytes synchronization_marker = 36;

    // This field is only used for testing.
    // In previous versions of this proto this field had the id 268435455
    // This caused many problems:
    // - protozero decoder does not handle field ids larger than 999.
    // - old versions of protoc produce Java bindings with syntax errors when
    //   the field id is large enough.
    // removed field with id 900
  }

  // Trusted user id of the producer which generated this packet. Keep in sync
  // with TrustedPacket.trusted_uid.
  //
  // TODO(eseckler): Emit this field in a PacketSequenceDescriptor message
  // instead.
  oneof optional_trusted_uid { int32 trusted_uid = 3; };

  // Service-assigned identifier of the packet sequence this packet belongs to.
  // Uniquely identifies a producer + writer pair within the tracing session. A
  // value of zero denotes an invalid ID. Keep in sync with
  // TrustedPacket.trusted_packet_sequence_id.
  oneof optional_trusted_packet_sequence_id {
    uint32 trusted_packet_sequence_id = 10;
  }

  // Incrementally emitted interned data, valid only on the packet's sequence
  // (packets with the same |trusted_packet_sequence_id|). The writer will
  // usually emit new interned data in the same TracePacket that first refers to
  // it (since the last reset of interning state). It may also be emitted
  // proactively in advance of referring to them in later packets.
  optional InternedData interned_data = 12;

  // Set to true by the writer to indicate that it will re-emit any incremental
  // data for the packet's sequence before referring to it again. This includes
  // interned data as well as periodically emitted data like
  // Process/ThreadDescriptors. This flag only affects the current packet
  // sequence (see |trusted_packet_sequence_id|).
  //
  // When set to true, this TracePacket and subsequent TracePackets on the same
  // sequence will not refer to any incremental data emitted before this
  // TracePacket. For example, previously emitted interned data will be
  // re-emitted if it is referred to again.
  //
  // When the reader detects packet loss (|previous_packet_dropped|), it needs
  // to skip packets in the sequence until the next one with this flag set, to
  // ensure intact incremental data.
  optional bool incremental_state_cleared = 41;

  // Flag set by the service if, for the current packet sequence (see
  // |trusted_packet_sequence_id|), either:
  // * this is the first packet, or
  // * one or multiple packets were dropped since the last packet that the
  //   consumer read from the sequence. This can happen if chunks in the trace
  //   buffer are overridden before the consumer could read them when the trace
  //   is configured in ring buffer mode.
  //
  // When packet loss occurs, incrementally emitted data (including interned
  // data) on the sequence should be considered invalid up until the next packet
  // with |incremental_state_cleared| set.
  optional bool previous_packet_dropped = 42;
}

// End of protos/perfetto/trace/trace_packet.proto

// Begin of protos/perfetto/trace/track_event/debug_annotation.proto

// Key/value annotations provided in untyped TRACE_EVENT macros. These
// annotations are intended for debug use and are not considered a stable API
// surface. As such, they should not be relied upon to implement (new) metrics.
message DebugAnnotation {
  message NestedValue {
    enum NestedType {
      UNSPECIFIED = 0;  // leaf value.
      DICT = 1;
      ARRAY = 2;
    }
    optional NestedType nested_type = 1;

    repeated string dict_keys = 2;
    repeated NestedValue dict_values = 3;
    repeated NestedValue array_values = 4;
    optional int64 int_value = 5;
    optional double double_value = 6;
    optional bool bool_value = 7;
    optional string string_value = 8;
  }

  optional uint32 name_iid = 1;  // interned DebugAnnotationName.

  oneof value {
    bool bool_value = 2;
    uint64 uint_value = 3;
    int64 int_value = 4;
    double double_value = 5;
    string string_value = 6;
    // Pointers are stored in a separate type as the JSON output treats them
    // differently from other uint64 values.
    uint64 pointer_value = 7;
    NestedValue nested_value = 8;

    // Legacy instrumentation may not support conversion of nested data to
    // NestedValue yet.
    string legacy_json_value = 9;
  }
}

// --------------------
// Interned data types:
// --------------------

message DebugAnnotationName {
  optional uint32 iid = 1;
  optional string name = 2;
}

// End of protos/perfetto/trace/track_event/debug_annotation.proto

// Begin of protos/perfetto/trace/track_event/process_descriptor.proto

// Process-wide data that is periodically emitted by one thread per process.
// Valid for all events in packet sequences emitted by the same process.
//
// Next id: 5.
message ProcessDescriptor {
  optional int32 pid = 1;
  repeated string cmdline = 2;

  // To support old UI. New UI should determine default sorting by process_type.
  optional int32 legacy_sort_index = 3;

  // See chromium's content::ProcessType.
  enum ChromeProcessType {
    PROCESS_UNSPECIFIED = 0;
    PROCESS_BROWSER = 1;
    PROCESS_RENDERER = 2;
    PROCESS_UTILITY = 3;
    PROCESS_ZYGOTE = 4;
    PROCESS_SANDBOX_HELPER = 5;
    PROCESS_GPU = 6;
    PROCESS_PPAPI_PLUGIN = 7;
    PROCESS_PPAPI_BROKER = 8;
  }
  optional ChromeProcessType chrome_process_type = 4;
}

// End of protos/perfetto/trace/track_event/process_descriptor.proto

// Begin of protos/perfetto/trace/track_event/task_execution.proto

// TrackEvent arguments describing the execution of a task.
message TaskExecution {
  // Source location that the task was posted from.
  optional uint32 posted_from_iid = 1;  // interned SourceLocation.
}

// --------------------
// Interned data types:
// --------------------

message SourceLocation {
  optional uint32 iid = 1;

  // We intend to add a binary symbol version of this in the future.
  optional string file_name = 2;
  optional string function_name = 3;
}

// End of protos/perfetto/trace/track_event/task_execution.proto

// Begin of protos/perfetto/trace/track_event/thread_descriptor.proto

// Periodically emitted data that's common to all events emitted by the same
// thread, i.e. all events in the same packet sequence. Valid for all subsequent
// events in the same sequence.
//
// Next id: 8.
message ThreadDescriptor {
  optional int32 pid = 1;
  optional int32 tid = 2;

  // To support old UI. New UI should determine default sorting by thread_type.
  optional int32 legacy_sort_index = 3;

  enum ChromeThreadType {
    THREAD_UNSPECIFIED = 0;
    // TODO(eseckler): Add thread types.
  };
  optional ChromeThreadType chrome_thread_type = 4;

  // TODO(eseckler): Replace this with ChromeThreadType where possible.
  optional string thread_name = 5;

  // Absolute reference values. Clock values in subsequent TrackEvents can be
  // encoded accumulatively and relative to these. This reduces their var-int
  // encoding size.
  optional int64 reference_timestamp_us = 6;
  optional int64 reference_thread_time_us = 7;
}

// End of protos/perfetto/trace/track_event/thread_descriptor.proto

// Begin of protos/perfetto/trace/track_event/track_event.proto

// Trace events emitted by client instrumentation library (TRACE_EVENT macros),
// which describe activity on a track, such as a thread, task sequence, or
// asynchronous track.
//
// This message is optimized for writing and makes heavy use of data interning
// and delta encoding (e.g. of timestamps) to reduce data repetition and encoded
// data size.
//
// A TrackEvent exists in the context of its packet sequence (TracePackets
// emitted by the same producer + writer) and refers to data in preceding
// TracePackets emitted on the same sequence, both directly and indirectly. For
// example, interned data entries are emitted as part of a TracePacket and
// directly referred to from TrackEvents by their interning IDs. Attributes
// shared by all events on the same sequence (e.g. their thread and process
// association) are emitted as part of ProcessDescriptor and ThreadDescriptor
// messages in separate TracePackets instead.
//
// Next reserved id: 7 (up to 15).
// Next id: 21.
message TrackEvent {
  // Timestamp in microseconds (usually CLOCK_MONOTONIC).
  oneof timestamp {
    // Delta timestamp value since the last TrackEvent or ThreadDescriptor. To
    // calculate the absolute timestamp value, sum up all delta values of the
    // preceding TrackEvents since the last ThreadDescriptor and add the sum to
    // the |reference_timestamp| in ThreadDescriptor. This value should always
    // be positive.
    int64 timestamp_delta_us = 1;
    // Absolute value (e.g. a manually specified timestamp in the macro).
    // This is a one-off value that does not affect delta timestamp computation
    // in subsequent TrackEvents.
    int64 timestamp_absolute_us = 16;
  }

  // CPU time for the current thread (e.g., CLOCK_THREAD_CPUTIME_ID) in
  // microseconds.
  oneof thread_time {
    // Same encoding as |timestamp| fields above.
    int64 thread_time_delta_us = 2;
    // TODO(eseckler): Consider removing absolute thread time support. It's
    // currently required to support writing PHASE_COMPLETE events out-of-order,
    // but shouldn't be required anymore when we split them into begin/end.
    int64 thread_time_absolute_us = 17;
  }

  // Elapsed retired instruction count during the event.
  optional int64 thread_instruction_delta = 20;

  // We intend to add a binary symbol version of this in the future.
  repeated uint32 category_iids = 3;  // interned EventCategoryName.

  // TODO(eseckler): May also want a debug_name for untyped debug-only events.

  // Unstable key/value annotations shown in the trace viewer but not intended
  // for metrics use.
  repeated DebugAnnotation debug_annotations = 4;

  // Typed event arguments:
  optional TaskExecution task_execution = 5;
  // TODO(eseckler): New argument types go here :)

  // Apart from {category, time, thread time, tid, pid}, other legacy trace
  // event attributes are initially simply proxied for conversion to a JSON
  // trace. We intend to gradually transition these attributes to similar native
  // features in TrackEvent (e.g. async + flow events), or deprecate them
  // without replacement where transition is unsuitable.
  //
  // Next reserved id: 15 (up to 16).
  // Next id: 20.
  message LegacyEvent {
    optional uint32 name_iid = 1;  // interned LegacyEventName.
    optional int32 phase = 2;
    optional int64 duration_us = 3;
    optional int64 thread_duration_us = 4;

    reserved 5;  // used to be |flags|.

    oneof id {
      uint64 unscoped_id = 6;
      uint64 local_id = 10;
      uint64 global_id = 11;
    }
    // Additional optional scope for |id|.
    optional string id_scope = 7;

    // Consider the thread timestamps for async BEGIN/END event pairs as valid.
    optional bool use_async_tts = 9;

    // Idenfifies a flow. Flow events with the same bind_id are connected.
    optional uint64 bind_id = 8;
    // Use the enclosing slice as binding point for a flow end event instead of
    // the next slice. Flow start/step events always bind to the enclosing
    // slice.
    optional bool bind_to_enclosing = 12;

    enum FlowDirection {
      FLOW_UNSPECIFIED = 0;
      FLOW_IN = 1;
      FLOW_OUT = 2;
      FLOW_INOUT = 3;
    }
    optional FlowDirection flow_direction = 13;

    enum InstantEventScope {
      SCOPE_UNSPECIFIED = 0;
      SCOPE_GLOBAL = 1;
      SCOPE_PROCESS = 2;
      SCOPE_THREAD = 3;
    }
    optional InstantEventScope instant_event_scope = 14;

    // Override the pid/tid if the writer needs to emit events on behalf of
    // another process/thread. This should be the exception. Normally, the
    // pid+tid from ThreadDescriptor is used.
    optional int32 pid_override = 18;
    optional int32 tid_override = 19;
  }

  optional LegacyEvent legacy_event = 6;
}

// --------------------
// Interned data types:
// --------------------

message EventCategory {
  optional uint32 iid = 1;
  optional string name = 2;
}

message LegacyEventName {
  optional uint32 iid = 1;
  optional string name = 2;
}

// End of protos/perfetto/trace/track_event/track_event.proto

// Begin of protos/perfetto/trace/trigger.proto

// When a TracingSession receives a trigger it records the boot time nanoseconds
// in the TracePacket's timestamp field as well as the name of the producer that
// triggered it. We emit this data so filtering can be done on triggers received
// in the trace.
message Trigger {
  // Name of the trigger which was received.
  optional string trigger_name = 1;
  // The actual producer that activated |trigger|.
  optional string producer_name = 2;
  // The verified UID of the producer.
  optional int32 trusted_producer_uid = 3;
}

// End of protos/perfetto/trace/trigger.proto

// Begin of protos/perfetto/config/android/android_log_config.proto

message AndroidLogConfig {
  repeated AndroidLogId log_ids = 1;

  reserved 2;  // Was |poll_ms|, deprecated.

  // If set ignores all log messages whose prio is < the given value.
  optional AndroidLogPriority min_prio = 3;

  // If non-empty ignores all log messages whose tag doesn't match one of the
  // specified values.
  repeated string filter_tags = 4;
}

// End of protos/perfetto/config/android/android_log_config.proto

// Begin of protos/perfetto/config/chrome/chrome_config.proto

// When editing this file run ./tools/gen_tracing_cpp_headers_from_protos.py
// to reflect changes in the corresponding C++ headers.

message ChromeConfig {
  optional string trace_config = 1;

  // When enabled, the data source should only fill in fields in the output that
  // are not potentially privacy sensitive.
  optional bool privacy_filtering_enabled = 2;
}

// End of protos/perfetto/config/chrome/chrome_config.proto

// Begin of protos/perfetto/config/data_source_config.proto

// When editing this file run ./tools/gen_tracing_cpp_headers_from_protos.py
// to reflect changes in the corresponding C++ headers.

// The configuration that is passed to each data source when starting tracing.
message DataSourceConfig {
  // Data source unique name, e.g., "linux.ftrace". This must match
  // the name passed by the data source when it registers (see
  // RegisterDataSource()).
  optional string name = 1;

  // The index of the logging buffer where TracePacket(s) will be stored.
  // This field doesn't make a major difference for the Producer(s). The final
  // logging buffers, in fact, are completely owned by the Service. We just ask
  // the Producer to copy this number into the chunk headers it emits, so that
  // the Service can quickly identify the buffer where to move the chunks into
  // without expensive lookups on its fastpath.
  optional uint32 target_buffer = 2;

  // Set by the service to indicate the duration of the trace.
  // DO NOT SET in consumer as this will be overridden by the service.
  optional uint32 trace_duration_ms = 3;

  // Set by the service to indicate whether this tracing session has extra
  // guardrails.
  // DO NOT SET in consumer as this will be overridden by the service.
  optional bool enable_extra_guardrails = 6;

  // Set by the service to indicate which tracing session the data source
  // belongs to. The intended use case for this is checking if two data sources,
  // one of which produces metadata for the other one, belong to the same trace
  // session and hence should be linked together.
  // This field was introduced in Aug 2018 after Android P.
  optional uint64 tracing_session_id = 4;

  // Keeep the lower IDs (up to 99) for fields that are *not* specific to
  // data-sources and needs to be processed by the traced daemon.

  // All data source config fields must be marked as [lazy=true]. This prevents
  // the proto-to-cpp generator from recursing into those when generating the
  // cpp classes and polluting tracing/core with data-source-specific classes.
  // Instead they are treated as opaque strings containing raw proto bytes.

  optional FtraceConfig ftrace_config = 100 [lazy = true];
  optional InodeFileConfig inode_file_config = 102 [lazy = true];
  optional ProcessStatsConfig process_stats_config = 103 [lazy = true];
  optional SysStatsConfig sys_stats_config = 104 [lazy = true];
  optional HeapprofdConfig heapprofd_config = 105 [lazy = true];
  optional AndroidPowerConfig android_power_config = 106 [lazy = true];
  optional AndroidLogConfig android_log_config = 107 [lazy = true];

  // TODO(primiano): Figure out how to deal with this, needs a multi-side patch.
  optional ChromeConfig chrome_config = 101;

  // This is a fallback mechanism to send a free-form text config to the
  // producer. In theory this should never be needed. All the code that
  // is part of the platform (i.e. traced service) is supposed to *not* truncate
  // the trace config proto and propagate unknown fields. However, if anything
  // in the pipeline (client or backend) ends up breaking this forward compat
  // plan, this field will become the escape hatch to allow future data sources
  // to get some meaningful configuration.
  optional string legacy_config = 1000;

  // This field is only used for testing.
  optional TestConfig for_testing =
      268435455;  // 2^28 - 1, max field id for protos supported by Java.
}

// End of protos/perfetto/config/data_source_config.proto

// Begin of protos/perfetto/config/ftrace/ftrace_config.proto

// When editing this file run ./tools/gen_tracing_cpp_headers_from_protos.py
// to reflect changes in the corresponding C++ headers.

message FtraceConfig {
  repeated string ftrace_events = 1;
  repeated string atrace_categories = 2;
  repeated string atrace_apps = 3;
  // *Per-CPU* buffer size.
  optional uint32 buffer_size_kb = 10;
  optional uint32 drain_period_ms = 11;
}

// End of protos/perfetto/config/ftrace/ftrace_config.proto

// Begin of protos/perfetto/config/inode_file/inode_file_config.proto

// When editing this file run ./tools/gen_tracing_cpp_headers_from_protos.py
// to reflect changes in the corresponding C++ headers.

message InodeFileConfig {
  message MountPointMappingEntry {
    optional string mountpoint = 1;
    repeated string scan_roots = 2;
  }

  // How long to pause between batches.
  optional uint32 scan_interval_ms = 1;

  // How long to wait before the first scan in order to accumulate inodes.
  optional uint32 scan_delay_ms = 2;

  // How many inodes to scan in one batch.
  optional uint32 scan_batch_size = 3;

  // Do not scan for inodes not found in the static map.
  optional bool do_not_scan = 4;

  // If non-empty, only scan inodes corresponding to block devices named in
  // this list.
  repeated string scan_mount_points = 5;

  // When encountering an inode belonging to a block device corresponding
  // to one of the mount points in this map, scan its scan_roots instead.
  repeated MountPointMappingEntry mount_point_mapping = 6;
}

// End of protos/perfetto/config/inode_file/inode_file_config.proto

// Begin of protos/perfetto/config/power/android_power_config.proto

message AndroidPowerConfig {
  enum BatteryCounters {
    BATTERY_COUNTER_UNSPECIFIED = 0;
    BATTERY_COUNTER_CHARGE = 1;            // Coulomb counter.
    BATTERY_COUNTER_CAPACITY_PERCENT = 2;  // Charge (%).
    BATTERY_COUNTER_CURRENT = 3;           // Instantaneous current.
    BATTERY_COUNTER_CURRENT_AVG = 4;       // Avg current.
  }
  optional uint32 battery_poll_ms = 1;
  repeated BatteryCounters battery_counters = 2;

  // Where available enables per-power-rail measurements.
  optional bool collect_power_rails = 3;
}

// End of protos/perfetto/config/power/android_power_config.proto

// Begin of protos/perfetto/config/process_stats/process_stats_config.proto

// When editing this file run ./tools/gen_tracing_cpp_headers_from_protos.py
// to reflect changes in the corresponding C++ headers.

message ProcessStatsConfig {
  enum Quirks {
    QUIRKS_UNSPECIFIED = 0;

    // This has been deprecated and ignored as per 2018-05-01. Full scan at
    // startup is now disabled by default and can be re-enabled using the
    // |scan_all_processes_on_start| arg.
    DISABLE_INITIAL_DUMP = 1 [deprecated = true];

    DISABLE_ON_DEMAND = 2;
  }

  repeated Quirks quirks = 1;

  // If enabled all processes will be scanned and dumped when the trace starts.
  optional bool scan_all_processes_on_start = 2;

  // If enabled thread names are also recoded (this is redundant if sched_switch
  // is enabled).
  optional bool record_thread_names = 3;

  // If > 0 samples counters (see process_stats.proto) from
  // /proc/pid/status and oom_score_adj every X ms.
  // This is required to be > 100ms to avoid excessive CPU usage.
  // TODO(primiano): add CPU cost for change this value.
  optional uint32 proc_stats_poll_ms = 4;

  // If empty samples stats for all processes. If non empty samples stats only
  // for processes matching the given string in their argv0 (i.e. the first
  // entry of /proc/pid/cmdline).
  // TODO(primiano): implement this feature.
  // repeated string proc_stats_filter = 5;

  // This is required to be either = 0 or a multiple of |proc_stats_poll_ms|
  // (default: |proc_stats_poll_ms|). If = 0, will be set to
  // |proc_stats_poll_ms|. Non-multiples will be rounded down to the nearest
  // multiple.
  optional uint32 proc_stats_cache_ttl_ms = 6;
}

// End of protos/perfetto/config/process_stats/process_stats_config.proto

// Begin of protos/perfetto/config/sys_stats/sys_stats_config.proto

// When editing this file run ./tools/gen_tracing_cpp_headers_from_protos.py
// to reflect changes in the corresponding C++ headers.

// This file defines the configuration for the Linux /proc poller data source,
// which injects counters in the trace.
// Counters that are needed in the trace must be explicitly listed in the
// *_counters fields. This is to avoid spamming the trace with all counters
// at all times.
// The sampling rate is configurable. All polling rates (*_period_ms) need
// to be integer multiples of each other.
// OK:     [10ms, 10ms, 10ms],  [10ms, 20ms, 10ms],  [10ms, 20ms, 60ms]
// Not OK: [10ms, 10ms, 11ms],  [10ms, 15ms, 20ms]
message SysStatsConfig {
  // Polls /proc/meminfo every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  // Cost: 0.3 ms [read] + 0.07 ms [parse + trace injection]
  optional uint32 meminfo_period_ms = 1;

  // Only the counters specified below are reported.
  repeated MeminfoCounters meminfo_counters = 2;

  // Polls /proc/vmstat every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  // Cost: 0.2 ms [read] + 0.3 ms [parse + trace injection]
  optional uint32 vmstat_period_ms = 3;
  repeated VmstatCounters vmstat_counters = 4;

  // Pols /proc/stat every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  // Cost: 4.1 ms [read] + 1.9 ms [parse + trace injection]
  optional uint32 stat_period_ms = 5;
  enum StatCounters {
    STAT_UNSPECIFIED = 0;
    STAT_CPU_TIMES = 1;
    STAT_IRQ_COUNTS = 2;
    STAT_SOFTIRQ_COUNTS = 3;
    STAT_FORK_COUNT = 4;
  }
  repeated StatCounters stat_counters = 6;
}

// End of protos/perfetto/config/sys_stats/sys_stats_config.proto

// Begin of protos/perfetto/config/test_config.proto

// When editing this file run ./tools/gen_tracing_cpp_headers_from_protos.py
// to reflect changes in the corresponding C++ headers.

// The configuration for a fake producer used in tests.
message TestConfig {
  message DummyFields {
    optional uint32 field_uint32 = 1;
    optional int32 field_int32 = 2;
    optional uint64 field_uint64 = 3;
    optional int64 field_int64 = 4;
    optional fixed64 field_fixed64 = 5;
    optional sfixed64 field_sfixed64 = 6;
    optional fixed32 field_fixed32 = 7;
    optional sfixed32 field_sfixed32 = 8;
    optional double field_double = 9;
    optional float field_float = 10;
    optional sint64 field_sint64 = 11;
    optional sint32 field_sint32 = 12;
    optional string field_string = 13;
    optional bytes field_bytes = 14;
  }

  // The number of messages the fake producer should send.
  optional uint32 message_count = 1;

  // The maximum number of messages which should be sent each second.
  // The actual obserced speed may be lower if the producer is unable to
  // work fast enough.
  // If this is zero or unset, the producer will send as fast as possible.
  optional uint32 max_messages_per_second = 2;

  // The seed value for a simple multiplicative congruential pseudo-random
  // number sequence.
  optional uint32 seed = 3;

  // The size of each message in bytes. Should be greater than or equal 5 to
  // account for the number of bytes needed to encode the random number and a
  // null byte for the string.
  optional uint32 message_size = 4;

  // Whether the producer should send a event batch when the data source is
  // is initially registered.
  optional bool send_batch_on_register = 5;

  optional DummyFields dummy_fields = 6;
}

// End of protos/perfetto/config/test_config.proto

// Begin of protos/perfetto/config/trace_config.proto

// When editing this file run ./tools/gen_tracing_cpp_headers_from_protos
// to reflect changes in the corresponding C++ headers.

// The overall config that is used when starting a new tracing session through
// ProducerPort::StartTracing().
// It contains the general config for the logging buffer(s) and the configs for
// all the data source being enabled.
//
// Next id: 23.
message TraceConfig {
  message BufferConfig {
    optional uint32 size_kb = 1;

    reserved 2;  // |page_size|, now deprecated.
    reserved 3;  // |optimize_for|, now deprecated.

    enum FillPolicy {
      UNSPECIFIED = 0;

      // Default behavior. The buffer operates as a conventional ring buffer.
      // If the writer is faster than the reader (or if the reader reads only
      // after tracing is stopped) newly written packets will overwrite old
      // packets.
      RING_BUFFER = 1;

      // Behaves like RING_BUFFER as long as there is space in the buffer or
      // the reader catches up with the writer. As soon as the writer hits
      // an unread chunk, it stops accepting new data in the buffer.
      DISCARD = 2;
    }
    optional FillPolicy fill_policy = 4;
  }
  repeated BufferConfig buffers = 1;

  message DataSource {
    // Filters and data-source specific config. It contains also the unique name
    // of the data source, the one passed in the  DataSourceDescriptor when they
    // register on the service.
    optional protos.DataSourceConfig config = 1;

    // Optional. If multiple producers (~processes) expose the same data source
    // and |producer_name_filter| != "", the data source is enabled only for
    // producers whose names match any of the producer_name_filter below.
    // The |producer_name_filter| has to be an exact match. (TODO(primiano):
    // support wildcards or regex).
    // This allows to enable a data source only for specific processes.
    // The "repeated" field has OR sematics: specifying a filter ["foo", "bar"]
    // will enable data source on both "foo" and "bar" (if existent).
    repeated string producer_name_filter = 2;
  }
  repeated DataSource data_sources = 2;

  // Config for builtin trace packets emitted by perfetto like trace stats,
  // system info, etc.
  message BuiltinDataSource {
    // Disable emitting clock timestamps into the trace.
    optional bool disable_clock_snapshotting = 1;

    optional bool disable_trace_config = 2;

    optional bool disable_system_info = 3;
  }
  optional BuiltinDataSource builtin_data_sources = 20;

  // If specified, the trace will be stopped |duration_ms| after starting.
  // However in case of traces with triggers, see
  // TriggerConfig.trigger_timeout_ms instead.
  optional uint32 duration_ms = 3;

  // This is set when --dropbox is passed to the Perfetto command line client
  // and enables guardrails that limit resource usage for traces requested
  // by statsd.
  optional bool enable_extra_guardrails = 4;

  enum LockdownModeOperation {
    LOCKDOWN_UNCHANGED = 0;
    LOCKDOWN_CLEAR = 1;
    LOCKDOWN_SET = 2;
  }
  // Reject producers that are not running under the same UID as the tracing
  // service.
  optional LockdownModeOperation lockdown_mode = 5;

  message ProducerConfig {
    // Identifies the producer for which this config is for.
    optional string producer_name = 1;

    // Specifies the preferred size of the shared memory buffer. If the size is
    // larger than the max size, the max will be used. If it is smaller than
    // the page size or doesn't fit pages evenly into it, it will fall back to
    // the size specified by the producer or finally the default shared memory
    // size.
    optional uint32 shm_size_kb = 2;

    // Specifies the preferred size of each page in the shared memory buffer.
    // Must be an integer multiple of 4K.
    optional uint32 page_size_kb = 3;
  }

  repeated ProducerConfig producers = 6;

  // Contains statsd-specific metadata about an alert associated with the trace.
  message StatsdMetadata {
    // The identifier of the alert which triggered this trace.
    optional int64 triggering_alert_id = 1;
    // The uid which registered the triggering configuration with statsd.
    optional int32 triggering_config_uid = 2;
    // The identifier of the config which triggered the alert.
    optional int64 triggering_config_id = 3;
    // The identifier of the subscription which triggered this trace.
    optional int64 triggering_subscription_id = 4;
  }

  // Statsd-specific metadata.
  optional StatsdMetadata statsd_metadata = 7;

  // When true, the EnableTracing() request must also provide a file descriptor.
  // The service will then periodically read packets out of the trace buffer and
  // store it into the passed file.
  optional bool write_into_file = 8;

  // Optional. If non-zero tunes the write period. A min value of 100ms is
  // enforced (i.e. smaller values are ignored).
  optional uint32 file_write_period_ms = 9;

  // Optional. When non zero the periodic write stops once at most X bytes
  // have been written into the file. Tracing is disabled when this limit is
  // reached, even if |duration_ms| has not been reached yet.
  optional uint64 max_file_size_bytes = 10;

  // Contains flags which override the default values of the guardrails inside
  // Perfetto. These values are only affect userdebug builds.
  message GuardrailOverrides {
    // Override the default limit (in bytes) for uploading data to server within
    // a 24 hour period.
    optional uint64 max_upload_per_day_bytes = 1;
  }

  optional GuardrailOverrides guardrail_overrides = 11;

  // When true, data sources are not started until an explicit call to
  // StartTracing() on the consumer port. This is to support early
  // initialization and fast trace triggering. This can be used only when the
  // Consumer explicitly triggers the StartTracing() method.
  // This should not be used in a remote trace config via statsd, doing so will
  // result in a hung trace session.
  optional bool deferred_start = 12;

  // When set, it periodically issues a Flush() to all data source, forcing them
  // to commit their data into the tracing service. This can be used for
  // quasi-real-time streaming mode and to guarantee some partial ordering of
  // events in the trace in windows of X ms.
  optional uint32 flush_period_ms = 13;

  // Wait for this long for producers to acknowledge flush requests.
  // Default 5s.
  optional uint32 flush_timeout_ms = 14;

  reserved 15;  // |disable_clock_snapshotting| moved.

  // Android-only. If set, sends an intent to the Traceur system app when the
  // trace ends to notify it about the trace readiness.
  optional bool notify_traceur = 16;

  // Triggers allow producers to start or stop the tracing session when an event
  // occurs.
  //
  // For example if we are tracing probabilistically, most traces will be
  // uninteresting. Triggers allow us to keep only the interesting ones such as
  // those traces during which the device temperature reached a certain
  // threshold. In this case the producer can activate a trigger to keep
  // (STOP_TRACING) the trace, otherwise it can also begin a trace
  // (START_TRACING) because it knows something is about to happen.
  message TriggerConfig {
    enum TriggerMode {
      UNSPECIFIED = 0;

      // When this mode is chosen, data sources are not started until one of the
      // |triggers| are received. This supports early initialization and fast
      // starting of the tracing system. On triggering, the session will then
      // record for |stop_delay_ms|. However if no trigger is seen
      // after |trigger_timeout_ms| the session will be stopped and no data will
      // be returned.
      START_TRACING = 1;

      // When this mode is chosen, the session will be started via the normal
      // EnableTracing() & StartTracing(). If no trigger is ever seen
      // the session will be stopped after |trigger_timeout_ms| and no data will
      // be returned. However if triggered the trace will stop after
      // |stop_delay_ms| and any data in the buffer will be returned to the
      // consumer.
      STOP_TRACING = 2;
    }
    optional TriggerMode trigger_mode = 1;

    message Trigger {
      // The producer must specify this name to activate the trigger.
      optional string name = 1;

      // The a std::regex that will match the producer that can activate this
      // trigger. This is optional. If unset any producers can activate this
      // trigger.
      optional string producer_name_regex = 2;

      // After a trigger is received either in START_TRACING or STOP_TRACING
      // mode then the trace will end |stop_delay_ms| after triggering.
      optional uint32 stop_delay_ms = 3;
    }
    // A list of triggers which are related to this configuration. If ANY
    // trigger is seen then an action will be performed based on |trigger_mode|.
    repeated Trigger triggers = 2;

    // Required and must be positive if a TriggerConfig is specified. This is
    // how long this TraceConfig should wait for a trigger to arrive. After this
    // period of time if no trigger is seen the TracingSession will be cleaned
    // up.
    optional uint32 trigger_timeout_ms = 3;
  }
  optional TriggerConfig trigger_config = 17;

  // When this is non-empty the perfetto command line tool will ignore the rest
  // of this TraceConfig and instead connect to the perfetto service as a
  // producer and send these triggers, potentially stopping or starting traces
  // that were previous configured to use a TriggerConfig.
  repeated string activate_triggers = 18;

  // Configuration for trace contents that reference earlier trace data. For
  // example, a data source might intern strings, and emit packets containing
  // {interned id : string} pairs. Future packets from that data source can then
  // use the interned ids instead of duplicating the raw string contents. The
  // trace parser will then need to use that interning table to fully interpret
  // the rest of the trace.
  message IncrementalStateConfig {
    // If nonzero, notify eligible data sources to clear their incremental state
    // periodically, with the given period. The notification is sent only to
    // data sources that have |handles_incremental_state_clear| set in their
    // DataSourceDescriptor. The notification requests that the data source
    // stops referring to past trace contents. This is particularly useful when
    // tracing in ring buffer mode, where it is not exceptional to overwrite old
    // trace data.
    //
    // Warning: this time-based global clearing is likely to be removed in the
    // future, to be replaced with a smarter way of sending the notifications
    // only when necessary.
    optional uint32 clear_period_ms = 1;
  }
  optional IncrementalStateConfig incremental_state_config = 21;

  // Additional guardrail used by the Perfetto command line client.
  // On user builds when --dropbox is set perfetto will refuse to trace unless
  // this is also set.
  // Added in Q.
  optional bool allow_user_build_tracing = 19;

  // If set the tracing service will ensure there is at most one tracing session
  // with this key.
  optional string unique_session_name = 22;
}

// End of protos/perfetto/config/trace_config.proto

// Begin of protos/perfetto/config/profiling/heapprofd_config.proto

// Configuration for go/heapprofd.
message HeapprofdConfig {
  message ContinuousDumpConfig {
    // ms to wait before first dump.
    optional uint32 dump_phase_ms = 5;
    // ms to wait between following dumps.
    optional uint32 dump_interval_ms = 6;
  };

  // Set to 1 for perfect accuracy.
  // Otherwise, sample every sample_interval_bytes on average.
  //
  // See https://docs.perfetto.dev/#/heapprofd?id=sampling-interval for more
  // details.
  optional uint64 sampling_interval_bytes = 1;

  // E.g. surfaceflinger, com.android.phone
  // This input is normalized in the following way: if it contains slashes,
  // everything up to the last slash is discarded. If it contains "@",
  // everything after the first @ is discared.
  // E.g. /system/bin/surfaceflinger@1.0 normalizes to surfaceflinger.
  // This transformation is also applied to the processes' command lines when
  // matching.
  repeated string process_cmdline = 2;

  // For watermark based triggering or local debugging.
  repeated uint64 pid = 4;

  // Profile all processes eligible for profiling on the system.
  // See https://docs.perfetto.dev/#/heapprofd?id=target-processes for which
  // processes are eligible.
  //
  // On unmodified userdebug builds, this will lead to system crashes. Zygote
  // will crash when trying to launch a new process as it will have an
  // unexpected open socket to heapprofd.
  //
  // heapprofd will likely be overloaded by the amount of data for low
  // sampling intervals.
  optional bool all = 5;

  // Do not emit function names for mappings starting with this prefix.
  // E.g. /system to not emit symbols for any system libraries.
  repeated string skip_symbol_prefix = 7;

  // Dump once at the end of the trace, emitting the heap dump at maximum
  // memory usage.
  // optional bool retain_max = 5;  // TODO(fmayer): Implement

  // Dump at a predefined interval.
  optional ContinuousDumpConfig continuous_dump_config = 6;

  // Size of the shared memory buffer between the profiled processes and
  // heapprofd. Defaults to 8 MiB. If larger than 500 MiB, truncated to 500
  // MiB.
  //
  // Needs to be:
  // * at least 8192,
  // * a power of two,
  // * a multiple of 4096.
  optional uint64 shmem_size_bytes = 8;

  // When the shmem buffer is full, block the client instead of ending the
  // trace. Use with caution as this will significantly slow down the target
  // process.
  optional bool block_client = 9;

  // Do not profile processes from startup, only match already running
  // processes.
  //
  // Can not be set at the same time as no_running.
  optional bool no_startup = 10;

  // Do not profile running processes. Only match processes on startup.
  //
  // Can not be set at the same time as no_startup.
  optional bool no_running = 11;

  // Gather information on how many bytes of allocations are on non-referenced
  // pages. The way to use this generally is:
  // 1. Start profile of app.
  // 2. Start app.
  // 3. echo 1 > /proc/$APP_PID/clear_refs.
  // 4. Do operations.
  // 5. End profile.
  //
  // You can then find the allocations that were not used for the operations you
  // did in step 4.
  optional bool idle_allocations = 12;
}

// End of protos/perfetto/config/profiling/heapprofd_config.proto
