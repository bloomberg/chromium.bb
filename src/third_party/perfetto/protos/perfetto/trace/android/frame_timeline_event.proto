/*
 * Copyright (C) 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto2";
package perfetto.protos;

// Generated by SurfaceFlinger's FrameTimeline (go/adaptive-scheduling-fr).
// Used in comparing the expected timeline of a frame to the actual timeline.
// Key terms:
//    1) DisplayFrame - represents SurfaceFlinger's work on a frame(composited)
//    2) SurfaceFrame - represents App's work on its frame
//    3) Timeline = start to end of a component's(app/SF) work on a frame.
// SurfaceFlinger composites frames from many apps together, so
//    One DisplayFrame can map to N SurfaceFrame(s)
// This relationship can be reconstructed by using
//    DisplayFrame.token = SurfaceFrame.display_frame_token
message FrameTimelineEvent {
  // Specifies which component was the main source for the jank.
  enum JankType {
    JANK_UNSPECIFIED = 0;
    JANK_NONE = 1;
    JANK_SF_SCHEDULING = 2;
    JANK_PREDICTION_ERROR = 3;
    JANK_DISPLAY_HAL = 4;
    JANK_SF_DEADLINE_MISSED = 5;
    JANK_APP_DEADLINE_MISSED = 6;
    JANK_BUFFER_STUFFING = 7;
    JANK_UNKNOWN = 8;
  };

  // Specifies how a frame was presented on screen w.r.t. timing.
  // Can be different for SurfaceFrame and DisplayFrame.
  enum PresentType {
    PRESENT_UNSPECIFIED = 0;
    PRESENT_ON_TIME = 1;
    PRESENT_LATE = 2;
    PRESENT_EARLY = 3;
    PRESENT_DROPPED = 4;
  };

  // Represents the app's work on a frame.
  // Next id: 13
  message SurfaceFrame {
    // Token received by the app for its work. Can be shared between multiple
    // layers of the same app (example: pip mode).
    optional int64 token = 1;

    // The corresponding DisplayFrame token is required to link the App's work
    // with SurfaceFlinger's work. Many SurfaceFrames can be mapped to a single
    // DisplayFrame.
    // this.display_frame_token = DisplayFrame.token
    optional int64 display_frame_token = 12;

    optional PresentType present_type = 2;
    optional bool on_time_finish = 3;
    optional bool gpu_composition = 4;
    optional JankType jank_type = 5;

    // Timestamps in nanoseconds using CLOCK_MONOTONIC.
    // Expected timeline = expected_start to expected_end.
    optional int64 expected_start_ns = 6;
    optional int64 expected_end_ns = 7;

    // (b/172587309) Apps currently do not provide actual start time.
    // Actual timeline = expected_start to actual_end.
    optional int64 actual_start_ns = 8;
    // If two SufaceFrames have the same token and same pid, then
    //  actual timeline =
    //    expected_start to max(frame1.actual_end, frame2.actual_end)
    optional int64 actual_end_ns = 9;

    optional string layer_name = 10;
    optional int32 pid = 11;
  };

  // Represents the SurfaceFlinger's work on a frame.
  message DisplayFrame {
    // Token received by SurfaceFlinger for its work
    // this.token = SurfaceFrame.display_frame_token
    optional int64 token = 1;
    optional PresentType present_type = 2;
    optional bool on_time_finish = 3;
    optional bool gpu_composition = 4;
    optional JankType jank_type = 5;

    // Timestamps in nanoseconds using CLOCK_MONOTONIC.
    // Expected timeline = expected_start to expected_end.
    optional int64 expected_start_ns = 6;
    optional int64 expected_end_ns = 7;

    // Actual timeline = actual_start to actual_end.
    optional int64 actual_start_ns = 8;
    optional int64 actual_end_ns = 9;
  };

  oneof event {
    DisplayFrame display_frame = 1;
    SurfaceFrame surface_frame = 2;
  }
}
