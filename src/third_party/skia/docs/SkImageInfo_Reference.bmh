#Topic Image_Info
#Alias Image_Info_Reference ##

Image_Info specifies the dimensions and encoding of the pixels in a Bitmap.
The dimensions are integral width and height. The encoding is how pixel
bits describe Color_Alpha, transparency; Color components red, blue,
and green; and Color_Space, the range and linearity of colors.

Image_Info describes an uncompressed raster pixels. In contrast, Image
additionally describes compressed pixels like PNG, and Surface describes
destinations on the GPU. Image and Surface may be specified by Image_Info,
but Image and Surface may not contain Image_Info.

#Subtopic Overview
#Populate
##

#Subtopic Constant
#Populate
##

# ------------------------------------------------------------------------------
#Subtopic Alpha_Type
#Line # encoding for pixel transparency ##
#Alias Alpha_Type ##
#Alias Alpha_Types ##

#PhraseDef list_of_alpha_types
kUnknown_SkAlphaType, kOpaque_SkAlphaType, kPremul_SkAlphaType,
kUnpremul_SkAlphaType
##

#Enum SkAlphaType
#Line # encoding for pixel transparency ##

#Code
    enum SkAlphaType {
        kUnknown_SkAlphaType,
        kOpaque_SkAlphaType,
        kPremul_SkAlphaType,
        kUnpremul_SkAlphaType,
        kLastEnum_SkAlphaType = kUnpremul_SkAlphaType,
    };
##

Describes how to interpret the alpha component of a pixel. A pixel may
be opaque, or Color_Alpha, describing multiple levels of transparency.

In simple blending, Color_Alpha weights the draw color and the destination
color to create a new color. If alpha describes a weight from zero to one:

#Code
    new color = draw color * alpha + destination color * (1 - alpha)
##

In practice alpha is encoded in two or more bits, where 1.0 equals all bits set.

RGB may have Color_Alpha included in each component value; the stored
value is the original RGB multiplied by Color_Alpha. Premultiplied color
components improve performance.

#Const kUnknown_SkAlphaType 0
#Line # uninitialized ##
    Alpha_Type is uninitialized.
##
#Const kOpaque_SkAlphaType 1
#Line # pixel is opaque ##
#Details Opaque
    Pixels are opaque. The Color_Type must have no explicit alpha
    component, or all alpha components must be set to their maximum value.
##
#Const kPremul_SkAlphaType 2
#Line # pixel components are Premultiplied by Alpha ##
#Details Premul
    Pixels have Alpha Premultiplied into color components.
    Surface pixels must be Premultiplied.
##
#Const kUnpremul_SkAlphaType 3
#Line # pixel components are independent of Alpha ##
#Details Unpremul
    Pixel color component values are independent of alpha value.
    Images generated from encoded data like PNG do not Premultiply pixel color
    components. kUnpremul_SkAlphaType is supported for Image pixels, but not for
    Surface pixels.
##
#Const kLastEnum_SkAlphaType 3
#Line # last valid value ##
    Used by tests to iterate through all valid values.
##

#NoExample
##

#SeeAlso SkColorType SkColorSpace

#Enum SkAlphaType ##

#Subtopic Opaque
#Line # hints all pixels are opaque ##
Use kOpaque_SkAlphaType as a hint to optimize drawing when Alpha component
of all pixel is set to its maximum value of 1.0; all alpha component bits are set.
If Image_Info is set to kOpaque_SkAlphaType but all alpha values are not 1.0,
results are undefined.

#Example
#Height 64
#Description
SkPreMultiplyARGB parameter a is set to 255, its maximum value, and is interpreted
as Color_Alpha of 1.0. kOpaque_SkAlphaType may be set to improve performance.
If SkPreMultiplyARGB parameter a is set to a value smaller than 255,
kPremul_SkAlphaType must be used instead to avoid undefined results.
The four displayed values are the original component values, though not necessarily
in the same order.
##
    SkPMColor color = SkPreMultiplyARGB(255, 50, 100, 150);
    SkString s;
    s.printf("%u %u %u %u", SkColorGetA(color), SkColorGetR(color),
                            SkColorGetG(color), SkColorGetB(color));
    SkPaint paint;
    paint.setAntiAlias(true);
    canvas->drawString(s, 10, 62, paint);
    canvas->scale(50, 50);
    SkBitmap bitmap;
    SkImageInfo imageInfo = SkImageInfo::Make(1, 1, kN32_SkColorType, kOpaque_SkAlphaType);
    if (bitmap.installPixels(imageInfo, (void*) &color, imageInfo.minRowBytes())) {
        canvas->drawBitmap(bitmap, 0, 0);
    }
##

#Subtopic Opaque ##

#Subtopic Premul
#Line # stores components scaled by Alpha ##
Use kPremul_SkAlphaType when stored color components are the original color
multiplied by the alpha component. The alpha component range of 0.0 to 1.0 is
achieved by dividing the integer bit value by the maximum bit value.

#Code
stored color = original color * alpha / max alpha
##

The color component must be equal to or smaller than the alpha component,
or the results are undefined.

#Example
#Description
SkPreMultiplyARGB parameter a is set to 150, less than its maximum value, and is
interpreted as Color_Alpha of about 0.6. kPremul_SkAlphaType must be set, since
SkPreMultiplyARGB parameter a is set to a value smaller than 255,
to avoid undefined results.
The four displayed values reflect that the alpha component has been multiplied
by the original color.
##
#Height 64
    SkPMColor color = SkPreMultiplyARGB(150, 50, 100, 150);
    SkString s;
    s.printf("%u %u %u %u", SkColorGetA(color), SkColorGetR(color),
                            SkColorGetG(color), SkColorGetB(color));
    SkPaint paint;
    paint.setAntiAlias(true);
    canvas->drawString(s, 10, 62, paint);
    canvas->scale(50, 50);
    SkBitmap bitmap;
    SkImageInfo imageInfo = SkImageInfo::Make(1, 1, kN32_SkColorType, kPremul_SkAlphaType);
    if (bitmap.installPixels(imageInfo, (void*) &color, imageInfo.minRowBytes())) {
        canvas->drawBitmap(bitmap, 0, 0);
    }
##

#Subtopic Premul ##

#Subtopic Unpremul
#Line # stores components without Alpha scaling ##
Use kUnpremul_SkAlphaType if stored color components are not divided by the
alpha component. Some drawing destinations may not support
kUnpremul_SkAlphaType.

#Bug 7079
#Example
#Height 64
#Description
SkColorSetARGB parameter a is set to 150, less than its maximum value, and is
interpreted as Color_Alpha of about 0.6. color is not Premultiplied;
color components may have values greater than color alpha.
The four displayed values are the original component values, though not necessarily
in the same order.
##
    SkColor color = SkColorSetARGB(150, 50, 100, 255);
    SkString s;
    s.printf("%u %u %u %u", SkColorGetA(color), SkColorGetR(color),
                            SkColorGetG(color), SkColorGetB(color));
    SkPaint paint;
    paint.setAntiAlias(true);
    canvas->drawString(s, 10, 62, paint);
    canvas->scale(50, 50);
    SkBitmap bitmap;
    SkImageInfo imageInfo = SkImageInfo::Make(1, 1, kN32_SkColorType, kUnpremul_SkAlphaType);
    if (bitmap.installPixels(imageInfo, (void*) &color, imageInfo.minRowBytes())) {
        canvas->drawBitmap(bitmap, 0, 0);
    }
##

#Subtopic Unpremul ##

#Method static inline bool SkAlphaTypeIsOpaque(SkAlphaType at)
#In Property
#Line # returns if Alpha_Type equals kOpaque_SkAlphaType ##

Returns true if Alpha_Type equals kOpaque_SkAlphaType. kOpaque_SkAlphaType is a
hint that the Color_Type is opaque, or that all Color_Alpha values are set to
their 1.0 equivalent. If Alpha_Type is kOpaque_SkAlphaType, and Color_Type is not
opaque, then the result of drawing any pixel with a Color_Alpha value less than
1.0 is undefined.

#Param at one of: #list_of_alpha_types#
##
#Return true if at equals kOpaque_SkAlphaType ##
#NoExample
##
##

#Subtopic Alpha_Type ##

# ------------------------------------------------------------------------------
#Subtopic Color_Type
#Line # encoding for pixel color ##
#Alias Color_Type ##
#Alias Color_Types ##

#PhraseDef list_of_color_types
kUnknown_SkColorType, kAlpha_8_SkColorType, kRGB_565_SkColorType,
kARGB_4444_SkColorType, kRGBA_8888_SkColorType, kRGB_888x_SkColorType,
kBGRA_8888_SkColorType, kRGBA_1010102_SkColorType, kRGB_101010x_SkColorType,
kGray_8_SkColorType, kRGBA_F16_SkColorType
##

#Enum SkColorType
#Line # encoding for pixel color ##

#Code
    enum SkColorType {
        kUnknown_SkColorType,
        kAlpha_8_SkColorType,
        kRGB_565_SkColorType,
        kARGB_4444_SkColorType,
        kRGBA_8888_SkColorType,
        kRGB_888x_SkColorType,
        kBGRA_8888_SkColorType,
        kRGBA_1010102_SkColorType,
        kRGB_101010x_SkColorType,
        kGray_8_SkColorType,
        kRGBA_F16_SkColorType,
        kRGBA_F32_SkColorType,
        kLastEnum_SkColorType = kRGBA_F32_SkColorType,
###$
    #if SK_PMCOLOR_BYTE_ORDER(B,G,R,A)
        kN32_SkColorType = kBGRA_8888_SkColorType,
    #elif SK_PMCOLOR_BYTE_ORDER(R,G,B,A)
        kN32_SkColorType = kRGBA_8888_SkColorType,
    #else
        #error "SK_*32_SHIFT values must correspond to BGRA or RGBA byte order"
    #endif
$$$#
    };
#Code ##

Describes how pixel bits encode color. A pixel may be an alpha mask, a
Grayscale, RGB, or ARGB.

kN32_SkColorType selects the native 32-bit ARGB format. On Little_Endian
processors, pixels containing 8-bit ARGB components pack into 32-bit
kBGRA_8888_SkColorType. On Big_Endian processors, pixels pack into 32-bit
kRGBA_8888_SkColorType.

#Const kUnknown_SkColorType 0
#Line # uninitialized ##
    Color_Type is set to kUnknown_SkColorType by default. If set,
    encoding format and size is unknown.
##

#Const kAlpha_8_SkColorType 1
#Line # pixel with Alpha in 8-bit byte ##
#Details Alpha_8
    Stores 8-bit byte pixel encoding that represents transparency. Value of zero
    is completely transparent; a value of 255 is completely opaque.
##

#Const kRGB_565_SkColorType 2
#Line # pixel with 5 bits red, 6 bits green, 5 bits blue, in 16-bit word ##
#Details RGB_565
    Stores 16-bit word pixel encoding that contains five bits of blue,
    six bits of green, and five bits of red.
##

#Const kARGB_4444_SkColorType 3
#Line # pixel with 4 bits for alpha, red, green, blue; in 16-bit word ##
#Details ARGB_4444
    Stores 16-bit word pixel encoding that contains four bits of alpha,
    four bits of blue, four bits of green, and four bits of red.
##

#Const kRGBA_8888_SkColorType 4
#Line # pixel with 8 bits for red, green, blue, alpha; in 32-bit word ##
#Details RGBA_8888
    Stores 32-bit word pixel encoding that contains eight bits of red,
    eight bits of green, eight bits of blue, and eight bits of alpha.
##

#Const kRGB_888x_SkColorType 5
#Line # pixel with 8 bits each for red, green, blue; in 32-bit word ##
#Details RGB_888
    Stores 32-bit word pixel encoding that contains eight bits of red,
    eight bits of green, eight bits of blue, and eight unused bits.
##

#Const kBGRA_8888_SkColorType 6
#Line # pixel with 8 bits for blue, green, red, alpha; in 32-bit word ##
#Details BGRA_8888
    Stores 32-bit word pixel encoding that contains eight bits of blue,
    eight bits of green, eight bits of red, and eight bits of alpha.
##

#Const kRGBA_1010102_SkColorType 7
#Line # 10 bits for red, green, blue; 2 bits for alpha; in 32-bit word ##
#Details RGBA_1010102
    Stores 32-bit word pixel encoding that contains ten bits of red,
    ten bits of green, ten bits of blue, and two bits of alpha.
##

#Const kRGB_101010x_SkColorType 8
#Line # pixel with 10 bits each for red, green, blue; in 32-bit word ##
#Details RGB_101010
    Stores 32-bit word pixel encoding that contains ten bits of red,
    ten bits of green, ten bits of blue, and two unused bits.
##

#Const kGray_8_SkColorType 9
#Line # pixel with Grayscale level in 8-bit byte ##
#Details Gray_8
    Stores 8-bit byte pixel encoding that equivalent to equal values for red,
    blue, and green, representing colors from black to white.
##

#Const kRGBA_F16_SkColorType 10
#Line # pixel with half floats for red, green, blue, alpha; in 64-bit word ##
#Details RGBA_F16
    Stores 64-bit word pixel encoding that contains 16 bits of blue,
    16 bits of green, 16 bits of red, and 16 bits of alpha. Each component
    is encoded as a half float.
##

#Const kRGBA_F32_SkColorType 11
#Line # pixel using C float for red, green, blue, alpha; in 128-bit word ##
#Details RGBA_F32
    Stores 128-bit word pixel encoding that contains 32 bits of blue,
    32 bits of green, 32 bits of red, and 32 bits of alpha. Each component
    is encoded as a single precision float.
##

#Const kLastEnum_SkColorType 11
#NoJustify
#Line # last valid value ##
    Used by tests to iterate through all valid values.
##

#Const kN32_SkColorType 4 or 6
#Alias Native_Color_Type ##
#NoJustify
#Line # native ARGB 32-bit encoding ##
    Encodes ARGB as either kRGBA_8888_SkColorType or
    kBGRA_8888_SkColorType, whichever is native to the platform.
##

#NoExample
##

#SeeAlso SkAlphaType SkColorSpace

#Enum SkColorType ##

#Subtopic Alpha_8
#Line # encodes transparency only ##
    Alpha pixels encode transparency without color information. Value of zero is
    completely transparent; a value of 255 is completely opaque. Bitmap
    pixels do not visibly draw, because its pixels have no color information.
    When SkColorType is set to kAlpha_8_SkColorType, the paired SkAlphaType is
    ignored.

    #Example
        #Description
        Alpha pixels can modify another draw. orangePaint fills the bounds of bitmap,
        with its transparency set to alpha8 pixel value.
        ##
        #Height 64
        canvas->scale(16, 16);
        SkBitmap bitmap;
        SkImageInfo imageInfo = SkImageInfo::Make(2, 2, kAlpha_8_SkColorType, kOpaque_SkAlphaType);
        bitmap.allocPixels(imageInfo);
        SkCanvas offscreen(bitmap);
        offscreen.clear(SK_ColorGREEN);
        SkPaint orangePaint;
        orangePaint.setARGB(0xFF, 0xFF, 0xA5, 0x00);
        canvas->drawBitmap(bitmap, 0, 0, &orangePaint);
        uint8_t alpha8[] = { 0xFF, 0xBB, 0x77, 0x33 };
        SkPixmap alphaPixmap(imageInfo, &alpha8, imageInfo.minRowBytes());
        if (bitmap.writePixels(alphaPixmap, 0, 0)) {
            canvas->drawBitmap(bitmap, 2, 2, &orangePaint);
        }
    ##
    #SeeAlso Alpha Gray_8
##

#Subtopic RGB_565
#Line # encodes RGB in 16 bits ##
    kRGB_565_SkColorType encodes RGB to fit in a 16-bit word. Red and blue
    components use five bits describing 32 levels. Green components, more sensitive
    to the eye, use six bits describing 64 levels. kRGB_565_SkColorType has no
    bits for Alpha.
    
    Pixels are fully opaque as if its Color_Alpha was set to one, and should
    always be paired with kOpaque_SkAlphaType.

    #Illustration

    #Example
    #Height 96
        canvas->scale(16, 16);
        SkBitmap bitmap;
        SkImageInfo imageInfo = SkImageInfo::Make(2, 2, kRGB_565_SkColorType, kOpaque_SkAlphaType);
        bitmap.allocPixels(imageInfo);
        SkCanvas offscreen(bitmap);
        offscreen.clear(SK_ColorGREEN);
        canvas->drawBitmap(bitmap, 0, 0);
        auto pack565 = [](unsigned r, unsigned g, unsigned b) -> uint16_t {
            return (b << 0) | (g << 5) | (r << 11);
        };
        uint16_t red565[] =  { pack565(0x1F, 0x00, 0x00), pack565(0x17, 0x00, 0x00),
                               pack565(0x0F, 0x00, 0x00), pack565(0x07, 0x00, 0x00) };
        uint16_t blue565[] = { pack565(0x00, 0x00, 0x1F), pack565(0x00, 0x00, 0x17),
                               pack565(0x00, 0x00, 0x0F), pack565(0x00, 0x00, 0x07) };
        SkPixmap redPixmap(imageInfo, &red565, imageInfo.minRowBytes());
        if (bitmap.writePixels(redPixmap, 0, 0)) {
            canvas->drawBitmap(bitmap, 2, 2);
        }
        SkPixmap bluePixmap(imageInfo, &blue565, imageInfo.minRowBytes());
        if (bitmap.writePixels(bluePixmap, 0, 0)) {
            canvas->drawBitmap(bitmap, 4, 4);
        }
    ##
    #SeeAlso ARGB_4444 RGBA_8888
##

#Subtopic ARGB_4444
#Line # encodes ARGB in 16 bits ##
    kARGB_4444_SkColorType encodes ARGB to fit in 16-bit word. Each
    component: alpha, blue, green, and red; use four bits, describing 16 levels.
    Note that kARGB_4444_SkColorType is misnamed; the acronym does not
    describe the actual component order.

    #Illustration

    If paired with kPremul_SkAlphaType: blue, green, and red components are
    Premultiplied by the alpha value. If blue, green, or red is greater than alpha,
    the drawn result is undefined.

    If paired with kUnpremul_SkAlphaType: alpha, blue, green, and red components
    may have any value. There may be a performance penalty with Unpremultipled
    pixels.

    If paired with kOpaque_SkAlphaType: all alpha component values are at the maximum;
    blue, green, and red components are fully opaque. If any alpha component is
    less than 15, the drawn result is undefined.

    #Bug 7648

    #Example
    #Height 96
        canvas->scale(16, 16);
        SkBitmap bitmap;
        SkImageInfo imageInfo = SkImageInfo::Make(2, 2, kARGB_4444_SkColorType, kPremul_SkAlphaType);
        bitmap.allocPixels(imageInfo);
        SkCanvas offscreen(bitmap);
        offscreen.clear(SK_ColorGREEN);
        canvas->drawBitmap(bitmap, 0, 0);
        auto pack4444 = [](unsigned a, unsigned r, unsigned g, unsigned b) -> uint16_t {
            return (a << 0) | (b << 4) | (g << 8) | (r << 12);
        };
        uint16_t red4444[] =  { pack4444(0xF, 0xF, 0x0, 0x0), pack4444(0xF, 0xb, 0x0, 0x0),
                                pack4444(0xF, 0x7, 0x0, 0x0), pack4444(0xF, 0x3, 0x0, 0x0) };
        uint16_t blue4444[] = { pack4444(0xF, 0x0, 0x0, 0xF), pack4444(0xF, 0x0, 0x0, 0xb),
                                pack4444(0xF, 0x0, 0x0, 0x7), pack4444(0xF, 0x0, 0x0, 0x3) };
        SkPixmap redPixmap(imageInfo, &red4444, imageInfo.minRowBytes());
        if (bitmap.writePixels(redPixmap, 0, 0)) {
            canvas->drawBitmap(bitmap, 2, 2);
        }
        SkPixmap bluePixmap(imageInfo, &blue4444, imageInfo.minRowBytes());
        if (bitmap.writePixels(bluePixmap, 0, 0)) {
            canvas->drawBitmap(bitmap, 4, 4);
        }
    ##
    #SeeAlso RGBA_8888
##

#Subtopic RGBA_8888
#Line # encodes ARGB Big_Endian in 32 bits ##
    kRGBA_8888_SkColorType encodes ARGB into a 32-bit word. Each component:
    red, green, blue, alpha; use eight bits, describing 256 levels.

    #Illustration

    If paired with kPremul_SkAlphaType: red, green, and blue components are
    Premultiplied by the alpha value. If red, green, or blue is greater than alpha,
    the drawn result is undefined.

    If paired with kUnpremul_SkAlphaType: alpha, red, green, and blue components
    may have any value. There may be a performance penalty with Unpremultipled
    pixels.

    If paired with kOpaque_SkAlphaType: all alpha component values are at the maximum;
    red, green, and blue components are fully opaque. If any alpha component is
    less than 255, the drawn result is undefined.

    On Big_Endian platforms, kRGBA_8888_SkColorType is the native Color_Type, and
    will have the best performance. Use kN32_SkColorType to choose the best
    Color_Type for the platform at compile time.

    #Example
    #Height 96
        canvas->scale(16, 16);
        SkBitmap bitmap;
        SkImageInfo imageInfo = SkImageInfo::Make(2, 2, kRGBA_8888_SkColorType, kPremul_SkAlphaType);
        bitmap.allocPixels(imageInfo);
        SkCanvas offscreen(bitmap);
        offscreen.clear(SK_ColorGREEN);
        canvas->drawBitmap(bitmap, 0, 0);
        auto pack8888 = [](unsigned a, unsigned r, unsigned g, unsigned b) -> uint32_t {
            return (r << 0) | (g << 8) | (b << 16) | (a << 24);
        };
        uint32_t red8888[] = { pack8888(0xFF, 0xFF, 0x0, 0x0), pack8888(0xFF, 0xbb, 0x0, 0x0),
                               pack8888(0xFF, 0x77, 0x0, 0x0), pack8888(0xFF, 0x33, 0x0, 0x0) };
        uint32_t blue8888[] = { pack8888(0xFF, 0x0, 0x0, 0x0FF), pack8888(0xFF, 0x0, 0x0, 0x0bb),
                                pack8888(0xFF, 0x0, 0x0, 0x077), pack8888(0xFF, 0x0, 0x0, 0x033) };
        SkPixmap redPixmap(imageInfo, &red8888, imageInfo.minRowBytes());
        if (bitmap.writePixels(redPixmap, 0, 0)) {
            canvas->drawBitmap(bitmap, 2, 2);
        }
        SkPixmap bluePixmap(imageInfo, &blue8888, imageInfo.minRowBytes());
        if (bitmap.writePixels(bluePixmap, 0, 0)) {
            canvas->drawBitmap(bitmap, 4, 4);
        }
    ##
    #SeeAlso RGB_888 BGRA_8888
##

#Subtopic RGB_888
#Line # encodes RGB in 32 bits ##
    kRGB_888x_SkColorType encodes RGB into a 32-bit word. Each component:
    red, green, blue; use eight bits, describing 256 levels. Eight bits are
    unused. Pixels described by kRGB_888x_SkColorType are fully opaque as if 
    their Color_Alpha was set to one, and should always be paired with
    kOpaque_SkAlphaType.

    #Illustration

    #Example
    #Bug 7645
    #Height 96
    #Platform cpu
        canvas->scale(16, 16);
        SkBitmap bitmap;
        SkImageInfo imageInfo = SkImageInfo::Make(2, 2, kRGB_888x_SkColorType, kOpaque_SkAlphaType);
        bitmap.allocPixels(imageInfo);
        SkCanvas offscreen(bitmap);
        offscreen.clear(SK_ColorGREEN);
        canvas->drawBitmap(bitmap, 0, 0);
        auto pack888 = [](unsigned r, unsigned g, unsigned b) -> uint32_t {
            return (r << 0) | (g << 8) | (b << 16);
        };
        uint32_t red888[] =  { pack888(0xFF, 0x00, 0x00), pack888(0xbb, 0x00, 0x00),
            pack888(0x77, 0x00, 0x00), pack888(0x33, 0x00, 0x00) };
        uint32_t blue888[] = { pack888(0x00, 0x00, 0xFF), pack888(0x00, 0x00, 0xbb),
            pack888(0x00, 0x00, 0x77), pack888(0x00, 0x00, 0x33) };
        if (bitmap.installPixels(imageInfo, (void*) red888, imageInfo.minRowBytes())) {
            canvas->drawBitmap(bitmap, 2, 2);
        }
        if (bitmap.installPixels(imageInfo, (void*) blue888, imageInfo.minRowBytes())) {
            canvas->drawBitmap(bitmap, 4, 4);
        }
    ##
    #SeeAlso RGBA_8888 BGRA_8888
##

#Subtopic BGRA_8888
#Line # encodes ARGB Little_Endian in 32 bits ##
    kBGRA_8888_SkColorType encodes ARGB into a 32-bit word. Each component:
    blue, green, red, and alpha; use eight bits, describing 256 levels.

    #Illustration

    If paired with kPremul_SkAlphaType: blue, green, and red components are
    Premultiplied by the alpha value. If blue, green, or red is greater than alpha,
    the drawn result is undefined.

    If paired with kUnpremul_SkAlphaType: blue, green, red, and alpha components
    may have any value. There may be a performance penalty with Unpremultiplied
    pixels.

    If paired with kOpaque_SkAlphaType: all alpha component values are at the maximum;
    blue, green, and red components are fully opaque. If any alpha component is
    less than 255, the drawn result is undefined.

    On Little_Endian platforms, kBGRA_8888_SkColorType is the native Color_Type,
    and will have the best performance. Use kN32_SkColorType to choose the best
    Color_Type for the platform at compile time.

    #Example
    #Height 96
        canvas->scale(16, 16);
        SkBitmap bitmap;
        SkImageInfo imageInfo = SkImageInfo::Make(2, 2, kBGRA_8888_SkColorType, kPremul_SkAlphaType);
        bitmap.allocPixels(imageInfo);
        SkCanvas offscreen(bitmap);
        offscreen.clear(SK_ColorGREEN);
        canvas->drawBitmap(bitmap, 0, 0);
        auto pack8888 = [](unsigned a, unsigned r, unsigned g, unsigned b) -> uint32_t {
            return (b << 0) | (g << 8) | (r << 16) | (a << 24);
        };
        uint32_t red8888[] = { pack8888(0xFF, 0xFF, 0x0, 0x0), pack8888(0xFF, 0xbb, 0x0, 0x0),
                               pack8888(0xFF, 0x99, 0x0, 0x0), pack8888(0xFF, 0x55, 0x0, 0x0) };
        uint32_t blue8888[] = { pack8888(0xFF, 0x0, 0x0, 0x0FF), pack8888(0xFF, 0x0, 0x0, 0x0bb),
                                pack8888(0xFF, 0x0, 0x0, 0x099), pack8888(0xFF, 0x0, 0x0, 0x055) };
        SkPixmap redPixmap(imageInfo, &red8888, imageInfo.minRowBytes());
        if (bitmap.writePixels(redPixmap, 0, 0)) {
            canvas->drawBitmap(bitmap, 2, 2);
        }
        SkPixmap bluePixmap(imageInfo, &blue8888, imageInfo.minRowBytes());
        if (bitmap.writePixels(bluePixmap, 0, 0)) {
            canvas->drawBitmap(bitmap, 4, 4);
        }
    ##
    #SeeAlso RGBA_8888
##

#Subtopic RGBA_1010102
#Line # encodes ARGB ten bits per color component ##
    kRGBA_1010102_SkColorType encodes ARGB into a 32-bit word. Each
    Color component: red, green, and blue; use ten bits, describing 1024 levels.
    Two bits contain alpha, describing four levels. Possible alpha
    values are zero: fully transparent; one: 33% opaque; two: 67% opaque;
    three: fully opaque.

    At present, Color in Paint does not provide enough precision to
    draw all colors possible to a kRGBA_1010102_SkColorType Surface.

    #Illustration

    If paired with kPremul_SkAlphaType: red, green, and blue components are
    Premultiplied by the alpha value. If red, green, or blue is greater than the
    alpha replicated to ten bits, the drawn result is undefined.

    If paired with kUnpremul_SkAlphaType: alpha, red, green, and blue components
    may have any value. There may be a performance penalty with Unpremultiplied
    pixels.

    If paired with kOpaque_SkAlphaType: all alpha component values are at the maximum;
    red, green, and blue components are fully opaque. If any alpha component is
    less than three, the drawn result is undefined.

    #Example
    #Bug 7645
    #Height 96
    #Platform cpu
        canvas->scale(16, 16);
        SkBitmap bitmap;
        SkImageInfo imageInfo = SkImageInfo::Make(2, 2, kRGBA_1010102_SkColorType, kOpaque_SkAlphaType);
        bitmap.allocPixels(imageInfo);
        SkCanvas offscreen(bitmap);
        offscreen.clear(SK_ColorGREEN);
        canvas->drawBitmap(bitmap, 0, 0);
        auto pack1010102 = [](unsigned r, unsigned g, unsigned b, unsigned a) -> uint32_t {
            return (r << 0) | (g << 10) | (b << 20) | (a << 30);
        };
        uint32_t redBits[] =  { pack1010102(0x3FF, 0x000, 0x000, 0x3),
                                pack1010102(0x2ff, 0x000, 0x000, 0x3),
                                pack1010102(0x1ff, 0x000, 0x000, 0x3),
                                pack1010102(0x0ff, 0x000, 0x000, 0x3) };
        uint32_t blueBits[] = { pack1010102(0x000, 0x000, 0x3FF, 0x3),
                                pack1010102(0x000, 0x000, 0x2ff, 0x3),
                                pack1010102(0x000, 0x000, 0x1ff, 0x3),
                                pack1010102(0x000, 0x000, 0x0ff, 0x3) };
        if (bitmap.installPixels(imageInfo, (void*) redBits, imageInfo.minRowBytes())) {
            canvas->drawBitmap(bitmap, 2, 2);
        }
        SkPixmap bluePixmap(imageInfo, &blueBits, imageInfo.minRowBytes());
        if (bitmap.installPixels(imageInfo, (void*) blueBits, imageInfo.minRowBytes())) {
            canvas->drawBitmap(bitmap, 4, 4);
        }
    ##
    #SeeAlso RGB_101010 RGBA_8888
##

#Subtopic RGB_101010
#Line # encodes RGB ten bits per color component ##
    kRGB_101010x_SkColorType encodes RGB into a 32-bit word. Each
    Color component: red, green, and blue; use ten bits, describing 1024 levels.
    Two bits are unused. Pixels described by kRGB_101010x_SkColorType are fully
    opaque as if its Color_Alpha was set to one, and should always be paired
    with kOpaque_SkAlphaType.

    At present, Color in Paint does not provide enough precision to
    draw all colors possible to a kRGB_101010x_SkColorType Surface.

    #Illustration

    #Example
    #Bug 7645
    #Height 96
    #Platform cpu
        canvas->scale(16, 16);
        SkBitmap bitmap;
        SkImageInfo imageInfo = SkImageInfo::Make(2, 2, kRGB_101010x_SkColorType, kOpaque_SkAlphaType);
        bitmap.allocPixels(imageInfo);
        SkCanvas offscreen(bitmap);
        offscreen.clear(SK_ColorGREEN);
        canvas->drawBitmap(bitmap, 0, 0);
        auto pack101010x = [](unsigned r, unsigned g, unsigned b) -> uint32_t {
            return (r << 0) | (g << 10) | (b << 20);
        };
        uint32_t redBits[] =  { pack101010x(0x3FF, 0x000, 0x000), pack101010x(0x2ff, 0x000, 0x000),
        pack101010x(0x1ff, 0x000, 0x000), pack101010x(0x0ff, 0x000, 0x000) };
        uint32_t blueBits[] = { pack101010x(0x000, 0x000, 0x3FF), pack101010x(0x000, 0x000, 0x2ff),
        pack101010x(0x000, 0x000, 0x1ff), pack101010x(0x000, 0x000, 0x0ff) };
        if (bitmap.installPixels(imageInfo, (void*) redBits, imageInfo.minRowBytes())) {
            canvas->drawBitmap(bitmap, 2, 2);
        }
        SkPixmap bluePixmap(imageInfo, &blueBits, imageInfo.minRowBytes());
        if (bitmap.installPixels(imageInfo, (void*) blueBits, imageInfo.minRowBytes())) {
            canvas->drawBitmap(bitmap, 4, 4);
        }
    ##
    #SeeAlso RGBA_1010102
##

#Subtopic Gray_8
#Line # encodes level of Grayscale in 8 bits ##
    kGray_8_SkColorType encodes Grayscale level in eight bits that is equivalent
    to equal values for red, blue, and green, representing colors from black to
    white.  Pixels described by kGray_8_SkColorType are fully
    opaque as if its Color_Alpha was set to one, and should always be paired with
    kOpaque_SkAlphaType.

    #Example
    #Height 64
        canvas->scale(16, 16);
        SkBitmap bitmap;
        SkImageInfo imageInfo = SkImageInfo::Make(2, 2, kGray_8_SkColorType, kOpaque_SkAlphaType);
        bitmap.allocPixels(imageInfo);
        SkCanvas offscreen(bitmap);
        offscreen.clear(SK_ColorGREEN);
        canvas->drawBitmap(bitmap, 0, 0);
        uint8_t gray8[] = { 0xFF, 0xBB, 0x77, 0x33 };
        SkPixmap grayPixmap(imageInfo, &gray8, imageInfo.minRowBytes());
        if (bitmap.writePixels(grayPixmap, 0, 0)) {
            canvas->drawBitmap(bitmap, 2, 2);
        }
    ##
    #SeeAlso Alpha_8
##

#Subtopic RGBA_F16
#Line # encodes ARGB as half floats ##
    kRGBA_F16_SkColorType encodes ARGB into a 64-bit word. Each component:
    blue, green, red, and alpha; use 16 bits, describing a floating point value,
    from -65500 to 65000 with 3.31 decimal digits of precision.

    At present, Color in Paint does not provide enough precision or range to
    draw all colors possible to a kRGBA_F16_SkColorType Surface.

    Each component encodes a floating point value using
    #A Half floats # https://www.khronos.org/opengl/wiki/Small_Float_Formats ##
    . Meaningful colors are represented by the range 0.0 to 1.0, although smaller
    and larger values may be useful when used in combination with Transfer_Mode.

    #Illustration

    If paired with kPremul_SkAlphaType: blue, green, and red components are
    Premultiplied by the alpha value. If blue, green, or red is greater than alpha,
    the drawn result is undefined.

    If paired with kUnpremul_SkAlphaType: blue, green, red, and alpha components
    may have any value. There may be a performance penalty with Unpremultiplied
    pixels.

    If paired with kOpaque_SkAlphaType: all alpha component values are at the maximum;
    blue, green, and red components are fully opaque. If any alpha component is
    less than one, the drawn result is undefined.

    #ToDo
    FloatToHalf should be replaced with SkFloatToHalf if/when that's made public
    ##

    #Example
    #Height 96
    #Function
    union FloatUIntUnion {
        uint32_t fUInt;
        float    fFloat;
    };

    uint16_t FloatToHalf(float f) {
        static const FloatUIntUnion magic = { 15 << 23 };
        static const uint32_t round_mask = ~0xfffu;
        FloatUIntUnion floatUnion;
        floatUnion.fFloat = f;
        uint32_t sign = floatUnion.fUInt & 0x80000000u;
        floatUnion.fUInt ^= sign;
        floatUnion.fUInt &= round_mask;
        floatUnion.fFloat *= magic.fFloat;
        floatUnion.fUInt -= round_mask;
        return (floatUnion.fUInt >> 13) | (sign >> 16);
    }
    ##

    void draw(SkCanvas* canvas) {
        canvas->scale(16, 16);
        SkBitmap bitmap;
        SkImageInfo imageInfo = SkImageInfo::Make(2, 2, kRGBA_F16_SkColorType, kPremul_SkAlphaType);
        bitmap.allocPixels(imageInfo);
        SkCanvas offscreen(bitmap);
        offscreen.clear(SK_ColorGREEN);
        canvas->drawBitmap(bitmap, 0, 0);
        auto H = [](float c) -> uint16_t {
            return FloatToHalf(c);
        };
                                 //     R        G        B        A
        uint16_t red_f16[][4] =  { { H(1.0), H(0.0), H(0.0), H(1.0) },
                                   { H(.75), H(0.0), H(0.0), H(1.0) },
                                   { H(.50), H(0.0), H(0.0), H(1.0) },
                                   { H(.25), H(0.0), H(0.0), H(1.0) } };
        uint16_t blue_f16[][4] = { { H(0.0), H(0.0), H(1.0), H(1.0) },
                                   { H(0.0), H(0.0), H(.75), H(1.0) },
                                   { H(0.0), H(0.0), H(.50), H(1.0) },
                                   { H(0.0), H(0.0), H(.25), H(1.0) } };
        SkPixmap redPixmap(imageInfo, red_f16, imageInfo.minRowBytes());
        if (bitmap.writePixels(redPixmap, 0, 0)) {
            canvas->drawBitmap(bitmap, 2, 2);
        }
        SkPixmap bluePixmap(imageInfo, blue_f16, imageInfo.minRowBytes());
        if (bitmap.writePixels(bluePixmap, 0, 0)) {
            canvas->drawBitmap(bitmap, 4, 4);
        }
    }
    ##
    #SeeAlso SkColor4f
##

#Subtopic RGBA_F32
#Line # encodes ARGB as single precision floats ##
    kRGBA_F32_SkColorType encodes ARGB into a 128-bit word. Each component:
    blue, green, red, and alpha; use 32 bits, describing a floating point value,
    from -3.402823e+38 to 3.402823e+38 with 7.225 decimal digits of precision.

    At present, Color in Paint does not provide enough precision or range to
    draw all colors possible to a kRGBA_F32_SkColorType Surface.

    Each component encodes a floating point value using
    #A single-precision floats # https://en.wikipedia.org/wiki/Single-precision_floating-point_format ##
    . Meaningful colors are represented by the range 0.0 to 1.0, although smaller
    and larger values may be useful when used in combination with Transfer_Mode.

    #Illustration

    If paired with kPremul_SkAlphaType: blue, green, and red components are
    Premultiplied by the alpha value. If blue, green, or red is greater than alpha,
    the drawn result is undefined.

    If paired with kUnpremul_SkAlphaType: blue, green, red, and alpha components
    may have any value. There may be a performance penalty with Unpremultiplied
    pixels.

    If paired with kOpaque_SkAlphaType: all alpha component values are at the maximum;
    blue, green, and red components are fully opaque. If any alpha component is
    less than one, the drawn result is undefined.

    #NoExample
        canvas->scale(16, 16);
        SkBitmap bitmap;
        SkImageInfo imageInfo = SkImageInfo::Make(2, 2, kRGBA_F32_SkColorType, kPremul_SkAlphaType);
        bitmap.allocPixels(imageInfo);
        SkCanvas offscreen(bitmap);
        offscreen.clear(SK_ColorGREEN);
        canvas->drawBitmap(bitmap, 0, 0);
                             //    R    G    B    A
        float red_f32[][4] =  { { 1.0, 0.0, 0.0, 1.0 },
                                { .75, 0.0, 0.0, 1.0 },
                                { .50, 0.0, 0.0, 1.0 },
                                { .25, 0.0, 0.0, 1.0 } };
        float blue_f32[][4] = { { 0.0, 0.0, 1.0, 1.0 },
                                { 0.0, 0.0, .75, 1.0 },
                                { 0.0, 0.0, .50, 1.0 },
                                { 0.0, 0.0, .25, 1.0 } };
        SkPixmap redPixmap(imageInfo, red_f32, imageInfo.minRowBytes());
        if (bitmap.writePixels(redPixmap, 0, 0)) {
            canvas->drawBitmap(bitmap, 2, 2);
        }
        SkPixmap bluePixmap(imageInfo, blue_f32, imageInfo.minRowBytes());
        if (bitmap.writePixels(bluePixmap, 0, 0)) {
            canvas->drawBitmap(bitmap, 4, 4);
        }
    ##
    #SeeAlso SkColor4f
##


#Subtopic Color_Type ##

# ------------------------------------------------------------------------------

#Method int SkColorTypeBytesPerPixel(SkColorType ct)
#In Property
#Line # returns Color_Type byte size ##

Returns the number of bytes required to store a pixel, including unused padding.
Returns zero if ct is kUnknown_SkColorType or invalid.

#Param ct  one of: #list_of_color_types#
##

#Return bytes per pixel ##

#Example
#Height 192
    const char* colors[] = { "Unknown", "Alpha_8", "RGB_565", "ARGB_4444", "RGBA_8888", "RGB_888x",
                             "BGRA_8888", "RGBA_1010102", "RGB_101010x", "Gray_8", "RGBA_F16" };
    SkPaint paint;
    paint.setTypeface(SkTypeface::MakeFromName("monospace", SkFontStyle()));
    paint.setAntiAlias(true);
    paint.setTextSize(10);
    int y = 15;
    canvas->drawString("    colorType  bytes", 10, y, paint);
    for (SkColorType colorType : { #list_of_color_types#
                                 } ) {
        int result = SkColorTypeBytesPerPixel(colorType);
        SkString string;
        string.printf("%13s %4d", colors[(int) colorType], result);
        canvas->drawString(string, 10, y += 14, paint);
    }
##
#SeeAlso SkImageInfo::bytesPerPixel
##

# ------------------------------------------------------------------------------

#Method bool SkColorTypeIsAlwaysOpaque(SkColorType ct)
#In Property
#Line # returns if Color_Type includes Color_Alpha ##

Returns true if Color_Type always decodes Color_Alpha to 1.0, making the pixel
fully opaque. If true, Color_Type does not reserve bits to encode Color_Alpha.

#Param ct  one of: #list_of_color_types#
##

#Return true if Color_Alpha is always set to 1.0 ##

#Example
#Height 192
    const char* colors[] = { "Unknown", "Alpha_8", "RGB_565", "ARGB_4444", "RGBA_8888", "RGB_888x",
                             "BGRA_8888", "RGBA_1010102", "RGB_101010x", "Gray_8", "RGBA_F16" };
    SkPaint paint;
    paint.setTypeface(SkTypeface::MakeFromName("monospace", SkFontStyle()));
    paint.setAntiAlias(true);
    paint.setTextSize(10);
    int y = 15;
    canvas->drawString("    colorType  bytes", 10, y, paint);
    for (SkColorType colorType : { #list_of_color_types#
                                 } ) {
        bool result = SkColorTypeIsAlwaysOpaque(colorType);
        SkString string;
        string.printf("%13s %6s", colors[(int) colorType], result ? "true" : "false");
        canvas->drawString(string, 10, y += 14, paint);
    }
##
#SeeAlso SkColorTypeValidateAlphaType
##

# ------------------------------------------------------------------------------

#Method bool SkColorTypeValidateAlphaType(SkColorType colorType, SkAlphaType alphaType,
                                         SkAlphaType* canonical = nullptr)
#In Property
#Line # returns if Alpha_Type is valid ##

Returns true if canonical can be set to a valid Alpha_Type for colorType. If
there is more than one valid canonical Alpha_Type, set to alphaType, if valid.
If true is returned and canonical is not nullptr, store valid Alpha_Type.

Returns false only if alphaType is kUnknown_SkAlphaType, color type is not
kUnknown_SkColorType, and Color_Type is not always opaque. If false is returned,
canonical is ignored.

For kUnknown_SkColorType: set canonical to kUnknown_SkAlphaType and return true.
For kAlpha_8_SkColorType: set canonical to kPremul_SkAlphaType or
kOpaque_SkAlphaType and return true if alphaType is not kUnknown_SkAlphaType.
For kRGB_565_SkColorType, kRGB_888x_SkColorType, kRGB_101010x_SkColorType, and
kGray_8_SkColorType: set canonical to kOpaque_SkAlphaType and return true.
For kARGB_4444_SkColorType, kRGBA_8888_SkColorType, kBGRA_8888_SkColorType,
kRGBA_1010102_SkColorType, and kRGBA_F16_SkColorType: set canonical to alphaType
and return true if alphaType is not kUnknown_SkAlphaType.

#Param colorType  one of: #list_of_color_types#
##
#Param alphaType  one of: #list_of_alpha_types#
##
#Param canonical storage for Alpha_Type ##

#Return true if valid Alpha_Type can be associated with colorType ##

#Example
#Height 640
    const char* colors[] = { "Unknown", "Alpha_8", "RGB_565", "ARGB_4444", "RGBA_8888", "RGB_888x",
                             "BGRA_8888", "RGBA_1010102", "RGB_101010x", "Gray_8", "RGBA_F16" };
    const char* alphas[] = {"Unknown ", "Opaque  ", "Premul  ", "Unpremul"};
    SkAlphaType alphaTypes[] = { #list_of_alpha_types#
                               };
    SkPaint paint;
    paint.setTypeface(SkTypeface::MakeFromName("monospace", SkFontStyle()));
    paint.setAntiAlias(true);
    paint.setTextSize(10);
    int y = 15;
    canvas->drawString("   colorType   alphaType  canonical", 10, y, paint);
    for (SkColorType colorType : { #list_of_color_types#
                                 } ) {
        for (SkAlphaType alphaType : alphaTypes) {
            SkAlphaType canonicalAlphaType  = kUnknown_SkAlphaType;
            bool result = SkColorTypeValidateAlphaType(colorType, alphaType, &canonicalAlphaType);
            SkString string;
            string.printf("%13s %10s %10s", colors[(int) colorType], alphas[(int) alphaType],
                     result ? alphas[(int) canonicalAlphaType] : "------  ");
            canvas->drawString(string, 10, y += 14, paint);
        }
    }
##
#SeeAlso SkColorTypeIsAlwaysOpaque
##

# ------------------------------------------------------------------------------
#Subtopic YUV_ColorSpace
#Line # color range of YUV pixels ##
#Alias YUV_ColorSpace ##

#Enum SkYUVColorSpace
#Line # color range of YUV pixels ##

#Code
    enum SkYUVColorSpace {
        kJPEG_SkYUVColorSpace,
        kRec601_SkYUVColorSpace,
        kRec709_SkYUVColorSpace,
        kLastEnum_SkYUVColorSpace = kRec709_SkYUVColorSpace,
    };
##

Describes color range of YUV pixels. The color mapping from YUV to RGB varies
depending on the source. YUV pixels may be generated by JPEG images, standard
video streams, or high definition video streams. Each has its own mapping from
YUV and RGB.

JPEG YUV values encode the full range of 0 to 255 for all three components.
Video YUV values range from 16 to 235 for all three components. Details of
encoding and conversion to RGB are described in
#A YCbCr color space # https://en.wikipedia.org/wiki/YCbCr ##
.

#Const kJPEG_SkYUVColorSpace 0
#Line # describes full range ##
Describes standard JPEG color space;
#A CCIR 601 # https://en.wikipedia.org/wiki/Rec._601 ##
with full range of 0 to 255 for components.
##
#Const kRec601_SkYUVColorSpace 1
#Line # describes SDTV range ##
Describes standard used by standard definition television;
#A CCIR 601 # https://en.wikipedia.org/wiki/Rec._601 ##
with studio range of 16 to 235 range for components.
##
#Const kRec709_SkYUVColorSpace 2
#Line # describes HDTV range ##
Describes standard used by high definition television;
#A Rec. 709 # https://en.wikipedia.org/wiki/Rec._709 ##
with studio range of 16 to 235 range for components.
##
#Const kLastEnum_SkYUVColorSpace 2
#Line # last valid value ##
    Used by tests to iterate through all valid values.
##

#NoExample
##

#SeeAlso SkImage::MakeFromYUVTexturesCopy SkImage::MakeFromNV12TexturesCopy

#Enum SkYUVColorSpace ##
#Subtopic YUV_ColorSpace ##

# ------------------------------------------------------------------------------

#Struct SkImageInfo

Describes pixel dimensions and encoding. Bitmap, Image, PixMap, and Surface
can be created from Image_Info. Image_Info can be retrieved from Bitmap and
Pixmap, but not from Image and Surface. For example, Image and Surface
implementations may defer pixel depth, so may not completely specify Image_Info.

Image_Info contains dimensions, the pixel integral width and height. It encodes
how pixel bits describe Color_Alpha, transparency; Color components red, blue,
and green; and Color_Space, the range and linearity of colors.

#Subtopic Member_Function
#Populate
##

#Subtopic Related_Function
#Populate
##

# ------------------------------------------------------------------------------
#Subtopic Constructor
#Populate
##

#Method SkImageInfo()

#In Constructor
#Line # creates with zeroed dimensions, kUnknown_SkColorType, kUnknown_SkAlphaType ##
Creates an empty Image_Info with kUnknown_SkColorType, kUnknown_SkAlphaType,
a width and height of zero, and no Color_Space.

#Return empty Image_Info ##

#Example
#Height 32
#Description
An empty Image_Info may be passed to SkCanvas::accessTopLayerPixels as storage
for the Canvas actual Image_Info.
##
  SkImageInfo imageInfo;
  size_t rowBytes;
  SkIPoint origin;
  (void) canvas->accessTopLayerPixels(&imageInfo, &rowBytes, &origin);
  const char* alphaType[] = { "Unknown", "Opaque", "Premul", "Unpremul" };
  SkString string;
  string.printf("k%s_SkAlphaType", alphaType[(int) imageInfo.alphaType()]);
  SkPaint paint;
  canvas->drawString(string, 20, 20, paint);
##

#SeeAlso Make MakeN32 MakeS32 MakeA8

#Method ##

# ------------------------------------------------------------------------------

#Method static SkImageInfo Make(int width, int height, SkColorType ct, SkAlphaType at,
                            sk_sp<SkColorSpace> cs = nullptr)
#In Constructor
#Line # creates Image_Info from dimensions, Color_Type, Alpha_Type, Color_Space ##
Creates Image_Info from integral dimensions width and height, Color_Type ct,
Alpha_Type at, and optionally Color_Space cs.

If Color_Space cs is nullptr and Image_Info is part of drawing source: Color_Space
defaults to sRGB, mapping into Surface Color_Space.

Parameters are not validated to see if their values are legal, or that the
combination is supported.

#Param width  pixel column count; must be zero or greater ##
#Param height  pixel row count; must be zero or greater ##
#Param ct  one of: #list_of_color_types#
##
#Param at  one of: #list_of_alpha_types#
##
#Param cs  range of colors; may be nullptr ##

#Return created Image_Info ##

#Example
#Height 48
    uint8_t storage[][5] = {{ 0xCA, 0xDA, 0xCA, 0xC9, 0xA3 },
                            { 0xAC, 0xA8, 0x89, 0xA7, 0x87 },
                            { 0x9B, 0xB5, 0xE5, 0x95, 0x46 },
                            { 0x90, 0x81, 0xC5, 0x71, 0x33 },
                            { 0x75, 0x55, 0x44, 0x40, 0x30 }};
    SkImageInfo imageInfo = SkImageInfo::Make(5, 5, kGray_8_SkColorType, kOpaque_SkAlphaType);
    SkPixmap pixmap(imageInfo, storage[0], sizeof(storage) / 5);
    SkBitmap bitmap;
    bitmap.installPixels(pixmap);
    canvas->scale(8, 8);
    canvas->drawBitmap(bitmap, 0, 0);
##

#SeeAlso MakeN32 MakeN32Premul MakeS32 MakeA8

#Method ##

# ------------------------------------------------------------------------------

#Method static SkImageInfo MakeN32(int width, int height, SkAlphaType at,
                               sk_sp<SkColorSpace> cs = nullptr)
#In Constructor
#Line # creates Image_Info with Native_Color_Type ##
Creates Image_Info from integral dimensions width and height, kN32_SkColorType,
Alpha_Type at, and optionally Color_Space cs. kN32_SkColorType will equal either
kBGRA_8888_SkColorType or kRGBA_8888_SkColorType, whichever is optimal.

If Color_Space cs is nullptr and Image_Info is part of drawing source: Color_Space
defaults to sRGB, mapping into Surface Color_Space.

Parameters are not validated to see if their values are legal, or that the
combination is supported.

#Param width  pixel column count; must be zero or greater ##
#Param height  pixel row count; must be zero or greater ##
#Param at  one of: #list_of_alpha_types#
##
#Param cs  range of colors; may be nullptr ##

#Return created Image_Info ##

#Example
#Height 128
    SkBitmap bitmap;
    bitmap.allocPixels(SkImageInfo::MakeN32(16, 16, kPremul_SkAlphaType));
    SkCanvas offscreen(bitmap);
    offscreen.clear(SK_ColorWHITE);
    SkPaint paint;
    offscreen.drawString("g", 0, 10, paint);
    canvas->scale(8, 8);
    canvas->drawBitmap(bitmap, 0, 0);
##

#SeeAlso Make MakeN32Premul MakeS32 MakeA8

#Method ##

# ------------------------------------------------------------------------------

#Method static SkImageInfo MakeS32(int width, int height, SkAlphaType at)

#In Constructor
#Line # creates Image_Info with Native_Color_Type, sRGB Color_Space ##
Creates Image_Info from integral dimensions width and height, kN32_SkColorType,
Alpha_Type at, with sRGB Color_Space.

Parameters are not validated to see if their values are legal, or that the
combination is supported.

#Param width  pixel column count; must be zero or greater ##
#Param height  pixel row count; must be zero or greater ##
#Param at  one of: #list_of_alpha_types#
##

#Return created Image_Info ##

#Example
#Set sRGB
#Height 128
#Description
Top gradient is drawn to offScreen without Color_Space. It is darker than middle
gradient, drawn to offScreen with sRGB Color_Space. Bottom gradient shares bits
with middle, but does not specify the Color_Space in noColorSpaceBitmap. A source
without Color_Space is treated as sRGB; the bottom gradient is identical to the
middle gradient.
##
    const int width = 256;
    const int height = 32;
    SkImageInfo info = SkImageInfo::MakeN32Premul(width, height);
    SkColor  gradColors[] = { 0xFFAA0055, 0xFF11CC88 };
    SkPoint  gradPoints[] = { { 0, 0 }, { width, 0 } };
    SkPaint gradPaint;
    gradPaint.setShader(SkGradientShader::MakeLinear(gradPoints, gradColors, nullptr,
                    SK_ARRAY_COUNT(gradColors), SkShader::kClamp_TileMode));
    SkBitmap bitmap;
    bitmap.allocPixels(SkImageInfo::MakeN32(width, height, kPremul_SkAlphaType));
    SkCanvas offScreen(bitmap);
    offScreen.drawRect(SkRect::MakeWH(width, height), gradPaint);
    canvas->drawBitmap(bitmap, 0, 0);
    bitmap.allocPixels(SkImageInfo::MakeS32(width, height, kPremul_SkAlphaType));
    SkCanvas sRGBOffscreen(bitmap);
    sRGBOffscreen.drawRect(SkRect::MakeWH(width, height), gradPaint);
    canvas->drawBitmap(bitmap, 0, 48);
    SkBitmap noColorSpaceBitmap;
    noColorSpaceBitmap.setInfo(SkImageInfo::MakeN32(width, height, kPremul_SkAlphaType));
    noColorSpaceBitmap.setPixels(bitmap.getAddr(0, 0));
    canvas->drawBitmap(noColorSpaceBitmap, 0, 96);
##

#SeeAlso Make MakeN32 MakeN32Premul MakeA8

#Method ##

# ------------------------------------------------------------------------------

#Method static SkImageInfo MakeN32Premul(int width, int height, sk_sp<SkColorSpace> cs = nullptr)

#In Constructor
#Line # creates Image_Info with Native_Color_Type, kPremul_SkAlphaType ##
Creates Image_Info from integral dimensions width and height, kN32_SkColorType,
kPremul_SkAlphaType, with optional Color_Space.

If Color_Space cs is nullptr and Image_Info is part of drawing source: Color_Space
defaults to sRGB, mapping into Surface Color_Space.

Parameters are not validated to see if their values are legal, or that the
combination is supported.

#Param width  pixel column count; must be zero or greater ##
#Param height  pixel row count; must be zero or greater ##
#Param cs  range of colors; may be nullptr ##

#Return created Image_Info ##

#Example
#Height 128
    SkBitmap bitmap;
    bitmap.allocPixels(SkImageInfo::MakeN32Premul(18, 18));
    SkCanvas offscreen(bitmap);
    offscreen.clear(SK_ColorWHITE);
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setTextSize(15);
    offscreen.drawString("\xF0\x9F\x98\xB8", 1, 15, paint);
    canvas->scale(6, 6);
    canvas->drawBitmap(bitmap, 0, 0);
##

#SeeAlso MakeN32 MakeS32 MakeA8 Make

#Method ##

# ------------------------------------------------------------------------------

#Method static SkImageInfo MakeN32Premul(const SkISize& size)

#In Constructor
Creates Image_Info from integral dimensions width and height, kN32_SkColorType,
kPremul_SkAlphaType, with Color_Space set to nullptr.

If Image_Info is part of drawing source: Color_Space defaults to sRGB, mapping
into Surface Color_Space.

Parameters are not validated to see if their values are legal, or that the
combination is supported.

#Param size  width and height, each must be zero or greater ##

#Return created Image_Info ##

#Example
#Height 128
    SkBitmap bitmap;
    bitmap.allocPixels(SkImageInfo::MakeN32Premul({18, 18}));
    SkCanvas offscreen(bitmap);
    offscreen.clear(SK_ColorWHITE);
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setTextSize(15);
    offscreen.drawString("\xF0\x9F\x98\xB9", 1, 15, paint);
    canvas->scale(6, 6);
    canvas->drawBitmap(bitmap, 0, 0);
##

#SeeAlso MakeN32 MakeS32 MakeA8 Make

#Method ##

# ------------------------------------------------------------------------------

#Method static SkImageInfo MakeA8(int width, int height)

#In Constructor
#Line # creates Image_Info with kAlpha_8_SkColorType, kPremul_SkAlphaType ##
Creates Image_Info from integral dimensions width and height, kAlpha_8_SkColorType,
kPremul_SkAlphaType, with Color_Space set to nullptr.

#Param width  pixel column count; must be zero or greater ##
#Param height  pixel row count; must be zero or greater ##

#Return created Image_Info ##

#Example
#Height 64
    uint8_t pixels[][8] = { { 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00},
                            { 0x00, 0x7f, 0xff, 0x3f, 0x3f, 0x7f, 0x3f, 0x00},
                            { 0x3f, 0xff, 0x7f, 0x00, 0x7f, 0xff, 0x7f, 0x00},
                            { 0x00, 0x3f, 0x00, 0x00, 0x3f, 0x7f, 0x3f, 0x00},
                            { 0x3f, 0x7f, 0x7f, 0x3f, 0x00, 0x00, 0x00, 0x00},
                            { 0x7f, 0xff, 0xff, 0x7f, 0x00, 0x3f, 0x7f, 0x3f},
                            { 0x7f, 0xff, 0xff, 0x7f, 0x00, 0x7f, 0xff, 0x7f},
                            { 0x3f, 0x7f, 0x7f, 0x3f, 0x00, 0x3f, 0x7f, 0x3f} };
    SkBitmap bitmap;
    bitmap.installPixels(SkImageInfo::MakeA8(8, 8),
            (void*) pixels, sizeof(pixels[0]));
    SkPaint paint;
    canvas->scale(4, 4);
    for (auto color : { SK_ColorRED, SK_ColorBLUE, 0xFF007F00} ) {
        paint.setColor(color);
        canvas->drawBitmap(bitmap, 0, 0, &paint);
        canvas->translate(12, 0);
    }
##

#SeeAlso MakeN32 MakeS32 Make

#Method ##

# ------------------------------------------------------------------------------

#Method static SkImageInfo MakeUnknown(int width, int height)

#In Constructor
#Line # creates Image_Info with kUnknown_SkColorType, kUnknown_SkAlphaType ##
Creates Image_Info from integral dimensions width and height, kUnknown_SkColorType,
kUnknown_SkAlphaType, with Color_Space set to nullptr.

Returned Image_Info as part of source does not draw, and as part of destination
can not be drawn to.

#Param width  pixel column count; must be zero or greater ##
#Param height  pixel row count; must be zero or greater ##

#Return created Image_Info ##

#Example
#Height 32
#Width 384
SkImageInfo info;  // default constructor
SkString string;
string.printf("SkImageInfo() %c= SkImageInfo::MakeUnknown(0, 0)",
              info == SkImageInfo::MakeUnknown(0, 0) ? '=' : '!');
SkPaint paint;
canvas->drawString(string, 0, 12, paint);
##

#SeeAlso SkImageInfo() MakeN32 MakeS32 Make

#Method ##

# ------------------------------------------------------------------------------

#Method static SkImageInfo MakeUnknown()

#In Constructor
Creates Image_Info from integral dimensions width and height set to zero,
kUnknown_SkColorType, kUnknown_SkAlphaType, with Color_Space set to nullptr.

Returned Image_Info as part of source does not draw, and as part of destination
can not be drawn to.

#Return created Image_Info ##

#Example
#Height 32
#Width 384
SkImageInfo info;  // default constructor
SkString string;
string.printf("SkImageInfo() %c= SkImageInfo::MakeUnknown()",
              info == SkImageInfo::MakeUnknown() ? '=' : '!');
SkPaint paint;
canvas->drawString(string, 0, 12, paint);
##

#SeeAlso SkImageInfo() MakeN32 MakeS32 Make

#Method ##


# ------------------------------------------------------------------------------
#Subtopic Property
#Populate
#Line # metrics and attributes ##
##

#Method int width() const
#In Property
#Line # returns pixel column count ##
Returns pixel count in each row.

#Return pixel width ##

#Example
#Image 4
#Height 96
   canvas->translate(10, 10);
   canvas->drawBitmap(source, 0, 0);
   SkImageInfo imageInfo = source.info();
   canvas->translate(0, imageInfo.height());
   SkPaint paint;
   paint.setTextAlign(SkPaint::kCenter_Align);
   canvas->drawLine(0, 10, imageInfo.width(), 10, paint);
   canvas->drawString("width", imageInfo.width() / 2, 25, paint);
##

#SeeAlso height SkBitmap::width SkPixelRef::width SkImage::width SkSurface::width

#Method ##

# ------------------------------------------------------------------------------

#Method int height() const
#In Property
#Line # returns pixel row count ##
Returns pixel row count.

#Return pixel height ##

#Example
#Image 4
#Height 96
   canvas->translate(10, 20);
   canvas->drawBitmap(source, 0, 0);
   SkImageInfo imageInfo = source.info();
   SkPaint paint;
   paint.setTextAlign(SkPaint::kCenter_Align);
   paint.setVerticalText(true);
   canvas->drawLine(imageInfo.width() + 10, 0, imageInfo.width() + 10, imageInfo.height(), paint);
   canvas->drawString("height", imageInfo.width() + 25, imageInfo.height() / 2, paint);
##

#SeeAlso width SkBitmap::height SkPixelRef::height SkImage::height SkSurface::height

#Method ##

# ------------------------------------------------------------------------------

#Method SkColorType colorType() const
#In Property
#Line # returns Color_Type ##
Returns Color_Type, one of: #list_of_color_types#.

#Return Color_Type ##

#Example
    const char* colors[] = {"Unknown", "Alpha_8", "RGB_565", "ARGB_4444", "RGBA_8888", "RGB_888x",
                            "BGRA_8888", "RGBA_1010102", "RGB_101010x", "Gray_8", "RGBA_F16"};
    SkImageInfo info = SkImageInfo::MakeA8(16, 32);
    SkDebugf("color type: k" "%s" "_SkColorType\n", colors[info.colorType()]);
#StdOut
color type: kAlpha_8_SkColorType
##
##

#SeeAlso alphaType SkPixmap::colorType SkBitmap::colorType

#Method ##

# ------------------------------------------------------------------------------

#Method SkAlphaType alphaType() const
#In Property
#Line # returns Alpha_Type ##
Returns Alpha_Type, one of: #list_of_alpha_types#.

#Return Alpha_Type ##

#Example
    const char* alphas[] = {"Unknown", "Opaque", "Premul", "Unpremul"};
    SkImageInfo info = SkImageInfo::MakeA8(16, 32);
    SkDebugf("alpha type: k" "%s" "_SkAlphaType\n", alphas[info.alphaType()]);
#StdOut
alpha type: kPremul_SkAlphaType
##
##

#SeeAlso colorType SkPixmap::alphaType SkBitmap::alphaType

#Method ##

# ------------------------------------------------------------------------------

#Method SkColorSpace* colorSpace() const
#In Property
#Line # returns Color_Space ##
Returns Color_Space, the range of colors. The reference count of
Color_Space is unchanged. The returned Color_Space is immutable.

#Return Color_Space, or nullptr ##

#Example
#Description
SkColorSpace::MakeSRGBLinear creates Color_Space with linear gamma
and an sRGB gamut. This Color_Space gamma is not close to sRGB gamma.
##
    SkImageInfo info = SkImageInfo::MakeN32(16, 32, kPremul_SkAlphaType,
            SkColorSpace::MakeSRGBLinear());
    SkColorSpace* colorSpace = info.colorSpace();
    SkDebugf("gammaCloseToSRGB: %s  gammaIsLinear: %s  isSRGB: %s\n",
            colorSpace->gammaCloseToSRGB() ? "true" : "false",
            colorSpace->gammaIsLinear() ? "true" : "false",
            colorSpace->isSRGB() ? "true" : "false");
#StdOut
gammaCloseToSRGB: false  gammaIsLinear: true  isSRGB: false
##
##

#SeeAlso Color_Space SkPixmap::colorSpace SkBitmap::colorSpace

#Method ##

# ------------------------------------------------------------------------------

#Method sk_sp<SkColorSpace> refColorSpace() const
#In Property
#Line # returns Color_Space ##
Returns smart pointer to Color_Space, the range of colors. The smart pointer
tracks the number of objects sharing this Color_Space reference so the memory
is released when the owners destruct.

The returned Color_Space is immutable.

#Return Color_Space wrapped in a smart pointer ##

#Example
    SkImageInfo info1 = SkImageInfo::MakeN32(16, 32, kPremul_SkAlphaType,
            SkColorSpace::MakeSRGBLinear());
    SkImageInfo info2 = SkImageInfo::MakeN32(16, 32, kPremul_SkAlphaType,
            info1.refColorSpace());
    SkColorSpace* colorSpace = info2.colorSpace();
    SkDebugf("gammaCloseToSRGB: %s  gammaIsLinear: %s  isSRGB: %s\n",
            colorSpace->gammaCloseToSRGB() ? "true" : "false",
            colorSpace->gammaIsLinear() ? "true" : "false",
            colorSpace->isSRGB() ? "true" : "false");
##

#SeeAlso Color_Space SkBitmap::refColorSpace

#Method ##

# ------------------------------------------------------------------------------

#Method bool isEmpty() const
#In Property
#Line # returns if dimensions contain pixels ##

Returns if Image_Info describes an empty area of pixels by checking if either
width or height is zero or smaller.

#Return true if either dimension is zero or smaller ##

#Example
    for (int width : { 0, 2 } ) {
        for (int height : { 0, 2 } ) {
             SkImageInfo imageInfo= SkImageInfo::MakeA8(width, height);
             SkDebugf("width: %d height: %d empty: %s\n", width, height,
                      imageInfo.isEmpty() ? "true" : "false");
        }
    }
#StdOut
width: 0 height: 0 empty: true
width: 0 height: 2 empty: true
width: 2 height: 0 empty: true
width: 2 height: 2 empty: false
##
##

#SeeAlso dimensions bounds SkBitmap::empty SkPixmap::bounds

#Method ##

# ------------------------------------------------------------------------------

#Method bool isOpaque() const
#In Property
#Line # returns if Alpha_Type is kOpaque_SkAlphaType ##

Returns true if Alpha_Type is set to hint that all pixels are opaque; their
Color_Alpha value is implicitly or explicitly 1.0. If true, and all pixels are
not opaque, Skia may draw incorrectly.

Does not check if Color_Type allows Alpha, or if any pixel value has
transparency.

#Return true if Alpha_Type is kOpaque_SkAlphaType ##

#Example
    const int height = 2;
    const int width = 2;
    SkBitmap bitmap;
    SkImageInfo imageInfo = SkImageInfo::Make(width, height, kN32_SkColorType, kPremul_SkAlphaType);
    bitmap.setInfo(imageInfo);
    for (int index = 0; index < 2; ++index) {
        bitmap.allocPixels();
        bitmap.eraseColor(0x00000000);
        SkDebugf("isOpaque: %s\n", imageInfo.isOpaque() ? "true" : "false");
        bitmap.eraseColor(0xFFFFFFFF);
        SkDebugf("isOpaque: %s\n", imageInfo.isOpaque() ? "true" : "false");
        imageInfo = imageInfo.makeAlphaType(kOpaque_SkAlphaType);
        bitmap.setInfo(imageInfo);
    }
#StdOut
isOpaque: false
isOpaque: false
isOpaque: true
isOpaque: true
##
##

#SeeAlso Color_Alpha SkColorTypeValidateAlphaType SkBitmap::isOpaque SkImage::isOpaque SkPixmap::isOpaque

#Method ##

# ------------------------------------------------------------------------------

#Method SkISize dimensions() const
#In Property
#Line # returns width() and height() ##

Returns ISize { width(), height() }.

#Return integral size of width() and height() ##

#Example
    const int height = 2;
    const int width = 2;
    SkImageInfo imageInfo = SkImageInfo::Make(width, height, kN32_SkColorType, kPremul_SkAlphaType);
    SkISize dimensions = imageInfo.dimensions();
    SkIRect bounds = imageInfo.bounds();
    SkIRect dimensionsAsBounds = SkIRect::MakeSize(dimensions);
    SkDebugf("dimensionsAsBounds %c= bounds\n", dimensionsAsBounds == bounds ? '=' : '!');
#StdOut
dimensionsAsBounds == bounds
##
##

#SeeAlso width height bounds SkBitmap::dimensions

#Method ##

# ------------------------------------------------------------------------------

#Method SkIRect bounds() const
#In Property
#Line # returns width() and height() as Rectangle ##
Returns IRect { 0, 0, width(), height() }.

#Return integral rectangle from origin to width() and height() ##

#Example
#Height 64
#Image 4
    canvas->scale(.5f, .5f);
    SkImageInfo imageInfo = source.info();
    SkIRect bounds = imageInfo.bounds();
    for (int x : { 0, bounds.width() } ) {
        for (int y : { 0, bounds.height() } ) {
            canvas->drawBitmap(source, x, y);
        }
    }
##

#SeeAlso width height dimensions

#Method ##

# ------------------------------------------------------------------------------

#Method bool gammaCloseToSRGB() const
#In Property
#Line # returns if Color_Space gamma is approximately the same as sRGB ##

Returns true if associated Color_Space is not nullptr, and Color_Space gamma
is approximately the same as sRGB.
This includes the
###$
$A sRGB transfer function $ https://en.wikipedia.org/wiki/SRGB#The_sRGB_transfer_function_(%22gamma%22) $$
$$$#
as well as a gamma curve described by a 2.2 exponent.

#Return true if Color_Space gamma is approximately the same as sRGB ##

#Example
#Height 144
    const int width = 256;
    const int height = 64;
    auto drawLabel = [=](const char* what, bool closeToSRGB) -> void {
        SkString string;
        string.printf("%s gamma is %s" "close to sRGB", what, closeToSRGB ? "" : "not ");
        SkPaint paint;
        paint.setAntiAlias(true);
        paint.setTextAlign(SkPaint::kCenter_Align);
        canvas->drawString(string, width / 2, 56, paint);
    };
    SkColor  gradColors[] = { 0xFFFF7F00, 0xFF00FF7F,  0xFF0000FF, 0xFF7F7FFF };
    SkPoint  gradPoints[] = { { 0, 0 }, { width, 0 }, { width * 2, 0 }, { width * 3, 0 } };
    SkPaint gradPaint;
    gradPaint.setShader(SkGradientShader::MakeLinear(gradPoints, gradColors, nullptr,
                    SK_ARRAY_COUNT(gradColors), SkShader::kClamp_TileMode));
    canvas->drawRect(SkRect::MakeWH(width, height), gradPaint);
    drawLabel("canvas", canvas->imageInfo().gammaCloseToSRGB());
    SkBitmap bitmap;
    SkImageInfo offscreenInfo = SkImageInfo::MakeS32(width, height, kPremul_SkAlphaType);
    bitmap.allocPixels(offscreenInfo);
    SkCanvas sRGBOffscreen(bitmap);
    sRGBOffscreen.drawRect(SkRect::MakeWH(width, height), gradPaint);
    canvas->translate(0, 80);
    canvas->drawBitmap(bitmap, 0, 0);
    drawLabel("offscreen", offscreenInfo.gammaCloseToSRGB());
##

#SeeAlso SkColorSpace::gammaCloseToSRGB

#Method ##

# ------------------------------------------------------------------------------

#Method SkImageInfo makeWH(int newWidth, int newHeight) const
#In Constructor
#Line # creates Image_Info with changed dimensions ##
Creates Image_Info with the same Color_Type, Color_Space, and Alpha_Type,
with dimensions set to width and height.

#Param newWidth   pixel column count; must be zero or greater ##
#Param newHeight  pixel row count; must be zero or greater ##

#Return created Image_Info ##

#Example
#Height 144
#Image 3
    SkImageInfo canvasImageInfo = canvas->imageInfo();
    SkRect canvasBounds = SkRect::Make(canvasImageInfo.bounds());
    canvas->drawBitmapRect(source, source.bounds(), canvasBounds, nullptr);
    SkImageInfo insetImageInfo =
              canvasImageInfo.makeWH(canvasBounds.width() / 2, canvasBounds.height() / 2);
    SkBitmap inset;
    inset.allocPixels(insetImageInfo);
    SkCanvas offscreen(inset);
    offscreen.drawBitmapRect(source, source.bounds(), SkRect::Make(inset.bounds()), nullptr);
    canvas->drawBitmap(inset, canvasBounds.width() / 4, canvasBounds.height() / 4);
##

#SeeAlso Make makeAlphaType makeColorSpace makeColorType

#Method ##

# ------------------------------------------------------------------------------

#Method SkImageInfo makeAlphaType(SkAlphaType newAlphaType) const
#In Constructor
#Line # creates Image_Info with changed Alpha_Type ##
Creates Image_Info with same Color_Type, Color_Space, width, and height,
with Alpha_Type set to newAlphaType.

Created Image_Info contains newAlphaType even if it is incompatible with
Color_Type, in which case Alpha_Type in Image_Info is ignored.

#Param newAlphaType  one of: #list_of_alpha_types#
##

#Return created Image_Info ##

#Example
#Image 3
    const int width = 256;
    const int height = 128;
    SkColor pixels[height][width];
    for (int y = 0; y < height; ++y) {
        for (int x = 0; x < width; ++x) {
            int red = SkScalarRoundToInt(255 * SkScalarAbs(SkScalarSin((x * 4 + y) * 0.03f)));
            int blue = SkScalarRoundToInt(255 * SkScalarAbs(SkScalarCos((x * 3 + y) * 0.04f)));
            int green = SkScalarRoundToInt(255 * SkScalarAbs(SkScalarSin((x * 2 + y) * 0.05f)));
            int alpha = SkScalarRoundToInt(255 * SkScalarAbs(SkScalarCos((x * 1 + y) * 0.006f)));
            pixels[y][x] =
                SkColorSetARGB(alpha, red * alpha / 255, green * alpha / 255, blue * alpha / 255);
        }
    }
    SkBitmap bitmap;
    SkImageInfo info = SkImageInfo::Make(width, height, kBGRA_8888_SkColorType, kPremul_SkAlphaType);
    bitmap.installPixels(info, (void*) pixels, sizeof(SkColor) * width);
    canvas->drawBitmap(source, 0, 0);
    canvas->drawBitmap(bitmap, 0, 0);
    SkImageInfo unpremulInfo = info.makeAlphaType(kUnpremul_SkAlphaType);
    bitmap.installPixels(unpremulInfo, (void*) pixels, sizeof(SkColor) * width);
    canvas->drawBitmap(bitmap, 0, 128);
##

#SeeAlso Make MakeA8 makeColorType makeColorSpace

#Method ##

# ------------------------------------------------------------------------------

#Method SkImageInfo makeColorType(SkColorType newColorType) const
#In Constructor
#Line # creates Image_Info with changed Color_Type ##
Creates Image_Info with same Alpha_Type, Color_Space, width, and height,
with Color_Type set to newColorType.

#Param newColorType  one of:  #list_of_color_types#
##

#Return created Image_Info ##

#Example
    const int width = 256;
    const int height = 128;
    SkColor pixels[height][width];
    for (int y = 0; y < height; ++y) {
        for (int x = 0; x < width; ++x) {
            int red = SkScalarRoundToInt(255 * SkScalarAbs(SkScalarSin((x * 4 + y) * 0.03f)));
            int blue = SkScalarRoundToInt(255 * SkScalarAbs(SkScalarCos((x * 3 + y) * 0.04f)));
            int green = SkScalarRoundToInt(255 * SkScalarAbs(SkScalarSin((x * 2 + y) * 0.05f)));
            int alpha = SkScalarRoundToInt(255 * SkScalarAbs(SkScalarCos((x * 1 + y) * 0.006f)));
            pixels[y][x] =
                SkColorSetARGB(alpha, red * alpha / 255, green * alpha / 255, blue * alpha / 255);
        }
    }
    SkBitmap bitmap;
    SkImageInfo info = SkImageInfo::Make(width, height, kBGRA_8888_SkColorType, kPremul_SkAlphaType);
    bitmap.installPixels(info, (void*) pixels, sizeof(SkColor) * width);
    canvas->drawBitmap(source, 0, 0);
    canvas->drawBitmap(bitmap, 0, 0);
    SkImageInfo rgbaInfo = info.makeColorType(kRGBA_8888_SkColorType);
    bitmap.installPixels(rgbaInfo, (void*) pixels, sizeof(SkColor) * width);
    canvas->drawBitmap(bitmap, 0, 128);
##

#SeeAlso Make makeAlphaType makeColorSpace

#Method ##

# ------------------------------------------------------------------------------

#Method SkImageInfo makeColorSpace(sk_sp<SkColorSpace> cs) const
#In Constructor
#Line # creates Image_Info with changed Color_Space ##
Creates Image_Info with same Alpha_Type, Color_Type, width, and height,
with Color_Space set to cs.

#Param cs  range of colors; may be nullptr ##

#Return created Image_Info ##

#Example
#Height 224
    const int width = 256;
    const int height = 64;
    auto drawLabel = [=](const char* what, bool closeToSRGB) -> void {
        SkString string;
        string.printf("%s gamma is %s" "close to sRGB", what, closeToSRGB ? "" : "not ");
        SkPaint paint;
        paint.setAntiAlias(true);
        paint.setTextAlign(SkPaint::kCenter_Align);
        canvas->drawString(string, width / 2, 56, paint);
    };
    SkColor  gradColors[] = { 0xFFFF7F00, 0xFF00FF7F,  0xFF0000FF, 0xFF7F7FFF };
    SkPoint  gradPoints[] = { { 0, 0 }, { width, 0 }, { width * 2, 0 }, { width * 3, 0 } };
    SkPaint gradPaint;
    gradPaint.setShader(SkGradientShader::MakeLinear(gradPoints, gradColors, nullptr,
            SK_ARRAY_COUNT(gradColors), SkShader::kClamp_TileMode));
    canvas->drawRect(SkRect::MakeWH(width, height), gradPaint);
    drawLabel("canvas", canvas->imageInfo().gammaCloseToSRGB());
    SkBitmap bitmap;
    SkImageInfo offscreenInfo = SkImageInfo::MakeS32(width, height, kPremul_SkAlphaType);
    bitmap.allocPixels(offscreenInfo);
    SkCanvas sRGBOffscreen(bitmap);
    sRGBOffscreen.drawRect(SkRect::MakeWH(width, height), gradPaint);
    canvas->translate(0, 80);
    canvas->drawBitmap(bitmap, 0, 0);
    drawLabel("offscreen", offscreenInfo.gammaCloseToSRGB());
    SkImageInfo linearGamma =
            offscreenInfo.makeColorSpace(offscreenInfo.colorSpace()->makeLinearGamma());
    bitmap.allocPixels(linearGamma);
    SkCanvas lgOffscreen(bitmap);
    lgOffscreen.drawRect(SkRect::MakeWH(width, height), gradPaint);
    canvas->translate(0, 80);
    canvas->drawBitmap(bitmap, 0, 0);
    drawLabel("linear", linearGamma.gammaCloseToSRGB());
##

#SeeAlso Make MakeS32 makeAlphaType makeColorType

#Method ##

# ------------------------------------------------------------------------------

#Method int bytesPerPixel() const
#In Property
#Line # returns number of bytes in pixel based on Color_Type ##
Returns number of bytes per pixel required by Color_Type.
Returns zero if colorType( is kUnknown_SkColorType.

#Return bytes in pixel ##

#Example
    const char* colors[] = {"Unknown", "Alpha_8", "RGB_565", "ARGB_4444", "RGBA_8888", "RGB_888x",
                            "BGRA_8888", "RGBA_1010102", "RGB_101010x", "Gray_8", "RGBA_F16"};
    for (SkColorType colorType : { #list_of_color_types#
                                 } ) {
        SkImageInfo info = SkImageInfo::Make(1, 1, colorType, kOpaque_SkAlphaType);
        SkDebugf("color: k" "%s" "_SkColorType" "%*s" "bytesPerPixel: %d\n",
                colors[colorType], 13 - strlen(colors[colorType]), " ",
                info.bytesPerPixel());
    }
#StdOut
color: kUnknown_SkColorType      bytesPerPixel: 0
color: kAlpha_8_SkColorType      bytesPerPixel: 1
color: kRGB_565_SkColorType      bytesPerPixel: 2
color: kARGB_4444_SkColorType    bytesPerPixel: 2
color: kRGBA_8888_SkColorType    bytesPerPixel: 4
color: kRGB_888x_SkColorType     bytesPerPixel: 4
color: kBGRA_8888_SkColorType    bytesPerPixel: 4
color: kRGBA_1010102_SkColorType bytesPerPixel: 4
color: kRGB_101010x_SkColorType  bytesPerPixel: 4
color: kGray_8_SkColorType       bytesPerPixel: 1
color: kRGBA_F16_SkColorType     bytesPerPixel: 8
##
##

#SeeAlso width shiftPerPixel SkBitmap::bytesPerPixel

#Method ##

# ------------------------------------------------------------------------------

#Method int shiftPerPixel() const
#In Property
#Line # returns bit shift from pixels to bytes ##
Returns bit shift converting row bytes to row pixels.
Returns zero for kUnknown_SkColorType.

#Return one of: 0, 1, 2, 3; left shift to convert pixels to bytes ##

#Example
    const char* colors[] = {"Unknown", "Alpha_8", "RGB_565", "ARGB_4444", "RGBA_8888", "RGB_888x",
                            "BGRA_8888", "RGBA_1010102", "RGB_101010x", "Gray_8", "RGBA_F16"};
    for (SkColorType colorType : { #list_of_color_types#
                                 } ) {
        SkImageInfo info = SkImageInfo::Make(1, 1, colorType, kOpaque_SkAlphaType);
        SkDebugf("color: k" "%s" "_SkColorType" "%*s" "shiftPerPixel: %d\n",
                colors[colorType], 14 - strlen(colors[colorType]), " ",
                info.shiftPerPixel());
    }
#StdOut
color: kUnknown_SkColorType       shiftPerPixel: 0
color: kAlpha_8_SkColorType       shiftPerPixel: 0
color: kRGB_565_SkColorType       shiftPerPixel: 1
color: kARGB_4444_SkColorType     shiftPerPixel: 1
color: kRGBA_8888_SkColorType     shiftPerPixel: 2
color: kRGB_888x_SkColorType      shiftPerPixel: 2
color: kBGRA_8888_SkColorType     shiftPerPixel: 2
color: kRGBA_1010102_SkColorType  shiftPerPixel: 2
color: kRGB_101010x_SkColorType   shiftPerPixel: 2
color: kGray_8_SkColorType        shiftPerPixel: 0
color: kRGBA_F16_SkColorType      shiftPerPixel: 3
##
##

#SeeAlso bytesPerPixel minRowBytes SkBitmap::shiftPerPixel SkPixmap::shiftPerPixel

#Method ##

# ------------------------------------------------------------------------------

#Method uint64_t minRowBytes64() const
#In Property
#Line # returns width() times bytesPerPixel in 64 bits ##

Returns minimum bytes per row, computed from pixel width() and Color_Type, which
specifies bytesPerPixel(). Bitmap maximum value for row bytes must fit
in 31 bits.

#Return width() times bytesPerPixel as unsigned 64-bit integer ##

#Example
    for (int shift = 24; shift < 32; ++shift) {
        int width = 1 << shift;
        SkImageInfo imageInfo =
                SkImageInfo::Make(width, 1, kRGBA_F16_SkColorType, kPremul_SkAlphaType);
        uint64_t minRowBytes = imageInfo.minRowBytes64();
        bool widthTooLarge = (uint64_t) (int32_t) minRowBytes != minRowBytes;
        SkDebugf("RGBA_F16 width %d (0x%08x) %s\n",
                width, width, widthTooLarge ? "too large" : "OK");
    }
#StdOut
RGBA_F16 width 16777216 (0x01000000) OK
RGBA_F16 width 33554432 (0x02000000) OK
RGBA_F16 width 67108864 (0x04000000) OK
RGBA_F16 width 134217728 (0x08000000) OK
RGBA_F16 width 268435456 (0x10000000) too large
RGBA_F16 width 536870912 (0x20000000) too large
RGBA_F16 width 1073741824 (0x40000000) too large
RGBA_F16 width -2147483648 (0x80000000) too large
##
##

#SeeAlso minRowBytes computeByteSize computeMinByteSize validRowBytes

#Method ##

# ------------------------------------------------------------------------------

#Method size_t minRowBytes() const
#In Property
#Line # returns width() times bytesPerPixel in 32 bits ##

Returns minimum bytes per row, computed from pixel width() and Color_Type, which
specifies bytesPerPixel(). Bitmap maximum value for row bytes must fit
in 31 bits.

#Return width() times bytesPerPixel as signed 32-bit integer ##

#Example
    for (int shift = 24; shift < 32; ++shift) {
        int width = 1 << shift;
        SkImageInfo imageInfo =
                SkImageInfo::Make(width, 1, kRGBA_F16_SkColorType, kPremul_SkAlphaType);
        size_t minRowBytes = imageInfo.minRowBytes();
        bool widthTooLarge = !minRowBytes;
        SkDebugf("RGBA_F16 width %d (0x%08x) %s\n",
                width, width, widthTooLarge ? "too large" : "OK");
    }
#StdOut
RGBA_F16 width 16777216 (0x01000000) OK
RGBA_F16 width 33554432 (0x02000000) OK
RGBA_F16 width 67108864 (0x04000000) OK
RGBA_F16 width 134217728 (0x08000000) OK
RGBA_F16 width 268435456 (0x10000000) too large
RGBA_F16 width 536870912 (0x20000000) too large
RGBA_F16 width 1073741824 (0x40000000) too large
RGBA_F16 width -2147483648 (0x80000000) too large
##
##

#SeeAlso minRowBytes64 computeByteSize computeMinByteSize validRowBytes

#Method ##

# ------------------------------------------------------------------------------

#Method size_t computeOffset(int x, int y, size_t rowBytes) const
#In Utility
#Line # returns byte offset within pixel array ##

Returns byte offset of pixel from pixel base address.

Asserts in debug build if x or y is outside of bounds. Does not assert if
rowBytes is smaller than minRowBytes, even though result may be incorrect.

#Param x  column index, zero or greater, and less than width() ##
#Param y  row index, zero or greater, and less than height() ##
#Param rowBytes  size of pixel row or larger ##

#Return offset within pixel array ##

#Example
#Height 128
    uint8_t pixels[][12] = { { 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00},
                             { 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00},
                             { 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00},
                             { 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0xFF},
                             { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                             { 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00},
                             { 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00},
                             { 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00} };
    SkImageInfo imageInfo = SkImageInfo::MakeA8(8, 8);
    SkBitmap bitmap;
    bitmap.installPixels(imageInfo, (void*) pixels, sizeof(pixels[0]));
    SkPaint paint;
    paint.setColor(SK_ColorRED);
    canvas->drawBitmapRect(bitmap, SkRect::MakeWH(8, 8), SkRect::MakeWH(32, 32), &paint);
    size_t offset = imageInfo.computeOffset(2, 3, sizeof(pixels[0]));
    pixels[0][offset] = 0x7F;
    offset = imageInfo.computeOffset(5, 3, sizeof(pixels[0]));
    pixels[0][offset] = 0x7F;
    bitmap.installPixels(imageInfo, (void*) pixels, sizeof(pixels[0]));
    canvas->drawBitmapRect(bitmap, SkRect::MakeWH(8, 8), SkRect::MakeWH(128, 128), &paint);
##

#SeeAlso height width minRowBytes computeByteSize

#Method ##

# ------------------------------------------------------------------------------
#Subtopic Operator
#Populate
##

#Method bool operator==(const SkImageInfo& other)_const
#Line # compares Image_Info for equality ##

Compares Image_Info with other, and returns true if width, height, Color_Type,
Alpha_Type, and Color_Space are equivalent.

#Param other  Image_Info to compare ##

#Return true if Image_Info equals other ##

#Example
    SkImageInfo info1 = SkImageInfo::Make(10, 20, kGray_8_SkColorType, kPremul_SkAlphaType);
    SkImageInfo info2 = SkImageInfo::Make(20, 10, kAlpha_8_SkColorType, kUnpremul_SkAlphaType);
    SkDebugf("info1 %c= info2\n", info1 == info2 ? '=' : '!');
    info2 = info2.makeWH(10, 20);
    SkDebugf("info1 %c= info2\n", info1 == info2 ? '=' : '!');
    info2 = info2.makeColorType(kGray_8_SkColorType);
    SkDebugf("info1 %c= info2\n", info1 == info2 ? '=' : '!');
    info2 = info2.makeAlphaType(kPremul_SkAlphaType);
    SkDebugf("info1 %c= info2\n", info1 == info2 ? '=' : '!');
#StdOut
info1 != info2
info1 != info2
info1 != info2
info1 == info2
##
##

#SeeAlso operator!=(const SkImageInfo& other)_const SkColorSpace::Equals

#Method ##

# ------------------------------------------------------------------------------

#Method bool operator!=(const SkImageInfo& other)_const
#Line # compares Image_Info for inequality ##

Compares Image_Info with other, and returns true if width, height, Color_Type,
Alpha_Type, and Color_Space are not equivalent.

#Param other  Image_Info to compare ##

#Return true if Image_Info is not equal to other ##

#Example
    SkImageInfo info1 = SkImageInfo::Make(10, 20, kGray_8_SkColorType, kPremul_SkAlphaType);
    SkImageInfo info2 = SkImageInfo::Make(20, 10, kAlpha_8_SkColorType, kUnpremul_SkAlphaType);
    SkDebugf("info1 %c= info2\n", info1 != info2 ? '!' : '=');
    info2 = info2.makeWH(10, 20);
    SkDebugf("info1 %c= info2\n", info1 != info2 ? '!' : '=');
    info2 = info2.makeColorType(kGray_8_SkColorType);
    SkDebugf("info1 %c= info2\n", info1 != info2 ? '!' : '=');
    info2 = info2.makeAlphaType(kPremul_SkAlphaType);
    SkDebugf("info1 %c= info2\n", info1 != info2 ? '!' : '=');
#StdOut
info1 != info2
info1 != info2
info1 != info2
info1 == info2
##
##

#SeeAlso operator==(const SkImageInfo& other)_const SkColorSpace::Equals

#Method ##

# ------------------------------------------------------------------------------

#Method size_t computeByteSize(size_t rowBytes) const
#In Utility
#Line # returns memory required by pixel buffer with given row bytes ##
Returns storage required by pixel array, given Image_Info dimensions, Color_Type,
and rowBytes. rowBytes is assumed to be at least as large as minRowBytes().

Returns zero if height is zero.
Returns SIZE_MAX if answer exceeds the range of size_t.

#Param rowBytes  size of pixel row or larger ##

#Return memory required by pixel buffer ##

#Example
#Height 130
    SkImageInfo info = SkImageInfo::MakeN32Premul(2, 2);
    const size_t size = info.computeByteSize(100000);
    SkAutoTMalloc<SkPMColor> storage(size);
    SkPMColor* pixels = storage.get();
    SkBitmap bitmap;
    bitmap.setInfo(info);
    bitmap.setPixels(pixels);
    bitmap.eraseColor(SK_ColorRED);
    canvas->scale(50, 50);
    canvas->rotate(8);
    canvas->drawBitmap(bitmap, 2, 0);
##

#SeeAlso computeMinByteSize validRowBytes

#Method ##

# ------------------------------------------------------------------------------

#Method size_t computeMinByteSize() const
#In Utility
#Line # returns least memory required by pixel buffer ##
Returns storage required by pixel array, given Image_Info dimensions, and
Color_Type. Uses minRowBytes() to compute bytes for pixel row.

Returns zero if height is zero.
Returns SIZE_MAX if answer exceeds the range of size_t.

#Return least memory required by pixel buffer ##

#Example
#Height 130
    SkImageInfo info = SkImageInfo::MakeN32Premul(2, 2);
    const size_t size = info.computeMinByteSize();
    SkAutoTMalloc<SkPMColor> storage(size);
    SkPMColor* pixels = storage.get();
    SkBitmap bitmap;
    bitmap.setInfo(info);
    bitmap.setPixels(pixels);
    bitmap.eraseColor(SK_ColorRED);
    canvas->scale(50, 50);
    canvas->rotate(8);
    canvas->drawBitmap(bitmap, 2, 0);
##

#SeeAlso computeByteSize validRowBytes

#Method ##

# ------------------------------------------------------------------------------

#Method static bool ByteSizeOverflowed(size_t byteSize)
#In Utility
#Line # checks result of computeByteSize and computeMinByteSize ##
Returns true if byteSize equals SIZE_MAX. computeByteSize and
computeMinByteSize return SIZE_MAX if size_t can not hold buffer size.

#Param byteSize  result of computeByteSize or computeMinByteSize ##

#Return true if computeByteSize or computeMinByteSize result exceeds size_t ##

#Example
    SkImageInfo info = SkImageInfo::MakeN32Premul(2, 1000000000);
    for (size_t rowBytes = 100000000; rowBytes < 10000000000000LL; rowBytes *= 10) {
        const size_t size = info.computeByteSize(rowBytes);
        SkDebugf("rowBytes:%llu size:%llu overflowed:%s\n", rowBytes, size,
                 SkImageInfo::ByteSizeOverflowed(size) ? "true" : "false");
    }
#StdOut
rowBytes:100000000 size:99999999900000008 overflowed:false
rowBytes:1000000000 size:999999999000000008 overflowed:false
rowBytes:10000000000 size:9999999990000000008 overflowed:false
rowBytes:100000000000 size:18446744073709551615 overflowed:true
rowBytes:1000000000000 size:18446744073709551615 overflowed:true
##
##

#SeeAlso computeByteSize computeMinByteSize validRowBytes

#Method ##

# ------------------------------------------------------------------------------

#Method bool validRowBytes(size_t rowBytes) const
#In Utility
#Line # checks if row bytes is large enough to contain pixel row ##
Returns true if rowBytes is smaller than width times pixel size.

#Param rowBytes  size of pixel row or larger ##

#Return true if rowBytes is large enough to contain pixel row ##

#Example
    SkImageInfo info = SkImageInfo::MakeN32Premul(16, 8);
    for (size_t rowBytes = 60; rowBytes < 72; rowBytes += sizeof(SkPMColor)) {
        SkDebugf("validRowBytes(%llu): %s\n", rowBytes, info.validRowBytes(rowBytes) ?
                 "true" : "false");
    }
#StdOut
validRowBytes(60): false
validRowBytes(64): true
validRowBytes(68): true
##
##

#SeeAlso ByteSizeOverflowed computeByteSize computeMinByteSize

#Method ##

# ------------------------------------------------------------------------------

#Method void reset()
#In Constructor
#Line # sets zero dimensions, kUnknown_SkColorType, kUnknown_SkAlphaType ##
Creates an empty Image_Info with kUnknown_SkColorType, kUnknown_SkAlphaType,
a width and height of zero, and no Color_Space.

#Example
    SkImageInfo info = SkImageInfo::MakeN32Premul(16, 8);
    SkImageInfo copy = info;
    SkDebugf("info %c= copy\n", info == copy ? '=' : '!');
    copy.reset();
    SkDebugf("info %c= reset copy\n", info == copy ? '=' : '!');
    SkDebugf("SkImageInfo() %c= reset copy\n", SkImageInfo() == copy ? '=' : '!');
#StdOut
info == copy
info != reset copy
SkImageInfo() == reset copy
##
##

#SeeAlso SkImageInfo()

#Method ##

# ------------------------------------------------------------------------------
#Subtopic Utility
#Populate
#Line # rarely called management functions ##
##

#Method void validate() const
#In Utility
#Line # asserts if Image_Info is invalid (debug only) ##
Asserts if internal values are illegal or inconsistent. Only available if
SK_DEBUG is defined at compile time.

#NoExample
##

#SeeAlso validRowBytes SkBitmap::validate

#Method ##

#Struct SkImageInfo ##

#Topic Image_Info ##
