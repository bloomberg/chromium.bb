#Topic Pixmap
#Alias Pixmap_Reference ##

#Class SkPixmap

#Code
#Populate
##

Pixmap provides a utility to pair SkImageInfo with pixels and row bytes.
Pixmap is a low level class which provides convenience functions to access
raster destinations. Canvas can not draw Pixmap, nor does Pixmap provide
a direct drawing destination.

Use Bitmap to draw pixels referenced by Pixmap; use Surface to draw into
pixels referenced by Pixmap.

Pixmap does not try to manage the lifetime of the pixel memory. Use Pixel_Ref
to manage pixel memory; Pixel_Ref is safe across threads.


#Subtopic Initialization
#Line # sets fields for use ##

# ------------------------------------------------------------------------------

#Method SkPixmap()

#In Initialization
#Line # constructs with default values ##
#Populate

#Example
void draw(SkCanvas* canvas) {
    const char* alphas[] = {"Unknown", "Opaque", "Premul", "Unpremul"};
    const char* colors[] = {"Unknown", "Alpha_8", "RGB_565", "ARGB_4444", "RGBA_8888", "RGB_888x",
                            "BGRA_8888", "RGBA_1010102", "RGB_101010x", "Gray_8", "RGBA_F16"};
    SkPixmap pixmap;
    for (int i = 0; i < 2; ++i) {
       SkDebugf("width: %2d  height: %2d", pixmap.width(), pixmap.height());
       SkDebugf("  color: k%s_SkColorType", colors[pixmap.colorType()]);
       SkDebugf("  alpha: k%s_SkAlphaType\n", alphas[pixmap.alphaType()]);
       pixmap.reset(SkImageInfo::Make(25, 35, kRGBA_8888_SkColorType, kOpaque_SkAlphaType),
                    nullptr, 0);
    }
}
#StdOut
width:  0  height:  0  color: kUnknown_SkColorType  alpha: kUnknown_SkAlphaType
width: 25  height: 35  color: kRGBA_8888_SkColorType  alpha: kOpaque_SkAlphaType
##
##

#SeeAlso SkPixmap(const SkImageInfo& info, const void* addr, size_t rowBytes) reset() SkAlphaType SkColorType

##

# ------------------------------------------------------------------------------

#Method SkPixmap(const SkImageInfo& info, const void* addr, size_t rowBytes)

#In Initialization
#Line # constructs from Image_Info, pixels ##
#Populate

#Example
#Image 3
#Description
SkImage::MakeRasterCopy takes const SkPixmap& as an argument. The example
constructs a SkPixmap from the brace-delimited parameters.
##
    SkDebugf("image alpha only = %s\n", image->isAlphaOnly() ? "true" : "false");
    SkPMColor pmColors = 0;
    sk_sp<SkImage> copy = SkImage::MakeRasterCopy({SkImageInfo::MakeA8(1, 1),
                                                  (uint8_t*)&pmColors,
                                                  1});
    SkDebugf("copy alpha only = %s\n", copy->isAlphaOnly() ? "true" : "false");
#StdOut
image alpha only = false
copy alpha only = true
##
##

#SeeAlso SkPixmap() reset() SkAlphaType SkColorType

##

# ------------------------------------------------------------------------------

#Method void reset()

#In Initialization
#Line # reuses existing Pixmap with replacement values ##
#Populate

#Example
void draw(SkCanvas* canvas) {
    const char* alphas[] = {"Unknown", "Opaque", "Premul", "Unpremul"};
    const char* colors[] = {"Unknown", "Alpha_8", "RGB_565", "ARGB_4444", "RGBA_8888", "RGB_888x",
                            "BGRA_8888", "RGBA_1010102", "RGB_101010x", "Gray_8", "RGBA_F16"};
    SkPixmap pixmap(SkImageInfo::Make(25, 35, kRGBA_8888_SkColorType, kOpaque_SkAlphaType),
                    nullptr, 0);
    for (int i = 0; i < 2; ++i) {
       SkDebugf("width: %2d  height: %2d", pixmap.width(), pixmap.height());
       SkDebugf("  color: k%s_SkColorType", colors[pixmap.colorType()]);
       SkDebugf("  alpha: k%s_SkAlphaType\n", alphas[pixmap.alphaType()]);
       pixmap.reset();
    }
}
#StdOut
width: 25  height: 35  color: kRGBA_8888_SkColorType  alpha: kOpaque_SkAlphaType
width:  0  height:  0  color: kUnknown_SkColorType  alpha: kUnknown_SkAlphaType
##
##

#SeeAlso SkPixmap() SkAlphaType SkColorType

##

# ------------------------------------------------------------------------------

#Method void reset(const SkImageInfo& info, const void* addr, size_t rowBytes)

#In Initialization
#Populate

#Example
#Image 4
#Height 64
void draw(SkCanvas* canvas) {
    std::vector<int32_t> pixels;
    pixels.resize(image->height() * image->width() * 4);
    SkPixmap pixmap(SkImageInfo::Make(image->width(), image->height(), kN32_SkColorType,
            image->alphaType()), (const void*) &pixels.front(), image->width() * 4);
    image->readPixels(pixmap, 0, 0);
    int x = 0;
    for (auto colorType : { kRGBA_8888_SkColorType, kBGRA_8888_SkColorType } ) {
        pixmap.reset(SkImageInfo::Make(image->width(), image->height(), colorType,
                image->alphaType()), (const void*) &pixels.front(), image->width() * 4);
        SkBitmap bitmap;
        bitmap.installPixels(pixmap);
        canvas->drawBitmap(bitmap, x, 0);
        x += 128;
    }
}
##

#SeeAlso SkPixmap(const SkImageInfo& info, const void* addr, size_t rowBytes) reset() SkAlphaType SkColorType

##

# ------------------------------------------------------------------------------

#Method void setColorSpace(sk_sp<SkColorSpace> colorSpace)

#In Initialization
#Line # sets Image_Info Color_Space ##
#Populate

#Example
void draw(SkCanvas* canvas) {
    SkPixmap pixmap;
    sk_sp<SkColorSpace> colorSpace1 = SkColorSpace::MakeRGB(SkNamedTransferFn::kLinear,
                                                            SkNamedGamut::kRec2020);
    SkDebugf("is %sunique\n", colorSpace1->unique() ? "" : "not ");
    pixmap.setColorSpace(colorSpace1);
    SkDebugf("is %sunique\n", colorSpace1->unique() ? "" : "not ");
}
#StdOut
is unique
is not unique
##
##

#SeeAlso Color_Space SkImageInfo::makeColorSpace

##

# ------------------------------------------------------------------------------

#Method bool extractSubset(SkPixmap* subset, const SkIRect& area) const

#In Initialization
#Line # sets pointer to portion of original ##
#Populate

#Example
#Image 3
#Height 128
void draw(SkCanvas* canvas) {
    std::vector<int32_t> pixels;
    pixels.resize(image->height() * image->width() * 4);
    SkPixmap pixmap(SkImageInfo::Make(image->width(), image->height(), kN32_SkColorType,
            image->alphaType()), (const void*) &pixels.front(), image->width() * 4);
    image->readPixels(pixmap, 0, 0);
    SkPixmap inset;
    if (pixmap.extractSubset(&inset, {128, 128, 512, 512})) {
        SkBitmap bitmap;
        bitmap.installPixels(inset);
        canvas->drawBitmap(bitmap, 0, 0);
    }
}
##

#SeeAlso reset() SkIRect::intersect

##

#Subtopic Initialization ##

#Subtopic Image_Info_Access
#Line # returns all or part of Image_Info ##

# ------------------------------------------------------------------------------

#Method const SkImageInfo& info() const

#In Image_Info_Access
#Line # returns Image_Info ##
#Populate

#Example
#Image 3
    std::vector<int32_t> pixels;
    pixels.resize(image->height() * image->width() * 4);
    SkPixmap pixmap(SkImageInfo::Make(image->width(), image->height(), kN32_SkColorType,
            image->alphaType()), (const void*) &pixels.front(), image->width() * 4);
    image->readPixels(pixmap, 0, 0);
    SkPixmap inset;
    if (pixmap.extractSubset(&inset, {128, 128, 512, 512})) {
        const SkImageInfo& info = inset.info();
        const char* alphas[] = {"Unknown", "Opaque", "Premul", "Unpremul"};
        const char* colors[] = {"Unknown", "Alpha_8", "RGB_565", "ARGB_4444", "RGBA_8888",
                "RGB_888x", "BGRA_8888", "RGBA_1010102", "RGB_101010x", "Gray_8", "RGBA_F16"};
        SkDebugf("width: %d height: %d color: %s alpha: %s\n", info.width(), info.height(),
                 colors[info.colorType()], alphas[info.alphaType()]);
    }
#StdOut
width: 384 height: 384 color: BGRA_8888 alpha: Opaque
##
##

#SeeAlso Image_Info

##

# ------------------------------------------------------------------------------

#Method size_t rowBytes() const

#In Image_Info_Access
#Line # returns interval between rows in bytes ##
Returns row bytes, the interval from one pixel row to the next. Row bytes
is at least as large as: #Formula # width() * info().bytesPerPixel() ##.

Returns zero if colorType is kUnknown_SkColorType.
It is up to the Bitmap creator to ensure that row bytes is a useful value.

#Return  byte length of pixel row ##

#Example
SkPixmap badPixmap = {SkImageInfo::MakeA8(4, 4), nullptr, 2};
SkPixmap okPixmap = {SkImageInfo::MakeA8(4, 4), nullptr, 8};
for (auto& pixmap : { badPixmap, okPixmap } ) {
    SkDebugf("rowBytes: %d minRowBytes: %d\n", pixmap.rowBytes(),
       pixmap.info().minRowBytes());
}
#StdOut
rowBytes: 2 minRowBytes: 4
rowBytes: 8 minRowBytes: 4
##
##

#SeeAlso addr() info() SkImageInfo::minRowBytes

##

# ------------------------------------------------------------------------------

#Method const void* addr() const

#In Image_Info_Access
#Line # returns readable pixel address as void pointer ##
#Populate

#Example
#Image 3
    std::vector<int32_t> pixels;
    pixels.resize(image->height() * image->width() * 4);
    SkPixmap pixmap(SkImageInfo::Make(image->width(), image->height(), kN32_SkColorType,
            image->alphaType()), (const void*) &pixels.front(), image->width() * 4);
    image->readPixels(pixmap, 0, 0);
    SkDebugf("pixels address: 0x%llx\n", pixmap.addr());
    SkPixmap inset;
    if (pixmap.extractSubset(&inset, {128, 128, 512, 512})) {
         SkDebugf("inset address:  0x%llx\n", inset.addr());
    }
#StdOut
#Volatile
pixels address: 0x7f2a440bb010
inset address:  0x7f2a440fb210
##
##

#SeeAlso addr(int x, int y) addr8 addr16 addr32 addr64 info() rowBytes()

##

# ------------------------------------------------------------------------------

#Method int width() const

#In Image_Info_Access
#Line # returns pixel column count ##
Returns pixel count in each pixel row. Should be equal or less than:

#Formula # rowBytes() / info().bytesPerPixel() ##.

#Return  pixel width in Image_Info ##

#Example
    SkImageInfo info = SkImageInfo::MakeA8(16, 32);
    SkPixmap pixmap(info, nullptr, 64);
    SkDebugf("pixmap width: %d  info width: %d\n", pixmap.width(), info.width());
#StdOut
pixmap width: 16  info width: 16
##
##

#SeeAlso height() SkImageInfo::width()

##

# ------------------------------------------------------------------------------

#Method int height() const

#In Image_Info_Access
#Line # returns pixel row count ##
#Populate

#Example
    SkPixmap pixmap(SkImageInfo::MakeA8(16, 32), nullptr, 64);
    SkDebugf("pixmap height: %d  info height: %d\n", pixmap.height(), pixmap.info().height());
#StdOut
pixmap height: 32  info height: 32
##
##

#SeeAlso width SkImageInfo::height

##

# ------------------------------------------------------------------------------

#Method SkColorType colorType() const

#In Image_Info_Access
#Line # returns Image_Info Color_Type ##
Returns Color_Type, one of: #list_of_color_types#.

#Return  Color_Type in Image_Info ##

#Example
    const char* colors[] = {"Unknown", "Alpha_8", "RGB_565", "ARGB_4444", "RGBA_8888", "RGB_888x",
                            "BGRA_8888", "RGBA_1010102", "RGB_101010x", "Gray_8", "RGBA_F16"};
    SkPixmap pixmap(SkImageInfo::MakeA8(16, 32), nullptr, 64);
    SkDebugf("color type: k" "%s" "_SkColorType\n", colors[pixmap.colorType()]);
#StdOut
color type: kAlpha_8_SkColorType
##
##

#SeeAlso alphaType() SkImageInfo::colorType

##

# ------------------------------------------------------------------------------

#Method SkAlphaType alphaType() const

#In Image_Info_Access
#Line # returns Image_Info Alpha_Type ##
Returns Alpha_Type, one of: #list_of_alpha_types#.

#Return  Alpha_Type in Image_Info ##

#Example
    const char* alphas[] = {"Unknown", "Opaque", "Premul", "Unpremul"};
    SkPixmap pixmap(SkImageInfo::MakeA8(16, 32), nullptr, 64);
    SkDebugf("alpha type: k" "%s" "_SkAlphaType\n", alphas[pixmap.alphaType()]);
#StdOut
alpha type: kPremul_SkAlphaType
##
##

#SeeAlso colorType() SkImageInfo::alphaType

##

# ------------------------------------------------------------------------------

#Method SkColorSpace* colorSpace() const

#In Image_Info_Access
#Line # returns Image_Info Color_Space ##
#Populate

#Example
#Description
SkColorSpace::MakeSRGBLinear creates Color_Space with linear gamma
and an sRGB gamut. This Color_Space gamma is not close to sRGB gamma.
##
    SkPixmap pixmap(SkImageInfo::MakeN32(16, 32, kPremul_SkAlphaType,
            SkColorSpace::MakeSRGBLinear()), nullptr, 64);
    SkColorSpace* colorSpace = pixmap.colorSpace();
    SkDebugf("gammaCloseToSRGB: %s  gammaIsLinear: %s  isSRGB: %s\n",
            colorSpace->gammaCloseToSRGB() ? "true" : "false",
            colorSpace->gammaIsLinear() ? "true" : "false",
            colorSpace->isSRGB() ? "true" : "false");
#StdOut
gammaCloseToSRGB: false  gammaIsLinear: true  isSRGB: false
##
##

#SeeAlso Color_Space SkImageInfo::colorSpace

##

# ------------------------------------------------------------------------------

#Method bool isOpaque() const

#In Image_Info_Access
#Line # returns true if Image_Info describes opaque pixels ##
#Populate

#Example
#Description
    isOpaque ignores whether all pixels are opaque or not.
##
    std::vector<uint32_t> pixels;
    const int height = 2;
    const int width = 2;
    pixels.resize(height * width * 4);
    SkPixmap pixmap(SkImageInfo::Make(width, height, kN32_SkColorType,
            kPremul_SkAlphaType), (const void*) &pixels.front(), width * 4);
    for (int index = 0; index < 2; ++index) {
        pixmap.erase(0x00000000);
        SkDebugf("isOpaque: %s\n", pixmap.isOpaque() ? "true" : "false");
        pixmap.erase(0xFFFFFFFF);
        SkDebugf("isOpaque: %s\n", pixmap.isOpaque() ? "true" : "false");
        pixmap.reset(pixmap.info().makeAlphaType(kOpaque_SkAlphaType),
                     (const void*) &pixels.front(), width * 4);
    }
#StdOut
isOpaque: false
isOpaque: false
isOpaque: true
isOpaque: true
##
##

#SeeAlso computeIsOpaque SkImageInfo::isOpaque

##

# ------------------------------------------------------------------------------

#Method SkIRect bounds() const

#In Image_Info_Access
#Line # returns width and height as Rectangle ##
#Populate

#Example
    for (int width : { 0, 2 } ) {
        for (int height : { 0, 2 } ) {
             SkPixmap pixmap(SkImageInfo::MakeA8(width, height), nullptr, width);
             SkDebugf("width: %d height: %d empty: %s\n", width, height,
                      pixmap.bounds().isEmpty() ? "true" : "false");
        }
    }
#StdOut
width: 0 height: 0 empty: true
width: 0 height: 2 empty: true
width: 2 height: 0 empty: true
width: 2 height: 2 empty: false
##
##

#SeeAlso height() width() IRect

##

# ------------------------------------------------------------------------------

#Method int rowBytesAsPixels() const

#In Image_Info_Access
#Line # returns interval between rows in pixels ##
#Populate

#Example
    for (int rowBytes : { 4, 5, 6, 7, 8} ) {
        SkPixmap pixmap(SkImageInfo::MakeN32(1, 1, kPremul_SkAlphaType), nullptr, rowBytes);
        SkDebugf("rowBytes: %d rowBytesAsPixels: %d\n", rowBytes, pixmap.rowBytesAsPixels());
    }
#StdOut
rowBytes: 4 rowBytesAsPixels: 1
rowBytes: 5 rowBytesAsPixels: 1
rowBytes: 6 rowBytesAsPixels: 1
rowBytes: 7 rowBytesAsPixels: 1
rowBytes: 8 rowBytesAsPixels: 2
##
##

#SeeAlso rowBytes shiftPerPixel width SkImageInfo::bytesPerPixel

##

# ------------------------------------------------------------------------------

#Method int shiftPerPixel() const

#In Image_Info_Access
#Line # returns bit shift from pixels to bytes ##
#Populate

#Example
    const char* colors[] = {"Unknown", "Alpha_8", "RGB_565", "ARGB_4444", "RGBA_8888", "RGB_888x",
                            "BGRA_8888", "RGBA_1010102", "RGB_101010x", "Gray_8", "RGBA_F16"};
    SkImageInfo info = SkImageInfo::MakeA8(1, 1);
    for (SkColorType colorType : { kUnknown_SkColorType,   kAlpha_8_SkColorType,
                                   kRGB_565_SkColorType,   kARGB_4444_SkColorType,
                                   kRGBA_8888_SkColorType, kBGRA_8888_SkColorType,
                                   kGray_8_SkColorType,    kRGBA_F16_SkColorType } ) {
        SkPixmap pixmap(info.makeColorType(colorType), nullptr, 4);
        SkDebugf("color: k" "%s" "_SkColorType" "%*s" "bytesPerPixel: %d shiftPerPixel: %d\n",
                colors[colorType], 10 - strlen(colors[colorType]), " ",
                pixmap.info().bytesPerPixel(), pixmap.shiftPerPixel());
    }
#StdOut
color: kUnknown_SkColorType   bytesPerPixel: 0 shiftPerPixel: 0
color: kAlpha_8_SkColorType   bytesPerPixel: 1 shiftPerPixel: 0
color: kRGB_565_SkColorType   bytesPerPixel: 2 shiftPerPixel: 1
color: kARGB_4444_SkColorType bytesPerPixel: 2 shiftPerPixel: 1
color: kRGBA_8888_SkColorType bytesPerPixel: 4 shiftPerPixel: 2
color: kBGRA_8888_SkColorType bytesPerPixel: 4 shiftPerPixel: 2
color: kGray_8_SkColorType    bytesPerPixel: 1 shiftPerPixel: 0
color: kRGBA_F16_SkColorType  bytesPerPixel: 8 shiftPerPixel: 3
##
##

#SeeAlso rowBytes rowBytesAsPixels width SkImageInfo::bytesPerPixel

##

# ------------------------------------------------------------------------------

#Method size_t computeByteSize() const

#In Image_Info_Access
#Line # returns size required for pixels ##
#Populate

#Example
    SkPixmap pixmap;
    for (int width : { 1, 1000, 1000000 } ) {
        for (int height: { 1, 1000, 1000000 } ) {
            SkImageInfo imageInfo = SkImageInfo::MakeN32(width, height, kPremul_SkAlphaType);
            pixmap.reset(imageInfo, nullptr, width * 5);
            SkDebugf("width: %7d height: %7d computeByteSize: %13lld\n", width, height,
                     pixmap.computeByteSize());
        }
    }
#StdOut
width:       1 height:       1 computeByteSize:             4
width:       1 height:    1000 computeByteSize:          4999
width:       1 height: 1000000 computeByteSize:       4999999
width:    1000 height:       1 computeByteSize:          4000
width:    1000 height:    1000 computeByteSize:       4999000
width:    1000 height: 1000000 computeByteSize:    4999999000
width: 1000000 height:       1 computeByteSize:       4000000
width: 1000000 height:    1000 computeByteSize:    4999000000
width: 1000000 height: 1000000 computeByteSize: 4999999000000
##
##

#SeeAlso SkImageInfo::computeByteSize

##

#Subtopic Image_Info_Access ##

#Subtopic Reader
#Line # examine pixel value ##

# ------------------------------------------------------------------------------

#Method bool computeIsOpaque() const

#In Reader
#Line # returns true if all pixels are opaque ##
#Populate

#Example
    std::vector<uint32_t> pixels;
    const int height = 2;
    const int width = 2;
    pixels.resize(height * width * 4);
    SkPixmap pixmap(SkImageInfo::Make(width, height, kN32_SkColorType,
            kPremul_SkAlphaType), (const void*) &pixels.front(), width * 4);
    for (int index = 0; index < 2; ++index) {
        pixmap.erase(0x00000000);
        SkDebugf("computeIsOpaque: %s\n", pixmap.computeIsOpaque() ? "true" : "false");
        pixmap.erase(0xFFFFFFFF);
        SkDebugf("computeIsOpaque: %s\n", pixmap.computeIsOpaque() ? "true" : "false");
        pixmap.reset(pixmap.info().makeAlphaType(kOpaque_SkAlphaType),
                     (const void*) &pixels.front(), width * 4);
    }
#StdOut
computeIsOpaque: false
computeIsOpaque: true
computeIsOpaque: false
computeIsOpaque: true
##
##

#SeeAlso isOpaque Color_Type Alpha

##

# ------------------------------------------------------------------------------

#Method SkColor getColor(int x, int y) const

#In Reader
#Line # returns one pixel as Unpremultiplied Color ##
#Populate

#Example
    const int w = 4;
    const int h = 4;
    std::vector<SkPMColor> storage;
    storage.resize(w * h);
    SkDebugf("Premultiplied:\n");
    for (int y = 0; y < h; ++y) {
        SkDebugf("(0, %d) ", y);
        for (int x = 0; x < w; ++x) {
            int a = 0xFF * (x + y) / (w - 1 + h - 1);
            storage[x + y * w] = SkPackARGB32(a, a * x / (w - 1), a * y / (h - 1), a);
            SkDebugf("0x%08x%c", storage[x + y * w], x == w - 1 ? '\n' : ' ');
        }
    }
    SkPixmap pixmap(SkImageInfo::MakeN32(w, h, kPremul_SkAlphaType), &storage.front(), w * 4);
    SkDebugf("Unpremultiplied:\n");
    for (int y = 0; y < h; ++y) {
        SkDebugf("(0, %d) ", y);
        for (int x = 0; x < w; ++x) {
            SkDebugf("0x%08x%c", pixmap.getColor(x, y), x == w - 1 ? '\n' : ' ');
        }
    }
#StdOut
Premultiplied:
(0, 0) 0x00000000 0x2a0e002a 0x55380055 0x7f7f007f
(0, 1) 0x2a000e2a 0x551c1c55 0x7f542a7f 0xaaaa38aa
(0, 2) 0x55003855 0x7f2a547f 0xaa7171aa 0xd4d48dd4
(0, 3) 0x7f007f7f 0xaa38aaaa 0xd48dd4d4 0xffffffff
Unpremultiplied:
(0, 0) 0x00000000 0x2a5500ff 0x55a800ff 0x7fff00ff
(0, 1) 0x2a0055ff 0x555454ff 0x7fa954ff 0xaaff54ff
(0, 2) 0x5500a8ff 0x7f54a9ff 0xaaaaaaff 0xd4ffaaff
(0, 3) 0x7f00ffff 0xaa54ffff 0xd4aaffff 0xffffffff
##
##

#SeeAlso getAlphaf addr() readPixels

##

#Method float getAlphaf(int x, int y) const
#In Property
#Line # returns Alpha normalized from zero to one ##

Looks up the pixel at (x,y) and return its alpha component, normalized to [0..1].
This is roughly equivalent to #Formula # SkGetColorA(getColor()) ##, but can be more efficient
(and more precise if the pixels store more than 8 bits per component).

#Param x  column index, zero or greater, and less than width() ##
#Param y  row index, zero or greater, and less than height() ##

#Return   alpha converted to normalized float ##

#NoExample
##

#SeeAlso getColor

##

#Subtopic Reader ##

#Subtopic Readable_Address
#Line # returns read only pixels ##

# ------------------------------------------------------------------------------

#Method const void* addr(int x, int y) const

#In Readable_Address
#Populate

#Example
    const int w = 4;
    const int h = 4;
    std::vector<SkPMColor> storage;
    storage.resize(w * h);
    SkPixmap pixmap(SkImageInfo::MakeN32(w, h, kPremul_SkAlphaType), &storage.front(), w * 4);
    SkDebugf("pixmap.addr(1, 2) %c= &storage[1 + 2 * w]\n",
              pixmap.addr(1, 2)  == &storage[1 + 2 * w] ? '=' : '!');
#StdOut
pixmap.addr(1, 2) == &storage[1 + 2 * w]
##
##

#SeeAlso addr8 addr16 addr32 addr64 addrF16 getColor writable_addr SkBitmap::getAddr

##

# ------------------------------------------------------------------------------

#Method const uint8_t* addr8() const

#In Readable_Address
#Line # returns readable pixel address as 8-bit pointer ##
#Populate

#Example
    const int w = 4;
    const int h = 4;
    uint8_t storage[w * h];
    SkPixmap pixmap(SkImageInfo::Make(w, h, kGray_8_SkColorType, kPremul_SkAlphaType),
                    storage, w * sizeof(storage[0]));
    SkDebugf("pixmap.addr8() %c= storage\n",
              pixmap.addr8()  == storage ? '=' : '!');
#StdOut
pixmap.addr8() == storage
##
##

#SeeAlso addr() addr16 addr32 addr64 addrF16 getColor writable_addr writable_addr8

##

# ------------------------------------------------------------------------------

#Method const uint16_t* addr16() const

#In Readable_Address
#Line # returns readable pixel address as 16-bit pointer ##
#Populate

#Example
    const int w = 4;
    const int h = 4;
    uint16_t storage[w * h];
    SkPixmap pixmap(SkImageInfo::Make(w, h, kARGB_4444_SkColorType, kPremul_SkAlphaType),
                    storage, w * sizeof(storage[0]));
    SkDebugf("pixmap.addr16() %c= storage\n",
              pixmap.addr16()  == storage ? '=' : '!');
#StdOut
pixmap.addr16() == storage
##
##

#SeeAlso addr() addr8 addr32 addr64 addrF16 getColor writable_addr writable_addr16

##

# ------------------------------------------------------------------------------

#Method const uint32_t* addr32() const

#In Readable_Address
#Line # returns readable pixel address as 32-bit pointer ##
#Populate

#Example
    const int w = 4;
    const int h = 4;
    uint32_t storage[w * h];
    SkPixmap pixmap(SkImageInfo::MakeN32(w, h, kPremul_SkAlphaType),
                    storage, w * sizeof(storage[0]));
    SkDebugf("pixmap.addr32() %c= storage\n",
              pixmap.addr32()  == storage ? '=' : '!');
#StdOut
pixmap.addr32() == storage
##
##

#SeeAlso addr() addr8 addr16 addr64 addrF16 getColor writable_addr writable_addr32

##

# ------------------------------------------------------------------------------

#Method const uint64_t* addr64() const

#In Readable_Address
#Line # returns readable pixel address as 64-bit pointer ##
#Populate

#Example
    const int w = 4;
    const int h = 4;
    uint64_t storage[w * h];
    SkPixmap pixmap(SkImageInfo::Make(w, h, kRGBA_F16_SkColorType, kPremul_SkAlphaType),
                    storage, w * sizeof(storage[0]));
    SkDebugf("pixmap.addr64() %c= storage\n",
              pixmap.addr64()  == storage ? '=' : '!');
#StdOut
pixmap.addr64() == storage
##
##

#SeeAlso addr() addr8 addr16 addr32 addrF16 getColor writable_addr writable_addr64

##

# ------------------------------------------------------------------------------

#Method const uint16_t* addrF16() const

#In Readable_Address
#Line # returns readable pixel component address as 16-bit pointer ##
#Populate

#Example
    const int w = 4;
    const int h = 4;
    uint16_t storage[w * h * 4];
    SkPixmap pixmap(SkImageInfo::Make(w, h, kRGBA_F16_SkColorType, kPremul_SkAlphaType),
                    storage, w * 4 * sizeof(storage[0]));
    SkDebugf("pixmap.addrF16() %c= storage\n",
              pixmap.addrF16()  == storage ? '=' : '!');
#StdOut
pixmap.addrF16() == storage
##
##

#SeeAlso addr() addr8 addr16 addr32 addr64 getColor writable_addr writable_addrF16

##

# ------------------------------------------------------------------------------

#Method const uint8_t* addr8(int x, int y) const

#In Readable_Address
#Populate

#Example
    const int w = 4;
    const int h = 4;
    uint8_t storage[w * h];
    SkPixmap pixmap(SkImageInfo::Make(w, h, kGray_8_SkColorType, kPremul_SkAlphaType),
                    storage, w * sizeof(storage[0]));
    SkDebugf("pixmap.addr8(1, 2) %c= &storage[1 + 2 * w]\n",
              pixmap.addr8(1, 2)  == &storage[1 + 2 * w] ? '=' : '!');
#StdOut
pixmap.addr8(1, 2) == &storage[1 + 2 * w]
##
##

#SeeAlso addr() addr16 addr32 addr64 addrF16 getColor writable_addr writable_addr8

##

# ------------------------------------------------------------------------------

#Method const uint16_t* addr16(int x, int y) const

#In Readable_Address
#Populate

#Example
    const int w = 4;
    const int h = 4;
    uint16_t storage[w * h];
    SkPixmap pixmap(SkImageInfo::Make(w, h, kARGB_4444_SkColorType, kPremul_SkAlphaType),
                    storage, w * sizeof(storage[0]));
    SkDebugf("pixmap.addr16(1, 2) %c= &storage[1 + 2 * w]\n",
              pixmap.addr16(1, 2)  == &storage[1 + 2 * w] ? '=' : '!');
#StdOut
pixmap.addr16(1, 2) == &storage[1 + 2 * w]
##
##

#SeeAlso addr() addr8 addr32 addr64 addrF16 getColor writable_addr writable_addr16

##

# ------------------------------------------------------------------------------

#Method const uint32_t* addr32(int x, int y) const

#In Readable_Address
#Populate

#Example
    const int w = 4;
    const int h = 4;
    uint32_t storage[w * h];
    SkPixmap pixmap(SkImageInfo::Make(w, h, kRGBA_8888_SkColorType, kPremul_SkAlphaType),
                    storage, w * sizeof(storage[0]));
    SkDebugf("pixmap.addr32(1, 2) %c= &storage[1 + 2 * w]\n",
              pixmap.addr32(1, 2)  == &storage[1 + 2 * w] ? '=' : '!');
#StdOut
pixmap.addr32(1, 2) == &storage[1 + 2 * w]
##
##

#SeeAlso addr() addr8 addr16 addr64 addrF16 getColor writable_addr writable_addr64

##

# ------------------------------------------------------------------------------

#Method const uint64_t* addr64(int x, int y) const

#In Readable_Address
#Populate

#Example
    const int w = 4;
    const int h = 4;
    uint64_t storage[w * h];
    SkPixmap pixmap(SkImageInfo::Make(w, h, kRGBA_F16_SkColorType, kPremul_SkAlphaType),
                    storage, w * sizeof(storage[0]));
    SkDebugf("pixmap.addr64(1, 2) %c= &storage[1 + 2 * w]\n",
              pixmap.addr64(1, 2)  == &storage[1 + 2 * w] ? '=' : '!');
#StdOut
pixmap.addr64(1, 2) == &storage[1 + 2 * w]
##
##

#SeeAlso addr() addr8 addr16 addr32 addrF16 getColor writable_addr writable_addr64

##

# ------------------------------------------------------------------------------

#Method const uint16_t* addrF16(int x, int y) const

#In Readable_Address
#Populate

#Example
    const int w = 4;
    const int h = 4;
    const int wordsPerPixel = 4;
    const int rowWords = w * wordsPerPixel;
    uint16_t storage[rowWords * h];
    SkPixmap pixmap(SkImageInfo::Make(w, h, kRGBA_F16_SkColorType, kPremul_SkAlphaType),
                    storage, rowWords * sizeof(storage[0]));
    SkDebugf("pixmap.addrF16(1, 2) %c= &storage[1 * wordsPerPixel + 2 * rowWords]\n",
              pixmap.addrF16(1, 2)  == &storage[1 * wordsPerPixel + 2 * rowWords] ? '=' : '!');
#StdOut
pixmap.addrF16(1, 2) == &storage[1 * wordsPerPixel + 2 * rowWords]
##
##

#SeeAlso addr() addr8 addr16 addr32 addr64 getColor writable_addr writable_addrF16

##

#Subtopic Readable_Address ##

#Subtopic Writable_Address
#Line # returns writable pixels ##

# ------------------------------------------------------------------------------

#Method void* writable_addr() const

#In Writable_Address
#Line # returns writable pixel address as void pointer ##
#Populate

#Example
    const int w = 4;
    const int h = 4;
    SkPMColor storage[w * h * 4];
    SkPixmap pixmap(SkImageInfo::MakeN32(w, h, kPremul_SkAlphaType), storage, w * 4);
    SkDebugf("pixmap.writable_addr() %c= (void *)storage\n",
              pixmap.writable_addr()  == (void *)storage ? '=' : '!');
    pixmap.erase(0x00000000);
    *(SkPMColor*)pixmap.writable_addr() = 0xFFFFFFFF;
    SkDebugf("pixmap.getColor(0, 1) %c= 0x00000000\n",
              pixmap.getColor(0, 1)  == 0x00000000 ? '=' : '!');
    SkDebugf("pixmap.getColor(0, 0) %c= 0xFFFFFFFF\n",
              pixmap.getColor(0, 0)  == 0xFFFFFFFF ? '=' : '!');
#StdOut
pixmap.writable_addr() == (void *)storage
pixmap.getColor(0, 1) == 0x00000000
pixmap.getColor(0, 0) == 0xFFFFFFFF
##
##

#SeeAlso writable_addr8 writable_addr16 writable_addr32 writable_addr64 writable_addrF16 addr()

##

# ------------------------------------------------------------------------------

#Method void* writable_addr(int x, int y) const

#In Writable_Address
#Populate

#Example
    const int w = 4;
    const int h = 4;
    SkPMColor storage[w * h * 4];
    SkPixmap pixmap(SkImageInfo::MakeN32(w, h, kPremul_SkAlphaType), storage, w * 4);
    SkDebugf("pixmap.writable_addr() %c= (void *)storage\n",
              pixmap.writable_addr()  == (void *)storage ? '=' : '!');
    pixmap.erase(0x00000000);
    *(SkPMColor*)pixmap.writable_addr(1, 2) = 0xFFFFFFFF;
    SkDebugf("pixmap.getColor(0, 0) %c= 0x00000000\n",
              pixmap.getColor(0, 0)  == 0x00000000 ? '=' : '!');
    SkDebugf("pixmap.getColor(1, 2) %c= 0xFFFFFFFF\n",
              pixmap.getColor(1, 2)  == 0xFFFFFFFF ? '=' : '!');
#StdOut
pixmap.writable_addr() == (void *)storage
pixmap.getColor(0, 0) == 0x00000000
pixmap.getColor(1, 2) == 0xFFFFFFFF
##
##

#SeeAlso writable_addr8 writable_addr16 writable_addr32 writable_addr64 writable_addrF16 addr()

##

# ------------------------------------------------------------------------------

#Method uint8_t* writable_addr8(int x, int y) const

#In Writable_Address
#Line # returns writable pixel address as 8-bit pointer ##
#Populate

#Example
#Height 64
#Description
Altering pixels after drawing Bitmap is not guaranteed to affect subsequent
drawing on all platforms. Adding a second SkBitmap::installPixels after editing
pixel memory is safer.
##
void draw(SkCanvas* canvas) {
    uint8_t storage[][5] = {{ 0,   0,  64,   0,  0},
                            { 0, 128, 255, 128,  0},
                            {64, 255, 255, 255, 64},
                            { 0, 128, 255, 128,  0},
                            { 0,   0,  64,   0,  0}};
    SkImageInfo imageInfo = SkImageInfo::Make(5, 5, kGray_8_SkColorType, kPremul_SkAlphaType);
    SkPixmap pixmap(imageInfo, storage[0], 5);
    SkBitmap bitmap;
    bitmap.installPixels(pixmap);
    canvas->scale(10, 10);
    canvas->drawBitmap(bitmap, 0, 0);
    *pixmap.writable_addr8(2, 2) = 0;
//  bitmap.installPixels(pixmap);      // uncomment to fix on GPU
    canvas->drawBitmap(bitmap, 10, 0);
}
##

#SeeAlso writable_addr writable_addr16 writable_addr32 writable_addr64 writable_addrF16 addr() addr8

##

# ------------------------------------------------------------------------------

#Method uint16_t* writable_addr16(int x, int y) const

#In Writable_Address
#Line # returns writable pixel address as 16-bit pointer ##
#Populate

#Example
#Description
Draw a five by five bitmap, and draw it again with a center black pixel.
The low nibble of the 16-bit word is Alpha.
##
#Height 64
    uint16_t storage[][5] = {{ 0xCABF, 0xDABE, 0xCA9D, 0xC96C, 0xA39B },
                             { 0xACEE, 0xA87C, 0x893A, 0x4779, 0x8708 },
                             { 0x4B7C, 0x255B, 0x2559, 0x2557, 0x4656 },
                             { 0x9099, 0x8128, 0x2557, 0x4124, 0x3323 },
                             { 0x7547, 0x5505, 0x4434, 0x2012, 0x0000 }};
    SkImageInfo imageInfo = SkImageInfo::Make(5, 5, kARGB_4444_SkColorType, kPremul_SkAlphaType);
    SkPixmap pixmap(imageInfo, storage[0], sizeof(storage) / 5);
    SkBitmap bitmap;
    bitmap.installPixels(pixmap);
    canvas->scale(10, 10);
    canvas->drawBitmap(bitmap, 0, 0);
    *pixmap.writable_addr16(2, 2) = 0x000F;
    bitmap.installPixels(pixmap);
    canvas->drawBitmap(bitmap, 10, 0);
##

#SeeAlso writable_addr writable_addr8 writable_addr32 writable_addr64 writable_addrF16 addr() addr16

##

# ------------------------------------------------------------------------------

#Method uint32_t* writable_addr32(int x, int y) const

#In Writable_Address
#Line # returns writable pixel address as 32-bit pointer ##
#Populate

#Example
#Image 4
#Height 72
    std::vector<int32_t> pixels;
    pixels.resize(image->height() * image->width() * 4);
    SkPixmap pixmap(SkImageInfo::Make(image->width(), image->height(), kN32_SkColorType,
            image->alphaType()), (const void*) &pixels.front(), image->width() * 4);
    image->readPixels(pixmap, 0, 0);
    for (int y = 0; y < pixmap.height() / 2; ++y) {
        for (int x = 0; x < pixmap.width(); ++x) {
            if ((x & 4) == (y & 4)) {
                *pixmap.writable_addr32(x, y) =
                        *pixmap.writable_addr32(pixmap.width() - x, pixmap.height() - y);
            }
        }
    }
    SkBitmap bitmap;
    bitmap.installPixels(pixmap);
    canvas->drawBitmap(bitmap, 0, 0);
##

#SeeAlso writable_addr writable_addr8 writable_addr16 writable_addr64 writable_addrF16 addr() addr32

##

# ------------------------------------------------------------------------------

#Method uint64_t* writable_addr64(int x, int y) const

#In Writable_Address
#Line # returns writable pixel address as 64-bit pointer ##
#Populate

#Example
#Height 40
    SkImageInfo info = SkImageInfo::Make(3, 3, kRGBA_F16_SkColorType, kPremul_SkAlphaType);
    uint64_t storage[9];
    SkPixmap pixmap(info, storage, 3 * sizeof(uint64_t));
    SkColor4f c4 { 1, 0.45f, 0.25f, 0.65f };
    pixmap.erase(c4);
    SkBitmap bitmap;
    canvas->scale(10, 10);
    bitmap.installPixels(pixmap);
    canvas->drawBitmap(bitmap, 0, 0);
    *pixmap.writable_addr64(1, 1) |= 0x00ff000000000000LL;
    bitmap.installPixels(pixmap);
    canvas->drawBitmap(bitmap, 10, 0);
##

#SeeAlso writable_addr writable_addr8 writable_addr16 writable_addr32 writable_addrF16 addr() addr64

##

# ------------------------------------------------------------------------------

#Method uint16_t* writable_addrF16(int x, int y) const

#In Writable_Address
#Line # returns writable pixel component address as 16-bit pointer ##
#Populate

#Example
#Height 64
#Description
Left bitmap is drawn with two pixels defined in half float format. Right bitmap
is drawn after overwriting bottom half float color with top half float color.
##
    SkImageInfo info = SkImageInfo::Make(1, 2, kRGBA_F16_SkColorType, kPremul_SkAlphaType);
    uint16_t storage[2][4];
    SkPixmap pixmap(info, storage[0], sizeof(uint64_t));
    SkIRect topPixelBounds = {0, 0, 1, 1};
    pixmap.erase({ 0.65f, 0.45f, 0.25f, 1 }, &topPixelBounds);
    SkIRect bottomPixelBounds = {0, 1, 1, 2};
    pixmap.erase({ 0.25f, 0.65f, 0.45f, 1 }, &bottomPixelBounds);
    SkBitmap bitmap;
    canvas->scale(20, 20);
    bitmap.installPixels(pixmap);
    canvas->drawBitmap(bitmap, 0, 0);
    uint16_t* pixel2 = pixmap.writable_addrF16(0, 1);
    for (int i = 0; i < 4; ++i) {
        pixel2[i] = storage[0][i];
    }
    bitmap.installPixels(pixmap);
    canvas->drawBitmap(bitmap, 4, 0);
##

#SeeAlso writable_addr writable_addr8 writable_addr16 writable_addr32 writable_addr64 addr() addrF16

##

#Subtopic Writable_Address ##

#Subtopic Pixels
#Line # read and write pixel values ##
##

# ------------------------------------------------------------------------------

#Method bool readPixels(const SkImageInfo& dstInfo, void* dstPixels, size_t dstRowBytes) const
#In Pixels
#Line # copies and converts pixels ##
#Populate

#Example
#Height 128
#Description
Transferring the gradient from 8 bits per component to 4 bits per component
creates visible banding.
##
    std::vector<int32_t> pixels;
    const int width = 256;
    const int height = 64;
    pixels.resize(height * width * 4);
    SkImageInfo srcInfo = SkImageInfo::MakeN32Premul(width, height);
    SkPixmap srcPixmap(srcInfo, (const void*) &pixels.front(), width * 4);
    SkColor  gradColors[] = { 0xFFAA3300, 0x7F881122 };
    SkPoint  gradPoints[] = { { 0, 0 }, { 256, 0 } };
    SkPaint paint;
    paint.setShader(SkGradientShader::MakeLinear(gradPoints, gradColors, nullptr,
                    SK_ARRAY_COUNT(gradColors), SkShader::kClamp_TileMode));
    SkBitmap bitmap;
    bitmap.installPixels(srcPixmap);
    SkCanvas srcCanvas(bitmap);
    srcCanvas.drawRect(SkRect::MakeWH(width, height), paint);
    canvas->drawBitmap(bitmap, 0, 0);
    std::vector<int32_t> dstPixels;
    dstPixels.resize(height * width * 2);
    SkImageInfo dstInfo = srcInfo.makeColorType(kARGB_4444_SkColorType);
    srcPixmap.readPixels(dstInfo, &dstPixels.front(), width * 2);
    SkPixmap dstPixmap(dstInfo, &dstPixels.front(), width * 2);
    bitmap.installPixels(dstPixmap);
    canvas->drawBitmap(bitmap, 0, 128);
##

#SeeAlso erase SkBitmap::readPixels SkCanvas::drawBitmap SkCanvas::readPixels SkImage::readPixels SkSurface::readPixels

##

# ------------------------------------------------------------------------------

#Method bool readPixels(const SkImageInfo& dstInfo, void* dstPixels, size_t dstRowBytes, int srcX,
                    int srcY) const

Copies a Rect of pixels to dstPixels. Copy starts at (srcX, srcY), and does not
exceed Pixmap (width(), height()).

dstInfo specifies width, height, Color_Type, Alpha_Type, and
Color_Space of destination. dstRowBytes specifics the gap from one destination
row to the next. Returns true if pixels are copied. Returns false if
dstInfo has no address, or dstRowBytes is less than dstInfo.minRowBytes().

Pixels are copied only if pixel conversion is possible. If Pixmap colorType is
kGray_8_SkColorType, or kAlpha_8_SkColorType; dstInfo.colorType() must match.
If Pixmap colorType is kGray_8_SkColorType, dstInfo.colorSpace() must match.
If Pixmap alphaType is kOpaque_SkAlphaType, dstInfo.alphaType() must
match. If Pixmap colorSpace is nullptr, dstInfo.colorSpace() must match. Returns
false if pixel conversion is not possible.

srcX and srcY may be negative to copy only top or left of source. Returns
false if Pixmap width() or height() is zero or negative. Returns false if:

#Formula # abs(srcX) >= Pixmap width() ##, or if #Formula # abs(srcY) >= Pixmap height() ##.

#Param dstInfo  destination width, height, Color_Type, Alpha_Type, Color_Space ##
#Param dstPixels  destination pixel storage ##
#Param dstRowBytes  destination row length ##
#Param srcX  column index whose absolute value is less than width() ##
#Param srcY  row index whose absolute value is less than height() ##

#Return  true if pixels are copied to dstPixels ##

#Example
#Image 3
void draw(SkCanvas* canvas) {
    SkImageInfo info = SkImageInfo::MakeN32Premul(image->width(), image->height());
    std::vector<int32_t> srcPixels;
    const int rowBytes = image->width() * 4;
    srcPixels.resize(image->height() * rowBytes);
    SkPixmap pixmap(info, (const void*) &srcPixels.front(), rowBytes);
    image->readPixels(pixmap, 0, 0);
    for (int offset : { 32, 64, 96 } ) {
        std::vector<int32_t> dstPixels;
        dstPixels.resize(image->height() * rowBytes);
        pixmap.readPixels(info, &dstPixels.front(), rowBytes, offset, 0);
        SkBitmap bitmap;
        SkPixmap dstmap(info, &dstPixels.front(), rowBytes);
        bitmap.installPixels(dstmap);
        canvas->translate(32, 32);
        canvas->drawBitmap(bitmap, 0, 0);
    }
}
##

#SeeAlso erase SkBitmap::readPixels SkCanvas::drawBitmap SkCanvas::readPixels SkImage::readPixels SkSurface::readPixels

##

# ------------------------------------------------------------------------------

#Method bool readPixels(const SkPixmap& dst, int srcX, int srcY) const

Copies a Rect of pixels to dst. Copy starts at (srcX, srcY), and does not
exceed Pixmap (width(), height()). dst specifies width, height, Color_Type,
Alpha_Type, and Color_Space of destination.  Returns true if pixels are copied.
Returns false if dst.addr() equals nullptr, or dst.rowBytes() is less than
dst SkImageInfo::minRowBytes.

Pixels are copied only if pixel conversion is possible. If Pixmap colorType is
kGray_8_SkColorType, or kAlpha_8_SkColorType; dst.info().colorType() must match.
If Pixmap colorType is kGray_8_SkColorType, dst.info().colorSpace() must match.
If Pixmap alphaType is kOpaque_SkAlphaType, dst.info().alphaType() must
match. If Pixmap colorSpace is nullptr, dst.info().colorSpace() must match. Returns
false if pixel conversion is not possible.

srcX and srcY may be negative to copy only top or left of source. Returns
false Pixmap width() or height() is zero or negative. Returns false if:

#Formula # abs(srcX) >= Pixmap width() ##, or if #Formula # abs(srcY) >= Pixmap height() ##.

#Param dst  Image_Info and pixel address to write to ##
#Param srcX  column index whose absolute value is less than width() ##
#Param srcY  row index whose absolute value is less than height() ##

#Return  true if pixels are copied to dst ##

#Example
#Image 3
void draw(SkCanvas* canvas) {
    SkImageInfo info = SkImageInfo::MakeN32Premul(image->width(), image->height());
    std::vector<int32_t> srcPixels;
    const int rowBytes = image->width() * 4;
    srcPixels.resize(image->height() * rowBytes);
    SkPixmap pixmap(info, (const void*) &srcPixels.front(), rowBytes);
    image->readPixels(pixmap, 0, 0);
    for (int offset : { 32, 64, 96 } ) {
        std::vector<int32_t> dstPixels;
        dstPixels.resize(image->height() * rowBytes);
        SkPixmap dstmap(info, &dstPixels.front(), rowBytes);
        pixmap.readPixels(dstmap, offset, 0);
        SkBitmap bitmap;
        bitmap.installPixels(dstmap);
        canvas->translate(32, 32);
        canvas->drawBitmap(bitmap, 0, 0);
    }
}
##

#SeeAlso erase SkBitmap::readPixels SkCanvas::drawBitmap SkCanvas::readPixels SkImage::readPixels SkSurface::readPixels

##

# ------------------------------------------------------------------------------

#Method bool readPixels(const SkPixmap& dst) const
#Populate

#Example
#Image 3
void draw(SkCanvas* canvas) {
    SkImageInfo info = SkImageInfo::MakeN32Premul(image->width(), image->height());
    std::vector<int32_t> srcPixels;
    const int rowBytes = image->width() * 4;
    srcPixels.resize(image->height() * rowBytes);
    SkPixmap pixmap(info, (const void*) &srcPixels.front(), rowBytes);
    image->readPixels(pixmap, 0, 0);
    for (int index = 0; index < 3; ++index ) {
        std::vector<int32_t> dstPixels;
        dstPixels.resize(image->height() * rowBytes);
        SkPixmap dstmap(info, &dstPixels.front(), rowBytes);
        pixmap.readPixels(dstmap);
        SkBitmap bitmap;
        bitmap.installPixels(dstmap);
        canvas->translate(32, 32);
        canvas->drawBitmap(bitmap, 0, 0);
    }
}
##

#SeeAlso erase SkBitmap::readPixels SkCanvas::drawBitmap SkCanvas::readPixels SkImage::readPixels SkSurface::readPixels

##

# ------------------------------------------------------------------------------

#Method bool scalePixels(const SkPixmap& dst, SkFilterQuality filterQuality) const

#In Pixels
#Line # scales and converts pixels ##
#Populate

#Example
#Image 3
void draw(SkCanvas* canvas) {
    SkImageInfo info = SkImageInfo::MakeN32Premul(image->width(), image->height());
    std::vector<int32_t> srcPixels;
    int rowBytes = image->width() * 4;
    srcPixels.resize(image->height() * rowBytes);
    SkPixmap pixmap(info, (const void*) &srcPixels.front(), rowBytes);
    image->readPixels(pixmap, 0, 0);
    for (int offset : { 32, 64, 96 } ) {
        info = SkImageInfo::MakeN32Premul(image->width() + offset, image->height());
        rowBytes = info.width() * 4;
        std::vector<int32_t> dstPixels;
        dstPixels.resize(image->height() * rowBytes);
        SkPixmap dstmap(info, &dstPixels.front(), rowBytes);
        pixmap.scalePixels(dstmap, kMedium_SkFilterQuality);
        SkBitmap bitmap;
        bitmap.installPixels(dstmap);
        canvas->translate(32, 32);
        canvas->drawBitmap(bitmap, 0, 0);
    }
}
##

#SeeAlso SkCanvas::drawBitmap SkImage::scalePixels

##

# ------------------------------------------------------------------------------

#Method bool erase(SkColor color, const SkIRect& subset) const

#In Pixels
#Line # writes Color to pixels ##
#Populate

#Example
#Height 50
    uint32_t storage[2];
    SkImageInfo info = SkImageInfo::MakeN32Premul(1, 2);
    SkPixmap pixmap(info, storage, info.minRowBytes());
    pixmap.erase(SK_ColorBLUE, {0, 0, 1, 1});
    pixmap.erase(SK_ColorRED, {0, 1, 1, 2});
    SkBitmap bitmap;
    canvas->scale(20, 20);
    bitmap.installPixels(pixmap);
    canvas->drawBitmap(bitmap, 0, 0);
##

#SeeAlso SkBitmap::erase SkCanvas::clear SkCanvas::drawColor

##

# ------------------------------------------------------------------------------

#Method bool erase(SkColor color) const
#Populate

#Example
#Height 50
    uint32_t storage[2];
    SkImageInfo info = SkImageInfo::MakeN32Premul(1, 2);
    SkPixmap pixmap(info, storage, info.minRowBytes());
    pixmap.erase(SK_ColorBLUE);
    SkBitmap bitmap;
    canvas->scale(20, 20);
    bitmap.installPixels(pixmap);
    canvas->drawBitmap(bitmap, 0, 0);
##

#SeeAlso SkBitmap::erase SkCanvas::clear SkCanvas::drawColor

##

# ------------------------------------------------------------------------------

#Method bool erase(const SkColor4f& color, const SkIRect* subset = nullptr) const
#Populate

#Example
#Height 50
    uint32_t storage[2];
    SkImageInfo info = SkImageInfo::MakeN32Premul(1, 2);
    SkPixmap pixmap(info, storage, info.minRowBytes());
    SkIRect topPixelBounds = {0, 0, 1, 1};
    pixmap.erase({ 0.65f, 0.45f, 0.25f, 1 }, &topPixelBounds);
    SkIRect bottomPixelBounds = {0, 1, 1, 2};
    pixmap.erase({ 0.25f, 0.65f, 0.45f, 1 }, &bottomPixelBounds);
    SkBitmap bitmap;
    canvas->scale(20, 20);
    bitmap.installPixels(pixmap);
    canvas->drawBitmap(bitmap, 0, 0);
##

#SeeAlso SkBitmap::erase SkCanvas::clear SkCanvas::drawColor

##

#Class SkPixmap ##

#Topic Pixmap ##
