#Topic Rect
#Alias Rects ##
#Alias Rect_Reference ##

#Struct SkRect

#Code
#Populate
##

SkRect holds four SkScalar coordinates describing the upper and
lower bounds of a rectangle. SkRect may be created from outer bounds or
from position, width, and height. SkRect describes an area; if its right
is less than or equal to its left, or if its bottom is less than or equal to
its top, it is considered empty.

# move to topic about MakeIWH and friends
SkRect can be constructed from int values to avoid compiler warnings that
integer input cannot convert to SkScalar without loss of precision.

#Member SkScalar  fLeft
#Line # smaller x-axis bounds ##
May contain any value, including infinities and NaN. The smaller of the
horizontal values when sorted. When equal to or greater than fRight, Rect is empty.
##

#Member SkScalar  fTop
#Line # smaller y-axis bounds ##
May contain any value, including infinities and NaN. The smaller of the
vertical values when sorted. When equal to or greater than fBottom, Rect is empty.
##

#Member SkScalar  fRight
#Line # larger x-axis bounds ##
May contain any value, including infinities and NaN. The larger of the
horizontal values when sorted. When equal to or less than fLeft, Rect is empty.
##

#Member SkScalar  fBottom
#Line # larger y-axis bounds ##
May contain any value, including infinities and NaN. The larger of the
vertical values when sorted. When equal to or less than fTop, Rect is empty.
##

# ------------------------------------------------------------------------------

#Method static constexpr SkRect MakeEmpty()

#In Constructors
#Line # constructs from bounds of (0, 0, 0, 0) ##
#Populate

#Example
    SkRect rect = SkRect::MakeEmpty();
    SkDebugf("MakeEmpty isEmpty: %s\n", rect.isEmpty() ? "true" : "false");
    rect.offset(10, 10);
    SkDebugf("offset rect isEmpty: %s\n", rect.isEmpty() ? "true" : "false");
    rect.inset(10, 10);
    SkDebugf("inset rect isEmpty: %s\n", rect.isEmpty() ? "true" : "false");
    rect.outset(20, 20);
    SkDebugf("outset rect isEmpty: %s\n", rect.isEmpty() ? "true" : "false");
#StdOut
MakeEmpty isEmpty: true
offset rect isEmpty: true
inset rect isEmpty: true
outset rect isEmpty: false
##
##

#SeeAlso isEmpty setEmpty SkIRect::MakeEmpty

##

# ------------------------------------------------------------------------------

#Method static constexpr SkRect MakeWH(SkScalar w, SkScalar h)

#In Constructors
#Line # constructs from SkScalar input returning (0, 0, width, height) ##
#Populate

#Example
    SkRect rect1 = SkRect::MakeWH(25, 35);
    SkRect rect2 = SkRect::MakeIWH(25, 35);
    SkRect rect3 = SkRect::MakeXYWH(0, 0, 25, 35);
    SkRect rect4 = SkRect::MakeLTRB(0, 0, 25, 35);
    SkDebugf("all %s" "equal\n", rect1 == rect2 && rect2 == rect3 && rect3 == rect4 ?
             "" : "not ");
#StdOut
all equal
##
##

#SeeAlso MakeSize MakeXYWH MakeIWH setWH SkIRect::MakeWH

##

# ------------------------------------------------------------------------------

#Method static SkRect MakeIWH(int w, int h)

#In Constructors
#Line # constructs from int input returning (0, 0, width, height) ##
#Populate

#Example
    SkIRect i_rect = SkIRect::MakeWH(25, 35);
    SkRect  f_rect = SkRect::MakeIWH(25, 35);
    SkDebugf("i_rect width: %d f_rect width:%g\n", i_rect.width(), f_rect.width());
    i_rect = SkIRect::MakeWH(125000111, 0);
    f_rect = SkRect::MakeIWH(125000111, 0);
    SkDebugf("i_rect width: %d f_rect width:%.0f\n", i_rect.width(), f_rect.width());
#StdOut
i_rect width: 25 f_rect width:25
i_rect width: 125000111 f_rect width:125000112
##
##

#SeeAlso MakeXYWH MakeWH isetWH SkIRect::MakeWH

##

# ------------------------------------------------------------------------------

#Method static constexpr SkRect MakeSize(const SkSize& size)

#In Constructors
#Line # constructs from Size returning (0, 0, width, height) ##
#Populate

#Example
    SkSize size = {25.5f, 35.5f};
    SkRect rect = SkRect::MakeSize(size);
    SkDebugf("rect width: %g  height: %g\n", rect.width(), rect.height());
    SkISize floor = size.toFloor();
    rect = SkRect::MakeSize(SkSize::Make(floor));
    SkDebugf("floor width: %g  height: %g\n", rect.width(), rect.height());
#StdOut
rect width: 25.5  height: 35.5
floor width: 25  height: 35
##
##

#SeeAlso MakeWH MakeXYWH MakeIWH setWH SkIRect::MakeWH

##

# ------------------------------------------------------------------------------

#Method static constexpr SkRect MakeLTRB(SkScalar l, SkScalar t, SkScalar r,
                                                           SkScalar b)
#In Constructors
#Line # constructs from SkScalar left, top, right, bottom ##
#Populate

#Example
    SkRect rect = SkRect::MakeLTRB(5, 35, 15, 25);
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
    rect.sort();
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
#StdOut
rect: 5, 35, 15, 25  isEmpty: true
rect: 5, 25, 15, 35  isEmpty: false
##
##

#SeeAlso MakeXYWH SkIRect::MakeLTRB

##

# ------------------------------------------------------------------------------

#Method static constexpr SkRect MakeXYWH(SkScalar x, SkScalar y, SkScalar w, SkScalar h)

#In Constructors
#Line # constructs from SkScalar input returning (x, y, width, height) ##
Returns constructed Rect set to #Formula # (x, y, x + w, y + h) ##.
Does not validate input; w or h may be negative.

#Param x  stored in fLeft ##
#Param y  stored in fTop ##
#Param w  added to x and stored in fRight ##
#Param h  added to y and stored in fBottom ##

#Return bounds at (x, y) with width w and height h ##

#Example
    SkRect rect = SkRect::MakeXYWH(5, 35, -15, 25);
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
    rect.sort();
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
#StdOut
rect: 5, 35, -10, 60  isEmpty: true
rect: -10, 35, 5, 60  isEmpty: false
##
##

#SeeAlso MakeLTRB SkIRect::MakeXYWH

##

# ------------------------------------------------------------------------------

#Method static SkRect Make(const SkISize& size)

#In Constructors
#Line # constructs from ISize returning (0, 0, width, height) ##
#Populate

#Example
    SkRect rect1 = SkRect::MakeSize({2, 35});
    SkRect rect2 = SkRect::MakeIWH(2, 35);
    SkDebugf("rect1 %c= rect2\n", rect1 == rect2 ? '=' : '!');
#StdOut
rect1 == rect2
##
##

#SeeAlso MakeWH MakeXYWH SkRect::MakeIWH SkIRect::MakeSize

##

# ------------------------------------------------------------------------------

#Method static SkRect Make(const SkIRect& irect)

#In Constructors
#Populate

#Example
    SkIRect i_rect1 = {2, 35, 22, 53};
    SkRect f_rect = SkRect::Make(i_rect1);
    f_rect.offset(0.49f, 0.49f);
    SkIRect i_rect2;
    f_rect.round(&i_rect2);
    SkDebugf("i_rect1 %c= i_rect2\n", i_rect1 == i_rect2? '=' : '!');
##

#SeeAlso MakeLTRB

##

#Subtopic Property
#Line # member values, center, validity ##

# ------------------------------------------------------------------------------

#Method bool isEmpty() const

#In Property
#Line # returns true if width or height are zero or negative ##
#Populate

#Example
    SkRect tests[] = {{20, 40, 10, 50}, {20, 40, 20, 50}};
    for (auto rect : tests) {
        SkDebugf("rect: {%g, %g, %g, %g} is" "%s empty\n", rect.left(), rect.top(), rect.right(),
                 rect.bottom(), rect.isEmpty() ? "" : " not");
        rect.sort();
        SkDebugf("sorted: {%g, %g, %g, %g} is" "%s empty\n", rect.left(), rect.top(), rect.right(),
                 rect.bottom(), rect.isEmpty() ? "" : " not");
    }
#StdOut
rect: {20, 40, 10, 50} is empty
sorted: {10, 40, 20, 50} is not empty
rect: {20, 40, 20, 50} is empty
sorted: {20, 40, 20, 50} is empty
##
##

#SeeAlso MakeEmpty sort SkIRect::isEmpty

##

# ------------------------------------------------------------------------------

#Method bool isSorted() const

#In Property
#Line # returns true if width or height are zero or positive ##
#Populate

#Example
    SkRect tests[] = {{20, 40, 10, 50}, {20, 40, 20, 50}};
    for (auto rect : tests) {
        SkDebugf("rect: {%g, %g, %g, %g} is" "%s sorted\n", rect.left(), rect.top(), rect.right(),
                 rect.bottom(), rect.isSorted() ? "" : " not");
        rect.sort();
        SkDebugf("sorted: {%g, %g, %g, %g} is" "%s sorted\n", rect.left(), rect.top(), rect.right(),
                 rect.bottom(), rect.isSorted() ? "" : " not");
    }
#StdOut
rect: {20, 40, 10, 50} is not sorted
sorted: {10, 40, 20, 50} is sorted
rect: {20, 40, 20, 50} is sorted
sorted: {20, 40, 20, 50} is sorted
##
##

#SeeAlso sort makeSorted isEmpty

##

# ------------------------------------------------------------------------------

#Method bool isFinite() const

#In Property
#Line # returns true if no member is infinite or NaN ##
#Populate

#Example
SkRect largest = { SK_ScalarMin, SK_ScalarMin, SK_ScalarMax, SK_ScalarMax };
    SkDebugf("largest is finite: %s\n", largest.isFinite() ? "true" : "false");
    SkDebugf("large width %g\n", largest.width());
    SkRect widest = SkRect::MakeWH(largest.width(), largest.height());
    SkDebugf("widest is finite: %s\n", widest.isFinite() ? "true" : "false");
#StdOut
largest is finite: true
large width inf
widest is finite: false
##
##

#SeeAlso SkScalarIsFinite SkScalarIsNaN

##

# ------------------------------------------------------------------------------

#Method SkScalar    x() const

#In Property
#Line # returns bounds left ##
#Populate

#Example
    SkRect unsorted = { 15, 5, 10, 25 };
    SkDebugf("unsorted.fLeft: %g unsorted.x(): %g\n", unsorted.fLeft, unsorted.x());
    SkRect sorted = unsorted.makeSorted();
    SkDebugf("sorted.fLeft: %g sorted.x(): %g\n", sorted.fLeft, sorted.x());
#StdOut
unsorted.fLeft: 15 unsorted.x(): 15
sorted.fLeft: 10 sorted.x(): 10
##
##

#SeeAlso fLeft left() y() SkIRect::x()

##

# ------------------------------------------------------------------------------

#Method SkScalar    y() const

#In Property
#Line # returns bounds top ##
#Populate

#Example
    SkRect unsorted = { 15, 25, 10, 5 };
    SkDebugf("unsorted.fTop: %g unsorted.y(): %g\n", unsorted.fTop, unsorted.y());
    SkRect sorted = unsorted.makeSorted();
    SkDebugf("sorted.fTop: %g sorted.y(): %g\n", sorted.fTop, sorted.y());
#StdOut
unsorted.fTop: 25 unsorted.y(): 25
sorted.fTop: 5 sorted.y(): 5
##
##

#SeeAlso fTop top() x() SkIRect::y()

##

# ------------------------------------------------------------------------------

#Method SkScalar    left() const

#In Property
#Line # returns smaller bounds in x, if sorted ##
#Populate

#Example
    SkRect unsorted = { 15, 5, 10, 25 };
    SkDebugf("unsorted.fLeft: %g unsorted.left(): %g\n", unsorted.fLeft, unsorted.left());
    SkRect sorted = unsorted.makeSorted();
    SkDebugf("sorted.fLeft: %g sorted.left(): %g\n", sorted.fLeft, sorted.left());
#StdOut
unsorted.fLeft: 15 unsorted.left(): 15
sorted.fLeft: 10 sorted.left(): 10
##
##

#SeeAlso fLeft x() SkIRect::left()

##

# ------------------------------------------------------------------------------

#Method SkScalar    top() const

#In Property
#Line # returns smaller bounds in y, if sorted ##
#Populate

#Example
    SkRect unsorted = { 15, 25, 10, 5 };
    SkDebugf("unsorted.fTop: %g unsorted.top(): %g\n", unsorted.fTop, unsorted.top());
    SkRect sorted = unsorted.makeSorted();
    SkDebugf("sorted.fTop: %g sorted.top(): %g\n", sorted.fTop, sorted.top());
#StdOut
unsorted.fTop: 25 unsorted.top(): 25
sorted.fTop: 5 sorted.top(): 5
##
##

#SeeAlso fTop y() SkIRect::top()

##

# ------------------------------------------------------------------------------

#Method SkScalar    right() const

#In Property
#Line # returns larger bounds in x, if sorted ##
#Populate

#Example
    SkRect unsorted = { 15, 25, 10, 5 };
    SkDebugf("unsorted.fRight: %g unsorted.right(): %g\n", unsorted.fRight, unsorted.right());
    SkRect sorted = unsorted.makeSorted();
    SkDebugf("sorted.fRight: %g sorted.right(): %g\n", sorted.fRight, sorted.right());
#StdOut
unsorted.fRight: 10 unsorted.right(): 10
sorted.fRight: 15 sorted.right(): 15
##
##

#SeeAlso fRight SkIRect::right()

##

# ------------------------------------------------------------------------------

#Method SkScalar    bottom() const

#In Property
#Line # returns larger bounds in y, if sorted ##
#Populate

#Example
    SkRect unsorted = { 15, 25, 10, 5 };
    SkDebugf("unsorted.fBottom: %g unsorted.bottom(): %g\n", unsorted.fBottom, unsorted.bottom());
    SkRect sorted = unsorted.makeSorted();
    SkDebugf("sorted.fBottom: %g sorted.bottom(): %g\n", sorted.fBottom, sorted.bottom());
#StdOut
unsorted.fBottom: 5 unsorted.bottom(): 5
sorted.fBottom: 25 sorted.bottom(): 25
##
##

#SeeAlso fBottom SkIRect::bottom()

##

# ------------------------------------------------------------------------------

#Method SkScalar    width() const

#In Property
#Line # returns span in x ##
#Populate

#Example
#Description
Compare with SkIRect::width() example.
##
    SkRect unsorted = { 15, 25, 10, 5 };
    SkDebugf("unsorted width: %g\n", unsorted.width());
    SkRect large = { -2147483647.f, 1, 2147483644.f, 2 };
    SkDebugf("large width: %.0f\n", large.width());
#StdOut
unsorted width: -5
large width: 4294967296
##
##

#SeeAlso height() SkIRect::width()

##

# ------------------------------------------------------------------------------

#Method SkScalar    height() const

#In Property
#Line # returns span in y ##
#Populate

#Example
#Description
Compare with SkIRect::height() example.
##
    SkRect unsorted = { 15, 25, 10, 20 };
    SkDebugf("unsorted height: %g\n", unsorted.height());
    SkRect large = { 1, -2147483647.f, 2, 2147483644.f };
    SkDebugf("large height: %.0f\n", large.height());
#StdOut
unsorted height: -5
large height: 4294967296
##
##

#SeeAlso width() SkIRect::height()

##

# ------------------------------------------------------------------------------

#Method SkScalar    centerX() const

#In Property
#Line # returns midpoint in x ##
#Populate

#Example
    SkRect tests[] = {{20, 30, 41, 51}, {-20, -30, -41, -51}};
    for (auto rect : tests) {
        SkDebugf("left: %3g right: %3g centerX: %3g\n", rect.left(), rect.right(), rect.centerX());
        rect.sort();
        SkDebugf("left: %3g right: %3g centerX: %3g\n", rect.left(), rect.right(), rect.centerX());
    }
#StdOut
left:  20 right:  41 centerX: 30.5
left:  20 right:  41 centerX: 30.5
left: -20 right: -41 centerX: -30.5
left: -41 right: -20 centerX: -30.5
##
##

#SeeAlso centerY

##

# ------------------------------------------------------------------------------

#Method SkScalar    centerY() const

#In Property
#Line # returns midpoint in y ##
#Populate

#Example
   SkRect rect = { 2e+38, 2e+38, 3e+38, 3e+38 };
   SkDebugf("left: %g right: %g centerX: %g ", rect.left(), rect.right(), rect.centerX());
   SkDebugf("safe mid x: %g\n", rect.left() / 2 + rect.right() / 2);
#StdOut
left: 2e+38 right: 3e+38 centerX: 2.5e+38 safe mid x: 2.5e+38
##
##

#SeeAlso centerX

##

#Subtopic Property ##

#Subtopic Operators

# ------------------------------------------------------------------------------

#Method bool operator==(const SkRect& a, const SkRect& b)

#In Operators
#Line # returns true if members are equal ##
#Populate

#Example
    auto debugster = [](const SkRect& test) -> void {
        SkRect negZero = {-0.0f, -0.0f, 2, 2};
        SkDebugf("{%g, %g, %g, %g} %c= {%g, %g, %g, %g} %s numerically equal\n",
                 test.fLeft, test.fTop, test.fRight, test.fBottom,
                 negZero.fLeft, negZero.fTop, negZero.fRight, negZero.fBottom,
                 test == negZero ? '=' : '!',
                 test.fLeft == negZero.fLeft && test.fTop == negZero.fTop &&
                 test.fRight == negZero.fRight && test.fBottom == negZero.fBottom ?
                 "and are" : "yet are not");
    };
    SkRect tests[] = {{0, 0, 2, 2}, {-0, -0, 2, 2}, {0.0f, 0.0f, 2, 2}};
    SkDebugf("tests are %s" "equal\n", tests[0] == tests[1] && tests[1] == tests[2] ? "" : "not ");
    for (auto rect : tests) {
        debugster(rect);
    }
#StdOut
tests are equal
{0, 0, 2, 2} == {-0, -0, 2, 2} and are numerically equal
{0, 0, 2, 2} == {-0, -0, 2, 2} and are numerically equal
{0, 0, 2, 2} == {-0, -0, 2, 2} and are numerically equal
##
##

#SeeAlso operator!=(const SkRect& a, const SkRect& b)

##

# ------------------------------------------------------------------------------

#Method bool operator!=(const SkRect& a, const SkRect& b)

#In Operators
#Line # returns true if members are unequal ##
#Populate

#Example
    SkRect test = {0, 0, 2, SK_ScalarNaN};
    SkDebugf("test with NaN is %s" "equal to itself\n", test == test ? "" : "not ");
#StdOut
test with NaN is not equal to itself
##
##

#SeeAlso operator==(const SkRect& a, const SkRect& b)

##

#Subtopic Operators ##

#Subtopic As_Points
#Line # conversion to and from Points ##

# ------------------------------------------------------------------------------

#Method void toQuad(SkPoint quad[4]) const

#In As_Points
#Line # returns four corners as Point ##
#Populate

#Example
    SkRect rect = {1, 2, 3, 4};
    SkPoint corners[4];
    rect.toQuad(corners);
    SkDebugf("rect: {%g, %g, %g, %g}\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
    SkDebugf("corners:");
    for (auto corner : corners) {
        SkDebugf(" {%g, %g}", corner.fX, corner.fY);
    }
    SkDebugf("\n");
#StdOut
rect: {1, 2, 3, 4}
corners: {1, 2} {3, 2} {3, 4} {1, 4}
##
##

#SeeAlso SkPath::addRect

##

# ------------------------------------------------------------------------------

#Method void setBounds(const SkPoint pts[], int count)

#In As_Points
#Line # sets to upper and lower limits of Point array ##
#Populate

#Example
   SkPoint points[] = {{3, 4}, {1, 2}, {5, 6}, {SK_ScalarNaN, 8}};
   for (int count = 0; count <= (int) SK_ARRAY_COUNT(points); ++count) {
       SkRect rect;
       rect.setBounds(points, count);
       if (count > 0) {
           SkDebugf("added: %3g, %g ", points[count - 1].fX,  points[count - 1].fY);
       } else {
           SkDebugf("%14s", " ");
       }
       SkDebugf("count: %d rect: %g, %g, %g, %g\n", count,
               rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
   }
#StdOut
              count: 0 rect: 0, 0, 0, 0
added:   3, 4 count: 1 rect: 3, 4, 3, 4
added:   1, 2 count: 2 rect: 1, 2, 3, 4
added:   5, 6 count: 3 rect: 1, 2, 5, 6
added: nan, 8 count: 4 rect: 0, 0, 0, 0
##
##

#SeeAlso set setBoundsCheck SkPath::addPoly

##

# ------------------------------------------------------------------------------

#Method bool setBoundsCheck(const SkPoint pts[], int count)

#In As_Points
#Line # sets to upper and lower limits of Point array ##
#Populate

#Example
   SkPoint points[] = {{3, 4}, {1, 2}, {5, 6}, {SK_ScalarNaN, 8}};
   for (int count = 0; count <= (int) SK_ARRAY_COUNT(points); ++count) {
       SkRect rect;
       bool success = rect.setBoundsCheck(points, count);
       if (count > 0) {
           SkDebugf("added: %3g, %g ", points[count - 1].fX,  points[count - 1].fY);
       } else {
           SkDebugf("%14s", " ");
       }
       SkDebugf("count: %d rect: %g, %g, %g, %g success: %s\n", count,
               rect.fLeft, rect.fTop, rect.fRight, rect.fBottom, success ? "true" : "false");
   }
#StdOut
              count: 0 rect: 0, 0, 0, 0 success: true
added:   3, 4 count: 1 rect: 3, 4, 3, 4 success: true
added:   1, 2 count: 2 rect: 1, 2, 3, 4 success: true
added:   5, 6 count: 3 rect: 1, 2, 5, 6 success: true
added: nan, 8 count: 4 rect: 0, 0, 0, 0 success: false
##
##

#SeeAlso set setBounds SkPath::addPoly

##

#Subtopic As_Points ##

#Subtopic Set
#Line # replaces all values ##

# ------------------------------------------------------------------------------

#Method void setBoundsNoCheck(const SkPoint pts[], int count)
#In Set
#Line # sets to upper and lower limits of Point array ##
#Populate

#Example
   SkPoint points[] = {{3, 4}, {1, 2}, {SK_ScalarInfinity, 6}, {SK_ScalarNaN, 8}};
   for (int count = 0; count <= (int) SK_ARRAY_COUNT(points); ++count) {
       SkRect rect;
       rect.setBoundsNoCheck(points, count);
       if (count > 0) {
           SkDebugf("added: %3g, %g ", points[count - 1].fX,  points[count - 1].fY);
       } else {
           SkDebugf("%14s", " ");
       }
       SkDebugf("count: %d rect: %g, %g, %g, %g\n", count,
               rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
   }
##

#SeeAlso setBoundsCheck
#Method ##

# ------------------------------------------------------------------------------

#Method void setEmpty()

#In Set
#Line # sets to (0, 0, 0, 0) ##
#Populate

#Example
    SkRect rect = {3, 4, 1, 2};
    for (int i = 0; i < 2; ++i) {
    SkDebugf("rect: {%g, %g, %g, %g} is %s" "empty\n", rect.fLeft, rect.fTop,
             rect.fRight, rect.fBottom, rect.isEmpty() ? "" : "not ");
    rect.setEmpty();
    }
#StdOut
rect: {3, 4, 1, 2} is empty
rect: {0, 0, 0, 0} is empty
##
##

#SeeAlso MakeEmpty SkIRect::setEmpty

##

# ------------------------------------------------------------------------------

#Method void set(const SkIRect& src)

#In Set
#Line # sets to SkScalar input (left, top, right, bottom) and others ##
#Populate

#Example
    SkIRect i_rect = {3, 4, 1, 2};
    SkDebugf("i_rect: {%d, %d, %d, %d}\n", i_rect.fLeft, i_rect.fTop, i_rect.fRight, i_rect.fBottom);
    SkRect f_rect;
    f_rect.set(i_rect);
    SkDebugf("f_rect: {%g, %g, %g, %g}\n", f_rect.fLeft, f_rect.fTop, f_rect.fRight, f_rect.fBottom);
#StdOut
i_rect: {3, 4, 1, 2}
f_rect: {3, 4, 1, 2}
##
##

#SeeAlso  setLTRB SkIntToScalar

##

# ------------------------------------------------------------------------------

#Method void set(SkScalar left, SkScalar top, SkScalar right, SkScalar bottom)

#In Set
#Populate

#Example
    SkRect rect1 = {3, 4, 1, 2};
    SkDebugf("rect1: {%g, %g, %g, %g}\n", rect1.fLeft, rect1.fTop, rect1.fRight, rect1.fBottom);
    SkRect rect2;
    rect2.set(3, 4, 1, 2);
    SkDebugf("rect2: {%g, %g, %g, %g}\n", rect2.fLeft, rect2.fTop, rect2.fRight, rect2.fBottom);
#StdOut
rect1: {3, 4, 1, 2}
rect2: {3, 4, 1, 2}
##
##

#SeeAlso setLTRB setXYWH SkIRect::set

##

# ------------------------------------------------------------------------------

#Method void setLTRB(SkScalar left, SkScalar top, SkScalar right, SkScalar bottom)

#In Set
#Line # sets to SkScalar input (left, top, right, bottom) ##
#Populate

#Example
    SkRect rect1 = {3, 4, 1, 2};
    SkDebugf("rect1: {%g, %g, %g, %g}\n", rect1.fLeft, rect1.fTop, rect1.fRight, rect1.fBottom);
    SkRect rect2;
    rect2.setLTRB(3, 4, 1, 2);
    SkDebugf("rect2: {%g, %g, %g, %g}\n", rect2.fLeft, rect2.fTop, rect2.fRight, rect2.fBottom);
#StdOut
rect1: {3, 4, 1, 2}
rect2: {3, 4, 1, 2}
##
##

#SeeAlso set setXYWH SkIRect::set

##

# ------------------------------------------------------------------------------

#Method void set(const SkPoint pts[], int count)

#In Set
#Populate

#Example
   SkPoint points[] = {{3, 4}, {1, 2}, {5, 6}, {SK_ScalarNaN, 8}};
   for (int count = 0; count <= (int) SK_ARRAY_COUNT(points); ++count) {
       SkRect rect;
       rect.set(points, count);
       if (count > 0) {
           SkDebugf("added: %3g, %g ", points[count - 1].fX,  points[count - 1].fY);
       } else {
           SkDebugf("%14s", " ");
       }
       SkDebugf("count: %d rect: %g, %g, %g, %g\n", count,
               rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
   }
#StdOut
              count: 0 rect: 0, 0, 0, 0
added:   3, 4 count: 1 rect: 3, 4, 3, 4
added:   1, 2 count: 2 rect: 1, 2, 3, 4
added:   5, 6 count: 3 rect: 1, 2, 5, 6
added: nan, 8 count: 4 rect: 0, 0, 0, 0
##
##

#SeeAlso setBounds setBoundsCheck SkPath::addPoly

##

# ------------------------------------------------------------------------------

#Method void set(const SkPoint& p0, const SkPoint& p1)

#In Set
#Populate

#Example
#Description
p0 and p1 may be swapped and have the same effect unless one contains NaN.
##
   SkPoint point1 = {SK_ScalarNaN, 8};
   SkPoint point2 = {3, 4};
   SkRect rect;
   rect.set(point1, point2);
   SkDebugf("rect: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
   rect.set(point2, point1);
   SkDebugf("rect: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
##

#SeeAlso setBounds setBoundsCheck

##

# ------------------------------------------------------------------------------

#Method void setXYWH(SkScalar x, SkScalar y, SkScalar width, SkScalar height)

#In Set
#Line # sets to SkScalar input (x, y, width, height) ##
Sets Rect to #Formula # (x, y, x + width, y + height) ##.
Does not validate input; width or height may be negative.

#Param x  stored in fLeft ##
#Param y  stored in fTop ##
#Param width  added to x and stored in fRight ##
#Param height  added to y and stored in fBottom ##

#Example
    SkRect rect;
    rect.setXYWH(5, 35, -15, 25);
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
    rect.sort();
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
#StdOut
rect: 5, 35, -10, 60  isEmpty: true
rect: -10, 35, 5, 60  isEmpty: false
##
##

#SeeAlso MakeXYWH setLTRB set SkIRect::setXYWH

##

# ------------------------------------------------------------------------------

#Method void setWH(SkScalar width, SkScalar height)

#In Set
#Line # sets to SkScalar input (0, 0, width, height) ##
#Populate

#Example
    SkRect rect;
    rect.setWH(-15, 25);
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
    rect.sort();
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
#StdOut
rect: 0, 0, -15, 25  isEmpty: true
rect: -15, 0, 0, 25  isEmpty: false
##
##

#SeeAlso MakeWH setXYWH isetWH

##

#Subtopic Set ##

#Subtopic From_Integers
#Line # sets Scalar values from integer input ##

# ------------------------------------------------------------------------------

#Method void iset(int left, int top, int right, int bottom)

#In From_Integers
#Line # sets to int input (left, top, right, bottom) ##
#Populate

#Example
    SkRect rect1 = {3, 4, 1, 2};
    SkDebugf("rect1: {%g, %g, %g, %g}\n", rect1.fLeft, rect1.fTop, rect1.fRight, rect1.fBottom);
    SkRect rect2;
    rect2.iset(3, 4, 1, 2);
    SkDebugf("rect2: {%g, %g, %g, %g}\n", rect2.fLeft, rect2.fTop, rect2.fRight, rect2.fBottom);
#StdOut
rect1: {3, 4, 1, 2}
rect2: {3, 4, 1, 2}
##
##

#SeeAlso set setLTRB SkIRect::set SkIntToScalar

##

# ------------------------------------------------------------------------------

#Method void isetWH(int width, int height)

#In From_Integers
#Line # sets to int input (0, 0, width, height) ##
#Populate

#Example
    SkRect rect1 = {0, 0, 1, 2};
    SkDebugf("rect1: {%g, %g, %g, %g}\n", rect1.fLeft, rect1.fTop, rect1.fRight, rect1.fBottom);
    SkRect rect2;
    rect2.isetWH(1, 2);
    SkDebugf("rect2: {%g, %g, %g, %g}\n", rect2.fLeft, rect2.fTop, rect2.fRight, rect2.fBottom);
#StdOut
rect1: {0, 0, 1, 2}
rect2: {0, 0, 1, 2}
##
##

#SeeAlso MakeWH MakeXYWH iset() SkIRect:MakeWH

##

#Subtopic From_Integers ##

#Subtopic Inset_Outset_Offset
#Line # moves sides ##

# ------------------------------------------------------------------------------

#Method SkRect makeOffset(SkScalar dx, SkScalar dy) const

#In Inset_Outset_Offset
#Line # constructs from translated sides ##
#Populate

#Example
    SkRect rect = { 10, 50, 20, 60 };
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
    rect = rect.makeOffset(15, 32);
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
#StdOut
rect: 10, 50, 20, 60  isEmpty: false
rect: 25, 82, 35, 92  isEmpty: false
##
##

#SeeAlso offset() makeInset makeOutset SkIRect::makeOffset

##

# ------------------------------------------------------------------------------

#Method SkRect makeInset(SkScalar dx, SkScalar dy) const

#In Inset_Outset_Offset
#Line # constructs from sides moved symmetrically about the center ##
#Populate

#Example
    SkRect rect = { 10, 50, 20, 60 };
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
    rect = rect.makeInset(15, 32);
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
#StdOut
rect: 10, 50, 20, 60  isEmpty: false
rect: 25, 82, 5, 28  isEmpty: true
##
##

#SeeAlso inset() makeOffset makeOutset SkIRect::makeInset

##

# ------------------------------------------------------------------------------

#Method SkRect makeOutset(SkScalar dx, SkScalar dy) const

#In Inset_Outset_Offset
#Line # constructs from sides moved symmetrically about the center ##
#Populate

#Example
    SkRect rect = { 10, 50, 20, 60 };
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
    rect = rect.makeOutset(15, 32);
    SkDebugf("rect: %g, %g, %g, %g  isEmpty: %s\n", rect.left(), rect.top(), rect.right(),
              rect.bottom(), rect.isEmpty() ? "true" : "false");
#StdOut
rect: 10, 50, 20, 60  isEmpty: false
rect: -5, 18, 35, 92  isEmpty: false
##
##

#SeeAlso outset() makeOffset makeInset SkIRect::makeOutset

##

# ------------------------------------------------------------------------------

#Method void offset(SkScalar dx, SkScalar dy)

#In Inset_Outset_Offset
#Line # translates sides without changing width and height ##
#Populate

#Example
    SkRect rect = { 10, 14, 50, 73 };
    rect.offset(5, 13);
    SkDebugf("rect: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
#StdOut
rect: 15, 27, 55, 86
##
##

#SeeAlso offsetTo makeOffset SkIRect::offset

##

# ------------------------------------------------------------------------------

#Method void offset(const SkPoint& delta)

#In Inset_Outset_Offset
#Populate

#Example
    SkRect rect = { 10, 14, 50, 73 };
    rect.offset({5, 13});
    SkDebugf("rect: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
#StdOut
rect: 15, 27, 55, 86
##
##

#SeeAlso offsetTo makeOffset SkIRect::offset

##

# ------------------------------------------------------------------------------

#Method void offsetTo(SkScalar newX, SkScalar newY)

#In Inset_Outset_Offset
#Line # translates to (x, y) without changing width and height ##
#Populate

#Example
    SkRect rect = { 10, 14, 50, 73 };
    rect.offsetTo(15, 27);
    SkDebugf("rect: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
#StdOut
rect: 15, 27, 55, 86
##
##

#SeeAlso offset makeOffset setXYWH SkIRect::offsetTo

##

# ------------------------------------------------------------------------------

#Method void inset(SkScalar dx, SkScalar dy)

#In Inset_Outset_Offset
#Line # moves the sides symmetrically about the center ##
#Populate

#Example
    SkRect rect = { 10, 14, 50, 73 };
    rect.inset(5, 13);
    SkDebugf("rect: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
#StdOut
rect: 15, 27, 45, 60
##
##

#SeeAlso outset makeInset SkIRect::inset

##

# ------------------------------------------------------------------------------

#Method void outset(SkScalar dx, SkScalar dy)

#In Inset_Outset_Offset
#Line # moves the sides symmetrically about the center ##
#Populate

#Example
    SkRect rect = { 10, 14, 50, 73 };
    rect.outset(5, 13);
    SkDebugf("rect: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
#StdOut
rect: 5, 1, 55, 86
##
##

#SeeAlso inset makeOutset SkIRect::outset

##

#Subtopic Inset_Outset_Offset ##

#Subtopic Intersection
#Line # sets to shared bounds ##

Rects intersect when they enclose a common area. To intersect, each of the pair
must describe area; fLeft is less than fRight, and fTop is less than fBottom;
isEmpty() returns false. The intersection of Rect pair can be described by:
#Formula # (max(a.fLeft, b.fLeft), max(a.fTop, b.fTop),
            min(a.fRight, b.fRight), min(a.fBottom, b.fBottom)) ##.

The intersection is only meaningful if the resulting Rect is not empty and
describes an area: fLeft is less than fRight, and fTop is less than fBottom.

# ------------------------------------------------------------------------------

#Method    bool contains(SkScalar x, SkScalar y) const

#In Intersection
#Line # returns true if points are equal or inside ##
#Populate

#Example
    SkRect rect = { 30, 50, 40, 60 };
    SkPoint tests[] = { { 30, 50 }, { 39, 49 }, { 29, 59 } };
    for (auto contained : tests) {
        SkDebugf("rect: (%g, %g, %g, %g) %s (%g, %g)\n",
                 rect.left(), rect.top(), rect.right(), rect.bottom(),
                 rect.contains(contained.x(), contained.y()) ? "contains" : "does not contain",
                 contained.x(), contained.y());
    }
#StdOut
rect: (30, 50, 40, 60) contains (30, 50)
rect: (30, 50, 40, 60) does not contain (39, 49)
rect: (30, 50, 40, 60) does not contain (29, 59)
##
##

#SeeAlso SkIRect::contains SkRRect::contains

##

# ------------------------------------------------------------------------------

#Method    bool contains(const SkRect& r) const

#In Intersection
#Populate

#Example
    SkRect rect = { 30, 50, 40, 60 };
    SkRect tests[] = { { 30, 50, 31, 51}, { 39, 49, 40, 50}, { 29, 59, 30, 60} };
    for (auto contained : tests) {
        SkDebugf("rect: (%g, %g, %g, %g) %s (%g, %g, %g, %g)\n",
                 rect.left(), rect.top(), rect.right(), rect.bottom(),
                 rect.contains(contained) ? "contains" : "does not contain",
                 contained.left(), contained.top(), contained.right(), contained.bottom());
    }
#StdOut
rect: (30, 50, 40, 60) contains (30, 50, 31, 51)
rect: (30, 50, 40, 60) does not contain (39, 49, 40, 50)
rect: (30, 50, 40, 60) does not contain (29, 59, 30, 60)
##
##

#SeeAlso SkIRect::contains

##

# ------------------------------------------------------------------------------

#Method    bool contains(const SkIRect& r) const

#In Intersection
#Populate

#Example
    SkRect rect = { 30, 50, 40, 60 };
    SkIRect tests[] = { { 30, 50, 31, 51}, { 39, 49, 40, 50}, { 29, 59, 30, 60} };
    for (auto contained : tests) {
        SkDebugf("rect: (%g, %g, %g, %g) %s (%d, %d, %d, %d)\n",
                 rect.left(), rect.top(), rect.right(), rect.bottom(),
                 rect.contains(contained) ? "contains" : "does not contain",
                 contained.left(), contained.top(), contained.right(), contained.bottom());
    }
#StdOut
rect: (30, 50, 40, 60) contains (30, 50, 31, 51)
rect: (30, 50, 40, 60) does not contain (39, 49, 40, 50)
rect: (30, 50, 40, 60) does not contain (29, 59, 30, 60)
##
##

#SeeAlso SkIRect::contains

##

# ------------------------------------------------------------------------------

#Method bool intersect(const SkRect& r)

#In Intersection
#Line # sets to shared area; returns true if not empty ##
#Populate

#Example
#Description
Two SkDebugf calls are required. If the calls are combined, their arguments
may not be evaluated in left to right order: the printed intersection may
be before or after the call to intersect.
##
    SkRect leftRect =  { 10, 40, 50, 80 };
    SkRect rightRect = { 30, 60, 70, 90 };
    SkDebugf("%s intersection: ", leftRect.intersect(rightRect) ? "" : "no ");
    SkDebugf("%g, %g, %g, %g\n", leftRect.left(), leftRect.top(),
                                 leftRect.right(), leftRect.bottom());
#StdOut
 intersection: 30, 60, 50, 80
##
##

#SeeAlso intersects Intersects join SkIRect::intersect

##

# ------------------------------------------------------------------------------

#Method bool intersect(SkScalar left, SkScalar top, SkScalar right, SkScalar bottom)

#In Intersection
#Populate

#Example
#Description
Two SkDebugf calls are required. If the calls are combined, their arguments
may not be evaluated in left to right order: the printed intersection may
be before or after the call to intersect.
##
    SkRect leftRect =  { 10, 40, 50, 80 };
    SkDebugf("%s intersection: ", leftRect.intersect(30, 60, 70, 90) ? "" : "no ");
    SkDebugf("%g, %g, %g, %g\n", leftRect.left(), leftRect.top(),
                                 leftRect.right(), leftRect.bottom());
#StdOut
 intersection: 30, 60, 50, 80
##
##

#SeeAlso intersects Intersects join SkIRect::intersect

##

# ------------------------------------------------------------------------------

#Method bool intersect(const SkRect& a, const SkRect& b)

#In Intersection
#Populate

#Example
    SkRect result;
    bool intersected = result.intersect({ 10, 40, 50, 80 }, { 30, 60, 70, 90 });
    SkDebugf("%s intersection: %g, %g, %g, %g\n", intersected ? "" : "no ",
             result.left(), result.top(), result.right(), result.bottom());
#StdOut
 intersection: 30, 60, 50, 80
##
##

#SeeAlso intersects Intersects join SkIRect::intersect

##

# ------------------------------------------------------------------------------

#Method    bool intersects(SkScalar left, SkScalar top, SkScalar right, SkScalar bottom) const

#In Intersection
#Line # returns true if areas overlap ##
#Populate

#Example
    SkRect rect = { 10, 40, 50, 80 };
    SkDebugf("%s intersection", rect.intersects(30, 60, 70, 90) ? "" : "no ");
#StdOut
 intersection
##
##

#SeeAlso intersect Intersects SkIRect::Intersects

##

# ------------------------------------------------------------------------------

#Method    bool intersects(const SkRect& r) const

#In Intersection
#Populate

#Example
    SkRect rect = { 10, 40, 50, 80 };
    SkDebugf("%s intersection", rect.intersects({30, 60, 70, 90}) ? "" : "no ");
#StdOut
 intersection
##
##

#SeeAlso intersect Intersects SkIRect::Intersects

##

# ------------------------------------------------------------------------------

#Method    static bool Intersects(const SkRect& a, const SkRect& b)

#In Intersection
#Line # returns true if areas overlap ##
#Populate

#Example
    SkDebugf("%s intersection", SkRect::Intersects({10, 40, 50, 80}, {30, 60, 70, 90}) ? "" : "no ");
#StdOut
 intersection
##
##

#SeeAlso intersect intersects SkIRect::Intersects

##

#Subtopic Intersection ##

#Subtopic Join
#Line # sets to union of bounds ##

# ------------------------------------------------------------------------------

#Method    void join(SkScalar left, SkScalar top, SkScalar right, SkScalar bottom)

#In Join
#Line # sets to union of bounds ##
#Populate

#Example
    SkRect rect = { 10, 20, 15, 25};
    rect.join(50, 60, 55, 65);
    SkDebugf("join: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
#StdOut
 join: 10, 20, 55, 65
##
##

#SeeAlso joinNonEmptyArg joinPossiblyEmptyRect SkIRect::join

##

# ------------------------------------------------------------------------------

#Method    void join(const SkRect& r)

#In Join
#Populate

#Example
    SkRect rect = { 10, 20, 15, 25};
    rect.join({50, 60, 55, 65});
    SkDebugf("join: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
#StdOut
 join: 10, 20, 55, 65
##
##

#SeeAlso joinNonEmptyArg joinPossiblyEmptyRect SkIRect::join

##

# ------------------------------------------------------------------------------

#Method    void joinNonEmptyArg(const SkRect& r)

#In Join
#Line # sets to union of bounds, asserting that argument is not empty ##
#Populate

#Example
#Description
Since Rect is not sorted, first result is copy of toJoin.
##
    SkRect rect = { 10, 100, 15, 0};
    SkRect sorted = rect.makeSorted();
    SkRect toJoin = { 50, 60, 55, 65 };
    rect.joinNonEmptyArg(toJoin);
    SkDebugf("rect: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
    sorted.joinNonEmptyArg(toJoin);
    SkDebugf("sorted: %g, %g, %g, %g\n", sorted.fLeft, sorted.fTop, sorted.fRight, sorted.fBottom);
#StdOut
rect: 50, 60, 55, 65
sorted: 10, 0, 55, 100
##
##

#SeeAlso join joinPossiblyEmptyRect SkIRect::join

##

# ------------------------------------------------------------------------------

#Method    void joinPossiblyEmptyRect(const SkRect& r)

#In Join
#Line # sets to union of bounds; skips empty check for both ##
#Populate

#Example
#Description
Since Rect is not sorted, first result is not useful.
##
    SkRect rect = { 10, 100, 15, 0};
    SkRect sorted = rect.makeSorted();
    SkRect toJoin = { 50, 60, 55, 65 };
    rect.joinPossiblyEmptyRect(toJoin);
    SkDebugf("rect: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
    sorted.joinPossiblyEmptyRect(toJoin);
    SkDebugf("sorted: %g, %g, %g, %g\n", sorted.fLeft, sorted.fTop, sorted.fRight, sorted.fBottom);
#StdOut
rect: 10, 60, 55, 65
sorted: 10, 0, 55, 100
##
##

#SeeAlso joinNonEmptyArg join SkIRect::join

##

#Subtopic Join ##

#Subtopic Rounding
#Line # adjust to integer bounds ##

#Method    void round(SkIRect* dst) const

#In Rounding
#Line # sets members to nearest integer value ##
Sets IRect by adding 0.5 and discarding the fractional portion of Rect
members, using #Formula # (SkScalarRoundToInt(fLeft), SkScalarRoundToInt(fTop),
                           SkScalarRoundToInt(fRight), SkScalarRoundToInt(fBottom)) ##.

#Param dst  storage for IRect ##

#Example
    SkRect rect = { 30.5f, 50.5f, 40.5f, 60.5f };
    SkIRect round;
    rect.round(&round);
    SkDebugf("round: %d, %d, %d, %d\n", round.fLeft, round.fTop, round.fRight, round.fBottom);
#StdOut
round: 31, 51, 41, 61
##
##

#SeeAlso roundIn roundOut SkScalarRoundToInt

##

# ------------------------------------------------------------------------------

#Method    void roundOut(SkIRect* dst) const

#In Rounding
#Line # sets members to nearest integer value away from opposite ##
Sets IRect by discarding the fractional portion of fLeft and fTop; and rounding
up fRight and fBottom, using 
#Formula # (SkScalarFloorToInt(fLeft), SkScalarFloorToInt(fTop),
            SkScalarCeilToInt(fRight), SkScalarCeilToInt(fBottom)) ##.

#Param dst  storage for IRect ##

#Example
    SkRect rect = { 30.5f, 50.5f, 40.5f, 60.5f };
    SkIRect round;
    rect.roundOut(&round);
    SkDebugf("round: %d, %d, %d, %d\n", round.fLeft, round.fTop, round.fRight, round.fBottom);
#StdOut
round: 30, 50, 41, 61
##
##

#SeeAlso roundIn round SkScalarRoundToInt

##

# ------------------------------------------------------------------------------

#Method    void roundOut(SkRect* dst) const

#In Rounding
Sets Rect by discarding the fractional portion of fLeft and fTop; and rounding 
up fRight and fBottom, using 
#Formula # (SkScalarFloorToInt(fLeft), SkScalarFloorToInt(fTop),
            SkScalarCeilToInt(fRight), SkScalarCeilToInt(fBottom)) ##.

#Param dst  storage for Rect ##

#Example
    SkRect rect = { 30.5f, 50.5f, 40.5f, 60.5f };
    SkRect round;
    rect.roundOut(&round);
    SkDebugf("round: %g, %g, %g, %g\n", round.fLeft, round.fTop, round.fRight, round.fBottom);
#StdOut
round: 30, 50, 41, 61
##
##

#SeeAlso roundIn round SkScalarRoundToInt

##

# ------------------------------------------------------------------------------

#Method    void roundIn(SkIRect* dst) const

#In Rounding
#Line # sets members to nearest integer value towards opposite ##
Sets Rect by rounding up fLeft and fTop; and discarding the fractional portion
of fRight and fBottom, using
#Formula # (SkScalarCeilToInt(fLeft), SkScalarCeilToInt(fTop),
            SkScalarFloorToInt(fRight), SkScalarFloorToInt(fBottom)) ##.

#Param dst  storage for IRect ##

#Example
    SkRect rect = { 30.5f, 50.5f, 40.5f, 60.5f };
    SkIRect round;
    rect.roundIn(&round);
    SkDebugf("round: %d, %d, %d, %d\n", round.fLeft, round.fTop, round.fRight, round.fBottom);
#StdOut
round: 31, 51, 40, 60
##
##

#SeeAlso roundOut round SkScalarRoundToInt

##

# ------------------------------------------------------------------------------

#Method    SkIRect round() const

#In Rounding
Returns IRect by adding 0.5 and discarding the fractional portion of Rect
members, using #Formula # (SkScalarRoundToInt(fLeft), SkScalarRoundToInt(fTop),
                           SkScalarRoundToInt(fRight), SkScalarRoundToInt(fBottom)) ##.

#Return  rounded IRect ##

#Example
    SkRect rect = { 30.5f, 50.5f, 40.5f, 60.5f };
    SkIRect round = rect.round();
    SkDebugf("round: %d, %d, %d, %d\n", round.fLeft, round.fTop, round.fRight, round.fBottom);
#StdOut
round: 31, 51, 41, 61
##
##

#SeeAlso roundOut roundIn SkScalarRoundToInt

##

# ------------------------------------------------------------------------------

#Method    SkIRect roundOut() const

#In Rounding
Sets IRect by discarding the fractional portion of fLeft and fTop; and rounding
up fRight and fBottom, using
#Formula # (SkScalarFloorToInt(fLeft), SkScalarFloorToInt(fTop),
            SkScalarCeilToInt(fRight), SkScalarCeilToInt(fBottom)) ##.

#Return  rounded IRect ##

#Example
    SkRect rect = { 30.5f, 50.5f, 40.5f, 60.5f };
    SkIRect round = rect.roundOut();
    SkDebugf("round: %d, %d, %d, %d\n", round.fLeft, round.fTop, round.fRight, round.fBottom);
#StdOut
round: 30, 50, 41, 61
##
##

#SeeAlso round roundIn SkScalarRoundToInt

##

#Subtopic Rounding ##

#Subtopic Sorting
#Line # orders sides ##

# ------------------------------------------------------------------------------

#Method    void sort()

#In Sorting
#Line # orders sides from smaller to larger ##
#Populate

#Example
    SkRect rect = { 30.5f, 50.5f, 20.5f, 10.5f };
    SkDebugf("rect: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
    rect.sort();
    SkDebugf("sorted: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
#StdOut
rect: 30.5, 50.5, 20.5, 10.5
sorted: 20.5, 10.5, 30.5, 50.5
##
##

#SeeAlso makeSorted SkIRect::sort isSorted

##

# ------------------------------------------------------------------------------

#Method    SkRect makeSorted() const

#In Sorting
#In Constructors
#Line # constructs Rect, ordering sides from smaller to larger ##
#Populate

#Example
    SkRect rect = { 30.5f, 50.5f, 20.5f, 10.5f };
    SkDebugf("rect: %g, %g, %g, %g\n", rect.fLeft, rect.fTop, rect.fRight, rect.fBottom);
    SkRect sort = rect.makeSorted();
    SkDebugf("sorted: %g, %g, %g, %g\n", sort.fLeft, sort.fTop, sort.fRight, sort.fBottom);
#StdOut
rect: 30.5, 50.5, 20.5, 10.5
sorted: 20.5, 10.5, 30.5, 50.5
##
##

#SeeAlso sort SkIRect::makeSorted isSorted

##

#Subtopic Sorting ##

# ------------------------------------------------------------------------------

#Method    const SkScalar* asScalars() const
#In Property
#Line # returns pointer to members as array ##
#Populate

#Example
   SkRect rect = {7, 11, 13, 17};
SkDebugf("rect.asScalars() %c= &rect.fLeft\n", rect.asScalars() == &rect.fLeft? '=' : '!');
#StdOut
rect.asScalars() == &rect.fLeft
##
##

#SeeAlso toQuad

##

# ------------------------------------------------------------------------------

#Method    void dump(bool asHex) const
#In Property
#Line # sends text representation to standard output using floats ##
#Populate

#Example
   SkRect rect = {20, 30, 40, 50};
    for (bool dumpAsHex : { false, true } ) {
        rect.dump(dumpAsHex);
        SkDebugf("\n");
    }
#StdOut
SkRect::MakeLTRB(20, 30, 40, 50);

SkRect::MakeLTRB(SkBits2Float(0x41a00000), /* 20.000000 */
                 SkBits2Float(0x41f00000), /* 30.000000 */
                 SkBits2Float(0x42200000), /* 40.000000 */
                 SkBits2Float(0x42480000)  /* 50.000000 */);
##
##

#SeeAlso dumpHex

##

# ------------------------------------------------------------------------------

#Method    void dump() const
#Populate

#Example
SkRect rect = {6.f / 7, 2.f / 3, 26.f / 10, 42.f / 6};
rect.dump();
SkRect copy = SkRect::MakeLTRB(0.857143f, 0.666667f, 2.6f, 7);
SkDebugf("rect is " "%s" "equal to copy\n", rect == copy ? "" : "not ");
#StdOut
SkRect::MakeLTRB(0.857143f, 0.666667f, 2.6f, 7);
rect is not equal to copy
##
##

#SeeAlso dumpHex

##

# ------------------------------------------------------------------------------

#Method    void dumpHex() const
#In Property
#Line # sends text representation to standard output using hexadecimal ##
Writes text representation of Rect to standard output. The representation may be
directly compiled as C++ code. Floating point values are written
in hexadecimal to preserve their exact bit pattern. The output reconstructs the
original Rect.

Use instead of dump() when submitting
#A bug reports against Skia # https://bug.skia.org ##
.

#Example
   SkRect rect = {6.f / 7, 2.f / 3, 26.f / 10, 42.f / 6};
rect.dumpHex();
SkRect copy = SkRect::MakeLTRB(SkBits2Float(0x3f5b6db7), /* 0.857143 */
                 SkBits2Float(0x3f2aaaab), /* 0.666667 */
                 SkBits2Float(0x40266666), /* 2.600000 */
                 SkBits2Float(0x40e00000)  /* 7.000000 */);
SkDebugf("rect is " "%s" "equal to copy\n", rect == copy ? "" : "not ");
#StdOut
SkRect::MakeLTRB(SkBits2Float(0x3f5b6db7), /* 0.857143 */
                 SkBits2Float(0x3f2aaaab), /* 0.666667 */
                 SkBits2Float(0x40266666), /* 2.600000 */
                 SkBits2Float(0x40e00000)  /* 7.000000 */);
rect is equal to copy
##
##

#SeeAlso dump

##

#Struct SkRect ##

#Topic Rect ##
