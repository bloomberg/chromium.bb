#!/usr/bin/env python
# Copyright 2019 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
'''python %(prog)s [options]
Generate mapping from IPP attribute name to appropriate handler based on its
type as described in IPP registration files.'''

import argparse
import csv
import re

def get_handler(syntax, name):
  if syntax.startswith('1setOf'):
    handler = get_handler(syntax[6:].strip(), name)
    if handler == 'EnumHandler':
      # 3 is 'none' value for finishings.
      # IPP enums always use positive numbers so we can use 0 in other cases.
      default = 3 if name.endswith('finishings') else 0
      return 'MultivalueEnumHandler, %d' % default
    return ''

  if syntax == 'collection':
    # TODO(crbug.com/964919): Add collection handler
    return ''

  if syntax.startswith('type1') or syntax.startswith('type2'):
    # ignore prefix
    return get_handler(syntax[5:].strip(), name)

  if syntax.startswith('keyword'):
    return 'KeywordHandler'

  if syntax.startswith('enum'):
    return 'EnumHandler'

  if syntax == 'boolean':
    return 'BooleanHandler'

  if syntax.startswith('integer'):
    # TODO(crbug.com/964919): Add integer handler
    return 'NumberHandler'

  if syntax.startswith('name') or syntax.startswith('text'):
    return 'TextHandler'

  return ''

# We skip attributes that are already implemented in print preview
NOOP_ATTRS = ['copies', 'job-hold-until', 'job-password',
              'job-password-encryption', 'media', 'media-col', 'number-up',
              'page-ranges', 'print-color-mode', 'printer-resolution',
              'sheet-collate', 'sides']

OUTPUT_HEADER = """// DO NOT MODIFY
// Generated by printing/backend/tools/code_generator.py

#include "printing/backend/ipp_handler_map.h"

#include "base/bind.h"
#include "printing/backend/ipp_handlers.h"

namespace printing {

HandlerMap GenerateHandlers() {
  HandlerMap result;
"""

OUTPUT_FOOTER = """  return result;
}

}  // namespace printing
"""

def main():
  parser = argparse.ArgumentParser(usage=__doc__)
  parser.add_argument('-i', '--attributes-file', dest='attributes_file',
                      help='path to ipp-registrations-2.csv input file',
                      metavar='FILE', required=True)
  parser.add_argument('-o', '--ipp-handler-map', dest='ipp_handler_map',
                      help='path to ipp_handler_map.cc output file',
                      metavar='FILE', required=True)
  args = parser.parse_args()

  with open(args.ipp_handler_map, 'w') as mapfile:
    with open(args.attributes_file, 'r') as attrfile:
      reader = csv.reader(attrfile)
      mapfile.write(OUTPUT_HEADER)
      name_pattern = re.compile('^[a-z][a-z-]*[a-z]$')

      for attr in reader:
        group = attr[0]
        if group not in ['Job Template', 'Operation']:
          continue

        sub_attr = attr[2]
        if sub_attr != '':
          # Skip collections for now.
          continue

        attr_name = attr[1]
        # Remove annotations like '(obsolete)', '(deprecated)' etc.
        parenthesis = attr_name.find('(')
        if parenthesis != -1:
          attr_name = attr_name[:parenthesis].strip()

        if not name_pattern.match(attr_name):
          print('Warning: attribute name %s is invalid' % attr_name)
          continue

        syntax = attr[4]
        handler = 'NoOpHandler'
        if attr_name not in NOOP_ATTRS:
          handler = get_handler(syntax.strip(), attr_name);

        if handler == '':
          continue

        mapfile.write('  result.emplace("' + attr_name +
                      '", base::BindRepeating(&' + handler + '));\n')

      mapfile.write(OUTPUT_FOOTER)

if __name__ == '__main__':
  main()
