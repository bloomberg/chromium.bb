diff -Naur ../PRISTINE/binutils-2.18/bfd/Makefile.am binutils-2.18/bfd/Makefile.am
--- ../PRISTINE/binutils-2.18/bfd/Makefile.am	2007-08-28 13:20:14.000000000 -0700
+++ binutils-2.18/bfd/Makefile.am	2009-01-09 17:32:43.314868000 -0800
@@ -277,6 +277,7 @@
 	elf32-mips.lo \
 	elf32-mt.lo \
 	elf32-msp430.lo \
+	elf32-nacl.lo \
 	elf32-openrisc.lo \
 	elf32-or32.lo \
 	elf32-pj.lo \
@@ -456,6 +457,7 @@
 	elf32-mips.c \
 	elf32-mt.c \
 	elf32-msp430.c \
+	elf32-nacl.c \
 	elf32-openrisc.c \
 	elf32-or32.c \
 	elf32-pj.c \
@@ -1468,6 +1470,10 @@
   $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
   $(INCDIR)/bfdlink.h $(INCDIR)/elf/msp430.h $(INCDIR)/elf/reloc-macros.h \
   elf32-target.h
+elf32-nacl.lo: elf32-nacl.c $(INCDIR)/filenames.h $(INCDIR)/bfdlink.h \
+  $(INCDIR)/hashtab.h elf-bfd.h $(INCDIR)/elf/common.h \
+  $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h elf-vxworks.h \
+  $(INCDIR)/elf/i386.h $(INCDIR)/elf/reloc-macros.h elf32-target.h
 elf32-openrisc.lo: elf32-openrisc.c $(INCDIR)/filenames.h \
   $(INCDIR)/hashtab.h elf-bfd.h $(INCDIR)/elf/common.h \
   $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h \
diff -Naur ../PRISTINE/binutils-2.18/bfd/Makefile.in binutils-2.18/bfd/Makefile.in
--- ../PRISTINE/binutils-2.18/bfd/Makefile.in	2007-08-28 13:20:12.000000000 -0700
+++ binutils-2.18/bfd/Makefile.in	2009-01-09 17:32:43.321854000 -0800
@@ -527,6 +527,7 @@
 	elf32-mips.lo \
 	elf32-mt.lo \
 	elf32-msp430.lo \
+	elf32-nacl.lo \
 	elf32-openrisc.lo \
 	elf32-or32.lo \
 	elf32-pj.lo \
@@ -706,6 +707,7 @@
 	elf32-mips.c \
 	elf32-mt.c \
 	elf32-msp430.c \
+	elf32-nacl.c \
 	elf32-openrisc.c \
 	elf32-or32.c \
 	elf32-pj.c \
@@ -2048,6 +2050,10 @@
   $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
   $(INCDIR)/bfdlink.h $(INCDIR)/elf/msp430.h $(INCDIR)/elf/reloc-macros.h \
   elf32-target.h
+elf32-nacl.lo: elf32-nacl.c $(INCDIR)/filenames.h $(INCDIR)/bfdlink.h \
+  $(INCDIR)/hashtab.h elf-bfd.h $(INCDIR)/elf/common.h \
+  $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h elf-vxworks.h \
+  $(INCDIR)/elf/i386.h $(INCDIR)/elf/reloc-macros.h elf32-target.h
 elf32-openrisc.lo: elf32-openrisc.c $(INCDIR)/filenames.h \
   $(INCDIR)/hashtab.h elf-bfd.h $(INCDIR)/elf/common.h \
   $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h \
diff -Naur ../PRISTINE/binutils-2.18/bfd/config.bfd binutils-2.18/bfd/config.bfd
--- ../PRISTINE/binutils-2.18/bfd/config.bfd	2007-08-28 10:19:33.000000000 -0700
+++ binutils-2.18/bfd/config.bfd	2009-01-09 17:32:43.333848000 -0800
@@ -575,6 +575,11 @@
     targ_selvecs="i386linux_vec bfd_efi_app_ia32_vec"
     targ64_selvecs=bfd_elf64_x86_64_vec
     ;;
+  i[3-7]86-*-nacl*)
+    targ_defvec=bfd_elf32_nacl_vec
+    targ_selvecs="bfd_elf32_i386_vec i386linux_vec bfd_efi_app_ia32_vec mach_o_le_vec mach_o_be_vec mach_o_fat_vec"
+    targ_archs="bfd_i386_arch bfd_powerpc_arch"
+    ;;
 #ifdef BFD64
   x86_64-*-elf*)
     targ_defvec=bfd_elf64_x86_64_vec
diff -Naur ../PRISTINE/binutils-2.18/bfd/configure binutils-2.18/bfd/configure
--- ../PRISTINE/binutils-2.18/bfd/configure	2007-08-28 13:19:51.000000000 -0700
+++ binutils-2.18/bfd/configure	2009-01-09 17:32:43.360865000 -0800
@@ -19107,6 +19107,7 @@
     bfd_elf32_mn10300_vec)	tb="$tb elf-m10300.lo elf32.lo $elf" ;;
     bfd_elf32_mt_vec)           tb="$tb elf32-mt.lo elf32.lo $elf" ;;
     bfd_elf32_msp430_vec)	tb="$tb elf32-msp430.lo elf32.lo $elf" ;;
+    bfd_elf32_nacl_vec)		tb="$tb elf32-nacl.lo elf-vxworks.lo elf32.lo $elf" ;;
     bfd_elf32_nbigmips_vec)	tb="$tb elfn32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf32_nlittlemips_vec)	tb="$tb elfn32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf32_ntradbigmips_vec)	tb="$tb elfn32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
diff -Naur ../PRISTINE/binutils-2.18/bfd/configure.in binutils-2.18/bfd/configure.in
--- ../PRISTINE/binutils-2.18/bfd/configure.in	2007-08-28 13:19:56.000000000 -0700
+++ binutils-2.18/bfd/configure.in	2009-01-09 17:32:43.391852000 -0800
@@ -685,6 +685,7 @@
     bfd_elf32_mn10300_vec)	tb="$tb elf-m10300.lo elf32.lo $elf" ;;
     bfd_elf32_mt_vec)           tb="$tb elf32-mt.lo elf32.lo $elf" ;;
     bfd_elf32_msp430_vec)	tb="$tb elf32-msp430.lo elf32.lo $elf" ;;
+    bfd_elf32_nacl_vec)		tb="$tb elf32-nacl.lo elf-vxworks.lo elf32.lo $elf" ;;
     bfd_elf32_nbigmips_vec)	tb="$tb elfn32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf32_nlittlemips_vec)	tb="$tb elfn32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf32_ntradbigmips_vec)	tb="$tb elfn32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
diff -Naur ../PRISTINE/binutils-2.18/bfd/elf32-nacl.c binutils-2.18/bfd/elf32-nacl.c
--- ../PRISTINE/binutils-2.18/bfd/elf32-nacl.c	1969-12-31 16:00:00.000000000 -0800
+++ binutils-2.18/bfd/elf32-nacl.c	2009-02-19 14:48:00.181607000 -0800
@@ -0,0 +1,3945 @@
+/* Intel 80386/80486-specific support for 32-bit ELF
+   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+   2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "bfdlink.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+#include "elf-vxworks.h"
+#include "elf/nacl.h"
+
+/* NativeClient binary format description input. */
+/* NativeClient format is based on elf32. */
+
+
+/* 386 uses REL relocations instead of RELA.  */
+#define USE_REL	1
+
+#include "elf/i386.h"
+
+static reloc_howto_type elf_howto_table[]=
+{
+  HOWTO(R_386_NONE, 0, 0, 0, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_NONE",
+	TRUE, 0x00000000, 0x00000000, FALSE),
+  HOWTO(R_386_32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_32",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_PC32, 0, 2, 32, TRUE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_PC32",
+	TRUE, 0xffffffff, 0xffffffff, TRUE),
+  HOWTO(R_386_GOT32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_GOT32",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_PLT32, 0, 2, 32, TRUE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_PLT32",
+	TRUE, 0xffffffff, 0xffffffff, TRUE),
+  HOWTO(R_386_COPY, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_COPY",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_GLOB_DAT, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_GLOB_DAT",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_JUMP_SLOT, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_JUMP_SLOT",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_RELATIVE, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_RELATIVE",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_GOTOFF, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_GOTOFF",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_GOTPC, 0, 2, 32, TRUE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_GOTPC",
+	TRUE, 0xffffffff, 0xffffffff, TRUE),
+
+  /* We have a gap in the reloc numbers here.
+     R_386_standard counts the number up to this point, and
+     R_386_ext_offset is the value to subtract from a reloc type of
+     R_386_16 thru R_386_PC8 to form an index into this table.  */
+#define R_386_standard (R_386_GOTPC + 1)
+#define R_386_ext_offset (R_386_TLS_TPOFF - R_386_standard)
+
+  /* These relocs are a GNU extension.  */
+  HOWTO(R_386_TLS_TPOFF, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_TPOFF",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_IE, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_IE",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_GOTIE, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_GOTIE",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_LE, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_LE",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_GD, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_GD",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_LDM, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_LDM",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_16, 0, 1, 16, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_16",
+	TRUE, 0xffff, 0xffff, FALSE),
+  HOWTO(R_386_PC16, 0, 1, 16, TRUE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_PC16",
+	TRUE, 0xffff, 0xffff, TRUE),
+  HOWTO(R_386_8, 0, 0, 8, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_8",
+	TRUE, 0xff, 0xff, FALSE),
+  HOWTO(R_386_PC8, 0, 0, 8, TRUE, 0, complain_overflow_signed,
+	bfd_elf_generic_reloc, "R_386_PC8",
+	TRUE, 0xff, 0xff, TRUE),
+
+#define R_386_ext (R_386_PC8 + 1 - R_386_ext_offset)
+#define R_386_tls_offset (R_386_TLS_LDO_32 - R_386_ext)
+  /* These are common with Solaris TLS implementation.  */
+  HOWTO(R_386_TLS_LDO_32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_LDO_32",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_IE_32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_IE_32",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_LE_32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_LE_32",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_DTPMOD32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_DTPMOD32",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_DTPOFF32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_DTPOFF32",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_TPOFF32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_TPOFF32",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  EMPTY_HOWTO (38),
+  HOWTO(R_386_TLS_GOTDESC, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_GOTDESC",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_DESC_CALL, 0, 0, 0, FALSE, 0, complain_overflow_dont,
+	bfd_elf_generic_reloc, "R_386_TLS_DESC_CALL",
+	FALSE, 0, 0, FALSE),
+  HOWTO(R_386_TLS_DESC, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_DESC",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+
+  /* Another gap.  */
+#define R_386_tls (R_386_TLS_DESC + 1 - R_386_tls_offset)
+#define R_386_vt_offset (R_386_GNU_VTINHERIT - R_386_tls)
+
+/* GNU extension to record C++ vtable hierarchy.  */
+  HOWTO (R_386_GNU_VTINHERIT,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 NULL,			/* special_function */
+	 "R_386_GNU_VTINHERIT",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+/* GNU extension to record C++ vtable member usage.  */
+  HOWTO (R_386_GNU_VTENTRY,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_elf_rel_vtable_reloc_fn, /* special_function */
+	 "R_386_GNU_VTENTRY",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE)			/* pcrel_offset */
+
+#define R_386_vt (R_386_GNU_VTENTRY + 1 - R_386_vt_offset)
+
+};
+
+#ifdef DEBUG_GEN_RELOC
+#define TRACE(str) \
+  fprintf (stderr, "i386 bfd reloc lookup %d (%s)\n", code, str)
+#else
+#define TRACE(str)
+#endif
+
+static reloc_howto_type *
+elf_i386_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+			    bfd_reloc_code_real_type code)
+{
+  switch (code)
+    {
+    case BFD_RELOC_NONE:
+      TRACE ("BFD_RELOC_NONE");
+      return &elf_howto_table[R_386_NONE];
+
+    case BFD_RELOC_32:
+      TRACE ("BFD_RELOC_32");
+      return &elf_howto_table[R_386_32];
+
+    case BFD_RELOC_CTOR:
+      TRACE ("BFD_RELOC_CTOR");
+      return &elf_howto_table[R_386_32];
+
+    case BFD_RELOC_32_PCREL:
+      TRACE ("BFD_RELOC_PC32");
+      return &elf_howto_table[R_386_PC32];
+
+    case BFD_RELOC_386_GOT32:
+      TRACE ("BFD_RELOC_386_GOT32");
+      return &elf_howto_table[R_386_GOT32];
+
+    case BFD_RELOC_386_PLT32:
+      TRACE ("BFD_RELOC_386_PLT32");
+      return &elf_howto_table[R_386_PLT32];
+
+    case BFD_RELOC_386_COPY:
+      TRACE ("BFD_RELOC_386_COPY");
+      return &elf_howto_table[R_386_COPY];
+
+    case BFD_RELOC_386_GLOB_DAT:
+      TRACE ("BFD_RELOC_386_GLOB_DAT");
+      return &elf_howto_table[R_386_GLOB_DAT];
+
+    case BFD_RELOC_386_JUMP_SLOT:
+      TRACE ("BFD_RELOC_386_JUMP_SLOT");
+      return &elf_howto_table[R_386_JUMP_SLOT];
+
+    case BFD_RELOC_386_RELATIVE:
+      TRACE ("BFD_RELOC_386_RELATIVE");
+      return &elf_howto_table[R_386_RELATIVE];
+
+    case BFD_RELOC_386_GOTOFF:
+      TRACE ("BFD_RELOC_386_GOTOFF");
+      return &elf_howto_table[R_386_GOTOFF];
+
+    case BFD_RELOC_386_GOTPC:
+      TRACE ("BFD_RELOC_386_GOTPC");
+      return &elf_howto_table[R_386_GOTPC];
+
+      /* These relocs are a GNU extension.  */
+    case BFD_RELOC_386_TLS_TPOFF:
+      TRACE ("BFD_RELOC_386_TLS_TPOFF");
+      return &elf_howto_table[R_386_TLS_TPOFF - R_386_ext_offset];
+
+    case BFD_RELOC_386_TLS_IE:
+      TRACE ("BFD_RELOC_386_TLS_IE");
+      return &elf_howto_table[R_386_TLS_IE - R_386_ext_offset];
+
+    case BFD_RELOC_386_TLS_GOTIE:
+      TRACE ("BFD_RELOC_386_TLS_GOTIE");
+      return &elf_howto_table[R_386_TLS_GOTIE - R_386_ext_offset];
+
+    case BFD_RELOC_386_TLS_LE:
+      TRACE ("BFD_RELOC_386_TLS_LE");
+      return &elf_howto_table[R_386_TLS_LE - R_386_ext_offset];
+
+    case BFD_RELOC_386_TLS_GD:
+      TRACE ("BFD_RELOC_386_TLS_GD");
+      return &elf_howto_table[R_386_TLS_GD - R_386_ext_offset];
+
+    case BFD_RELOC_386_TLS_LDM:
+      TRACE ("BFD_RELOC_386_TLS_LDM");
+      return &elf_howto_table[R_386_TLS_LDM - R_386_ext_offset];
+
+    case BFD_RELOC_16:
+      TRACE ("BFD_RELOC_16");
+      return &elf_howto_table[R_386_16 - R_386_ext_offset];
+
+    case BFD_RELOC_16_PCREL:
+      TRACE ("BFD_RELOC_16_PCREL");
+      return &elf_howto_table[R_386_PC16 - R_386_ext_offset];
+
+    case BFD_RELOC_8:
+      TRACE ("BFD_RELOC_8");
+      return &elf_howto_table[R_386_8 - R_386_ext_offset];
+
+    case BFD_RELOC_8_PCREL:
+      TRACE ("BFD_RELOC_8_PCREL");
+      return &elf_howto_table[R_386_PC8 - R_386_ext_offset];
+
+    /* Common with Sun TLS implementation.  */
+    case BFD_RELOC_386_TLS_LDO_32:
+      TRACE ("BFD_RELOC_386_TLS_LDO_32");
+      return &elf_howto_table[R_386_TLS_LDO_32 - R_386_tls_offset];
+
+    case BFD_RELOC_386_TLS_IE_32:
+      TRACE ("BFD_RELOC_386_TLS_IE_32");
+      return &elf_howto_table[R_386_TLS_IE_32 - R_386_tls_offset];
+
+    case BFD_RELOC_386_TLS_LE_32:
+      TRACE ("BFD_RELOC_386_TLS_LE_32");
+      return &elf_howto_table[R_386_TLS_LE_32 - R_386_tls_offset];
+
+    case BFD_RELOC_386_TLS_DTPMOD32:
+      TRACE ("BFD_RELOC_386_TLS_DTPMOD32");
+      return &elf_howto_table[R_386_TLS_DTPMOD32 - R_386_tls_offset];
+
+    case BFD_RELOC_386_TLS_DTPOFF32:
+      TRACE ("BFD_RELOC_386_TLS_DTPOFF32");
+      return &elf_howto_table[R_386_TLS_DTPOFF32 - R_386_tls_offset];
+
+    case BFD_RELOC_386_TLS_TPOFF32:
+      TRACE ("BFD_RELOC_386_TLS_TPOFF32");
+      return &elf_howto_table[R_386_TLS_TPOFF32 - R_386_tls_offset];
+
+    case BFD_RELOC_386_TLS_GOTDESC:
+      TRACE ("BFD_RELOC_386_TLS_GOTDESC");
+      return &elf_howto_table[R_386_TLS_GOTDESC - R_386_tls_offset];
+
+    case BFD_RELOC_386_TLS_DESC_CALL:
+      TRACE ("BFD_RELOC_386_TLS_DESC_CALL");
+      return &elf_howto_table[R_386_TLS_DESC_CALL - R_386_tls_offset];
+
+    case BFD_RELOC_386_TLS_DESC:
+      TRACE ("BFD_RELOC_386_TLS_DESC");
+      return &elf_howto_table[R_386_TLS_DESC - R_386_tls_offset];
+
+    case BFD_RELOC_VTABLE_INHERIT:
+      TRACE ("BFD_RELOC_VTABLE_INHERIT");
+      return &elf_howto_table[R_386_GNU_VTINHERIT - R_386_vt_offset];
+
+    case BFD_RELOC_VTABLE_ENTRY:
+      TRACE ("BFD_RELOC_VTABLE_ENTRY");
+      return &elf_howto_table[R_386_GNU_VTENTRY - R_386_vt_offset];
+
+    default:
+      break;
+    }
+
+  TRACE ("Unknown");
+  return 0;
+}
+
+static reloc_howto_type *
+elf_i386_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+			    const char *r_name)
+{
+  unsigned int i;
+
+  for (i = 0; i < sizeof (elf_howto_table) / sizeof (elf_howto_table[0]); i++)
+    if (elf_howto_table[i].name != NULL
+	&& strcasecmp (elf_howto_table[i].name, r_name) == 0)
+      return &elf_howto_table[i];
+
+  return NULL;
+}
+
+static void
+elf_i386_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
+			    arelent *cache_ptr,
+			    Elf_Internal_Rela *dst)
+{
+  unsigned int r_type = ELF32_R_TYPE (dst->r_info);
+  unsigned int indx;
+
+  if ((indx = r_type) >= R_386_standard
+      && ((indx = r_type - R_386_ext_offset) - R_386_standard
+	  >= R_386_ext - R_386_standard)
+      && ((indx = r_type - R_386_tls_offset) - R_386_ext
+	  >= R_386_tls - R_386_ext)
+      && ((indx = r_type - R_386_vt_offset) - R_386_tls
+	  >= R_386_vt - R_386_tls))
+    {
+      (*_bfd_error_handler) (_("%B: invalid relocation type %d"),
+			     abfd, (int) r_type);
+      indx = R_386_NONE;
+    }
+  cache_ptr->howto = &elf_howto_table[indx];
+}
+
+/* Return whether a symbol name implies a local label.  The UnixWare
+   2.1 cc generates temporary symbols that start with .X, so we
+   recognize them here.  FIXME: do other SVR4 compilers also use .X?.
+   If so, we should move the .X recognition into
+   _bfd_elf_is_local_label_name.  */
+
+static bfd_boolean
+elf_i386_is_local_label_name (bfd *abfd, const char *name)
+{
+  if (name[0] == '.' && name[1] == 'X')
+    return TRUE;
+
+  return _bfd_elf_is_local_label_name (abfd, name);
+}
+
+/* Support for core dump NOTE sections.  */
+
+static bfd_boolean
+elf_i386_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
+{
+  int offset;
+  size_t size;
+
+  if (note->namesz == 8 && strcmp (note->namedata, "FreeBSD") == 0)
+    {
+      int pr_version = bfd_get_32 (abfd, note->descdata);
+
+      if (pr_version != 1)
+ 	return FALSE;
+
+      /* pr_cursig */
+      elf_tdata (abfd)->core_signal = bfd_get_32 (abfd, note->descdata + 20);
+
+      /* pr_pid */
+      elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 24);
+
+      /* pr_reg */
+      offset = 28;
+      size = bfd_get_32 (abfd, note->descdata + 8);
+    }
+  else
+    {
+      switch (note->descsz)
+	{
+	default:
+	  return FALSE;
+
+	case 144:		/* Linux/i386 */
+	  /* pr_cursig */
+	  elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);
+
+	  /* pr_pid */
+	  elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 24);
+
+	  /* pr_reg */
+	  offset = 72;
+	  size = 68;
+
+	  break;
+	}
+    }
+
+  /* Make a ".reg/999" section.  */
+  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
+					  size, note->descpos + offset);
+}
+
+static bfd_boolean
+elf_i386_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
+{
+  if (note->namesz == 8 && strcmp (note->namedata, "FreeBSD") == 0)
+    {
+      int pr_version = bfd_get_32 (abfd, note->descdata);
+
+      if (pr_version != 1)
+	return FALSE;
+
+      elf_tdata (abfd)->core_program
+	= _bfd_elfcore_strndup (abfd, note->descdata + 8, 17);
+      elf_tdata (abfd)->core_command
+	= _bfd_elfcore_strndup (abfd, note->descdata + 25, 81);
+    }
+  else
+    {
+      switch (note->descsz)
+	{
+	default:
+	  return FALSE;
+
+	case 124:		/* Linux/i386 elf_prpsinfo.  */
+	  elf_tdata (abfd)->core_program
+	    = _bfd_elfcore_strndup (abfd, note->descdata + 28, 16);
+	  elf_tdata (abfd)->core_command
+	    = _bfd_elfcore_strndup (abfd, note->descdata + 44, 80);
+	}
+    }
+
+  /* Note that for some reason, a spurious space is tacked
+     onto the end of the args in some (at least one anyway)
+     implementations, so strip it off if it exists.  */
+  {
+    char *command = elf_tdata (abfd)->core_command;
+    int n = strlen (command);
+
+    if (0 < n && command[n - 1] == ' ')
+      command[n - 1] = '\0';
+  }
+
+  return TRUE;
+}
+
+/* Functions for the i386 ELF linker.
+
+   In order to gain some understanding of code in this file without
+   knowing all the intricate details of the linker, note the
+   following:
+
+   Functions named elf_i386_* are called by external routines, other
+   functions are only called locally.  elf_i386_* functions appear
+   in this file more or less in the order in which they are called
+   from external routines.  eg. elf_i386_check_relocs is called
+   early in the link process, elf_i386_finish_dynamic_sections is
+   one of the last functions.  */
+
+
+/* The name of the dynamic interpreter.  This is put in the .interp
+   section.  */
+
+#define ELF_DYNAMIC_INTERPRETER "/usr/lib/libc.so.1"
+
+/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
+   copying dynamic variables from a shared lib into an app's dynbss
+   section, and instead use a dynamic relocation to point into the
+   shared lib.  */
+#define ELIMINATE_COPY_RELOCS 1
+
+/* The size in bytes of an entry in the procedure linkage table.  */
+
+#define PLT_ENTRY_SIZE 64
+
+/* The first entry in an absolute procedure linkage table looks like
+   this.  See the SVR4 ABI i386 supplement to see how this works.
+   Will be padded to PLT_ENTRY_SIZE with htab->plt0_pad_byte.  */
+
+static const bfd_byte elf_i386_plt0_entry[18] =
+{
+  0xff, 0x35,	    /* pushl contents of address */
+#define elf_i386_plt0_entry_offset1 2
+  0, 0, 0, 0,	    /* replaced with address of .got + 4.  */
+  0xb9,             /* movl address, %ecx */
+#define elf_i386_plt0_entry_offset2 7
+  0, 0, 0, 0,       /* replaced with address of .got + 8.  */
+  0x8b, 0x09,       /* mov (%ecx), %ecx */
+  0x83, 0xe1, 0xe0, /* andl %ecx, NACLMASK */
+  0xff, 0xe1	       /* jmp *%ecx */
+};
+
+/* Subsequent entries in an absolute procedure linkage table look like
+   this.  */
+
+static const bfd_byte elf_i386_plt_entry[PLT_ENTRY_SIZE] =
+{
+  0xb9,	                    /* movl address, %ecx */
+#define elf_i386_plt_entry_offset1 1
+  0, 0, 0, 0,	            /* replaced with address of this symbol in .got.  */
+  0x8b, 0x09,               /* mov (%ecx), %ecx */
+  0x83, 0xe1, 0xe0,         /* andl %ecx, NACLMASK */
+  0xff, 0xe1,	            /* jmp *%ecx */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+#define elf_i386_plt_entry_offset2 32
+  0x68,		            /* pushl immediate */
+#define elf_i386_plt_entry_offset3 33
+  0, 0, 0, 0,	            /* replaced with offset into relocation table.  */
+  0xe9,		            /* jmp relative */
+#define elf_i386_plt_entry_offset4 38
+  0, 0, 0, 0,	            /* replaced with offset to start of .plt.  */
+#define elf_i386_plt_entry_offset5 42
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4                /* fill with hlt instructions. */
+};
+
+/* The first entry in a PIC procedure linkage table look like this.
+   Will be padded to PLT_ENTRY_SIZE with htab->plt0_pad_byte.  */
+
+static const bfd_byte elf_i386_pic_plt0_entry[12] =
+{
+  0xff, 0xb3, 4, 0, 0, 0,	/* pushl 4(%ebx) */
+  0xff, 0xa3, 8, 0, 0, 0	/* jmp *8(%ebx) */
+};
+
+/* Subsequent entries in a PIC procedure linkage table look like this.  */
+
+static const bfd_byte elf_i386_pic_plt_entry[PLT_ENTRY_SIZE] =
+{
+  0x8b, 0x8b,               /* movl offset(%ebx), %ecx */
+  0, 0, 0, 0,	            /* replaced with offset of this symbol in .got.  */
+  0x83, 0xe1, 0xe0,         /* andl %ecx, NACLMASK */
+  0xff, 0xe1,	            /* jmp *%ecx */
+  0x68,		            /* pushl immediate */
+  0, 0, 0, 0,	            /* replaced with offset into relocation table.  */
+  0xe9,		            /* jmp relative */
+  0, 0, 0, 0,	            /* replaced with offset to start of .plt.  */
+  0xf4, 0xf4, 0xf4,         /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4    /* fill with hlt instructions. */
+};
+
+/* On VxWorks, the .rel.plt.unloaded section has absolute relocations
+   for the PLTResolve stub and then for each PLT entry.  */
+#define PLTRESOLVE_RELOCS_SHLIB 0
+#define PLTRESOLVE_RELOCS 2
+#define PLT_NON_JUMP_SLOT_RELOCS 2
+
+/* The i386 linker needs to keep track of the number of relocs that it
+   decides to copy as dynamic relocs in check_relocs for each symbol.
+   This is so that it can later discard them if they are found to be
+   unnecessary.  We store the information in a field extending the
+   regular ELF linker hash table.  */
+
+struct elf_i386_dyn_relocs
+{
+  struct elf_i386_dyn_relocs *next;
+
+  /* The input section of the reloc.  */
+  asection *sec;
+
+  /* Total number of relocs copied for the input section.  */
+  bfd_size_type count;
+
+  /* Number of pc-relative relocs copied for the input section.  */
+  bfd_size_type pc_count;
+};
+
+/* i386 ELF linker hash entry.  */
+
+struct elf_i386_link_hash_entry
+{
+  struct elf_link_hash_entry elf;
+
+  /* Track dynamic relocs copied for this symbol.  */
+  struct elf_i386_dyn_relocs *dyn_relocs;
+
+#define GOT_UNKNOWN	0
+#define GOT_NORMAL	1
+#define GOT_TLS_GD	2
+#define GOT_TLS_IE	4
+#define GOT_TLS_IE_POS	5
+#define GOT_TLS_IE_NEG	6
+#define GOT_TLS_IE_BOTH 7
+#define GOT_TLS_GDESC	8
+#define GOT_TLS_GD_BOTH_P(type)						\
+  ((type) == (GOT_TLS_GD | GOT_TLS_GDESC))
+#define GOT_TLS_GD_P(type)						\
+  ((type) == GOT_TLS_GD || GOT_TLS_GD_BOTH_P (type))
+#define GOT_TLS_GDESC_P(type)						\
+  ((type) == GOT_TLS_GDESC || GOT_TLS_GD_BOTH_P (type))
+#define GOT_TLS_GD_ANY_P(type)						\
+  (GOT_TLS_GD_P (type) || GOT_TLS_GDESC_P (type))
+  unsigned char tls_type;
+
+  /* Offset of the GOTPLT entry reserved for the TLS descriptor,
+     starting at the end of the jump table.  */
+  bfd_vma tlsdesc_got;
+};
+
+#define elf_i386_hash_entry(ent) ((struct elf_i386_link_hash_entry *)(ent))
+
+struct elf_i386_obj_tdata
+{
+  struct elf_obj_tdata root;
+
+  /* tls_type for each local got entry.  */
+  char *local_got_tls_type;
+
+  /* GOTPLT entries for TLS descriptors.  */
+  bfd_vma *local_tlsdesc_gotent;
+};
+
+#define elf_i386_tdata(abfd) \
+  ((struct elf_i386_obj_tdata *) (abfd)->tdata.any)
+
+#define elf_i386_local_got_tls_type(abfd) \
+  (elf_i386_tdata (abfd)->local_got_tls_type)
+
+#define elf_i386_local_tlsdesc_gotent(abfd) \
+  (elf_i386_tdata (abfd)->local_tlsdesc_gotent)
+
+static bfd_boolean
+elf_i386_mkobject (bfd *abfd)
+{
+  if (abfd->tdata.any == NULL)
+    {
+      bfd_size_type amt = sizeof (struct elf_i386_obj_tdata);
+      abfd->tdata.any = bfd_zalloc (abfd, amt);
+      if (abfd->tdata.any == NULL)
+	return FALSE;
+    }
+  return bfd_elf_mkobject (abfd);
+}
+
+/* i386 ELF linker hash table.  */
+
+struct elf_i386_link_hash_table
+{
+  struct elf_link_hash_table elf;
+
+  /* Short-cuts to get to dynamic linker sections.  */
+  asection *sgot;
+  asection *sgotplt;
+  asection *srelgot;
+  asection *splt;
+  asection *srelplt;
+  asection *sdynbss;
+  asection *srelbss;
+
+  /* The (unloaded but important) .rel.plt.unloaded section on VxWorks.  */
+  asection *srelplt2;
+
+  /* True if the target system is VxWorks.  */
+  int is_vxworks;
+
+  /* Value used to fill the last word of the first plt entry.  */
+  bfd_byte plt0_pad_byte;
+
+  /* The index of the next unused R_386_TLS_DESC slot in .rel.plt.  */
+  bfd_vma next_tls_desc_index;
+
+  union {
+    bfd_signed_vma refcount;
+    bfd_vma offset;
+  } tls_ldm_got;
+
+  /* The amount of space used by the reserved portion of the sgotplt
+     section, plus whatever space is used by the jump slots.  */
+  bfd_vma sgotplt_jump_table_size;
+
+  /* Small local sym to section mapping cache.  */
+  struct sym_sec_cache sym_sec;
+};
+
+/* Get the i386 ELF linker hash table from a link_info structure.  */
+
+#define elf_i386_hash_table(p) \
+  ((struct elf_i386_link_hash_table *) ((p)->hash))
+
+#define elf_i386_compute_jump_table_size(htab) \
+  ((htab)->next_tls_desc_index * 4)
+
+/* Create an entry in an i386 ELF linker hash table.  */
+
+static struct bfd_hash_entry *
+link_hash_newfunc (struct bfd_hash_entry *entry,
+		   struct bfd_hash_table *table,
+		   const char *string)
+{
+  /* Allocate the structure if it has not already been allocated by a
+     subclass.  */
+  if (entry == NULL)
+    {
+      entry = bfd_hash_allocate (table,
+				 sizeof (struct elf_i386_link_hash_entry));
+      if (entry == NULL)
+	return entry;
+    }
+
+  /* Call the allocation method of the superclass.  */
+  entry = _bfd_elf_link_hash_newfunc (entry, table, string);
+  if (entry != NULL)
+    {
+      struct elf_i386_link_hash_entry *eh;
+
+      eh = (struct elf_i386_link_hash_entry *) entry;
+      eh->dyn_relocs = NULL;
+      eh->tls_type = GOT_UNKNOWN;
+      eh->tlsdesc_got = (bfd_vma) -1;
+    }
+
+  return entry;
+}
+
+/* Create an i386 ELF linker hash table.  */
+
+static struct bfd_link_hash_table *
+elf_i386_link_hash_table_create (bfd *abfd)
+{
+  struct elf_i386_link_hash_table *ret;
+  bfd_size_type amt = sizeof (struct elf_i386_link_hash_table);
+
+  ret = bfd_malloc (amt);
+  if (ret == NULL)
+    return NULL;
+
+  if (!_bfd_elf_link_hash_table_init (&ret->elf, abfd, link_hash_newfunc,
+				      sizeof (struct elf_i386_link_hash_entry)))
+    {
+      free (ret);
+      return NULL;
+    }
+
+  ret->sgot = NULL;
+  ret->sgotplt = NULL;
+  ret->srelgot = NULL;
+  ret->splt = NULL;
+  ret->srelplt = NULL;
+  ret->sdynbss = NULL;
+  ret->srelbss = NULL;
+  ret->tls_ldm_got.refcount = 0;
+  ret->next_tls_desc_index = 0;
+  ret->sgotplt_jump_table_size = 0;
+  ret->sym_sec.abfd = NULL;
+  ret->is_vxworks = 0;
+  ret->srelplt2 = NULL;
+  ret->plt0_pad_byte = 0xf4;
+
+  return &ret->elf.root;
+}
+
+/* Create .got, .gotplt, and .rel.got sections in DYNOBJ, and set up
+   shortcuts to them in our hash table.  */
+
+static bfd_boolean
+create_got_section (bfd *dynobj, struct bfd_link_info *info)
+{
+  struct elf_i386_link_hash_table *htab;
+
+  if (! _bfd_elf_create_got_section (dynobj, info))
+    return FALSE;
+
+  htab = elf_i386_hash_table (info);
+  htab->sgot = bfd_get_section_by_name (dynobj, ".got");
+  htab->sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
+  if (!htab->sgot || !htab->sgotplt)
+    abort ();
+
+  htab->srelgot = bfd_make_section_with_flags (dynobj, ".rel.got",
+					       (SEC_ALLOC | SEC_LOAD
+						| SEC_HAS_CONTENTS
+						| SEC_IN_MEMORY
+						| SEC_LINKER_CREATED
+						| SEC_READONLY));
+  if (htab->srelgot == NULL
+      || ! bfd_set_section_alignment (dynobj, htab->srelgot, 2))
+    return FALSE;
+  return TRUE;
+}
+
+/* Create .plt, .rel.plt, .got, .got.plt, .rel.got, .dynbss, and
+   .rel.bss sections in DYNOBJ, and set up shortcuts to them in our
+   hash table.  */
+
+static bfd_boolean
+elf_i386_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info)
+{
+  struct elf_i386_link_hash_table *htab;
+
+  htab = elf_i386_hash_table (info);
+  if (!htab->sgot && !create_got_section (dynobj, info))
+    return FALSE;
+
+  if (!_bfd_elf_create_dynamic_sections (dynobj, info))
+    return FALSE;
+
+  htab->splt = bfd_get_section_by_name (dynobj, ".plt");
+  htab->srelplt = bfd_get_section_by_name (dynobj, ".rel.plt");
+  htab->sdynbss = bfd_get_section_by_name (dynobj, ".dynbss");
+  if (!info->shared)
+    htab->srelbss = bfd_get_section_by_name (dynobj, ".rel.bss");
+
+  if (!htab->splt || !htab->srelplt || !htab->sdynbss
+      || (!info->shared && !htab->srelbss))
+    abort ();
+
+  if (!bfd_set_section_alignment(dynobj, htab->splt, 5))
+    return FALSE;
+
+  if (htab->is_vxworks
+      && !elf_vxworks_create_dynamic_sections (dynobj, info, &htab->srelplt2))
+    return FALSE;
+
+  return TRUE;
+}
+
+/* Copy the extra info we tack onto an elf_link_hash_entry.  */
+
+static void
+elf_i386_copy_indirect_symbol (struct bfd_link_info *info,
+			       struct elf_link_hash_entry *dir,
+			       struct elf_link_hash_entry *ind)
+{
+  struct elf_i386_link_hash_entry *edir, *eind;
+
+  edir = (struct elf_i386_link_hash_entry *) dir;
+  eind = (struct elf_i386_link_hash_entry *) ind;
+
+  if (eind->dyn_relocs != NULL)
+    {
+      if (edir->dyn_relocs != NULL)
+	{
+	  struct elf_i386_dyn_relocs **pp;
+	  struct elf_i386_dyn_relocs *p;
+
+	  /* Add reloc counts against the indirect sym to the direct sym
+	     list.  Merge any entries against the same section.  */
+	  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )
+	    {
+	      struct elf_i386_dyn_relocs *q;
+
+	      for (q = edir->dyn_relocs; q != NULL; q = q->next)
+		if (q->sec == p->sec)
+		  {
+		    q->pc_count += p->pc_count;
+		    q->count += p->count;
+		    *pp = p->next;
+		    break;
+		  }
+	      if (q == NULL)
+		pp = &p->next;
+	    }
+	  *pp = edir->dyn_relocs;
+	}
+
+      edir->dyn_relocs = eind->dyn_relocs;
+      eind->dyn_relocs = NULL;
+    }
+
+  if (ind->root.type == bfd_link_hash_indirect
+      && dir->got.refcount <= 0)
+    {
+      edir->tls_type = eind->tls_type;
+      eind->tls_type = GOT_UNKNOWN;
+    }
+
+  if (ELIMINATE_COPY_RELOCS
+      && ind->root.type != bfd_link_hash_indirect
+      && dir->dynamic_adjusted)
+    {
+      /* If called to transfer flags for a weakdef during processing
+	 of elf_adjust_dynamic_symbol, don't copy non_got_ref.
+	 We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
+      dir->ref_dynamic |= ind->ref_dynamic;
+      dir->ref_regular |= ind->ref_regular;
+      dir->ref_regular_nonweak |= ind->ref_regular_nonweak;
+      dir->needs_plt |= ind->needs_plt;
+      dir->pointer_equality_needed |= ind->pointer_equality_needed;
+    }
+  else
+    _bfd_elf_link_hash_copy_indirect (info, dir, ind);
+}
+
+static int
+elf_i386_tls_transition (struct bfd_link_info *info, int r_type, int is_local)
+{
+  if (info->shared)
+    return r_type;
+
+  switch (r_type)
+    {
+    case R_386_TLS_GD:
+    case R_386_TLS_GOTDESC:
+    case R_386_TLS_DESC_CALL:
+    case R_386_TLS_IE_32:
+      if (is_local)
+	return R_386_TLS_LE_32;
+      return R_386_TLS_IE_32;
+    case R_386_TLS_IE:
+    case R_386_TLS_GOTIE:
+      if (is_local)
+	return R_386_TLS_LE_32;
+      return r_type;
+    case R_386_TLS_LDM:
+      return R_386_TLS_LE_32;
+    }
+
+  return r_type;
+}
+
+/* Look through the relocs for a section during the first phase, and
+   calculate needed space in the global offset table, procedure linkage
+   table, and dynamic reloc sections.  */
+
+static bfd_boolean
+elf_i386_check_relocs (bfd *abfd,
+		       struct bfd_link_info *info,
+		       asection *sec,
+		       const Elf_Internal_Rela *relocs)
+{
+  struct elf_i386_link_hash_table *htab;
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  const Elf_Internal_Rela *rel;
+  const Elf_Internal_Rela *rel_end;
+  asection *sreloc;
+
+  if (info->relocatable)
+    return TRUE;
+
+  htab = elf_i386_hash_table (info);
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (abfd);
+
+  sreloc = NULL;
+
+  rel_end = relocs + sec->reloc_count;
+  for (rel = relocs; rel < rel_end; rel++)
+    {
+      unsigned int r_type;
+      unsigned long r_symndx;
+      struct elf_link_hash_entry *h;
+
+      r_symndx = ELF32_R_SYM (rel->r_info);
+      r_type = ELF32_R_TYPE (rel->r_info);
+
+      if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))
+	{
+	  (*_bfd_error_handler) (_("%B: bad symbol index: %d"),
+				 abfd,
+				 r_symndx);
+	  return FALSE;
+	}
+
+      if (r_symndx < symtab_hdr->sh_info)
+	h = NULL;
+      else
+	{
+	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+	}
+
+      r_type = elf_i386_tls_transition (info, r_type, h == NULL);
+
+      switch (r_type)
+	{
+	case R_386_TLS_LDM:
+	  htab->tls_ldm_got.refcount += 1;
+	  goto create_got;
+
+	case R_386_PLT32:
+	  /* This symbol requires a procedure linkage table entry.  We
+	     actually build the entry in adjust_dynamic_symbol,
+	     because this might be a case of linking PIC code which is
+	     never referenced by a dynamic object, in which case we
+	     don't need to generate a procedure linkage table entry
+	     after all.  */
+
+	  /* If this is a local symbol, we resolve it directly without
+	     creating a procedure linkage table entry.  */
+	  if (h == NULL)
+	    continue;
+
+	  h->needs_plt = 1;
+	  h->plt.refcount += 1;
+	  break;
+
+	case R_386_TLS_IE_32:
+	case R_386_TLS_IE:
+	case R_386_TLS_GOTIE:
+	  if (info->shared)
+	    info->flags |= DF_STATIC_TLS;
+	  /* Fall through */
+
+	case R_386_GOT32:
+	case R_386_TLS_GD:
+	case R_386_TLS_GOTDESC:
+	case R_386_TLS_DESC_CALL:
+	  /* This symbol requires a global offset table entry.  */
+	  {
+	    int tls_type, old_tls_type;
+
+	    switch (r_type)
+	      {
+	      default:
+	      case R_386_GOT32: tls_type = GOT_NORMAL; break;
+	      case R_386_TLS_GD: tls_type = GOT_TLS_GD; break;
+	      case R_386_TLS_GOTDESC:
+	      case R_386_TLS_DESC_CALL:
+		tls_type = GOT_TLS_GDESC; break;
+	      case R_386_TLS_IE_32:
+		if (ELF32_R_TYPE (rel->r_info) == r_type)
+		  tls_type = GOT_TLS_IE_NEG;
+		else
+		  /* If this is a GD->IE transition, we may use either of
+		     R_386_TLS_TPOFF and R_386_TLS_TPOFF32.  */
+		  tls_type = GOT_TLS_IE;
+		break;
+	      case R_386_TLS_IE:
+	      case R_386_TLS_GOTIE:
+		tls_type = GOT_TLS_IE_POS; break;
+	      }
+
+	    if (h != NULL)
+	      {
+		h->got.refcount += 1;
+		old_tls_type = elf_i386_hash_entry(h)->tls_type;
+	      }
+	    else
+	      {
+		bfd_signed_vma *local_got_refcounts;
+
+		/* This is a global offset table entry for a local symbol.  */
+		local_got_refcounts = elf_local_got_refcounts (abfd);
+		if (local_got_refcounts == NULL)
+		  {
+		    bfd_size_type size;
+
+		    size = symtab_hdr->sh_info;
+		    size *= (sizeof (bfd_signed_vma)
+			     + sizeof (bfd_vma) + sizeof(char));
+		    local_got_refcounts = bfd_zalloc (abfd, size);
+		    if (local_got_refcounts == NULL)
+		      return FALSE;
+		    elf_local_got_refcounts (abfd) = local_got_refcounts;
+		    elf_i386_local_tlsdesc_gotent (abfd)
+		      = (bfd_vma *) (local_got_refcounts + symtab_hdr->sh_info);
+		    elf_i386_local_got_tls_type (abfd)
+		      = (char *) (local_got_refcounts + 2 * symtab_hdr->sh_info);
+		  }
+		local_got_refcounts[r_symndx] += 1;
+		old_tls_type = elf_i386_local_got_tls_type (abfd) [r_symndx];
+	      }
+
+	    if ((old_tls_type & GOT_TLS_IE) && (tls_type & GOT_TLS_IE))
+	      tls_type |= old_tls_type;
+	    /* If a TLS symbol is accessed using IE at least once,
+	       there is no point to use dynamic model for it.  */
+	    else if (old_tls_type != tls_type && old_tls_type != GOT_UNKNOWN
+		     && (! GOT_TLS_GD_ANY_P (old_tls_type)
+			 || (tls_type & GOT_TLS_IE) == 0))
+	      {
+		if ((old_tls_type & GOT_TLS_IE) && GOT_TLS_GD_ANY_P (tls_type))
+		  tls_type = old_tls_type;
+		else if (GOT_TLS_GD_ANY_P (old_tls_type)
+			 && GOT_TLS_GD_ANY_P (tls_type))
+		  tls_type |= old_tls_type;
+		else
+		  {
+		    (*_bfd_error_handler)
+		      (_("%B: `%s' accessed both as normal and "
+			 "thread local symbol"),
+		       abfd,
+		       h ? h->root.root.string : "<local>");
+		    return FALSE;
+		  }
+	      }
+
+	    if (old_tls_type != tls_type)
+	      {
+		if (h != NULL)
+		  elf_i386_hash_entry (h)->tls_type = tls_type;
+		else
+		  elf_i386_local_got_tls_type (abfd) [r_symndx] = tls_type;
+	      }
+	  }
+	  /* Fall through */
+
+	case R_386_GOTOFF:
+	case R_386_GOTPC:
+	create_got:
+	  if (htab->sgot == NULL)
+	    {
+	      if (htab->elf.dynobj == NULL)
+		htab->elf.dynobj = abfd;
+	      if (!create_got_section (htab->elf.dynobj, info))
+		return FALSE;
+	    }
+	  if (r_type != R_386_TLS_IE)
+	    break;
+	  /* Fall through */
+
+	case R_386_TLS_LE_32:
+	case R_386_TLS_LE:
+	  if (!info->shared)
+	    break;
+	  info->flags |= DF_STATIC_TLS;
+	  /* Fall through */
+
+	case R_386_32:
+	case R_386_PC32:
+	  if (h != NULL && !info->shared)
+	    {
+	      /* If this reloc is in a read-only section, we might
+		 need a copy reloc.  We can't check reliably at this
+		 stage whether the section is read-only, as input
+		 sections have not yet been mapped to output sections.
+		 Tentatively set the flag for now, and correct in
+		 adjust_dynamic_symbol.  */
+	      h->non_got_ref = 1;
+
+	      /* We may need a .plt entry if the function this reloc
+		 refers to is in a shared lib.  */
+	      h->plt.refcount += 1;
+	      if (r_type != R_386_PC32)
+		h->pointer_equality_needed = 1;
+	    }
+
+	  /* If we are creating a shared library, and this is a reloc
+	     against a global symbol, or a non PC relative reloc
+	     against a local symbol, then we need to copy the reloc
+	     into the shared library.  However, if we are linking with
+	     -Bsymbolic, we do not need to copy a reloc against a
+	     global symbol which is defined in an object we are
+	     including in the link (i.e., DEF_REGULAR is set).  At
+	     this point we have not seen all the input files, so it is
+	     possible that DEF_REGULAR is not set now but will be set
+	     later (it is never cleared).  In case of a weak definition,
+	     DEF_REGULAR may be cleared later by a strong definition in
+	     a shared library.  We account for that possibility below by
+	     storing information in the relocs_copied field of the hash
+	     table entry.  A similar situation occurs when creating
+	     shared libraries and symbol visibility changes render the
+	     symbol local.
+
+	     If on the other hand, we are creating an executable, we
+	     may need to keep relocations for symbols satisfied by a
+	     dynamic library if we manage to avoid copy relocs for the
+	     symbol.  */
+	  if ((info->shared
+	       && (sec->flags & SEC_ALLOC) != 0
+	       && (r_type != R_386_PC32
+		   || (h != NULL
+		       && (! SYMBOLIC_BIND (info, h)
+			   || h->root.type == bfd_link_hash_defweak
+			   || !h->def_regular))))
+	      || (ELIMINATE_COPY_RELOCS
+		  && !info->shared
+		  && (sec->flags & SEC_ALLOC) != 0
+		  && h != NULL
+		  && (h->root.type == bfd_link_hash_defweak
+		      || !h->def_regular)))
+	    {
+	      struct elf_i386_dyn_relocs *p;
+	      struct elf_i386_dyn_relocs **head;
+
+	      /* We must copy these reloc types into the output file.
+		 Create a reloc section in dynobj and make room for
+		 this reloc.  */
+	      if (sreloc == NULL)
+		{
+		  const char *name;
+		  bfd *dynobj;
+		  unsigned int strndx = elf_elfheader (abfd)->e_shstrndx;
+		  unsigned int shnam = elf_section_data (sec)->rel_hdr.sh_name;
+
+		  name = bfd_elf_string_from_elf_section (abfd, strndx, shnam);
+		  if (name == NULL)
+		    return FALSE;
+
+		  if (! CONST_STRNEQ (name, ".rel")
+		      || strcmp (bfd_get_section_name (abfd, sec),
+				 name + 4) != 0)
+		    {
+		      (*_bfd_error_handler)
+			(_("%B: bad relocation section name `%s\'"),
+			 abfd, name);
+		    }
+
+		  if (htab->elf.dynobj == NULL)
+		    htab->elf.dynobj = abfd;
+
+		  dynobj = htab->elf.dynobj;
+		  sreloc = bfd_get_section_by_name (dynobj, name);
+		  if (sreloc == NULL)
+		    {
+		      flagword flags;
+
+		      flags = (SEC_HAS_CONTENTS | SEC_READONLY
+			       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
+		      if ((sec->flags & SEC_ALLOC) != 0)
+			flags |= SEC_ALLOC | SEC_LOAD;
+		      sreloc = bfd_make_section_with_flags (dynobj,
+							    name,
+							    flags);
+		      if (sreloc == NULL
+			  || ! bfd_set_section_alignment (dynobj, sreloc, 2))
+			return FALSE;
+		    }
+		  elf_section_data (sec)->sreloc = sreloc;
+		}
+
+	      /* If this is a global symbol, we count the number of
+		 relocations we need for this symbol.  */
+	      if (h != NULL)
+		{
+		  head = &((struct elf_i386_link_hash_entry *) h)->dyn_relocs;
+		}
+	      else
+		{
+		  void **vpp;
+		  /* Track dynamic relocs needed for local syms too.
+		     We really need local syms available to do this
+		     easily.  Oh well.  */
+
+		  asection *s;
+		  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
+						 sec, r_symndx);
+		  if (s == NULL)
+		    return FALSE;
+
+		  vpp = &elf_section_data (s)->local_dynrel;
+		  head = (struct elf_i386_dyn_relocs **)vpp;
+		}
+
+	      p = *head;
+	      if (p == NULL || p->sec != sec)
+		{
+		  bfd_size_type amt = sizeof *p;
+		  p = bfd_alloc (htab->elf.dynobj, amt);
+		  if (p == NULL)
+		    return FALSE;
+		  p->next = *head;
+		  *head = p;
+		  p->sec = sec;
+		  p->count = 0;
+		  p->pc_count = 0;
+		}
+
+	      p->count += 1;
+	      if (r_type == R_386_PC32)
+		p->pc_count += 1;
+	    }
+	  break;
+
+	  /* This relocation describes the C++ object vtable hierarchy.
+	     Reconstruct it for later use during GC.  */
+	case R_386_GNU_VTINHERIT:
+	  BFD_ASSERT (h != NULL);
+	  if (h != NULL
+	      && !bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
+	    return FALSE;
+	  break;
+
+	  /* This relocation describes which C++ vtable entries are actually
+	     used.  Record for later use during GC.  */
+	case R_386_GNU_VTENTRY:
+	  BFD_ASSERT (h != NULL);
+	  if (h != NULL
+	      && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_offset))
+	    return FALSE;
+	  break;
+
+	default:
+	  break;
+	}
+    }
+
+  return TRUE;
+}
+
+/* Return the section that should be marked against GC for a given
+   relocation.  */
+
+static asection *
+elf_i386_gc_mark_hook (asection *sec,
+		       struct bfd_link_info *info,
+		       Elf_Internal_Rela *rel,
+		       struct elf_link_hash_entry *h,
+		       Elf_Internal_Sym *sym)
+{
+  if (h != NULL)
+    switch (ELF32_R_TYPE (rel->r_info))
+      {
+      case R_386_GNU_VTINHERIT:
+      case R_386_GNU_VTENTRY:
+	return NULL;
+      }
+
+  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
+}
+
+/* Update the got entry reference counts for the section being removed.  */
+
+static bfd_boolean
+elf_i386_gc_sweep_hook (bfd *abfd,
+			struct bfd_link_info *info,
+			asection *sec,
+			const Elf_Internal_Rela *relocs)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  bfd_signed_vma *local_got_refcounts;
+  const Elf_Internal_Rela *rel, *relend;
+
+  elf_section_data (sec)->local_dynrel = NULL;
+
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (abfd);
+  local_got_refcounts = elf_local_got_refcounts (abfd);
+
+  relend = relocs + sec->reloc_count;
+  for (rel = relocs; rel < relend; rel++)
+    {
+      unsigned long r_symndx;
+      unsigned int r_type;
+      struct elf_link_hash_entry *h = NULL;
+
+      r_symndx = ELF32_R_SYM (rel->r_info);
+      if (r_symndx >= symtab_hdr->sh_info)
+	{
+	  struct elf_i386_link_hash_entry *eh;
+	  struct elf_i386_dyn_relocs **pp;
+	  struct elf_i386_dyn_relocs *p;
+
+	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+	  eh = (struct elf_i386_link_hash_entry *) h;
+
+	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
+	    if (p->sec == sec)
+	      {
+		/* Everything must go for SEC.  */
+		*pp = p->next;
+		break;
+	      }
+	}
+
+      r_type = ELF32_R_TYPE (rel->r_info);
+      r_type = elf_i386_tls_transition (info, r_type, h != NULL);
+      switch (r_type)
+	{
+	case R_386_TLS_LDM:
+	  if (elf_i386_hash_table (info)->tls_ldm_got.refcount > 0)
+	    elf_i386_hash_table (info)->tls_ldm_got.refcount -= 1;
+	  break;
+
+	case R_386_TLS_GD:
+	case R_386_TLS_GOTDESC:
+	case R_386_TLS_DESC_CALL:
+	case R_386_TLS_IE_32:
+	case R_386_TLS_IE:
+	case R_386_TLS_GOTIE:
+	case R_386_GOT32:
+	  if (h != NULL)
+	    {
+	      if (h->got.refcount > 0)
+		h->got.refcount -= 1;
+	    }
+	  else if (local_got_refcounts != NULL)
+	    {
+	      if (local_got_refcounts[r_symndx] > 0)
+		local_got_refcounts[r_symndx] -= 1;
+	    }
+	  break;
+
+	case R_386_32:
+	case R_386_PC32:
+	  if (info->shared)
+	    break;
+	  /* Fall through */
+
+	case R_386_PLT32:
+	  if (h != NULL)
+	    {
+	      if (h->plt.refcount > 0)
+		h->plt.refcount -= 1;
+	    }
+	  break;
+
+	default:
+	  break;
+	}
+    }
+
+  return TRUE;
+}
+
+/* Adjust a symbol defined by a dynamic object and referenced by a
+   regular object.  The current definition is in some section of the
+   dynamic object, but we're not including those sections.  We have to
+   change the definition to something the rest of the link can
+   understand.  */
+
+static bfd_boolean
+elf_i386_adjust_dynamic_symbol (struct bfd_link_info *info,
+				struct elf_link_hash_entry *h)
+{
+  struct elf_i386_link_hash_table *htab;
+  asection *s;
+
+  /* If this is a function, put it in the procedure linkage table.  We
+     will fill in the contents of the procedure linkage table later,
+     when we know the address of the .got section.  */
+  if (h->type == STT_FUNC
+      || h->needs_plt)
+    {
+      if (h->plt.refcount <= 0
+	  || SYMBOL_CALLS_LOCAL (info, h)
+	  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
+	      && h->root.type == bfd_link_hash_undefweak))
+	{
+	  /* This case can occur if we saw a PLT32 reloc in an input
+	     file, but the symbol was never referred to by a dynamic
+	     object, or if all references were garbage collected.  In
+	     such a case, we don't actually need to build a procedure
+	     linkage table, and we can just do a PC32 reloc instead.  */
+	  h->plt.offset = (bfd_vma) -1;
+	  h->needs_plt = 0;
+	}
+
+      return TRUE;
+    }
+  else
+    /* It's possible that we incorrectly decided a .plt reloc was
+       needed for an R_386_PC32 reloc to a non-function sym in
+       check_relocs.  We can't decide accurately between function and
+       non-function syms in check-relocs;  Objects loaded later in
+       the link may change h->type.  So fix it now.  */
+    h->plt.offset = (bfd_vma) -1;
+
+  /* If this is a weak symbol, and there is a real definition, the
+     processor independent code will have arranged for us to see the
+     real definition first, and we can just use the same value.  */
+  if (h->u.weakdef != NULL)
+    {
+      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
+		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
+      h->root.u.def.section = h->u.weakdef->root.u.def.section;
+      h->root.u.def.value = h->u.weakdef->root.u.def.value;
+      if (ELIMINATE_COPY_RELOCS || info->nocopyreloc)
+	h->non_got_ref = h->u.weakdef->non_got_ref;
+      return TRUE;
+    }
+
+  /* This is a reference to a symbol defined by a dynamic object which
+     is not a function.  */
+
+  /* If we are creating a shared library, we must presume that the
+     only references to the symbol are via the global offset table.
+     For such cases we need not do anything here; the relocations will
+     be handled correctly by relocate_section.  */
+  if (info->shared)
+    return TRUE;
+
+  /* If there are no references to this symbol that do not use the
+     GOT, we don't need to generate a copy reloc.  */
+  if (!h->non_got_ref)
+    return TRUE;
+
+  /* If -z nocopyreloc was given, we won't generate them either.  */
+  if (info->nocopyreloc)
+    {
+      h->non_got_ref = 0;
+      return TRUE;
+    }
+
+  htab = elf_i386_hash_table (info);
+
+  /* If there aren't any dynamic relocs in read-only sections, then
+     we can keep the dynamic relocs and avoid the copy reloc.  This
+     doesn't work on VxWorks, where we can not have dynamic relocations
+     (other than copy and jump slot relocations) in an executable.  */
+  if (ELIMINATE_COPY_RELOCS && !htab->is_vxworks)
+    {
+      struct elf_i386_link_hash_entry * eh;
+      struct elf_i386_dyn_relocs *p;
+
+      eh = (struct elf_i386_link_hash_entry *) h;
+      for (p = eh->dyn_relocs; p != NULL; p = p->next)
+	{
+	  s = p->sec->output_section;
+	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
+	    break;
+	}
+
+      if (p == NULL)
+	{
+	  h->non_got_ref = 0;
+	  return TRUE;
+	}
+    }
+
+  if (h->size == 0)
+    {
+      (*_bfd_error_handler) (_("dynamic variable `%s' is zero size"),
+			     h->root.root.string);
+      return TRUE;
+    }
+
+  /* We must allocate the symbol in our .dynbss section, which will
+     become part of the .bss section of the executable.  There will be
+     an entry for this symbol in the .dynsym section.  The dynamic
+     object will contain position independent code, so all references
+     from the dynamic object to this symbol will go through the global
+     offset table.  The dynamic linker will use the .dynsym entry to
+     determine the address it must put in the global offset table, so
+     both the dynamic object and the regular object will refer to the
+     same memory location for the variable.  */
+
+  /* We must generate a R_386_COPY reloc to tell the dynamic linker to
+     copy the initial value out of the dynamic object and into the
+     runtime process image.  */
+  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
+    {
+      htab->srelbss->size += sizeof (Elf32_External_Rel);
+      h->needs_copy = 1;
+    }
+
+  s = htab->sdynbss;
+
+  return _bfd_elf_adjust_dynamic_copy (h, s);
+}
+
+/* Allocate space in .plt, .got and associated reloc sections for
+   dynamic relocs.  */
+
+static bfd_boolean
+allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
+{
+  struct bfd_link_info *info;
+  struct elf_i386_link_hash_table *htab;
+  struct elf_i386_link_hash_entry *eh;
+  struct elf_i386_dyn_relocs *p;
+
+  if (h->root.type == bfd_link_hash_indirect)
+    return TRUE;
+
+  if (h->root.type == bfd_link_hash_warning)
+    /* When warning symbols are created, they **replace** the "real"
+       entry in the hash table, thus we never get to see the real
+       symbol in a hash traversal.  So look at it now.  */
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  info = (struct bfd_link_info *) inf;
+  htab = elf_i386_hash_table (info);
+
+  if (htab->elf.dynamic_sections_created
+      && h->plt.refcount > 0)
+    {
+      /* Make sure this symbol is output as a dynamic symbol.
+	 Undefined weak syms won't yet be marked as dynamic.  */
+      if (h->dynindx == -1
+	  && !h->forced_local)
+	{
+	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
+	    return FALSE;
+	}
+
+      if (info->shared
+	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
+	{
+	  asection *s = htab->splt;
+
+	  /* If this is the first .plt entry, make room for the special
+	     first entry.  */
+	  if (s->size == 0)
+	    s->size += PLT_ENTRY_SIZE;
+
+	  h->plt.offset = s->size;
+
+	  /* If this symbol is not defined in a regular file, and we are
+	     not generating a shared library, then set the symbol to this
+	     location in the .plt.  This is required to make function
+	     pointers compare as equal between the normal executable and
+	     the shared library.  */
+	  if (! info->shared
+	      && !h->def_regular)
+	    {
+	      h->root.u.def.section = s;
+	      h->root.u.def.value = h->plt.offset;
+	    }
+
+	  /* Make room for this entry.  */
+	  s->size += PLT_ENTRY_SIZE;
+
+	  /* We also need to make an entry in the .got.plt section, which
+	     will be placed in the .got section by the linker script.  */
+	  htab->sgotplt->size += 4;
+
+	  /* We also need to make an entry in the .rel.plt section.  */
+	  htab->srelplt->size += sizeof (Elf32_External_Rel);
+	  htab->next_tls_desc_index++;
+
+	  if (htab->is_vxworks && !info->shared)
+	    {
+	      /* VxWorks has a second set of relocations for each PLT entry
+		 in executables.  They go in a separate relocation section,
+		 which is processed by the kernel loader.  */
+
+	      /* There are two relocations for the initial PLT entry: an
+		 R_386_32 relocation for _GLOBAL_OFFSET_TABLE_ + 4 and an
+		 R_386_32 relocation for _GLOBAL_OFFSET_TABLE_ + 8.  */
+
+	      if (h->plt.offset == PLT_ENTRY_SIZE)
+		htab->srelplt2->size += (sizeof (Elf32_External_Rel) * 2);
+
+	      /* There are two extra relocations for each subsequent PLT entry:
+		 an R_386_32 relocation for the GOT entry, and an R_386_32
+		 relocation for the PLT entry.  */
+
+	      htab->srelplt2->size += (sizeof (Elf32_External_Rel) * 2);
+	    }
+	}
+      else
+	{
+	  h->plt.offset = (bfd_vma) -1;
+	  h->needs_plt = 0;
+	}
+    }
+  else
+    {
+      h->plt.offset = (bfd_vma) -1;
+      h->needs_plt = 0;
+    }
+
+  eh = (struct elf_i386_link_hash_entry *) h;
+  eh->tlsdesc_got = (bfd_vma) -1;
+
+  /* If R_386_TLS_{IE_32,IE,GOTIE} symbol is now local to the binary,
+     make it a R_386_TLS_LE_32 requiring no TLS entry.  */
+  if (h->got.refcount > 0
+      && !info->shared
+      && h->dynindx == -1
+      && (elf_i386_hash_entry(h)->tls_type & GOT_TLS_IE))
+    h->got.offset = (bfd_vma) -1;
+  else if (h->got.refcount > 0)
+    {
+      asection *s;
+      bfd_boolean dyn;
+      int tls_type = elf_i386_hash_entry(h)->tls_type;
+
+      /* Make sure this symbol is output as a dynamic symbol.
+	 Undefined weak syms won't yet be marked as dynamic.  */
+      if (h->dynindx == -1
+	  && !h->forced_local)
+	{
+	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
+	    return FALSE;
+	}
+
+      s = htab->sgot;
+      if (GOT_TLS_GDESC_P (tls_type))
+	{
+	  eh->tlsdesc_got = htab->sgotplt->size
+	    - elf_i386_compute_jump_table_size (htab);
+	  htab->sgotplt->size += 8;
+	  h->got.offset = (bfd_vma) -2;
+	}
+      if (! GOT_TLS_GDESC_P (tls_type)
+	  || GOT_TLS_GD_P (tls_type))
+	{
+	  h->got.offset = s->size;
+	  s->size += 4;
+	  /* R_386_TLS_GD needs 2 consecutive GOT slots.  */
+	  if (GOT_TLS_GD_P (tls_type) || tls_type == GOT_TLS_IE_BOTH)
+	    s->size += 4;
+	}
+      dyn = htab->elf.dynamic_sections_created;
+      /* R_386_TLS_IE_32 needs one dynamic relocation,
+	 R_386_TLS_IE resp. R_386_TLS_GOTIE needs one dynamic relocation,
+	 (but if both R_386_TLS_IE_32 and R_386_TLS_IE is present, we
+	 need two), R_386_TLS_GD needs one if local symbol and two if
+	 global.  */
+      if (tls_type == GOT_TLS_IE_BOTH)
+	htab->srelgot->size += 2 * sizeof (Elf32_External_Rel);
+      else if ((GOT_TLS_GD_P (tls_type) && h->dynindx == -1)
+	       || (tls_type & GOT_TLS_IE))
+	htab->srelgot->size += sizeof (Elf32_External_Rel);
+      else if (GOT_TLS_GD_P (tls_type))
+	htab->srelgot->size += 2 * sizeof (Elf32_External_Rel);
+      else if (! GOT_TLS_GDESC_P (tls_type)
+	       && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
+		   || h->root.type != bfd_link_hash_undefweak)
+	       && (info->shared
+		   || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
+	htab->srelgot->size += sizeof (Elf32_External_Rel);
+      if (GOT_TLS_GDESC_P (tls_type))
+	htab->srelplt->size += sizeof (Elf32_External_Rel);
+    }
+  else
+    h->got.offset = (bfd_vma) -1;
+
+  if (eh->dyn_relocs == NULL)
+    return TRUE;
+
+  /* In the shared -Bsymbolic case, discard space allocated for
+     dynamic pc-relative relocs against symbols which turn out to be
+     defined in regular objects.  For the normal shared case, discard
+     space for pc-relative relocs that have become local due to symbol
+     visibility changes.  */
+
+  if (info->shared)
+    {
+      /* The only reloc that uses pc_count is R_386_PC32, which will
+	 appear on a call or on something like ".long foo - .".  We
+	 want calls to protected symbols to resolve directly to the
+	 function rather than going via the plt.  If people want
+	 function pointer comparisons to work as expected then they
+	 should avoid writing assembly like ".long foo - .".  */
+      if (SYMBOL_CALLS_LOCAL (info, h))
+	{
+	  struct elf_i386_dyn_relocs **pp;
+
+	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
+	    {
+	      p->count -= p->pc_count;
+	      p->pc_count = 0;
+	      if (p->count == 0)
+		*pp = p->next;
+	      else
+		pp = &p->next;
+	    }
+	}
+
+      /* Also discard relocs on undefined weak syms with non-default
+	 visibility.  */
+      if (eh->dyn_relocs != NULL
+	  && h->root.type == bfd_link_hash_undefweak)
+	{
+	  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)
+	    eh->dyn_relocs = NULL;
+
+	  /* Make sure undefined weak symbols are output as a dynamic
+	     symbol in PIEs.  */
+	  else if (h->dynindx == -1
+		   && !h->forced_local)
+	    {
+	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
+		return FALSE;
+	    }
+	}
+    }
+  else if (ELIMINATE_COPY_RELOCS)
+    {
+      /* For the non-shared case, discard space for relocs against
+	 symbols which turn out to need copy relocs or are not
+	 dynamic.  */
+
+      if (!h->non_got_ref
+	  && ((h->def_dynamic
+	       && !h->def_regular)
+	      || (htab->elf.dynamic_sections_created
+		  && (h->root.type == bfd_link_hash_undefweak
+		      || h->root.type == bfd_link_hash_undefined))))
+	{
+	  /* Make sure this symbol is output as a dynamic symbol.
+	     Undefined weak syms won't yet be marked as dynamic.  */
+	  if (h->dynindx == -1
+	      && !h->forced_local)
+	    {
+	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
+		return FALSE;
+	    }
+
+	  /* If that succeeded, we know we'll be keeping all the
+	     relocs.  */
+	  if (h->dynindx != -1)
+	    goto keep;
+	}
+
+      eh->dyn_relocs = NULL;
+
+    keep: ;
+    }
+
+  /* Finally, allocate space.  */
+  for (p = eh->dyn_relocs; p != NULL; p = p->next)
+    {
+      asection *sreloc = elf_section_data (p->sec)->sreloc;
+      sreloc->size += p->count * sizeof (Elf32_External_Rel);
+    }
+
+  return TRUE;
+}
+
+/* Find any dynamic relocs that apply to read-only sections.  */
+
+static bfd_boolean
+readonly_dynrelocs (struct elf_link_hash_entry *h, void *inf)
+{
+  struct elf_i386_link_hash_entry *eh;
+  struct elf_i386_dyn_relocs *p;
+
+  if (h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  eh = (struct elf_i386_link_hash_entry *) h;
+  for (p = eh->dyn_relocs; p != NULL; p = p->next)
+    {
+      asection *s = p->sec->output_section;
+
+      if (s != NULL && (s->flags & SEC_READONLY) != 0)
+	{
+	  struct bfd_link_info *info = (struct bfd_link_info *) inf;
+
+	  info->flags |= DF_TEXTREL;
+
+	  /* Not an error, just cut short the traversal.  */
+	  return FALSE;
+	}
+    }
+  return TRUE;
+}
+
+/* Set the sizes of the dynamic sections.  */
+
+static bfd_boolean
+elf_i386_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
+				struct bfd_link_info *info)
+{
+  struct elf_i386_link_hash_table *htab;
+  bfd *dynobj;
+  asection *s;
+  bfd_boolean relocs;
+  bfd *ibfd;
+
+  htab = elf_i386_hash_table (info);
+  dynobj = htab->elf.dynobj;
+  if (dynobj == NULL)
+    abort ();
+
+  if (htab->elf.dynamic_sections_created)
+    {
+      /* Set the contents of the .interp section to the interpreter.  */
+      if (info->executable)
+	{
+	  s = bfd_get_section_by_name (dynobj, ".interp");
+	  if (s == NULL)
+	    abort ();
+	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
+	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
+	}
+    }
+
+  /* Set up .got offsets for local syms, and space for local dynamic
+     relocs.  */
+  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
+    {
+      bfd_signed_vma *local_got;
+      bfd_signed_vma *end_local_got;
+      char *local_tls_type;
+      bfd_vma *local_tlsdesc_gotent;
+      bfd_size_type locsymcount;
+      Elf_Internal_Shdr *symtab_hdr;
+      asection *srel;
+
+      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
+	continue;
+
+      for (s = ibfd->sections; s != NULL; s = s->next)
+	{
+	  struct elf_i386_dyn_relocs *p;
+
+	  for (p = ((struct elf_i386_dyn_relocs *)
+		     elf_section_data (s)->local_dynrel);
+	       p != NULL;
+	       p = p->next)
+	    {
+	      if (!bfd_is_abs_section (p->sec)
+		  && bfd_is_abs_section (p->sec->output_section))
+		{
+		  /* Input section has been discarded, either because
+		     it is a copy of a linkonce section or due to
+		     linker script /DISCARD/, so we'll be discarding
+		     the relocs too.  */
+		}
+	      else if (p->count != 0)
+		{
+		  srel = elf_section_data (p->sec)->sreloc;
+		  srel->size += p->count * sizeof (Elf32_External_Rel);
+		  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
+		    info->flags |= DF_TEXTREL;
+		}
+	    }
+	}
+
+      local_got = elf_local_got_refcounts (ibfd);
+      if (!local_got)
+	continue;
+
+      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
+      locsymcount = symtab_hdr->sh_info;
+      end_local_got = local_got + locsymcount;
+      local_tls_type = elf_i386_local_got_tls_type (ibfd);
+      local_tlsdesc_gotent = elf_i386_local_tlsdesc_gotent (ibfd);
+      s = htab->sgot;
+      srel = htab->srelgot;
+      for (; local_got < end_local_got;
+	   ++local_got, ++local_tls_type, ++local_tlsdesc_gotent)
+	{
+	  *local_tlsdesc_gotent = (bfd_vma) -1;
+	  if (*local_got > 0)
+	    {
+	      if (GOT_TLS_GDESC_P (*local_tls_type))
+		{
+		  *local_tlsdesc_gotent = htab->sgotplt->size
+		    - elf_i386_compute_jump_table_size (htab);
+		  htab->sgotplt->size += 8;
+		  *local_got = (bfd_vma) -2;
+		}
+	      if (! GOT_TLS_GDESC_P (*local_tls_type)
+		  || GOT_TLS_GD_P (*local_tls_type))
+		{
+		  *local_got = s->size;
+		  s->size += 4;
+		  if (GOT_TLS_GD_P (*local_tls_type)
+		      || *local_tls_type == GOT_TLS_IE_BOTH)
+		    s->size += 4;
+		}
+	      if (info->shared
+		  || GOT_TLS_GD_ANY_P (*local_tls_type)
+		  || (*local_tls_type & GOT_TLS_IE))
+		{
+		  if (*local_tls_type == GOT_TLS_IE_BOTH)
+		    srel->size += 2 * sizeof (Elf32_External_Rel);
+		  else if (GOT_TLS_GD_P (*local_tls_type)
+			   || ! GOT_TLS_GDESC_P (*local_tls_type))
+		    srel->size += sizeof (Elf32_External_Rel);
+		  if (GOT_TLS_GDESC_P (*local_tls_type))
+		    htab->srelplt->size += sizeof (Elf32_External_Rel);
+		}
+	    }
+	  else
+	    *local_got = (bfd_vma) -1;
+	}
+    }
+
+  if (htab->tls_ldm_got.refcount > 0)
+    {
+      /* Allocate 2 got entries and 1 dynamic reloc for R_386_TLS_LDM
+	 relocs.  */
+      htab->tls_ldm_got.offset = htab->sgot->size;
+      htab->sgot->size += 8;
+      htab->srelgot->size += sizeof (Elf32_External_Rel);
+    }
+  else
+    htab->tls_ldm_got.offset = -1;
+
+  /* Allocate global sym .plt and .got entries, and space for global
+     sym dynamic relocs.  */
+  elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, (PTR) info);
+
+  /* For every jump slot reserved in the sgotplt, reloc_count is
+     incremented.  However, when we reserve space for TLS descriptors,
+     it's not incremented, so in order to compute the space reserved
+     for them, it suffices to multiply the reloc count by the jump
+     slot size.  */
+  if (htab->srelplt)
+    htab->sgotplt_jump_table_size = htab->next_tls_desc_index * 4;
+
+  /* We now have determined the sizes of the various dynamic sections.
+     Allocate memory for them.  */
+  relocs = FALSE;
+  for (s = dynobj->sections; s != NULL; s = s->next)
+    {
+      bfd_boolean strip_section = TRUE;
+
+      if ((s->flags & SEC_LINKER_CREATED) == 0)
+	continue;
+
+      if (s == htab->splt
+	  || s == htab->sgot
+	  || s == htab->sgotplt
+	  || s == htab->sdynbss)
+	{
+	  /* Strip this section if we don't need it; see the
+	     comment below.  */
+	  /* We'd like to strip these sections if they aren't needed, but if
+	     we've exported dynamic symbols from them we must leave them.
+	     It's too late to tell BFD to get rid of the symbols.  */
+
+	  if (htab->elf.hplt != NULL)
+	    strip_section = FALSE;
+	}
+      else if (CONST_STRNEQ (bfd_get_section_name (dynobj, s), ".rel"))
+	{
+	  if (s->size != 0 && s != htab->srelplt && s != htab->srelplt2)
+	    relocs = TRUE;
+
+	  /* We use the reloc_count field as a counter if we need
+	     to copy relocs into the output file.  */
+	  s->reloc_count = 0;
+	}
+      else
+	{
+	  /* It's not one of our sections, so don't allocate space.  */
+	  continue;
+	}
+
+      if (s->size == 0)
+	{
+	  /* If we don't need this section, strip it from the
+	     output file.  This is mostly to handle .rel.bss and
+	     .rel.plt.  We must create both sections in
+	     create_dynamic_sections, because they must be created
+	     before the linker maps input sections to output
+	     sections.  The linker does that before
+	     adjust_dynamic_symbol is called, and it is that
+	     function which decides whether anything needs to go
+	     into these sections.  */
+	  if (strip_section)
+	    s->flags |= SEC_EXCLUDE;
+	  continue;
+	}
+
+      if ((s->flags & SEC_HAS_CONTENTS) == 0)
+	continue;
+
+      /* Allocate memory for the section contents.  We use bfd_zalloc
+	 here in case unused entries are not reclaimed before the
+	 section's contents are written out.  This should not happen,
+	 but this way if it does, we get a R_386_NONE reloc instead
+	 of garbage.  */
+      s->contents = bfd_zalloc (dynobj, s->size);
+      if (s->contents == NULL)
+	return FALSE;
+    }
+
+  if (htab->elf.dynamic_sections_created)
+    {
+      /* Add some entries to the .dynamic section.  We fill in the
+	 values later, in elf_i386_finish_dynamic_sections, but we
+	 must add the entries now so that we get the correct size for
+	 the .dynamic section.  The DT_DEBUG entry is filled in by the
+	 dynamic linker and used by the debugger.  */
+#define add_dynamic_entry(TAG, VAL) \
+  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
+
+      if (info->executable)
+	{
+	  if (!add_dynamic_entry (DT_DEBUG, 0))
+	    return FALSE;
+	}
+
+      if (htab->splt->size != 0)
+	{
+	  if (!add_dynamic_entry (DT_PLTGOT, 0)
+	      || !add_dynamic_entry (DT_PLTRELSZ, 0)
+	      || !add_dynamic_entry (DT_PLTREL, DT_REL)
+	      || !add_dynamic_entry (DT_JMPREL, 0))
+	    return FALSE;
+	}
+
+      if (relocs)
+	{
+	  if (!add_dynamic_entry (DT_REL, 0)
+	      || !add_dynamic_entry (DT_RELSZ, 0)
+	      || !add_dynamic_entry (DT_RELENT, sizeof (Elf32_External_Rel)))
+	    return FALSE;
+
+	  /* If any dynamic relocs apply to a read-only section,
+	     then we need a DT_TEXTREL entry.  */
+	  if ((info->flags & DF_TEXTREL) == 0)
+	    elf_link_hash_traverse (&htab->elf, readonly_dynrelocs,
+				    (PTR) info);
+
+	  if ((info->flags & DF_TEXTREL) != 0)
+	    {
+	      if (!add_dynamic_entry (DT_TEXTREL, 0))
+		return FALSE;
+	    }
+	}
+    }
+#undef add_dynamic_entry
+
+  return TRUE;
+}
+
+static bfd_boolean
+elf_i386_always_size_sections (bfd *output_bfd,
+			       struct bfd_link_info *info)
+{
+  asection *tls_sec = elf_hash_table (info)->tls_sec;
+
+  if (tls_sec)
+    {
+      struct elf_link_hash_entry *tlsbase;
+
+      tlsbase = elf_link_hash_lookup (elf_hash_table (info),
+				      "_TLS_MODULE_BASE_",
+				      FALSE, FALSE, FALSE);
+
+      if (tlsbase && tlsbase->type == STT_TLS)
+	{
+	  struct bfd_link_hash_entry *bh = NULL;
+	  const struct elf_backend_data *bed
+	    = get_elf_backend_data (output_bfd);
+
+	  if (!(_bfd_generic_link_add_one_symbol
+		(info, output_bfd, "_TLS_MODULE_BASE_", BSF_LOCAL,
+		 tls_sec, 0, NULL, FALSE,
+		 bed->collect, &bh)))
+	    return FALSE;
+	  tlsbase = (struct elf_link_hash_entry *)bh;
+	  tlsbase->def_regular = 1;
+	  tlsbase->other = STV_HIDDEN;
+	  (*bed->elf_backend_hide_symbol) (info, tlsbase, TRUE);
+	}
+    }
+
+  return TRUE;
+}
+
+/* Set the correct type for an x86 ELF section.  We do this by the
+   section name, which is a hack, but ought to work.  */
+
+static bfd_boolean
+elf_i386_fake_sections (bfd *abfd ATTRIBUTE_UNUSED,
+			Elf_Internal_Shdr *hdr,
+			asection *sec)
+{
+  register const char *name;
+
+  name = bfd_get_section_name (abfd, sec);
+
+  /* This is an ugly, but unfortunately necessary hack that is
+     needed when producing EFI binaries on x86. It tells
+     elf.c:elf_fake_sections() not to consider ".reloc" as a section
+     containing ELF relocation info.  We need this hack in order to
+     be able to generate ELF binaries that can be translated into
+     EFI applications (which are essentially COFF objects).  Those
+     files contain a COFF ".reloc" section inside an ELFNN object,
+     which would normally cause BFD to segfault because it would
+     attempt to interpret this section as containing relocation
+     entries for section "oc".  With this hack enabled, ".reloc"
+     will be treated as a normal data section, which will avoid the
+     segfault.  However, you won't be able to create an ELFNN binary
+     with a section named "oc" that needs relocations, but that's
+     the kind of ugly side-effects you get when detecting section
+     types based on their names...  In practice, this limitation is
+     unlikely to bite.  */
+  if (strcmp (name, ".reloc") == 0)
+    hdr->sh_type = SHT_PROGBITS;
+
+  return TRUE;
+}
+
+/* Return the base VMA address which should be subtracted from real addresses
+   when resolving @dtpoff relocation.
+   This is PT_TLS segment p_vaddr.  */
+
+static bfd_vma
+dtpoff_base (struct bfd_link_info *info)
+{
+  /* If tls_sec is NULL, we should have signalled an error already.  */
+  if (elf_hash_table (info)->tls_sec == NULL)
+    return 0;
+  return elf_hash_table (info)->tls_sec->vma;
+}
+
+/* Return the relocation value for @tpoff relocation
+   if STT_TLS virtual address is ADDRESS.  */
+
+static bfd_vma
+tpoff (struct bfd_link_info *info, bfd_vma address)
+{
+  struct elf_link_hash_table *htab = elf_hash_table (info);
+
+  /* If tls_sec is NULL, we should have signalled an error already.  */
+  if (htab->tls_sec == NULL)
+    return 0;
+  return htab->tls_size + htab->tls_sec->vma - address;
+}
+
+/* Relocate an i386 ELF section.  */
+
+static bfd_boolean
+elf_i386_relocate_section (bfd *output_bfd,
+			   struct bfd_link_info *info,
+			   bfd *input_bfd,
+			   asection *input_section,
+			   bfd_byte *contents,
+			   Elf_Internal_Rela *relocs,
+			   Elf_Internal_Sym *local_syms,
+			   asection **local_sections)
+{
+  struct elf_i386_link_hash_table *htab;
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  bfd_vma *local_got_offsets;
+  bfd_vma *local_tlsdesc_gotents;
+  Elf_Internal_Rela *rel;
+  Elf_Internal_Rela *relend;
+
+  htab = elf_i386_hash_table (info);
+  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (input_bfd);
+  local_got_offsets = elf_local_got_offsets (input_bfd);
+  local_tlsdesc_gotents = elf_i386_local_tlsdesc_gotent (input_bfd);
+
+  rel = relocs;
+  relend = relocs + input_section->reloc_count;
+  for (; rel < relend; rel++)
+    {
+      unsigned int r_type;
+      reloc_howto_type *howto;
+      unsigned long r_symndx;
+      struct elf_link_hash_entry *h;
+      Elf_Internal_Sym *sym;
+      asection *sec;
+      bfd_vma off, offplt;
+      bfd_vma relocation;
+      bfd_boolean unresolved_reloc;
+      bfd_reloc_status_type r;
+      unsigned int indx;
+      int tls_type;
+
+      r_type = ELF32_R_TYPE (rel->r_info);
+      if (r_type == R_386_GNU_VTINHERIT
+	  || r_type == R_386_GNU_VTENTRY)
+	continue;
+
+      if ((indx = r_type) >= R_386_standard
+	  && ((indx = r_type - R_386_ext_offset) - R_386_standard
+	      >= R_386_ext - R_386_standard)
+	  && ((indx = r_type - R_386_tls_offset) - R_386_ext
+	      >= R_386_tls - R_386_ext))
+	{
+	  (*_bfd_error_handler)
+	    (_("%B: unrecognized relocation (0x%x) in section `%A'"),
+	     input_bfd, input_section, r_type);
+	  bfd_set_error (bfd_error_bad_value);
+	  return FALSE;
+	}
+      howto = elf_howto_table + indx;
+
+      r_symndx = ELF32_R_SYM (rel->r_info);
+      h = NULL;
+      sym = NULL;
+      sec = NULL;
+      unresolved_reloc = FALSE;
+      if (r_symndx < symtab_hdr->sh_info)
+	{
+	  sym = local_syms + r_symndx;
+	  sec = local_sections[r_symndx];
+	  relocation = (sec->output_section->vma
+			+ sec->output_offset
+			+ sym->st_value);
+
+	  if (ELF_ST_TYPE (sym->st_info) == STT_SECTION
+	      && ((sec->flags & SEC_MERGE) != 0
+		  || (info->relocatable
+		      && sec->output_offset != 0)))
+	    {
+	      bfd_vma addend;
+	      bfd_byte *where = contents + rel->r_offset;
+
+	      switch (howto->size)
+		{
+		case 0:
+		  addend = bfd_get_8 (input_bfd, where);
+		  if (howto->pc_relative)
+		    {
+		      addend = (addend ^ 0x80) - 0x80;
+		      addend += 1;
+		    }
+		  break;
+		case 1:
+		  addend = bfd_get_16 (input_bfd, where);
+		  if (howto->pc_relative)
+		    {
+		      addend = (addend ^ 0x8000) - 0x8000;
+		      addend += 2;
+		    }
+		  break;
+		case 2:
+		  addend = bfd_get_32 (input_bfd, where);
+		  if (howto->pc_relative)
+		    {
+		      addend = (addend ^ 0x80000000) - 0x80000000;
+		      addend += 4;
+		    }
+		  break;
+		default:
+		  abort ();
+		}
+
+	      if (info->relocatable)
+		addend += sec->output_offset;
+	      else
+		{
+		  asection *msec = sec;
+		  addend = _bfd_elf_rel_local_sym (output_bfd, sym, &msec,
+						   addend);
+		  addend -= relocation;
+		  addend += msec->output_section->vma + msec->output_offset;
+		}
+
+	      switch (howto->size)
+		{
+		case 0:
+		  /* FIXME: overflow checks.  */
+		  if (howto->pc_relative)
+		    addend -= 1;
+		  bfd_put_8 (input_bfd, addend, where);
+		  break;
+		case 1:
+		  if (howto->pc_relative)
+		    addend -= 2;
+		  bfd_put_16 (input_bfd, addend, where);
+		  break;
+		case 2:
+		  if (howto->pc_relative)
+		    addend -= 4;
+		  bfd_put_32 (input_bfd, addend, where);
+		  break;
+		}
+	    }
+	}
+      else
+	{
+	  bfd_boolean warned;
+
+	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
+				   r_symndx, symtab_hdr, sym_hashes,
+				   h, sec, relocation,
+				   unresolved_reloc, warned);
+	}
+
+      if (sec != NULL && elf_discarded_section (sec))
+	{
+	  /* For relocs against symbols from removed linkonce sections,
+	     or sections discarded by a linker script, we just want the
+	     section contents zeroed.  Avoid any special processing.  */
+	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
+	  rel->r_info = 0;
+	  rel->r_addend = 0;
+	  continue;
+	}
+
+      if (info->relocatable)
+	continue;
+
+      switch (r_type)
+	{
+	case R_386_GOT32:
+	  /* Relocation is to the entry for this symbol in the global
+	     offset table.  */
+	  if (htab->sgot == NULL)
+	    abort ();
+
+	  if (h != NULL)
+	    {
+	      bfd_boolean dyn;
+
+	      off = h->got.offset;
+	      dyn = htab->elf.dynamic_sections_created;
+	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
+		  || (info->shared
+		      && SYMBOL_REFERENCES_LOCAL (info, h))
+		  || (ELF_ST_VISIBILITY (h->other)
+		      && h->root.type == bfd_link_hash_undefweak))
+		{
+		  /* This is actually a static link, or it is a
+		     -Bsymbolic link and the symbol is defined
+		     locally, or the symbol was forced to be local
+		     because of a version file.  We must initialize
+		     this entry in the global offset table.  Since the
+		     offset must always be a multiple of 4, we use the
+		     least significant bit to record whether we have
+		     initialized it already.
+
+		     When doing a dynamic link, we create a .rel.got
+		     relocation entry to initialize the value.  This
+		     is done in the finish_dynamic_symbol routine.  */
+		  if ((off & 1) != 0)
+		    off &= ~1;
+		  else
+		    {
+		      bfd_put_32 (output_bfd, relocation,
+				  htab->sgot->contents + off);
+		      h->got.offset |= 1;
+		    }
+		}
+	      else
+		unresolved_reloc = FALSE;
+	    }
+	  else
+	    {
+	      if (local_got_offsets == NULL)
+		abort ();
+
+	      off = local_got_offsets[r_symndx];
+
+	      /* The offset must always be a multiple of 4.  We use
+		 the least significant bit to record whether we have
+		 already generated the necessary reloc.  */
+	      if ((off & 1) != 0)
+		off &= ~1;
+	      else
+		{
+		  bfd_put_32 (output_bfd, relocation,
+			      htab->sgot->contents + off);
+
+		  if (info->shared)
+		    {
+		      asection *s;
+		      Elf_Internal_Rela outrel;
+		      bfd_byte *loc;
+
+		      s = htab->srelgot;
+		      if (s == NULL)
+			abort ();
+
+		      outrel.r_offset = (htab->sgot->output_section->vma
+					 + htab->sgot->output_offset
+					 + off);
+		      outrel.r_info = ELF32_R_INFO (0, R_386_RELATIVE);
+		      loc = s->contents;
+		      loc += s->reloc_count++ * sizeof (Elf32_External_Rel);
+		      bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
+		    }
+
+		  local_got_offsets[r_symndx] |= 1;
+		}
+	    }
+
+	  if (off >= (bfd_vma) -2)
+	    abort ();
+
+	  relocation = htab->sgot->output_section->vma
+		       + htab->sgot->output_offset + off
+		       - htab->sgotplt->output_section->vma
+		       - htab->sgotplt->output_offset;
+	  break;
+
+	case R_386_GOTOFF:
+	  /* Relocation is relative to the start of the global offset
+	     table.  */
+
+	  /* Check to make sure it isn't a protected function symbol
+	     for shared library since it may not be local when used
+	     as function address.  */
+	  if (info->shared
+	      && !info->executable
+	      && h
+	      && h->def_regular
+	      && h->type == STT_FUNC
+	      && ELF_ST_VISIBILITY (h->other) == STV_PROTECTED)
+	    {
+	      (*_bfd_error_handler)
+		(_("%B: relocation R_386_GOTOFF against protected function `%s' can not be used when making a shared object"),
+		 input_bfd, h->root.root.string);
+	      bfd_set_error (bfd_error_bad_value);
+	      return FALSE;
+	    }
+
+	  /* Note that sgot is not involved in this
+	     calculation.  We always want the start of .got.plt.  If we
+	     defined _GLOBAL_OFFSET_TABLE_ in a different way, as is
+	     permitted by the ABI, we might have to change this
+	     calculation.  */
+	  relocation -= htab->sgotplt->output_section->vma
+			+ htab->sgotplt->output_offset;
+	  break;
+
+	case R_386_GOTPC:
+	  /* Use global offset table as symbol value.  */
+	  relocation = htab->sgotplt->output_section->vma
+		       + htab->sgotplt->output_offset;
+	  unresolved_reloc = FALSE;
+	  break;
+
+	case R_386_PLT32:
+	  /* Relocation is to the entry for this symbol in the
+	     procedure linkage table.  */
+
+	  /* Resolve a PLT32 reloc against a local symbol directly,
+	     without using the procedure linkage table.  */
+	  if (h == NULL)
+	    break;
+
+	  if (h->plt.offset == (bfd_vma) -1
+	      || htab->splt == NULL)
+	    {
+	      /* We didn't make a PLT entry for this symbol.  This
+		 happens when statically linking PIC code, or when
+		 using -Bsymbolic.  */
+	      break;
+	    }
+
+	  relocation = (htab->splt->output_section->vma
+			+ htab->splt->output_offset
+			+ h->plt.offset);
+	  unresolved_reloc = FALSE;
+	  break;
+
+	case R_386_32:
+	case R_386_PC32:
+	  if ((input_section->flags & SEC_ALLOC) == 0)
+	    break;
+
+	  if ((info->shared
+	       && (h == NULL
+		   || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
+		   || h->root.type != bfd_link_hash_undefweak)
+	       && (r_type != R_386_PC32
+		   || !SYMBOL_CALLS_LOCAL (info, h)))
+	      || (ELIMINATE_COPY_RELOCS
+		  && !info->shared
+		  && h != NULL
+		  && h->dynindx != -1
+		  && !h->non_got_ref
+		  && ((h->def_dynamic
+		       && !h->def_regular)
+		      || h->root.type == bfd_link_hash_undefweak
+		      || h->root.type == bfd_link_hash_undefined)))
+	    {
+	      Elf_Internal_Rela outrel;
+	      bfd_byte *loc;
+	      bfd_boolean skip, relocate;
+	      asection *sreloc;
+
+	      /* When generating a shared object, these relocations
+		 are copied into the output file to be resolved at run
+		 time.  */
+
+	      skip = FALSE;
+	      relocate = FALSE;
+
+	      outrel.r_offset =
+		_bfd_elf_section_offset (output_bfd, info, input_section,
+					 rel->r_offset);
+	      if (outrel.r_offset == (bfd_vma) -1)
+		skip = TRUE;
+	      else if (outrel.r_offset == (bfd_vma) -2)
+		skip = TRUE, relocate = TRUE;
+	      outrel.r_offset += (input_section->output_section->vma
+				  + input_section->output_offset);
+
+	      if (skip)
+		memset (&outrel, 0, sizeof outrel);
+	      else if (h != NULL
+		       && h->dynindx != -1
+		       && (r_type == R_386_PC32
+			   || !info->shared
+			   || !SYMBOLIC_BIND (info, h)
+			   || !h->def_regular))
+		outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
+	      else
+		{
+		  /* This symbol is local, or marked to become local.  */
+		  relocate = TRUE;
+		  outrel.r_info = ELF32_R_INFO (0, R_386_RELATIVE);
+		}
+
+	      sreloc = elf_section_data (input_section)->sreloc;
+	      if (sreloc == NULL)
+		abort ();
+
+	      loc = sreloc->contents;
+	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rel);
+	      bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
+
+	      /* If this reloc is against an external symbol, we do
+		 not want to fiddle with the addend.  Otherwise, we
+		 need to include the symbol value so that it becomes
+		 an addend for the dynamic reloc.  */
+	      if (! relocate)
+		continue;
+	    }
+	  break;
+
+	case R_386_TLS_IE:
+	  if (info->shared)
+	    {
+	      Elf_Internal_Rela outrel;
+	      bfd_byte *loc;
+	      asection *sreloc;
+
+	      outrel.r_offset = rel->r_offset
+				+ input_section->output_section->vma
+				+ input_section->output_offset;
+	      outrel.r_info = ELF32_R_INFO (0, R_386_RELATIVE);
+	      sreloc = elf_section_data (input_section)->sreloc;
+	      if (sreloc == NULL)
+		abort ();
+	      loc = sreloc->contents;
+	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rel);
+	      bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
+	    }
+	  /* Fall through */
+
+	case R_386_TLS_GD:
+	case R_386_TLS_GOTDESC:
+	case R_386_TLS_DESC_CALL:
+	case R_386_TLS_IE_32:
+	case R_386_TLS_GOTIE:
+	  r_type = elf_i386_tls_transition (info, r_type, h == NULL);
+	  tls_type = GOT_UNKNOWN;
+	  if (h == NULL && local_got_offsets)
+	    tls_type = elf_i386_local_got_tls_type (input_bfd) [r_symndx];
+	  else if (h != NULL)
+	    {
+	      tls_type = elf_i386_hash_entry(h)->tls_type;
+	      if (!info->shared && h->dynindx == -1 && (tls_type & GOT_TLS_IE))
+		r_type = R_386_TLS_LE_32;
+	    }
+	  if (tls_type == GOT_TLS_IE)
+	    tls_type = GOT_TLS_IE_NEG;
+	  if (r_type == R_386_TLS_GD
+	      || r_type == R_386_TLS_GOTDESC
+	      || r_type == R_386_TLS_DESC_CALL)
+	    {
+	      if (tls_type == GOT_TLS_IE_POS)
+		r_type = R_386_TLS_GOTIE;
+	      else if (tls_type & GOT_TLS_IE)
+		r_type = R_386_TLS_IE_32;
+	    }
+
+	  if (r_type == R_386_TLS_LE_32)
+	    {
+	      BFD_ASSERT (! unresolved_reloc);
+	      if (ELF32_R_TYPE (rel->r_info) == R_386_TLS_GD)
+		{
+		  unsigned int val, type;
+		  bfd_vma roff;
+
+		  /* GD->LE transition.  */
+		  BFD_ASSERT (rel->r_offset >= 2);
+		  type = bfd_get_8 (input_bfd, contents + rel->r_offset - 2);
+		  BFD_ASSERT (type == 0x8d || type == 0x04);
+		  BFD_ASSERT (rel->r_offset + 9 <= input_section->size);
+		  BFD_ASSERT (bfd_get_8 (input_bfd,
+					 contents + rel->r_offset + 4)
+			      == 0xe8);
+		  BFD_ASSERT (rel + 1 < relend);
+		  BFD_ASSERT (ELF32_R_TYPE (rel[1].r_info) == R_386_PLT32);
+		  roff = rel->r_offset + 5;
+		  val = bfd_get_8 (input_bfd,
+				   contents + rel->r_offset - 1);
+		  if (type == 0x04)
+		    {
+		      /* leal foo(,%reg,1), %eax; call ___tls_get_addr
+			 Change it into:
+			 movl %gs:0, %eax; subl $foo@tpoff, %eax
+			 (6 byte form of subl).  */
+		      BFD_ASSERT (rel->r_offset >= 3);
+		      BFD_ASSERT (bfd_get_8 (input_bfd,
+					     contents + rel->r_offset - 3)
+				  == 0x8d);
+		      BFD_ASSERT ((val & 0xc7) == 0x05 && val != (4 << 3));
+		      memcpy (contents + rel->r_offset - 3,
+			      "\x65\xa1\0\0\0\0\x81\xe8\0\0\0", 12);
+		    }
+		  else
+		    {
+		      BFD_ASSERT ((val & 0xf8) == 0x80 && (val & 7) != 4);
+		      if (rel->r_offset + 10 <= input_section->size
+			  && bfd_get_8 (input_bfd,
+					contents + rel->r_offset + 9) == 0x90)
+			{
+			  /* leal foo(%reg), %eax; call ___tls_get_addr; nop
+			     Change it into:
+			     movl %gs:0, %eax; subl $foo@tpoff, %eax
+			     (6 byte form of subl).  */
+			  memcpy (contents + rel->r_offset - 2,
+				  "\x65\xa1\0\0\0\0\x81\xe8\0\0\0", 12);
+			  roff = rel->r_offset + 6;
+			}
+		      else
+			{
+			  /* leal foo(%reg), %eax; call ___tls_get_addr
+			     Change it into:
+			     movl %gs:0, %eax; subl $foo@tpoff, %eax
+			     (5 byte form of subl).  */
+			  memcpy (contents + rel->r_offset - 2,
+				  "\x65\xa1\0\0\0\0\x2d\0\0\0", 11);
+			}
+		    }
+		  bfd_put_32 (output_bfd, tpoff (info, relocation),
+			      contents + roff);
+		  /* Skip R_386_PLT32.  */
+		  rel++;
+		  continue;
+		}
+	      else if (ELF32_R_TYPE (rel->r_info) == R_386_TLS_GOTDESC)
+		{
+		  /* GDesc -> LE transition.
+		     It's originally something like:
+		     leal x@tlsdesc(%ebx), %eax
+
+		     leal x@ntpoff, %eax
+
+		     Registers other than %eax may be set up here.  */
+
+		  unsigned int val, type;
+		  bfd_vma roff;
+
+		  /* First, make sure it's a leal adding ebx to a
+		     32-bit offset into any register, although it's
+		     probably almost always going to be eax.  */
+		  roff = rel->r_offset;
+		  BFD_ASSERT (roff >= 2);
+		  type = bfd_get_8 (input_bfd, contents + roff - 2);
+		  BFD_ASSERT (type == 0x8d);
+		  val = bfd_get_8 (input_bfd, contents + roff - 1);
+		  BFD_ASSERT ((val & 0xc7) == 0x83);
+		  BFD_ASSERT (roff + 4 <= input_section->size);
+
+		  /* Now modify the instruction as appropriate.  */
+		  /* aoliva FIXME: remove the above and xor the byte
+		     below with 0x86.  */
+		  bfd_put_8 (output_bfd, val ^ 0x86,
+			     contents + roff - 1);
+		  bfd_put_32 (output_bfd, -tpoff (info, relocation),
+			      contents + roff);
+		  continue;
+		}
+	      else if (ELF32_R_TYPE (rel->r_info) == R_386_TLS_DESC_CALL)
+		{
+		  /* GDesc -> LE transition.
+		     It's originally:
+		     call *(%eax)
+		     Turn it into:
+		     nop; nop  */
+
+		  unsigned int val, type;
+		  bfd_vma roff;
+
+		  /* First, make sure it's a call *(%eax).  */
+		  roff = rel->r_offset;
+		  BFD_ASSERT (roff + 2 <= input_section->size);
+		  type = bfd_get_8 (input_bfd, contents + roff);
+		  BFD_ASSERT (type == 0xff);
+		  val = bfd_get_8 (input_bfd, contents + roff + 1);
+		  BFD_ASSERT (val == 0x10);
+
+		  /* Now modify the instruction as appropriate.  Use
+		     xchg %ax,%ax instead of 2 nops.  */
+		  bfd_put_8 (output_bfd, 0x66, contents + roff);
+		  bfd_put_8 (output_bfd, 0x90, contents + roff + 1);
+		  continue;
+		}
+	      else if (ELF32_R_TYPE (rel->r_info) == R_386_TLS_IE)
+		{
+		  unsigned int val, type;
+
+		  /* IE->LE transition:
+		     Originally it can be one of:
+		     movl foo, %eax
+		     movl foo, %reg
+		     addl foo, %reg
+		     We change it into:
+		     movl $foo, %eax
+		     movl $foo, %reg
+		     addl $foo, %reg.  */
+		  BFD_ASSERT (rel->r_offset >= 1);
+		  val = bfd_get_8 (input_bfd, contents + rel->r_offset - 1);
+		  BFD_ASSERT (rel->r_offset + 4 <= input_section->size);
+		  if (val == 0xa1)
+		    {
+		      /* movl foo, %eax.  */
+		      bfd_put_8 (output_bfd, 0xb8,
+				 contents + rel->r_offset - 1);
+		    }
+		  else
+		    {
+		      BFD_ASSERT (rel->r_offset >= 2);
+		      type = bfd_get_8 (input_bfd,
+					contents + rel->r_offset - 2);
+		      switch (type)
+			{
+			case 0x8b:
+			  /* movl */
+			  BFD_ASSERT ((val & 0xc7) == 0x05);
+			  bfd_put_8 (output_bfd, 0xc7,
+				     contents + rel->r_offset - 2);
+			  bfd_put_8 (output_bfd,
+				     0xc0 | ((val >> 3) & 7),
+				     contents + rel->r_offset - 1);
+			  break;
+			case 0x03:
+			  /* addl */
+			  BFD_ASSERT ((val & 0xc7) == 0x05);
+			  bfd_put_8 (output_bfd, 0x81,
+				     contents + rel->r_offset - 2);
+			  bfd_put_8 (output_bfd,
+				     0xc0 | ((val >> 3) & 7),
+				     contents + rel->r_offset - 1);
+			  break;
+			default:
+			  BFD_FAIL ();
+			  break;
+			}
+		    }
+		  bfd_put_32 (output_bfd, -tpoff (info, relocation),
+			      contents + rel->r_offset);
+		  continue;
+		}
+	      else
+		{
+		  unsigned int val, type;
+
+		  /* {IE_32,GOTIE}->LE transition:
+		     Originally it can be one of:
+		     subl foo(%reg1), %reg2
+		     movl foo(%reg1), %reg2
+		     addl foo(%reg1), %reg2
+		     We change it into:
+		     subl $foo, %reg2
+		     movl $foo, %reg2 (6 byte form)
+		     addl $foo, %reg2.  */
+		  BFD_ASSERT (rel->r_offset >= 2);
+		  type = bfd_get_8 (input_bfd, contents + rel->r_offset - 2);
+		  val = bfd_get_8 (input_bfd, contents + rel->r_offset - 1);
+		  BFD_ASSERT (rel->r_offset + 4 <= input_section->size);
+		  BFD_ASSERT ((val & 0xc0) == 0x80 && (val & 7) != 4);
+		  if (type == 0x8b)
+		    {
+		      /* movl */
+		      bfd_put_8 (output_bfd, 0xc7,
+				 contents + rel->r_offset - 2);
+		      bfd_put_8 (output_bfd, 0xc0 | ((val >> 3) & 7),
+				 contents + rel->r_offset - 1);
+		    }
+		  else if (type == 0x2b)
+		    {
+		      /* subl */
+		      bfd_put_8 (output_bfd, 0x81,
+				 contents + rel->r_offset - 2);
+		      bfd_put_8 (output_bfd, 0xe8 | ((val >> 3) & 7),
+				 contents + rel->r_offset - 1);
+		    }
+		  else if (type == 0x03)
+		    {
+		      /* addl */
+		      bfd_put_8 (output_bfd, 0x81,
+				 contents + rel->r_offset - 2);
+		      bfd_put_8 (output_bfd, 0xc0 | ((val >> 3) & 7),
+				 contents + rel->r_offset - 1);
+		    }
+		  else
+		    BFD_FAIL ();
+		  if (ELF32_R_TYPE (rel->r_info) == R_386_TLS_GOTIE)
+		    bfd_put_32 (output_bfd, -tpoff (info, relocation),
+				contents + rel->r_offset);
+		  else
+		    bfd_put_32 (output_bfd, tpoff (info, relocation),
+				contents + rel->r_offset);
+		  continue;
+		}
+	    }
+
+	  if (htab->sgot == NULL)
+	    abort ();
+
+	  if (h != NULL)
+	    {
+	      off = h->got.offset;
+	      offplt = elf_i386_hash_entry (h)->tlsdesc_got;
+	    }
+	  else
+	    {
+	      if (local_got_offsets == NULL)
+		abort ();
+
+	      off = local_got_offsets[r_symndx];
+	      offplt = local_tlsdesc_gotents[r_symndx];
+	    }
+
+	  if ((off & 1) != 0)
+	    off &= ~1;
+	  else
+	    {
+	      Elf_Internal_Rela outrel;
+	      bfd_byte *loc;
+	      int dr_type, indx;
+	      asection *sreloc;
+
+	      if (htab->srelgot == NULL)
+		abort ();
+
+	      indx = h && h->dynindx != -1 ? h->dynindx : 0;
+
+	      if (GOT_TLS_GDESC_P (tls_type))
+		{
+		  outrel.r_info = ELF32_R_INFO (indx, R_386_TLS_DESC);
+		  BFD_ASSERT (htab->sgotplt_jump_table_size + offplt + 8
+			      <= htab->sgotplt->size);
+		  outrel.r_offset = (htab->sgotplt->output_section->vma
+				     + htab->sgotplt->output_offset
+				     + offplt
+				     + htab->sgotplt_jump_table_size);
+		  sreloc = htab->srelplt;
+		  loc = sreloc->contents;
+		  loc += (htab->next_tls_desc_index++
+			  * sizeof (Elf32_External_Rel));
+		  BFD_ASSERT (loc + sizeof (Elf32_External_Rel)
+			      <= sreloc->contents + sreloc->size);
+		  bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
+		  if (indx == 0)
+		    {
+		      BFD_ASSERT (! unresolved_reloc);
+		      bfd_put_32 (output_bfd,
+				  relocation - dtpoff_base (info),
+				  htab->sgotplt->contents + offplt
+				  + htab->sgotplt_jump_table_size + 4);
+		    }
+		  else
+		    {
+		      bfd_put_32 (output_bfd, 0,
+				  htab->sgotplt->contents + offplt
+				  + htab->sgotplt_jump_table_size + 4);
+		    }
+		}
+
+	      sreloc = htab->srelgot;
+
+	      outrel.r_offset = (htab->sgot->output_section->vma
+				 + htab->sgot->output_offset + off);
+
+	      if (GOT_TLS_GD_P (tls_type))
+		dr_type = R_386_TLS_DTPMOD32;
+	      else if (GOT_TLS_GDESC_P (tls_type))
+		goto dr_done;
+	      else if (tls_type == GOT_TLS_IE_POS)
+		dr_type = R_386_TLS_TPOFF;
+	      else
+		dr_type = R_386_TLS_TPOFF32;
+
+	      if (dr_type == R_386_TLS_TPOFF && indx == 0)
+		bfd_put_32 (output_bfd, relocation - dtpoff_base (info),
+			    htab->sgot->contents + off);
+	      else if (dr_type == R_386_TLS_TPOFF32 && indx == 0)
+		bfd_put_32 (output_bfd, dtpoff_base (info) - relocation,
+			    htab->sgot->contents + off);
+	      else if (dr_type != R_386_TLS_DESC)
+		bfd_put_32 (output_bfd, 0,
+			    htab->sgot->contents + off);
+	      outrel.r_info = ELF32_R_INFO (indx, dr_type);
+
+	      loc = sreloc->contents;
+	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rel);
+	      BFD_ASSERT (loc + sizeof (Elf32_External_Rel)
+			  <= sreloc->contents + sreloc->size);
+	      bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
+
+	      if (GOT_TLS_GD_P (tls_type))
+		{
+		  if (indx == 0)
+		    {
+	    	      BFD_ASSERT (! unresolved_reloc);
+		      bfd_put_32 (output_bfd,
+				  relocation - dtpoff_base (info),
+				  htab->sgot->contents + off + 4);
+		    }
+		  else
+		    {
+		      bfd_put_32 (output_bfd, 0,
+				  htab->sgot->contents + off + 4);
+		      outrel.r_info = ELF32_R_INFO (indx,
+						    R_386_TLS_DTPOFF32);
+		      outrel.r_offset += 4;
+		      sreloc->reloc_count++;
+		      loc += sizeof (Elf32_External_Rel);
+		      BFD_ASSERT (loc + sizeof (Elf32_External_Rel)
+				  <= sreloc->contents + sreloc->size);
+		      bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
+		    }
+		}
+	      else if (tls_type == GOT_TLS_IE_BOTH)
+		{
+		  bfd_put_32 (output_bfd,
+			      indx == 0 ? relocation - dtpoff_base (info) : 0,
+			      htab->sgot->contents + off + 4);
+		  outrel.r_info = ELF32_R_INFO (indx, R_386_TLS_TPOFF);
+		  outrel.r_offset += 4;
+		  sreloc->reloc_count++;
+		  loc += sizeof (Elf32_External_Rel);
+		  bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
+		}
+
+	    dr_done:
+	      if (h != NULL)
+		h->got.offset |= 1;
+	      else
+		local_got_offsets[r_symndx] |= 1;
+	    }
+
+	  if (off >= (bfd_vma) -2
+	      && ! GOT_TLS_GDESC_P (tls_type))
+	    abort ();
+	  if (r_type == R_386_TLS_GOTDESC
+	      || r_type == R_386_TLS_DESC_CALL)
+	    {
+	      relocation = htab->sgotplt_jump_table_size + offplt;
+	      unresolved_reloc = FALSE;
+	    }
+	  else if (r_type == ELF32_R_TYPE (rel->r_info))
+	    {
+	      bfd_vma g_o_t = htab->sgotplt->output_section->vma
+			      + htab->sgotplt->output_offset;
+	      relocation = htab->sgot->output_section->vma
+		+ htab->sgot->output_offset + off - g_o_t;
+	      if ((r_type == R_386_TLS_IE || r_type == R_386_TLS_GOTIE)
+		  && tls_type == GOT_TLS_IE_BOTH)
+		relocation += 4;
+	      if (r_type == R_386_TLS_IE)
+		relocation += g_o_t;
+	      unresolved_reloc = FALSE;
+	    }
+	  else if (ELF32_R_TYPE (rel->r_info) == R_386_TLS_GD)
+	    {
+	      unsigned int val, type;
+	      bfd_vma roff;
+
+	      /* GD->IE transition.  */
+	      BFD_ASSERT (rel->r_offset >= 2);
+	      type = bfd_get_8 (input_bfd, contents + rel->r_offset - 2);
+	      BFD_ASSERT (type == 0x8d || type == 0x04);
+	      BFD_ASSERT (rel->r_offset + 9 <= input_section->size);
+	      BFD_ASSERT (bfd_get_8 (input_bfd, contents + rel->r_offset + 4)
+			  == 0xe8);
+	      BFD_ASSERT (rel + 1 < relend);
+	      BFD_ASSERT (ELF32_R_TYPE (rel[1].r_info) == R_386_PLT32);
+	      roff = rel->r_offset - 3;
+	      val = bfd_get_8 (input_bfd, contents + rel->r_offset - 1);
+	      if (type == 0x04)
+		{
+		  /* leal foo(,%reg,1), %eax; call ___tls_get_addr
+		     Change it into:
+		     movl %gs:0, %eax; subl $foo@gottpoff(%reg), %eax.  */
+		  BFD_ASSERT (rel->r_offset >= 3);
+		  BFD_ASSERT (bfd_get_8 (input_bfd,
+					 contents + rel->r_offset - 3)
+			      == 0x8d);
+		  BFD_ASSERT ((val & 0xc7) == 0x05 && val != (4 << 3));
+		  val >>= 3;
+		}
+	      else
+		{
+		  /* leal foo(%reg), %eax; call ___tls_get_addr; nop
+		     Change it into:
+		     movl %gs:0, %eax; subl $foo@gottpoff(%reg), %eax.  */
+		  BFD_ASSERT (rel->r_offset + 10 <= input_section->size);
+		  BFD_ASSERT ((val & 0xf8) == 0x80 && (val & 7) != 4);
+		  BFD_ASSERT (bfd_get_8 (input_bfd,
+					 contents + rel->r_offset + 9)
+			      == 0x90);
+		  roff = rel->r_offset - 2;
+		}
+	      memcpy (contents + roff,
+		      "\x65\xa1\0\0\0\0\x2b\x80\0\0\0", 12);
+	      contents[roff + 7] = 0x80 | (val & 7);
+	      /* If foo is used only with foo@gotntpoff(%reg) and
+		 foo@indntpoff, but not with foo@gottpoff(%reg), change
+		 subl $foo@gottpoff(%reg), %eax
+		 into:
+		 addl $foo@gotntpoff(%reg), %eax.  */
+	      if (tls_type == GOT_TLS_IE_POS)
+		contents[roff + 6] = 0x03;
+	      bfd_put_32 (output_bfd,
+			  htab->sgot->output_section->vma
+			  + htab->sgot->output_offset + off
+			  - htab->sgotplt->output_section->vma
+			  - htab->sgotplt->output_offset,
+			  contents + roff + 8);
+	      /* Skip R_386_PLT32.  */
+	      rel++;
+	      continue;
+	    }
+	  else if (ELF32_R_TYPE (rel->r_info) == R_386_TLS_GOTDESC)
+	    {
+	      /* GDesc -> IE transition.
+		 It's originally something like:
+		 leal x@tlsdesc(%ebx), %eax
+
+		 Change it to:
+		 movl x@gotntpoff(%ebx), %eax # before nop; nop
+		 or:
+		 movl x@gottpoff(%ebx), %eax # before negl %eax
+
+		 Registers other than %eax may be set up here.  */
+
+	      unsigned int val, type;
+	      bfd_vma roff;
+
+	      /* First, make sure it's a leal adding ebx to a 32-bit
+		 offset into any register, although it's probably
+		 almost always going to be eax.  */
+	      roff = rel->r_offset;
+	      BFD_ASSERT (roff >= 2);
+	      type = bfd_get_8 (input_bfd, contents + roff - 2);
+	      BFD_ASSERT (type == 0x8d);
+	      val = bfd_get_8 (input_bfd, contents + roff - 1);
+	      BFD_ASSERT ((val & 0xc7) == 0x83);
+	      BFD_ASSERT (roff + 4 <= input_section->size);
+
+	      /* Now modify the instruction as appropriate.  */
+	      /* To turn a leal into a movl in the form we use it, it
+		 suffices to change the first byte from 0x8d to 0x8b.
+		 aoliva FIXME: should we decide to keep the leal, all
+		 we have to do is remove the statement below, and
+		 adjust the relaxation of R_386_TLS_DESC_CALL.  */
+	      bfd_put_8 (output_bfd, 0x8b, contents + roff - 2);
+
+	      if (tls_type == GOT_TLS_IE_BOTH)
+		off += 4;
+
+	      bfd_put_32 (output_bfd,
+			  htab->sgot->output_section->vma
+			  + htab->sgot->output_offset + off
+			  - htab->sgotplt->output_section->vma
+			  - htab->sgotplt->output_offset,
+			  contents + roff);
+	      continue;
+	    }
+	  else if (ELF32_R_TYPE (rel->r_info) == R_386_TLS_DESC_CALL)
+	    {
+	      /* GDesc -> IE transition.
+		 It's originally:
+		 call *(%eax)
+
+		 Change it to:
+		 nop; nop
+		 or
+		 negl %eax
+		 depending on how we transformed the TLS_GOTDESC above.
+	      */
+
+	      unsigned int val, type;
+	      bfd_vma roff;
+
+	      /* First, make sure it's a call *(%eax).  */
+	      roff = rel->r_offset;
+	      BFD_ASSERT (roff + 2 <= input_section->size);
+	      type = bfd_get_8 (input_bfd, contents + roff);
+	      BFD_ASSERT (type == 0xff);
+	      val = bfd_get_8 (input_bfd, contents + roff + 1);
+	      BFD_ASSERT (val == 0x10);
+
+	      /* Now modify the instruction as appropriate.  */
+	      if (tls_type != GOT_TLS_IE_NEG)
+		{
+		  /* xchg %ax,%ax */
+		  bfd_put_8 (output_bfd, 0x66, contents + roff);
+		  bfd_put_8 (output_bfd, 0x90, contents + roff + 1);
+		}
+	      else
+		{
+		  /* negl %eax */
+		  bfd_put_8 (output_bfd, 0xf7, contents + roff);
+		  bfd_put_8 (output_bfd, 0xd8, contents + roff + 1);
+		}
+
+	      continue;
+	    }
+	  else
+	    BFD_ASSERT (FALSE);
+	  break;
+
+	case R_386_TLS_LDM:
+	  if (! info->shared)
+	    {
+	      unsigned int val;
+
+	      /* LD->LE transition:
+		 Ensure it is:
+		 leal foo(%reg), %eax; call ___tls_get_addr.
+		 We change it into:
+		 movl %gs:0, %eax; nop; leal 0(%esi,1), %esi.  */
+	      BFD_ASSERT (rel->r_offset >= 2);
+	      BFD_ASSERT (bfd_get_8 (input_bfd, contents + rel->r_offset - 2)
+			  == 0x8d);
+	      val = bfd_get_8 (input_bfd, contents + rel->r_offset - 1);
+	      BFD_ASSERT ((val & 0xf8) == 0x80 && (val & 7) != 4);
+	      BFD_ASSERT (rel->r_offset + 9 <= input_section->size);
+	      BFD_ASSERT (bfd_get_8 (input_bfd, contents + rel->r_offset + 4)
+			  == 0xe8);
+	      BFD_ASSERT (rel + 1 < relend);
+	      BFD_ASSERT (ELF32_R_TYPE (rel[1].r_info) == R_386_PLT32);
+	      memcpy (contents + rel->r_offset - 2,
+		      "\x65\xa1\0\0\0\0\x90\x8d\x74\x26", 11);
+	      /* Skip R_386_PLT32.  */
+	      rel++;
+	      continue;
+	    }
+
+	  if (htab->sgot == NULL)
+	    abort ();
+
+	  off = htab->tls_ldm_got.offset;
+	  if (off & 1)
+	    off &= ~1;
+	  else
+	    {
+	      Elf_Internal_Rela outrel;
+	      bfd_byte *loc;
+
+	      if (htab->srelgot == NULL)
+		abort ();
+
+	      outrel.r_offset = (htab->sgot->output_section->vma
+				 + htab->sgot->output_offset + off);
+
+	      bfd_put_32 (output_bfd, 0,
+			  htab->sgot->contents + off);
+	      bfd_put_32 (output_bfd, 0,
+			  htab->sgot->contents + off + 4);
+	      outrel.r_info = ELF32_R_INFO (0, R_386_TLS_DTPMOD32);
+	      loc = htab->srelgot->contents;
+	      loc += htab->srelgot->reloc_count++ * sizeof (Elf32_External_Rel);
+	      bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
+	      htab->tls_ldm_got.offset |= 1;
+	    }
+	  relocation = htab->sgot->output_section->vma
+		       + htab->sgot->output_offset + off
+		       - htab->sgotplt->output_section->vma
+		       - htab->sgotplt->output_offset;
+	  unresolved_reloc = FALSE;
+	  break;
+
+	case R_386_TLS_LDO_32:
+	  if (info->shared || (input_section->flags & SEC_CODE) == 0)
+	    relocation -= dtpoff_base (info);
+	  else
+	    /* When converting LDO to LE, we must negate.  */
+	    relocation = -tpoff (info, relocation);
+	  break;
+
+	case R_386_TLS_LE_32:
+	case R_386_TLS_LE:
+	  if (info->shared)
+	    {
+	      Elf_Internal_Rela outrel;
+	      asection *sreloc;
+	      bfd_byte *loc;
+	      int indx;
+
+	      outrel.r_offset = rel->r_offset
+				+ input_section->output_section->vma
+				+ input_section->output_offset;
+	      if (h != NULL && h->dynindx != -1)
+		indx = h->dynindx;
+	      else
+		indx = 0;
+	      if (r_type == R_386_TLS_LE_32)
+		outrel.r_info = ELF32_R_INFO (indx, R_386_TLS_TPOFF32);
+	      else
+		outrel.r_info = ELF32_R_INFO (indx, R_386_TLS_TPOFF);
+	      sreloc = elf_section_data (input_section)->sreloc;
+	      if (sreloc == NULL)
+		abort ();
+	      loc = sreloc->contents;
+	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rel);
+	      bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
+	      if (indx)
+		continue;
+	      else if (r_type == R_386_TLS_LE_32)
+		relocation = dtpoff_base (info) - relocation;
+	      else
+		relocation -= dtpoff_base (info);
+	    }
+	  else if (r_type == R_386_TLS_LE_32)
+	    relocation = tpoff (info, relocation);
+	  else
+	    relocation = -tpoff (info, relocation);
+	  break;
+
+	default:
+	  break;
+	}
+
+      /* Dynamic relocs are not propagated for SEC_DEBUGGING sections
+	 because such sections are not SEC_ALLOC and thus ld.so will
+	 not process them.  */
+      if (unresolved_reloc
+	  && !((input_section->flags & SEC_DEBUGGING) != 0
+	       && h->def_dynamic))
+	{
+	  (*_bfd_error_handler)
+	    (_("%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"),
+	     input_bfd,
+	     input_section,
+	     (long) rel->r_offset,
+	     howto->name,
+	     h->root.root.string);
+	  return FALSE;
+	}
+
+      r = _bfd_final_link_relocate (howto, input_bfd, input_section,
+				    contents, rel->r_offset,
+				    relocation, 0);
+
+      if (r != bfd_reloc_ok)
+	{
+	  const char *name;
+
+	  if (h != NULL)
+	    name = h->root.root.string;
+	  else
+	    {
+	      name = bfd_elf_string_from_elf_section (input_bfd,
+						      symtab_hdr->sh_link,
+						      sym->st_name);
+	      if (name == NULL)
+		return FALSE;
+	      if (*name == '\0')
+		name = bfd_section_name (input_bfd, sec);
+	    }
+
+	  if (r == bfd_reloc_overflow)
+	    {
+	      if (! ((*info->callbacks->reloc_overflow)
+		     (info, (h ? &h->root : NULL), name, howto->name,
+		      (bfd_vma) 0, input_bfd, input_section,
+		      rel->r_offset)))
+		return FALSE;
+	    }
+	  else
+	    {
+	      (*_bfd_error_handler)
+		(_("%B(%A+0x%lx): reloc against `%s': error %d"),
+		 input_bfd, input_section,
+		 (long) rel->r_offset, name, (int) r);
+	      return FALSE;
+	    }
+	}
+    }
+
+  return TRUE;
+}
+
+/* Finish up dynamic symbol handling.  We set the contents of various
+   dynamic sections here.  */
+
+static bfd_boolean
+elf_i386_finish_dynamic_symbol (bfd *output_bfd,
+				struct bfd_link_info *info,
+				struct elf_link_hash_entry *h,
+				Elf_Internal_Sym *sym)
+{
+  struct elf_i386_link_hash_table *htab;
+
+  htab = elf_i386_hash_table (info);
+
+  if (h->plt.offset != (bfd_vma) -1)
+    {
+      bfd_vma plt_index;
+      bfd_vma got_offset;
+      Elf_Internal_Rela rel;
+      bfd_byte *loc;
+
+      /* This symbol has an entry in the procedure linkage table.  Set
+	 it up.  */
+
+      if (h->dynindx == -1
+	  || htab->splt == NULL
+	  || htab->sgotplt == NULL
+	  || htab->srelplt == NULL)
+	abort ();
+
+      /* Get the index in the procedure linkage table which
+	 corresponds to this symbol.  This is the index of this symbol
+	 in all the symbols for which we are making plt entries.  The
+	 first entry in the procedure linkage table is reserved.  */
+      plt_index = h->plt.offset / PLT_ENTRY_SIZE - 1;
+
+      /* Get the offset into the .got table of the entry that
+	 corresponds to this function.  Each .got entry is 4 bytes.
+	 The first three are reserved.  */
+      got_offset = (plt_index + 3) * 4;
+
+      /* Fill in the entry in the procedure linkage table.  */
+      if (! info->shared)
+	{
+	  memcpy (htab->splt->contents + h->plt.offset, elf_i386_plt_entry,
+		  PLT_ENTRY_SIZE);
+	  bfd_put_32 (output_bfd,
+		      (htab->sgotplt->output_section->vma
+		       + htab->sgotplt->output_offset
+		       + got_offset),
+		      htab->splt->contents + h->plt.offset +
+                      elf_i386_plt_entry_offset1);
+
+	  if (htab->is_vxworks)
+	    {
+	      int s, k, reloc_index;
+
+	      /* Create the R_386_32 relocation referencing the GOT
+		 for this PLT entry.  */
+
+	      /* S: Current slot number (zero-based).  */
+	      s = (h->plt.offset - PLT_ENTRY_SIZE) / PLT_ENTRY_SIZE;
+	      /* K: Number of relocations for PLTResolve. */
+	      if (info->shared)
+		k = PLTRESOLVE_RELOCS_SHLIB;
+	      else
+		k = PLTRESOLVE_RELOCS;
+	      /* Skip the PLTresolve relocations, and the relocations for
+		 the other PLT slots. */
+	      reloc_index = k + s * PLT_NON_JUMP_SLOT_RELOCS;
+	      loc = (htab->srelplt2->contents + reloc_index
+		     * sizeof (Elf32_External_Rel));
+
+	      rel.r_offset = (htab->splt->output_section->vma
+			      + htab->splt->output_offset
+			      + h->plt.offset + 2),
+	      rel.r_info = ELF32_R_INFO (htab->elf.hgot->indx, R_386_32);
+	      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
+
+	      /* Create the R_386_32 relocation referencing the beginning of
+		 the PLT for this GOT entry.  */
+	      rel.r_offset = (htab->sgotplt->output_section->vma
+			      + htab->sgotplt->output_offset
+			      + got_offset);
+	      rel.r_info = ELF32_R_INFO (htab->elf.hplt->indx, R_386_32);
+	      bfd_elf32_swap_reloc_out (output_bfd, &rel,
+	      loc + sizeof (Elf32_External_Rel));
+	    }
+	}
+      else
+	{
+	  memcpy (htab->splt->contents + h->plt.offset, elf_i386_pic_plt_entry,
+		  PLT_ENTRY_SIZE);
+	  bfd_put_32 (output_bfd, got_offset,
+		      htab->splt->contents + h->plt.offset + 2);
+	}
+
+      bfd_put_32 (output_bfd, plt_index * sizeof (Elf32_External_Rel),
+		  htab->splt->contents + h->plt.offset +
+                  elf_i386_plt_entry_offset3);
+      /*
+       * The previous code assumed that the jump entry ended a PLT entry.
+       * Forcing alignment to 0mod32 adds some hlt bytes at the end (11).
+       * We therefore need to subtract those bytes from the jump offset.
+       */
+      bfd_put_32 (output_bfd, - (h->plt.offset + elf_i386_plt_entry_offset5),
+		  htab->splt->contents + h->plt.offset +
+                  elf_i386_plt_entry_offset4);
+
+      /* Fill in the entry in the global offset table.  */
+      bfd_put_32 (output_bfd,
+		  (htab->splt->output_section->vma
+		   + htab->splt->output_offset
+		   + h->plt.offset
+		   + elf_i386_plt_entry_offset2),
+		  htab->sgotplt->contents + got_offset);
+
+      /* Fill in the entry in the .rel.plt section.  */
+      rel.r_offset = (htab->sgotplt->output_section->vma
+		      + htab->sgotplt->output_offset
+		      + got_offset);
+      rel.r_info = ELF32_R_INFO (h->dynindx, R_386_JUMP_SLOT);
+      loc = htab->srelplt->contents + plt_index * sizeof (Elf32_External_Rel);
+      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
+
+      if (!h->def_regular)
+	{
+	  /* Mark the symbol as undefined, rather than as defined in
+	     the .plt section.  Leave the value if there were any
+	     relocations where pointer equality matters (this is a clue
+	     for the dynamic linker, to make function pointer
+	     comparisons work between an application and shared
+	     library), otherwise set it to zero.  If a function is only
+	     called from a binary, there is no need to slow down
+	     shared libraries because of that.  */
+	  sym->st_shndx = SHN_UNDEF;
+	  if (!h->pointer_equality_needed)
+	    sym->st_value = 0;
+	}
+    }
+
+  if (h->got.offset != (bfd_vma) -1
+      && ! GOT_TLS_GD_ANY_P (elf_i386_hash_entry(h)->tls_type)
+      && (elf_i386_hash_entry(h)->tls_type & GOT_TLS_IE) == 0)
+    {
+      Elf_Internal_Rela rel;
+      bfd_byte *loc;
+
+      /* This symbol has an entry in the global offset table.  Set it
+	 up.  */
+
+      if (htab->sgot == NULL || htab->srelgot == NULL)
+	abort ();
+
+      rel.r_offset = (htab->sgot->output_section->vma
+		      + htab->sgot->output_offset
+		      + (h->got.offset & ~(bfd_vma) 1));
+
+      /* If this is a static link, or it is a -Bsymbolic link and the
+	 symbol is defined locally or was forced to be local because
+	 of a version file, we just want to emit a RELATIVE reloc.
+	 The entry in the global offset table will already have been
+	 initialized in the relocate_section function.  */
+      if (info->shared
+	  && SYMBOL_REFERENCES_LOCAL (info, h))
+	{
+	  BFD_ASSERT((h->got.offset & 1) != 0);
+	  rel.r_info = ELF32_R_INFO (0, R_386_RELATIVE);
+	}
+      else
+	{
+	  BFD_ASSERT((h->got.offset & 1) == 0);
+	  bfd_put_32 (output_bfd, (bfd_vma) 0,
+		      htab->sgot->contents + h->got.offset);
+	  rel.r_info = ELF32_R_INFO (h->dynindx, R_386_GLOB_DAT);
+	}
+
+      loc = htab->srelgot->contents;
+      loc += htab->srelgot->reloc_count++ * sizeof (Elf32_External_Rel);
+      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
+    }
+
+  if (h->needs_copy)
+    {
+      Elf_Internal_Rela rel;
+      bfd_byte *loc;
+
+      /* This symbol needs a copy reloc.  Set it up.  */
+
+      if (h->dynindx == -1
+	  || (h->root.type != bfd_link_hash_defined
+	      && h->root.type != bfd_link_hash_defweak)
+	  || htab->srelbss == NULL)
+	abort ();
+
+      rel.r_offset = (h->root.u.def.value
+		      + h->root.u.def.section->output_section->vma
+		      + h->root.u.def.section->output_offset);
+      rel.r_info = ELF32_R_INFO (h->dynindx, R_386_COPY);
+      loc = htab->srelbss->contents;
+      loc += htab->srelbss->reloc_count++ * sizeof (Elf32_External_Rel);
+      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
+    }
+
+  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.
+     On VxWorks, the _GLOBAL_OFFSET_TABLE_ symbol is not absolute: it
+     is relative to the ".got" section.  */
+  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
+      || (!htab->is_vxworks && h == htab->elf.hgot))
+    sym->st_shndx = SHN_ABS;
+
+  return TRUE;
+}
+
+/* Used to decide how to sort relocs in an optimal manner for the
+   dynamic linker, before writing them out.  */
+
+static enum elf_reloc_type_class
+elf_i386_reloc_type_class (const Elf_Internal_Rela *rela)
+{
+  switch (ELF32_R_TYPE (rela->r_info))
+    {
+    case R_386_RELATIVE:
+      return reloc_class_relative;
+    case R_386_JUMP_SLOT:
+      return reloc_class_plt;
+    case R_386_COPY:
+      return reloc_class_copy;
+    default:
+      return reloc_class_normal;
+    }
+}
+
+/* Finish up the dynamic sections.  */
+
+static bfd_boolean
+elf_i386_finish_dynamic_sections (bfd *output_bfd,
+				  struct bfd_link_info *info)
+{
+  struct elf_i386_link_hash_table *htab;
+  bfd *dynobj;
+  asection *sdyn;
+
+  htab = elf_i386_hash_table (info);
+  dynobj = htab->elf.dynobj;
+  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
+
+  if (htab->elf.dynamic_sections_created)
+    {
+      Elf32_External_Dyn *dyncon, *dynconend;
+
+      if (sdyn == NULL || htab->sgot == NULL)
+	abort ();
+
+      dyncon = (Elf32_External_Dyn *) sdyn->contents;
+      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
+      for (; dyncon < dynconend; dyncon++)
+	{
+	  Elf_Internal_Dyn dyn;
+	  asection *s;
+
+	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);
+
+	  switch (dyn.d_tag)
+	    {
+	    default:
+	      continue;
+
+	    case DT_PLTGOT:
+	      s = htab->sgotplt;
+	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
+	      break;
+
+	    case DT_JMPREL:
+	      s = htab->srelplt;
+	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
+	      break;
+
+	    case DT_PLTRELSZ:
+	      s = htab->srelplt;
+	      dyn.d_un.d_val = s->size;
+	      break;
+
+	    case DT_RELSZ:
+	      /* My reading of the SVR4 ABI indicates that the
+		 procedure linkage table relocs (DT_JMPREL) should be
+		 included in the overall relocs (DT_REL).  This is
+		 what Solaris does.  However, UnixWare can not handle
+		 that case.  Therefore, we override the DT_RELSZ entry
+		 here to make it not include the JMPREL relocs.  */
+	      s = htab->srelplt;
+	      if (s == NULL)
+		continue;
+	      dyn.d_un.d_val -= s->size;
+	      break;
+
+	    case DT_REL:
+	      /* We may not be using the standard ELF linker script.
+		 If .rel.plt is the first .rel section, we adjust
+		 DT_REL to not include it.  */
+	      s = htab->srelplt;
+	      if (s == NULL)
+		continue;
+	      if (dyn.d_un.d_ptr != s->output_section->vma + s->output_offset)
+		continue;
+	      dyn.d_un.d_ptr += s->size;
+	      break;
+	    }
+
+	  bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
+	}
+
+      /* Fill in the first entry in the procedure linkage table.  */
+      if (htab->splt && htab->splt->size > 0)
+	{
+	  if (info->shared)
+	    {
+	      memcpy (htab->splt->contents, elf_i386_pic_plt0_entry,
+		      sizeof (elf_i386_pic_plt0_entry));
+	      memset (htab->splt->contents + sizeof (elf_i386_pic_plt0_entry),
+		      htab->plt0_pad_byte,
+		      PLT_ENTRY_SIZE - sizeof (elf_i386_pic_plt0_entry));
+	    }
+	  else
+	    {
+	      memcpy (htab->splt->contents, elf_i386_plt0_entry,
+		      sizeof(elf_i386_plt0_entry));
+	      memset (htab->splt->contents + sizeof (elf_i386_plt0_entry),
+		      htab->plt0_pad_byte,
+		      PLT_ENTRY_SIZE - sizeof (elf_i386_plt0_entry));
+	      bfd_put_32 (output_bfd,
+			  (htab->sgotplt->output_section->vma
+			   + htab->sgotplt->output_offset
+			   + 4),
+			  htab->splt->contents + elf_i386_plt0_entry_offset1);
+	      bfd_put_32 (output_bfd,
+			  (htab->sgotplt->output_section->vma
+			   + htab->sgotplt->output_offset
+			   + 8),
+			  htab->splt->contents + elf_i386_plt0_entry_offset2);
+
+	      if (htab->is_vxworks)
+		{
+		  Elf_Internal_Rela rel;
+
+		  /* Generate a relocation for _GLOBAL_OFFSET_TABLE_ + 4.
+		     On IA32 we use REL relocations so the addend goes in
+		     the PLT directly.  */
+		  rel.r_offset = (htab->splt->output_section->vma
+				  + htab->splt->output_offset
+				  + 2);
+		  rel.r_info = ELF32_R_INFO (htab->elf.hgot->indx, R_386_32);
+		  bfd_elf32_swap_reloc_out (output_bfd, &rel,
+					    htab->srelplt2->contents);
+		  /* Generate a relocation for _GLOBAL_OFFSET_TABLE_ + 8.  */
+		  rel.r_offset = (htab->splt->output_section->vma
+				  + htab->splt->output_offset
+				  + 8);
+		  rel.r_info = ELF32_R_INFO (htab->elf.hgot->indx, R_386_32);
+		  bfd_elf32_swap_reloc_out (output_bfd, &rel,
+					    htab->srelplt2->contents +
+					    sizeof (Elf32_External_Rel));
+		}
+	    }
+
+	  /* UnixWare sets the entsize of .plt to 4, although that doesn't
+	     really seem like the right value.  */
+	  elf_section_data (htab->splt->output_section)
+	    ->this_hdr.sh_entsize = 4;
+
+	  /* Correct the .rel.plt.unloaded relocations.  */
+	  if (htab->is_vxworks && !info->shared)
+	    {
+	      int num_plts = (htab->splt->size / PLT_ENTRY_SIZE) - 1;
+	      unsigned char *p;
+
+	      p = htab->srelplt2->contents;
+	      if (info->shared)
+		p += PLTRESOLVE_RELOCS_SHLIB * sizeof (Elf32_External_Rel);
+	      else
+		p += PLTRESOLVE_RELOCS * sizeof (Elf32_External_Rel);
+
+	      for (; num_plts; num_plts--)
+		{
+		  Elf_Internal_Rela rel;
+		  bfd_elf32_swap_reloc_in (output_bfd, p, &rel);
+		  rel.r_info = ELF32_R_INFO (htab->elf.hgot->indx, R_386_32);
+		  bfd_elf32_swap_reloc_out (output_bfd, &rel, p);
+		  p += sizeof (Elf32_External_Rel);
+
+		  bfd_elf32_swap_reloc_in (output_bfd, p, &rel);
+		  rel.r_info = ELF32_R_INFO (htab->elf.hplt->indx, R_386_32);
+		  bfd_elf32_swap_reloc_out (output_bfd, &rel, p);
+		  p += sizeof (Elf32_External_Rel);
+		}
+	    }
+	}
+    }
+
+  if (htab->sgotplt)
+    {
+      /* Fill in the first three entries in the global offset table.  */
+      if (htab->sgotplt->size > 0)
+	{
+	  bfd_put_32 (output_bfd,
+		      (sdyn == NULL ? 0
+		       : sdyn->output_section->vma + sdyn->output_offset),
+		      htab->sgotplt->contents);
+	  bfd_put_32 (output_bfd, 0, htab->sgotplt->contents + 4);
+	  bfd_put_32 (output_bfd, 0, htab->sgotplt->contents + 8);
+	}
+
+      elf_section_data (htab->sgotplt->output_section)->this_hdr.sh_entsize = 4;
+    }
+
+  if (htab->sgot && htab->sgot->size > 0)
+    elf_section_data (htab->sgot->output_section)->this_hdr.sh_entsize = 4;
+
+  return TRUE;
+}
+
+/* Return address for Ith PLT stub in section PLT, for relocation REL
+   or (bfd_vma) -1 if it should not be included.  */
+
+static bfd_vma
+elf_i386_plt_sym_val (bfd_vma i, const asection *plt,
+		      const arelent *rel ATTRIBUTE_UNUSED)
+{
+  return plt->vma + (i + 1) * PLT_ENTRY_SIZE;
+}
+
+/* Return TRUE if symbol should be hashed in the `.gnu.hash' section.  */
+
+static bfd_boolean
+elf_i386_hash_symbol (struct elf_link_hash_entry *h)
+{
+  if (h->plt.offset != (bfd_vma) -1
+      && !h->def_regular
+      && !h->pointer_equality_needed)
+    return FALSE;
+
+  return _bfd_elf_hash_symbol (h);
+}
+
+#define TARGET_LITTLE_SYM		bfd_elf32_nacl_vec
+#define TARGET_LITTLE_NAME		"elf32-nacl"
+
+/* NativeClient defines its own ABI.*/
+#undef	ELF_OSABI
+#define	ELF_OSABI			ELFOSABI_NACL
+
+#define ELF_ARCH			bfd_arch_i386
+#define ELF_MACHINE_CODE		EM_386
+#define ELF_MAXPAGESIZE			0x10000
+
+#define elf_backend_can_gc_sections	1
+#define elf_backend_can_refcount	1
+#define elf_backend_want_got_plt	1
+#define elf_backend_plt_readonly	1
+#define elf_backend_want_plt_sym	0
+#define elf_backend_got_header_size	12
+
+/* Support RELA for objdump of prelink objects.  */
+#define elf_info_to_howto		      elf_i386_info_to_howto_rel
+#define elf_info_to_howto_rel		      elf_i386_info_to_howto_rel
+
+#define bfd_elf32_mkobject		      elf_i386_mkobject
+
+#define bfd_elf32_bfd_is_local_label_name     elf_i386_is_local_label_name
+#define bfd_elf32_bfd_link_hash_table_create  elf_i386_link_hash_table_create
+#define bfd_elf32_bfd_reloc_type_lookup	      elf_i386_reloc_type_lookup
+#define bfd_elf32_bfd_reloc_name_lookup elf_i386_reloc_name_lookup
+
+#define elf_backend_adjust_dynamic_symbol     elf_i386_adjust_dynamic_symbol
+#define elf_backend_check_relocs	      elf_i386_check_relocs
+#define elf_backend_copy_indirect_symbol      elf_i386_copy_indirect_symbol
+#define elf_backend_create_dynamic_sections   elf_i386_create_dynamic_sections
+#define elf_backend_fake_sections	      elf_i386_fake_sections
+#define elf_backend_finish_dynamic_sections   elf_i386_finish_dynamic_sections
+#define elf_backend_finish_dynamic_symbol     elf_i386_finish_dynamic_symbol
+#define elf_backend_gc_mark_hook	      elf_i386_gc_mark_hook
+#define elf_backend_gc_sweep_hook	      elf_i386_gc_sweep_hook
+#define elf_backend_grok_prstatus	      elf_i386_grok_prstatus
+#define elf_backend_grok_psinfo		      elf_i386_grok_psinfo
+#define elf_backend_reloc_type_class	      elf_i386_reloc_type_class
+#define elf_backend_relocate_section	      elf_i386_relocate_section
+#define elf_backend_size_dynamic_sections     elf_i386_size_dynamic_sections
+#define elf_backend_always_size_sections      elf_i386_always_size_sections
+#define elf_backend_omit_section_dynsym \
+  ((bfd_boolean (*) (bfd *, struct bfd_link_info *, asection *)) bfd_true)
+#define elf_backend_plt_sym_val		      elf_i386_plt_sym_val
+#define elf_backend_hash_symbol		      elf_i386_hash_symbol
+
+#define bfd_elf32_bfd_merge_private_bfd_data \
+  elf32_nacl_merge_private_bfd_data
+
+static unsigned long previous_ibfd_e_flags = (unsigned long) EF_NACL_ALIGN_LIB;
+static unsigned char previous_ibfd_abiversion = 0;
+
+static bfd_boolean
+elf32_nacl_merge_private_bfd_data (bfd *ibfd,
+                                   bfd *obfd)
+{
+  unsigned long ibfd_e_flags;
+  unsigned char ibfd_abiversion;
+
+  ibfd_e_flags = elf_elfheader (ibfd)->e_flags & EF_NACL_ALIGN_MASK;
+  if ((ibfd_e_flags != EF_NACL_ALIGN_LIB) &&
+      (previous_ibfd_e_flags != EF_NACL_ALIGN_LIB) &&
+      (ibfd_e_flags != previous_ibfd_e_flags)) {
+    (*_bfd_error_handler)
+    (_("%B: linking files with incompatible alignments"), ibfd);
+    bfd_set_error (bfd_error_bad_value);
+    return FALSE;
+  }
+
+  ibfd_abiversion = elf_elfheader (ibfd)->e_ident[EI_ABIVERSION];
+  if (ibfd_abiversion != 0 &&
+      previous_ibfd_abiversion != 0 &&
+      ibfd_abiversion != previous_ibfd_abiversion) {
+    (*_bfd_error_handler)
+    (_("%B: linking files with incompatible abi version"), ibfd);
+    bfd_set_error (bfd_error_bad_value);
+    return FALSE;
+  }
+
+  previous_ibfd_e_flags = ibfd_e_flags;
+  elf_elfheader (obfd)->e_flags |= previous_ibfd_e_flags;
+
+  previous_ibfd_abiversion = ibfd_abiversion;
+  elf_elfheader (obfd)->e_ident[EI_ABIVERSION] = previous_ibfd_abiversion;
+
+  return TRUE;
+}
+
+#define elf_backend_final_write_processing \
+  elf32_nacl_backend_final_write_processing
+
+static void
+elf32_nacl_backend_final_write_processing (bfd *abfd,
+                                           bfd_boolean linker ATTRIBUTE_UNUSED)
+{
+  elf_elfheader (abfd)->e_ident[EI_OSABI] = ELFOSABI_NACL;
+  elf_elfheader (abfd)->e_ident[EI_ABIVERSION] = EF_NACL_ABIVERSION;
+  elf_elfheader (abfd)->e_flags |= previous_ibfd_e_flags;
+}
+
+#include "elf32-target.h"
diff -Naur ../PRISTINE/binutils-2.18/bfd/targets.c binutils-2.18/bfd/targets.c
--- ../PRISTINE/binutils-2.18/bfd/targets.c	2007-08-06 12:59:42.000000000 -0700
+++ binutils-2.18/bfd/targets.c	2009-01-09 17:32:43.436803000 -0800
@@ -622,6 +622,7 @@
 extern const bfd_target bfd_elf32_mn10300_vec;
 extern const bfd_target bfd_elf32_mt_vec;
 extern const bfd_target bfd_elf32_msp430_vec;
+extern const bfd_target bfd_elf32_nacl_vec;
 extern const bfd_target bfd_elf32_nbigmips_vec;
 extern const bfd_target bfd_elf32_nlittlemips_vec;
 extern const bfd_target bfd_elf32_ntradbigmips_vec;
diff -Naur ../PRISTINE/binutils-2.18/binutils/readelf.c binutils-2.18/binutils/readelf.c
--- ../PRISTINE/binutils-2.18/binutils/readelf.c	2007-08-28 10:19:34.000000000 -0700
+++ binutils-2.18/binutils/readelf.c	2009-01-09 17:32:43.452792000 -0800
@@ -2362,6 +2362,7 @@
     case ELFOSABI_AROS:		return "Amiga Research OS";
     case ELFOSABI_STANDALONE:	return _("Standalone App");
     case ELFOSABI_ARM:		return "ARM";
+    case ELFOSABI_NACL:		return "NativeClient";
     default:
       snprintf (buff, sizeof (buff), _("<unknown: %x>"), osabi);
       return buff;
diff -Naur ../PRISTINE/binutils-2.18/config.sub binutils-2.18/config.sub
--- ../PRISTINE/binutils-2.18/config.sub	2007-08-06 13:00:30.000000000 -0700
+++ binutils-2.18/config.sub	2009-01-09 17:32:43.459781000 -0800
@@ -306,6 +306,10 @@
 	i*86 | x86_64)
 	  basic_machine=$basic_machine-pc
 	  ;;
+	nacl*)
+	  basic_machine=i686-pc
+	  os=-nacl
+	  ;;
 	# Object if more than one company name word.
 	*-*-*)
 		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
@@ -1238,6 +1242,9 @@
 			;;
 		esac
 		;;
+	-nacl*)
+		os=-nacl
+		;;
 	-nto-qnx*)
 		;;
 	-nto*)
diff -Naur ../PRISTINE/binutils-2.18/configure binutils-2.18/configure
--- ../PRISTINE/binutils-2.18/configure	2007-08-06 13:29:40.000000000 -0700
+++ binutils-2.18/configure	2009-01-09 17:32:43.485749000 -0800
@@ -6128,7 +6128,7 @@
     # For an installed makeinfo, we require it to be from texinfo 4.4 or
     # higher, else we use the "missing" dummy.
     if ${MAKEINFO} --version \
-       | egrep 'texinfo[^0-9]*([1-3][0-9]|4\.[4-9]|[5-9])' >/dev/null 2>&1; then
+       | egrep 'texinfo[^0-9]*([1-3][0-9]|4\.([4-9]|1[0-9])|[5-9])' >/dev/null 2>&1; then
       :
     else
       MAKEINFO="$MISSING makeinfo"
diff -Naur ../PRISTINE/binutils-2.18/gas/as.c binutils-2.18/gas/as.c
--- ../PRISTINE/binutils-2.18/gas/as.c	2007-08-28 10:19:35.000000000 -0700
+++ binutils-2.18/gas/as.c	2009-01-09 17:32:43.491740000 -0800
@@ -430,7 +430,7 @@
       OPTION_AL,
       OPTION_HASH_TABLE_SIZE,
       OPTION_REDUCE_MEMORY_OVERHEADS,
-      OPTION_WARN_FATAL
+      OPTION_WARN_FATAL,
     /* When you add options here, check that they do
        not collide with OPTION_MD_BASE.  See as.h.  */
     };
diff -Naur ../PRISTINE/binutils-2.18/gas/config/tc-i386.c binutils-2.18/gas/config/tc-i386.c
--- ../PRISTINE/binutils-2.18/gas/config/tc-i386.c	2007-08-24 07:01:22.000000000 -0700
+++ binutils-2.18/gas/config/tc-i386.c	2009-01-09 17:32:43.510748000 -0800
@@ -99,6 +99,7 @@
 #if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
 static void handle_large_common (int small ATTRIBUTE_UNUSED);
 #endif
+static void nativeclient_symbol_init (void);
 
 static const char *default_arch = DEFAULT_ARCH;
 
@@ -339,6 +340,14 @@
 /* The dwarf2 data alignment, adjusted for 32 or 64 bit.  */
 int x86_cie_data_alignment;
 
+/* NativeClient support */
+
+/* Default alignment.  0=OFF */
+int nacl_alignment = NACL_ALIGN_POW2;
+
+/* Use library mode.  0=OFF */
+int nacl_library_mode = 0;
+
 /* Interface to relax_segment.
    There are 3 major relax states for 386 jump insns because the
    different types of jumps add different sizes to frags when we're
@@ -1212,6 +1221,34 @@
   else
     as_fatal (_("Unknown architecture"));
 }
+
+void
+nativeclient_symbol_init ()
+{
+  symbolS *symbolP;
+  int entry_align;
+
+  /*
+   * A symbol conveying the setting of nacl_alignment to assembler writers.
+   */
+  symbolP = symbol_new ("NACLALIGN", absolute_section,
+			(valueT) nacl_alignment, &zero_address_frag);
+  symbol_table_insert (symbolP);
+
+  /*
+   * A symbol conveying the function entry alignment.  This differs from
+   * NACLALIGN in library mode.
+   */
+  if (nacl_library_mode) {
+    entry_align = 5;
+  }
+  else {
+    entry_align = nacl_alignment;
+  }
+  symbolP = symbol_new ("NACLENTRYALIGN", absolute_section,
+			(valueT) entry_align, &zero_address_frag);
+  symbol_table_insert (symbolP);
+}
 
 void
 md_begin ()
@@ -1344,6 +1381,8 @@
       x86_dwarf2_return_column = 8;
       x86_cie_data_alignment = -4;
     }
+
+  nativeclient_symbol_init();
 }
 
 void
@@ -3989,19 +4028,93 @@
 }
 
 static void
+insert_sandbox_code (void)
+{
+  char* p;
+  int align_mask = (1 << nacl_alignment) - 1;
+
+  if (getenv("NACL_DEBUG_ALIGN")) {
+    p = frag_more (12);
+    p[0] = 0xF7; p[1] = 0xC0 + i.rm.regmem;
+    p[2] = align_mask; p[3] = p[4] = p[5] = 0x00; // TEST reg, align_mask
+    p[6] = 0x74; p[7] = 0x04; // JZ +4
+    p[8] = 0xCC; // INT3
+    p[9] = 0x0F; p[10] = 0x1F; p[11] = 0x00; // NOP
+  }
+  else {
+    p = frag_more (3);
+    p[0] = 0x83; // AND instruction.
+    p[1] = (0xe0 + i.rm.regmem); // mod = 11, reg = 100,  rm = i.rm.regmem;
+    // p[2] = 0xff & ~align_mask;
+    p[2] = 0xff;
+  }
+}
+
+
+static int
+frag_is_a_call (void)
+{
+  if (i.tm.base_opcode == 0xe8) {
+    // direct calls
+    return 1;
+  }
+  else if (i.tm.base_opcode == 0xff) {
+    // possibly indirect calls
+    return (i.rm.mode == 3) && (i.rm.reg == 2);
+  }
+  else {
+    return 0;
+  }
+}
+
+
+static void
 output_insn (void)
 {
   fragS *insn_start_frag;
   offsetT insn_start_off;
 
+  // DCS -- New code for NativeClient.
+  // Frag_align_code sets the alignment on the current fragment and may
+  // create a new one.  Because of this we remember the current fragment
+  // before calling frag_align_code.
+  insn_start_frag = frag_now;
+
+  if (nacl_alignment > 0) {
+    frag_align_code(0, 0);
+#ifdef DCS
+    // TODO(sehr): this code seems unnecessary.  Remove it.
+    // Really ugly stuff to avoid splitting call and its subsequent alignment
+    // across two fragments.
+    if (frag_is_a_call() &&
+        obstack_room(&frchain_now->frch_obstack) < (unsigned)((1<<(nacl_alignment+1))-1)) {
+      fragS *temp_frag = frag_now;
+      frag_align_code(nacl_alignment + 1, 0);
+      temp_frag->fr_offset = 0;
+      temp_frag->fr_subtype = 0;
+    }
+#endif /* DCS */
+  }
+
   /* Tie dwarf2 debug info to the address at the start of the insn.
      We can't do this after the insn has been output as the current
      frag may have been closed off.  eg. by frag_var.  */
   dwarf2_emit_insn (0);
 
-  insn_start_frag = frag_now;
   insn_start_off = frag_now_fix ();
 
+  if (nacl_alignment > 0) {
+    if (!strcmp(i.tm.name, "naclcall")) {
+      insert_sandbox_code();
+    }
+    else if (!strcmp(i.tm.name, "nacljmp")) {
+      insert_sandbox_code();
+    }
+    else if (!strcmp(i.tm.name, "naclret")) {
+      insert_sandbox_code();
+    }
+  }
+
   /* Output jumps.  */
   if (i.tm.opcode_modifier & Jump)
     output_branch ();
@@ -4115,6 +4228,74 @@
       pi ("" /*line*/, &i);
     }
 #endif /* DEBUG386  */
+  /*
+   * We want to make sure no instruction straddles a (1 << nacl_alignment)
+   * boundary.  We do this by setting the fragment alignment to
+   * (1 << nacl_alignment), but allowing no more than the size of the
+   * instruction as fill.
+   */
+  if (nacl_alignment > 0) {
+    int align_base;
+    int call_align;
+    int instrsize = (int) frag_now_fix();
+
+    /*
+     * "library mode" enables compatible library builds for either 16 or
+     * 32 byte alignment.  Using the strictest alignment requirement for
+     * instructions makes them 0mod16 aligned.  Calls need to end a 32 byte
+     * region.
+     */
+    if (nacl_library_mode) {
+      align_base = 4;
+      call_align = 5;
+    }
+    else {
+      align_base = nacl_alignment;
+      call_align = nacl_alignment;
+    }
+
+    switch (instrsize) {
+      case 0:
+        // We get zero size for jump instructions.  Go to their biggest.
+        insn_start_frag->fr_offset = align_base;
+        insn_start_frag->fr_subtype = 5;
+        break;
+
+      case 1:
+        if ((i.tm.base_opcode == 0xf3) || (i.tm.base_opcode == 0xf2) ||
+            (i.tm.base_opcode == 0xf0)) {
+          // rep and lock refixes are treated as separate instructions.
+          // I don't know any other patch but to force an alignment to 0,
+          // i.e., waste as many bytes as it takes.
+          insn_start_frag->fr_offset = align_base;
+          insn_start_frag->fr_subtype = 0;
+        }
+        else {
+          // Don't align other one-byte instructions.
+          insn_start_frag->fr_offset = 0;
+          insn_start_frag->fr_subtype = 0;
+        }
+        break;
+
+      default:
+        // Don't use more than size-1 bytes to pad.
+        insn_start_frag->fr_offset = align_base;
+        insn_start_frag->fr_subtype = instrsize-1;
+        break;
+    }
+
+
+    /*
+     * Calls need to fall at the end of a (1 << call_align) region.  We
+     * make sure there are no instructions after the call until the next
+     * alignment.  During writing of the object we swap the nops before the
+     * instruction.
+     */
+    if (frag_is_a_call()) {
+      frag_now->is_call = 1;
+      frag_align_code(call_align,0);
+    }
+  }
 }
 
 /* Return the size of the displacement operand N.  */
@@ -5985,6 +6166,9 @@
 #define OPTION_DIVIDE (OPTION_MD_BASE + 2)
 #define OPTION_MARCH (OPTION_MD_BASE + 3)
 #define OPTION_MTUNE (OPTION_MD_BASE + 4)
+#define OPTION_NACL_ALIGN (OPTION_MD_BASE + 5)
+#define OPTION_NACL_LIBRARY_MODE (OPTION_MD_BASE + 6)
+
 
 struct option md_longopts[] =
 {
@@ -5995,6 +6179,8 @@
   {"divide", no_argument, NULL, OPTION_DIVIDE},
   {"march", required_argument, NULL, OPTION_MARCH},
   {"mtune", required_argument, NULL, OPTION_MTUNE},
+  {"nacl-align", required_argument, NULL, OPTION_NACL_ALIGN},
+  {"nacl-library-mode", no_argument, NULL, OPTION_NACL_LIBRARY_MODE},
   {NULL, no_argument, NULL, 0}
 };
 size_t md_longopts_size = sizeof (md_longopts);
@@ -6115,6 +6301,20 @@
 	as_fatal (_("Invalid -mtune= option: `%s'"), arg);
       break;
 
+    case OPTION_NACL_ALIGN:
+      {
+        nacl_alignment = atoi (optarg);
+        if (nacl_alignment < 0)
+          as_fatal (_("--nacl-align needs a non-negative argument"));
+        break;
+      }
+
+    case OPTION_NACL_LIBRARY_MODE:
+      {
+        nacl_library_mode = 1;
+        break;
+      }
+
     default:
       return 0;
     }
diff -Naur ../PRISTINE/binutils-2.18/gas/config/tc-i386.h binutils-2.18/gas/config/tc-i386.h
--- ../PRISTINE/binutils-2.18/gas/config/tc-i386.h	2007-08-06 12:59:57.000000000 -0700
+++ binutils-2.18/gas/config/tc-i386.h	2009-01-09 17:32:43.517716000 -0800
@@ -199,6 +199,7 @@
 #if (defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)) && !defined (LEX_AT)
 #define TC_PARSE_CONS_EXPRESSION(EXP, NBYTES) x86_cons (EXP, NBYTES)
 extern void x86_cons (expressionS *, int);
+
 #endif
 
 #define TC_CONS_FIX_NEW(FRAG,OFF,LEN,EXP) x86_cons_fix_new(FRAG, OFF, LEN, EXP)
@@ -317,4 +318,12 @@
 
 #endif /* TE_PE */
 
+/* NativeClient specific additions. */
+
+/* log2 of the instruction alignment */
+extern int nacl_alignment;
+
+/* library mode: 16-byte alignment, calls end 32-byte chunks. */
+extern int nacl_library_mode;
+
 #endif /* TC_I386 */
diff -Naur ../PRISTINE/binutils-2.18/gas/config/tc-nacl.c binutils-2.18/gas/config/tc-nacl.c
--- ../PRISTINE/binutils-2.18/gas/config/tc-nacl.c	1969-12-31 16:00:00.000000000 -0800
+++ binutils-2.18/gas/config/tc-nacl.c	2009-02-19 14:58:24.814566000 -0800
@@ -0,0 +1,8199 @@
+/* tc-nacl.c -- Assemble code for NativeClient
+   Copyright 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
+   Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+/* Intel 80386 machine specific gas.
+   Written by Eliot Dresselhaus (eliot@mgm.mit.edu).
+   x86_64 support by Jan Hubicka (jh@suse.cz)
+   VIA PadLock support by Michal Ludvig (mludvig@suse.cz)
+   Bugs & suggestions are completely welcome.  This is free software.
+   Please help us make it better.  */
+
+#include "as.h"
+#include "safe-ctype.h"
+#include "subsegs.h"
+#include "dwarf2dbg.h"
+#include "dw2gencfi.h"
+#include "elf/x86-64.h"
+#include "elf/nacl.h"
+
+#ifndef REGISTER_WARNINGS
+#define REGISTER_WARNINGS 1
+#endif
+
+#ifndef INFER_ADDR_PREFIX
+#define INFER_ADDR_PREFIX 1
+#endif
+
+#ifndef SCALE1_WHEN_NO_INDEX
+/* Specifying a scale factor besides 1 when there is no index is
+   futile.  eg. `mov (%ebx,2),%al' does exactly the same as
+   `mov (%ebx),%al'.  To slavishly follow what the programmer
+   specified, set SCALE1_WHEN_NO_INDEX to 0.  */
+#define SCALE1_WHEN_NO_INDEX 1
+#endif
+
+#ifndef DEFAULT_ARCH
+#define DEFAULT_ARCH "i386"
+#endif
+
+#ifndef INLINE
+#if __GNUC__ >= 2
+#define INLINE __inline__
+#else
+#define INLINE
+#endif
+#endif
+
+static void set_code_flag (int);
+static void set_16bit_gcc_code_flag (int);
+static void set_intel_syntax (int);
+static void set_cpu_arch (int);
+#ifdef TE_PE
+static void pe_directive_secrel (int);
+#endif
+static void signed_cons (int);
+static char *output_invalid (int c);
+static int i386_operand (char *);
+static int i386_intel_operand (char *, int);
+static const reg_entry *parse_register (char *, char **);
+static char *parse_insn (char *, char *);
+static char *parse_operands (char *, const char *);
+static void swap_operands (void);
+static void swap_2_operands (int, int);
+static void optimize_imm (void);
+static void optimize_disp (void);
+static int match_template (void);
+static int check_string (void);
+static int process_suffix (void);
+static int check_byte_reg (void);
+static int check_long_reg (void);
+static int check_qword_reg (void);
+static int check_word_reg (void);
+static int finalize_imm (void);
+static int process_operands (void);
+static const seg_entry *build_modrm_byte (void);
+static void output_insn (void);
+static void output_imm (fragS *, offsetT);
+static void output_disp (fragS *, offsetT);
+#ifndef I386COFF
+static void s_bss (int);
+#endif
+#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
+static void handle_large_common (int small ATTRIBUTE_UNUSED);
+#endif
+static void nativeclient_symbol_init (void);
+
+static const char *default_arch = DEFAULT_ARCH;
+
+/* 'md_assemble ()' gathers together information and puts it into a
+   i386_insn.  */
+
+union i386_op
+  {
+    expressionS *disps;
+    expressionS *imms;
+    const reg_entry *regs;
+  };
+
+struct _i386_insn
+  {
+    /* TM holds the template for the insn were currently assembling.  */
+    template tm;
+
+    /* SUFFIX holds the instruction mnemonic suffix if given.
+       (e.g. 'l' for 'movl')  */
+    char suffix;
+
+    /* OPERANDS gives the number of given operands.  */
+    unsigned int operands;
+
+    /* REG_OPERANDS, DISP_OPERANDS, MEM_OPERANDS, IMM_OPERANDS give the number
+       of given register, displacement, memory operands and immediate
+       operands.  */
+    unsigned int reg_operands, disp_operands, mem_operands, imm_operands;
+
+    /* TYPES [i] is the type (see above #defines) which tells us how to
+       use OP[i] for the corresponding operand.  */
+    unsigned int types[MAX_OPERANDS];
+
+    /* Displacement expression, immediate expression, or register for each
+       operand.  */
+    union i386_op op[MAX_OPERANDS];
+
+    /* Flags for operands.  */
+    unsigned int flags[MAX_OPERANDS];
+#define Operand_PCrel 1
+
+    /* Relocation type for operand */
+    enum bfd_reloc_code_real reloc[MAX_OPERANDS];
+
+    /* BASE_REG, INDEX_REG, and LOG2_SCALE_FACTOR are used to encode
+       the base index byte below.  */
+    const reg_entry *base_reg;
+    const reg_entry *index_reg;
+    unsigned int log2_scale_factor;
+
+    /* SEG gives the seg_entries of this insn.  They are zero unless
+       explicit segment overrides are given.  */
+    const seg_entry *seg[2];
+
+    /* PREFIX holds all the given prefix opcodes (usually null).
+       PREFIXES is the number of prefix opcodes.  */
+    unsigned int prefixes;
+    unsigned char prefix[MAX_PREFIXES];
+
+    /* RM and SIB are the modrm byte and the sib byte where the
+       addressing modes of this insn are encoded.  */
+
+    modrm_byte rm;
+    rex_byte rex;
+    sib_byte sib;
+  };
+
+typedef struct _i386_insn i386_insn;
+
+/* List of chars besides those in app.c:symbol_chars that can start an
+   operand.  Used to prevent the scrubber eating vital white-space.  */
+const char extra_symbol_chars[] = "*%-(["
+#ifdef LEX_AT
+	"@"
+#endif
+#ifdef LEX_QM
+	"?"
+#endif
+	;
+
+#if (defined (TE_I386AIX)				\
+     || ((defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF))	\
+	 && !defined (TE_GNU)				\
+	 && !defined (TE_LINUX)				\
+ 	 && !defined (TE_NETWARE)			\
+	 && !defined (TE_FreeBSD)			\
+	 && !defined (TE_NetBSD)))
+/* This array holds the chars that always start a comment.  If the
+   pre-processor is disabled, these aren't very useful.  The option
+   --divide will remove '/' from this list.  */
+const char *i386_comment_chars = "#/";
+#define SVR4_COMMENT_CHARS 1
+#define PREFIX_SEPARATOR '\\'
+
+#else
+const char *i386_comment_chars = "#";
+#define PREFIX_SEPARATOR '/'
+#endif
+
+/* This array holds the chars that only start a comment at the beginning of
+   a line.  If the line seems to have the form '# 123 filename'
+   .line and .file directives will appear in the pre-processed output.
+   Note that input_file.c hand checks for '#' at the beginning of the
+   first line of the input file.  This is because the compiler outputs
+   #NO_APP at the beginning of its output.
+   Also note that comments started like this one will always work if
+   '/' isn't otherwise defined.  */
+const char line_comment_chars[] = "#/";
+
+const char line_separator_chars[] = ";";
+
+/* Chars that can be used to separate mant from exp in floating point
+   nums.  */
+const char EXP_CHARS[] = "eE";
+
+/* Chars that mean this number is a floating point constant
+   As in 0f12.456
+   or    0d1.2345e12.  */
+const char FLT_CHARS[] = "fFdDxX";
+
+/* Tables for lexical analysis.  */
+static char mnemonic_chars[256];
+static char register_chars[256];
+static char operand_chars[256];
+static char identifier_chars[256];
+static char digit_chars[256];
+
+/* Lexical macros.  */
+#define is_mnemonic_char(x) (mnemonic_chars[(unsigned char) x])
+#define is_operand_char(x) (operand_chars[(unsigned char) x])
+#define is_register_char(x) (register_chars[(unsigned char) x])
+#define is_space_char(x) ((x) == ' ')
+#define is_identifier_char(x) (identifier_chars[(unsigned char) x])
+#define is_digit_char(x) (digit_chars[(unsigned char) x])
+
+/* All non-digit non-letter characters that may occur in an operand.  */
+static char operand_special_chars[] = "%$-+(,)*._~/<>|&^!:[@]";
+
+/* md_assemble() always leaves the strings it's passed unaltered.  To
+   effect this we maintain a stack of saved characters that we've smashed
+   with '\0's (indicating end of strings for various sub-fields of the
+   assembler instruction).  */
+static char save_stack[32];
+static char *save_stack_p;
+#define END_STRING_AND_SAVE(s) \
+	do { *save_stack_p++ = *(s); *(s) = '\0'; } while (0)
+#define RESTORE_END_STRING(s) \
+	do { *(s) = *--save_stack_p; } while (0)
+
+/* The instruction we're assembling.  */
+static i386_insn i;
+
+/* Possible templates for current insn.  */
+static const templates *current_templates;
+
+/* Per instruction expressionS buffers: max displacements & immediates.  */
+static expressionS disp_expressions[MAX_MEMORY_OPERANDS];
+static expressionS im_expressions[MAX_IMMEDIATE_OPERANDS];
+
+/* Current operand we are working on.  */
+static int this_operand;
+
+/* We support four different modes.  FLAG_CODE variable is used to distinguish
+   these.  */
+
+enum flag_code {
+	CODE_32BIT,
+	CODE_16BIT,
+	CODE_64BIT };
+#define NUM_FLAG_CODE ((int) CODE_64BIT + 1)
+
+static enum flag_code flag_code;
+static unsigned int object_64bit;
+static int use_rela_relocations = 0;
+
+/* The names used to print error messages.  */
+static const char *flag_code_names[] =
+  {
+    "32",
+    "16",
+    "64"
+  };
+
+/* 1 for intel syntax,
+   0 if att syntax.  */
+static int intel_syntax = 0;
+
+/* 1 if register prefix % not required.  */
+static int allow_naked_reg = 0;
+
+/* Register prefix used for error message.  */
+static const char *register_prefix = "%";
+
+/* Used in 16 bit gcc mode to add an l suffix to call, ret, enter,
+   leave, push, and pop instructions so that gcc has the same stack
+   frame as in 32 bit mode.  */
+static char stackop_size = '\0';
+
+/* Non-zero to optimize code alignment.  */
+int optimize_align_code = 1;
+
+/* Non-zero to quieten some warnings.  */
+static int quiet_warnings = 0;
+
+/* CPU name.  */
+static const char *cpu_arch_name = NULL;
+static const char *cpu_sub_arch_name = NULL;
+
+/* CPU feature flags.  */
+static unsigned int cpu_arch_flags = CpuUnknownFlags | CpuNo64;
+
+/* If we have selected a cpu we are generating instructions for.  */
+static int cpu_arch_tune_set = 0;
+
+/* Cpu we are generating instructions for.  */
+static enum processor_type cpu_arch_tune = PROCESSOR_UNKNOWN;
+
+/* CPU feature flags of cpu we are generating instructions for.  */
+static unsigned int cpu_arch_tune_flags = 0;
+
+/* CPU instruction set architecture used.  */
+static enum processor_type cpu_arch_isa = PROCESSOR_UNKNOWN;
+
+/* CPU feature flags of instruction set architecture used.  */
+static unsigned int cpu_arch_isa_flags = 0;
+
+/* If set, conditional jumps are not automatically promoted to handle
+   larger than a byte offset.  */
+static unsigned int no_cond_jump_promotion = 0;
+
+/* Pre-defined "_GLOBAL_OFFSET_TABLE_".  */
+static symbolS *GOT_symbol;
+
+/* The dwarf2 return column, adjusted for 32 or 64 bit.  */
+unsigned int x86_dwarf2_return_column;
+
+/* The dwarf2 data alignment, adjusted for 32 or 64 bit.  */
+int x86_cie_data_alignment;
+
+/* NativeClient support */
+
+/* Default alignment.  0=OFF */
+int nacl_alignment = NACL_ALIGN_POW2;
+
+/* Use library mode.  0=OFF */
+int nacl_library_mode = 0;
+
+/* Interface to relax_segment.
+   There are 3 major relax states for 386 jump insns because the
+   different types of jumps add different sizes to frags when we're
+   figuring out what sort of jump to choose to reach a given label.  */
+
+/* Types.  */
+#define UNCOND_JUMP 0
+#define COND_JUMP 1
+#define COND_JUMP86 2
+
+/* Sizes.  */
+#define CODE16	1
+#define SMALL	0
+#define SMALL16 (SMALL | CODE16)
+#define BIG	2
+#define BIG16	(BIG | CODE16)
+
+#ifndef INLINE
+#ifdef __GNUC__
+#define INLINE __inline__
+#else
+#define INLINE
+#endif
+#endif
+
+#define ENCODE_RELAX_STATE(type, size) \
+  ((relax_substateT) (((type) << 2) | (size)))
+#define TYPE_FROM_RELAX_STATE(s) \
+  ((s) >> 2)
+#define DISP_SIZE_FROM_RELAX_STATE(s) \
+    ((((s) & 3) == BIG ? 4 : (((s) & 3) == BIG16 ? 2 : 1)))
+
+/* This table is used by relax_frag to promote short jumps to long
+   ones where necessary.  SMALL (short) jumps may be promoted to BIG
+   (32 bit long) ones, and SMALL16 jumps to BIG16 (16 bit long).  We
+   don't allow a short jump in a 32 bit code segment to be promoted to
+   a 16 bit offset jump because it's slower (requires data size
+   prefix), and doesn't work, unless the destination is in the bottom
+   64k of the code segment (The top 16 bits of eip are zeroed).  */
+
+const relax_typeS md_relax_table[] =
+{
+  /* The fields are:
+     1) most positive reach of this state,
+     2) most negative reach of this state,
+     3) how many bytes this mode will have in the variable part of the frag
+     4) which index into the table to try if we can't fit into this one.  */
+
+  /* UNCOND_JUMP states.  */
+  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (UNCOND_JUMP, BIG)},
+  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (UNCOND_JUMP, BIG16)},
+  /* dword jmp adds 4 bytes to frag:
+     0 extra opcode bytes, 4 displacement bytes.  */
+  {0, 0, 4, 0},
+  /* word jmp adds 2 byte2 to frag:
+     0 extra opcode bytes, 2 displacement bytes.  */
+  {0, 0, 2, 0},
+
+  /* COND_JUMP states.  */
+  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (COND_JUMP, BIG)},
+  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (COND_JUMP, BIG16)},
+  /* dword conditionals adds 5 bytes to frag:
+     1 extra opcode byte, 4 displacement bytes.  */
+  {0, 0, 5, 0},
+  /* word conditionals add 3 bytes to frag:
+     1 extra opcode byte, 2 displacement bytes.  */
+  {0, 0, 3, 0},
+
+  /* COND_JUMP86 states.  */
+  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (COND_JUMP86, BIG)},
+  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (COND_JUMP86, BIG16)},
+  /* dword conditionals adds 5 bytes to frag:
+     1 extra opcode byte, 4 displacement bytes.  */
+  {0, 0, 5, 0},
+  /* word conditionals add 4 bytes to frag:
+     1 displacement byte and a 3 byte long branch insn.  */
+  {0, 0, 4, 0}
+};
+
+static const arch_entry cpu_arch[] =
+{
+  {"generic32", PROCESSOR_GENERIC32,
+   Cpu186|Cpu286|Cpu386},
+  {"generic64", PROCESSOR_GENERIC64,
+   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX
+   |CpuMMX2|CpuSSE|CpuSSE2},
+  {"i8086", PROCESSOR_UNKNOWN,
+   0},
+  {"i186", PROCESSOR_UNKNOWN,
+   Cpu186},
+  {"i286", PROCESSOR_UNKNOWN,
+   Cpu186|Cpu286},
+  {"i386", PROCESSOR_I386,
+   Cpu186|Cpu286|Cpu386},
+  {"i486", PROCESSOR_I486,
+   Cpu186|Cpu286|Cpu386|Cpu486},
+  {"i586", PROCESSOR_PENTIUM,
+   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586},
+  {"i686", PROCESSOR_PENTIUMPRO,
+   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686},
+  {"pentium", PROCESSOR_PENTIUM,
+   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586},
+  {"pentiumpro",PROCESSOR_PENTIUMPRO,
+   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686},
+  {"pentiumii",	PROCESSOR_PENTIUMPRO,
+   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuMMX},
+  {"pentiumiii",PROCESSOR_PENTIUMPRO,
+   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuMMX|CpuMMX2|CpuSSE},
+  {"pentium4", PROCESSOR_PENTIUM4,
+   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX
+   |CpuMMX2|CpuSSE|CpuSSE2},
+  {"prescott", PROCESSOR_NOCONA,
+   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX
+   |CpuMMX2|CpuSSE|CpuSSE2|CpuSSE3},
+  {"nocona", PROCESSOR_NOCONA,
+   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX
+   |CpuMMX2|CpuSSE|CpuSSE2|CpuSSE3},
+  {"yonah", PROCESSOR_CORE,
+   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX
+   |CpuMMX2|CpuSSE|CpuSSE2|CpuSSE3},
+  {"core", PROCESSOR_CORE,
+   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX
+   |CpuMMX2|CpuSSE|CpuSSE2|CpuSSE3},
+  {"merom", PROCESSOR_CORE2,
+   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX
+   |CpuMMX2|CpuSSE|CpuSSE2|CpuSSE3|CpuSSSE3},
+  {"core2", PROCESSOR_CORE2,
+   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX
+   |CpuMMX2|CpuSSE|CpuSSE2|CpuSSE3|CpuSSSE3},
+  {"k6", PROCESSOR_K6,
+   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|CpuK6|CpuMMX},
+  {"k6_2", PROCESSOR_K6,
+   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|CpuK6|CpuMMX|Cpu3dnow},
+  {"athlon", PROCESSOR_ATHLON,
+   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuK6
+   |CpuMMX|CpuMMX2|Cpu3dnow|Cpu3dnowA},
+  {"sledgehammer", PROCESSOR_K8,
+   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuK6
+   |CpuSledgehammer|CpuMMX|CpuMMX2|Cpu3dnow|Cpu3dnowA|CpuSSE|CpuSSE2},
+  {"opteron", PROCESSOR_K8,
+   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuK6
+   |CpuSledgehammer|CpuMMX|CpuMMX2|Cpu3dnow|Cpu3dnowA|CpuSSE|CpuSSE2},
+  {"k8", PROCESSOR_K8,
+   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuK6
+   |CpuSledgehammer|CpuMMX|CpuMMX2|Cpu3dnow|Cpu3dnowA|CpuSSE|CpuSSE2},
+  {"amdfam10", PROCESSOR_AMDFAM10,
+   Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuK6|CpuSledgehammer
+   |CpuMMX|CpuMMX2|Cpu3dnow|Cpu3dnowA|CpuSSE|CpuSSE2|CpuSSE3|CpuSSE4a
+   |CpuABM},
+  {".mmx", PROCESSOR_UNKNOWN,
+   CpuMMX},
+  {".sse", PROCESSOR_UNKNOWN,
+   CpuMMX|CpuMMX2|CpuSSE},
+  {".sse2", PROCESSOR_UNKNOWN,
+   CpuMMX|CpuMMX2|CpuSSE|CpuSSE2},
+  {".sse3", PROCESSOR_UNKNOWN,
+   CpuMMX|CpuMMX2|CpuSSE|CpuSSE2|CpuSSE3},
+  {".ssse3", PROCESSOR_UNKNOWN,
+   CpuMMX|CpuMMX2|CpuSSE|CpuSSE2|CpuSSE3|CpuSSSE3},
+  {".sse4.1", PROCESSOR_UNKNOWN,
+   CpuMMX|CpuMMX2|CpuSSE|CpuSSE2|CpuSSE3|CpuSSSE3|CpuSSE4_1},
+  {".sse4.2", PROCESSOR_UNKNOWN,
+   CpuMMX|CpuMMX2|CpuSSE|CpuSSE2|CpuSSE3|CpuSSSE3|CpuSSE4},
+  {".sse4", PROCESSOR_UNKNOWN,
+   CpuMMX|CpuMMX2|CpuSSE|CpuSSE2|CpuSSE3|CpuSSSE3|CpuSSE4},
+  {".3dnow", PROCESSOR_UNKNOWN,
+   CpuMMX|Cpu3dnow},
+  {".3dnowa", PROCESSOR_UNKNOWN,
+   CpuMMX|CpuMMX2|Cpu3dnow|Cpu3dnowA},
+  {".padlock", PROCESSOR_UNKNOWN,
+   CpuPadLock},
+  {".pacifica", PROCESSOR_UNKNOWN,
+   CpuSVME},
+  {".svme", PROCESSOR_UNKNOWN,
+   CpuSVME},
+  {".sse4a", PROCESSOR_UNKNOWN,
+   CpuMMX|CpuMMX2|CpuSSE|CpuSSE2|CpuSSE3|CpuSSE4a},
+  {".abm", PROCESSOR_UNKNOWN,
+   CpuABM}
+};
+
+const pseudo_typeS md_pseudo_table[] =
+{
+#if !defined(OBJ_AOUT) && !defined(USE_ALIGN_PTWO)
+  {"align", s_align_bytes, 0},
+#else
+  {"align", s_align_ptwo, 0},
+#endif
+  {"arch", set_cpu_arch, 0},
+#ifndef I386COFF
+  {"bss", s_bss, 0},
+#endif
+  {"ffloat", float_cons, 'f'},
+  {"dfloat", float_cons, 'd'},
+  {"tfloat", float_cons, 'x'},
+  {"value", cons, 2},
+  {"slong", signed_cons, 4},
+  {"noopt", s_ignore, 0},
+  {"optim", s_ignore, 0},
+  {"code16gcc", set_16bit_gcc_code_flag, CODE_16BIT},
+  {"code16", set_code_flag, CODE_16BIT},
+  {"code32", set_code_flag, CODE_32BIT},
+  {"code64", set_code_flag, CODE_64BIT},
+  {"intel_syntax", set_intel_syntax, 1},
+  {"att_syntax", set_intel_syntax, 0},
+#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
+  {"largecomm", handle_large_common, 0},
+#else
+  {"file", (void (*) (int)) dwarf2_directive_file, 0},
+  {"loc", dwarf2_directive_loc, 0},
+  {"loc_mark_labels", dwarf2_directive_loc_mark_labels, 0},
+#endif
+#ifdef TE_PE
+  {"secrel32", pe_directive_secrel, 0},
+#endif
+  {0, 0, 0}
+};
+
+/* For interface with expression ().  */
+extern char *input_line_pointer;
+
+/* Hash table for instruction mnemonic lookup.  */
+static struct hash_control *op_hash;
+
+/* Hash table for register lookup.  */
+static struct hash_control *reg_hash;
+
+void
+i386_align_code (fragS *fragP, int count)
+{
+  /* Various efficient no-op patterns for aligning code labels.
+     Note: Don't try to assemble the instructions in the comments.
+     0L and 0w are not legal.  */
+  static const char f32_1[] =
+    {0x90};					/* nop			*/
+  static const char f32_2[] =
+    {0x66,0x90};				/* xchg %ax,%ax */
+  static const char f32_3[] =
+    {0x8d,0x76,0x00};				/* leal 0(%esi),%esi	*/
+  static const char f32_4[] =
+    {0x8d,0x74,0x26,0x00};			/* leal 0(%esi,1),%esi	*/
+  static const char f32_5[] =
+    {0x90,					/* nop			*/
+     0x8d,0x74,0x26,0x00};			/* leal 0(%esi,1),%esi	*/
+  static const char f32_6[] =
+    {0x8d,0xb6,0x00,0x00,0x00,0x00};		/* leal 0L(%esi),%esi	*/
+  static const char f32_7[] =
+    {0x8d,0xb4,0x26,0x00,0x00,0x00,0x00};	/* leal 0L(%esi,1),%esi */
+  static const char f32_8[] =
+    {0x90,					/* nop			*/
+     0x8d,0xb4,0x26,0x00,0x00,0x00,0x00};	/* leal 0L(%esi,1),%esi */
+  static const char f32_9[] =
+    {0x89,0xf6,					/* movl %esi,%esi	*/
+     0x8d,0xbc,0x27,0x00,0x00,0x00,0x00};	/* leal 0L(%edi,1),%edi */
+  static const char f32_10[] =
+    {0x8d,0x76,0x00,				/* leal 0(%esi),%esi	*/
+     0x8d,0xbc,0x27,0x00,0x00,0x00,0x00};	/* leal 0L(%edi,1),%edi */
+  static const char f32_11[] =
+    {0x8d,0x74,0x26,0x00,			/* leal 0(%esi,1),%esi	*/
+     0x8d,0xbc,0x27,0x00,0x00,0x00,0x00};	/* leal 0L(%edi,1),%edi */
+  static const char f32_12[] =
+    {0x8d,0xb6,0x00,0x00,0x00,0x00,		/* leal 0L(%esi),%esi	*/
+     0x8d,0xbf,0x00,0x00,0x00,0x00};		/* leal 0L(%edi),%edi	*/
+  static const char f32_13[] =
+    {0x8d,0xb6,0x00,0x00,0x00,0x00,		/* leal 0L(%esi),%esi	*/
+     0x8d,0xbc,0x27,0x00,0x00,0x00,0x00};	/* leal 0L(%edi,1),%edi */
+  static const char f32_14[] =
+    {0x8d,0xb4,0x26,0x00,0x00,0x00,0x00,	/* leal 0L(%esi,1),%esi */
+     0x8d,0xbc,0x27,0x00,0x00,0x00,0x00};	/* leal 0L(%edi,1),%edi */
+  static const char f16_3[] =
+    {0x8d,0x74,0x00};				/* lea 0(%esi),%esi	*/
+  static const char f16_4[] =
+    {0x8d,0xb4,0x00,0x00};			/* lea 0w(%si),%si	*/
+  static const char f16_5[] =
+    {0x90,					/* nop			*/
+     0x8d,0xb4,0x00,0x00};			/* lea 0w(%si),%si	*/
+  static const char f16_6[] =
+    {0x89,0xf6,					/* mov %si,%si		*/
+     0x8d,0xbd,0x00,0x00};			/* lea 0w(%di),%di	*/
+  static const char f16_7[] =
+    {0x8d,0x74,0x00,				/* lea 0(%si),%si	*/
+     0x8d,0xbd,0x00,0x00};			/* lea 0w(%di),%di	*/
+  static const char f16_8[] =
+    {0x8d,0xb4,0x00,0x00,			/* lea 0w(%si),%si	*/
+     0x8d,0xbd,0x00,0x00};			/* lea 0w(%di),%di	*/
+  static const char jump_31[] =
+    {0xeb,0x1d,0x90,0x90,0x90,0x90,0x90,	/* jmp .+31; lotsa nops	*/
+     0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,
+     0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,
+     0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90};
+  static const char *const f32_patt[] = {
+    f32_1, f32_2, f32_3, f32_4, f32_5, f32_6, f32_7, f32_8,
+    f32_9, f32_10, f32_11, f32_12, f32_13, f32_14
+  };
+  static const char *const f16_patt[] = {
+    f32_1, f32_2, f16_3, f16_4, f16_5, f16_6, f16_7, f16_8
+  };
+  /* nopl (%[re]ax) */
+  static const char alt_3[] =
+    {0x0f,0x1f,0x00};
+  /* nopl 0(%[re]ax) */
+  static const char alt_4[] =
+    {0x0f,0x1f,0x40,0x00};
+  /* nopl 0(%[re]ax,%[re]ax,1) */
+  static const char alt_5[] =
+    {0x0f,0x1f,0x44,0x00,0x00};
+  /* nopw 0(%[re]ax,%[re]ax,1) */
+  static const char alt_6[] =
+    {0x66,0x0f,0x1f,0x44,0x00,0x00};
+  /* nopl 0L(%[re]ax) */
+  static const char alt_7[] =
+    {0x0f,0x1f,0x80,0x00,0x00,0x00,0x00};
+  /* nopl 0L(%[re]ax,%[re]ax,1) */
+  static const char alt_8[] =
+    {0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00};
+  /* nopw 0L(%[re]ax,%[re]ax,1) */
+  static const char alt_9[] =
+    {0x66,0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00};
+  /* nopw %cs:0L(%[re]ax,%[re]ax,1) */
+  static const char alt_10[] =
+    {0x66,0x2e,0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00};
+  /* data16
+     nopw %cs:0L(%[re]ax,%[re]ax,1) */
+  static const char alt_long_11[] =
+    {0x66,
+     0x66,0x2e,0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00};
+  /* data16
+     data16
+     nopw %cs:0L(%[re]ax,%[re]ax,1) */
+  static const char alt_long_12[] =
+    {0x66,
+     0x66,
+     0x66,0x2e,0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00};
+  /* data16
+     data16
+     data16
+     nopw %cs:0L(%[re]ax,%[re]ax,1) */
+  static const char alt_long_13[] =
+    {0x66,
+     0x66,
+     0x66,
+     0x66,0x2e,0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00};
+  /* data16
+     data16
+     data16
+     data16
+     nopw %cs:0L(%[re]ax,%[re]ax,1) */
+  static const char alt_long_14[] =
+    {0x66,
+     0x66,
+     0x66,
+     0x66,
+     0x66,0x2e,0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00};
+  /* data16
+     data16
+     data16
+     data16
+     data16
+     nopw %cs:0L(%[re]ax,%[re]ax,1) */
+  static const char alt_long_15[] =
+    {0x66,
+     0x66,
+     0x66,
+     0x66,
+     0x66,
+     0x66,0x2e,0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00};
+  /* nopl 0(%[re]ax,%[re]ax,1)
+     nopw 0(%[re]ax,%[re]ax,1) */
+  static const char alt_short_11[] =
+    {0x0f,0x1f,0x44,0x00,0x00,
+     0x66,0x0f,0x1f,0x44,0x00,0x00};
+  /* nopw 0(%[re]ax,%[re]ax,1)
+     nopw 0(%[re]ax,%[re]ax,1) */
+  static const char alt_short_12[] =
+    {0x66,0x0f,0x1f,0x44,0x00,0x00,
+     0x66,0x0f,0x1f,0x44,0x00,0x00};
+  /* nopw 0(%[re]ax,%[re]ax,1)
+     nopl 0L(%[re]ax) */
+  static const char alt_short_13[] =
+    {0x66,0x0f,0x1f,0x44,0x00,0x00,
+     0x0f,0x1f,0x80,0x00,0x00,0x00,0x00};
+  /* nopl 0L(%[re]ax)
+     nopl 0L(%[re]ax) */
+  static const char alt_short_14[] =
+    {0x0f,0x1f,0x80,0x00,0x00,0x00,0x00,
+     0x0f,0x1f,0x80,0x00,0x00,0x00,0x00};
+  /* nopl 0L(%[re]ax)
+     nopl 0L(%[re]ax,%[re]ax,1) */
+  static const char alt_short_15[] =
+    {0x0f,0x1f,0x80,0x00,0x00,0x00,0x00,
+     0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00};
+  static const char *const alt_short_patt[] = {
+    f32_1, f32_2, alt_3, alt_4, alt_5, alt_6, alt_7, alt_8,
+    alt_9, alt_10, alt_short_11, alt_short_12, alt_short_13,
+    alt_short_14, alt_short_15
+  };
+  static const char *const alt_long_patt[] = {
+    f32_1, f32_2, alt_3, alt_4, alt_5, alt_6, alt_7, alt_8,
+    alt_9, alt_10, alt_long_11, alt_long_12, alt_long_13,
+    alt_long_14, alt_long_15
+  };
+
+  /* Only align for at least a positive non-zero boundary. */
+  if (count <= 0 || count > MAX_MEM_FOR_RS_ALIGN_CODE)
+    return;
+
+  /* We need to decide which NOP sequence to use for 32bit and
+     64bit. When -mtune= is used:
+
+     1. For PROCESSOR_I386, PROCESSOR_I486, PROCESSOR_PENTIUM and
+     PROCESSOR_GENERIC32, f32_patt will be used.
+     2. For PROCESSOR_PENTIUMPRO, PROCESSOR_PENTIUM4, PROCESSOR_NOCONA,
+     PROCESSOR_CORE, PROCESSOR_CORE2, and PROCESSOR_GENERIC64,
+     alt_long_patt will be used.
+     3. For PROCESSOR_ATHLON, PROCESSOR_K6, PROCESSOR_K8 and
+     PROCESSOR_AMDFAM10, alt_short_patt will be used.
+
+     When -mtune= isn't used, alt_long_patt will be used if
+     cpu_arch_isa_flags has Cpu686. Otherwise, f32_patt will
+     be used.
+
+     When -march= or .arch is used, we can't use anything beyond
+     cpu_arch_isa_flags.   */
+
+  if (flag_code == CODE_16BIT)
+    {
+      if (count > 8)
+	{
+	  memcpy (fragP->fr_literal + fragP->fr_fix,
+		  jump_31, count);
+	  /* Adjust jump offset.  */
+	  fragP->fr_literal[fragP->fr_fix + 1] = count - 2;
+	}
+      else
+	memcpy (fragP->fr_literal + fragP->fr_fix,
+		f16_patt[count - 1], count);
+    }
+  else
+    {
+      const char *const *patt = NULL;
+
+      if (cpu_arch_isa == PROCESSOR_UNKNOWN)
+	{
+	  /* PROCESSOR_UNKNOWN means that all ISAs may be used.  */
+	  switch (cpu_arch_tune)
+	    {
+	    case PROCESSOR_UNKNOWN:
+	      /* We use cpu_arch_isa_flags to check if we SHOULD
+		 optimize for Cpu686.  */
+	      if ((cpu_arch_isa_flags & Cpu686) != 0)
+		patt = alt_long_patt;
+	      else
+		patt = f32_patt;
+	      break;
+	    case PROCESSOR_PENTIUMPRO:
+	    case PROCESSOR_PENTIUM4:
+	    case PROCESSOR_NOCONA:
+	    case PROCESSOR_CORE:
+	    case PROCESSOR_CORE2:
+	    case PROCESSOR_GENERIC64:
+	      patt = alt_long_patt;
+	      break;
+	    case PROCESSOR_K6:
+	    case PROCESSOR_ATHLON:
+	    case PROCESSOR_K8:
+	    case PROCESSOR_AMDFAM10:
+	      patt = alt_short_patt;
+	      break;
+	    case PROCESSOR_I386:
+	    case PROCESSOR_I486:
+	    case PROCESSOR_PENTIUM:
+	    case PROCESSOR_GENERIC32:
+	      patt = f32_patt;
+	      break;
+	    }
+	}
+      else
+	{
+	  switch (cpu_arch_tune)
+	    {
+	    case PROCESSOR_UNKNOWN:
+	      /* When cpu_arch_isa is net, cpu_arch_tune shouldn't be
+		 PROCESSOR_UNKNOWN.  */
+	      abort ();
+	      break;
+
+	    case PROCESSOR_I386:
+	    case PROCESSOR_I486:
+	    case PROCESSOR_PENTIUM:
+	    case PROCESSOR_K6:
+	    case PROCESSOR_ATHLON:
+	    case PROCESSOR_K8:
+	    case PROCESSOR_AMDFAM10:
+	    case PROCESSOR_GENERIC32:
+	      /* We use cpu_arch_isa_flags to check if we CAN optimize
+		 for Cpu686.  */
+	      if ((cpu_arch_isa_flags & Cpu686) != 0)
+		patt = alt_short_patt;
+	      else
+		patt = f32_patt;
+	      break;
+	    case PROCESSOR_PENTIUMPRO:
+	    case PROCESSOR_PENTIUM4:
+	    case PROCESSOR_NOCONA:
+	    case PROCESSOR_CORE:
+	    case PROCESSOR_CORE2:
+	      if ((cpu_arch_isa_flags & Cpu686) != 0)
+		patt = alt_long_patt;
+	      else
+		patt = f32_patt;
+	      break;
+	    case PROCESSOR_GENERIC64:
+	      patt = alt_long_patt;
+	      break;
+	    }
+	}
+
+      if (patt == f32_patt)
+	{
+	  /* If the padding is less than 15 bytes, we use the normal
+	     ones.  Otherwise, we use a jump instruction and adjust
+	     its offset.  */
+	  if (count < 15)
+	    memcpy (fragP->fr_literal + fragP->fr_fix,
+		    patt[count - 1], count);
+	  else
+	    {
+	      memcpy (fragP->fr_literal + fragP->fr_fix,
+		      jump_31, count);
+	      /* Adjust jump offset.  */
+	      fragP->fr_literal[fragP->fr_fix + 1] = count - 2;
+	    }
+	}
+      else
+	{
+	  /* Maximum length of an instruction is 15 byte.  If the
+	     padding is greater than 15 bytes and we don't use jump,
+	     we have to break it into smaller pieces.  */
+	  int padding = count;
+	  while (padding > 15)
+	    {
+	      padding -= 15;
+	      memcpy (fragP->fr_literal + fragP->fr_fix + padding,
+		      patt [14], 15);
+	    }
+
+	  if (padding)
+	    memcpy (fragP->fr_literal + fragP->fr_fix,
+		    patt [padding - 1], padding);
+	}
+    }
+  fragP->fr_var = count;
+}
+
+static INLINE unsigned int
+mode_from_disp_size (unsigned int t)
+{
+  return (t & Disp8) ? 1 : (t & (Disp16 | Disp32 | Disp32S)) ? 2 : 0;
+}
+
+static INLINE int
+fits_in_signed_byte (offsetT num)
+{
+  return (num >= -128) && (num <= 127);
+}
+
+static INLINE int
+fits_in_unsigned_byte (offsetT num)
+{
+  return (num & 0xff) == num;
+}
+
+static INLINE int
+fits_in_unsigned_word (offsetT num)
+{
+  return (num & 0xffff) == num;
+}
+
+static INLINE int
+fits_in_signed_word (offsetT num)
+{
+  return (-32768 <= num) && (num <= 32767);
+}
+
+static INLINE int
+fits_in_signed_long (offsetT num ATTRIBUTE_UNUSED)
+{
+#ifndef BFD64
+  return 1;
+#else
+  return (!(((offsetT) -1 << 31) & num)
+	  || (((offsetT) -1 << 31) & num) == ((offsetT) -1 << 31));
+#endif
+}				/* fits_in_signed_long() */
+
+static INLINE int
+fits_in_unsigned_long (offsetT num ATTRIBUTE_UNUSED)
+{
+#ifndef BFD64
+  return 1;
+#else
+  return (num & (((offsetT) 2 << 31) - 1)) == num;
+#endif
+}				/* fits_in_unsigned_long() */
+
+static unsigned int
+smallest_imm_type (offsetT num)
+{
+  if (cpu_arch_flags != (Cpu186 | Cpu286 | Cpu386 | Cpu486 | CpuNo64))
+    {
+      /* This code is disabled on the 486 because all the Imm1 forms
+	 in the opcode table are slower on the i486.  They're the
+	 versions with the implicitly specified single-position
+	 displacement, which has another syntax if you really want to
+	 use that form.  */
+      if (num == 1)
+	return Imm1 | Imm8 | Imm8S | Imm16 | Imm32 | Imm32S | Imm64;
+    }
+  return (fits_in_signed_byte (num)
+	  ? (Imm8S | Imm8 | Imm16 | Imm32 | Imm32S | Imm64)
+	  : fits_in_unsigned_byte (num)
+	  ? (Imm8 | Imm16 | Imm32 | Imm32S | Imm64)
+	  : (fits_in_signed_word (num) || fits_in_unsigned_word (num))
+	  ? (Imm16 | Imm32 | Imm32S | Imm64)
+	  : fits_in_signed_long (num)
+	  ? (Imm32 | Imm32S | Imm64)
+	  : fits_in_unsigned_long (num)
+	  ? (Imm32 | Imm64)
+	  : Imm64);
+}
+
+static offsetT
+offset_in_range (offsetT val, int size)
+{
+  addressT mask;
+
+  switch (size)
+    {
+    case 1: mask = ((addressT) 1 <<  8) - 1; break;
+    case 2: mask = ((addressT) 1 << 16) - 1; break;
+    case 4: mask = ((addressT) 2 << 31) - 1; break;
+#ifdef BFD64
+    case 8: mask = ((addressT) 2 << 63) - 1; break;
+#endif
+    default: abort ();
+    }
+
+  /* If BFD64, sign extend val.  */
+  if (!use_rela_relocations)
+    if ((val & ~(((addressT) 2 << 31) - 1)) == 0)
+      val = (val ^ ((addressT) 1 << 31)) - ((addressT) 1 << 31);
+
+  if ((val & ~mask) != 0 && (val & ~mask) != ~mask)
+    {
+      char buf1[40], buf2[40];
+
+      sprint_value (buf1, val);
+      sprint_value (buf2, val & mask);
+      as_warn (_("%s shortened to %s"), buf1, buf2);
+    }
+  return val & mask;
+}
+
+/* Returns 0 if attempting to add a prefix where one from the same
+   class already exists, 1 if non rep/repne added, 2 if rep/repne
+   added.  */
+static int
+add_prefix (unsigned int prefix)
+{
+  int ret = 1;
+  unsigned int q;
+
+  if (prefix >= REX_OPCODE && prefix < REX_OPCODE + 16
+      && flag_code == CODE_64BIT)
+    {
+      if ((i.prefix[REX_PREFIX] & prefix & REX_W)
+	  || ((i.prefix[REX_PREFIX] & (REX_R | REX_X | REX_B))
+	      && (prefix & (REX_R | REX_X | REX_B))))
+	ret = 0;
+      q = REX_PREFIX;
+    }
+  else
+    {
+      switch (prefix)
+	{
+	default:
+	  abort ();
+
+	case CS_PREFIX_OPCODE:
+	case DS_PREFIX_OPCODE:
+	case ES_PREFIX_OPCODE:
+	case FS_PREFIX_OPCODE:
+	case GS_PREFIX_OPCODE:
+	case SS_PREFIX_OPCODE:
+	  q = SEG_PREFIX;
+	  break;
+
+	case REPNE_PREFIX_OPCODE:
+	case REPE_PREFIX_OPCODE:
+	  ret = 2;
+	  /* fall thru */
+	case LOCK_PREFIX_OPCODE:
+	  q = LOCKREP_PREFIX;
+	  break;
+
+	case FWAIT_OPCODE:
+	  q = WAIT_PREFIX;
+	  break;
+
+	case ADDR_PREFIX_OPCODE:
+	  q = ADDR_PREFIX;
+	  break;
+
+	case DATA_PREFIX_OPCODE:
+	  q = DATA_PREFIX;
+	  break;
+	}
+      if (i.prefix[q] != 0)
+	ret = 0;
+    }
+
+  if (ret)
+    {
+      if (!i.prefix[q])
+	++i.prefixes;
+      i.prefix[q] |= prefix;
+    }
+  else
+    as_bad (_("same type of prefix used twice"));
+
+  return ret;
+}
+
+static void
+set_code_flag (int value)
+{
+  flag_code = value;
+  cpu_arch_flags &= ~(Cpu64 | CpuNo64);
+  cpu_arch_flags |= (flag_code == CODE_64BIT ? Cpu64 : CpuNo64);
+  if (value == CODE_64BIT && !(cpu_arch_flags & CpuSledgehammer))
+    {
+      as_bad (_("64bit mode not supported on this CPU."));
+    }
+  if (value == CODE_32BIT && !(cpu_arch_flags & Cpu386))
+    {
+      as_bad (_("32bit mode not supported on this CPU."));
+    }
+  stackop_size = '\0';
+}
+
+static void
+set_16bit_gcc_code_flag (int new_code_flag)
+{
+  flag_code = new_code_flag;
+  cpu_arch_flags &= ~(Cpu64 | CpuNo64);
+  cpu_arch_flags |= (flag_code == CODE_64BIT ? Cpu64 : CpuNo64);
+  stackop_size = LONG_MNEM_SUFFIX;
+}
+
+static void
+set_intel_syntax (int syntax_flag)
+{
+  /* Find out if register prefixing is specified.  */
+  int ask_naked_reg = 0;
+
+  SKIP_WHITESPACE ();
+  if (!is_end_of_line[(unsigned char) *input_line_pointer])
+    {
+      char *string = input_line_pointer;
+      int e = get_symbol_end ();
+
+      if (strcmp (string, "prefix") == 0)
+	ask_naked_reg = 1;
+      else if (strcmp (string, "noprefix") == 0)
+	ask_naked_reg = -1;
+      else
+	as_bad (_("bad argument to syntax directive."));
+      *input_line_pointer = e;
+    }
+  demand_empty_rest_of_line ();
+
+  intel_syntax = syntax_flag;
+
+  if (ask_naked_reg == 0)
+    allow_naked_reg = (intel_syntax
+		       && (bfd_get_symbol_leading_char (stdoutput) != '\0'));
+  else
+    allow_naked_reg = (ask_naked_reg < 0);
+
+  identifier_chars['%'] = intel_syntax && allow_naked_reg ? '%' : 0;
+  identifier_chars['$'] = intel_syntax ? '$' : 0;
+  register_prefix = allow_naked_reg ? "" : "%";
+}
+
+static void
+set_cpu_arch (int dummy ATTRIBUTE_UNUSED)
+{
+  SKIP_WHITESPACE ();
+
+  if (!is_end_of_line[(unsigned char) *input_line_pointer])
+    {
+      char *string = input_line_pointer;
+      int e = get_symbol_end ();
+      unsigned int i;
+
+      for (i = 0; i < ARRAY_SIZE (cpu_arch); i++)
+	{
+	  if (strcmp (string, cpu_arch[i].name) == 0)
+	    {
+	      if (*string != '.')
+		{
+		  cpu_arch_name = cpu_arch[i].name;
+		  cpu_sub_arch_name = NULL;
+		  cpu_arch_flags = (cpu_arch[i].flags
+				    | (flag_code == CODE_64BIT
+				       ? Cpu64 : CpuNo64));
+		  cpu_arch_isa = cpu_arch[i].type;
+		  cpu_arch_isa_flags = cpu_arch[i].flags;
+		  if (!cpu_arch_tune_set)
+		    {
+		      cpu_arch_tune = cpu_arch_isa;
+		      cpu_arch_tune_flags = cpu_arch_isa_flags;
+		    }
+		  break;
+		}
+	      if ((cpu_arch_flags | cpu_arch[i].flags) != cpu_arch_flags)
+		{
+		  cpu_sub_arch_name = cpu_arch[i].name;
+		  cpu_arch_flags |= cpu_arch[i].flags;
+		}
+	      *input_line_pointer = e;
+	      demand_empty_rest_of_line ();
+	      return;
+	    }
+	}
+      if (i >= ARRAY_SIZE (cpu_arch))
+	as_bad (_("no such architecture: `%s'"), string);
+
+      *input_line_pointer = e;
+    }
+  else
+    as_bad (_("missing cpu architecture"));
+
+  no_cond_jump_promotion = 0;
+  if (*input_line_pointer == ','
+      && !is_end_of_line[(unsigned char) input_line_pointer[1]])
+    {
+      char *string = ++input_line_pointer;
+      int e = get_symbol_end ();
+
+      if (strcmp (string, "nojumps") == 0)
+	no_cond_jump_promotion = 1;
+      else if (strcmp (string, "jumps") == 0)
+	;
+      else
+	as_bad (_("no such architecture modifier: `%s'"), string);
+
+      *input_line_pointer = e;
+    }
+
+  demand_empty_rest_of_line ();
+}
+
+unsigned long
+i386_mach ()
+{
+  if (!strcmp (default_arch, "x86_64"))
+    return bfd_mach_x86_64;
+  else if (!strcmp (default_arch, "i386"))
+    return bfd_mach_i386_i386;
+  else
+    as_fatal (_("Unknown architecture"));
+}
+
+void
+nativeclient_symbol_init ()
+{
+  symbolS *symbolP;
+  int entry_align;
+
+  /*
+   * A symbol conveying the setting of nacl_alignment to assembler writers.
+   */
+  symbolP = symbol_new ("NACLALIGN", absolute_section,
+			(valueT) nacl_alignment, &zero_address_frag);
+  symbol_table_insert (symbolP);
+
+  /*
+   * A symbol conveying the function entry alignment.  This differs from
+   * NACLALIGN in library mode.
+   */
+  if (nacl_library_mode) {
+    entry_align = 5;
+  }
+  else {
+    entry_align = nacl_alignment;
+  }
+  symbolP = symbol_new ("NACLENTRYALIGN", absolute_section,
+			(valueT) entry_align, &zero_address_frag);
+  symbol_table_insert (symbolP);
+}
+
+void
+md_begin ()
+{
+  const char *hash_err;
+
+  /* Initialize op_hash hash table.  */
+  op_hash = hash_new ();
+
+  {
+    const template *optab;
+    templates *core_optab;
+
+    /* Setup for loop.  */
+    optab = i386_optab;
+    core_optab = (templates *) xmalloc (sizeof (templates));
+    core_optab->start = optab;
+
+    while (1)
+      {
+	++optab;
+	if (optab->name == NULL
+	    || strcmp (optab->name, (optab - 1)->name) != 0)
+	  {
+	    /* different name --> ship out current template list;
+	       add to hash table; & begin anew.  */
+	    core_optab->end = optab;
+	    hash_err = hash_insert (op_hash,
+				    (optab - 1)->name,
+				    (PTR) core_optab);
+	    if (hash_err)
+	      {
+		as_fatal (_("Internal Error:  Can't hash %s: %s"),
+			  (optab - 1)->name,
+			  hash_err);
+	      }
+	    if (optab->name == NULL)
+	      break;
+	    core_optab = (templates *) xmalloc (sizeof (templates));
+	    core_optab->start = optab;
+	  }
+      }
+  }
+
+  /* Initialize reg_hash hash table.  */
+  reg_hash = hash_new ();
+  {
+    const reg_entry *regtab;
+    unsigned int regtab_size = i386_regtab_size;
+
+    for (regtab = i386_regtab; regtab_size--; regtab++)
+      {
+	hash_err = hash_insert (reg_hash, regtab->reg_name, (PTR) regtab);
+	if (hash_err)
+	  as_fatal (_("Internal Error:  Can't hash %s: %s"),
+		    regtab->reg_name,
+		    hash_err);
+      }
+  }
+
+  /* Fill in lexical tables:  mnemonic_chars, operand_chars.  */
+  {
+    int c;
+    char *p;
+
+    for (c = 0; c < 256; c++)
+      {
+	if (ISDIGIT (c))
+	  {
+	    digit_chars[c] = c;
+	    mnemonic_chars[c] = c;
+	    register_chars[c] = c;
+	    operand_chars[c] = c;
+	  }
+	else if (ISLOWER (c))
+	  {
+	    mnemonic_chars[c] = c;
+	    register_chars[c] = c;
+	    operand_chars[c] = c;
+	  }
+	else if (ISUPPER (c))
+	  {
+	    mnemonic_chars[c] = TOLOWER (c);
+	    register_chars[c] = mnemonic_chars[c];
+	    operand_chars[c] = c;
+	  }
+
+	if (ISALPHA (c) || ISDIGIT (c))
+	  identifier_chars[c] = c;
+	else if (c >= 128)
+	  {
+	    identifier_chars[c] = c;
+	    operand_chars[c] = c;
+	  }
+      }
+
+#ifdef LEX_AT
+    identifier_chars['@'] = '@';
+#endif
+#ifdef LEX_QM
+    identifier_chars['?'] = '?';
+    operand_chars['?'] = '?';
+#endif
+    digit_chars['-'] = '-';
+    mnemonic_chars['-'] = '-';
+    mnemonic_chars['.'] = '.';
+    identifier_chars['_'] = '_';
+    identifier_chars['.'] = '.';
+
+    for (p = operand_special_chars; *p != '\0'; p++)
+      operand_chars[(unsigned char) *p] = *p;
+  }
+
+#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
+  if (IS_ELF)
+    {
+      record_alignment (text_section, nacl_alignment);
+      record_alignment (data_section, 2);
+      record_alignment (bss_section, 2);
+    }
+#endif
+
+  if (flag_code == CODE_64BIT)
+    {
+      x86_dwarf2_return_column = 16;
+      x86_cie_data_alignment = -8;
+    }
+  else
+    {
+      x86_dwarf2_return_column = 8;
+      x86_cie_data_alignment = -4;
+    }
+
+  nativeclient_symbol_init();
+}
+
+void
+i386_print_statistics (FILE *file)
+{
+  hash_print_statistics (file, "i386 opcode", op_hash);
+  hash_print_statistics (file, "i386 register", reg_hash);
+}
+
+#ifdef DEBUG386
+
+/* Debugging routines for md_assemble.  */
+static void pte (template *);
+static void pt (unsigned int);
+static void pe (expressionS *);
+static void ps (symbolS *);
+
+static void
+pi (char *line, i386_insn *x)
+{
+  unsigned int i;
+
+  fprintf (stdout, "%s: template ", line);
+  pte (&x->tm);
+  fprintf (stdout, "  address: base %s  index %s  scale %x\n",
+	   x->base_reg ? x->base_reg->reg_name : "none",
+	   x->index_reg ? x->index_reg->reg_name : "none",
+	   x->log2_scale_factor);
+  fprintf (stdout, "  modrm:  mode %x  reg %x  reg/mem %x\n",
+	   x->rm.mode, x->rm.reg, x->rm.regmem);
+  fprintf (stdout, "  sib:  base %x  index %x  scale %x\n",
+	   x->sib.base, x->sib.index, x->sib.scale);
+  fprintf (stdout, "  rex: 64bit %x  extX %x  extY %x  extZ %x\n",
+	   (x->rex & REX_W) != 0,
+	   (x->rex & REX_R) != 0,
+	   (x->rex & REX_X) != 0,
+	   (x->rex & REX_B) != 0);
+  for (i = 0; i < x->operands; i++)
+    {
+      fprintf (stdout, "    #%d:  ", i + 1);
+      pt (x->types[i]);
+      fprintf (stdout, "\n");
+      if (x->types[i]
+	  & (Reg | SReg2 | SReg3 | Control | Debug | Test | RegMMX | RegXMM))
+	fprintf (stdout, "%s\n", x->op[i].regs->reg_name);
+      if (x->types[i] & Imm)
+	pe (x->op[i].imms);
+      if (x->types[i] & Disp)
+	pe (x->op[i].disps);
+    }
+}
+
+static void
+pte (template *t)
+{
+  unsigned int i;
+  fprintf (stdout, " %d operands ", t->operands);
+  fprintf (stdout, "opcode %x ", t->base_opcode);
+  if (t->extension_opcode != None)
+    fprintf (stdout, "ext %x ", t->extension_opcode);
+  if (t->opcode_modifier & D)
+    fprintf (stdout, "D");
+  if (t->opcode_modifier & W)
+    fprintf (stdout, "W");
+  fprintf (stdout, "\n");
+  for (i = 0; i < t->operands; i++)
+    {
+      fprintf (stdout, "    #%d type ", i + 1);
+      pt (t->operand_types[i]);
+      fprintf (stdout, "\n");
+    }
+}
+
+static void
+pe (expressionS *e)
+{
+  fprintf (stdout, "    operation     %d\n", e->X_op);
+  fprintf (stdout, "    add_number    %ld (%lx)\n",
+	   (long) e->X_add_number, (long) e->X_add_number);
+  if (e->X_add_symbol)
+    {
+      fprintf (stdout, "    add_symbol    ");
+      ps (e->X_add_symbol);
+      fprintf (stdout, "\n");
+    }
+  if (e->X_op_symbol)
+    {
+      fprintf (stdout, "    op_symbol    ");
+      ps (e->X_op_symbol);
+      fprintf (stdout, "\n");
+    }
+}
+
+static void
+ps (symbolS *s)
+{
+  fprintf (stdout, "%s type %s%s",
+	   S_GET_NAME (s),
+	   S_IS_EXTERNAL (s) ? "EXTERNAL " : "",
+	   segment_name (S_GET_SEGMENT (s)));
+}
+
+static struct type_name
+  {
+    unsigned int mask;
+    char *tname;
+  }
+const type_names[] =
+{
+  { Reg8, "r8" },
+  { Reg16, "r16" },
+  { Reg32, "r32" },
+  { Reg64, "r64" },
+  { Imm8, "i8" },
+  { Imm8S, "i8s" },
+  { Imm16, "i16" },
+  { Imm32, "i32" },
+  { Imm32S, "i32s" },
+  { Imm64, "i64" },
+  { Imm1, "i1" },
+  { BaseIndex, "BaseIndex" },
+  { Disp8, "d8" },
+  { Disp16, "d16" },
+  { Disp32, "d32" },
+  { Disp32S, "d32s" },
+  { Disp64, "d64" },
+  { InOutPortReg, "InOutPortReg" },
+  { ShiftCount, "ShiftCount" },
+  { Control, "control reg" },
+  { Test, "test reg" },
+  { Debug, "debug reg" },
+  { FloatReg, "FReg" },
+  { FloatAcc, "FAcc" },
+  { SReg2, "SReg2" },
+  { SReg3, "SReg3" },
+  { Acc, "Acc" },
+  { JumpAbsolute, "Jump Absolute" },
+  { RegMMX, "rMMX" },
+  { RegXMM, "rXMM" },
+  { EsSeg, "es" },
+  { 0, "" }
+};
+
+static void
+pt (t)
+     unsigned int t;
+{
+  const struct type_name *ty;
+
+  for (ty = type_names; ty->mask; ty++)
+    if (t & ty->mask)
+      fprintf (stdout, "%s, ", ty->tname);
+  fflush (stdout);
+}
+
+#endif /* DEBUG386 */
+
+static bfd_reloc_code_real_type
+reloc (unsigned int size,
+       int pcrel,
+       int sign,
+       bfd_reloc_code_real_type other)
+{
+  if (other != NO_RELOC)
+    {
+      reloc_howto_type *reloc;
+
+      if (size == 8)
+	switch (other)
+	  {
+	  case BFD_RELOC_X86_64_GOT32:
+	    return BFD_RELOC_X86_64_GOT64;
+	    break;
+	  case BFD_RELOC_X86_64_PLTOFF64:
+	    return BFD_RELOC_X86_64_PLTOFF64;
+	    break;
+	  case BFD_RELOC_X86_64_GOTPC32:
+	    other = BFD_RELOC_X86_64_GOTPC64;
+	    break;
+	  case BFD_RELOC_X86_64_GOTPCREL:
+	    other = BFD_RELOC_X86_64_GOTPCREL64;
+	    break;
+	  case BFD_RELOC_X86_64_TPOFF32:
+	    other = BFD_RELOC_X86_64_TPOFF64;
+	    break;
+	  case BFD_RELOC_X86_64_DTPOFF32:
+	    other = BFD_RELOC_X86_64_DTPOFF64;
+	    break;
+	  default:
+	    break;
+	  }
+
+      /* Sign-checking 4-byte relocations in 16-/32-bit code is pointless.  */
+      if (size == 4 && flag_code != CODE_64BIT)
+	sign = -1;
+
+      reloc = bfd_reloc_type_lookup (stdoutput, other);
+      if (!reloc)
+	as_bad (_("unknown relocation (%u)"), other);
+      else if (size != bfd_get_reloc_size (reloc))
+	as_bad (_("%u-byte relocation cannot be applied to %u-byte field"),
+		bfd_get_reloc_size (reloc),
+		size);
+      else if (pcrel && !reloc->pc_relative)
+	as_bad (_("non-pc-relative relocation for pc-relative field"));
+      else if ((reloc->complain_on_overflow == complain_overflow_signed
+		&& !sign)
+	       || (reloc->complain_on_overflow == complain_overflow_unsigned
+		   && sign > 0))
+	as_bad (_("relocated field and relocation type differ in signedness"));
+      else
+	return other;
+      return NO_RELOC;
+    }
+
+  if (pcrel)
+    {
+      if (!sign)
+	as_bad (_("there are no unsigned pc-relative relocations"));
+      switch (size)
+	{
+	case 1: return BFD_RELOC_8_PCREL;
+	case 2: return BFD_RELOC_16_PCREL;
+	case 4: return BFD_RELOC_32_PCREL;
+	case 8: return BFD_RELOC_64_PCREL;
+	}
+      as_bad (_("cannot do %u byte pc-relative relocation"), size);
+    }
+  else
+    {
+      if (sign > 0)
+	switch (size)
+	  {
+	  case 4: return BFD_RELOC_X86_64_32S;
+	  }
+      else
+	switch (size)
+	  {
+	  case 1: return BFD_RELOC_8;
+	  case 2: return BFD_RELOC_16;
+	  case 4: return BFD_RELOC_32;
+	  case 8: return BFD_RELOC_64;
+	  }
+      as_bad (_("cannot do %s %u byte relocation"),
+	      sign > 0 ? "signed" : "unsigned", size);
+    }
+
+  abort ();
+  return BFD_RELOC_NONE;
+}
+
+/* Here we decide which fixups can be adjusted to make them relative to
+   the beginning of the section instead of the symbol.  Basically we need
+   to make sure that the dynamic relocations are done correctly, so in
+   some cases we force the original symbol to be used.  */
+
+int
+tc_i386_fix_adjustable (fixS *fixP ATTRIBUTE_UNUSED)
+{
+#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
+  if (!IS_ELF)
+    return 1;
+
+  /* Don't adjust pc-relative references to merge sections in 64-bit
+     mode.  */
+  if (use_rela_relocations
+      && (S_GET_SEGMENT (fixP->fx_addsy)->flags & SEC_MERGE) != 0
+      && fixP->fx_pcrel)
+    return 0;
+
+  /* The x86_64 GOTPCREL are represented as 32bit PCrel relocations
+     and changed later by validate_fix.  */
+  if (GOT_symbol && fixP->fx_subsy == GOT_symbol
+      && fixP->fx_r_type == BFD_RELOC_32_PCREL)
+    return 0;
+
+  /* adjust_reloc_syms doesn't know about the GOT.  */
+  if (fixP->fx_r_type == BFD_RELOC_386_GOTOFF
+      || fixP->fx_r_type == BFD_RELOC_386_PLT32
+      || fixP->fx_r_type == BFD_RELOC_386_GOT32
+      || fixP->fx_r_type == BFD_RELOC_386_TLS_GD
+      || fixP->fx_r_type == BFD_RELOC_386_TLS_LDM
+      || fixP->fx_r_type == BFD_RELOC_386_TLS_LDO_32
+      || fixP->fx_r_type == BFD_RELOC_386_TLS_IE_32
+      || fixP->fx_r_type == BFD_RELOC_386_TLS_IE
+      || fixP->fx_r_type == BFD_RELOC_386_TLS_GOTIE
+      || fixP->fx_r_type == BFD_RELOC_386_TLS_LE_32
+      || fixP->fx_r_type == BFD_RELOC_386_TLS_LE
+      || fixP->fx_r_type == BFD_RELOC_386_TLS_GOTDESC
+      || fixP->fx_r_type == BFD_RELOC_386_TLS_DESC_CALL
+      || fixP->fx_r_type == BFD_RELOC_X86_64_PLT32
+      || fixP->fx_r_type == BFD_RELOC_X86_64_GOT32
+      || fixP->fx_r_type == BFD_RELOC_X86_64_GOTPCREL
+      || fixP->fx_r_type == BFD_RELOC_X86_64_TLSGD
+      || fixP->fx_r_type == BFD_RELOC_X86_64_TLSLD
+      || fixP->fx_r_type == BFD_RELOC_X86_64_DTPOFF32
+      || fixP->fx_r_type == BFD_RELOC_X86_64_DTPOFF64
+      || fixP->fx_r_type == BFD_RELOC_X86_64_GOTTPOFF
+      || fixP->fx_r_type == BFD_RELOC_X86_64_TPOFF32
+      || fixP->fx_r_type == BFD_RELOC_X86_64_TPOFF64
+      || fixP->fx_r_type == BFD_RELOC_X86_64_GOTOFF64
+      || fixP->fx_r_type == BFD_RELOC_X86_64_GOTPC32_TLSDESC
+      || fixP->fx_r_type == BFD_RELOC_X86_64_TLSDESC_CALL
+      || fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
+      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
+    return 0;
+#endif
+  return 1;
+}
+
+static int
+intel_float_operand (const char *mnemonic)
+{
+  /* Note that the value returned is meaningful only for opcodes with (memory)
+     operands, hence the code here is free to improperly handle opcodes that
+     have no operands (for better performance and smaller code). */
+
+  if (mnemonic[0] != 'f')
+    return 0; /* non-math */
+
+  switch (mnemonic[1])
+    {
+    /* fclex, fdecstp, fdisi, femms, feni, fincstp, finit, fsetpm, and
+       the fs segment override prefix not currently handled because no
+       call path can make opcodes without operands get here */
+    case 'i':
+      return 2 /* integer op */;
+    case 'l':
+      if (mnemonic[2] == 'd' && (mnemonic[3] == 'c' || mnemonic[3] == 'e'))
+	return 3; /* fldcw/fldenv */
+      break;
+    case 'n':
+      if (mnemonic[2] != 'o' /* fnop */)
+	return 3; /* non-waiting control op */
+      break;
+    case 'r':
+      if (mnemonic[2] == 's')
+	return 3; /* frstor/frstpm */
+      break;
+    case 's':
+      if (mnemonic[2] == 'a')
+	return 3; /* fsave */
+      if (mnemonic[2] == 't')
+	{
+	  switch (mnemonic[3])
+	    {
+	    case 'c': /* fstcw */
+	    case 'd': /* fstdw */
+	    case 'e': /* fstenv */
+	    case 's': /* fsts[gw] */
+	      return 3;
+	    }
+	}
+      break;
+    case 'x':
+      if (mnemonic[2] == 'r' || mnemonic[2] == 's')
+	return 0; /* fxsave/fxrstor are not really math ops */
+      break;
+    }
+
+  return 1;
+}
+
+/* This is the guts of the machine-dependent assembler.  LINE points to a
+   machine dependent instruction.  This function is supposed to emit
+   the frags/bytes it assembles to.  */
+
+void
+md_assemble (line)
+     char *line;
+{
+  int j;
+  char mnemonic[MAX_MNEM_SIZE];
+
+  /* Initialize globals.  */
+  memset (&i, '\0', sizeof (i));
+  for (j = 0; j < MAX_OPERANDS; j++)
+    i.reloc[j] = NO_RELOC;
+  memset (disp_expressions, '\0', sizeof (disp_expressions));
+  memset (im_expressions, '\0', sizeof (im_expressions));
+  save_stack_p = save_stack;
+
+  /* First parse an instruction mnemonic & call i386_operand for the operands.
+     We assume that the scrubber has arranged it so that line[0] is the valid
+     start of a (possibly prefixed) mnemonic.  */
+
+  line = parse_insn (line, mnemonic);
+  if (line == NULL)
+    return;
+
+  line = parse_operands (line, mnemonic);
+  if (line == NULL)
+    return;
+
+  /* The order of the immediates should be reversed
+     for 2 immediates extrq and insertq instructions */
+  if ((i.imm_operands == 2)
+      && ((strcmp (mnemonic, "extrq") == 0)
+	  || (strcmp (mnemonic, "insertq") == 0)))
+    {
+      swap_2_operands (0, 1);
+      /* "extrq" and insertq" are the only two instructions whose operands
+	 have to be reversed even though they have two immediate operands.
+      */
+      if (intel_syntax)
+	swap_operands ();
+    }
+
+  /* Now we've parsed the mnemonic into a set of templates, and have the
+     operands at hand.  */
+
+  /* All intel opcodes have reversed operands except for "bound" and
+     "enter".  We also don't reverse intersegment "jmp" and "call"
+     instructions with 2 immediate operands so that the immediate segment
+     precedes the offset, as it does when in AT&T mode. */
+  if (intel_syntax
+      && i.operands > 1
+      && (strcmp (mnemonic, "bound") != 0)
+      && (strcmp (mnemonic, "invlpga") != 0)
+      && !((i.types[0] & Imm) && (i.types[1] & Imm)))
+    swap_operands ();
+
+  if (i.imm_operands)
+    optimize_imm ();
+
+  /* Don't optimize displacement for movabs since it only takes 64bit
+     displacement.  */
+  if (i.disp_operands
+      && (flag_code != CODE_64BIT
+	  || strcmp (mnemonic, "movabs") != 0))
+    optimize_disp ();
+
+  /* Next, we find a template that matches the given insn,
+     making sure the overlap of the given operands types is consistent
+     with the template operand types.  */
+
+  if (!match_template ())
+    return;
+
+  if (intel_syntax)
+    {
+      /* Undo SYSV386_COMPAT brokenness when in Intel mode.  See i386.h  */
+      if (SYSV386_COMPAT
+	  && (i.tm.base_opcode & 0xfffffde0) == 0xdce0)
+	i.tm.base_opcode ^= Opcode_FloatR;
+
+      /* Zap movzx and movsx suffix.  The suffix may have been set from
+	 "word ptr" or "byte ptr" on the source operand, but we'll use
+	 the suffix later to choose the destination register.  */
+      if ((i.tm.base_opcode & ~9) == 0x0fb6)
+	{
+	  if (i.reg_operands < 2
+	      && !i.suffix
+	      && (~i.tm.opcode_modifier
+		  & (No_bSuf
+		     | No_wSuf
+		     | No_lSuf
+		     | No_sSuf
+		     | No_xSuf
+		     | No_qSuf)))
+	    as_bad (_("ambiguous operand size for `%s'"), i.tm.name);
+
+	  i.suffix = 0;
+	}
+    }
+
+  if (i.tm.opcode_modifier & FWait)
+    if (!add_prefix (FWAIT_OPCODE))
+      return;
+
+  /* Check string instruction segment overrides.  */
+  if ((i.tm.opcode_modifier & IsString) != 0 && i.mem_operands != 0)
+    {
+      if (!check_string ())
+	return;
+    }
+
+  if (!process_suffix ())
+    return;
+
+  /* Make still unresolved immediate matches conform to size of immediate
+     given in i.suffix.  */
+  if (!finalize_imm ())
+    return;
+
+  if (i.types[0] & Imm1)
+    i.imm_operands = 0;	/* kludge for shift insns.  */
+  if (i.types[0] & ImplicitRegister)
+    i.reg_operands--;
+  if (i.types[1] & ImplicitRegister)
+    i.reg_operands--;
+  if (i.types[2] & ImplicitRegister)
+    i.reg_operands--;
+
+  if (i.tm.opcode_modifier & ImmExt)
+    {
+      expressionS *exp;
+
+      if ((i.tm.cpu_flags & CpuSSE3) && i.operands > 0)
+	{
+	  /* Streaming SIMD extensions 3 Instructions have the fixed
+	     operands with an opcode suffix which is coded in the same
+	     place as an 8-bit immediate field would be. Here we check
+	     those operands and remove them afterwards.  */
+	  unsigned int x;
+
+	  for (x = 0; x < i.operands; x++)
+	    if (i.op[x].regs->reg_num != x)
+	      as_bad (_("can't use register '%s%s' as operand %d in '%s'."),
+		      register_prefix,
+		      i.op[x].regs->reg_name,
+		      x + 1,
+		      i.tm.name);
+	  i.operands = 0;
+ 	}
+
+      /* These AMD 3DNow! and Intel Katmai New Instructions have an
+	 opcode suffix which is coded in the same place as an 8-bit
+	 immediate field would be.  Here we fake an 8-bit immediate
+	 operand from the opcode suffix stored in tm.extension_opcode.  */
+
+      assert (i.imm_operands == 0 && i.operands <= 2 && 2 < MAX_OPERANDS);
+
+      exp = &im_expressions[i.imm_operands++];
+      i.op[i.operands].imms = exp;
+      i.types[i.operands++] = Imm8;
+      exp->X_op = O_constant;
+      exp->X_add_number = i.tm.extension_opcode;
+      i.tm.extension_opcode = None;
+    }
+
+  /* For insns with operands there are more diddles to do to the opcode.  */
+  if (i.operands)
+    {
+      if (!process_operands ())
+	return;
+    }
+  else if (!quiet_warnings && (i.tm.opcode_modifier & Ugh) != 0)
+    {
+      /* UnixWare fsub no args is alias for fsubp, fadd -> faddp, etc.  */
+      as_warn (_("translating to `%sp'"), i.tm.name);
+    }
+
+  /* Handle conversion of 'int $3' --> special int3 insn.  */
+  if (i.tm.base_opcode == INT_OPCODE && i.op[0].imms->X_add_number == 3)
+    {
+      i.tm.base_opcode = INT3_OPCODE;
+      i.imm_operands = 0;
+    }
+
+  if ((i.tm.opcode_modifier & (Jump | JumpByte | JumpDword))
+      && i.op[0].disps->X_op == O_constant)
+    {
+      /* Convert "jmp constant" (and "call constant") to a jump (call) to
+	 the absolute address given by the constant.  Since ix86 jumps and
+	 calls are pc relative, we need to generate a reloc.  */
+      i.op[0].disps->X_add_symbol = &abs_symbol;
+      i.op[0].disps->X_op = O_symbol;
+    }
+
+  if ((i.tm.opcode_modifier & Rex64) != 0)
+    i.rex |= REX_W;
+
+  /* For 8 bit registers we need an empty rex prefix.  Also if the
+     instruction already has a prefix, we need to convert old
+     registers to new ones.  */
+
+  if (((i.types[0] & Reg8) != 0
+       && (i.op[0].regs->reg_flags & RegRex64) != 0)
+      || ((i.types[1] & Reg8) != 0
+	  && (i.op[1].regs->reg_flags & RegRex64) != 0)
+      || (((i.types[0] & Reg8) != 0 || (i.types[1] & Reg8) != 0)
+	  && i.rex != 0))
+    {
+      int x;
+
+      i.rex |= REX_OPCODE;
+      for (x = 0; x < 2; x++)
+	{
+	  /* Look for 8 bit operand that uses old registers.  */
+	  if ((i.types[x] & Reg8) != 0
+	      && (i.op[x].regs->reg_flags & RegRex64) == 0)
+	    {
+	      /* In case it is "hi" register, give up.  */
+	      if (i.op[x].regs->reg_num > 3)
+		as_bad (_("can't encode register '%s%s' in an "
+			  "instruction requiring REX prefix."),
+			register_prefix, i.op[x].regs->reg_name);
+
+	      /* Otherwise it is equivalent to the extended register.
+		 Since the encoding doesn't change this is merely
+		 cosmetic cleanup for debug output.  */
+
+	      i.op[x].regs = i.op[x].regs + 8;
+	    }
+	}
+    }
+
+  if (i.rex != 0)
+    add_prefix (REX_OPCODE | i.rex);
+
+  /* We are ready to output the insn.  */
+  output_insn ();
+}
+
+static char *
+parse_insn (char *line, char *mnemonic)
+{
+  char *l = line;
+  char *token_start = l;
+  char *mnem_p;
+  int supported;
+  const template *t;
+
+  /* Non-zero if we found a prefix only acceptable with string insns.  */
+  const char *expecting_string_instruction = NULL;
+
+  while (1)
+    {
+      mnem_p = mnemonic;
+      while ((*mnem_p = mnemonic_chars[(unsigned char) *l]) != 0)
+	{
+	  mnem_p++;
+	  if (mnem_p >= mnemonic + MAX_MNEM_SIZE)
+	    {
+	      as_bad (_("no such instruction: `%s'"), token_start);
+	      return NULL;
+	    }
+	  l++;
+	}
+      if (!is_space_char (*l)
+	  && *l != END_OF_INSN
+	  && (intel_syntax
+	      || (*l != PREFIX_SEPARATOR
+		  && *l != ',')))
+	{
+	  as_bad (_("invalid character %s in mnemonic"),
+		  output_invalid (*l));
+	  return NULL;
+	}
+      if (token_start == l)
+	{
+	  if (!intel_syntax && *l == PREFIX_SEPARATOR)
+	    as_bad (_("expecting prefix; got nothing"));
+	  else
+	    as_bad (_("expecting mnemonic; got nothing"));
+	  return NULL;
+	}
+
+      /* Look up instruction (or prefix) via hash table.  */
+      current_templates = hash_find (op_hash, mnemonic);
+
+      if (*l != END_OF_INSN
+	  && (!is_space_char (*l) || l[1] != END_OF_INSN)
+	  && current_templates
+	  && (current_templates->start->opcode_modifier & IsPrefix))
+	{
+	  if (current_templates->start->cpu_flags
+	      & (flag_code != CODE_64BIT ? Cpu64 : CpuNo64))
+	    {
+	      as_bad ((flag_code != CODE_64BIT
+		       ? _("`%s' is only supported in 64-bit mode")
+		       : _("`%s' is not supported in 64-bit mode")),
+		      current_templates->start->name);
+	      return NULL;
+	    }
+	  /* If we are in 16-bit mode, do not allow addr16 or data16.
+	     Similarly, in 32-bit mode, do not allow addr32 or data32.  */
+	  if ((current_templates->start->opcode_modifier & (Size16 | Size32))
+	      && flag_code != CODE_64BIT
+	      && (((current_templates->start->opcode_modifier & Size32) != 0)
+		  ^ (flag_code == CODE_16BIT)))
+	    {
+	      as_bad (_("redundant %s prefix"),
+		      current_templates->start->name);
+	      return NULL;
+	    }
+	  /* Add prefix, checking for repeated prefixes.  */
+	  switch (add_prefix (current_templates->start->base_opcode))
+	    {
+	    case 0:
+	      return NULL;
+	    case 2:
+	      expecting_string_instruction = current_templates->start->name;
+	      break;
+	    }
+	  /* Skip past PREFIX_SEPARATOR and reset token_start.  */
+	  token_start = ++l;
+	}
+      else
+	break;
+    }
+
+  if (!current_templates)
+    {
+      /* See if we can get a match by trimming off a suffix.  */
+      switch (mnem_p[-1])
+	{
+	case WORD_MNEM_SUFFIX:
+	  if (intel_syntax && (intel_float_operand (mnemonic) & 2))
+	    i.suffix = SHORT_MNEM_SUFFIX;
+	  else
+	case BYTE_MNEM_SUFFIX:
+	case QWORD_MNEM_SUFFIX:
+	  i.suffix = mnem_p[-1];
+	  mnem_p[-1] = '\0';
+	  current_templates = hash_find (op_hash, mnemonic);
+	  break;
+	case SHORT_MNEM_SUFFIX:
+	case LONG_MNEM_SUFFIX:
+	  if (!intel_syntax)
+	    {
+	      i.suffix = mnem_p[-1];
+	      mnem_p[-1] = '\0';
+	      current_templates = hash_find (op_hash, mnemonic);
+	    }
+	  break;
+
+	  /* Intel Syntax.  */
+	case 'd':
+	  if (intel_syntax)
+	    {
+	      if (intel_float_operand (mnemonic) == 1)
+		i.suffix = SHORT_MNEM_SUFFIX;
+	      else
+		i.suffix = LONG_MNEM_SUFFIX;
+	      mnem_p[-1] = '\0';
+	      current_templates = hash_find (op_hash, mnemonic);
+	    }
+	  break;
+	}
+      if (!current_templates)
+	{
+	  as_bad (_("no such instruction: `%s'"), token_start);
+	  return NULL;
+	}
+    }
+
+  if (current_templates->start->opcode_modifier & (Jump | JumpByte))
+    {
+      /* Check for a branch hint.  We allow ",pt" and ",pn" for
+	 predict taken and predict not taken respectively.
+	 I'm not sure that branch hints actually do anything on loop
+	 and jcxz insns (JumpByte) for current Pentium4 chips.  They
+	 may work in the future and it doesn't hurt to accept them
+	 now.  */
+      if (l[0] == ',' && l[1] == 'p')
+	{
+	  if (l[2] == 't')
+	    {
+	      if (!add_prefix (DS_PREFIX_OPCODE))
+		return NULL;
+	      l += 3;
+	    }
+	  else if (l[2] == 'n')
+	    {
+	      if (!add_prefix (CS_PREFIX_OPCODE))
+		return NULL;
+	      l += 3;
+	    }
+	}
+    }
+  /* Any other comma loses.  */
+  if (*l == ',')
+    {
+      as_bad (_("invalid character %s in mnemonic"),
+	      output_invalid (*l));
+      return NULL;
+    }
+
+  /* Check if instruction is supported on specified architecture.  */
+  supported = 0;
+  for (t = current_templates->start; t < current_templates->end; ++t)
+    {
+      if (!((t->cpu_flags & ~(Cpu64 | CpuNo64))
+	    & ~(cpu_arch_flags & ~(Cpu64 | CpuNo64))))
+	supported |= 1;
+      if (!(t->cpu_flags & (flag_code == CODE_64BIT ? CpuNo64 : Cpu64)))
+	supported |= 2;
+    }
+  if (!(supported & 2))
+    {
+      as_bad (flag_code == CODE_64BIT
+	      ? _("`%s' is not supported in 64-bit mode")
+	      : _("`%s' is only supported in 64-bit mode"),
+	      current_templates->start->name);
+      return NULL;
+    }
+  if (!(supported & 1))
+    {
+      as_warn (_("`%s' is not supported on `%s%s'"),
+	       current_templates->start->name,
+	       cpu_arch_name,
+	       cpu_sub_arch_name ? cpu_sub_arch_name : "");
+    }
+  else if ((Cpu386 & ~cpu_arch_flags) && (flag_code != CODE_16BIT))
+    {
+      as_warn (_("use .code16 to ensure correct addressing mode"));
+    }
+
+  /* Check for rep/repne without a string instruction.  */
+  if (expecting_string_instruction)
+    {
+      static templates override;
+
+      for (t = current_templates->start; t < current_templates->end; ++t)
+	if (t->opcode_modifier & IsString)
+	  break;
+      if (t >= current_templates->end)
+	{
+	  as_bad (_("expecting string instruction after `%s'"),
+		  expecting_string_instruction);
+	  return NULL;
+	}
+      for (override.start = t; t < current_templates->end; ++t)
+	if (!(t->opcode_modifier & IsString))
+	  break;
+      override.end = t;
+      current_templates = &override;
+    }
+
+  return l;
+}
+
+static char *
+parse_operands (char *l, const char *mnemonic)
+{
+  char *token_start;
+
+  /* 1 if operand is pending after ','.  */
+  unsigned int expecting_operand = 0;
+
+  /* Non-zero if operand parens not balanced.  */
+  unsigned int paren_not_balanced;
+
+  while (*l != END_OF_INSN)
+    {
+      /* Skip optional white space before operand.  */
+      if (is_space_char (*l))
+	++l;
+      if (!is_operand_char (*l) && *l != END_OF_INSN)
+	{
+	  as_bad (_("invalid character %s before operand %d"),
+		  output_invalid (*l),
+		  i.operands + 1);
+	  return NULL;
+	}
+      token_start = l;	/* after white space */
+      paren_not_balanced = 0;
+      while (paren_not_balanced || *l != ',')
+	{
+	  if (*l == END_OF_INSN)
+	    {
+	      if (paren_not_balanced)
+		{
+		  if (!intel_syntax)
+		    as_bad (_("unbalanced parenthesis in operand %d."),
+			    i.operands + 1);
+		  else
+		    as_bad (_("unbalanced brackets in operand %d."),
+			    i.operands + 1);
+		  return NULL;
+		}
+	      else
+		break;	/* we are done */
+	    }
+	  else if (!is_operand_char (*l) && !is_space_char (*l))
+	    {
+	      as_bad (_("invalid character %s in operand %d"),
+		      output_invalid (*l),
+		      i.operands + 1);
+	      return NULL;
+	    }
+	  if (!intel_syntax)
+	    {
+	      if (*l == '(')
+		++paren_not_balanced;
+	      if (*l == ')')
+		--paren_not_balanced;
+	    }
+	  else
+	    {
+	      if (*l == '[')
+		++paren_not_balanced;
+	      if (*l == ']')
+		--paren_not_balanced;
+	    }
+	  l++;
+	}
+      if (l != token_start)
+	{			/* Yes, we've read in another operand.  */
+	  unsigned int operand_ok;
+	  this_operand = i.operands++;
+	  if (i.operands > MAX_OPERANDS)
+	    {
+	      as_bad (_("spurious operands; (%d operands/instruction max)"),
+		      MAX_OPERANDS);
+	      return NULL;
+	    }
+	  /* Now parse operand adding info to 'i' as we go along.  */
+	  END_STRING_AND_SAVE (l);
+
+	  if (intel_syntax)
+	    operand_ok =
+	      i386_intel_operand (token_start,
+				  intel_float_operand (mnemonic));
+	  else
+	    operand_ok = i386_operand (token_start);
+
+	  RESTORE_END_STRING (l);
+	  if (!operand_ok)
+	    return NULL;
+	}
+      else
+	{
+	  if (expecting_operand)
+	    {
+	    expecting_operand_after_comma:
+	      as_bad (_("expecting operand after ','; got nothing"));
+	      return NULL;
+	    }
+	  if (*l == ',')
+	    {
+	      as_bad (_("expecting operand before ','; got nothing"));
+	      return NULL;
+	    }
+	}
+
+      /* Now *l must be either ',' or END_OF_INSN.  */
+      if (*l == ',')
+	{
+	  if (*++l == END_OF_INSN)
+	    {
+	      /* Just skip it, if it's \n complain.  */
+	      goto expecting_operand_after_comma;
+	    }
+	  expecting_operand = 1;
+	}
+    }
+  return l;
+}
+
+static void
+swap_2_operands (int xchg1, int xchg2)
+{
+  union i386_op temp_op;
+  unsigned int temp_type;
+  enum bfd_reloc_code_real temp_reloc;
+
+  temp_type = i.types[xchg2];
+  i.types[xchg2] = i.types[xchg1];
+  i.types[xchg1] = temp_type;
+  temp_op = i.op[xchg2];
+  i.op[xchg2] = i.op[xchg1];
+  i.op[xchg1] = temp_op;
+  temp_reloc = i.reloc[xchg2];
+  i.reloc[xchg2] = i.reloc[xchg1];
+  i.reloc[xchg1] = temp_reloc;
+}
+
+static void
+swap_operands (void)
+{
+  switch (i.operands)
+    {
+    case 4:
+      swap_2_operands (1, i.operands - 2);
+    case 3:
+    case 2:
+      swap_2_operands (0, i.operands - 1);
+      break;
+    default:
+      abort ();
+    }
+
+  if (i.mem_operands == 2)
+    {
+      const seg_entry *temp_seg;
+      temp_seg = i.seg[0];
+      i.seg[0] = i.seg[1];
+      i.seg[1] = temp_seg;
+    }
+}
+
+/* Try to ensure constant immediates are represented in the smallest
+   opcode possible.  */
+static void
+optimize_imm (void)
+{
+  char guess_suffix = 0;
+  int op;
+
+  if (i.suffix)
+    guess_suffix = i.suffix;
+  else if (i.reg_operands)
+    {
+      /* Figure out a suffix from the last register operand specified.
+	 We can't do this properly yet, ie. excluding InOutPortReg,
+	 but the following works for instructions with immediates.
+	 In any case, we can't set i.suffix yet.  */
+      for (op = i.operands; --op >= 0;)
+	if (i.types[op] & Reg)
+	  {
+	    if (i.types[op] & Reg8)
+	      guess_suffix = BYTE_MNEM_SUFFIX;
+	    else if (i.types[op] & Reg16)
+	      guess_suffix = WORD_MNEM_SUFFIX;
+	    else if (i.types[op] & Reg32)
+	      guess_suffix = LONG_MNEM_SUFFIX;
+	    else if (i.types[op] & Reg64)
+	      guess_suffix = QWORD_MNEM_SUFFIX;
+	    break;
+	  }
+    }
+  else if ((flag_code == CODE_16BIT) ^ (i.prefix[DATA_PREFIX] != 0))
+    guess_suffix = WORD_MNEM_SUFFIX;
+
+  for (op = i.operands; --op >= 0;)
+    if (i.types[op] & Imm)
+      {
+	switch (i.op[op].imms->X_op)
+	  {
+	  case O_constant:
+	    /* If a suffix is given, this operand may be shortened.  */
+	    switch (guess_suffix)
+	      {
+	      case LONG_MNEM_SUFFIX:
+		i.types[op] |= Imm32 | Imm64;
+		break;
+	      case WORD_MNEM_SUFFIX:
+		i.types[op] |= Imm16 | Imm32S | Imm32 | Imm64;
+		break;
+	      case BYTE_MNEM_SUFFIX:
+		i.types[op] |= Imm16 | Imm8 | Imm8S | Imm32S | Imm32 | Imm64;
+		break;
+	      }
+
+	    /* If this operand is at most 16 bits, convert it
+	       to a signed 16 bit number before trying to see
+	       whether it will fit in an even smaller size.
+	       This allows a 16-bit operand such as $0xffe0 to
+	       be recognised as within Imm8S range.  */
+	    if ((i.types[op] & Imm16)
+		&& (i.op[op].imms->X_add_number & ~(offsetT) 0xffff) == 0)
+	      {
+		i.op[op].imms->X_add_number =
+		  (((i.op[op].imms->X_add_number & 0xffff) ^ 0x8000) - 0x8000);
+	      }
+	    if ((i.types[op] & Imm32)
+		&& ((i.op[op].imms->X_add_number & ~(((offsetT) 2 << 31) - 1))
+		    == 0))
+	      {
+		i.op[op].imms->X_add_number = ((i.op[op].imms->X_add_number
+						^ ((offsetT) 1 << 31))
+					       - ((offsetT) 1 << 31));
+	      }
+	    i.types[op] |= smallest_imm_type (i.op[op].imms->X_add_number);
+
+	    /* We must avoid matching of Imm32 templates when 64bit
+	       only immediate is available.  */
+	    if (guess_suffix == QWORD_MNEM_SUFFIX)
+	      i.types[op] &= ~Imm32;
+	    break;
+
+	  case O_absent:
+	  case O_register:
+	    abort ();
+
+	    /* Symbols and expressions.  */
+	  default:
+	    /* Convert symbolic operand to proper sizes for matching, but don't
+	       prevent matching a set of insns that only supports sizes other
+	       than those matching the insn suffix.  */
+	    {
+	      unsigned int mask, allowed = 0;
+	      const template *t;
+
+	      for (t = current_templates->start;
+		   t < current_templates->end;
+		   ++t)
+		allowed |= t->operand_types[op];
+	      switch (guess_suffix)
+		{
+		case QWORD_MNEM_SUFFIX:
+		  mask = Imm64 | Imm32S;
+		  break;
+		case LONG_MNEM_SUFFIX:
+		  mask = Imm32;
+		  break;
+		case WORD_MNEM_SUFFIX:
+		  mask = Imm16;
+		  break;
+		case BYTE_MNEM_SUFFIX:
+		  mask = Imm8;
+		  break;
+		default:
+		  mask = 0;
+		  break;
+		}
+	      if (mask & allowed)
+		i.types[op] &= mask;
+	    }
+	    break;
+	  }
+      }
+}
+
+/* Try to use the smallest displacement type too.  */
+static void
+optimize_disp (void)
+{
+  int op;
+
+  for (op = i.operands; --op >= 0;)
+    if (i.types[op] & Disp)
+      {
+	if (i.op[op].disps->X_op == O_constant)
+	  {
+	    offsetT disp = i.op[op].disps->X_add_number;
+
+	    if ((i.types[op] & Disp16)
+		&& (disp & ~(offsetT) 0xffff) == 0)
+	      {
+		/* If this operand is at most 16 bits, convert
+		   to a signed 16 bit number and don't use 64bit
+		   displacement.  */
+		disp = (((disp & 0xffff) ^ 0x8000) - 0x8000);
+		i.types[op] &= ~Disp64;
+	      }
+	    if ((i.types[op] & Disp32)
+		&& (disp & ~(((offsetT) 2 << 31) - 1)) == 0)
+	      {
+		/* If this operand is at most 32 bits, convert
+		   to a signed 32 bit number and don't use 64bit
+		   displacement.  */
+		disp &= (((offsetT) 2 << 31) - 1);
+		disp = (disp ^ ((offsetT) 1 << 31)) - ((addressT) 1 << 31);
+		i.types[op] &= ~Disp64;
+	      }
+	    if (!disp && (i.types[op] & BaseIndex))
+	      {
+		i.types[op] &= ~Disp;
+		i.op[op].disps = 0;
+		i.disp_operands--;
+	      }
+	    else if (flag_code == CODE_64BIT)
+	      {
+		if (fits_in_signed_long (disp))
+		  {
+		    i.types[op] &= ~Disp64;
+		    i.types[op] |= Disp32S;
+		  }
+		if (fits_in_unsigned_long (disp))
+		  i.types[op] |= Disp32;
+	      }
+	    if ((i.types[op] & (Disp32 | Disp32S | Disp16))
+		&& fits_in_signed_byte (disp))
+	      i.types[op] |= Disp8;
+	  }
+	else if (i.reloc[op] == BFD_RELOC_386_TLS_DESC_CALL
+		 || i.reloc[op] == BFD_RELOC_X86_64_TLSDESC_CALL)
+	  {
+	    fix_new_exp (frag_now, frag_more (0) - frag_now->fr_literal, 0,
+			 i.op[op].disps, 0, i.reloc[op]);
+	    i.types[op] &= ~Disp;
+	  }
+ 	else
+	  /* We only support 64bit displacement on constants.  */
+	  i.types[op] &= ~Disp64;
+      }
+}
+
+static int
+match_template (void)
+{
+  /* Points to template once we've found it.  */
+  const template *t;
+  unsigned int overlap0, overlap1, overlap2, overlap3;
+  unsigned int found_reverse_match;
+  int suffix_check;
+  unsigned int operand_types [MAX_OPERANDS];
+  int addr_prefix_disp;
+  unsigned int j;
+
+#if MAX_OPERANDS != 4
+# error "MAX_OPERANDS must be 4."
+#endif
+
+#define MATCH(overlap, given, template)				\
+  ((overlap & ~JumpAbsolute)					\
+   && (((given) & (BaseIndex | JumpAbsolute))			\
+       == ((overlap) & (BaseIndex | JumpAbsolute))))
+
+  /* If given types r0 and r1 are registers they must be of the same type
+     unless the expected operand type register overlap is null.
+     Note that Acc in a template matches every size of reg.  */
+#define CONSISTENT_REGISTER_MATCH(m0, g0, t0, m1, g1, t1)	\
+  (((g0) & Reg) == 0 || ((g1) & Reg) == 0			\
+   || ((g0) & Reg) == ((g1) & Reg)				\
+   || ((((m0) & Acc) ? Reg : (t0)) & (((m1) & Acc) ? Reg : (t1)) & Reg) == 0 )
+
+  overlap0 = 0;
+  overlap1 = 0;
+  overlap2 = 0;
+  overlap3 = 0;
+  found_reverse_match = 0;
+  for (j = 0; j < MAX_OPERANDS; j++)
+    operand_types [j] = 0;
+  addr_prefix_disp = -1;
+  suffix_check = (i.suffix == BYTE_MNEM_SUFFIX
+		  ? No_bSuf
+		  : (i.suffix == WORD_MNEM_SUFFIX
+		     ? No_wSuf
+		     : (i.suffix == SHORT_MNEM_SUFFIX
+			? No_sSuf
+			: (i.suffix == LONG_MNEM_SUFFIX
+			   ? No_lSuf
+			   : (i.suffix == QWORD_MNEM_SUFFIX
+			      ? No_qSuf
+			      : (i.suffix == LONG_DOUBLE_MNEM_SUFFIX
+				 ? No_xSuf : 0))))));
+
+  for (t = current_templates->start; t < current_templates->end; t++)
+    {
+      addr_prefix_disp = -1;
+
+      /* Must have right number of operands.  */
+      if (i.operands != t->operands)
+	continue;
+
+      /* Check the suffix, except for some instructions in intel mode.  */
+      if ((t->opcode_modifier & suffix_check)
+	  && !(intel_syntax
+	       && (t->opcode_modifier & IgnoreSize)))
+	continue;
+
+      for (j = 0; j < MAX_OPERANDS; j++)
+	operand_types [j] = t->operand_types [j];
+
+      /* In general, don't allow 64-bit operands in 32-bit mode.  */
+      if (i.suffix == QWORD_MNEM_SUFFIX
+	  && flag_code != CODE_64BIT
+	  && (intel_syntax
+	      ? (!(t->opcode_modifier & IgnoreSize)
+		 && !intel_float_operand (t->name))
+	      : intel_float_operand (t->name) != 2)
+	  && (!(operand_types[0] & (RegMMX | RegXMM))
+	      || !(operand_types[t->operands > 1] & (RegMMX | RegXMM)))
+	  && (t->base_opcode != 0x0fc7
+	      || t->extension_opcode != 1 /* cmpxchg8b */))
+	continue;
+
+      /* Do not verify operands when there are none.  */
+      else if (!t->operands)
+	{
+	  if (t->cpu_flags & ~cpu_arch_flags)
+	    continue;
+	  /* We've found a match; break out of loop.  */
+	  break;
+	}
+
+      /* Address size prefix will turn Disp64/Disp32/Disp16 operand
+	 into Disp32/Disp16/Disp32 operand.  */
+      if (i.prefix[ADDR_PREFIX] != 0)
+	  {
+	    unsigned int DispOn = 0, DispOff = 0;
+
+	    switch (flag_code)
+	    {
+	    case CODE_16BIT:
+	      DispOn = Disp32;
+	      DispOff = Disp16;
+	      break;
+	    case CODE_32BIT:
+	      DispOn = Disp16;
+	      DispOff = Disp32;
+	      break;
+	    case CODE_64BIT:
+	      DispOn = Disp32;
+	      DispOff = Disp64;
+	      break;
+	    }
+
+	    for (j = 0; j < MAX_OPERANDS; j++)
+	      {
+		/* There should be only one Disp operand.  */
+		if ((operand_types[j] & DispOff))
+		  {
+		    addr_prefix_disp = j;
+		    operand_types[j] |= DispOn;
+		    operand_types[j] &= ~DispOff;
+		    break;
+		  }
+	      }
+	  }
+
+      overlap0 = i.types[0] & operand_types[0];
+      switch (t->operands)
+	{
+	case 1:
+	  if (!MATCH (overlap0, i.types[0], operand_types[0]))
+	    continue;
+	  break;
+	case 2:
+	  /* xchg %eax, %eax is a special case. It is an aliase for nop
+	     only in 32bit mode and we can use opcode 0x90.  In 64bit
+	     mode, we can't use 0x90 for xchg %eax, %eax since it should
+	     zero-extend %eax to %rax.  */
+	  if (flag_code == CODE_64BIT
+	      && t->base_opcode == 0x90
+	      && i.types [0] == (Acc | Reg32)
+	      && i.types [1] == (Acc | Reg32))
+	    continue;
+	case 3:
+	case 4:
+	  overlap1 = i.types[1] & operand_types[1];
+	  if (!MATCH (overlap0, i.types[0], operand_types[0])
+	      || !MATCH (overlap1, i.types[1], operand_types[1])
+	      /* monitor in SSE3 is a very special case.  The first
+		 register and the second register may have different
+		 sizes.  The same applies to crc32 in SSE4.2.  */
+	      || !((t->base_opcode == 0x0f01
+		    && t->extension_opcode == 0xc8)
+		   || t->base_opcode == 0xf20f38f1
+		   || CONSISTENT_REGISTER_MATCH (overlap0, i.types[0],
+						 operand_types[0],
+						 overlap1, i.types[1],
+						 operand_types[1])))
+	    {
+	      /* Check if other direction is valid ...  */
+	      if ((t->opcode_modifier & (D | FloatD)) == 0)
+		continue;
+
+	      /* Try reversing direction of operands.  */
+	      overlap0 = i.types[0] & operand_types[1];
+	      overlap1 = i.types[1] & operand_types[0];
+	      if (!MATCH (overlap0, i.types[0], operand_types[1])
+		  || !MATCH (overlap1, i.types[1], operand_types[0])
+		  || !CONSISTENT_REGISTER_MATCH (overlap0, i.types[0],
+						 operand_types[1],
+						 overlap1, i.types[1],
+						 operand_types[0]))
+		{
+		  /* Does not match either direction.  */
+		  continue;
+		}
+	      /* found_reverse_match holds which of D or FloatDR
+		 we've found.  */
+	      if ((t->opcode_modifier & D))
+		found_reverse_match = Opcode_D;
+	      else if ((t->opcode_modifier & FloatD))
+		found_reverse_match = Opcode_FloatD;
+	      else
+		found_reverse_match = 0;
+	      if ((t->opcode_modifier & FloatR))
+		found_reverse_match |= Opcode_FloatR;
+	    }
+	  else
+	    {
+	      /* Found a forward 2 operand match here.  */
+	      switch (t->operands)
+		{
+		case 4:
+		  overlap3 = i.types[3] & operand_types[3];
+		case 3:
+		  overlap2 = i.types[2] & operand_types[2];
+		  break;
+		}
+
+	      switch (t->operands)
+		{
+		case 4:
+		  if (!MATCH (overlap3, i.types[3], operand_types[3])
+		      || !CONSISTENT_REGISTER_MATCH (overlap2,
+						     i.types[2],
+						     operand_types[2],
+						     overlap3,
+						     i.types[3],
+						     operand_types[3]))
+		    continue;
+		case 3:
+		  /* Here we make use of the fact that there are no
+		     reverse match 3 operand instructions, and all 3
+		     operand instructions only need to be checked for
+		     register consistency between operands 2 and 3.  */
+		  if (!MATCH (overlap2, i.types[2], operand_types[2])
+		      || !CONSISTENT_REGISTER_MATCH (overlap1,
+						     i.types[1],
+						     operand_types[1],
+						     overlap2,
+						     i.types[2],
+						     operand_types[2]))
+		    continue;
+		  break;
+		}
+	    }
+	  /* Found either forward/reverse 2, 3 or 4 operand match here:
+	     slip through to break.  */
+	}
+      if (t->cpu_flags & ~cpu_arch_flags)
+	{
+	  found_reverse_match = 0;
+	  continue;
+	}
+      /* We've found a match; break out of loop.  */
+      break;
+    }
+
+  if (t == current_templates->end)
+    {
+      /* We found no match.  */
+      as_bad (_("suffix or operands invalid for `%s'"),
+	      current_templates->start->name);
+      return 0;
+    }
+
+  if (!quiet_warnings)
+    {
+      if (!intel_syntax
+	  && ((i.types[0] & JumpAbsolute)
+	      != (operand_types[0] & JumpAbsolute)))
+	{
+	  as_warn (_("indirect %s without `*'"), t->name);
+	}
+
+      if ((t->opcode_modifier & (IsPrefix | IgnoreSize))
+	  == (IsPrefix | IgnoreSize))
+	{
+	  /* Warn them that a data or address size prefix doesn't
+	     affect assembly of the next line of code.  */
+	  as_warn (_("stand-alone `%s' prefix"), t->name);
+	}
+    }
+
+  /* Copy the template we found.  */
+  i.tm = *t;
+
+  if (addr_prefix_disp != -1)
+    i.tm.operand_types[addr_prefix_disp]
+      = operand_types[addr_prefix_disp];
+
+  if (found_reverse_match)
+    {
+      /* If we found a reverse match we must alter the opcode
+	 direction bit.  found_reverse_match holds bits to change
+	 (different for int & float insns).  */
+
+      i.tm.base_opcode ^= found_reverse_match;
+
+      i.tm.operand_types[0] = operand_types[1];
+      i.tm.operand_types[1] = operand_types[0];
+    }
+
+  return 1;
+}
+
+static int
+check_string (void)
+{
+  int mem_op = (i.types[0] & AnyMem) ? 0 : 1;
+  if ((i.tm.operand_types[mem_op] & EsSeg) != 0)
+    {
+      if (i.seg[0] != NULL && i.seg[0] != &es)
+	{
+	  as_bad (_("`%s' operand %d must use `%%es' segment"),
+		  i.tm.name,
+		  mem_op + 1);
+	  return 0;
+	}
+      /* There's only ever one segment override allowed per instruction.
+	 This instruction possibly has a legal segment override on the
+	 second operand, so copy the segment to where non-string
+	 instructions store it, allowing common code.  */
+      i.seg[0] = i.seg[1];
+    }
+  else if ((i.tm.operand_types[mem_op + 1] & EsSeg) != 0)
+    {
+      if (i.seg[1] != NULL && i.seg[1] != &es)
+	{
+	  as_bad (_("`%s' operand %d must use `%%es' segment"),
+		  i.tm.name,
+		  mem_op + 2);
+	  return 0;
+	}
+    }
+  return 1;
+}
+
+static int
+process_suffix (void)
+{
+  /* If matched instruction specifies an explicit instruction mnemonic
+     suffix, use it.  */
+  if (i.tm.opcode_modifier & (Size16 | Size32 | Size64))
+    {
+      if (i.tm.opcode_modifier & Size16)
+	i.suffix = WORD_MNEM_SUFFIX;
+      else if (i.tm.opcode_modifier & Size64)
+	i.suffix = QWORD_MNEM_SUFFIX;
+      else
+	i.suffix = LONG_MNEM_SUFFIX;
+    }
+  else if (i.reg_operands)
+    {
+      /* If there's no instruction mnemonic suffix we try to invent one
+	 based on register operands.  */
+      if (!i.suffix)
+	{
+	  /* We take i.suffix from the last register operand specified,
+	     Destination register type is more significant than source
+	     register type.  crc32 in SSE4.2 prefers source register
+	     type. */
+	  if (i.tm.base_opcode == 0xf20f38f1)
+	    {
+	      if ((i.types[0] & Reg))
+		i.suffix = ((i.types[0] & Reg16) ? WORD_MNEM_SUFFIX :
+			    LONG_MNEM_SUFFIX);
+	    }
+	  else if (i.tm.base_opcode == 0xf20f38f0)
+	    {
+	      if ((i.types[0] & Reg8))
+		i.suffix = BYTE_MNEM_SUFFIX;
+	    }
+
+	  if (!i.suffix)
+	    {
+	      int op;
+
+	      if (i.tm.base_opcode == 0xf20f38f1
+		  || i.tm.base_opcode == 0xf20f38f0)
+		{
+		  /* We have to know the operand size for crc32.  */
+		  as_bad (_("ambiguous memory operand size for `%s`"),
+			  i.tm.name);
+		  return 0;
+		}
+
+	      for (op = i.operands; --op >= 0;)
+		if ((i.types[op] & Reg)
+		    && !(i.tm.operand_types[op] & InOutPortReg))
+		  {
+		    i.suffix = ((i.types[op] & Reg8) ? BYTE_MNEM_SUFFIX :
+				(i.types[op] & Reg16) ? WORD_MNEM_SUFFIX :
+				(i.types[op] & Reg64) ? QWORD_MNEM_SUFFIX :
+				LONG_MNEM_SUFFIX);
+		    break;
+		  }
+	    }
+	}
+      else if (i.suffix == BYTE_MNEM_SUFFIX)
+	{
+	  if (!check_byte_reg ())
+	    return 0;
+	}
+      else if (i.suffix == LONG_MNEM_SUFFIX)
+	{
+	  if (!check_long_reg ())
+	    return 0;
+	}
+      else if (i.suffix == QWORD_MNEM_SUFFIX)
+	{
+	  if (!check_qword_reg ())
+	    return 0;
+	}
+      else if (i.suffix == WORD_MNEM_SUFFIX)
+	{
+	  if (!check_word_reg ())
+	    return 0;
+	}
+      else if (intel_syntax && (i.tm.opcode_modifier & IgnoreSize))
+	/* Do nothing if the instruction is going to ignore the prefix.  */
+	;
+      else
+	abort ();
+    }
+  else if ((i.tm.opcode_modifier & DefaultSize)
+	   && !i.suffix
+	   /* exclude fldenv/frstor/fsave/fstenv */
+	   && (i.tm.opcode_modifier & No_sSuf))
+    {
+      i.suffix = stackop_size;
+    }
+  else if (intel_syntax
+	   && !i.suffix
+	   && ((i.tm.operand_types[0] & JumpAbsolute)
+	       || (i.tm.opcode_modifier & (JumpByte|JumpInterSegment))
+	       || (i.tm.base_opcode == 0x0f01 /* [ls][gi]dt */
+		   && i.tm.extension_opcode <= 3)))
+    {
+      switch (flag_code)
+	{
+	case CODE_64BIT:
+	  if (!(i.tm.opcode_modifier & No_qSuf))
+	    {
+	      i.suffix = QWORD_MNEM_SUFFIX;
+	      break;
+	    }
+	case CODE_32BIT:
+	  if (!(i.tm.opcode_modifier & No_lSuf))
+	    i.suffix = LONG_MNEM_SUFFIX;
+	  break;
+	case CODE_16BIT:
+	  if (!(i.tm.opcode_modifier & No_wSuf))
+	    i.suffix = WORD_MNEM_SUFFIX;
+	  break;
+	}
+    }
+
+  if (!i.suffix)
+    {
+      if (!intel_syntax)
+	{
+	  if (i.tm.opcode_modifier & W)
+	    {
+	      as_bad (_("no instruction mnemonic suffix given and "
+			"no register operands; can't size instruction"));
+	      return 0;
+	    }
+	}
+      else
+	{
+	  unsigned int suffixes = (~i.tm.opcode_modifier
+				   & (No_bSuf
+				      | No_wSuf
+				      | No_lSuf
+				      | No_sSuf
+				      | No_xSuf
+				      | No_qSuf));
+
+	  if ((i.tm.opcode_modifier & W)
+	      || ((suffixes & (suffixes - 1))
+		  && !(i.tm.opcode_modifier & (DefaultSize | IgnoreSize))))
+	    {
+	      as_bad (_("ambiguous operand size for `%s'"), i.tm.name);
+	      return 0;
+	    }
+	}
+    }
+
+  /* Change the opcode based on the operand size given by i.suffix;
+     We don't need to change things for byte insns.  */
+
+  if (i.suffix && i.suffix != BYTE_MNEM_SUFFIX)
+    {
+      /* It's not a byte, select word/dword operation.  */
+      if (i.tm.opcode_modifier & W)
+	{
+	  if (i.tm.opcode_modifier & ShortForm)
+	    i.tm.base_opcode |= 8;
+	  else
+	    i.tm.base_opcode |= 1;
+	}
+
+      /* Now select between word & dword operations via the operand
+	 size prefix, except for instructions that will ignore this
+	 prefix anyway.  */
+      if (i.tm.base_opcode == 0x0f01 && i.tm.extension_opcode == 0xc8)
+	{
+	  /* monitor in SSE3 is a very special case. The default size
+	     of AX is the size of mode. The address size override
+	     prefix will change the size of AX.  */
+	  if (i.op->regs[0].reg_type &
+	      (flag_code == CODE_32BIT ? Reg16 : Reg32))
+	    if (!add_prefix (ADDR_PREFIX_OPCODE))
+	      return 0;
+	}
+      else if (i.suffix != QWORD_MNEM_SUFFIX
+	       && i.suffix != LONG_DOUBLE_MNEM_SUFFIX
+	       && !(i.tm.opcode_modifier & (IgnoreSize | FloatMF))
+	       && ((i.suffix == LONG_MNEM_SUFFIX) == (flag_code == CODE_16BIT)
+		   || (flag_code == CODE_64BIT
+		       && (i.tm.opcode_modifier & JumpByte))))
+	{
+	  unsigned int prefix = DATA_PREFIX_OPCODE;
+
+	  if (i.tm.opcode_modifier & JumpByte) /* jcxz, loop */
+	    prefix = ADDR_PREFIX_OPCODE;
+
+	  if (!add_prefix (prefix))
+	    return 0;
+	}
+
+      /* Set mode64 for an operand.  */
+      if (i.suffix == QWORD_MNEM_SUFFIX
+	  && flag_code == CODE_64BIT
+	  && (i.tm.opcode_modifier & NoRex64) == 0)
+	{
+	  /* Special case for xchg %rax,%rax.  It is NOP and doesn't
+	     need rex64.  */
+	  if (i.operands != 2
+	      || i.types [0] != (Acc | Reg64)
+	      || i.types [1] != (Acc | Reg64)
+	      || i.tm.base_opcode != 0x90)
+	    i.rex |= REX_W;
+	}
+
+      /* Size floating point instruction.  */
+      if (i.suffix == LONG_MNEM_SUFFIX)
+	if (i.tm.opcode_modifier & FloatMF)
+	  i.tm.base_opcode ^= 4;
+    }
+
+  return 1;
+}
+
+static int
+check_byte_reg (void)
+{
+  int op;
+
+  for (op = i.operands; --op >= 0;)
+    {
+      /* If this is an eight bit register, it's OK.  If it's the 16 or
+	 32 bit version of an eight bit register, we will just use the
+	 low portion, and that's OK too.  */
+      if (i.types[op] & Reg8)
+	continue;
+
+      /* movzx, movsx, pextrb and pinsrb should not generate this
+	 warning.  */
+      if (intel_syntax
+	  && (i.tm.base_opcode == 0xfb7
+	      || i.tm.base_opcode == 0xfb6
+	      || i.tm.base_opcode == 0x63
+	      || i.tm.base_opcode == 0xfbe
+	      || i.tm.base_opcode == 0xfbf
+	      || i.tm.base_opcode == 0x660f3a14
+	      || i.tm.base_opcode == 0x660f3a20))
+	continue;
+
+      /* crc32 doesn't generate this warning.  */
+      if (i.tm.base_opcode == 0xf20f38f0)
+	continue;
+
+      if ((i.types[op] & WordReg) && i.op[op].regs->reg_num < 4)
+	{
+	  /* Prohibit these changes in the 64bit mode, since the
+	     lowering is more complicated.  */
+	  if (flag_code == CODE_64BIT
+	      && (i.tm.operand_types[op] & InOutPortReg) == 0)
+	    {
+	      as_bad (_("Incorrect register `%s%s' used with `%c' suffix"),
+		      register_prefix, i.op[op].regs->reg_name,
+		      i.suffix);
+	      return 0;
+	    }
+#if REGISTER_WARNINGS
+	  if (!quiet_warnings
+	      && (i.tm.operand_types[op] & InOutPortReg) == 0)
+	    as_warn (_("using `%s%s' instead of `%s%s' due to `%c' suffix"),
+		     register_prefix,
+		     (i.op[op].regs + (i.types[op] & Reg16
+				       ? REGNAM_AL - REGNAM_AX
+				       : REGNAM_AL - REGNAM_EAX))->reg_name,
+		     register_prefix,
+		     i.op[op].regs->reg_name,
+		     i.suffix);
+#endif
+	  continue;
+	}
+      /* Any other register is bad.  */
+      if (i.types[op] & (Reg | RegMMX | RegXMM
+			 | SReg2 | SReg3
+			 | Control | Debug | Test
+			 | FloatReg | FloatAcc))
+	{
+	  as_bad (_("`%s%s' not allowed with `%s%c'"),
+		  register_prefix,
+		  i.op[op].regs->reg_name,
+		  i.tm.name,
+		  i.suffix);
+	  return 0;
+	}
+    }
+  return 1;
+}
+
+static int
+check_long_reg (void)
+{
+  int op;
+
+  for (op = i.operands; --op >= 0;)
+    /* Reject eight bit registers, except where the template requires
+       them. (eg. movzb)  */
+    if ((i.types[op] & Reg8) != 0
+	&& (i.tm.operand_types[op] & (Reg16 | Reg32 | Acc)) != 0)
+      {
+	as_bad (_("`%s%s' not allowed with `%s%c'"),
+		register_prefix,
+		i.op[op].regs->reg_name,
+		i.tm.name,
+		i.suffix);
+	return 0;
+      }
+  /* Warn if the e prefix on a general reg is missing.  */
+    else if ((!quiet_warnings || flag_code == CODE_64BIT)
+	     && (i.types[op] & Reg16) != 0
+	     && (i.tm.operand_types[op] & (Reg32 | Acc)) != 0)
+      {
+	/* Prohibit these changes in the 64bit mode, since the
+	   lowering is more complicated.  */
+	if (flag_code == CODE_64BIT)
+	  {
+	    as_bad (_("Incorrect register `%s%s' used with `%c' suffix"),
+		    register_prefix, i.op[op].regs->reg_name,
+		    i.suffix);
+	    return 0;
+	  }
+#if REGISTER_WARNINGS
+	else
+	  as_warn (_("using `%s%s' instead of `%s%s' due to `%c' suffix"),
+		   register_prefix,
+		   (i.op[op].regs + REGNAM_EAX - REGNAM_AX)->reg_name,
+		   register_prefix,
+		   i.op[op].regs->reg_name,
+		   i.suffix);
+#endif
+      }
+  /* Warn if the r prefix on a general reg is missing.  */
+    else if ((i.types[op] & Reg64) != 0
+	     && (i.tm.operand_types[op] & (Reg32 | Acc)) != 0)
+      {
+	if (intel_syntax
+	    && i.tm.base_opcode == 0xf30f2d
+	    && (i.types[0] & RegXMM) == 0)
+	  {
+	    /* cvtss2si converts DWORD memory to Reg64.  We want
+	       REX byte. */
+	    i.suffix = QWORD_MNEM_SUFFIX;
+	  }
+	else
+	  {
+	    as_bad (_("Incorrect register `%s%s' used with `%c' suffix"),
+		    register_prefix, i.op[op].regs->reg_name,
+		    i.suffix);
+	    return 0;
+	  }
+      }
+  return 1;
+}
+
+static int
+check_qword_reg (void)
+{
+  int op;
+
+  for (op = i.operands; --op >= 0; )
+    /* Reject eight bit registers, except where the template requires
+       them. (eg. movzb)  */
+    if ((i.types[op] & Reg8) != 0
+	&& (i.tm.operand_types[op] & (Reg16 | Reg32 | Acc)) != 0)
+      {
+	as_bad (_("`%s%s' not allowed with `%s%c'"),
+		register_prefix,
+		i.op[op].regs->reg_name,
+		i.tm.name,
+		i.suffix);
+	return 0;
+      }
+  /* Warn if the e prefix on a general reg is missing.  */
+    else if ((i.types[op] & (Reg16 | Reg32)) != 0
+	     && (i.tm.operand_types[op] & (Reg32 | Acc)) != 0)
+      {
+	/* Prohibit these changes in the 64bit mode, since the
+	   lowering is more complicated.  */
+	if (intel_syntax
+	    && i.tm.base_opcode == 0xf20f2d
+	    && (i.types[0] & RegXMM) == 0)
+	  {
+	    /* cvtsd2si converts QWORD memory to Reg32.  We don't want
+	       REX byte. */
+	    i.suffix = LONG_MNEM_SUFFIX;
+	  }
+	else
+	  {
+	    as_bad (_("Incorrect register `%s%s' used with `%c' suffix"),
+		    register_prefix, i.op[op].regs->reg_name,
+		    i.suffix);
+	    return 0;
+	  }
+      }
+  return 1;
+}
+
+static int
+check_word_reg (void)
+{
+  int op;
+  for (op = i.operands; --op >= 0;)
+    /* Reject eight bit registers, except where the template requires
+       them. (eg. movzb)  */
+    if ((i.types[op] & Reg8) != 0
+	&& (i.tm.operand_types[op] & (Reg16 | Reg32 | Acc)) != 0)
+      {
+	as_bad (_("`%s%s' not allowed with `%s%c'"),
+		register_prefix,
+		i.op[op].regs->reg_name,
+		i.tm.name,
+		i.suffix);
+	return 0;
+      }
+  /* Warn if the e prefix on a general reg is present.  */
+    else if ((!quiet_warnings || flag_code == CODE_64BIT)
+	     && (i.types[op] & Reg32) != 0
+	     && (i.tm.operand_types[op] & (Reg16 | Acc)) != 0)
+      {
+	/* Prohibit these changes in the 64bit mode, since the
+	   lowering is more complicated.  */
+	if (flag_code == CODE_64BIT)
+	  {
+	    as_bad (_("Incorrect register `%s%s' used with `%c' suffix"),
+		    register_prefix, i.op[op].regs->reg_name,
+		    i.suffix);
+	    return 0;
+	  }
+	else
+#if REGISTER_WARNINGS
+	  as_warn (_("using `%s%s' instead of `%s%s' due to `%c' suffix"),
+		   register_prefix,
+		   (i.op[op].regs + REGNAM_AX - REGNAM_EAX)->reg_name,
+		   register_prefix,
+		   i.op[op].regs->reg_name,
+		   i.suffix);
+#endif
+      }
+  return 1;
+}
+
+static int
+finalize_imm (void)
+{
+  unsigned int overlap0, overlap1, overlap2;
+
+  overlap0 = i.types[0] & i.tm.operand_types[0];
+  if ((overlap0 & (Imm8 | Imm8S | Imm16 | Imm32 | Imm32S | Imm64))
+      && overlap0 != Imm8 && overlap0 != Imm8S
+      && overlap0 != Imm16 && overlap0 != Imm32S
+      && overlap0 != Imm32 && overlap0 != Imm64)
+    {
+      if (i.suffix)
+	{
+	  overlap0 &= (i.suffix == BYTE_MNEM_SUFFIX
+		       ? Imm8 | Imm8S
+		       : (i.suffix == WORD_MNEM_SUFFIX
+			  ? Imm16
+			  : (i.suffix == QWORD_MNEM_SUFFIX
+			     ? Imm64 | Imm32S
+			     : Imm32)));
+	}
+      else if (overlap0 == (Imm16 | Imm32S | Imm32)
+	       || overlap0 == (Imm16 | Imm32)
+	       || overlap0 == (Imm16 | Imm32S))
+	{
+	  overlap0 = ((flag_code == CODE_16BIT) ^ (i.prefix[DATA_PREFIX] != 0)
+		      ? Imm16 : Imm32S);
+	}
+      if (overlap0 != Imm8 && overlap0 != Imm8S
+	  && overlap0 != Imm16 && overlap0 != Imm32S
+	  && overlap0 != Imm32 && overlap0 != Imm64)
+	{
+	  as_bad (_("no instruction mnemonic suffix given; "
+		    "can't determine immediate size"));
+	  return 0;
+	}
+    }
+  i.types[0] = overlap0;
+
+  overlap1 = i.types[1] & i.tm.operand_types[1];
+  if ((overlap1 & (Imm8 | Imm8S | Imm16 | Imm32S | Imm32 | Imm64))
+      && overlap1 != Imm8 && overlap1 != Imm8S
+      && overlap1 != Imm16 && overlap1 != Imm32S
+      && overlap1 != Imm32 && overlap1 != Imm64)
+    {
+      if (i.suffix)
+	{
+	  overlap1 &= (i.suffix == BYTE_MNEM_SUFFIX
+		       ? Imm8 | Imm8S
+		       : (i.suffix == WORD_MNEM_SUFFIX
+			  ? Imm16
+			  : (i.suffix == QWORD_MNEM_SUFFIX
+			     ? Imm64 | Imm32S
+			     : Imm32)));
+	}
+      else if (overlap1 == (Imm16 | Imm32 | Imm32S)
+	       || overlap1 == (Imm16 | Imm32)
+	       || overlap1 == (Imm16 | Imm32S))
+	{
+	  overlap1 = ((flag_code == CODE_16BIT) ^ (i.prefix[DATA_PREFIX] != 0)
+		      ? Imm16 : Imm32S);
+	}
+      if (overlap1 != Imm8 && overlap1 != Imm8S
+	  && overlap1 != Imm16 && overlap1 != Imm32S
+	  && overlap1 != Imm32 && overlap1 != Imm64)
+	{
+	  as_bad (_("no instruction mnemonic suffix given; "
+		    "can't determine immediate size %x %c"),
+		  overlap1, i.suffix);
+	  return 0;
+	}
+    }
+  i.types[1] = overlap1;
+
+  overlap2 = i.types[2] & i.tm.operand_types[2];
+  assert ((overlap2 & Imm) == 0);
+  i.types[2] = overlap2;
+
+  return 1;
+}
+
+static int
+process_operands (void)
+{
+  /* Default segment register this instruction will use for memory
+     accesses.  0 means unknown.  This is only for optimizing out
+     unnecessary segment overrides.  */
+  const seg_entry *default_seg = 0;
+
+  /* The imul $imm, %reg instruction is converted into
+     imul $imm, %reg, %reg, and the clr %reg instruction
+     is converted into xor %reg, %reg.  */
+  if (i.tm.opcode_modifier & RegKludge)
+    {
+       if ((i.tm.cpu_flags & CpuSSE4_1))
+	 {
+	   /* The first operand in instruction blendvpd, blendvps and
+	      pblendvb in SSE4.1 is implicit and must be xmm0.  */
+	   assert (i.operands == 3
+		   && i.reg_operands >= 2
+		   && i.types[0] == RegXMM);
+	   if (i.op[0].regs->reg_num != 0)
+	     {
+	       if (intel_syntax)
+		 as_bad (_("the last operand of `%s' must be `%sxmm0'"),
+			 i.tm.name, register_prefix);
+	       else
+		 as_bad (_("the first operand of `%s' must be `%sxmm0'"),
+			 i.tm.name, register_prefix);
+	       return 0;
+	     }
+	   i.op[0] = i.op[1];
+	   i.op[1] = i.op[2];
+	   i.types[0] = i.types[1];
+	   i.types[1] = i.types[2];
+	   i.operands--;
+	   i.reg_operands--;
+
+	   /* We need to adjust fields in i.tm since they are used by
+	      build_modrm_byte.  */
+	   i.tm.operand_types [0] = i.tm.operand_types [1];
+	   i.tm.operand_types [1] = i.tm.operand_types [2];
+	   i.tm.operands--;
+	 }
+       else
+	 {
+	   unsigned int first_reg_op = (i.types[0] & Reg) ? 0 : 1;
+	   /* Pretend we saw the extra register operand.  */
+	   assert (i.reg_operands == 1
+		   && i.op[first_reg_op + 1].regs == 0);
+	   i.op[first_reg_op + 1].regs = i.op[first_reg_op].regs;
+	   i.types[first_reg_op + 1] = i.types[first_reg_op];
+	   i.operands++;
+	   i.reg_operands++;
+	 }
+    }
+
+  if (i.tm.opcode_modifier & ShortForm)
+    {
+      if (i.types[0] & (SReg2 | SReg3))
+	{
+	  if (i.tm.base_opcode == POP_SEG_SHORT
+	      && i.op[0].regs->reg_num == 1)
+	    {
+	      as_bad (_("you can't `pop %%cs'"));
+	      return 0;
+	    }
+	  i.tm.base_opcode |= (i.op[0].regs->reg_num << 3);
+	  if ((i.op[0].regs->reg_flags & RegRex) != 0)
+	    i.rex |= REX_B;
+	}
+      else
+	{
+	  /* The register or float register operand is in operand 0 or 1.  */
+	  unsigned int op = (i.types[0] & (Reg | FloatReg)) ? 0 : 1;
+	  /* Register goes in low 3 bits of opcode.  */
+	  i.tm.base_opcode |= i.op[op].regs->reg_num;
+	  if ((i.op[op].regs->reg_flags & RegRex) != 0)
+	    i.rex |= REX_B;
+	  if (!quiet_warnings && (i.tm.opcode_modifier & Ugh) != 0)
+	    {
+	      /* Warn about some common errors, but press on regardless.
+		 The first case can be generated by gcc (<= 2.8.1).  */
+	      if (i.operands == 2)
+		{
+		  /* Reversed arguments on faddp, fsubp, etc.  */
+		  as_warn (_("translating to `%s %s%s,%s%s'"), i.tm.name,
+			   register_prefix, i.op[1].regs->reg_name,
+			   register_prefix, i.op[0].regs->reg_name);
+		}
+	      else
+		{
+		  /* Extraneous `l' suffix on fp insn.  */
+		  as_warn (_("translating to `%s %s%s'"), i.tm.name,
+			   register_prefix, i.op[0].regs->reg_name);
+		}
+	    }
+	}
+    }
+  else if (i.tm.opcode_modifier & Modrm)
+    {
+      /* The opcode is completed (modulo i.tm.extension_opcode which
+	 must be put into the modrm byte).  Now, we make the modrm and
+	 index base bytes based on all the info we've collected.  */
+
+      default_seg = build_modrm_byte ();
+    }
+  else if ((i.tm.base_opcode & ~0x3) == MOV_AX_DISP32)
+    {
+      default_seg = &ds;
+    }
+  else if ((i.tm.opcode_modifier & IsString) != 0)
+    {
+      /* For the string instructions that allow a segment override
+	 on one of their operands, the default segment is ds.  */
+      default_seg = &ds;
+    }
+
+  if ((i.tm.base_opcode == 0x8d /* lea */
+       || (i.tm.cpu_flags & CpuSVME))
+      && i.seg[0] && !quiet_warnings)
+    as_warn (_("segment override on `%s' is ineffectual"), i.tm.name);
+
+  /* If a segment was explicitly specified, and the specified segment
+     is not the default, use an opcode prefix to select it.  If we
+     never figured out what the default segment is, then default_seg
+     will be zero at this point, and the specified segment prefix will
+     always be used.  */
+  if ((i.seg[0]) && (i.seg[0] != default_seg))
+    {
+      if (!add_prefix (i.seg[0]->seg_prefix))
+	return 0;
+    }
+  return 1;
+}
+
+static const seg_entry *
+build_modrm_byte (void)
+{
+  const seg_entry *default_seg = 0;
+
+  /* i.reg_operands MUST be the number of real register operands;
+     implicit registers do not count.  */
+  if (i.reg_operands == 2)
+    {
+      unsigned int source, dest;
+
+      switch (i.operands)
+	{
+	case 2:
+	  source = 0;
+	  break;
+	case 3:
+	  /* When there are 3 operands, one of them may be immediate,
+	     which may be the first or the last operand.  Otherwise,
+	     the first operand must be shift count register (cl). */
+	  assert (i.imm_operands == 1
+		  || (i.imm_operands == 0
+		      && (i.types[0] & ShiftCount)));
+	  source = (i.types[0] & (Imm | ShiftCount)) ? 1 : 0;
+	  break;
+	case 4:
+	  /* When there are 4 operands, the first two must be immediate
+	     operands. The source operand will be the 3rd one.  */
+	  assert (i.imm_operands == 2
+		  && (i.types[0] & Imm)
+		  && (i.types[1] & Imm));
+	  source = 2;
+	  break;
+	default:
+	  abort ();
+	}
+
+      dest = source + 1;
+
+      i.rm.mode = 3;
+      /* One of the register operands will be encoded in the i.tm.reg
+	 field, the other in the combined i.tm.mode and i.tm.regmem
+	 fields.  If no form of this instruction supports a memory
+	 destination operand, then we assume the source operand may
+	 sometimes be a memory operand and so we need to store the
+	 destination in the i.rm.reg field.  */
+      if ((i.tm.operand_types[dest] & (AnyMem | RegMem)) == 0)
+	{
+	  i.rm.reg = i.op[dest].regs->reg_num;
+	  i.rm.regmem = i.op[source].regs->reg_num;
+	  if ((i.op[dest].regs->reg_flags & RegRex) != 0)
+	    i.rex |= REX_R;
+	  if ((i.op[source].regs->reg_flags & RegRex) != 0)
+	    i.rex |= REX_B;
+	}
+      else
+	{
+	  i.rm.reg = i.op[source].regs->reg_num;
+	  i.rm.regmem = i.op[dest].regs->reg_num;
+	  if ((i.op[dest].regs->reg_flags & RegRex) != 0)
+	    i.rex |= REX_B;
+	  if ((i.op[source].regs->reg_flags & RegRex) != 0)
+	    i.rex |= REX_R;
+	}
+      if (flag_code != CODE_64BIT && (i.rex & (REX_R | REX_B)))
+	{
+	  if (!((i.types[0] | i.types[1]) & Control))
+	    abort ();
+	  i.rex &= ~(REX_R | REX_B);
+	  add_prefix (LOCK_PREFIX_OPCODE);
+	}
+    }
+  else
+    {			/* If it's not 2 reg operands...  */
+      if (i.mem_operands)
+	{
+	  unsigned int fake_zero_displacement = 0;
+	  unsigned int op;
+
+	  for (op = 0; op < i.operands; op++)
+	    if ((i.types[op] & AnyMem))
+	      break;
+	  assert (op < i.operands);
+
+	  default_seg = &ds;
+
+	  if (i.base_reg == 0)
+	    {
+	      i.rm.mode = 0;
+	      if (!i.disp_operands)
+		fake_zero_displacement = 1;
+	      if (i.index_reg == 0)
+		{
+		  /* Operand is just <disp>  */
+		  if (flag_code == CODE_64BIT)
+		    {
+		      /* 64bit mode overwrites the 32bit absolute
+			 addressing by RIP relative addressing and
+			 absolute addressing is encoded by one of the
+			 redundant SIB forms.  */
+		      i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
+		      i.sib.base = NO_BASE_REGISTER;
+		      i.sib.index = NO_INDEX_REGISTER;
+		      i.types[op] = ((i.prefix[ADDR_PREFIX] == 0)
+				     ? Disp32S : Disp32);
+		    }
+		  else if ((flag_code == CODE_16BIT)
+			   ^ (i.prefix[ADDR_PREFIX] != 0))
+		    {
+		      i.rm.regmem = NO_BASE_REGISTER_16;
+		      i.types[op] = Disp16;
+		    }
+		  else
+		    {
+		      i.rm.regmem = NO_BASE_REGISTER;
+		      i.types[op] = Disp32;
+		    }
+		}
+	      else /* !i.base_reg && i.index_reg  */
+		{
+		  i.sib.index = i.index_reg->reg_num;
+		  i.sib.base = NO_BASE_REGISTER;
+		  i.sib.scale = i.log2_scale_factor;
+		  i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
+		  i.types[op] &= ~Disp;
+		  if (flag_code != CODE_64BIT)
+		    i.types[op] |= Disp32;	/* Must be 32 bit */
+		  else
+		    i.types[op] |= Disp32S;
+		  if ((i.index_reg->reg_flags & RegRex) != 0)
+		    i.rex |= REX_X;
+		}
+	    }
+	  /* RIP addressing for 64bit mode.  */
+	  else if (i.base_reg->reg_type == BaseIndex)
+	    {
+	      i.rm.regmem = NO_BASE_REGISTER;
+	      i.types[op] &= ~ Disp;
+	      i.types[op] |= Disp32S;
+	      i.flags[op] |= Operand_PCrel;
+	      if (! i.disp_operands)
+		fake_zero_displacement = 1;
+	    }
+	  else if (i.base_reg->reg_type & Reg16)
+	    {
+	      switch (i.base_reg->reg_num)
+		{
+		case 3: /* (%bx)  */
+		  if (i.index_reg == 0)
+		    i.rm.regmem = 7;
+		  else /* (%bx,%si) -> 0, or (%bx,%di) -> 1  */
+		    i.rm.regmem = i.index_reg->reg_num - 6;
+		  break;
+		case 5: /* (%bp)  */
+		  default_seg = &ss;
+		  if (i.index_reg == 0)
+		    {
+		      i.rm.regmem = 6;
+		      if ((i.types[op] & Disp) == 0)
+			{
+			  /* fake (%bp) into 0(%bp)  */
+			  i.types[op] |= Disp8;
+			  fake_zero_displacement = 1;
+			}
+		    }
+		  else /* (%bp,%si) -> 2, or (%bp,%di) -> 3  */
+		    i.rm.regmem = i.index_reg->reg_num - 6 + 2;
+		  break;
+		default: /* (%si) -> 4 or (%di) -> 5  */
+		  i.rm.regmem = i.base_reg->reg_num - 6 + 4;
+		}
+	      i.rm.mode = mode_from_disp_size (i.types[op]);
+	    }
+	  else /* i.base_reg and 32/64 bit mode  */
+	    {
+	      if (flag_code == CODE_64BIT
+		  && (i.types[op] & Disp))
+		i.types[op] = ((i.types[op] & Disp8)
+			       | (i.prefix[ADDR_PREFIX] == 0
+				  ? Disp32S : Disp32));
+
+	      i.rm.regmem = i.base_reg->reg_num;
+	      if ((i.base_reg->reg_flags & RegRex) != 0)
+		i.rex |= REX_B;
+	      i.sib.base = i.base_reg->reg_num;
+	      /* x86-64 ignores REX prefix bit here to avoid decoder
+		 complications.  */
+	      if ((i.base_reg->reg_num & 7) == EBP_REG_NUM)
+		{
+		  default_seg = &ss;
+		  if (i.disp_operands == 0)
+		    {
+		      fake_zero_displacement = 1;
+		      i.types[op] |= Disp8;
+		    }
+		}
+	      else if (i.base_reg->reg_num == ESP_REG_NUM)
+		{
+		  default_seg = &ss;
+		}
+	      i.sib.scale = i.log2_scale_factor;
+	      if (i.index_reg == 0)
+		{
+		  /* <disp>(%esp) becomes two byte modrm with no index
+		     register.  We've already stored the code for esp
+		     in i.rm.regmem ie. ESCAPE_TO_TWO_BYTE_ADDRESSING.
+		     Any base register besides %esp will not use the
+		     extra modrm byte.  */
+		  i.sib.index = NO_INDEX_REGISTER;
+#if !SCALE1_WHEN_NO_INDEX
+		  /* Another case where we force the second modrm byte.  */
+		  if (i.log2_scale_factor)
+		    i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
+#endif
+		}
+	      else
+		{
+		  i.sib.index = i.index_reg->reg_num;
+		  i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
+		  if ((i.index_reg->reg_flags & RegRex) != 0)
+		    i.rex |= REX_X;
+		}
+
+	      if (i.disp_operands
+		  && (i.reloc[op] == BFD_RELOC_386_TLS_DESC_CALL
+		      || i.reloc[op] == BFD_RELOC_X86_64_TLSDESC_CALL))
+		i.rm.mode = 0;
+	      else
+		i.rm.mode = mode_from_disp_size (i.types[op]);
+	    }
+
+	  if (fake_zero_displacement)
+	    {
+	      /* Fakes a zero displacement assuming that i.types[op]
+		 holds the correct displacement size.  */
+	      expressionS *exp;
+
+	      assert (i.op[op].disps == 0);
+	      exp = &disp_expressions[i.disp_operands++];
+	      i.op[op].disps = exp;
+	      exp->X_op = O_constant;
+	      exp->X_add_number = 0;
+	      exp->X_add_symbol = (symbolS *) 0;
+	      exp->X_op_symbol = (symbolS *) 0;
+	    }
+	}
+
+      /* Fill in i.rm.reg or i.rm.regmem field with register operand
+	 (if any) based on i.tm.extension_opcode.  Again, we must be
+	 careful to make sure that segment/control/debug/test/MMX
+	 registers are coded into the i.rm.reg field.  */
+      if (i.reg_operands)
+	{
+	  unsigned int op;
+
+	  for (op = 0; op < i.operands; op++)
+	    if ((i.types[op] & (Reg | RegMMX | RegXMM
+				| SReg2 | SReg3
+				| Control | Debug | Test)))
+	      break;
+	  assert (op < i.operands);
+
+	  /* If there is an extension opcode to put here, the register
+	     number must be put into the regmem field.  */
+	  if (i.tm.extension_opcode != None)
+	    {
+	      i.rm.regmem = i.op[op].regs->reg_num;
+	      if ((i.op[op].regs->reg_flags & RegRex) != 0)
+		i.rex |= REX_B;
+	    }
+	  else
+	    {
+	      i.rm.reg = i.op[op].regs->reg_num;
+	      if ((i.op[op].regs->reg_flags & RegRex) != 0)
+		i.rex |= REX_R;
+	    }
+
+	  /* Now, if no memory operand has set i.rm.mode = 0, 1, 2 we
+	     must set it to 3 to indicate this is a register operand
+	     in the regmem field.  */
+	  if (!i.mem_operands)
+	    i.rm.mode = 3;
+	}
+
+      /* Fill in i.rm.reg field with extension opcode (if any).  */
+      if (i.tm.extension_opcode != None)
+	i.rm.reg = i.tm.extension_opcode;
+    }
+  return default_seg;
+}
+
+static void
+output_branch (void)
+{
+  char *p;
+  int code16;
+  int prefix;
+  relax_substateT subtype;
+  symbolS *sym;
+  offsetT off;
+
+  code16 = 0;
+  if (flag_code == CODE_16BIT)
+    code16 = CODE16;
+
+  prefix = 0;
+  if (i.prefix[DATA_PREFIX] != 0)
+    {
+      prefix = 1;
+      i.prefixes -= 1;
+      code16 ^= CODE16;
+    }
+  /* Pentium4 branch hints.  */
+  if (i.prefix[SEG_PREFIX] == CS_PREFIX_OPCODE /* not taken */
+      || i.prefix[SEG_PREFIX] == DS_PREFIX_OPCODE /* taken */)
+    {
+      prefix++;
+      i.prefixes--;
+    }
+  if (i.prefix[REX_PREFIX] != 0)
+    {
+      prefix++;
+      i.prefixes--;
+    }
+
+  if (i.prefixes != 0 && !intel_syntax)
+    as_warn (_("skipping prefixes on this instruction"));
+
+  /* It's always a symbol;  End frag & setup for relax.
+     Make sure there is enough room in this frag for the largest
+     instruction we may generate in md_convert_frag.  This is 2
+     bytes for the opcode and room for the prefix and largest
+     displacement.  */
+  frag_grow (prefix + 2 + 4);
+  /* Prefix and 1 opcode byte go in fr_fix.  */
+  p = frag_more (prefix + 1);
+  if (i.prefix[DATA_PREFIX] != 0)
+    *p++ = DATA_PREFIX_OPCODE;
+  if (i.prefix[SEG_PREFIX] == CS_PREFIX_OPCODE
+      || i.prefix[SEG_PREFIX] == DS_PREFIX_OPCODE)
+    *p++ = i.prefix[SEG_PREFIX];
+  if (i.prefix[REX_PREFIX] != 0)
+    *p++ = i.prefix[REX_PREFIX];
+  *p = i.tm.base_opcode;
+
+  if ((unsigned char) *p == JUMP_PC_RELATIVE)
+    subtype = ENCODE_RELAX_STATE (UNCOND_JUMP, SMALL);
+  else if ((cpu_arch_flags & Cpu386) != 0)
+    subtype = ENCODE_RELAX_STATE (COND_JUMP, SMALL);
+  else
+    subtype = ENCODE_RELAX_STATE (COND_JUMP86, SMALL);
+  subtype |= code16;
+
+  sym = i.op[0].disps->X_add_symbol;
+  off = i.op[0].disps->X_add_number;
+
+  if (i.op[0].disps->X_op != O_constant
+      && i.op[0].disps->X_op != O_symbol)
+    {
+      /* Handle complex expressions.  */
+      sym = make_expr_symbol (i.op[0].disps);
+      off = 0;
+    }
+
+  /* 1 possible extra opcode + 4 byte displacement go in var part.
+     Pass reloc in fr_var.  */
+  frag_var (rs_machine_dependent, 5, i.reloc[0], subtype, sym, off, p);
+}
+
+static void
+output_jump (void)
+{
+  char *p;
+  int size;
+  fixS *fixP;
+
+  if (i.tm.opcode_modifier & JumpByte)
+    {
+      /* This is a loop or jecxz type instruction.  */
+      size = 1;
+      if (i.prefix[ADDR_PREFIX] != 0)
+	{
+	  FRAG_APPEND_1_CHAR (ADDR_PREFIX_OPCODE);
+	  i.prefixes -= 1;
+	}
+      /* Pentium4 branch hints.  */
+      if (i.prefix[SEG_PREFIX] == CS_PREFIX_OPCODE /* not taken */
+	  || i.prefix[SEG_PREFIX] == DS_PREFIX_OPCODE /* taken */)
+	{
+	  FRAG_APPEND_1_CHAR (i.prefix[SEG_PREFIX]);
+	  i.prefixes--;
+	}
+    }
+  else
+    {
+      int code16;
+
+      code16 = 0;
+      if (flag_code == CODE_16BIT)
+	code16 = CODE16;
+
+      if (i.prefix[DATA_PREFIX] != 0)
+	{
+	  FRAG_APPEND_1_CHAR (DATA_PREFIX_OPCODE);
+	  i.prefixes -= 1;
+	  code16 ^= CODE16;
+	}
+
+      size = 4;
+      if (code16)
+	size = 2;
+    }
+
+  if (i.prefix[REX_PREFIX] != 0)
+    {
+      FRAG_APPEND_1_CHAR (i.prefix[REX_PREFIX]);
+      i.prefixes -= 1;
+    }
+
+  if (i.prefixes != 0 && !intel_syntax)
+    as_warn (_("skipping prefixes on this instruction"));
+
+  p = frag_more (1 + size);
+  *p++ = i.tm.base_opcode;
+
+  fixP = fix_new_exp (frag_now, p - frag_now->fr_literal, size,
+		      i.op[0].disps, 1, reloc (size, 1, 1, i.reloc[0]));
+
+  /* All jumps handled here are signed, but don't use a signed limit
+     check for 32 and 16 bit jumps as we want to allow wrap around at
+     4G and 64k respectively.  */
+  if (size == 1)
+    fixP->fx_signed = 1;
+}
+
+static void
+output_interseg_jump (void)
+{
+  char *p;
+  int size;
+  int prefix;
+  int code16;
+
+  code16 = 0;
+  if (flag_code == CODE_16BIT)
+    code16 = CODE16;
+
+  prefix = 0;
+  if (i.prefix[DATA_PREFIX] != 0)
+    {
+      prefix = 1;
+      i.prefixes -= 1;
+      code16 ^= CODE16;
+    }
+  if (i.prefix[REX_PREFIX] != 0)
+    {
+      prefix++;
+      i.prefixes -= 1;
+    }
+
+  size = 4;
+  if (code16)
+    size = 2;
+
+  if (i.prefixes != 0 && !intel_syntax)
+    as_warn (_("skipping prefixes on this instruction"));
+
+  /* 1 opcode; 2 segment; offset  */
+  p = frag_more (prefix + 1 + 2 + size);
+
+  if (i.prefix[DATA_PREFIX] != 0)
+    *p++ = DATA_PREFIX_OPCODE;
+
+  if (i.prefix[REX_PREFIX] != 0)
+    *p++ = i.prefix[REX_PREFIX];
+
+  *p++ = i.tm.base_opcode;
+  if (i.op[1].imms->X_op == O_constant)
+    {
+      offsetT n = i.op[1].imms->X_add_number;
+
+      if (size == 2
+	  && !fits_in_unsigned_word (n)
+	  && !fits_in_signed_word (n))
+	{
+	  as_bad (_("16-bit jump out of range"));
+	  return;
+	}
+      md_number_to_chars (p, n, size);
+    }
+  else
+    fix_new_exp (frag_now, p - frag_now->fr_literal, size,
+		 i.op[1].imms, 0, reloc (size, 0, 0, i.reloc[1]));
+  if (i.op[0].imms->X_op != O_constant)
+    as_bad (_("can't handle non absolute segment in `%s'"),
+	    i.tm.name);
+  md_number_to_chars (p + size, (valueT) i.op[0].imms->X_add_number, 2);
+}
+
+static void
+insert_sandbox_code (void)
+{
+  char* p;
+  int align_mask = (1 << nacl_alignment) - 1;
+
+  if (getenv("NACL_DEBUG_ALIGN")) {
+    p = frag_more (12);
+    p[0] = 0xF7; p[1] = 0xC0 + i.rm.regmem;
+    p[2] = align_mask; p[3] = p[4] = p[5] = 0x00; // TEST reg, align_mask
+    p[6] = 0x74; p[7] = 0x04; // JZ +4
+    p[8] = 0xCC; // INT3
+    p[9] = 0x0F; p[10] = 0x1F; p[11] = 0x00; // NOP
+  }
+  else {
+    p = frag_more (3);
+    p[0] = 0x83; // AND instruction.
+    p[1] = (0xe0 + i.rm.regmem); // mod = 11, reg = 100,  rm = i.rm.regmem;
+    p[2] = 0xff & ~align_mask;
+  }
+}
+
+
+static int
+frag_is_a_call (void)
+{
+  if (i.tm.base_opcode == 0xe8) {
+    // direct calls
+    return 1;
+  }
+  else if (i.tm.base_opcode == 0xff) {
+    // possibly indirect calls
+    return (i.rm.mode == 3) && (i.rm.reg == 2);
+  }
+  else {
+    return 0;
+  }
+}
+
+
+static void
+output_insn (void)
+{
+  fragS *insn_start_frag;
+  offsetT insn_start_off;
+
+  // DCS -- New code for NativeClient.
+  // Frag_align_code sets the alignment on the current fragment and may
+  // create a new one.  Because of this we remember the current fragment
+  // before calling frag_align_code.
+  insn_start_frag = frag_now;
+
+  if (nacl_alignment > 0) {
+    frag_align_code(0, 0);
+#ifdef DCS
+    // TODO(sehr): this code seems unnecessary.  Remove it.
+    // Really ugly stuff to avoid splitting call and its subsequent alignment
+    // across two fragments.
+    if (frag_is_a_call() &&
+        obstack_room(&frchain_now->frch_obstack) < (unsigned)((1<<(nacl_alignment+1))-1)) {
+      fragS *temp_frag = frag_now;
+      frag_align_code(nacl_alignment + 1, 0);
+      temp_frag->fr_offset = 0;
+      temp_frag->fr_subtype = 0;
+    }
+#endif /* DCS */
+  }
+
+  /* Tie dwarf2 debug info to the address at the start of the insn.
+     We can't do this after the insn has been output as the current
+     frag may have been closed off.  eg. by frag_var.  */
+  dwarf2_emit_insn (0);
+
+  insn_start_off = frag_now_fix ();
+
+  if (nacl_alignment > 0) {
+    if (!strcmp(i.tm.name, "naclcall")) {
+      insert_sandbox_code();
+    }
+    else if (!strcmp(i.tm.name, "nacljmp")) {
+      insert_sandbox_code();
+    }
+    else if (!strcmp(i.tm.name, "naclret")) {
+      insert_sandbox_code();
+    }
+  }
+
+  /* Output jumps.  */
+  if (i.tm.opcode_modifier & Jump)
+    output_branch ();
+  else if (i.tm.opcode_modifier & (JumpByte | JumpDword))
+    output_jump ();
+  else if (i.tm.opcode_modifier & JumpInterSegment)
+    output_interseg_jump ();
+  else
+    {
+      /* Output normal instructions here.  */
+      char *p;
+      unsigned char *q;
+      unsigned int prefix;
+
+      /* All opcodes on i386 have either 1 or 2 bytes.  SSSE3 and
+	 SSE4 instructions have 3 bytes.  We may use one more higher
+	 byte to specify a prefix the instruction requires.  Exclude
+	 instructions which are in both SSE4 and ABM.  */
+      if ((i.tm.cpu_flags & (CpuSSSE3 | CpuSSE4)) != 0
+	  && (i.tm.cpu_flags & CpuABM) == 0)
+	{
+	  if (i.tm.base_opcode & 0xff000000)
+	    {
+	      prefix = (i.tm.base_opcode >> 24) & 0xff;
+	      goto check_prefix;
+	    }
+	}
+      else if ((i.tm.base_opcode & 0xff0000) != 0)
+	{
+	  prefix = (i.tm.base_opcode >> 16) & 0xff;
+	  if ((i.tm.cpu_flags & CpuPadLock) != 0)
+	    {
+	    check_prefix:
+	      if (prefix != REPE_PREFIX_OPCODE
+		  || i.prefix[LOCKREP_PREFIX] != REPE_PREFIX_OPCODE)
+		add_prefix (prefix);
+	    }
+	  else
+	    add_prefix (prefix);
+	}
+
+      /* The prefix bytes.  */
+      for (q = i.prefix;
+	   q < i.prefix + sizeof (i.prefix) / sizeof (i.prefix[0]);
+	   q++)
+	{
+	  if (*q)
+	    {
+	      p = frag_more (1);
+	      md_number_to_chars (p, (valueT) *q, 1);
+	    }
+	}
+
+      /* Now the opcode; be careful about word order here!  */
+      if (fits_in_unsigned_byte (i.tm.base_opcode))
+	{
+	  FRAG_APPEND_1_CHAR (i.tm.base_opcode);
+	}
+      else
+	{
+	  if ((i.tm.cpu_flags & (CpuSSSE3 | CpuSSE4)) != 0
+	      && (i.tm.cpu_flags & CpuABM) == 0)
+	    {
+	      p = frag_more (3);
+	      *p++ = (i.tm.base_opcode >> 16) & 0xff;
+	    }
+	  else
+	    p = frag_more (2);
+
+	  /* Put out high byte first: can't use md_number_to_chars!  */
+	  *p++ = (i.tm.base_opcode >> 8) & 0xff;
+	  *p = i.tm.base_opcode & 0xff;
+	}
+
+      /* Now the modrm byte and sib byte (if present).  */
+      if (i.tm.opcode_modifier & Modrm)
+	{
+	  p = frag_more (1);
+	  md_number_to_chars (p,
+			      (valueT) (i.rm.regmem << 0
+					| i.rm.reg << 3
+					| i.rm.mode << 6),
+			      1);
+	  /* If i.rm.regmem == ESP (4)
+	     && i.rm.mode != (Register mode)
+	     && not 16 bit
+	     ==> need second modrm byte.  */
+	  if (i.rm.regmem == ESCAPE_TO_TWO_BYTE_ADDRESSING
+	      && i.rm.mode != 3
+	      && !(i.base_reg && (i.base_reg->reg_type & Reg16) != 0))
+	    {
+	      p = frag_more (1);
+	      md_number_to_chars (p,
+				  (valueT) (i.sib.base << 0
+					    | i.sib.index << 3
+					    | i.sib.scale << 6),
+				  1);
+	    }
+	}
+
+      if (i.disp_operands)
+	output_disp (frag_now, insn_start_off);
+
+      if (i.imm_operands)
+	output_imm (frag_now, insn_start_off);
+    }
+
+#ifdef DEBUG386
+  if (flag_debug)
+    {
+      pi ("" /*line*/, &i);
+    }
+#endif /* DEBUG386  */
+  /*
+   * We want to make sure no instruction straddles a (1 << nacl_alignment)
+   * boundary.  We do this by setting the fragment alignment to
+   * (1 << nacl_alignment), but allowing no more than the size of the
+   * instruction as fill.
+   */
+  if (nacl_alignment > 0) {
+    int align_base;
+    int call_align;
+    int instrsize = (int) frag_now_fix();
+
+    /*
+     * "library mode" enables compatible library builds for either 16 or
+     * 32 byte alignment.  Using the strictest alignment requirement for
+     * instructions makes them 0mod16 aligned.  Calls need to end a 32 byte
+     * region.
+     */
+    if (nacl_library_mode) {
+      align_base = 4;
+      call_align = 5;
+    }
+    else {
+      align_base = nacl_alignment;
+      call_align = nacl_alignment;
+    }
+
+    switch (instrsize) {
+      case 0:
+        // We get zero size for jump instructions.  Go to their biggest.
+        insn_start_frag->fr_offset = align_base;
+        insn_start_frag->fr_subtype = 5;
+        break;
+
+      case 1:
+        if ((i.tm.base_opcode == 0xf3) || (i.tm.base_opcode == 0xf2) ||
+            (i.tm.base_opcode == 0xf0)) {
+          // rep and lock refixes are treated as separate instructions.
+          // I don't know any other patch but to force an alignment to 0,
+          // i.e., waste as many bytes as it takes.
+          insn_start_frag->fr_offset = align_base;
+          insn_start_frag->fr_subtype = 0;
+        }
+        else {
+          // Don't align other one-byte instructions.
+          insn_start_frag->fr_offset = 0;
+          insn_start_frag->fr_subtype = 0;
+        }
+        break;
+
+      default:
+        // Don't use more than size-1 bytes to pad.
+        insn_start_frag->fr_offset = align_base;
+        insn_start_frag->fr_subtype = instrsize-1;
+        break;
+    }
+
+
+    /*
+     * Calls need to fall at the end of a (1 << call_align) region.  We
+     * make sure there are no instructions after the call until the next
+     * alignment.  During writing of the object we swap the nops before the
+     * instruction.
+     */
+    if (frag_is_a_call()) {
+      frag_now->is_call = 1;
+      frag_align_code(call_align,0);
+    }
+  }
+}
+
+/* Return the size of the displacement operand N.  */
+
+static int
+disp_size (unsigned int n)
+{
+  int size = 4;
+  if (i.types[n] & (Disp8 | Disp16 | Disp64))
+    {
+      size = 2;
+      if (i.types[n] & Disp8)
+	size = 1;
+      if (i.types[n] & Disp64)
+	size = 8;
+    }
+  return size;
+}
+
+/* Return the size of the immediate operand N.  */
+
+static int
+imm_size (unsigned int n)
+{
+  int size = 4;
+  if (i.types[n] & (Imm8 | Imm8S | Imm16 | Imm64))
+    {
+      size = 2;
+      if (i.types[n] & (Imm8 | Imm8S))
+	size = 1;
+      if (i.types[n] & Imm64)
+	size = 8;
+    }
+  return size;
+}
+
+static void
+output_disp (fragS *insn_start_frag, offsetT insn_start_off)
+{
+  char *p;
+  unsigned int n;
+
+  for (n = 0; n < i.operands; n++)
+    {
+      if (i.types[n] & Disp)
+	{
+	  if (i.op[n].disps->X_op == O_constant)
+	    {
+	      int size = disp_size (n);
+	      offsetT val;
+
+	      val = offset_in_range (i.op[n].disps->X_add_number,
+				     size);
+	      p = frag_more (size);
+	      md_number_to_chars (p, val, size);
+	    }
+	  else
+	    {
+	      enum bfd_reloc_code_real reloc_type;
+	      int size = disp_size (n);
+	      int sign = (i.types[n] & Disp32S) != 0;
+	      int pcrel = (i.flags[n] & Operand_PCrel) != 0;
+
+	      /* We can't have 8 bit displacement here.  */
+	      assert ((i.types[n] & Disp8) == 0);
+
+	      /* The PC relative address is computed relative
+		 to the instruction boundary, so in case immediate
+		 fields follows, we need to adjust the value.  */
+	      if (pcrel && i.imm_operands)
+		{
+		  unsigned int n1;
+		  int sz = 0;
+
+		  for (n1 = 0; n1 < i.operands; n1++)
+		    if (i.types[n1] & Imm)
+		      {
+			/* Only one immediate is allowed for PC
+			   relative address.  */
+			assert (sz == 0);
+			sz = imm_size (n1);
+			i.op[n].disps->X_add_number -= sz;
+		      }
+		  /* We should find the immediate.  */
+		  assert (sz != 0);
+		}
+
+	      p = frag_more (size);
+	      reloc_type = reloc (size, pcrel, sign, i.reloc[n]);
+	      if (GOT_symbol
+		  && GOT_symbol == i.op[n].disps->X_add_symbol
+		  && (((reloc_type == BFD_RELOC_32
+			|| reloc_type == BFD_RELOC_X86_64_32S
+			|| (reloc_type == BFD_RELOC_64
+			    && object_64bit))
+		       && (i.op[n].disps->X_op == O_symbol
+			   || (i.op[n].disps->X_op == O_add
+			       && ((symbol_get_value_expression
+				    (i.op[n].disps->X_op_symbol)->X_op)
+				   == O_subtract))))
+		      || reloc_type == BFD_RELOC_32_PCREL))
+		{
+		  offsetT add;
+
+		  if (insn_start_frag == frag_now)
+		    add = (p - frag_now->fr_literal) - insn_start_off;
+		  else
+		    {
+		      fragS *fr;
+
+		      add = insn_start_frag->fr_fix - insn_start_off;
+		      for (fr = insn_start_frag->fr_next;
+			   fr && fr != frag_now; fr = fr->fr_next)
+			add += fr->fr_fix;
+		      add += p - frag_now->fr_literal;
+		    }
+
+		  if (!object_64bit)
+		    {
+		      reloc_type = BFD_RELOC_386_GOTPC;
+		      i.op[n].imms->X_add_number += add;
+		    }
+		  else if (reloc_type == BFD_RELOC_64)
+		    reloc_type = BFD_RELOC_X86_64_GOTPC64;
+		  else
+		    /* Don't do the adjustment for x86-64, as there
+		       the pcrel addressing is relative to the _next_
+		       insn, and that is taken care of in other code.  */
+		    reloc_type = BFD_RELOC_X86_64_GOTPC32;
+		}
+	      fix_new_exp (frag_now, p - frag_now->fr_literal, size,
+			   i.op[n].disps, pcrel, reloc_type);
+	    }
+	}
+    }
+}
+
+static void
+output_imm (fragS *insn_start_frag, offsetT insn_start_off)
+{
+  char *p;
+  unsigned int n;
+
+  for (n = 0; n < i.operands; n++)
+    {
+      if (i.types[n] & Imm)
+	{
+	  if (i.op[n].imms->X_op == O_constant)
+	    {
+	      int size = imm_size (n);
+	      offsetT val;
+
+	      val = offset_in_range (i.op[n].imms->X_add_number,
+				     size);
+	      p = frag_more (size);
+	      md_number_to_chars (p, val, size);
+	    }
+	  else
+	    {
+	      /* Not absolute_section.
+		 Need a 32-bit fixup (don't support 8bit
+		 non-absolute imms).  Try to support other
+		 sizes ...  */
+	      enum bfd_reloc_code_real reloc_type;
+	      int size = imm_size (n);
+	      int sign;
+
+	      if ((i.types[n] & (Imm32S))
+		  && (i.suffix == QWORD_MNEM_SUFFIX
+		      || (!i.suffix && (i.tm.opcode_modifier & No_lSuf))))
+		sign = 1;
+	      else
+		sign = 0;
+
+	      p = frag_more (size);
+	      reloc_type = reloc (size, 0, sign, i.reloc[n]);
+
+	      /*   This is tough to explain.  We end up with this one if we
+	       * have operands that look like
+	       * "_GLOBAL_OFFSET_TABLE_+[.-.L284]".  The goal here is to
+	       * obtain the absolute address of the GOT, and it is strongly
+	       * preferable from a performance point of view to avoid using
+	       * a runtime relocation for this.  The actual sequence of
+	       * instructions often look something like:
+	       *
+	       *	call	.L66
+	       * .L66:
+	       *	popl	%ebx
+	       *	addl	$_GLOBAL_OFFSET_TABLE_+[.-.L66],%ebx
+	       *
+	       *   The call and pop essentially return the absolute address
+	       * of the label .L66 and store it in %ebx.  The linker itself
+	       * will ultimately change the first operand of the addl so
+	       * that %ebx points to the GOT, but to keep things simple, the
+	       * .o file must have this operand set so that it generates not
+	       * the absolute address of .L66, but the absolute address of
+	       * itself.  This allows the linker itself simply treat a GOTPC
+	       * relocation as asking for a pcrel offset to the GOT to be
+	       * added in, and the addend of the relocation is stored in the
+	       * operand field for the instruction itself.
+	       *
+	       *   Our job here is to fix the operand so that it would add
+	       * the correct offset so that %ebx would point to itself.  The
+	       * thing that is tricky is that .-.L66 will point to the
+	       * beginning of the instruction, so we need to further modify
+	       * the operand so that it will point to itself.  There are
+	       * other cases where you have something like:
+	       *
+	       *	.long	$_GLOBAL_OFFSET_TABLE_+[.-.L66]
+	       *
+	       * and here no correction would be required.  Internally in
+	       * the assembler we treat operands of this form as not being
+	       * pcrel since the '.' is explicitly mentioned, and I wonder
+	       * whether it would simplify matters to do it this way.  Who
+	       * knows.  In earlier versions of the PIC patches, the
+	       * pcrel_adjust field was used to store the correction, but
+	       * since the expression is not pcrel, I felt it would be
+	       * confusing to do it this way.  */
+
+	      if ((reloc_type == BFD_RELOC_32
+		   || reloc_type == BFD_RELOC_X86_64_32S
+		   || reloc_type == BFD_RELOC_64)
+		  && GOT_symbol
+		  && GOT_symbol == i.op[n].imms->X_add_symbol
+		  && (i.op[n].imms->X_op == O_symbol
+		      || (i.op[n].imms->X_op == O_add
+			  && ((symbol_get_value_expression
+			       (i.op[n].imms->X_op_symbol)->X_op)
+			      == O_subtract))))
+		{
+		  offsetT add;
+
+		  if (insn_start_frag == frag_now)
+		    add = (p - frag_now->fr_literal) - insn_start_off;
+		  else
+		    {
+		      fragS *fr;
+
+		      add = insn_start_frag->fr_fix - insn_start_off;
+		      for (fr = insn_start_frag->fr_next;
+			   fr && fr != frag_now; fr = fr->fr_next)
+			add += fr->fr_fix;
+		      add += p - frag_now->fr_literal;
+		    }
+
+		  if (!object_64bit)
+		    reloc_type = BFD_RELOC_386_GOTPC;
+		  else if (size == 4)
+		    reloc_type = BFD_RELOC_X86_64_GOTPC32;
+		  else if (size == 8)
+		    reloc_type = BFD_RELOC_X86_64_GOTPC64;
+		  i.op[n].imms->X_add_number += add;
+		}
+	      fix_new_exp (frag_now, p - frag_now->fr_literal, size,
+			   i.op[n].imms, 0, reloc_type);
+	    }
+	}
+    }
+}
+
+/* x86_cons_fix_new is called via the expression parsing code when a
+   reloc is needed.  We use this hook to get the correct .got reloc.  */
+static enum bfd_reloc_code_real got_reloc = NO_RELOC;
+static int cons_sign = -1;
+
+void
+x86_cons_fix_new (fragS *frag, unsigned int off, unsigned int len,
+		  expressionS *exp)
+{
+  enum bfd_reloc_code_real r = reloc (len, 0, cons_sign, got_reloc);
+
+  got_reloc = NO_RELOC;
+
+#ifdef TE_PE
+  if (exp->X_op == O_secrel)
+    {
+      exp->X_op = O_symbol;
+      r = BFD_RELOC_32_SECREL;
+    }
+#endif
+
+  fix_new_exp (frag, off, len, exp, 0, r);
+}
+
+#if (!defined (OBJ_ELF) && !defined (OBJ_MAYBE_ELF)) || defined (LEX_AT)
+# define lex_got(reloc, adjust, types) NULL
+#else
+/* Parse operands of the form
+   <symbol>@GOTOFF+<nnn>
+   and similar .plt or .got references.
+
+   If we find one, set up the correct relocation in RELOC and copy the
+   input string, minus the `@GOTOFF' into a malloc'd buffer for
+   parsing by the calling routine.  Return this buffer, and if ADJUST
+   is non-null set it to the length of the string we removed from the
+   input line.  Otherwise return NULL.  */
+static char *
+lex_got (enum bfd_reloc_code_real *reloc,
+	 int *adjust,
+	 unsigned int *types)
+{
+  /* Some of the relocations depend on the size of what field is to
+     be relocated.  But in our callers i386_immediate and i386_displacement
+     we don't yet know the operand size (this will be set by insn
+     matching).  Hence we record the word32 relocation here,
+     and adjust the reloc according to the real size in reloc().  */
+  static const struct {
+    const char *str;
+    const enum bfd_reloc_code_real rel[2];
+    const unsigned int types64;
+  } gotrel[] = {
+    { "PLTOFF",   { 0,
+		    BFD_RELOC_X86_64_PLTOFF64 },
+      Imm64 },
+    { "PLT",      { BFD_RELOC_386_PLT32,
+		    BFD_RELOC_X86_64_PLT32    },
+      Imm32 | Imm32S | Disp32 },
+    { "GOTPLT",   { 0,
+		    BFD_RELOC_X86_64_GOTPLT64 },
+      Imm64 | Disp64 },
+    { "GOTOFF",   { BFD_RELOC_386_GOTOFF,
+		    BFD_RELOC_X86_64_GOTOFF64 },
+      Imm64 | Disp64 },
+    { "GOTPCREL", { 0,
+		    BFD_RELOC_X86_64_GOTPCREL },
+      Imm32 | Imm32S | Disp32 },
+    { "TLSGD",    { BFD_RELOC_386_TLS_GD,
+		    BFD_RELOC_X86_64_TLSGD    },
+      Imm32 | Imm32S | Disp32 },
+    { "TLSLDM",   { BFD_RELOC_386_TLS_LDM,
+		    0                         },
+      0 },
+    { "TLSLD",    { 0,
+		    BFD_RELOC_X86_64_TLSLD    },
+      Imm32 | Imm32S | Disp32 },
+    { "GOTTPOFF", { BFD_RELOC_386_TLS_IE_32,
+		    BFD_RELOC_X86_64_GOTTPOFF },
+      Imm32 | Imm32S | Disp32 },
+    { "TPOFF",    { BFD_RELOC_386_TLS_LE_32,
+		    BFD_RELOC_X86_64_TPOFF32  },
+      Imm32 | Imm32S | Imm64 | Disp32 | Disp64 },
+    { "NTPOFF",   { BFD_RELOC_386_TLS_LE,
+		    0                         },
+      0 },
+    { "DTPOFF",   { BFD_RELOC_386_TLS_LDO_32,
+		    BFD_RELOC_X86_64_DTPOFF32 },
+      Imm32 | Imm32S | Imm64 | Disp32 | Disp64 },
+    { "GOTNTPOFF",{ BFD_RELOC_386_TLS_GOTIE,
+		    0                         },
+      0 },
+    { "INDNTPOFF",{ BFD_RELOC_386_TLS_IE,
+		    0                         },
+      0 },
+    { "GOT",      { BFD_RELOC_386_GOT32,
+		    BFD_RELOC_X86_64_GOT32    },
+      Imm32 | Imm32S | Disp32 | Imm64 },
+    { "TLSDESC",  { BFD_RELOC_386_TLS_GOTDESC,
+		    BFD_RELOC_X86_64_GOTPC32_TLSDESC },
+      Imm32 | Imm32S | Disp32 },
+    { "TLSCALL",  { BFD_RELOC_386_TLS_DESC_CALL,
+		    BFD_RELOC_X86_64_TLSDESC_CALL },
+      Imm32 | Imm32S | Disp32 }
+  };
+  char *cp;
+  unsigned int j;
+
+  if (!IS_ELF)
+    return NULL;
+
+  for (cp = input_line_pointer; *cp != '@'; cp++)
+    if (is_end_of_line[(unsigned char) *cp] || *cp == ',')
+      return NULL;
+
+  for (j = 0; j < sizeof (gotrel) / sizeof (gotrel[0]); j++)
+    {
+      int len;
+
+      len = strlen (gotrel[j].str);
+      if (strncasecmp (cp + 1, gotrel[j].str, len) == 0)
+	{
+	  if (gotrel[j].rel[object_64bit] != 0)
+	    {
+	      int first, second;
+	      char *tmpbuf, *past_reloc;
+
+	      *reloc = gotrel[j].rel[object_64bit];
+	      if (adjust)
+		*adjust = len;
+
+	      if (types)
+		{
+		  if (flag_code != CODE_64BIT)
+		    *types = Imm32 | Disp32;
+		  else
+		    *types = gotrel[j].types64;
+		}
+
+	      if (GOT_symbol == NULL)
+		GOT_symbol = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);
+
+	      /* The length of the first part of our input line.  */
+	      first = cp - input_line_pointer;
+
+	      /* The second part goes from after the reloc token until
+		 (and including) an end_of_line char or comma.  */
+	      past_reloc = cp + 1 + len;
+	      cp = past_reloc;
+	      while (!is_end_of_line[(unsigned char) *cp] && *cp != ',')
+		++cp;
+	      second = cp + 1 - past_reloc;
+
+	      /* Allocate and copy string.  The trailing NUL shouldn't
+		 be necessary, but be safe.  */
+	      tmpbuf = xmalloc (first + second + 2);
+	      memcpy (tmpbuf, input_line_pointer, first);
+	      if (second != 0 && *past_reloc != ' ')
+		/* Replace the relocation token with ' ', so that
+		   errors like foo@GOTOFF1 will be detected.  */
+		tmpbuf[first++] = ' ';
+	      memcpy (tmpbuf + first, past_reloc, second);
+	      tmpbuf[first + second] = '\0';
+	      return tmpbuf;
+	    }
+
+	  as_bad (_("@%s reloc is not supported with %d-bit output format"),
+		  gotrel[j].str, 1 << (5 + object_64bit));
+	  return NULL;
+	}
+    }
+
+  /* Might be a symbol version string.  Don't as_bad here.  */
+  return NULL;
+}
+
+void
+x86_cons (expressionS *exp, int size)
+{
+  if (size == 4 || (object_64bit && size == 8))
+    {
+      /* Handle @GOTOFF and the like in an expression.  */
+      char *save;
+      char *gotfree_input_line;
+      int adjust;
+
+      save = input_line_pointer;
+      gotfree_input_line = lex_got (&got_reloc, &adjust, NULL);
+      if (gotfree_input_line)
+	input_line_pointer = gotfree_input_line;
+
+      expression (exp);
+
+      if (gotfree_input_line)
+	{
+	  /* expression () has merrily parsed up to the end of line,
+	     or a comma - in the wrong buffer.  Transfer how far
+	     input_line_pointer has moved to the right buffer.  */
+	  input_line_pointer = (save
+				+ (input_line_pointer - gotfree_input_line)
+				+ adjust);
+	  free (gotfree_input_line);
+	}
+    }
+  else
+    expression (exp);
+}
+#endif
+
+static void signed_cons (int size)
+{
+  if (flag_code == CODE_64BIT)
+    cons_sign = 1;
+  cons (size);
+  cons_sign = -1;
+}
+
+#ifdef TE_PE
+static void
+pe_directive_secrel (dummy)
+     int dummy ATTRIBUTE_UNUSED;
+{
+  expressionS exp;
+
+  do
+    {
+      expression (&exp);
+      if (exp.X_op == O_symbol)
+	exp.X_op = O_secrel;
+
+      emit_expr (&exp, 4);
+    }
+  while (*input_line_pointer++ == ',');
+
+  input_line_pointer--;
+  demand_empty_rest_of_line ();
+}
+#endif
+
+static int
+i386_immediate (char *imm_start)
+{
+  char *save_input_line_pointer;
+  char *gotfree_input_line;
+  segT exp_seg = 0;
+  expressionS *exp;
+  unsigned int types = ~0U;
+
+  if (i.imm_operands == MAX_IMMEDIATE_OPERANDS)
+    {
+      as_bad (_("at most %d immediate operands are allowed"),
+	      MAX_IMMEDIATE_OPERANDS);
+      return 0;
+    }
+
+  exp = &im_expressions[i.imm_operands++];
+  i.op[this_operand].imms = exp;
+
+  if (is_space_char (*imm_start))
+    ++imm_start;
+
+  save_input_line_pointer = input_line_pointer;
+  input_line_pointer = imm_start;
+
+  gotfree_input_line = lex_got (&i.reloc[this_operand], NULL, &types);
+  if (gotfree_input_line)
+    input_line_pointer = gotfree_input_line;
+
+  exp_seg = expression (exp);
+
+  SKIP_WHITESPACE ();
+  if (*input_line_pointer)
+    as_bad (_("junk `%s' after expression"), input_line_pointer);
+
+  input_line_pointer = save_input_line_pointer;
+  if (gotfree_input_line)
+    free (gotfree_input_line);
+
+  if (exp->X_op == O_absent || exp->X_op == O_big)
+    {
+      /* Missing or bad expr becomes absolute 0.  */
+      as_bad (_("missing or invalid immediate expression `%s' taken as 0"),
+	      imm_start);
+      exp->X_op = O_constant;
+      exp->X_add_number = 0;
+      exp->X_add_symbol = (symbolS *) 0;
+      exp->X_op_symbol = (symbolS *) 0;
+    }
+  else if (exp->X_op == O_constant)
+    {
+      /* Size it properly later.  */
+      i.types[this_operand] |= Imm64;
+      /* If BFD64, sign extend val.  */
+      if (!use_rela_relocations
+	  && (exp->X_add_number & ~(((addressT) 2 << 31) - 1)) == 0)
+	exp->X_add_number
+	  = (exp->X_add_number ^ ((addressT) 1 << 31)) - ((addressT) 1 << 31);
+    }
+#if (defined (OBJ_AOUT) || defined (OBJ_MAYBE_AOUT))
+  else if (OUTPUT_FLAVOR == bfd_target_aout_flavour
+	   && exp_seg != absolute_section
+	   && exp_seg != text_section
+	   && exp_seg != data_section
+	   && exp_seg != bss_section
+	   && exp_seg != undefined_section
+	   && !bfd_is_com_section (exp_seg))
+    {
+      as_bad (_("unimplemented segment %s in operand"), exp_seg->name);
+      return 0;
+    }
+#endif
+  else if (!intel_syntax && exp->X_op == O_register)
+    {
+      as_bad (_("illegal immediate register operand %s"), imm_start);
+      return 0;
+    }
+  else
+    {
+      /* This is an address.  The size of the address will be
+	 determined later, depending on destination register,
+	 suffix, or the default for the section.  */
+      i.types[this_operand] |= Imm8 | Imm16 | Imm32 | Imm32S | Imm64;
+      i.types[this_operand] &= types;
+    }
+
+  return 1;
+}
+
+static char *
+i386_scale (char *scale)
+{
+  offsetT val;
+  char *save = input_line_pointer;
+
+  input_line_pointer = scale;
+  val = get_absolute_expression ();
+
+  switch (val)
+    {
+    case 1:
+      i.log2_scale_factor = 0;
+      break;
+    case 2:
+      i.log2_scale_factor = 1;
+      break;
+    case 4:
+      i.log2_scale_factor = 2;
+      break;
+    case 8:
+      i.log2_scale_factor = 3;
+      break;
+    default:
+      {
+	char sep = *input_line_pointer;
+
+	*input_line_pointer = '\0';
+	as_bad (_("expecting scale factor of 1, 2, 4, or 8: got `%s'"),
+		scale);
+	*input_line_pointer = sep;
+	input_line_pointer = save;
+	return NULL;
+      }
+    }
+  if (i.log2_scale_factor != 0 && i.index_reg == 0)
+    {
+      as_warn (_("scale factor of %d without an index register"),
+	       1 << i.log2_scale_factor);
+#if SCALE1_WHEN_NO_INDEX
+      i.log2_scale_factor = 0;
+#endif
+    }
+  scale = input_line_pointer;
+  input_line_pointer = save;
+  return scale;
+}
+
+static int
+i386_displacement (char *disp_start, char *disp_end)
+{
+  expressionS *exp;
+  segT exp_seg = 0;
+  char *save_input_line_pointer;
+  char *gotfree_input_line;
+  int bigdisp, override;
+  unsigned int types = Disp;
+
+  if (i.disp_operands == MAX_MEMORY_OPERANDS)
+    {
+      as_bad (_("at most %d displacement operands are allowed"),
+	      MAX_MEMORY_OPERANDS);
+      return 0;
+    }
+
+  if ((i.types[this_operand] & JumpAbsolute)
+      || !(current_templates->start->opcode_modifier & (Jump | JumpDword)))
+    {
+      bigdisp = Disp32;
+      override = (i.prefix[ADDR_PREFIX] != 0);
+    }
+  else
+    {
+      /* For PC-relative branches, the width of the displacement
+	 is dependent upon data size, not address size.  */
+      bigdisp = 0;
+      override = (i.prefix[DATA_PREFIX] != 0);
+    }
+  if (flag_code == CODE_64BIT)
+    {
+      if (!bigdisp)
+	bigdisp = ((override || i.suffix == WORD_MNEM_SUFFIX)
+		   ? Disp16
+		   : Disp32S | Disp32);
+      else if (!override)
+	bigdisp = Disp64 | Disp32S | Disp32;
+    }
+  else
+    {
+      if (!bigdisp)
+	{
+	  if (!override)
+	    override = (i.suffix == (flag_code != CODE_16BIT
+				     ? WORD_MNEM_SUFFIX
+				     : LONG_MNEM_SUFFIX));
+	  bigdisp = Disp32;
+	}
+      if ((flag_code == CODE_16BIT) ^ override)
+	bigdisp = Disp16;
+    }
+  i.types[this_operand] |= bigdisp;
+
+  exp = &disp_expressions[i.disp_operands];
+  i.op[this_operand].disps = exp;
+  i.disp_operands++;
+  save_input_line_pointer = input_line_pointer;
+  input_line_pointer = disp_start;
+  END_STRING_AND_SAVE (disp_end);
+
+#ifndef GCC_ASM_O_HACK
+#define GCC_ASM_O_HACK 0
+#endif
+#if GCC_ASM_O_HACK
+  END_STRING_AND_SAVE (disp_end + 1);
+  if ((i.types[this_operand] & BaseIndex) != 0
+      && displacement_string_end[-1] == '+')
+    {
+      /* This hack is to avoid a warning when using the "o"
+	 constraint within gcc asm statements.
+	 For instance:
+
+	 #define _set_tssldt_desc(n,addr,limit,type) \
+	 __asm__ __volatile__ ( \
+	 "movw %w2,%0\n\t" \
+	 "movw %w1,2+%0\n\t" \
+	 "rorl $16,%1\n\t" \
+	 "movb %b1,4+%0\n\t" \
+	 "movb %4,5+%0\n\t" \
+	 "movb $0,6+%0\n\t" \
+	 "movb %h1,7+%0\n\t" \
+	 "rorl $16,%1" \
+	 : "=o"(*(n)) : "q" (addr), "ri"(limit), "i"(type))
+
+	 This works great except that the output assembler ends
+	 up looking a bit weird if it turns out that there is
+	 no offset.  You end up producing code that looks like:
+
+	 #APP
+	 movw $235,(%eax)
+	 movw %dx,2+(%eax)
+	 rorl $16,%edx
+	 movb %dl,4+(%eax)
+	 movb $137,5+(%eax)
+	 movb $0,6+(%eax)
+	 movb %dh,7+(%eax)
+	 rorl $16,%edx
+	 #NO_APP
+
+	 So here we provide the missing zero.  */
+
+      *displacement_string_end = '0';
+    }
+#endif
+  gotfree_input_line = lex_got (&i.reloc[this_operand], NULL, &types);
+  if (gotfree_input_line)
+    input_line_pointer = gotfree_input_line;
+
+  exp_seg = expression (exp);
+
+  SKIP_WHITESPACE ();
+  if (*input_line_pointer)
+    as_bad (_("junk `%s' after expression"), input_line_pointer);
+#if GCC_ASM_O_HACK
+  RESTORE_END_STRING (disp_end + 1);
+#endif
+  RESTORE_END_STRING (disp_end);
+  input_line_pointer = save_input_line_pointer;
+  if (gotfree_input_line)
+    free (gotfree_input_line);
+
+  /* We do this to make sure that the section symbol is in
+     the symbol table.  We will ultimately change the relocation
+     to be relative to the beginning of the section.  */
+  if (i.reloc[this_operand] == BFD_RELOC_386_GOTOFF
+      || i.reloc[this_operand] == BFD_RELOC_X86_64_GOTPCREL
+      || i.reloc[this_operand] == BFD_RELOC_X86_64_GOTOFF64)
+    {
+      if (exp->X_op != O_symbol)
+	{
+	  as_bad (_("bad expression used with @%s"),
+		  (i.reloc[this_operand] == BFD_RELOC_X86_64_GOTPCREL
+		   ? "GOTPCREL"
+		   : "GOTOFF"));
+	  return 0;
+	}
+
+      if (S_IS_LOCAL (exp->X_add_symbol)
+	  && S_GET_SEGMENT (exp->X_add_symbol) != undefined_section)
+	section_symbol (S_GET_SEGMENT (exp->X_add_symbol));
+      exp->X_op = O_subtract;
+      exp->X_op_symbol = GOT_symbol;
+      if (i.reloc[this_operand] == BFD_RELOC_X86_64_GOTPCREL)
+	i.reloc[this_operand] = BFD_RELOC_32_PCREL;
+      else if (i.reloc[this_operand] == BFD_RELOC_X86_64_GOTOFF64)
+	i.reloc[this_operand] = BFD_RELOC_64;
+      else
+	i.reloc[this_operand] = BFD_RELOC_32;
+    }
+
+  if (exp->X_op == O_absent || exp->X_op == O_big)
+    {
+      /* Missing or bad expr becomes absolute 0.  */
+      as_bad (_("missing or invalid displacement expression `%s' taken as 0"),
+	      disp_start);
+      exp->X_op = O_constant;
+      exp->X_add_number = 0;
+      exp->X_add_symbol = (symbolS *) 0;
+      exp->X_op_symbol = (symbolS *) 0;
+    }
+
+#if (defined (OBJ_AOUT) || defined (OBJ_MAYBE_AOUT))
+  if (exp->X_op != O_constant
+      && OUTPUT_FLAVOR == bfd_target_aout_flavour
+      && exp_seg != absolute_section
+      && exp_seg != text_section
+      && exp_seg != data_section
+      && exp_seg != bss_section
+      && exp_seg != undefined_section
+      && !bfd_is_com_section (exp_seg))
+    {
+      as_bad (_("unimplemented segment %s in operand"), exp_seg->name);
+      return 0;
+    }
+#endif
+
+  if (!(i.types[this_operand] & ~Disp))
+    i.types[this_operand] &= types;
+
+  return 1;
+}
+
+/* Make sure the memory operand we've been dealt is valid.
+   Return 1 on success, 0 on a failure.  */
+
+static int
+i386_index_check (const char *operand_string)
+{
+  int ok;
+#if INFER_ADDR_PREFIX
+  int fudged = 0;
+
+ tryprefix:
+#endif
+  ok = 1;
+  if ((current_templates->start->cpu_flags & CpuSVME)
+      && current_templates->end[-1].operand_types[0] == AnyMem)
+    {
+      /* Memory operands of SVME insns are special in that they only allow
+	 rAX as their memory address and ignore any segment override.  */
+      unsigned RegXX;
+
+      /* SKINIT is even more restrictive: it always requires EAX.  */
+      if (strcmp (current_templates->start->name, "skinit") == 0)
+	RegXX = Reg32;
+      else if (flag_code == CODE_64BIT)
+	RegXX = i.prefix[ADDR_PREFIX] == 0 ? Reg64 : Reg32;
+      else
+	RegXX = ((flag_code == CODE_16BIT) ^ (i.prefix[ADDR_PREFIX] != 0)
+		 ? Reg16
+		 : Reg32);
+      if (!i.base_reg
+	  || !(i.base_reg->reg_type & Acc)
+	  || !(i.base_reg->reg_type & RegXX)
+	  || i.index_reg
+	  || (i.types[0] & Disp))
+	ok = 0;
+    }
+  else if (flag_code == CODE_64BIT)
+    {
+      unsigned RegXX = (i.prefix[ADDR_PREFIX] == 0 ? Reg64 : Reg32);
+
+      if ((i.base_reg
+	   && ((i.base_reg->reg_type & RegXX) == 0)
+	   && (i.base_reg->reg_type != BaseIndex
+	       || i.index_reg))
+	  || (i.index_reg
+	      && ((i.index_reg->reg_type & (RegXX | BaseIndex))
+		  != (RegXX | BaseIndex))))
+	ok = 0;
+    }
+  else
+    {
+      if ((flag_code == CODE_16BIT) ^ (i.prefix[ADDR_PREFIX] != 0))
+	{
+	  /* 16bit checks.  */
+	  if ((i.base_reg
+	       && ((i.base_reg->reg_type & (Reg16 | BaseIndex | RegRex))
+		   != (Reg16 | BaseIndex)))
+	      || (i.index_reg
+		  && (((i.index_reg->reg_type & (Reg16 | BaseIndex))
+		       != (Reg16 | BaseIndex))
+		      || !(i.base_reg
+			   && i.base_reg->reg_num < 6
+			   && i.index_reg->reg_num >= 6
+			   && i.log2_scale_factor == 0))))
+	    ok = 0;
+	}
+      else
+	{
+	  /* 32bit checks.  */
+	  if ((i.base_reg
+	       && (i.base_reg->reg_type & (Reg32 | RegRex)) != Reg32)
+	      || (i.index_reg
+		  && ((i.index_reg->reg_type & (Reg32 | BaseIndex | RegRex))
+		      != (Reg32 | BaseIndex))))
+	    ok = 0;
+	}
+    }
+  if (!ok)
+    {
+#if INFER_ADDR_PREFIX
+      if (i.prefix[ADDR_PREFIX] == 0)
+	{
+	  i.prefix[ADDR_PREFIX] = ADDR_PREFIX_OPCODE;
+	  i.prefixes += 1;
+	  /* Change the size of any displacement too.  At most one of
+	     Disp16 or Disp32 is set.
+	     FIXME.  There doesn't seem to be any real need for separate
+	     Disp16 and Disp32 flags.  The same goes for Imm16 and Imm32.
+	     Removing them would probably clean up the code quite a lot.  */
+	  if (flag_code != CODE_64BIT
+	      && (i.types[this_operand] & (Disp16 | Disp32)))
+	    i.types[this_operand] ^= (Disp16 | Disp32);
+	  fudged = 1;
+	  goto tryprefix;
+	}
+      if (fudged)
+	as_bad (_("`%s' is not a valid base/index expression"),
+		operand_string);
+      else
+#endif
+	as_bad (_("`%s' is not a valid %s bit base/index expression"),
+		operand_string,
+		flag_code_names[flag_code]);
+    }
+  return ok;
+}
+
+/* Parse OPERAND_STRING into the i386_insn structure I.  Returns non-zero
+   on error.  */
+
+static int
+i386_operand (char *operand_string)
+{
+  const reg_entry *r;
+  char *end_op;
+  char *op_string = operand_string;
+
+  if (is_space_char (*op_string))
+    ++op_string;
+
+  /* We check for an absolute prefix (differentiating,
+     for example, 'jmp pc_relative_label' from 'jmp *absolute_label'.  */
+  if (*op_string == ABSOLUTE_PREFIX)
+    {
+      ++op_string;
+      if (is_space_char (*op_string))
+	++op_string;
+      i.types[this_operand] |= JumpAbsolute;
+    }
+
+  /* Check if operand is a register.  */
+  if ((r = parse_register (op_string, &end_op)) != NULL)
+    {
+      /* Check for a segment override by searching for ':' after a
+	 segment register.  */
+      op_string = end_op;
+      if (is_space_char (*op_string))
+	++op_string;
+      if (*op_string == ':' && (r->reg_type & (SReg2 | SReg3)))
+	{
+	  switch (r->reg_num)
+	    {
+	    case 0:
+	      i.seg[i.mem_operands] = &es;
+	      break;
+	    case 1:
+	      i.seg[i.mem_operands] = &cs;
+	      break;
+	    case 2:
+	      i.seg[i.mem_operands] = &ss;
+	      break;
+	    case 3:
+	      i.seg[i.mem_operands] = &ds;
+	      break;
+	    case 4:
+	      i.seg[i.mem_operands] = &fs;
+	      break;
+	    case 5:
+	      i.seg[i.mem_operands] = &gs;
+	      break;
+	    }
+
+	  /* Skip the ':' and whitespace.  */
+	  ++op_string;
+	  if (is_space_char (*op_string))
+	    ++op_string;
+
+	  if (!is_digit_char (*op_string)
+	      && !is_identifier_char (*op_string)
+	      && *op_string != '('
+	      && *op_string != ABSOLUTE_PREFIX)
+	    {
+	      as_bad (_("bad memory operand `%s'"), op_string);
+	      return 0;
+	    }
+	  /* Handle case of %es:*foo.  */
+	  if (*op_string == ABSOLUTE_PREFIX)
+	    {
+	      ++op_string;
+	      if (is_space_char (*op_string))
+		++op_string;
+	      i.types[this_operand] |= JumpAbsolute;
+	    }
+	  goto do_memory_reference;
+	}
+      if (*op_string)
+	{
+	  as_bad (_("junk `%s' after register"), op_string);
+	  return 0;
+	}
+      i.types[this_operand] |= r->reg_type & ~BaseIndex;
+      i.op[this_operand].regs = r;
+      i.reg_operands++;
+    }
+  else if (*op_string == REGISTER_PREFIX)
+    {
+      as_bad (_("bad register name `%s'"), op_string);
+      return 0;
+    }
+  else if (*op_string == IMMEDIATE_PREFIX)
+    {
+      ++op_string;
+      if (i.types[this_operand] & JumpAbsolute)
+	{
+	  as_bad (_("immediate operand illegal with absolute jump"));
+	  return 0;
+	}
+      if (!i386_immediate (op_string))
+	return 0;
+    }
+  else if (is_digit_char (*op_string)
+	   || is_identifier_char (*op_string)
+	   || *op_string == '(')
+    {
+      /* This is a memory reference of some sort.  */
+      char *base_string;
+
+      /* Start and end of displacement string expression (if found).  */
+      char *displacement_string_start;
+      char *displacement_string_end;
+
+    do_memory_reference:
+      if ((i.mem_operands == 1
+	   && (current_templates->start->opcode_modifier & IsString) == 0)
+	  || i.mem_operands == 2)
+	{
+	  as_bad (_("too many memory references for `%s'"),
+		  current_templates->start->name);
+	  return 0;
+	}
+
+      /* Check for base index form.  We detect the base index form by
+	 looking for an ')' at the end of the operand, searching
+	 for the '(' matching it, and finding a REGISTER_PREFIX or ','
+	 after the '('.  */
+      base_string = op_string + strlen (op_string);
+
+      --base_string;
+      if (is_space_char (*base_string))
+	--base_string;
+
+      /* If we only have a displacement, set-up for it to be parsed later.  */
+      displacement_string_start = op_string;
+      displacement_string_end = base_string + 1;
+
+      if (*base_string == ')')
+	{
+	  char *temp_string;
+	  unsigned int parens_balanced = 1;
+	  /* We've already checked that the number of left & right ()'s are
+	     equal, so this loop will not be infinite.  */
+	  do
+	    {
+	      base_string--;
+	      if (*base_string == ')')
+		parens_balanced++;
+	      if (*base_string == '(')
+		parens_balanced--;
+	    }
+	  while (parens_balanced);
+
+	  temp_string = base_string;
+
+	  /* Skip past '(' and whitespace.  */
+	  ++base_string;
+	  if (is_space_char (*base_string))
+	    ++base_string;
+
+	  if (*base_string == ','
+	      || ((i.base_reg = parse_register (base_string, &end_op))
+		  != NULL))
+	    {
+	      displacement_string_end = temp_string;
+
+	      i.types[this_operand] |= BaseIndex;
+
+	      if (i.base_reg)
+		{
+		  base_string = end_op;
+		  if (is_space_char (*base_string))
+		    ++base_string;
+		}
+
+	      /* There may be an index reg or scale factor here.  */
+	      if (*base_string == ',')
+		{
+		  ++base_string;
+		  if (is_space_char (*base_string))
+		    ++base_string;
+
+		  if ((i.index_reg = parse_register (base_string, &end_op))
+		      != NULL)
+		    {
+		      base_string = end_op;
+		      if (is_space_char (*base_string))
+			++base_string;
+		      if (*base_string == ',')
+			{
+			  ++base_string;
+			  if (is_space_char (*base_string))
+			    ++base_string;
+			}
+		      else if (*base_string != ')')
+			{
+			  as_bad (_("expecting `,' or `)' "
+				    "after index register in `%s'"),
+				  operand_string);
+			  return 0;
+			}
+		    }
+		  else if (*base_string == REGISTER_PREFIX)
+		    {
+		      as_bad (_("bad register name `%s'"), base_string);
+		      return 0;
+		    }
+
+		  /* Check for scale factor.  */
+		  if (*base_string != ')')
+		    {
+		      char *end_scale = i386_scale (base_string);
+
+		      if (!end_scale)
+			return 0;
+
+		      base_string = end_scale;
+		      if (is_space_char (*base_string))
+			++base_string;
+		      if (*base_string != ')')
+			{
+			  as_bad (_("expecting `)' "
+				    "after scale factor in `%s'"),
+				  operand_string);
+			  return 0;
+			}
+		    }
+		  else if (!i.index_reg)
+		    {
+		      as_bad (_("expecting index register or scale factor "
+				"after `,'; got '%c'"),
+			      *base_string);
+		      return 0;
+		    }
+		}
+	      else if (*base_string != ')')
+		{
+		  as_bad (_("expecting `,' or `)' "
+			    "after base register in `%s'"),
+			  operand_string);
+		  return 0;
+		}
+	    }
+	  else if (*base_string == REGISTER_PREFIX)
+	    {
+	      as_bad (_("bad register name `%s'"), base_string);
+	      return 0;
+	    }
+	}
+
+      /* If there's an expression beginning the operand, parse it,
+	 assuming displacement_string_start and
+	 displacement_string_end are meaningful.  */
+      if (displacement_string_start != displacement_string_end)
+	{
+	  if (!i386_displacement (displacement_string_start,
+				  displacement_string_end))
+	    return 0;
+	}
+
+      /* Special case for (%dx) while doing input/output op.  */
+      if (i.base_reg
+	  && i.base_reg->reg_type == (Reg16 | InOutPortReg)
+	  && i.index_reg == 0
+	  && i.log2_scale_factor == 0
+	  && i.seg[i.mem_operands] == 0
+	  && (i.types[this_operand] & Disp) == 0)
+	{
+	  i.types[this_operand] = InOutPortReg;
+	  return 1;
+	}
+
+      if (i386_index_check (operand_string) == 0)
+	return 0;
+      i.mem_operands++;
+    }
+  else
+    {
+      /* It's not a memory operand; argh!  */
+      as_bad (_("invalid char %s beginning operand %d `%s'"),
+	      output_invalid (*op_string),
+	      this_operand + 1,
+	      op_string);
+      return 0;
+    }
+  return 1;			/* Normal return.  */
+}
+
+/* md_estimate_size_before_relax()
+
+   Called just before relax() for rs_machine_dependent frags.  The x86
+   assembler uses these frags to handle variable size jump
+   instructions.
+
+   Any symbol that is now undefined will not become defined.
+   Return the correct fr_subtype in the frag.
+   Return the initial "guess for variable size of frag" to caller.
+   The guess is actually the growth beyond the fixed part.  Whatever
+   we do to grow the fixed or variable part contributes to our
+   returned value.  */
+
+int
+md_estimate_size_before_relax (fragP, segment)
+     fragS *fragP;
+     segT segment;
+{
+  /* We've already got fragP->fr_subtype right;  all we have to do is
+     check for un-relaxable symbols.  On an ELF system, we can't relax
+     an externally visible symbol, because it may be overridden by a
+     shared library.  */
+  if (S_GET_SEGMENT (fragP->fr_symbol) != segment
+#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
+      || (IS_ELF
+	  && (S_IS_EXTERNAL (fragP->fr_symbol)
+	      || S_IS_WEAK (fragP->fr_symbol)))
+#endif
+      )
+    {
+      /* Symbol is undefined in this segment, or we need to keep a
+	 reloc so that weak symbols can be overridden.  */
+      int size = (fragP->fr_subtype & CODE16) ? 2 : 4;
+      enum bfd_reloc_code_real reloc_type;
+      unsigned char *opcode;
+      int old_fr_fix;
+
+      if (fragP->fr_var != NO_RELOC)
+	reloc_type = fragP->fr_var;
+      else if (size == 2)
+	reloc_type = BFD_RELOC_16_PCREL;
+      else
+	reloc_type = BFD_RELOC_32_PCREL;
+
+      old_fr_fix = fragP->fr_fix;
+      opcode = (unsigned char *) fragP->fr_opcode;
+
+      switch (TYPE_FROM_RELAX_STATE (fragP->fr_subtype))
+	{
+	case UNCOND_JUMP:
+	  /* Make jmp (0xeb) a (d)word displacement jump.  */
+	  opcode[0] = 0xe9;
+	  fragP->fr_fix += size;
+	  fix_new (fragP, old_fr_fix, size,
+		   fragP->fr_symbol,
+		   fragP->fr_offset, 1,
+		   reloc_type);
+	  break;
+
+	case COND_JUMP86:
+	  if (size == 2
+	      && (!no_cond_jump_promotion || fragP->fr_var != NO_RELOC))
+	    {
+	      /* Negate the condition, and branch past an
+		 unconditional jump.  */
+	      opcode[0] ^= 1;
+	      opcode[1] = 3;
+	      /* Insert an unconditional jump.  */
+	      opcode[2] = 0xe9;
+	      /* We added two extra opcode bytes, and have a two byte
+		 offset.  */
+	      fragP->fr_fix += 2 + 2;
+	      fix_new (fragP, old_fr_fix + 2, 2,
+		       fragP->fr_symbol,
+		       fragP->fr_offset, 1,
+		       reloc_type);
+	      break;
+	    }
+	  /* Fall through.  */
+
+	case COND_JUMP:
+	  if (no_cond_jump_promotion && fragP->fr_var == NO_RELOC)
+	    {
+	      fixS *fixP;
+
+	      fragP->fr_fix += 1;
+	      fixP = fix_new (fragP, old_fr_fix, 1,
+			      fragP->fr_symbol,
+			      fragP->fr_offset, 1,
+			      BFD_RELOC_8_PCREL);
+	      fixP->fx_signed = 1;
+	      break;
+	    }
+
+	  /* This changes the byte-displacement jump 0x7N
+	     to the (d)word-displacement jump 0x0f,0x8N.  */
+	  opcode[1] = opcode[0] + 0x10;
+	  opcode[0] = TWO_BYTE_OPCODE_ESCAPE;
+	  /* We've added an opcode byte.  */
+	  fragP->fr_fix += 1 + size;
+	  fix_new (fragP, old_fr_fix + 1, size,
+		   fragP->fr_symbol,
+		   fragP->fr_offset, 1,
+		   reloc_type);
+	  break;
+
+	default:
+	  BAD_CASE (fragP->fr_subtype);
+	  break;
+	}
+      frag_wane (fragP);
+      return fragP->fr_fix - old_fr_fix;
+    }
+
+  /* Guess size depending on current relax state.  Initially the relax
+     state will correspond to a short jump and we return 1, because
+     the variable part of the frag (the branch offset) is one byte
+     long.  However, we can relax a section more than once and in that
+     case we must either set fr_subtype back to the unrelaxed state,
+     or return the value for the appropriate branch.  */
+  return md_relax_table[fragP->fr_subtype].rlx_length;
+}
+
+/* Called after relax() is finished.
+
+   In:	Address of frag.
+	fr_type == rs_machine_dependent.
+	fr_subtype is what the address relaxed to.
+
+   Out:	Any fixSs and constants are set up.
+	Caller will turn frag into a ".space 0".  */
+
+void
+md_convert_frag (abfd, sec, fragP)
+     bfd *abfd ATTRIBUTE_UNUSED;
+     segT sec ATTRIBUTE_UNUSED;
+     fragS *fragP;
+{
+  unsigned char *opcode;
+  unsigned char *where_to_put_displacement = NULL;
+  offsetT target_address;
+  offsetT opcode_address;
+  unsigned int extension = 0;
+  offsetT displacement_from_opcode_start;
+
+  opcode = (unsigned char *) fragP->fr_opcode;
+
+  /* Address we want to reach in file space.  */
+  target_address = S_GET_VALUE (fragP->fr_symbol) + fragP->fr_offset;
+
+  /* Address opcode resides at in file space.  */
+  opcode_address = fragP->fr_address + fragP->fr_fix;
+
+  /* Displacement from opcode start to fill into instruction.  */
+  displacement_from_opcode_start = target_address - opcode_address;
+
+  if ((fragP->fr_subtype & BIG) == 0)
+    {
+      /* Don't have to change opcode.  */
+      extension = 1;		/* 1 opcode + 1 displacement  */
+      where_to_put_displacement = &opcode[1];
+    }
+  else
+    {
+      if (no_cond_jump_promotion
+	  && TYPE_FROM_RELAX_STATE (fragP->fr_subtype) != UNCOND_JUMP)
+	as_warn_where (fragP->fr_file, fragP->fr_line,
+		       _("long jump required"));
+
+      switch (fragP->fr_subtype)
+	{
+	case ENCODE_RELAX_STATE (UNCOND_JUMP, BIG):
+	  extension = 4;		/* 1 opcode + 4 displacement  */
+	  opcode[0] = 0xe9;
+	  where_to_put_displacement = &opcode[1];
+	  break;
+
+	case ENCODE_RELAX_STATE (UNCOND_JUMP, BIG16):
+	  extension = 2;		/* 1 opcode + 2 displacement  */
+	  opcode[0] = 0xe9;
+	  where_to_put_displacement = &opcode[1];
+	  break;
+
+	case ENCODE_RELAX_STATE (COND_JUMP, BIG):
+	case ENCODE_RELAX_STATE (COND_JUMP86, BIG):
+	  extension = 5;		/* 2 opcode + 4 displacement  */
+	  opcode[1] = opcode[0] + 0x10;
+	  opcode[0] = TWO_BYTE_OPCODE_ESCAPE;
+	  where_to_put_displacement = &opcode[2];
+	  break;
+
+	case ENCODE_RELAX_STATE (COND_JUMP, BIG16):
+	  extension = 3;		/* 2 opcode + 2 displacement  */
+	  opcode[1] = opcode[0] + 0x10;
+	  opcode[0] = TWO_BYTE_OPCODE_ESCAPE;
+	  where_to_put_displacement = &opcode[2];
+	  break;
+
+	case ENCODE_RELAX_STATE (COND_JUMP86, BIG16):
+	  extension = 4;
+	  opcode[0] ^= 1;
+	  opcode[1] = 3;
+	  opcode[2] = 0xe9;
+	  where_to_put_displacement = &opcode[3];
+	  break;
+
+	default:
+	  BAD_CASE (fragP->fr_subtype);
+	  break;
+	}
+    }
+
+  /* If size if less then four we are sure that the operand fits,
+     but if it's 4, then it could be that the displacement is larger
+     then -/+ 2GB.  */
+  if (DISP_SIZE_FROM_RELAX_STATE (fragP->fr_subtype) == 4
+      && object_64bit
+      && ((addressT) (displacement_from_opcode_start - extension
+		      + ((addressT) 1 << 31))
+	  > (((addressT) 2 << 31) - 1)))
+    {
+      as_bad_where (fragP->fr_file, fragP->fr_line,
+		    _("jump target out of range"));
+      /* Make us emit 0.  */
+      displacement_from_opcode_start = extension;
+    }
+  /* Now put displacement after opcode.  */
+  md_number_to_chars ((char *) where_to_put_displacement,
+		      (valueT) (displacement_from_opcode_start - extension),
+		      DISP_SIZE_FROM_RELAX_STATE (fragP->fr_subtype));
+  fragP->fr_fix += extension;
+}
+
+/* Size of byte displacement jmp.  */
+int md_short_jump_size = 2;
+
+/* Size of dword displacement jmp.  */
+int md_long_jump_size = 5;
+
+void
+md_create_short_jump (ptr, from_addr, to_addr, frag, to_symbol)
+     char *ptr;
+     addressT from_addr, to_addr;
+     fragS *frag ATTRIBUTE_UNUSED;
+     symbolS *to_symbol ATTRIBUTE_UNUSED;
+{
+  offsetT offset;
+
+  offset = to_addr - (from_addr + 2);
+  /* Opcode for byte-disp jump.  */
+  md_number_to_chars (ptr, (valueT) 0xeb, 1);
+  md_number_to_chars (ptr + 1, (valueT) offset, 1);
+}
+
+void
+md_create_long_jump (ptr, from_addr, to_addr, frag, to_symbol)
+     char *ptr;
+     addressT from_addr, to_addr;
+     fragS *frag ATTRIBUTE_UNUSED;
+     symbolS *to_symbol ATTRIBUTE_UNUSED;
+{
+  offsetT offset;
+
+  offset = to_addr - (from_addr + 5);
+  md_number_to_chars (ptr, (valueT) 0xe9, 1);
+  md_number_to_chars (ptr + 1, (valueT) offset, 4);
+}
+
+/* Apply a fixup (fixS) to segment data, once it has been determined
+   by our caller that we have all the info we need to fix it up.
+
+   On the 386, immediates, displacements, and data pointers are all in
+   the same (little-endian) format, so we don't need to care about which
+   we are handling.  */
+
+void
+md_apply_fix (fixP, valP, seg)
+     /* The fix we're to put in.  */
+     fixS *fixP;
+     /* Pointer to the value of the bits.  */
+     valueT *valP;
+     /* Segment fix is from.  */
+     segT seg ATTRIBUTE_UNUSED;
+{
+  char *p = fixP->fx_where + fixP->fx_frag->fr_literal;
+  valueT value = *valP;
+
+#if !defined (TE_Mach)
+  if (fixP->fx_pcrel)
+    {
+      switch (fixP->fx_r_type)
+	{
+	default:
+	  break;
+
+	case BFD_RELOC_64:
+	  fixP->fx_r_type = BFD_RELOC_64_PCREL;
+	  break;
+	case BFD_RELOC_32:
+	case BFD_RELOC_X86_64_32S:
+	  fixP->fx_r_type = BFD_RELOC_32_PCREL;
+	  break;
+	case BFD_RELOC_16:
+	  fixP->fx_r_type = BFD_RELOC_16_PCREL;
+	  break;
+	case BFD_RELOC_8:
+	  fixP->fx_r_type = BFD_RELOC_8_PCREL;
+	  break;
+	}
+    }
+
+  if (fixP->fx_addsy != NULL
+      && (fixP->fx_r_type == BFD_RELOC_32_PCREL
+	  || fixP->fx_r_type == BFD_RELOC_64_PCREL
+	  || fixP->fx_r_type == BFD_RELOC_16_PCREL
+	  || fixP->fx_r_type == BFD_RELOC_8_PCREL)
+      && !use_rela_relocations)
+    {
+      /* This is a hack.  There should be a better way to handle this.
+	 This covers for the fact that bfd_install_relocation will
+	 subtract the current location (for partial_inplace, PC relative
+	 relocations); see more below.  */
+#ifndef OBJ_AOUT
+      if (IS_ELF
+#ifdef TE_PE
+	  || OUTPUT_FLAVOR == bfd_target_coff_flavour
+#endif
+	  )
+	value += fixP->fx_where + fixP->fx_frag->fr_address;
+#endif
+#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
+      if (IS_ELF)
+	{
+	  segT sym_seg = S_GET_SEGMENT (fixP->fx_addsy);
+
+	  if ((sym_seg == seg
+	       || (symbol_section_p (fixP->fx_addsy)
+		   && sym_seg != absolute_section))
+	      && !generic_force_reloc (fixP))
+	    {
+	      /* Yes, we add the values in twice.  This is because
+		 bfd_install_relocation subtracts them out again.  I think
+		 bfd_install_relocation is broken, but I don't dare change
+		 it.  FIXME.  */
+	      value += fixP->fx_where + fixP->fx_frag->fr_address;
+	    }
+	}
+#endif
+#if defined (OBJ_COFF) && defined (TE_PE)
+      /* For some reason, the PE format does not store a
+	 section address offset for a PC relative symbol.  */
+      if (S_GET_SEGMENT (fixP->fx_addsy) != seg
+	  || S_IS_WEAK (fixP->fx_addsy))
+	value += md_pcrel_from (fixP);
+#endif
+    }
+
+  /* Fix a few things - the dynamic linker expects certain values here,
+     and we must not disappoint it.  */
+#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
+  if (IS_ELF && fixP->fx_addsy)
+    switch (fixP->fx_r_type)
+      {
+      case BFD_RELOC_386_PLT32:
+      case BFD_RELOC_X86_64_PLT32:
+	/* Make the jump instruction point to the address of the operand.  At
+	   runtime we merely add the offset to the actual PLT entry.  */
+	value = -4;
+	break;
+
+      case BFD_RELOC_386_TLS_GD:
+      case BFD_RELOC_386_TLS_LDM:
+      case BFD_RELOC_386_TLS_IE_32:
+      case BFD_RELOC_386_TLS_IE:
+      case BFD_RELOC_386_TLS_GOTIE:
+      case BFD_RELOC_386_TLS_GOTDESC:
+      case BFD_RELOC_X86_64_TLSGD:
+      case BFD_RELOC_X86_64_TLSLD:
+      case BFD_RELOC_X86_64_GOTTPOFF:
+      case BFD_RELOC_X86_64_GOTPC32_TLSDESC:
+	value = 0; /* Fully resolved at runtime.  No addend.  */
+	/* Fallthrough */
+      case BFD_RELOC_386_TLS_LE:
+      case BFD_RELOC_386_TLS_LDO_32:
+      case BFD_RELOC_386_TLS_LE_32:
+      case BFD_RELOC_X86_64_DTPOFF32:
+      case BFD_RELOC_X86_64_DTPOFF64:
+      case BFD_RELOC_X86_64_TPOFF32:
+      case BFD_RELOC_X86_64_TPOFF64:
+	S_SET_THREAD_LOCAL (fixP->fx_addsy);
+	break;
+
+      case BFD_RELOC_386_TLS_DESC_CALL:
+      case BFD_RELOC_X86_64_TLSDESC_CALL:
+	value = 0; /* Fully resolved at runtime.  No addend.  */
+	S_SET_THREAD_LOCAL (fixP->fx_addsy);
+	fixP->fx_done = 0;
+	return;
+
+      case BFD_RELOC_386_GOT32:
+      case BFD_RELOC_X86_64_GOT32:
+	value = 0; /* Fully resolved at runtime.  No addend.  */
+	break;
+
+      case BFD_RELOC_VTABLE_INHERIT:
+      case BFD_RELOC_VTABLE_ENTRY:
+	fixP->fx_done = 0;
+	return;
+
+      default:
+	break;
+      }
+#endif /* defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)  */
+  *valP = value;
+#endif /* !defined (TE_Mach)  */
+
+  /* Are we finished with this relocation now?  */
+  if (fixP->fx_addsy == NULL)
+    fixP->fx_done = 1;
+  else if (use_rela_relocations)
+    {
+      fixP->fx_no_overflow = 1;
+      /* Remember value for tc_gen_reloc.  */
+      fixP->fx_addnumber = value;
+      value = 0;
+    }
+
+  md_number_to_chars (p, value, fixP->fx_size);
+}
+
+#define MAX_LITTLENUMS 6
+
+/* Turn the string pointed to by litP into a floating point constant
+   of type TYPE, and emit the appropriate bytes.  The number of
+   LITTLENUMS emitted is stored in *SIZEP.  An error message is
+   returned, or NULL on OK.  */
+
+char *
+md_atof (type, litP, sizeP)
+     int type;
+     char *litP;
+     int *sizeP;
+{
+  int prec;
+  LITTLENUM_TYPE words[MAX_LITTLENUMS];
+  LITTLENUM_TYPE *wordP;
+  char *t;
+
+  switch (type)
+    {
+    case 'f':
+    case 'F':
+      prec = 2;
+      break;
+
+    case 'd':
+    case 'D':
+      prec = 4;
+      break;
+
+    case 'x':
+    case 'X':
+      prec = 5;
+      break;
+
+    default:
+      *sizeP = 0;
+      return _("Bad call to md_atof ()");
+    }
+  t = atof_ieee (input_line_pointer, type, words);
+  if (t)
+    input_line_pointer = t;
+
+  *sizeP = prec * sizeof (LITTLENUM_TYPE);
+  /* This loops outputs the LITTLENUMs in REVERSE order; in accord with
+     the bigendian 386.  */
+  for (wordP = words + prec - 1; prec--;)
+    {
+      md_number_to_chars (litP, (valueT) (*wordP--), sizeof (LITTLENUM_TYPE));
+      litP += sizeof (LITTLENUM_TYPE);
+    }
+  return 0;
+}
+
+static char output_invalid_buf[sizeof (unsigned char) * 2 + 6];
+
+static char *
+output_invalid (int c)
+{
+  if (ISPRINT (c))
+    snprintf (output_invalid_buf, sizeof (output_invalid_buf),
+	      "'%c'", c);
+  else
+    snprintf (output_invalid_buf, sizeof (output_invalid_buf),
+	      "(0x%x)", (unsigned char) c);
+  return output_invalid_buf;
+}
+
+/* REG_STRING starts *before* REGISTER_PREFIX.  */
+
+static const reg_entry *
+parse_real_register (char *reg_string, char **end_op)
+{
+  char *s = reg_string;
+  char *p;
+  char reg_name_given[MAX_REG_NAME_SIZE + 1];
+  const reg_entry *r;
+
+  /* Skip possible REGISTER_PREFIX and possible whitespace.  */
+  if (*s == REGISTER_PREFIX)
+    ++s;
+
+  if (is_space_char (*s))
+    ++s;
+
+  p = reg_name_given;
+  while ((*p++ = register_chars[(unsigned char) *s]) != '\0')
+    {
+      if (p >= reg_name_given + MAX_REG_NAME_SIZE)
+	return (const reg_entry *) NULL;
+      s++;
+    }
+
+  /* For naked regs, make sure that we are not dealing with an identifier.
+     This prevents confusing an identifier like `eax_var' with register
+     `eax'.  */
+  if (allow_naked_reg && identifier_chars[(unsigned char) *s])
+    return (const reg_entry *) NULL;
+
+  *end_op = s;
+
+  r = (const reg_entry *) hash_find (reg_hash, reg_name_given);
+
+  /* Handle floating point regs, allowing spaces in the (i) part.  */
+  if (r == i386_regtab /* %st is first entry of table  */)
+    {
+      if (is_space_char (*s))
+	++s;
+      if (*s == '(')
+	{
+	  ++s;
+	  if (is_space_char (*s))
+	    ++s;
+	  if (*s >= '0' && *s <= '7')
+	    {
+	      int fpr = *s - '0';
+	      ++s;
+	      if (is_space_char (*s))
+		++s;
+	      if (*s == ')')
+		{
+		  *end_op = s + 1;
+		  r = hash_find (reg_hash, "st(0)");
+		  know (r);
+		  return r + fpr;
+		}
+	    }
+	  /* We have "%st(" then garbage.  */
+	  return (const reg_entry *) NULL;
+	}
+    }
+
+  if (r != NULL
+      && ((r->reg_flags & (RegRex64 | RegRex)) | (r->reg_type & Reg64)) != 0
+      && (r->reg_type != Control || !(cpu_arch_flags & CpuSledgehammer))
+      && flag_code != CODE_64BIT)
+    return (const reg_entry *) NULL;
+
+  return r;
+}
+
+/* REG_STRING starts *before* REGISTER_PREFIX.  */
+
+static const reg_entry *
+parse_register (char *reg_string, char **end_op)
+{
+  const reg_entry *r;
+
+  if (*reg_string == REGISTER_PREFIX || allow_naked_reg)
+    r = parse_real_register (reg_string, end_op);
+  else
+    r = NULL;
+  if (!r)
+    {
+      char *save = input_line_pointer;
+      char c;
+      symbolS *symbolP;
+
+      input_line_pointer = reg_string;
+      c = get_symbol_end ();
+      symbolP = symbol_find (reg_string);
+      if (symbolP && S_GET_SEGMENT (symbolP) == reg_section)
+	{
+	  const expressionS *e = symbol_get_value_expression (symbolP);
+
+	  know (e->X_op == O_register);
+	  know (e->X_add_number >= 0
+		&& (valueT) e->X_add_number < i386_regtab_size);
+	  r = i386_regtab + e->X_add_number;
+	  *end_op = input_line_pointer;
+	}
+      *input_line_pointer = c;
+      input_line_pointer = save;
+    }
+  return r;
+}
+
+int
+i386_parse_name (char *name, expressionS *e, char *nextcharP)
+{
+  const reg_entry *r;
+  char *end = input_line_pointer;
+
+  *end = *nextcharP;
+  r = parse_register (name, &input_line_pointer);
+  if (r && end <= input_line_pointer)
+    {
+      *nextcharP = *input_line_pointer;
+      *input_line_pointer = 0;
+      e->X_op = O_register;
+      e->X_add_number = r - i386_regtab;
+      return 1;
+    }
+  input_line_pointer = end;
+  *end = 0;
+  return 0;
+}
+
+void
+md_operand (expressionS *e)
+{
+  if (*input_line_pointer == REGISTER_PREFIX)
+    {
+      char *end;
+      const reg_entry *r = parse_real_register (input_line_pointer, &end);
+
+      if (r)
+	{
+	  e->X_op = O_register;
+	  e->X_add_number = r - i386_regtab;
+	  input_line_pointer = end;
+	}
+    }
+}
+
+
+#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
+const char *md_shortopts = "kVQ:sqn";
+#else
+const char *md_shortopts = "qn";
+#endif
+
+#define OPTION_32 (OPTION_MD_BASE + 0)
+#define OPTION_64 (OPTION_MD_BASE + 1)
+#define OPTION_DIVIDE (OPTION_MD_BASE + 2)
+#define OPTION_MARCH (OPTION_MD_BASE + 3)
+#define OPTION_MTUNE (OPTION_MD_BASE + 4)
+#define OPTION_NACL_ALIGN (OPTION_MD_BASE + 5)
+#define OPTION_NACL_LIBRARY_MODE (OPTION_MD_BASE + 6)
+
+
+struct option md_longopts[] =
+{
+  {"32", no_argument, NULL, OPTION_32},
+#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) || defined(TE_PEP)
+  {"64", no_argument, NULL, OPTION_64},
+#endif
+  {"divide", no_argument, NULL, OPTION_DIVIDE},
+  {"march", required_argument, NULL, OPTION_MARCH},
+  {"mtune", required_argument, NULL, OPTION_MTUNE},
+  {"nacl-align", required_argument, NULL, OPTION_NACL_ALIGN},
+  {"nacl-library-mode", no_argument, NULL, OPTION_NACL_LIBRARY_MODE},
+  {NULL, no_argument, NULL, 0}
+};
+size_t md_longopts_size = sizeof (md_longopts);
+
+int
+md_parse_option (int c, char *arg)
+{
+  unsigned int i;
+
+  switch (c)
+    {
+    case 'n':
+      optimize_align_code = 0;
+      break;
+
+    case 'q':
+      quiet_warnings = 1;
+      break;
+
+#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
+      /* -Qy, -Qn: SVR4 arguments controlling whether a .comment section
+	 should be emitted or not.  FIXME: Not implemented.  */
+    case 'Q':
+      break;
+
+      /* -V: SVR4 argument to print version ID.  */
+    case 'V':
+      print_version_id ();
+      break;
+
+      /* -k: Ignore for FreeBSD compatibility.  */
+    case 'k':
+      break;
+
+    case 's':
+      /* -s: On i386 Solaris, this tells the native assembler to use
+	 .stab instead of .stab.excl.  We always use .stab anyhow.  */
+      break;
+#endif
+#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) || defined(TE_PEP)
+    case OPTION_64:
+      {
+	const char **list, **l;
+
+	list = bfd_target_list ();
+	for (l = list; *l != NULL; l++)
+	  if (CONST_STRNEQ (*l, "elf64-x86-64")
+	      || strcmp (*l, "coff-x86-64") == 0
+	      || strcmp (*l, "pe-x86-64") == 0
+	      || strcmp (*l, "pei-x86-64") == 0)
+	    {
+	      default_arch = "x86_64";
+	      break;
+	    }
+	if (*l == NULL)
+	  as_fatal (_("No compiled in support for x86_64"));
+	free (list);
+      }
+      break;
+#endif
+
+    case OPTION_32:
+      default_arch = "i386";
+      break;
+
+    case OPTION_DIVIDE:
+#ifdef SVR4_COMMENT_CHARS
+      {
+	char *n, *t;
+	const char *s;
+
+	n = (char *) xmalloc (strlen (i386_comment_chars) + 1);
+	t = n;
+	for (s = i386_comment_chars; *s != '\0'; s++)
+	  if (*s != '/')
+	    *t++ = *s;
+	*t = '\0';
+	i386_comment_chars = n;
+      }
+#endif
+      break;
+
+    case OPTION_MARCH:
+      if (*arg == '.')
+	as_fatal (_("Invalid -march= option: `%s'"), arg);
+      for (i = 0; i < ARRAY_SIZE (cpu_arch); i++)
+	{
+	  if (strcmp (arg, cpu_arch [i].name) == 0)
+	    {
+	      cpu_arch_isa = cpu_arch[i].type;
+	      cpu_arch_isa_flags = cpu_arch[i].flags;
+	      if (!cpu_arch_tune_set)
+		{
+		  cpu_arch_tune = cpu_arch_isa;
+		  cpu_arch_tune_flags = cpu_arch_isa_flags;
+		}
+	      break;
+	    }
+	}
+      if (i >= ARRAY_SIZE (cpu_arch))
+	as_fatal (_("Invalid -march= option: `%s'"), arg);
+      break;
+
+    case OPTION_MTUNE:
+      if (*arg == '.')
+	as_fatal (_("Invalid -mtune= option: `%s'"), arg);
+      for (i = 0; i < ARRAY_SIZE (cpu_arch); i++)
+	{
+	  if (strcmp (arg, cpu_arch [i].name) == 0)
+	    {
+	      cpu_arch_tune_set = 1;
+	      cpu_arch_tune = cpu_arch [i].type;
+	      cpu_arch_tune_flags = cpu_arch[i].flags;
+	      break;
+	    }
+	}
+      if (i >= ARRAY_SIZE (cpu_arch))
+	as_fatal (_("Invalid -mtune= option: `%s'"), arg);
+      break;
+
+    case OPTION_NACL_ALIGN:
+      {
+        nacl_alignment = atoi (optarg);
+        if (nacl_alignment < 0)
+          as_fatal (_("--nacl-align needs a non-negative argument"));
+        break;
+      }
+
+    case OPTION_NACL_LIBRARY_MODE:
+      {
+        nacl_library_mode = 1;
+        break;
+      }
+
+    default:
+      return 0;
+    }
+  return 1;
+}
+
+void
+md_show_usage (stream)
+     FILE *stream;
+{
+#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
+  fprintf (stream, _("\
+  -Q                      ignored\n\
+  -V                      print assembler version number\n\
+  -k                      ignored\n"));
+#endif
+  fprintf (stream, _("\
+  -n                      Do not optimize code alignment\n\
+  -q                      quieten some warnings\n"));
+#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
+  fprintf (stream, _("\
+  -s                      ignored\n"));
+#endif
+#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) || defined(TE_PEP)
+  fprintf (stream, _("\
+  --32/--64               generate 32bit/64bit code\n"));
+#endif
+#ifdef SVR4_COMMENT_CHARS
+  fprintf (stream, _("\
+  --divide                do not treat `/' as a comment character\n"));
+#else
+  fprintf (stream, _("\
+  --divide                ignored\n"));
+#endif
+  fprintf (stream, _("\
+  -march=CPU/-mtune=CPU   generate code/optimize for CPU, where CPU is one of:\n\
+                           i386, i486, pentium, pentiumpro, pentium4, nocona,\n\
+                           core, core2, k6, athlon, k8, generic32, generic64\n"));
+
+}
+
+#if ((defined (OBJ_MAYBE_COFF) && defined (OBJ_MAYBE_AOUT)) \
+     || defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) || defined (TE_PEP))
+
+/* Pick the target format to use.  */
+
+const char *
+i386_target_format (void)
+{
+  if (!strcmp (default_arch, "x86_64"))
+    {
+      set_code_flag (CODE_64BIT);
+      if (cpu_arch_isa_flags == 0)
+	cpu_arch_isa_flags = Cpu186|Cpu286|Cpu386|Cpu486
+			     |Cpu586|Cpu686|CpuP4|CpuMMX|CpuMMX2
+			     |CpuSSE|CpuSSE2;
+      if (cpu_arch_tune_flags == 0)
+	cpu_arch_tune_flags = Cpu186|Cpu286|Cpu386|Cpu486
+			      |Cpu586|Cpu686|CpuP4|CpuMMX|CpuMMX2
+			      |CpuSSE|CpuSSE2;
+    }
+  else if (!strcmp (default_arch, "i386"))
+    {
+      set_code_flag (CODE_32BIT);
+      if (cpu_arch_isa_flags == 0)
+	cpu_arch_isa_flags = Cpu186|Cpu286|Cpu386;
+      if (cpu_arch_tune_flags == 0)
+	cpu_arch_tune_flags = Cpu186|Cpu286|Cpu386;
+    }
+  else
+    as_fatal (_("Unknown architecture"));
+  switch (OUTPUT_FLAVOR)
+    {
+#ifdef TE_PEP
+    case bfd_target_coff_flavour:
+      return flag_code == CODE_64BIT ? COFF_TARGET_FORMAT : "coff-i386";
+      break;
+#endif
+#ifdef OBJ_MAYBE_AOUT
+    case bfd_target_aout_flavour:
+      return AOUT_TARGET_FORMAT;
+#endif
+#ifdef OBJ_MAYBE_COFF
+    case bfd_target_coff_flavour:
+      return "coff-i386";
+#endif
+#if defined (OBJ_MAYBE_ELF) || defined (OBJ_ELF)
+    case bfd_target_elf_flavour:
+      {
+	if (flag_code == CODE_64BIT)
+	  {
+	    object_64bit = 1;
+	    use_rela_relocations = 1;
+	  }
+	return flag_code == CODE_64BIT ? ELF_TARGET_FORMAT64 : ELF_TARGET_FORMAT;
+      }
+#endif
+    default:
+      abort ();
+      return NULL;
+    }
+}
+
+#endif /* OBJ_MAYBE_ more than one  */
+
+#if (defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF))
+void
+i386_elf_emit_arch_note (void)
+{
+  if (IS_ELF && cpu_arch_name != NULL)
+    {
+      char *p;
+      asection *seg = now_seg;
+      subsegT subseg = now_subseg;
+      Elf_Internal_Note i_note;
+      Elf_External_Note e_note;
+      asection *note_secp;
+      int len;
+
+      /* Create the .note section.  */
+      note_secp = subseg_new (".note", 0);
+      bfd_set_section_flags (stdoutput,
+			     note_secp,
+			     SEC_HAS_CONTENTS | SEC_READONLY);
+
+      /* Process the arch string.  */
+      len = strlen (cpu_arch_name);
+
+      i_note.namesz = len + 1;
+      i_note.descsz = 0;
+      i_note.type = NT_ARCH;
+      p = frag_more (sizeof (e_note.namesz));
+      md_number_to_chars (p, (valueT) i_note.namesz, sizeof (e_note.namesz));
+      p = frag_more (sizeof (e_note.descsz));
+      md_number_to_chars (p, (valueT) i_note.descsz, sizeof (e_note.descsz));
+      p = frag_more (sizeof (e_note.type));
+      md_number_to_chars (p, (valueT) i_note.type, sizeof (e_note.type));
+      p = frag_more (len + 1);
+      strcpy (p, cpu_arch_name);
+
+      frag_align (2, 0, 0);
+
+      subseg_set (seg, subseg);
+    }
+}
+#endif
+
+symbolS *
+md_undefined_symbol (name)
+     char *name;
+{
+  if (name[0] == GLOBAL_OFFSET_TABLE_NAME[0]
+      && name[1] == GLOBAL_OFFSET_TABLE_NAME[1]
+      && name[2] == GLOBAL_OFFSET_TABLE_NAME[2]
+      && strcmp (name, GLOBAL_OFFSET_TABLE_NAME) == 0)
+    {
+      if (!GOT_symbol)
+	{
+	  if (symbol_find (name))
+	    as_bad (_("GOT already in symbol table"));
+	  GOT_symbol = symbol_new (name, undefined_section,
+				   (valueT) 0, &zero_address_frag);
+	};
+      return GOT_symbol;
+    }
+  return 0;
+}
+
+/* Round up a section size to the appropriate boundary.  */
+
+valueT
+md_section_align (segment, size)
+     segT segment ATTRIBUTE_UNUSED;
+     valueT size;
+{
+#if (defined (OBJ_AOUT) || defined (OBJ_MAYBE_AOUT))
+  if (OUTPUT_FLAVOR == bfd_target_aout_flavour)
+    {
+      /* For a.out, force the section size to be aligned.  If we don't do
+	 this, BFD will align it for us, but it will not write out the
+	 final bytes of the section.  This may be a bug in BFD, but it is
+	 easier to fix it here since that is how the other a.out targets
+	 work.  */
+      int align;
+
+      align = bfd_get_section_alignment (stdoutput, segment);
+      size = ((size + (1 << align) - 1) & ((valueT) -1 << align));
+    }
+#endif
+
+  return size;
+}
+
+/* On the i386, PC-relative offsets are relative to the start of the
+   next instruction.  That is, the address of the offset, plus its
+   size, since the offset is always the last part of the insn.  */
+
+long
+md_pcrel_from (fixS *fixP)
+{
+  return fixP->fx_size + fixP->fx_where + fixP->fx_frag->fr_address;
+}
+
+#ifndef I386COFF
+
+static void
+s_bss (int ignore ATTRIBUTE_UNUSED)
+{
+  int temp;
+
+#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
+  if (IS_ELF)
+    obj_elf_section_change_hook ();
+#endif
+  temp = get_absolute_expression ();
+  subseg_set (bss_section, (subsegT) temp);
+  demand_empty_rest_of_line ();
+}
+
+#endif
+
+void
+i386_validate_fix (fixS *fixp)
+{
+  if (fixp->fx_subsy && fixp->fx_subsy == GOT_symbol)
+    {
+      if (fixp->fx_r_type == BFD_RELOC_32_PCREL)
+	{
+	  if (!object_64bit)
+	    abort ();
+	  fixp->fx_r_type = BFD_RELOC_X86_64_GOTPCREL;
+	}
+      else
+	{
+	  if (!object_64bit)
+	    fixp->fx_r_type = BFD_RELOC_386_GOTOFF;
+	  else
+	    fixp->fx_r_type = BFD_RELOC_X86_64_GOTOFF64;
+	}
+      fixp->fx_subsy = 0;
+    }
+}
+
+arelent *
+tc_gen_reloc (section, fixp)
+     asection *section ATTRIBUTE_UNUSED;
+     fixS *fixp;
+{
+  arelent *rel;
+  bfd_reloc_code_real_type code;
+
+  switch (fixp->fx_r_type)
+    {
+    case BFD_RELOC_X86_64_PLT32:
+    case BFD_RELOC_X86_64_GOT32:
+    case BFD_RELOC_X86_64_GOTPCREL:
+    case BFD_RELOC_386_PLT32:
+    case BFD_RELOC_386_GOT32:
+    case BFD_RELOC_386_GOTOFF:
+    case BFD_RELOC_386_GOTPC:
+    case BFD_RELOC_386_TLS_GD:
+    case BFD_RELOC_386_TLS_LDM:
+    case BFD_RELOC_386_TLS_LDO_32:
+    case BFD_RELOC_386_TLS_IE_32:
+    case BFD_RELOC_386_TLS_IE:
+    case BFD_RELOC_386_TLS_GOTIE:
+    case BFD_RELOC_386_TLS_LE_32:
+    case BFD_RELOC_386_TLS_LE:
+    case BFD_RELOC_386_TLS_GOTDESC:
+    case BFD_RELOC_386_TLS_DESC_CALL:
+    case BFD_RELOC_X86_64_TLSGD:
+    case BFD_RELOC_X86_64_TLSLD:
+    case BFD_RELOC_X86_64_DTPOFF32:
+    case BFD_RELOC_X86_64_DTPOFF64:
+    case BFD_RELOC_X86_64_GOTTPOFF:
+    case BFD_RELOC_X86_64_TPOFF32:
+    case BFD_RELOC_X86_64_TPOFF64:
+    case BFD_RELOC_X86_64_GOTOFF64:
+    case BFD_RELOC_X86_64_GOTPC32:
+    case BFD_RELOC_X86_64_GOT64:
+    case BFD_RELOC_X86_64_GOTPCREL64:
+    case BFD_RELOC_X86_64_GOTPC64:
+    case BFD_RELOC_X86_64_GOTPLT64:
+    case BFD_RELOC_X86_64_PLTOFF64:
+    case BFD_RELOC_X86_64_GOTPC32_TLSDESC:
+    case BFD_RELOC_X86_64_TLSDESC_CALL:
+    case BFD_RELOC_RVA:
+    case BFD_RELOC_VTABLE_ENTRY:
+    case BFD_RELOC_VTABLE_INHERIT:
+#ifdef TE_PE
+    case BFD_RELOC_32_SECREL:
+#endif
+      code = fixp->fx_r_type;
+      break;
+    case BFD_RELOC_X86_64_32S:
+      if (!fixp->fx_pcrel)
+	{
+	  /* Don't turn BFD_RELOC_X86_64_32S into BFD_RELOC_32.  */
+	  code = fixp->fx_r_type;
+	  break;
+	}
+    default:
+      if (fixp->fx_pcrel)
+	{
+	  switch (fixp->fx_size)
+	    {
+	    default:
+	      as_bad_where (fixp->fx_file, fixp->fx_line,
+			    _("can not do %d byte pc-relative relocation"),
+			    fixp->fx_size);
+	      code = BFD_RELOC_32_PCREL;
+	      break;
+	    case 1: code = BFD_RELOC_8_PCREL;  break;
+	    case 2: code = BFD_RELOC_16_PCREL; break;
+	    case 4: code = BFD_RELOC_32_PCREL; break;
+#ifdef BFD64
+	    case 8: code = BFD_RELOC_64_PCREL; break;
+#endif
+	    }
+	}
+      else
+	{
+	  switch (fixp->fx_size)
+	    {
+	    default:
+	      as_bad_where (fixp->fx_file, fixp->fx_line,
+			    _("can not do %d byte relocation"),
+			    fixp->fx_size);
+	      code = BFD_RELOC_32;
+	      break;
+	    case 1: code = BFD_RELOC_8;  break;
+	    case 2: code = BFD_RELOC_16; break;
+	    case 4: code = BFD_RELOC_32; break;
+#ifdef BFD64
+	    case 8: code = BFD_RELOC_64; break;
+#endif
+	    }
+	}
+      break;
+    }
+
+  if ((code == BFD_RELOC_32
+       || code == BFD_RELOC_32_PCREL
+       || code == BFD_RELOC_X86_64_32S)
+      && GOT_symbol
+      && fixp->fx_addsy == GOT_symbol)
+    {
+      if (!object_64bit)
+	code = BFD_RELOC_386_GOTPC;
+      else
+	code = BFD_RELOC_X86_64_GOTPC32;
+    }
+  if ((code == BFD_RELOC_64 || code == BFD_RELOC_64_PCREL)
+      && GOT_symbol
+      && fixp->fx_addsy == GOT_symbol)
+    {
+      code = BFD_RELOC_X86_64_GOTPC64;
+    }
+
+  rel = (arelent *) xmalloc (sizeof (arelent));
+  rel->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
+  *rel->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
+
+  rel->address = fixp->fx_frag->fr_address + fixp->fx_where;
+
+  if (!use_rela_relocations)
+    {
+      /* HACK: Since i386 ELF uses Rel instead of Rela, encode the
+	 vtable entry to be used in the relocation's section offset.  */
+      if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
+	rel->address = fixp->fx_offset;
+
+      rel->addend = 0;
+    }
+  /* Use the rela in 64bit mode.  */
+  else
+    {
+      if (!fixp->fx_pcrel)
+	rel->addend = fixp->fx_offset;
+      else
+	switch (code)
+	  {
+	  case BFD_RELOC_X86_64_PLT32:
+	  case BFD_RELOC_X86_64_GOT32:
+	  case BFD_RELOC_X86_64_GOTPCREL:
+	  case BFD_RELOC_X86_64_TLSGD:
+	  case BFD_RELOC_X86_64_TLSLD:
+	  case BFD_RELOC_X86_64_GOTTPOFF:
+	  case BFD_RELOC_X86_64_GOTPC32_TLSDESC:
+	  case BFD_RELOC_X86_64_TLSDESC_CALL:
+	    rel->addend = fixp->fx_offset - fixp->fx_size;
+	    break;
+	  default:
+	    rel->addend = (section->vma
+			   - fixp->fx_size
+			   + fixp->fx_addnumber
+			   + md_pcrel_from (fixp));
+	    break;
+	  }
+    }
+
+  rel->howto = bfd_reloc_type_lookup (stdoutput, code);
+  if (rel->howto == NULL)
+    {
+      as_bad_where (fixp->fx_file, fixp->fx_line,
+		    _("cannot represent relocation type %s"),
+		    bfd_get_reloc_code_name (code));
+      /* Set howto to a garbage value so that we can keep going.  */
+      rel->howto = bfd_reloc_type_lookup (stdoutput, BFD_RELOC_32);
+      assert (rel->howto != NULL);
+    }
+
+  return rel;
+}
+
+
+/* Parse operands using Intel syntax. This implements a recursive descent
+   parser based on the BNF grammar published in Appendix B of the MASM 6.1
+   Programmer's Guide.
+
+   FIXME: We do not recognize the full operand grammar defined in the MASM
+	  documentation.  In particular, all the structure/union and
+	  high-level macro operands are missing.
+
+   Uppercase words are terminals, lower case words are non-terminals.
+   Objects surrounded by double brackets '[[' ']]' are optional. Vertical
+   bars '|' denote choices. Most grammar productions are implemented in
+   functions called 'intel_<production>'.
+
+   Initial production is 'expr'.
+
+    addOp		+ | -
+
+    alpha		[a-zA-Z]
+
+    binOp		& | AND | \| | OR | ^ | XOR
+
+    byteRegister	AL | AH | BL | BH | CL | CH | DL | DH
+
+    constant		digits [[ radixOverride ]]
+
+    dataType		BYTE | WORD | DWORD | FWORD | QWORD | TBYTE | OWORD | XMMWORD
+
+    digits		decdigit
+			| digits decdigit
+			| digits hexdigit
+
+    decdigit		[0-9]
+
+    e04			e04 addOp e05
+			| e05
+
+    e05			e05 binOp e06
+			| e06
+
+    e06			e06 mulOp e09
+			| e09
+
+    e09			OFFSET e10
+			| SHORT e10
+			| + e10
+			| - e10
+			| ~ e10
+			| NOT e10
+			| e09 PTR e10
+			| e09 : e10
+			| e10
+
+    e10			e10 [ expr ]
+			| e11
+
+    e11			( expr )
+			| [ expr ]
+			| constant
+			| dataType
+			| id
+			| $
+			| register
+
+ => expr		expr cmpOp e04
+			| e04
+
+    gpRegister		AX | EAX | BX | EBX | CX | ECX | DX | EDX
+			| BP | EBP | SP | ESP | DI | EDI | SI | ESI
+
+    hexdigit		a | b | c | d | e | f
+			| A | B | C | D | E | F
+
+    id			alpha
+			| id alpha
+			| id decdigit
+
+    mulOp		* | / | % | MOD | << | SHL | >> | SHR
+
+    quote		" | '
+
+    register		specialRegister
+			| gpRegister
+			| byteRegister
+
+    segmentRegister	CS | DS | ES | FS | GS | SS
+
+    specialRegister	CR0 | CR2 | CR3 | CR4
+			| DR0 | DR1 | DR2 | DR3 | DR6 | DR7
+			| TR3 | TR4 | TR5 | TR6 | TR7
+
+    We simplify the grammar in obvious places (e.g., register parsing is
+    done by calling parse_register) and eliminate immediate left recursion
+    to implement a recursive-descent parser.
+
+    expr	e04 expr'
+
+    expr'	cmpOp e04 expr'
+		| Empty
+
+    e04		e05 e04'
+
+    e04'	addOp e05 e04'
+		| Empty
+
+    e05		e06 e05'
+
+    e05'	binOp e06 e05'
+		| Empty
+
+    e06		e09 e06'
+
+    e06'	mulOp e09 e06'
+		| Empty
+
+    e09		OFFSET e10 e09'
+		| SHORT e10'
+		| + e10'
+		| - e10'
+		| ~ e10'
+		| NOT e10'
+		| e10 e09'
+
+    e09'	PTR e10 e09'
+		| : e10 e09'
+		| Empty
+
+    e10		e11 e10'
+
+    e10'	[ expr ] e10'
+		| Empty
+
+    e11		( expr )
+		| [ expr ]
+		| BYTE
+		| WORD
+		| DWORD
+		| FWORD
+		| QWORD
+		| TBYTE
+		| OWORD
+		| XMMWORD
+		| .
+		| $
+		| register
+		| id
+		| constant  */
+
+/* Parsing structure for the intel syntax parser. Used to implement the
+   semantic actions for the operand grammar.  */
+struct intel_parser_s
+  {
+    char *op_string;		/* The string being parsed.  */
+    int got_a_float;		/* Whether the operand is a float.  */
+    int op_modifier;		/* Operand modifier.  */
+    int is_mem;			/* 1 if operand is memory reference.  */
+    int in_offset;		/* >=1 if parsing operand of offset.  */
+    int in_bracket;		/* >=1 if parsing operand in brackets.  */
+    const reg_entry *reg;	/* Last register reference found.  */
+    char *disp;			/* Displacement string being built.  */
+    char *next_operand;		/* Resume point when splitting operands.  */
+  };
+
+static struct intel_parser_s intel_parser;
+
+/* Token structure for parsing intel syntax.  */
+struct intel_token
+  {
+    int code;			/* Token code.  */
+    const reg_entry *reg;	/* Register entry for register tokens.  */
+    char *str;			/* String representation.  */
+  };
+
+static struct intel_token cur_token, prev_token;
+
+/* Token codes for the intel parser. Since T_SHORT is already used
+   by COFF, undefine it first to prevent a warning.  */
+#define T_NIL		-1
+#define T_CONST		1
+#define T_REG		2
+#define T_BYTE		3
+#define T_WORD		4
+#define T_DWORD		5
+#define T_FWORD		6
+#define T_QWORD		7
+#define T_TBYTE		8
+#define T_XMMWORD	9
+#undef  T_SHORT
+#define T_SHORT		10
+#define T_OFFSET	11
+#define T_PTR		12
+#define T_ID		13
+#define T_SHL		14
+#define T_SHR		15
+
+/* Prototypes for intel parser functions.  */
+static int intel_match_token (int);
+static void intel_putback_token	(void);
+static void intel_get_token (void);
+static int intel_expr (void);
+static int intel_e04 (void);
+static int intel_e05 (void);
+static int intel_e06 (void);
+static int intel_e09 (void);
+static int intel_e10 (void);
+static int intel_e11 (void);
+
+static int
+i386_intel_operand (char *operand_string, int got_a_float)
+{
+  int ret;
+  char *p;
+
+  p = intel_parser.op_string = xstrdup (operand_string);
+  intel_parser.disp = (char *) xmalloc (strlen (operand_string) + 1);
+
+  for (;;)
+    {
+      /* Initialize token holders.  */
+      cur_token.code = prev_token.code = T_NIL;
+      cur_token.reg = prev_token.reg = NULL;
+      cur_token.str = prev_token.str = NULL;
+
+      /* Initialize parser structure.  */
+      intel_parser.got_a_float = got_a_float;
+      intel_parser.op_modifier = 0;
+      intel_parser.is_mem = 0;
+      intel_parser.in_offset = 0;
+      intel_parser.in_bracket = 0;
+      intel_parser.reg = NULL;
+      intel_parser.disp[0] = '\0';
+      intel_parser.next_operand = NULL;
+
+      /* Read the first token and start the parser.  */
+      intel_get_token ();
+      ret = intel_expr ();
+
+      if (!ret)
+	break;
+
+      if (cur_token.code != T_NIL)
+	{
+	  as_bad (_("invalid operand for '%s' ('%s' unexpected)"),
+		  current_templates->start->name, cur_token.str);
+	  ret = 0;
+	}
+      /* If we found a memory reference, hand it over to i386_displacement
+	 to fill in the rest of the operand fields.  */
+      else if (intel_parser.is_mem)
+	{
+	  if ((i.mem_operands == 1
+	       && (current_templates->start->opcode_modifier & IsString) == 0)
+	      || i.mem_operands == 2)
+	    {
+	      as_bad (_("too many memory references for '%s'"),
+		      current_templates->start->name);
+	      ret = 0;
+	    }
+	  else
+	    {
+	      char *s = intel_parser.disp;
+	      i.mem_operands++;
+
+	      if (!quiet_warnings && intel_parser.is_mem < 0)
+		/* See the comments in intel_bracket_expr.  */
+		as_warn (_("Treating `%s' as memory reference"), operand_string);
+
+	      /* Add the displacement expression.  */
+	      if (*s != '\0')
+		ret = i386_displacement (s, s + strlen (s));
+	      if (ret)
+		{
+		  /* Swap base and index in 16-bit memory operands like
+		     [si+bx]. Since i386_index_check is also used in AT&T
+		     mode we have to do that here.  */
+		  if (i.base_reg
+		      && i.index_reg
+		      && (i.base_reg->reg_type & Reg16)
+		      && (i.index_reg->reg_type & Reg16)
+		      && i.base_reg->reg_num >= 6
+		      && i.index_reg->reg_num < 6)
+		    {
+		      const reg_entry *base = i.index_reg;
+
+		      i.index_reg = i.base_reg;
+		      i.base_reg = base;
+		    }
+		  ret = i386_index_check (operand_string);
+		}
+	    }
+	}
+
+      /* Constant and OFFSET expressions are handled by i386_immediate.  */
+      else if ((intel_parser.op_modifier & (1 << T_OFFSET))
+	       || intel_parser.reg == NULL)
+	ret = i386_immediate (intel_parser.disp);
+
+      if (intel_parser.next_operand && this_operand >= MAX_OPERANDS - 1)
+	ret = 0;
+      if (!ret || !intel_parser.next_operand)
+	break;
+      intel_parser.op_string = intel_parser.next_operand;
+      this_operand = i.operands++;
+    }
+
+  free (p);
+  free (intel_parser.disp);
+
+  return ret;
+}
+
+#define NUM_ADDRESS_REGS (!!i.base_reg + !!i.index_reg)
+
+/* expr	e04 expr'
+
+   expr'  cmpOp e04 expr'
+	| Empty  */
+static int
+intel_expr (void)
+{
+  /* XXX Implement the comparison operators.  */
+  return intel_e04 ();
+}
+
+/* e04	e05 e04'
+
+   e04'	addOp e05 e04'
+	| Empty  */
+static int
+intel_e04 (void)
+{
+  int nregs = -1;
+
+  for (;;)
+    {
+      if (!intel_e05())
+	return 0;
+
+      if (nregs >= 0 && NUM_ADDRESS_REGS > nregs)
+	i.base_reg = i386_regtab + REGNAM_AL; /* al is invalid as base */
+
+      if (cur_token.code == '+')
+	nregs = -1;
+      else if (cur_token.code == '-')
+	nregs = NUM_ADDRESS_REGS;
+      else
+	return 1;
+
+      strcat (intel_parser.disp, cur_token.str);
+      intel_match_token (cur_token.code);
+    }
+}
+
+/* e05	e06 e05'
+
+   e05'	binOp e06 e05'
+	| Empty  */
+static int
+intel_e05 (void)
+{
+  int nregs = ~NUM_ADDRESS_REGS;
+
+  for (;;)
+    {
+      if (!intel_e06())
+	return 0;
+
+      if (cur_token.code == '&'
+	  || cur_token.code == '|'
+	  || cur_token.code == '^')
+	{
+	  char str[2];
+
+	  str[0] = cur_token.code;
+	  str[1] = 0;
+	  strcat (intel_parser.disp, str);
+	}
+      else
+	break;
+
+      intel_match_token (cur_token.code);
+
+      if (nregs < 0)
+	nregs = ~nregs;
+    }
+  if (nregs >= 0 && NUM_ADDRESS_REGS > nregs)
+    i.base_reg = i386_regtab + REGNAM_AL + 1; /* cl is invalid as base */
+  return 1;
+}
+
+/* e06	e09 e06'
+
+   e06'	mulOp e09 e06'
+	| Empty  */
+static int
+intel_e06 (void)
+{
+  int nregs = ~NUM_ADDRESS_REGS;
+
+  for (;;)
+    {
+      if (!intel_e09())
+	return 0;
+
+      if (cur_token.code == '*'
+	  || cur_token.code == '/'
+	  || cur_token.code == '%')
+	{
+	  char str[2];
+
+	  str[0] = cur_token.code;
+	  str[1] = 0;
+	  strcat (intel_parser.disp, str);
+	}
+      else if (cur_token.code == T_SHL)
+	strcat (intel_parser.disp, "<<");
+      else if (cur_token.code == T_SHR)
+	strcat (intel_parser.disp, ">>");
+      else
+	break;
+
+      intel_match_token (cur_token.code);
+
+      if (nregs < 0)
+	nregs = ~nregs;
+    }
+  if (nregs >= 0 && NUM_ADDRESS_REGS > nregs)
+    i.base_reg = i386_regtab + REGNAM_AL + 2; /* dl is invalid as base */
+  return 1;
+}
+
+/* e09	OFFSET e09
+	| SHORT e09
+	| + e09
+	| - e09
+	| ~ e09
+	| NOT e09
+	| e10 e09'
+
+   e09'	PTR e10 e09'
+	| : e10 e09'
+	| Empty */
+static int
+intel_e09 (void)
+{
+  int nregs = ~NUM_ADDRESS_REGS;
+  int in_offset = 0;
+
+  for (;;)
+    {
+      /* Don't consume constants here.  */
+      if (cur_token.code == '+' || cur_token.code == '-')
+	{
+	  /* Need to look one token ahead - if the next token
+	     is a constant, the current token is its sign.  */
+	  int next_code;
+
+	  intel_match_token (cur_token.code);
+	  next_code = cur_token.code;
+	  intel_putback_token ();
+	  if (next_code == T_CONST)
+	    break;
+	}
+
+      /* e09  OFFSET e09  */
+      if (cur_token.code == T_OFFSET)
+	{
+	  if (!in_offset++)
+	    ++intel_parser.in_offset;
+	}
+
+      /* e09  SHORT e09  */
+      else if (cur_token.code == T_SHORT)
+	intel_parser.op_modifier |= 1 << T_SHORT;
+
+      /* e09  + e09  */
+      else if (cur_token.code == '+')
+	strcat (intel_parser.disp, "+");
+
+      /* e09  - e09
+	      | ~ e09
+	      | NOT e09  */
+      else if (cur_token.code == '-' || cur_token.code == '~')
+	{
+	  char str[2];
+
+	  if (nregs < 0)
+	    nregs = ~nregs;
+	  str[0] = cur_token.code;
+	  str[1] = 0;
+	  strcat (intel_parser.disp, str);
+	}
+
+      /* e09  e10 e09'  */
+      else
+	break;
+
+      intel_match_token (cur_token.code);
+    }
+
+  for (;;)
+    {
+      if (!intel_e10 ())
+	return 0;
+
+      /* e09'  PTR e10 e09' */
+      if (cur_token.code == T_PTR)
+	{
+	  char suffix;
+
+	  if (prev_token.code == T_BYTE)
+	    suffix = BYTE_MNEM_SUFFIX;
+
+	  else if (prev_token.code == T_WORD)
+	    {
+	      if (current_templates->start->name[0] == 'l'
+		  && current_templates->start->name[2] == 's'
+		  && current_templates->start->name[3] == 0)
+		suffix = BYTE_MNEM_SUFFIX; /* so it will cause an error */
+	      else if (intel_parser.got_a_float == 2)	/* "fi..." */
+		suffix = SHORT_MNEM_SUFFIX;
+	      else
+		suffix = WORD_MNEM_SUFFIX;
+	    }
+
+	  else if (prev_token.code == T_DWORD)
+	    {
+	      if (current_templates->start->name[0] == 'l'
+		  && current_templates->start->name[2] == 's'
+		  && current_templates->start->name[3] == 0)
+		suffix = WORD_MNEM_SUFFIX;
+	      else if (flag_code == CODE_16BIT
+		       && (current_templates->start->opcode_modifier
+			   & (Jump | JumpDword)))
+		suffix = LONG_DOUBLE_MNEM_SUFFIX;
+	      else if (intel_parser.got_a_float == 1)	/* "f..." */
+		suffix = SHORT_MNEM_SUFFIX;
+	      else
+		suffix = LONG_MNEM_SUFFIX;
+	    }
+
+	  else if (prev_token.code == T_FWORD)
+	    {
+	      if (current_templates->start->name[0] == 'l'
+		  && current_templates->start->name[2] == 's'
+		  && current_templates->start->name[3] == 0)
+		suffix = LONG_MNEM_SUFFIX;
+	      else if (!intel_parser.got_a_float)
+		{
+		  if (flag_code == CODE_16BIT)
+		    add_prefix (DATA_PREFIX_OPCODE);
+		  suffix = LONG_DOUBLE_MNEM_SUFFIX;
+		}
+	      else
+		suffix = BYTE_MNEM_SUFFIX; /* so it will cause an error */
+	    }
+
+	  else if (prev_token.code == T_QWORD)
+	    {
+	      if (intel_parser.got_a_float == 1)	/* "f..." */
+		suffix = LONG_MNEM_SUFFIX;
+	      else
+		suffix = QWORD_MNEM_SUFFIX;
+	    }
+
+	  else if (prev_token.code == T_TBYTE)
+	    {
+	      if (intel_parser.got_a_float == 1)
+		suffix = LONG_DOUBLE_MNEM_SUFFIX;
+	      else
+		suffix = BYTE_MNEM_SUFFIX; /* so it will cause an error */
+	    }
+
+	  else if (prev_token.code == T_XMMWORD)
+	    {
+	      /* XXX ignored for now, but accepted since gcc uses it */
+	      suffix = 0;
+	    }
+
+	  else
+	    {
+	      as_bad (_("Unknown operand modifier `%s'"), prev_token.str);
+	      return 0;
+	    }
+
+	  /* Operands for jump/call using 'ptr' notation denote absolute
+	     addresses.  */
+	  if (current_templates->start->opcode_modifier & (Jump | JumpDword))
+	    i.types[this_operand] |= JumpAbsolute;
+
+	  if (current_templates->start->base_opcode == 0x8d /* lea */)
+	    ;
+	  else if (!i.suffix)
+	    i.suffix = suffix;
+	  else if (i.suffix != suffix)
+	    {
+	      as_bad (_("Conflicting operand modifiers"));
+	      return 0;
+	    }
+
+	}
+
+      /* e09'  : e10 e09'  */
+      else if (cur_token.code == ':')
+	{
+	  if (prev_token.code != T_REG)
+	    {
+	      /* While {call,jmp} SSSS:OOOO is MASM syntax only when SSSS is a
+		 segment/group identifier (which we don't have), using comma
+		 as the operand separator there is even less consistent, since
+		 there all branches only have a single operand.  */
+	      if (this_operand != 0
+		  || intel_parser.in_offset
+		  || intel_parser.in_bracket
+		  || (!(current_templates->start->opcode_modifier
+			& (Jump|JumpDword|JumpInterSegment))
+		      && !(current_templates->start->operand_types[0]
+			   & JumpAbsolute)))
+		return intel_match_token (T_NIL);
+	      /* Remember the start of the 2nd operand and terminate 1st
+		 operand here.
+		 XXX This isn't right, yet (when SSSS:OOOO is right operand of
+		 another expression), but it gets at least the simplest case
+		 (a plain number or symbol on the left side) right.  */
+	      intel_parser.next_operand = intel_parser.op_string;
+	      *--intel_parser.op_string = '\0';
+	      return intel_match_token (':');
+	    }
+	}
+
+      /* e09'  Empty  */
+      else
+	break;
+
+      intel_match_token (cur_token.code);
+
+    }
+
+  if (in_offset)
+    {
+      --intel_parser.in_offset;
+      if (nregs < 0)
+	nregs = ~nregs;
+      if (NUM_ADDRESS_REGS > nregs)
+	{
+	  as_bad (_("Invalid operand to `OFFSET'"));
+	  return 0;
+	}
+      intel_parser.op_modifier |= 1 << T_OFFSET;
+    }
+
+  if (nregs >= 0 && NUM_ADDRESS_REGS > nregs)
+    i.base_reg = i386_regtab + REGNAM_AL + 3; /* bl is invalid as base */
+  return 1;
+}
+
+static int
+intel_bracket_expr (void)
+{
+  int was_offset = intel_parser.op_modifier & (1 << T_OFFSET);
+  const char *start = intel_parser.op_string;
+  int len;
+
+  if (i.op[this_operand].regs)
+    return intel_match_token (T_NIL);
+
+  intel_match_token ('[');
+
+  /* Mark as a memory operand only if it's not already known to be an
+     offset expression.  If it's an offset expression, we need to keep
+     the brace in.  */
+  if (!intel_parser.in_offset)
+    {
+      ++intel_parser.in_bracket;
+
+      /* Operands for jump/call inside brackets denote absolute addresses.  */
+      if (current_templates->start->opcode_modifier & (Jump | JumpDword))
+	i.types[this_operand] |= JumpAbsolute;
+
+      /* Unfortunately gas always diverged from MASM in a respect that can't
+	 be easily fixed without risking to break code sequences likely to be
+	 encountered (the testsuite even check for this): MASM doesn't consider
+	 an expression inside brackets unconditionally as a memory reference.
+	 When that is e.g. a constant, an offset expression, or the sum of the
+	 two, this is still taken as a constant load. gas, however, always
+	 treated these as memory references. As a compromise, we'll try to make
+	 offset expressions inside brackets work the MASM way (since that's
+	 less likely to be found in real world code), but make constants alone
+	 continue to work the traditional gas way. In either case, issue a
+	 warning.  */
+      intel_parser.op_modifier &= ~was_offset;
+    }
+  else
+    strcat (intel_parser.disp, "[");
+
+  /* Add a '+' to the displacement string if necessary.  */
+  if (*intel_parser.disp != '\0'
+      && *(intel_parser.disp + strlen (intel_parser.disp) - 1) != '+')
+    strcat (intel_parser.disp, "+");
+
+  if (intel_expr ()
+      && (len = intel_parser.op_string - start - 1,
+	  intel_match_token (']')))
+    {
+      /* Preserve brackets when the operand is an offset expression.  */
+      if (intel_parser.in_offset)
+	strcat (intel_parser.disp, "]");
+      else
+	{
+	  --intel_parser.in_bracket;
+	  if (i.base_reg || i.index_reg)
+	    intel_parser.is_mem = 1;
+	  if (!intel_parser.is_mem)
+	    {
+	      if (!(intel_parser.op_modifier & (1 << T_OFFSET)))
+		/* Defer the warning until all of the operand was parsed.  */
+		intel_parser.is_mem = -1;
+	      else if (!quiet_warnings)
+		as_warn (_("`[%.*s]' taken to mean just `%.*s'"),
+			 len, start, len, start);
+	    }
+	}
+      intel_parser.op_modifier |= was_offset;
+
+      return 1;
+    }
+  return 0;
+}
+
+/* e10	e11 e10'
+
+   e10'	[ expr ] e10'
+	| Empty  */
+static int
+intel_e10 (void)
+{
+  if (!intel_e11 ())
+    return 0;
+
+  while (cur_token.code == '[')
+    {
+      if (!intel_bracket_expr ())
+	return 0;
+    }
+
+  return 1;
+}
+
+/* e11	( expr )
+	| [ expr ]
+	| BYTE
+	| WORD
+	| DWORD
+	| FWORD
+	| QWORD
+	| TBYTE
+	| OWORD
+	| XMMWORD
+	| $
+	| .
+	| register
+	| id
+	| constant  */
+static int
+intel_e11 (void)
+{
+  switch (cur_token.code)
+    {
+    /* e11  ( expr ) */
+    case '(':
+      intel_match_token ('(');
+      strcat (intel_parser.disp, "(");
+
+      if (intel_expr () && intel_match_token (')'))
+	{
+	  strcat (intel_parser.disp, ")");
+	  return 1;
+	}
+      return 0;
+
+    /* e11  [ expr ] */
+    case '[':
+      return intel_bracket_expr ();
+
+    /* e11  $
+	    | .  */
+    case '.':
+      strcat (intel_parser.disp, cur_token.str);
+      intel_match_token (cur_token.code);
+
+      /* Mark as a memory operand only if it's not already known to be an
+	 offset expression.  */
+      if (!intel_parser.in_offset)
+	intel_parser.is_mem = 1;
+
+      return 1;
+
+    /* e11  register  */
+    case T_REG:
+      {
+	const reg_entry *reg = intel_parser.reg = cur_token.reg;
+
+	intel_match_token (T_REG);
+
+	/* Check for segment change.  */
+	if (cur_token.code == ':')
+	  {
+	    if (!(reg->reg_type & (SReg2 | SReg3)))
+	      {
+		as_bad (_("`%s' is not a valid segment register"),
+			reg->reg_name);
+		return 0;
+	      }
+	    else if (i.seg[i.mem_operands])
+	      as_warn (_("Extra segment override ignored"));
+	    else
+	      {
+		if (!intel_parser.in_offset)
+		  intel_parser.is_mem = 1;
+		switch (reg->reg_num)
+		  {
+		  case 0:
+		    i.seg[i.mem_operands] = &es;
+		    break;
+		  case 1:
+		    i.seg[i.mem_operands] = &cs;
+		    break;
+		  case 2:
+		    i.seg[i.mem_operands] = &ss;
+		    break;
+		  case 3:
+		    i.seg[i.mem_operands] = &ds;
+		    break;
+		  case 4:
+		    i.seg[i.mem_operands] = &fs;
+		    break;
+		  case 5:
+		    i.seg[i.mem_operands] = &gs;
+		    break;
+		  }
+	      }
+	  }
+
+	/* Not a segment register. Check for register scaling.  */
+	else if (cur_token.code == '*')
+	  {
+	    if (!intel_parser.in_bracket)
+	      {
+		as_bad (_("Register scaling only allowed in memory operands"));
+		return 0;
+	      }
+
+	    if (reg->reg_type & Reg16) /* Disallow things like [si*1]. */
+	      reg = i386_regtab + REGNAM_AX + 4; /* sp is invalid as index */
+	    else if (i.index_reg)
+	      reg = i386_regtab + REGNAM_EAX + 4; /* esp is invalid as index */
+
+	    /* What follows must be a valid scale.  */
+	    intel_match_token ('*');
+	    i.index_reg = reg;
+	    i.types[this_operand] |= BaseIndex;
+
+	    /* Set the scale after setting the register (otherwise,
+	       i386_scale will complain)  */
+	    if (cur_token.code == '+' || cur_token.code == '-')
+	      {
+		char *str, sign = cur_token.code;
+		intel_match_token (cur_token.code);
+		if (cur_token.code != T_CONST)
+		  {
+		    as_bad (_("Syntax error: Expecting a constant, got `%s'"),
+			    cur_token.str);
+		    return 0;
+		  }
+		str = (char *) xmalloc (strlen (cur_token.str) + 2);
+		strcpy (str + 1, cur_token.str);
+		*str = sign;
+		if (!i386_scale (str))
+		  return 0;
+		free (str);
+	      }
+	    else if (!i386_scale (cur_token.str))
+	      return 0;
+	    intel_match_token (cur_token.code);
+	  }
+
+	/* No scaling. If this is a memory operand, the register is either a
+	   base register (first occurrence) or an index register (second
+	   occurrence).  */
+	else if (intel_parser.in_bracket)
+	  {
+
+	    if (!i.base_reg)
+	      i.base_reg = reg;
+	    else if (!i.index_reg)
+	      i.index_reg = reg;
+	    else
+	      {
+		as_bad (_("Too many register references in memory operand"));
+		return 0;
+	      }
+
+	    i.types[this_operand] |= BaseIndex;
+	  }
+
+	/* It's neither base nor index.  */
+	else if (!intel_parser.in_offset && !intel_parser.is_mem)
+	  {
+	    i.types[this_operand] |= reg->reg_type & ~BaseIndex;
+	    i.op[this_operand].regs = reg;
+	    i.reg_operands++;
+	  }
+	else
+	  {
+	    as_bad (_("Invalid use of register"));
+	    return 0;
+	  }
+
+	/* Since registers are not part of the displacement string (except
+	   when we're parsing offset operands), we may need to remove any
+	   preceding '+' from the displacement string.  */
+	if (*intel_parser.disp != '\0'
+	    && !intel_parser.in_offset)
+	  {
+	    char *s = intel_parser.disp;
+	    s += strlen (s) - 1;
+	    if (*s == '+')
+	      *s = '\0';
+	  }
+
+	return 1;
+      }
+
+    /* e11  BYTE
+	    | WORD
+	    | DWORD
+	    | FWORD
+	    | QWORD
+	    | TBYTE
+	    | OWORD
+	    | XMMWORD  */
+    case T_BYTE:
+    case T_WORD:
+    case T_DWORD:
+    case T_FWORD:
+    case T_QWORD:
+    case T_TBYTE:
+    case T_XMMWORD:
+      intel_match_token (cur_token.code);
+
+      if (cur_token.code == T_PTR)
+	return 1;
+
+      /* It must have been an identifier.  */
+      intel_putback_token ();
+      cur_token.code = T_ID;
+      /* FALLTHRU */
+
+    /* e11  id
+	    | constant  */
+    case T_ID:
+      if (!intel_parser.in_offset && intel_parser.is_mem <= 0)
+	{
+	  symbolS *symbolP;
+
+	  /* The identifier represents a memory reference only if it's not
+	     preceded by an offset modifier and if it's not an equate.  */
+	  symbolP = symbol_find(cur_token.str);
+	  if (!symbolP || S_GET_SEGMENT(symbolP) != absolute_section)
+	    intel_parser.is_mem = 1;
+	}
+	/* FALLTHRU */
+
+    case T_CONST:
+    case '-':
+    case '+':
+      {
+	char *save_str, sign = 0;
+
+	/* Allow constants that start with `+' or `-'.  */
+	if (cur_token.code == '-' || cur_token.code == '+')
+	  {
+	    sign = cur_token.code;
+	    intel_match_token (cur_token.code);
+	    if (cur_token.code != T_CONST)
+	      {
+		as_bad (_("Syntax error: Expecting a constant, got `%s'"),
+			cur_token.str);
+		return 0;
+	      }
+	  }
+
+	save_str = (char *) xmalloc (strlen (cur_token.str) + 2);
+	strcpy (save_str + !!sign, cur_token.str);
+	if (sign)
+	  *save_str = sign;
+
+	/* Get the next token to check for register scaling.  */
+	intel_match_token (cur_token.code);
+
+	/* Check if this constant is a scaling factor for an
+	   index register.  */
+	if (cur_token.code == '*')
+	  {
+	    if (intel_match_token ('*') && cur_token.code == T_REG)
+	      {
+		const reg_entry *reg = cur_token.reg;
+
+		if (!intel_parser.in_bracket)
+		  {
+		    as_bad (_("Register scaling only allowed "
+			      "in memory operands"));
+		    return 0;
+		  }
+
+		 /* Disallow things like [1*si].
+		    sp and esp are invalid as index.  */
+		if (reg->reg_type & Reg16)
+		  reg = i386_regtab + REGNAM_AX + 4;
+		else if (i.index_reg)
+		  reg = i386_regtab + REGNAM_EAX + 4;
+
+		/* The constant is followed by `* reg', so it must be
+		   a valid scale.  */
+		i.index_reg = reg;
+		i.types[this_operand] |= BaseIndex;
+
+		/* Set the scale after setting the register (otherwise,
+		   i386_scale will complain)  */
+		if (!i386_scale (save_str))
+		  return 0;
+		intel_match_token (T_REG);
+
+		/* Since registers are not part of the displacement
+		   string, we may need to remove any preceding '+' from
+		   the displacement string.  */
+		if (*intel_parser.disp != '\0')
+		  {
+		    char *s = intel_parser.disp;
+		    s += strlen (s) - 1;
+		    if (*s == '+')
+		      *s = '\0';
+		  }
+
+		free (save_str);
+
+		return 1;
+	      }
+
+	    /* The constant was not used for register scaling. Since we have
+	       already consumed the token following `*' we now need to put it
+	       back in the stream.  */
+	    intel_putback_token ();
+	  }
+
+	/* Add the constant to the displacement string.  */
+	strcat (intel_parser.disp, save_str);
+	free (save_str);
+
+	return 1;
+      }
+    }
+
+  as_bad (_("Unrecognized token '%s'"), cur_token.str);
+  return 0;
+}
+
+/* Match the given token against cur_token. If they match, read the next
+   token from the operand string.  */
+static int
+intel_match_token (int code)
+{
+  if (cur_token.code == code)
+    {
+      intel_get_token ();
+      return 1;
+    }
+  else
+    {
+      as_bad (_("Unexpected token `%s'"), cur_token.str);
+      return 0;
+    }
+}
+
+/* Read a new token from intel_parser.op_string and store it in cur_token.  */
+static void
+intel_get_token (void)
+{
+  char *end_op;
+  const reg_entry *reg;
+  struct intel_token new_token;
+
+  new_token.code = T_NIL;
+  new_token.reg = NULL;
+  new_token.str = NULL;
+
+  /* Free the memory allocated to the previous token and move
+     cur_token to prev_token.  */
+  if (prev_token.str)
+    free (prev_token.str);
+
+  prev_token = cur_token;
+
+  /* Skip whitespace.  */
+  while (is_space_char (*intel_parser.op_string))
+    intel_parser.op_string++;
+
+  /* Return an empty token if we find nothing else on the line.  */
+  if (*intel_parser.op_string == '\0')
+    {
+      cur_token = new_token;
+      return;
+    }
+
+  /* The new token cannot be larger than the remainder of the operand
+     string.  */
+  new_token.str = (char *) xmalloc (strlen (intel_parser.op_string) + 1);
+  new_token.str[0] = '\0';
+
+  if (strchr ("0123456789", *intel_parser.op_string))
+    {
+      char *p = new_token.str;
+      char *q = intel_parser.op_string;
+      new_token.code = T_CONST;
+
+      /* Allow any kind of identifier char to encompass floating point and
+	 hexadecimal numbers.  */
+      while (is_identifier_char (*q))
+	*p++ = *q++;
+      *p = '\0';
+
+      /* Recognize special symbol names [0-9][bf].  */
+      if (strlen (intel_parser.op_string) == 2
+	  && (intel_parser.op_string[1] == 'b'
+	      || intel_parser.op_string[1] == 'f'))
+	new_token.code = T_ID;
+    }
+
+  else if ((reg = parse_register (intel_parser.op_string, &end_op)) != NULL)
+    {
+      size_t len = end_op - intel_parser.op_string;
+
+      new_token.code = T_REG;
+      new_token.reg = reg;
+
+      memcpy (new_token.str, intel_parser.op_string, len);
+      new_token.str[len] = '\0';
+    }
+
+  else if (is_identifier_char (*intel_parser.op_string))
+    {
+      char *p = new_token.str;
+      char *q = intel_parser.op_string;
+
+      /* A '.' or '$' followed by an identifier char is an identifier.
+	 Otherwise, it's operator '.' followed by an expression.  */
+      if ((*q == '.' || *q == '$') && !is_identifier_char (*(q + 1)))
+	{
+	  new_token.code = '.';
+	  new_token.str[0] = '.';
+	  new_token.str[1] = '\0';
+	}
+      else
+	{
+	  while (is_identifier_char (*q) || *q == '@')
+	    *p++ = *q++;
+	  *p = '\0';
+
+	  if (strcasecmp (new_token.str, "NOT") == 0)
+	    new_token.code = '~';
+
+	  else if (strcasecmp (new_token.str, "MOD") == 0)
+	    new_token.code = '%';
+
+	  else if (strcasecmp (new_token.str, "AND") == 0)
+	    new_token.code = '&';
+
+	  else if (strcasecmp (new_token.str, "OR") == 0)
+	    new_token.code = '|';
+
+	  else if (strcasecmp (new_token.str, "XOR") == 0)
+	    new_token.code = '^';
+
+	  else if (strcasecmp (new_token.str, "SHL") == 0)
+	    new_token.code = T_SHL;
+
+	  else if (strcasecmp (new_token.str, "SHR") == 0)
+	    new_token.code = T_SHR;
+
+	  else if (strcasecmp (new_token.str, "BYTE") == 0)
+	    new_token.code = T_BYTE;
+
+	  else if (strcasecmp (new_token.str, "WORD") == 0)
+	    new_token.code = T_WORD;
+
+	  else if (strcasecmp (new_token.str, "DWORD") == 0)
+	    new_token.code = T_DWORD;
+
+	  else if (strcasecmp (new_token.str, "FWORD") == 0)
+	    new_token.code = T_FWORD;
+
+	  else if (strcasecmp (new_token.str, "QWORD") == 0)
+	    new_token.code = T_QWORD;
+
+	  else if (strcasecmp (new_token.str, "TBYTE") == 0
+		   /* XXX remove (gcc still uses it) */
+		   || strcasecmp (new_token.str, "XWORD") == 0)
+	    new_token.code = T_TBYTE;
+
+	  else if (strcasecmp (new_token.str, "XMMWORD") == 0
+		   || strcasecmp (new_token.str, "OWORD") == 0)
+	    new_token.code = T_XMMWORD;
+
+	  else if (strcasecmp (new_token.str, "PTR") == 0)
+	    new_token.code = T_PTR;
+
+	  else if (strcasecmp (new_token.str, "SHORT") == 0)
+	    new_token.code = T_SHORT;
+
+	  else if (strcasecmp (new_token.str, "OFFSET") == 0)
+	    {
+	      new_token.code = T_OFFSET;
+
+	      /* ??? This is not mentioned in the MASM grammar but gcc
+		     makes use of it with -mintel-syntax.  OFFSET may be
+		     followed by FLAT:  */
+	      if (strncasecmp (q, " FLAT:", 6) == 0)
+		strcat (new_token.str, " FLAT:");
+	    }
+
+	  /* ??? This is not mentioned in the MASM grammar.  */
+	  else if (strcasecmp (new_token.str, "FLAT") == 0)
+	    {
+	      new_token.code = T_OFFSET;
+	      if (*q == ':')
+		strcat (new_token.str, ":");
+	      else
+		as_bad (_("`:' expected"));
+	    }
+
+	  else
+	    new_token.code = T_ID;
+	}
+    }
+
+  else if (strchr ("+-/*%|&^:[]()~", *intel_parser.op_string))
+    {
+      new_token.code = *intel_parser.op_string;
+      new_token.str[0] = *intel_parser.op_string;
+      new_token.str[1] = '\0';
+    }
+
+  else if (strchr ("<>", *intel_parser.op_string)
+	   && *intel_parser.op_string == *(intel_parser.op_string + 1))
+    {
+      new_token.code = *intel_parser.op_string == '<' ? T_SHL : T_SHR;
+      new_token.str[0] = *intel_parser.op_string;
+      new_token.str[1] = *intel_parser.op_string;
+      new_token.str[2] = '\0';
+    }
+
+  else
+    as_bad (_("Unrecognized token `%s'"), intel_parser.op_string);
+
+  intel_parser.op_string += strlen (new_token.str);
+  cur_token = new_token;
+}
+
+/* Put cur_token back into the token stream and make cur_token point to
+   prev_token.  */
+static void
+intel_putback_token (void)
+{
+  if (cur_token.code != T_NIL)
+    {
+      intel_parser.op_string -= strlen (cur_token.str);
+      free (cur_token.str);
+    }
+  cur_token = prev_token;
+
+  /* Forget prev_token.  */
+  prev_token.code = T_NIL;
+  prev_token.reg = NULL;
+  prev_token.str = NULL;
+}
+
+int
+tc_x86_regname_to_dw2regnum (char *regname)
+{
+  unsigned int regnum;
+  unsigned int regnames_count;
+  static const char *const regnames_32[] =
+    {
+      "eax", "ecx", "edx", "ebx",
+      "esp", "ebp", "esi", "edi",
+      "eip", "eflags", NULL,
+      "st0", "st1", "st2", "st3",
+      "st4", "st5", "st6", "st7",
+      NULL, NULL,
+      "xmm0", "xmm1", "xmm2", "xmm3",
+      "xmm4", "xmm5", "xmm6", "xmm7",
+      "mm0", "mm1", "mm2", "mm3",
+      "mm4", "mm5", "mm6", "mm7",
+      "fcw", "fsw", "mxcsr",
+      "es", "cs", "ss", "ds", "fs", "gs", NULL, NULL,
+      "tr", "ldtr"
+    };
+  static const char *const regnames_64[] =
+    {
+      "rax", "rdx", "rcx", "rbx",
+      "rsi", "rdi", "rbp", "rsp",
+      "r8",  "r9",  "r10", "r11",
+      "r12", "r13", "r14", "r15",
+      "rip",
+      "xmm0",  "xmm1",  "xmm2",  "xmm3",
+      "xmm4",  "xmm5",  "xmm6",  "xmm7",
+      "xmm8",  "xmm9",  "xmm10", "xmm11",
+      "xmm12", "xmm13", "xmm14", "xmm15",
+      "st0", "st1", "st2", "st3",
+      "st4", "st5", "st6", "st7",
+      "mm0", "mm1", "mm2", "mm3",
+      "mm4", "mm5", "mm6", "mm7",
+      "rflags",
+      "es", "cs", "ss", "ds", "fs", "gs", NULL, NULL,
+      "fs.base", "gs.base", NULL, NULL,
+      "tr", "ldtr",
+      "mxcsr", "fcw", "fsw"
+    };
+  const char *const *regnames;
+
+  if (flag_code == CODE_64BIT)
+    {
+      regnames = regnames_64;
+      regnames_count = ARRAY_SIZE (regnames_64);
+    }
+  else
+    {
+      regnames = regnames_32;
+      regnames_count = ARRAY_SIZE (regnames_32);
+    }
+
+  for (regnum = 0; regnum < regnames_count; regnum++)
+    if (regnames[regnum] != NULL
+	&& strcmp (regname, regnames[regnum]) == 0)
+      return regnum;
+
+  return -1;
+}
+
+void
+tc_x86_frame_initial_instructions (void)
+{
+  static unsigned int sp_regno;
+
+  if (!sp_regno)
+    sp_regno = tc_x86_regname_to_dw2regnum (flag_code == CODE_64BIT
+					    ? "rsp" : "esp");
+
+  cfi_add_CFA_def_cfa (sp_regno, -x86_cie_data_alignment);
+  cfi_add_CFA_offset (x86_dwarf2_return_column, x86_cie_data_alignment);
+}
+
+int
+i386_elf_section_type (const char *str, size_t len)
+{
+  if (flag_code == CODE_64BIT
+      && len == sizeof ("unwind") - 1
+      && strncmp (str, "unwind", 6) == 0)
+    return SHT_X86_64_UNWIND;
+
+  return -1;
+}
+
+#ifdef TE_PE
+void
+tc_pe_dwarf2_emit_offset (symbolS *symbol, unsigned int size)
+{
+  expressionS expr;
+
+  expr.X_op = O_secrel;
+  expr.X_add_symbol = symbol;
+  expr.X_add_number = 0;
+  emit_expr (&expr, size);
+}
+#endif
+
+#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
+/* For ELF on x86-64, add support for SHF_X86_64_LARGE.  */
+
+int
+x86_64_section_letter (int letter, char **ptr_msg)
+{
+  if (flag_code == CODE_64BIT)
+    {
+      if (letter == 'l')
+	return SHF_X86_64_LARGE;
+
+      *ptr_msg = _("Bad .section directive: want a,l,w,x,M,S,G,T in string");
+    }
+  else
+    *ptr_msg = _("Bad .section directive: want a,w,x,M,S,G,T in string");
+  return -1;
+}
+
+int
+x86_64_section_word (char *str, size_t len)
+{
+  if (len == 5 && flag_code == CODE_64BIT && CONST_STRNEQ (str, "large"))
+    return SHF_X86_64_LARGE;
+
+  return -1;
+}
+
+static void
+handle_large_common (int small ATTRIBUTE_UNUSED)
+{
+  if (flag_code != CODE_64BIT)
+    {
+      s_comm_internal (0, elf_common_parse);
+      as_warn (_(".largecomm supported only in 64bit mode, producing .comm"));
+    }
+  else
+    {
+      static segT lbss_section;
+      asection *saved_com_section_ptr = elf_com_section_ptr;
+      asection *saved_bss_section = bss_section;
+
+      if (lbss_section == NULL)
+	{
+	  flagword applicable;
+	  segT seg = now_seg;
+	  subsegT subseg = now_subseg;
+
+	  /* The .lbss section is for local .largecomm symbols.  */
+	  lbss_section = subseg_new (".lbss", 0);
+	  applicable = bfd_applicable_section_flags (stdoutput);
+	  bfd_set_section_flags (stdoutput, lbss_section,
+				 applicable & SEC_ALLOC);
+	  seg_info (lbss_section)->bss = 1;
+
+	  subseg_set (seg, subseg);
+	}
+
+      elf_com_section_ptr = &_bfd_elf_large_com_section;
+      bss_section = lbss_section;
+
+      s_comm_internal (0, elf_common_parse);
+
+      elf_com_section_ptr = saved_com_section_ptr;
+      bss_section = saved_bss_section;
+    }
+}
+
+void nacl_elf_final_processing(void)
+{
+  elf_elfheader (stdoutput)->e_ident[EI_OSABI] = ELFOSABI_NACL;
+  elf_elfheader (stdoutput)->e_ident[EI_ABIVERSION] = EF_NACL_ABIVERSION;
+
+  elf_elfheader (stdoutput)->e_flags &= ~EF_NACL_ALIGN_MASK;
+  if (nacl_library_mode)
+    elf_elfheader (stdoutput)->e_flags |= EF_NACL_ALIGN_LIB;
+  else if (nacl_alignment == 4)
+    elf_elfheader (stdoutput)->e_flags |= EF_NACL_ALIGN_16;
+  else if (nacl_alignment == 5)
+    elf_elfheader (stdoutput)->e_flags |= EF_NACL_ALIGN_32;
+}
+#endif /* OBJ_ELF || OBJ_MAYBE_ELF */
diff -Naur ../PRISTINE/binutils-2.18/gas/config/tc-nacl.h binutils-2.18/gas/config/tc-nacl.h
--- ../PRISTINE/binutils-2.18/gas/config/tc-nacl.h	1969-12-31 16:00:00.000000000 -0800
+++ binutils-2.18/gas/config/tc-nacl.h	2009-01-09 17:32:43.541696000 -0800
@@ -0,0 +1,332 @@
+/* tc-i386.h -- Header file for tc-i386.c
+   Copyright 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
+   2001, 2002, 2003, 2004, 2005, 2006, 2007
+   Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#ifndef TC_NACL
+#define TC_NACL 1
+
+#include "opcodes/i386-opc.h"
+
+struct fix;
+
+#define TARGET_BYTES_BIG_ENDIAN	0
+
+#define TARGET_ARCH		bfd_arch_i386
+#define TARGET_MACH		(i386_mach ())
+extern unsigned long i386_mach (void);
+
+#ifdef TE_FreeBSD
+#define AOUT_TARGET_FORMAT	"a.out-i386-freebsd"
+#endif
+#ifdef TE_NetBSD
+#define AOUT_TARGET_FORMAT	"a.out-i386-netbsd"
+#endif
+#ifdef TE_386BSD
+#define AOUT_TARGET_FORMAT	"a.out-i386-bsd"
+#endif
+#ifdef TE_LINUX
+#define AOUT_TARGET_FORMAT	"a.out-i386-linux"
+#endif
+#ifdef TE_Mach
+#define AOUT_TARGET_FORMAT	"a.out-mach3"
+#endif
+#ifdef TE_DYNIX
+#define AOUT_TARGET_FORMAT	"a.out-i386-dynix"
+#endif
+#ifndef AOUT_TARGET_FORMAT
+#define AOUT_TARGET_FORMAT	"a.out-i386"
+#endif
+
+#ifdef TE_FreeBSD
+#define ELF_TARGET_FORMAT	"elf32-i386-freebsd"
+#define ELF_TARGET_FORMAT64	"elf64-x86-64-freebsd"
+#elif defined (TE_VXWORKS)
+#define ELF_TARGET_FORMAT	"elf32-i386-vxworks"
+#endif
+
+#ifndef ELF_TARGET_FORMAT
+#define ELF_TARGET_FORMAT	"elf32-nacl"
+#endif
+
+#ifndef ELF_TARGET_FORMAT64
+#define ELF_TARGET_FORMAT64	"elf64-x86-64"
+#endif
+
+#if ((defined (OBJ_MAYBE_COFF) && defined (OBJ_MAYBE_AOUT)) \
+     || defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF))
+extern const char *i386_target_format (void);
+#define TARGET_FORMAT i386_target_format ()
+#else
+#ifdef OBJ_ELF
+#define TARGET_FORMAT		ELF_TARGET_FORMAT
+#endif
+#ifdef OBJ_AOUT
+#define TARGET_FORMAT		AOUT_TARGET_FORMAT
+#endif
+#endif
+
+#if (defined (OBJ_MAYBE_ELF) || defined (OBJ_ELF))
+#define md_end i386_elf_emit_arch_note
+extern void i386_elf_emit_arch_note (void);
+#endif
+
+#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN) 0
+
+#define LOCAL_LABELS_FB 1
+
+extern const char extra_symbol_chars[];
+#define tc_symbol_chars extra_symbol_chars
+
+extern const char *i386_comment_chars;
+#define tc_comment_chars i386_comment_chars
+
+/* Prefixes will be emitted in the order defined below.
+   WAIT_PREFIX must be the first prefix since FWAIT is really is an
+   instruction, and so must come before any prefixes.
+   The preferred prefix order is SEG_PREFIX, ADDR_PREFIX, DATA_PREFIX,
+   LOCKREP_PREFIX.  */
+#define WAIT_PREFIX	0
+#define SEG_PREFIX	1
+#define ADDR_PREFIX	2
+#define DATA_PREFIX	3
+#define LOCKREP_PREFIX	4
+#define REX_PREFIX	5       /* must come last.  */
+#define MAX_PREFIXES	6	/* max prefixes per opcode */
+
+/* we define the syntax here (modulo base,index,scale syntax) */
+#define REGISTER_PREFIX '%'
+#define IMMEDIATE_PREFIX '$'
+#define ABSOLUTE_PREFIX '*'
+
+/* these are the instruction mnemonic suffixes.  */
+#define WORD_MNEM_SUFFIX  'w'
+#define BYTE_MNEM_SUFFIX  'b'
+#define SHORT_MNEM_SUFFIX 's'
+#define LONG_MNEM_SUFFIX  'l'
+#define QWORD_MNEM_SUFFIX  'q'
+/* Intel Syntax */
+#define LONG_DOUBLE_MNEM_SUFFIX 'x'
+
+#define END_OF_INSN '\0'
+
+/*
+  'templates' is for grouping together 'template' structures for opcodes
+  of the same name.  This is only used for storing the insns in the grand
+  ole hash table of insns.
+  The templates themselves start at START and range up to (but not including)
+  END.
+  */
+typedef struct
+{
+  const template *start;
+  const template *end;
+}
+templates;
+
+/* 386 operand encoding bytes:  see 386 book for details of this.  */
+typedef struct
+{
+  unsigned int regmem;	/* codes register or memory operand */
+  unsigned int reg;	/* codes register operand (or extended opcode) */
+  unsigned int mode;	/* how to interpret regmem & reg */
+}
+modrm_byte;
+
+/* x86-64 extension prefix.  */
+typedef int rex_byte;
+
+/* 386 opcode byte to code indirect addressing.  */
+typedef struct
+{
+  unsigned base;
+  unsigned index;
+  unsigned scale;
+}
+sib_byte;
+
+enum processor_type
+{
+  PROCESSOR_UNKNOWN,
+  PROCESSOR_I386,
+  PROCESSOR_I486,
+  PROCESSOR_PENTIUM,
+  PROCESSOR_PENTIUMPRO,
+  PROCESSOR_PENTIUM4,
+  PROCESSOR_NOCONA,
+  PROCESSOR_CORE,
+  PROCESSOR_CORE2,
+  PROCESSOR_K6,
+  PROCESSOR_ATHLON,
+  PROCESSOR_K8,
+  PROCESSOR_GENERIC32,
+  PROCESSOR_GENERIC64,
+  PROCESSOR_AMDFAM10
+};
+
+/* x86 arch names, types and features */
+typedef struct
+{
+  const char *name;		/* arch name */
+  enum processor_type type;	/* arch type */
+  unsigned int flags;		/* cpu feature flags */
+}
+arch_entry;
+
+/* The name of the global offset table generated by the compiler. Allow
+   this to be overridden if need be.  */
+#ifndef GLOBAL_OFFSET_TABLE_NAME
+#define GLOBAL_OFFSET_TABLE_NAME "_GLOBAL_OFFSET_TABLE_"
+#endif
+
+#if (defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)) && !defined (LEX_AT)
+#define TC_PARSE_CONS_EXPRESSION(EXP, NBYTES) x86_cons (EXP, NBYTES)
+extern void x86_cons (expressionS *, int);
+
+#endif
+
+#define TC_CONS_FIX_NEW(FRAG,OFF,LEN,EXP) x86_cons_fix_new(FRAG, OFF, LEN, EXP)
+extern void x86_cons_fix_new
+  (fragS *, unsigned int, unsigned int, expressionS *);
+
+#define DIFF_EXPR_OK    /* foo-. gets turned into PC relative relocs */
+
+#define NO_RELOC BFD_RELOC_NONE
+
+void i386_validate_fix (struct fix *);
+#define TC_VALIDATE_FIX(FIX,SEGTYPE,SKIP) i386_validate_fix(FIX)
+
+#define tc_fix_adjustable(X)  tc_i386_fix_adjustable(X)
+extern int tc_i386_fix_adjustable (struct fix *);
+
+/* Values passed to md_apply_fix don't include the symbol value.  */
+#define MD_APPLY_SYM_VALUE(FIX) 0
+
+/* ELF wants external syms kept, as does PE COFF.  */
+#if defined (TE_PE) && defined (STRICT_PE_FORMAT)
+#define EXTERN_FORCE_RELOC				\
+  (OUTPUT_FLAVOR == bfd_target_elf_flavour		\
+   || OUTPUT_FLAVOR == bfd_target_coff_flavour)
+#else
+#define EXTERN_FORCE_RELOC				\
+  (OUTPUT_FLAVOR == bfd_target_elf_flavour)
+#endif
+
+/* This expression evaluates to true if the relocation is for a local
+   object for which we still want to do the relocation at runtime.
+   False if we are willing to perform this relocation while building
+   the .o file.  GOTOFF does not need to be checked here because it is
+   not pcrel.  I am not sure if some of the others are ever used with
+   pcrel, but it is easier to be safe than sorry.  */
+
+#define TC_FORCE_RELOCATION_LOCAL(FIX)			\
+  (!(FIX)->fx_pcrel					\
+   || (FIX)->fx_r_type == BFD_RELOC_386_PLT32		\
+   || (FIX)->fx_r_type == BFD_RELOC_386_GOT32		\
+   || (FIX)->fx_r_type == BFD_RELOC_386_GOTPC		\
+   || TC_FORCE_RELOCATION (FIX))
+
+extern int i386_parse_name (char *, expressionS *, char *);
+#define md_parse_name(s, e, m, c) i386_parse_name (s, e, c)
+
+extern const struct relax_type md_relax_table[];
+#define TC_GENERIC_RELAX_TABLE md_relax_table
+
+extern int optimize_align_code;
+
+#define md_do_align(n, fill, len, max, around)				\
+if ((n)									\
+    && !need_pass_2							\
+    && optimize_align_code						\
+    && (!(fill)								\
+	|| ((char)*(fill) == (char)0x90 && (len) == 1))			\
+    && subseg_text_p (now_seg))						\
+  {									\
+    frag_align_code ((n), (max));					\
+    goto around;							\
+  }
+
+#define MAX_MEM_FOR_RS_ALIGN_CODE  31
+
+extern void i386_align_code (fragS *, int);
+
+#define HANDLE_ALIGN(fragP)						\
+if (fragP->fr_type == rs_align_code) 					\
+  i386_align_code (fragP, (fragP->fr_next->fr_address			\
+			   - fragP->fr_address				\
+			   - fragP->fr_fix));
+
+void i386_print_statistics (FILE *);
+#define tc_print_statistics i386_print_statistics
+
+#define md_number_to_chars number_to_chars_littleendian
+
+#ifdef SCO_ELF
+#define tc_init_after_args() sco_id ()
+extern void sco_id (void);
+#endif
+
+#define WORKING_DOT_WORD 1
+
+/* We want .cfi_* pseudo-ops for generating unwind info.  */
+#define TARGET_USE_CFIPOP 1
+
+extern unsigned int x86_dwarf2_return_column;
+#define DWARF2_DEFAULT_RETURN_COLUMN x86_dwarf2_return_column
+
+extern int x86_cie_data_alignment;
+#define DWARF2_CIE_DATA_ALIGNMENT x86_cie_data_alignment
+
+#define tc_regname_to_dw2regnum tc_x86_regname_to_dw2regnum
+extern int tc_x86_regname_to_dw2regnum (char *);
+
+#define tc_cfi_frame_initial_instructions tc_x86_frame_initial_instructions
+extern void tc_x86_frame_initial_instructions (void);
+
+#define md_elf_section_type(str,len) i386_elf_section_type (str, len)
+extern int i386_elf_section_type (const char *, size_t);
+
+/* Support for SHF_X86_64_LARGE */
+extern int x86_64_section_word (char *, size_t);
+extern int x86_64_section_letter (int, char **);
+#define md_elf_section_letter(LETTER, PTR_MSG)	x86_64_section_letter (LETTER, PTR_MSG)
+#define md_elf_section_word(STR, LEN)		x86_64_section_word (STR, LEN)
+
+#ifdef TE_PE
+
+#define O_secrel O_md1
+
+#define TC_DWARF2_EMIT_OFFSET  tc_pe_dwarf2_emit_offset
+void tc_pe_dwarf2_emit_offset (symbolS *, unsigned int);
+
+#endif /* TE_PE */
+
+/* NativeClient specific additions. */
+
+/* log2 of the instruction alignment */
+extern int nacl_alignment;
+
+/* library mode: 16-byte alignment, calls end 32-byte chunks. */
+extern int nacl_library_mode;
+
+#define elf_tc_final_processing nacl_elf_final_processing
+extern void nacl_elf_final_processing PARAMS ((void));
+
+#endif /* TC_NACL */
diff -Naur ../PRISTINE/binutils-2.18/gas/configure.tgt binutils-2.18/gas/configure.tgt
--- ../PRISTINE/binutils-2.18/gas/configure.tgt	2007-08-28 10:19:36.000000000 -0700
+++ binutils-2.18/gas/configure.tgt	2009-01-09 17:32:43.545689000 -0800
@@ -57,6 +57,7 @@
   mips*el)		cpu_type=mips endian=little ;;
   mips*)		cpu_type=mips endian=big ;;
   mt)                   cpu_type=mt endian=big ;;
+  nacl*)		cpu_type=nacl arch=i386 ;;
   or32*)		cpu_type=or32 endian=big ;;
   pjl*)			cpu_type=pj endian=little ;;
   pj*)			cpu_type=pj endian=big ;;
@@ -193,6 +194,7 @@
   i386-*-linux*coff*)			fmt=coff em=linux ;;
   i386-*-linux-*)			fmt=elf em=linux ;;
   i386-*-lynxos*)			fmt=elf em=lynx ;;
+  i386-*-nacl*)			fmt=elf em=linux cpu_type=nacl;;
   i386-*-sysv[45]*)			fmt=elf ;;
   i386-*-solaris*)			fmt=elf ;;
   i386-*-freebsdaout*)			fmt=aout em=386bsd ;;
diff -Naur ../PRISTINE/binutils-2.18/gas/frags.c binutils-2.18/gas/frags.c
--- ../PRISTINE/binutils-2.18/gas/frags.c	2007-08-06 12:59:50.000000000 -0700
+++ binutils-2.18/gas/frags.c	2009-01-09 17:32:43.553690000 -0800
@@ -35,6 +35,7 @@
   zero_address_frag.fr_type = rs_fill;
   bss_address_frag.fr_type = rs_fill;
 }
+
 
 /* Check that we're not trying to assemble into a section that can't
    allocate frags (currently, this is only possible in the absolute
@@ -69,6 +70,16 @@
   (void) obstack_alloc (ob, 0);
   oalign = obstack_alignment_mask (ob);
   obstack_alignment_mask (ob) = 0;
+  {
+    /* If there isn't adequate space for a frag plus its contents plus the
+     * alignment contents in the current chunk, force the allocation of a new
+     * chunk. */
+
+    int space = obstack_room (ob);
+    if (space < SIZEOF_STRUCT_FRAG + (1 <<(nacl_alignment + 2))) {
+      (void) obstack_alloc (ob, space-1);
+    }
+  }
   ptr = (fragS *) obstack_alloc (ob, SIZEOF_STRUCT_FRAG);
   obstack_alignment_mask (ob) = oalign;
   memset (ptr, 0, SIZEOF_STRUCT_FRAG);
diff -Naur ../PRISTINE/binutils-2.18/gas/frags.h binutils-2.18/gas/frags.h
--- ../PRISTINE/binutils-2.18/gas/frags.h	2007-08-06 12:59:51.000000000 -0700
+++ binutils-2.18/gas/frags.h	2009-01-09 17:32:43.557676000 -0800
@@ -77,10 +77,22 @@
   unsigned int has_code:1;
   unsigned int insn_addr:6;
 
+  /* NativeClient support:
+   * Set if this fragment contains a call in a native client assembly.  These
+   * need to end an alignment unit.
+   */
+  unsigned int is_call:1;
+
   /* What state is my tail in? */
   relax_stateT fr_type;
   relax_substateT fr_subtype;
 
+  /* NativeClient support:
+   * If this fragment contains a call, we will need to tweak the fixup to
+   * reflect the padding to put the call at the end of the fragment.
+   */
+  fixS *nacl_fixup;
+
 #ifdef USING_CGEN
   /* Don't include this unless using CGEN to keep frag size down.  */
   struct {
diff -Naur ../PRISTINE/binutils-2.18/gas/write.c binutils-2.18/gas/write.c
--- ../PRISTINE/binutils-2.18/gas/write.c	2007-08-06 12:59:51.000000000 -0700
+++ binutils-2.18/gas/write.c	2009-01-09 17:32:43.565664000 -0800
@@ -150,6 +150,8 @@
 
   fixP = obstack_alloc (&notes, sizeof (fixS));
 
+  frag->nacl_fixup = fixP;
+
   fixP->fx_frag = frag;
   fixP->fx_where = where;
   fixP->fx_size = size;
@@ -414,6 +416,38 @@
 }
 
 static void
+move_call_insn_to_end(fragS *fragP, fragS *next ATTRIBUTE_UNUSED)
+{
+  if (fragP->fr_offset != 0) {
+    // fragP->fr_fix is the start of the fixup code (i.e. nops).
+    int i;
+    unsigned char *tmp = alloca(fragP->fr_fix);
+    memcpy(tmp, fragP->fr_literal, fragP->fr_fix);
+    for (i = 0; i < fragP->fr_var; i++) {
+      fragP->fr_literal[i] = fragP->fr_literal[fragP->fr_fix+i];
+    }
+    for (i = 0; i< fragP->fr_fix; i++) {
+      fragP->fr_literal[fragP->fr_var+i] = tmp[i];
+    }
+    // TODO(sehr): this code should be obsolete.  Remove it.
+    // If it was a direct call, there's a fixup for the target address.
+    // This needs to corrected to point to the new location of the
+    // constant after we moved the nops.
+    // If there is no fixup, but this is a call, then it is an indirect
+    // call, and we need to put in the fixups for the sandbox code.
+    if (fragP->nacl_fixup) {
+      fragP->nacl_fixup->fx_where += fragP->fr_var;
+    }
+    else if (getenv("NACL_CONTROL_ENFORCE_RANGE")) {
+      symbolS* and_mask = symbol_find_or_make("__nacl_and_mask");
+      symbolS* exec_start = symbol_find_or_make("__executable_start");
+      fix_new (fragP, 2+fragP->fr_var, 4, and_mask, 0, 0, BFD_RELOC_32);
+      fix_new (fragP, 8+fragP->fr_var, 4, exec_start, 0, 0, BFD_RELOC_32);
+    }
+  }
+}
+
+static void
 cvt_frag_to_fill (segT sec ATTRIBUTE_UNUSED, fragS *fragP)
 {
   switch (fragP->fr_type)
@@ -437,6 +471,10 @@
 			(long) fragP->fr_offset);
 	  fragP->fr_offset = 0;
 	}
+
+      if (fragP->is_call && (nacl_alignment > 0)) {
+        move_call_insn_to_end(fragP, NULL);
+      }
       fragP->fr_type = rs_fill;
       break;
 
@@ -1151,6 +1189,8 @@
     {
       int j;
       int fx_size, slack;
+      /* NativeClient change here to handle moving calls. */
+      int limitsize;
       offsetT loc;
 
       if (fixp->fx_done)
@@ -1161,7 +1201,10 @@
       if (slack > 0)
 	fx_size = fx_size > slack ? fx_size - slack : 0;
       loc = fixp->fx_where + fx_size;
-      if (slack >= 0 && loc > fixp->fx_frag->fr_fix)
+      limitsize = (fixp->fx_frag->is_call ?
+                   (fixp->fx_frag->fr_fix + fixp->fx_frag->fr_var) :
+                   fixp->fx_frag->fr_fix);
+      if (slack >= 0 && loc > limitsize)
 	as_bad_where (fixp->fx_file, fixp->fx_line,
 		      _("internal error: fixup not contained within frag"));
 
diff -Naur ../PRISTINE/binutils-2.18/gprof/gprof.1 binutils-2.18/gprof/gprof.1
--- ../PRISTINE/binutils-2.18/gprof/gprof.1	2007-08-06 13:39:31.000000000 -0700
+++ binutils-2.18/gprof/gprof.1	2009-01-09 17:32:43.575664000 -0800
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
+.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.3
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -25,11 +25,11 @@
 ..
 .\" Set up some character translations and predefined strings.  \*(-- will
 .\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
-.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
-.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
-.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
-.\" nothing in troff, for use with C<>.
-.tr \(*W-
+.\" double quote, and \*(R" will give a right double quote.  | will give a
+.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
+.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
+.\" expand to `' in nroff, nothing in troff, for use with C<>.
+.tr \(*W-|\(bv\*(Tr
 .ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
 .ie n \{\
 .    ds -- \(*W-
@@ -128,7 +128,7 @@
 .\" ========================================================================
 .\"
 .IX Title "GPROF 1"
-.TH GPROF 1 "2007-08-06" "binutils-2.17.90" "GNU"
+.TH GPROF 1 "2008-04-04" "binutils-2.18" "GNU"
 .SH "NAME"
 gprof \- display call graph profile data
 .SH "SYNOPSIS"
diff -Naur ../PRISTINE/binutils-2.18/include/elf/common.h binutils-2.18/include/elf/common.h
--- ../PRISTINE/binutils-2.18/include/elf/common.h	2007-08-28 10:19:40.000000000 -0700
+++ binutils-2.18/include/elf/common.h	2009-01-09 17:32:43.586651000 -0800
@@ -75,6 +75,7 @@
 #define ELFOSABI_NSK	     14	/* Hewlett-Packard Non-Stop Kernel */
 #define ELFOSABI_AROS	     15	/* Amiga Research OS */
 #define ELFOSABI_ARM	     97	/* ARM */
+#define ELFOSABI_NACL	    123	/* x86 NativeClient */
 #define ELFOSABI_STANDALONE 255	/* Standalone (embedded) application */
 
 #define EI_ABIVERSION	8	/* ABI version */
diff -Naur ../PRISTINE/binutils-2.18/include/elf/nacl.h binutils-2.18/include/elf/nacl.h
--- ../PRISTINE/binutils-2.18/include/elf/nacl.h	1969-12-31 16:00:00.000000000 -0800
+++ binutils-2.18/include/elf/nacl.h	2009-01-09 17:32:43.590639000 -0800
@@ -0,0 +1,33 @@
+/* ix86 ELF support for BFD.
+   Copyright 1998, 1999, 2000, 2002, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _ELF_NACL_H
+#define _ELF_NACL_H
+
+/* e_flags settings for NativeClient. */
+#define EF_NACL_ALIGN_MASK  0x300000	/* bits indicating alignment */
+#define EF_NACL_ALIGN_16    0x100000	/* aligned zero mod 16 */
+#define EF_NACL_ALIGN_32    0x200000	/* aligned zero mod 32 */ 
+#define EF_NACL_ALIGN_LIB   0x000000	/* aligned to pass either way */
+
+/* ABI version number -- increment when ABI changes are incompatible. */
+#define EF_NACL_ABIVERSION  6
+
+#endif
diff -Naur ../PRISTINE/binutils-2.18/ld/Makefile.am binutils-2.18/ld/Makefile.am
--- ../PRISTINE/binutils-2.18/ld/Makefile.am	2007-08-06 13:00:17.000000000 -0700
+++ binutils-2.18/ld/Makefile.am	2009-01-09 17:32:43.596640000 -0800
@@ -206,6 +206,7 @@
 	eelf_i386_fbsd.o \
 	eelf_i386_ldso.o \
 	eelf_i386_vxworks.o \
+	eelf_nacl.o \
 	eelf_s390.o \
 	egld960.o \
 	egld960coff.o \
@@ -981,6 +982,9 @@
 eelf_i386.c: $(srcdir)/emulparams/elf_i386.sh \
   $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf_i386 "$(tdir_elf_i386)"
+eelf_nacl.c: $(srcdir)/emulparams/elf_nacl.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_nacl "$(tdir_elf_nacl)"
 eelf_x86_64.c: $(srcdir)/emulparams/elf_x86_64.sh \
   $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf_x86_64 "$(tdir_elf_x86_64)"
diff -Naur ../PRISTINE/binutils-2.18/ld/Makefile.in binutils-2.18/ld/Makefile.in
--- ../PRISTINE/binutils-2.18/ld/Makefile.in	2007-08-06 13:29:54.000000000 -0700
+++ binutils-2.18/ld/Makefile.in	2009-01-09 17:32:43.643588000 -0800
@@ -453,6 +453,7 @@
 	eelf_i386_fbsd.o \
 	eelf_i386_ldso.o \
 	eelf_i386_vxworks.o \
+	eelf_nacl.o \
 	eelf_s390.o \
 	egld960.o \
 	egld960coff.o \
@@ -1807,6 +1808,9 @@
 eelf_i386.c: $(srcdir)/emulparams/elf_i386.sh \
   $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf_i386 "$(tdir_elf_i386)"
+eelf_nacl.c: $(srcdir)/emulparams/elf_nacl.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_nacl "$(tdir_elf_nacl)"
 eelf_x86_64.c: $(srcdir)/emulparams/elf_x86_64.sh \
   $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf_x86_64 "$(tdir_elf_x86_64)"
diff -Naur ../PRISTINE/binutils-2.18/ld/configure.tgt binutils-2.18/ld/configure.tgt
--- ../PRISTINE/binutils-2.18/ld/configure.tgt	2007-08-28 10:19:42.000000000 -0700
+++ binutils-2.18/ld/configure.tgt	2009-01-09 17:32:43.652590000 -0800
@@ -220,6 +220,7 @@
 			targ_extra_ofiles="deffilep.o pe-dll.o" ;;
 i[3-7]86-*-netbsd*)	targ_emul=i386nbsd
 			targ_extra_emuls=elf_i386 ;;
+i[3-7]86-*-nacl*)	targ_emul=elf_nacl ;;
 x86_64-*-netbsd*)	targ_emul=elf_x86_64
 			targ_extra_emuls="elf_i386 i386nbsd"
 			tdir_elf_i386=`echo ${targ_alias} | \
diff -Naur ../PRISTINE/binutils-2.18/ld/emulparams/elf_nacl.sh binutils-2.18/ld/emulparams/elf_nacl.sh
--- ../PRISTINE/binutils-2.18/ld/emulparams/elf_nacl.sh	1969-12-31 16:00:00.000000000 -0800
+++ binutils-2.18/ld/emulparams/elf_nacl.sh	2009-01-09 17:32:43.658577000 -0800
@@ -0,0 +1,13 @@
+SCRIPT_NAME=naclelf
+OUTPUT_FORMAT="elf32-nacl"
+TEXT_START_ADDR=0x00020000
+MAXPAGESIZE="CONSTANT (MAXPAGESIZE)"
+COMMONPAGESIZE="CONSTANT (COMMONPAGESIZE)"
+ARCH=i386
+MACHINE=
+NOP=0x90909090
+TEMPLATE_NAME=elf32
+GENERATE_SHLIB_SCRIPT=yes
+GENERATE_PIE_SCRIPT=yes
+NO_SMALL_DATA=yes
+SEPARATE_GOTPLT=12
diff -Naur ../PRISTINE/binutils-2.18/ld/ld.1 binutils-2.18/ld/ld.1
--- ../PRISTINE/binutils-2.18/ld/ld.1	2007-08-28 13:24:23.000000000 -0700
+++ binutils-2.18/ld/ld.1	2009-01-09 17:32:43.670563000 -0800
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
+.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.3
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -25,11 +25,11 @@
 ..
 .\" Set up some character translations and predefined strings.  \*(-- will
 .\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
-.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
-.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
-.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
-.\" nothing in troff, for use with C<>.
-.tr \(*W-
+.\" double quote, and \*(R" will give a right double quote.  | will give a
+.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
+.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
+.\" expand to `' in nroff, nothing in troff, for use with C<>.
+.tr \(*W-|\(bv\*(Tr
 .ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
 .ie n \{\
 .    ds -- \(*W-
@@ -128,7 +128,7 @@
 .\" ========================================================================
 .\"
 .IX Title "LD 1"
-.TH LD 1 "2007-08-28" "binutils-2.18" "GNU Development Tools"
+.TH LD 1 "2008-04-04" "binutils-2.18" "GNU Development Tools"
 .SH "NAME"
 ld \- The GNU linker
 .SH "SYNOPSIS"
diff -Naur ../PRISTINE/binutils-2.18/ld/ldexp.c binutils-2.18/ld/ldexp.c
--- ../PRISTINE/binutils-2.18/ld/ldexp.c	2007-08-06 13:00:20.000000000 -0700
+++ binutils-2.18/ld/ldexp.c	2009-01-09 17:32:43.676555000 -0800
@@ -46,6 +46,8 @@
 static void exp_fold_tree_1 (etree_type *);
 static void exp_fold_tree_no_dot (etree_type *);
 static bfd_vma align_n (bfd_vma, bfd_vma);
+static bfd_vma ceilp2 (bfd_vma);
+static bfd_vma nacl_mask (bfd_vma);
 
 segment_type *segments;
 
@@ -269,6 +271,20 @@
 	    expld.result.valid_p = FALSE;
 	  break;
 
+	case CEILP2:
+	  if (expld.phase != lang_first_phase_enum)
+	    expld.result.value = ceilp2 (expld.result.value);
+	  else
+	    expld.result.valid_p = FALSE;
+	  break;
+
+	case NACL_MASK:
+	  if (expld.phase != lang_first_phase_enum)
+	    expld.result.value = nacl_mask (expld.result.value);
+	  else
+	    expld.result.valid_p = FALSE;
+	  break;
+
 	default:
 	  FAIL ();
 	  break;
@@ -1151,3 +1167,27 @@
   value = (value + align - 1) / align;
   return value * align;
 }
+
+static bfd_vma
+ceilp2 (bfd_vma value)
+{
+  value |= (value >> 1);
+  value |= (value >> 2);
+  value |= (value >> 4);
+  value |= (value >> 8);
+  value |= (value >> 16);
+  return value + 1;
+}
+
+static bfd_vma
+nacl_mask (bfd_vma value)
+{
+  char* str = getenv ("NACL_CONTROL_ENFORCE_ALIGN");
+  if (str) {
+    int nacl_alignment = atoi (str);
+    return (value - 1) & ~((1 << nacl_alignment) - 1);
+  }
+  else {
+    return value - 1;
+  }
+}
diff -Naur ../PRISTINE/binutils-2.18/ld/ldgram.c binutils-2.18/ld/ldgram.c
--- ../PRISTINE/binutils-2.18/ld/ldgram.c	2007-08-06 13:39:31.000000000 -0700
+++ binutils-2.18/ld/ldgram.c	2009-01-09 17:32:43.707541000 -0800
@@ -1,9 +1,7 @@
-/* A Bison parser, made by GNU Bison 2.3.  */
+/* A Bison parser, made by GNU Bison 2.1.  */
 
-/* Skeleton implementation for Bison's Yacc-like parsers in C
-
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
-   Free Software Foundation, Inc.
+/* Skeleton parser for Yacc-like parsing with Bison,
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -20,21 +18,13 @@
    Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.  */
 
-/* As a special exception, you may create a larger work that contains
-   part or all of the Bison parser skeleton and distribute that work
-   under terms of your choice, so long as that work isn't itself a
-   parser generator using the skeleton or a modified version thereof
-   as a parser skeleton.  Alternatively, if you modify or redistribute
-   the parser skeleton itself, you may (at your option) remove this
-   special exception, which will cause the skeleton and the resulting
-   Bison output files to be licensed under the GNU General Public
-   License without this special exception.
-
-   This special exception was added by the Free Software Foundation in
-   version 2.2 of Bison.  */
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
 
-/* C LALR(1) parser skeleton written by Richard Stallman, by
-   simplifying the original so-called "semantic" parser.  */
+/* Written by Richard Stallman by simplifying the original so called
+   ``semantic'' parser.  */
 
 /* All symbols defined below should begin with yy or YY, to avoid
    infringing on user name space.  This should be done even for local
@@ -47,7 +37,7 @@
 #define YYBISON 1
 
 /* Bison version.  */
-#define YYBISON_VERSION "2.3"
+#define YYBISON_VERSION "2.1"
 
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
@@ -127,62 +117,64 @@
      LOADADDR = 316,
      MAX_K = 317,
      MIN_K = 318,
-     STARTUP = 319,
-     HLL = 320,
-     SYSLIB = 321,
-     FLOAT = 322,
-     NOFLOAT = 323,
-     NOCROSSREFS = 324,
-     ORIGIN = 325,
-     FILL = 326,
-     LENGTH = 327,
-     CREATE_OBJECT_SYMBOLS = 328,
-     INPUT = 329,
-     GROUP = 330,
-     OUTPUT = 331,
-     CONSTRUCTORS = 332,
-     ALIGNMOD = 333,
-     AT = 334,
-     SUBALIGN = 335,
-     PROVIDE = 336,
-     PROVIDE_HIDDEN = 337,
-     AS_NEEDED = 338,
-     CHIP = 339,
-     LIST = 340,
-     SECT = 341,
-     ABSOLUTE = 342,
-     LOAD = 343,
-     NEWLINE = 344,
-     ENDWORD = 345,
-     ORDER = 346,
-     NAMEWORD = 347,
-     ASSERT_K = 348,
-     FORMAT = 349,
-     PUBLIC = 350,
-     DEFSYMEND = 351,
-     BASE = 352,
-     ALIAS = 353,
-     TRUNCATE = 354,
-     REL = 355,
-     INPUT_SCRIPT = 356,
-     INPUT_MRI_SCRIPT = 357,
-     INPUT_DEFSYM = 358,
-     CASE = 359,
-     EXTERN = 360,
-     START = 361,
-     VERS_TAG = 362,
-     VERS_IDENTIFIER = 363,
-     GLOBAL = 364,
-     LOCAL = 365,
-     VERSIONK = 366,
-     INPUT_VERSION_SCRIPT = 367,
-     KEEP = 368,
-     ONLY_IF_RO = 369,
-     ONLY_IF_RW = 370,
-     SPECIAL = 371,
-     EXCLUDE_FILE = 372,
-     CONSTANT = 373,
-     INPUT_DYNAMIC_LIST = 374
+     CEILP2 = 319,
+     NACL_MASK = 320,
+     STARTUP = 321,
+     HLL = 322,
+     SYSLIB = 323,
+     FLOAT = 324,
+     NOFLOAT = 325,
+     NOCROSSREFS = 326,
+     ORIGIN = 327,
+     FILL = 328,
+     LENGTH = 329,
+     CREATE_OBJECT_SYMBOLS = 330,
+     INPUT = 331,
+     GROUP = 332,
+     OUTPUT = 333,
+     CONSTRUCTORS = 334,
+     ALIGNMOD = 335,
+     AT = 336,
+     SUBALIGN = 337,
+     PROVIDE = 338,
+     PROVIDE_HIDDEN = 339,
+     AS_NEEDED = 340,
+     CHIP = 341,
+     LIST = 342,
+     SECT = 343,
+     ABSOLUTE = 344,
+     LOAD = 345,
+     NEWLINE = 346,
+     ENDWORD = 347,
+     ORDER = 348,
+     NAMEWORD = 349,
+     ASSERT_K = 350,
+     FORMAT = 351,
+     PUBLIC = 352,
+     DEFSYMEND = 353,
+     BASE = 354,
+     ALIAS = 355,
+     TRUNCATE = 356,
+     REL = 357,
+     INPUT_SCRIPT = 358,
+     INPUT_MRI_SCRIPT = 359,
+     INPUT_DEFSYM = 360,
+     CASE = 361,
+     EXTERN = 362,
+     START = 363,
+     VERS_TAG = 364,
+     VERS_IDENTIFIER = 365,
+     GLOBAL = 366,
+     LOCAL = 367,
+     VERSIONK = 368,
+     INPUT_VERSION_SCRIPT = 369,
+     KEEP = 370,
+     ONLY_IF_RO = 371,
+     ONLY_IF_RW = 372,
+     SPECIAL = 373,
+     EXCLUDE_FILE = 374,
+     CONSTANT = 375,
+     INPUT_DYNAMIC_LIST = 376
    };
 #endif
 /* Tokens.  */
@@ -247,62 +239,64 @@
 #define LOADADDR 316
 #define MAX_K 317
 #define MIN_K 318
-#define STARTUP 319
-#define HLL 320
-#define SYSLIB 321
-#define FLOAT 322
-#define NOFLOAT 323
-#define NOCROSSREFS 324
-#define ORIGIN 325
-#define FILL 326
-#define LENGTH 327
-#define CREATE_OBJECT_SYMBOLS 328
-#define INPUT 329
-#define GROUP 330
-#define OUTPUT 331
-#define CONSTRUCTORS 332
-#define ALIGNMOD 333
-#define AT 334
-#define SUBALIGN 335
-#define PROVIDE 336
-#define PROVIDE_HIDDEN 337
-#define AS_NEEDED 338
-#define CHIP 339
-#define LIST 340
-#define SECT 341
-#define ABSOLUTE 342
-#define LOAD 343
-#define NEWLINE 344
-#define ENDWORD 345
-#define ORDER 346
-#define NAMEWORD 347
-#define ASSERT_K 348
-#define FORMAT 349
-#define PUBLIC 350
-#define DEFSYMEND 351
-#define BASE 352
-#define ALIAS 353
-#define TRUNCATE 354
-#define REL 355
-#define INPUT_SCRIPT 356
-#define INPUT_MRI_SCRIPT 357
-#define INPUT_DEFSYM 358
-#define CASE 359
-#define EXTERN 360
-#define START 361
-#define VERS_TAG 362
-#define VERS_IDENTIFIER 363
-#define GLOBAL 364
-#define LOCAL 365
-#define VERSIONK 366
-#define INPUT_VERSION_SCRIPT 367
-#define KEEP 368
-#define ONLY_IF_RO 369
-#define ONLY_IF_RW 370
-#define SPECIAL 371
-#define EXCLUDE_FILE 372
-#define CONSTANT 373
-#define INPUT_DYNAMIC_LIST 374
+#define CEILP2 319
+#define NACL_MASK 320
+#define STARTUP 321
+#define HLL 322
+#define SYSLIB 323
+#define FLOAT 324
+#define NOFLOAT 325
+#define NOCROSSREFS 326
+#define ORIGIN 327
+#define FILL 328
+#define LENGTH 329
+#define CREATE_OBJECT_SYMBOLS 330
+#define INPUT 331
+#define GROUP 332
+#define OUTPUT 333
+#define CONSTRUCTORS 334
+#define ALIGNMOD 335
+#define AT 336
+#define SUBALIGN 337
+#define PROVIDE 338
+#define PROVIDE_HIDDEN 339
+#define AS_NEEDED 340
+#define CHIP 341
+#define LIST 342
+#define SECT 343
+#define ABSOLUTE 344
+#define LOAD 345
+#define NEWLINE 346
+#define ENDWORD 347
+#define ORDER 348
+#define NAMEWORD 349
+#define ASSERT_K 350
+#define FORMAT 351
+#define PUBLIC 352
+#define DEFSYMEND 353
+#define BASE 354
+#define ALIAS 355
+#define TRUNCATE 356
+#define REL 357
+#define INPUT_SCRIPT 358
+#define INPUT_MRI_SCRIPT 359
+#define INPUT_DEFSYM 360
+#define CASE 361
+#define EXTERN 362
+#define START 363
+#define VERS_TAG 364
+#define VERS_IDENTIFIER 365
+#define GLOBAL 366
+#define LOCAL 367
+#define VERSIONK 368
+#define INPUT_VERSION_SCRIPT 369
+#define KEEP 370
+#define ONLY_IF_RO 371
+#define ONLY_IF_RW 372
+#define SPECIAL 373
+#define EXCLUDE_FILE 374
+#define CONSTANT 375
+#define INPUT_DYNAMIC_LIST 376
 
 
 
@@ -371,10 +365,9 @@
 # define YYTOKEN_TABLE 0
 #endif
 
-#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
-typedef union YYSTYPE
+#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
 #line 66 "ldgram.y"
-{
+typedef union YYSTYPE {
   bfd_vma integer;
   struct big_int
     {
@@ -401,10 +394,9 @@
   struct bfd_elf_version_deps *deflist;
   struct bfd_elf_version_expr *versyms;
   struct bfd_elf_version_tree *versnode;
-}
-/* Line 187 of yacc.c.  */
-#line 407 "ldgram.c"
-	YYSTYPE;
+} YYSTYPE;
+/* Line 196 of yacc.c.  */
+#line 400 "ldgram.c"
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
 # define YYSTYPE_IS_TRIVIAL 1
@@ -415,56 +407,23 @@
 /* Copy the second part of user declarations.  */
 
 
-/* Line 216 of yacc.c.  */
-#line 420 "ldgram.c"
+/* Line 219 of yacc.c.  */
+#line 412 "ldgram.c"
 
-#ifdef short
-# undef short
+#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
+# define YYSIZE_T __SIZE_TYPE__
 #endif
-
-#ifdef YYTYPE_UINT8
-typedef YYTYPE_UINT8 yytype_uint8;
-#else
-typedef unsigned char yytype_uint8;
+#if ! defined (YYSIZE_T) && defined (size_t)
+# define YYSIZE_T size_t
 #endif
-
-#ifdef YYTYPE_INT8
-typedef YYTYPE_INT8 yytype_int8;
-#elif (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-typedef signed char yytype_int8;
-#else
-typedef short int yytype_int8;
+#if ! defined (YYSIZE_T) && (defined (__STDC__) || defined (__cplusplus))
+# include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+# define YYSIZE_T size_t
 #endif
-
-#ifdef YYTYPE_UINT16
-typedef YYTYPE_UINT16 yytype_uint16;
-#else
-typedef unsigned short int yytype_uint16;
+#if ! defined (YYSIZE_T)
+# define YYSIZE_T unsigned int
 #endif
 
-#ifdef YYTYPE_INT16
-typedef YYTYPE_INT16 yytype_int16;
-#else
-typedef short int yytype_int16;
-#endif
-
-#ifndef YYSIZE_T
-# ifdef __SIZE_TYPE__
-#  define YYSIZE_T __SIZE_TYPE__
-# elif defined size_t
-#  define YYSIZE_T size_t
-# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# else
-#  define YYSIZE_T unsigned int
-# endif
-#endif
-
-#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
-
 #ifndef YY_
 # if YYENABLE_NLS
 #  if ENABLE_NLS
@@ -477,32 +436,7 @@
 # endif
 #endif
 
-/* Suppress unused-variable warnings by "using" E.  */
-#if ! defined lint || defined __GNUC__
-# define YYUSE(e) ((void) (e))
-#else
-# define YYUSE(e) /* empty */
-#endif
-
-/* Identity function, used to suppress warnings about constant conditions.  */
-#ifndef lint
-# define YYID(n) (n)
-#else
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static int
-YYID (int i)
-#else
-static int
-YYID (i)
-    int i;
-#endif
-{
-  return i;
-}
-#endif
-
-#if ! defined yyoverflow || YYERROR_VERBOSE
+#if ! defined (yyoverflow) || YYERROR_VERBOSE
 
 /* The parser invokes alloca or malloc; define the necessary symbols.  */
 
@@ -510,76 +444,64 @@
 #  if YYSTACK_USE_ALLOCA
 #   ifdef __GNUC__
 #    define YYSTACK_ALLOC __builtin_alloca
-#   elif defined __BUILTIN_VA_ARG_INCR
-#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
-#   elif defined _AIX
-#    define YYSTACK_ALLOC __alloca
-#   elif defined _MSC_VER
-#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
-#    define alloca _alloca
 #   else
 #    define YYSTACK_ALLOC alloca
-#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
+#    if defined (__STDC__) || defined (__cplusplus)
 #     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#     ifndef _STDLIB_H
-#      define _STDLIB_H 1
-#     endif
+#     define YYINCLUDED_STDLIB_H
 #    endif
 #   endif
 #  endif
 # endif
 
 # ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning.  */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+   /* Pacify GCC's `empty if-body' warning. */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
 #  ifndef YYSTACK_ALLOC_MAXIMUM
     /* The OS might guarantee only one guard page at the bottom of the stack,
        and a page size can be as small as 4096 bytes.  So we cannot safely
        invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
        to allow for a few compiler-allocated temporary stack slots.  */
-#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2005 */
 #  endif
 # else
 #  define YYSTACK_ALLOC YYMALLOC
 #  define YYSTACK_FREE YYFREE
 #  ifndef YYSTACK_ALLOC_MAXIMUM
-#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM ((YYSIZE_T) -1)
 #  endif
-#  if (defined __cplusplus && ! defined _STDLIB_H \
-       && ! ((defined YYMALLOC || defined malloc) \
-	     && (defined YYFREE || defined free)))
-#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   ifndef _STDLIB_H
-#    define _STDLIB_H 1
-#   endif
+#  ifdef __cplusplus
+extern "C" {
 #  endif
 #  ifndef YYMALLOC
 #   define YYMALLOC malloc
-#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
+#   if (! defined (malloc) && ! defined (YYINCLUDED_STDLIB_H) \
+	&& (defined (__STDC__) || defined (__cplusplus)))
 void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
 #   endif
 #  endif
 #  ifndef YYFREE
 #   define YYFREE free
-#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
+#   if (! defined (free) && ! defined (YYINCLUDED_STDLIB_H) \
+	&& (defined (__STDC__) || defined (__cplusplus)))
 void free (void *); /* INFRINGES ON USER NAME SPACE */
 #   endif
 #  endif
+#  ifdef __cplusplus
+}
+#  endif
 # endif
-#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
 
 
-#if (! defined yyoverflow \
-     && (! defined __cplusplus \
-	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+#if (! defined (yyoverflow) \
+     && (! defined (__cplusplus) \
+	 || (defined (YYSTYPE_IS_TRIVIAL) && YYSTYPE_IS_TRIVIAL)))
 
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
 {
-  yytype_int16 yyss;
+  short int yyss;
   YYSTYPE yyvs;
   };
 
@@ -589,13 +511,13 @@
 /* The size of an array large to enough to hold all stacks, each with
    N elements.  */
 # define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+     ((N) * (sizeof (short int) + sizeof (YYSTYPE))			\
       + YYSTACK_GAP_MAXIMUM)
 
 /* Copy COUNT objects from FROM to TO.  The source and destination do
    not overlap.  */
 # ifndef YYCOPY
-#  if defined __GNUC__ && 1 < __GNUC__
+#  if defined (__GNUC__) && 1 < __GNUC__
 #   define YYCOPY(To, From, Count) \
       __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
 #  else
@@ -606,7 +528,7 @@
 	  for (yyi = 0; yyi < (Count); yyi++)	\
 	    (To)[yyi] = (From)[yyi];		\
 	}					\
-      while (YYID (0))
+      while (0)
 #  endif
 # endif
 
@@ -624,47 +546,53 @@
 	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
 	yyptr += yynewbytes / sizeof (*yyptr);				\
       }									\
-    while (YYID (0))
+    while (0)
+
+#endif
 
+#if defined (__STDC__) || defined (__cplusplus)
+   typedef signed char yysigned_char;
+#else
+   typedef short int yysigned_char;
 #endif
 
-/* YYFINAL -- State number of the termination state.  */
+/* YYFINAL -- State number of the termination state. */
 #define YYFINAL  17
 /* YYLAST -- Last index in YYTABLE.  */
-#define YYLAST   1716
+#define YYLAST   1774
 
-/* YYNTOKENS -- Number of terminals.  */
-#define YYNTOKENS  143
-/* YYNNTS -- Number of nonterminals.  */
+/* YYNTOKENS -- Number of terminals. */
+#define YYNTOKENS  145
+/* YYNNTS -- Number of nonterminals. */
 #define YYNNTS  122
-/* YYNRULES -- Number of rules.  */
-#define YYNRULES  346
-/* YYNRULES -- Number of states.  */
-#define YYNSTATES  737
+/* YYNRULES -- Number of rules. */
+#define YYNRULES  348
+/* YYNRULES -- Number of states. */
+#define YYNSTATES  745
 
 /* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
 #define YYUNDEFTOK  2
-#define YYMAXUTOK   374
+#define YYMAXUTOK   376
 
 #define YYTRANSLATE(YYX)						\
   ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
 
 /* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
-static const yytype_uint8 yytranslate[] =
+static const unsigned char yytranslate[] =
 {
        0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,   141,     2,     2,     2,    34,    21,     2,
-      37,   138,    32,    30,   136,    31,     2,    33,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,    16,   137,
+       2,     2,     2,   143,     2,     2,     2,    34,    21,     2,
+      37,   140,    32,    30,   138,    31,     2,    33,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,    16,   139,
       24,     6,    25,    15,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,   139,     2,   140,    20,     2,     2,     2,     2,     2,
+       2,   141,     2,   142,    20,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,    53,    19,    54,   142,     2,     2,     2,
+       2,     2,     2,    53,    19,    54,   144,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
@@ -689,13 +617,13 @@
      101,   102,   103,   104,   105,   106,   107,   108,   109,   110,
      111,   112,   113,   114,   115,   116,   117,   118,   119,   120,
      121,   122,   123,   124,   125,   126,   127,   128,   129,   130,
-     131,   132,   133,   134,   135
+     131,   132,   133,   134,   135,   136,   137
 };
 
 #if YYDEBUG
 /* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
    YYRHS.  */
-static const yytype_uint16 yyprhs[] =
+static const unsigned short int yyprhs[] =
 {
        0,     0,     3,     6,     9,    12,    15,    18,    20,    21,
       26,    27,    30,    34,    35,    38,    43,    45,    47,    50,
@@ -721,146 +649,147 @@
      694,   698,   702,   706,   710,   714,   718,   722,   726,   730,
      734,   740,   744,   748,   753,   755,   757,   762,   767,   772,
      777,   782,   787,   792,   799,   806,   813,   818,   825,   830,
-     832,   839,   846,   853,   858,   863,   867,   868,   873,   874,
-     879,   880,   885,   886,   888,   890,   892,   893,   894,   895,
-     896,   897,   898,   918,   919,   920,   921,   922,   923,   942,
-     943,   944,   952,   954,   956,   958,   960,   962,   966,   967,
-     970,   974,   977,   984,   995,   998,  1000,  1001,  1003,  1006,
-    1007,  1008,  1012,  1013,  1014,  1015,  1016,  1028,  1033,  1034,
-    1037,  1038,  1039,  1046,  1048,  1049,  1053,  1059,  1060,  1064,
-    1065,  1068,  1070,  1073,  1078,  1081,  1082,  1085,  1086,  1092,
-    1094,  1097,  1102,  1108,  1115,  1117,  1120,  1121,  1124,  1129,
-    1134,  1143,  1145,  1147,  1151,  1155,  1156,  1166,  1167,  1175,
-    1177,  1181,  1183,  1187,  1189,  1193,  1194
+     832,   839,   846,   851,   856,   863,   868,   873,   877,   878,
+     883,   884,   889,   890,   895,   896,   898,   900,   902,   903,
+     904,   905,   906,   907,   908,   928,   929,   930,   931,   932,
+     933,   952,   953,   954,   962,   964,   966,   968,   970,   972,
+     976,   977,   980,   984,   987,   994,  1005,  1008,  1010,  1011,
+    1013,  1016,  1017,  1018,  1022,  1023,  1024,  1025,  1026,  1038,
+    1043,  1044,  1047,  1048,  1049,  1056,  1058,  1059,  1063,  1069,
+    1070,  1074,  1075,  1078,  1080,  1083,  1088,  1091,  1092,  1095,
+    1096,  1102,  1104,  1107,  1112,  1118,  1125,  1127,  1130,  1131,
+    1134,  1139,  1144,  1153,  1155,  1157,  1161,  1165,  1166,  1176,
+    1177,  1185,  1187,  1191,  1193,  1197,  1199,  1203,  1204
 };
 
-/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
-static const yytype_int16 yyrhs[] =
+/* YYRHS -- A `-1'-separated list of the rules' RHS. */
+static const short int yyrhs[] =
 {
-     144,     0,    -1,   117,   160,    -1,   118,   148,    -1,   128,
-     253,    -1,   135,   248,    -1,   119,   146,    -1,     4,    -1,
-      -1,   147,     4,     6,   210,    -1,    -1,   149,   150,    -1,
-     150,   151,   105,    -1,    -1,   100,   210,    -1,   100,   210,
-     136,   210,    -1,     4,    -1,   101,    -1,   107,   153,    -1,
-     106,    -1,   111,     4,     6,   210,    -1,   111,     4,   136,
-     210,    -1,   111,     4,   210,    -1,   110,     4,    -1,   102,
-       4,   136,   210,    -1,   102,     4,   210,    -1,   102,     4,
-       6,   210,    -1,    38,     4,     6,   210,    -1,    38,     4,
-     136,   210,    -1,    94,     4,     6,   210,    -1,    94,     4,
-     136,   210,    -1,   103,   155,    -1,   104,   154,    -1,   108,
-       4,    -1,   114,     4,   136,     4,    -1,   114,     4,   136,
-       3,    -1,   113,   210,    -1,   115,     3,    -1,   120,   156,
-      -1,   121,   157,    -1,    -1,    61,   145,   152,   150,    36,
-      -1,   122,     4,    -1,    -1,   153,   136,     4,    -1,   153,
-       4,    -1,    -1,     4,    -1,   154,   136,     4,    -1,     4,
-      -1,   155,   136,     4,    -1,    -1,     4,    -1,   156,   136,
-       4,    -1,    -1,   158,   159,    -1,     4,    -1,   159,     4,
-      -1,   159,   136,     4,    -1,    -1,   161,   162,    -1,   162,
-     163,    -1,    -1,   192,    -1,   170,    -1,   240,    -1,   201,
-      -1,   202,    -1,   204,    -1,   206,    -1,   172,    -1,   255,
-      -1,   137,    -1,    69,    37,     4,   138,    -1,    70,    37,
-     145,   138,    -1,    92,    37,   145,   138,    -1,    56,    37,
-       4,   138,    -1,    56,    37,     4,   136,     4,   136,     4,
-     138,    -1,    58,    37,     4,   138,    -1,    57,    -1,    59,
-      -1,    90,    37,   166,   138,    -1,    -1,    91,   164,    37,
-     166,   138,    -1,    71,    37,   145,   138,    -1,    -1,    61,
-     145,   165,   162,    36,    -1,    85,    37,   207,   138,    -1,
-     121,    37,   157,   138,    -1,     4,    -1,   166,   136,     4,
-      -1,   166,     4,    -1,     5,    -1,   166,   136,     5,    -1,
-     166,     5,    -1,    -1,    99,    37,   167,   166,   138,    -1,
-      -1,   166,   136,    99,    37,   168,   166,   138,    -1,    -1,
-     166,    99,    37,   169,   166,   138,    -1,    46,    53,   171,
-      54,    -1,   171,   216,    -1,   171,   172,    -1,    -1,    72,
-      37,     4,   138,    -1,   190,   189,    -1,    -1,   109,   173,
-      37,   210,   136,     4,   138,    -1,     4,    -1,    32,    -1,
-      15,    -1,   174,    -1,   133,    37,   176,   138,   174,    -1,
-      51,    37,   174,   138,    -1,    52,    37,   174,   138,    -1,
-      51,    37,    52,    37,   174,   138,   138,    -1,    51,    37,
-      51,    37,   174,   138,   138,    -1,    52,    37,    51,    37,
-     174,   138,   138,    -1,    52,    37,    52,    37,   174,   138,
-     138,    -1,    51,    37,   133,    37,   176,   138,   174,   138,
-      -1,   176,   174,    -1,   174,    -1,   177,   191,   175,    -1,
-     175,    -1,     4,    -1,   139,   177,   140,    -1,   175,    37,
-     177,   138,    -1,   178,    -1,    -1,   129,    37,   180,   178,
-     138,    -1,   190,   189,    -1,    89,    -1,   137,    -1,    93,
-      -1,    51,    37,    93,   138,    -1,   179,    -1,   185,    37,
-     208,   138,    -1,    87,    37,   186,   138,    -1,    -1,   109,
-     182,    37,   210,   136,     4,   138,   189,    -1,   183,   181,
-      -1,   181,    -1,    -1,   183,    -1,    41,    -1,    42,    -1,
-      43,    -1,    44,    -1,    45,    -1,   208,    -1,     6,   186,
+     146,     0,    -1,   119,   162,    -1,   120,   150,    -1,   130,
+     255,    -1,   137,   250,    -1,   121,   148,    -1,     4,    -1,
+      -1,   149,     4,     6,   212,    -1,    -1,   151,   152,    -1,
+     152,   153,   107,    -1,    -1,   102,   212,    -1,   102,   212,
+     138,   212,    -1,     4,    -1,   103,    -1,   109,   155,    -1,
+     108,    -1,   113,     4,     6,   212,    -1,   113,     4,   138,
+     212,    -1,   113,     4,   212,    -1,   112,     4,    -1,   104,
+       4,   138,   212,    -1,   104,     4,   212,    -1,   104,     4,
+       6,   212,    -1,    38,     4,     6,   212,    -1,    38,     4,
+     138,   212,    -1,    96,     4,     6,   212,    -1,    96,     4,
+     138,   212,    -1,   105,   157,    -1,   106,   156,    -1,   110,
+       4,    -1,   116,     4,   138,     4,    -1,   116,     4,   138,
+       3,    -1,   115,   212,    -1,   117,     3,    -1,   122,   158,
+      -1,   123,   159,    -1,    -1,    61,   147,   154,   152,    36,
+      -1,   124,     4,    -1,    -1,   155,   138,     4,    -1,   155,
+       4,    -1,    -1,     4,    -1,   156,   138,     4,    -1,     4,
+      -1,   157,   138,     4,    -1,    -1,     4,    -1,   158,   138,
+       4,    -1,    -1,   160,   161,    -1,     4,    -1,   161,     4,
+      -1,   161,   138,     4,    -1,    -1,   163,   164,    -1,   164,
+     165,    -1,    -1,   194,    -1,   172,    -1,   242,    -1,   203,
+      -1,   204,    -1,   206,    -1,   208,    -1,   174,    -1,   257,
+      -1,   139,    -1,    69,    37,     4,   140,    -1,    70,    37,
+     147,   140,    -1,    94,    37,   147,   140,    -1,    56,    37,
+       4,   140,    -1,    56,    37,     4,   138,     4,   138,     4,
+     140,    -1,    58,    37,     4,   140,    -1,    57,    -1,    59,
+      -1,    92,    37,   168,   140,    -1,    -1,    93,   166,    37,
+     168,   140,    -1,    71,    37,   147,   140,    -1,    -1,    61,
+     147,   167,   164,    36,    -1,    87,    37,   209,   140,    -1,
+     123,    37,   159,   140,    -1,     4,    -1,   168,   138,     4,
+      -1,   168,     4,    -1,     5,    -1,   168,   138,     5,    -1,
+     168,     5,    -1,    -1,   101,    37,   169,   168,   140,    -1,
+      -1,   168,   138,   101,    37,   170,   168,   140,    -1,    -1,
+     168,   101,    37,   171,   168,   140,    -1,    46,    53,   173,
+      54,    -1,   173,   218,    -1,   173,   174,    -1,    -1,    72,
+      37,     4,   140,    -1,   192,   191,    -1,    -1,   111,   175,
+      37,   212,   138,     4,   140,    -1,     4,    -1,    32,    -1,
+      15,    -1,   176,    -1,   135,    37,   178,   140,   176,    -1,
+      51,    37,   176,   140,    -1,    52,    37,   176,   140,    -1,
+      51,    37,    52,    37,   176,   140,   140,    -1,    51,    37,
+      51,    37,   176,   140,   140,    -1,    52,    37,    51,    37,
+     176,   140,   140,    -1,    52,    37,    52,    37,   176,   140,
+     140,    -1,    51,    37,   135,    37,   178,   140,   176,   140,
+      -1,   178,   176,    -1,   176,    -1,   179,   193,   177,    -1,
+     177,    -1,     4,    -1,   141,   179,   142,    -1,   177,    37,
+     179,   140,    -1,   180,    -1,    -1,   131,    37,   182,   180,
+     140,    -1,   192,   191,    -1,    91,    -1,   139,    -1,    95,
+      -1,    51,    37,    95,   140,    -1,   181,    -1,   187,    37,
+     210,   140,    -1,    89,    37,   188,   140,    -1,    -1,   111,
+     184,    37,   212,   138,     4,   140,   191,    -1,   185,   183,
+      -1,   183,    -1,    -1,   185,    -1,    41,    -1,    42,    -1,
+      43,    -1,    44,    -1,    45,    -1,   210,    -1,     6,   188,
       -1,    -1,    14,    -1,    13,    -1,    12,    -1,    11,    -1,
-      10,    -1,     9,    -1,     8,    -1,     7,    -1,   137,    -1,
-     136,    -1,     4,     6,   208,    -1,     4,   188,   208,    -1,
-      97,    37,     4,     6,   208,   138,    -1,    98,    37,     4,
-       6,   208,   138,    -1,   136,    -1,    -1,    62,    53,   194,
-     193,    54,    -1,   193,   194,    -1,   193,   136,   194,    -1,
-      -1,    -1,     4,   195,   198,    16,   196,   191,   197,    -1,
-      86,     6,   208,    -1,    88,     6,   208,    -1,    -1,    37,
-     199,   138,    -1,   200,    -1,   199,   200,    -1,     4,    -1,
-     141,     4,    -1,    80,    37,   145,   138,    -1,    81,    37,
-     203,   138,    -1,    81,    37,   138,    -1,   203,   191,   145,
-      -1,   145,    -1,    82,    37,   205,   138,    -1,   205,   191,
-     145,    -1,    -1,    83,    -1,    84,    -1,    -1,     4,   207,
-      -1,     4,   136,   207,    -1,    -1,   209,   210,    -1,    31,
-     210,    -1,    37,   210,   138,    -1,    73,    37,   210,   138,
-      -1,   141,   210,    -1,    30,   210,    -1,   142,   210,    -1,
-     210,    32,   210,    -1,   210,    33,   210,    -1,   210,    34,
-     210,    -1,   210,    30,   210,    -1,   210,    31,   210,    -1,
-     210,    29,   210,    -1,   210,    28,   210,    -1,   210,    23,
-     210,    -1,   210,    22,   210,    -1,   210,    27,   210,    -1,
-     210,    26,   210,    -1,   210,    24,   210,    -1,   210,    25,
-     210,    -1,   210,    21,   210,    -1,   210,    20,   210,    -1,
-     210,    19,   210,    -1,   210,    15,   210,    16,   210,    -1,
-     210,    18,   210,    -1,   210,    17,   210,    -1,    68,    37,
-       4,   138,    -1,     3,    -1,    55,    -1,    75,    37,     4,
-     138,    -1,    74,    37,     4,   138,    -1,    76,    37,     4,
-     138,    -1,    77,    37,     4,   138,    -1,   134,    37,     4,
-     138,    -1,   103,    37,   210,   138,    -1,    38,    37,   210,
-     138,    -1,    38,    37,   210,   136,   210,   138,    -1,    48,
-      37,   210,   136,   210,   138,    -1,    49,    37,   210,   136,
-     210,   138,    -1,    50,    37,   210,   138,    -1,    60,    37,
-       4,   136,   210,   138,    -1,    39,    37,   210,   138,    -1,
-       4,    -1,    78,    37,   210,   136,   210,   138,    -1,    79,
-      37,   210,   136,   210,   138,    -1,   109,    37,   210,   136,
-       4,   138,    -1,    86,    37,     4,   138,    -1,    88,    37,
-       4,   138,    -1,    95,    25,     4,    -1,    -1,    95,    37,
-     210,   138,    -1,    -1,    38,    37,   210,   138,    -1,    -1,
-      96,    37,   210,   138,    -1,    -1,   130,    -1,   131,    -1,
-     132,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     4,   217,
-     231,   212,   213,   214,   218,   215,    53,   219,   184,    54,
-     220,   234,   211,   235,   187,   221,   191,    -1,    -1,    -1,
-      -1,    -1,    -1,    67,   222,   232,   233,   212,   214,   223,
-      53,   224,   236,    54,   225,   234,   211,   235,   187,   226,
-     191,    -1,    -1,    -1,    91,   227,   231,   228,    53,   171,
+      10,    -1,     9,    -1,     8,    -1,     7,    -1,   139,    -1,
+     138,    -1,     4,     6,   210,    -1,     4,   190,   210,    -1,
+      99,    37,     4,     6,   210,   140,    -1,   100,    37,     4,
+       6,   210,   140,    -1,   138,    -1,    -1,    62,    53,   196,
+     195,    54,    -1,   195,   196,    -1,   195,   138,   196,    -1,
+      -1,    -1,     4,   197,   200,    16,   198,   193,   199,    -1,
+      88,     6,   210,    -1,    90,     6,   210,    -1,    -1,    37,
+     201,   140,    -1,   202,    -1,   201,   202,    -1,     4,    -1,
+     143,     4,    -1,    82,    37,   147,   140,    -1,    83,    37,
+     205,   140,    -1,    83,    37,   140,    -1,   205,   193,   147,
+      -1,   147,    -1,    84,    37,   207,   140,    -1,   207,   193,
+     147,    -1,    -1,    85,    -1,    86,    -1,    -1,     4,   209,
+      -1,     4,   138,   209,    -1,    -1,   211,   212,    -1,    31,
+     212,    -1,    37,   212,   140,    -1,    73,    37,   212,   140,
+      -1,   143,   212,    -1,    30,   212,    -1,   144,   212,    -1,
+     212,    32,   212,    -1,   212,    33,   212,    -1,   212,    34,
+     212,    -1,   212,    30,   212,    -1,   212,    31,   212,    -1,
+     212,    29,   212,    -1,   212,    28,   212,    -1,   212,    23,
+     212,    -1,   212,    22,   212,    -1,   212,    27,   212,    -1,
+     212,    26,   212,    -1,   212,    24,   212,    -1,   212,    25,
+     212,    -1,   212,    21,   212,    -1,   212,    20,   212,    -1,
+     212,    19,   212,    -1,   212,    15,   212,    16,   212,    -1,
+     212,    18,   212,    -1,   212,    17,   212,    -1,    68,    37,
+       4,   140,    -1,     3,    -1,    55,    -1,    75,    37,     4,
+     140,    -1,    74,    37,     4,   140,    -1,    76,    37,     4,
+     140,    -1,    77,    37,     4,   140,    -1,   136,    37,     4,
+     140,    -1,   105,    37,   212,   140,    -1,    38,    37,   212,
+     140,    -1,    38,    37,   212,   138,   212,   140,    -1,    48,
+      37,   212,   138,   212,   140,    -1,    49,    37,   212,   138,
+     212,   140,    -1,    50,    37,   212,   140,    -1,    60,    37,
+       4,   138,   212,   140,    -1,    39,    37,   212,   140,    -1,
+       4,    -1,    78,    37,   212,   138,   212,   140,    -1,    79,
+      37,   212,   138,   212,   140,    -1,    80,    37,   212,   140,
+      -1,    81,    37,   212,   140,    -1,   111,    37,   212,   138,
+       4,   140,    -1,    88,    37,     4,   140,    -1,    90,    37,
+       4,   140,    -1,    97,    25,     4,    -1,    -1,    97,    37,
+     212,   140,    -1,    -1,    38,    37,   212,   140,    -1,    -1,
+      98,    37,   212,   140,    -1,    -1,   132,    -1,   133,    -1,
+     134,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     4,   219,
+     233,   214,   215,   216,   220,   217,    53,   221,   186,    54,
+     222,   236,   213,   237,   189,   223,   193,    -1,    -1,    -1,
+      -1,    -1,    -1,    67,   224,   234,   235,   214,   216,   225,
+      53,   226,   238,    54,   227,   236,   213,   237,   189,   228,
+     193,    -1,    -1,    -1,    93,   229,   233,   230,    53,   173,
       54,    -1,    63,    -1,    64,    -1,    65,    -1,    66,    -1,
-      67,    -1,    37,   229,   138,    -1,    -1,    37,   138,    -1,
-     210,   230,    16,    -1,   230,    16,    -1,    40,    37,   210,
-     138,   230,    16,    -1,    40,    37,   210,   138,    39,    37,
-     210,   138,   230,    16,    -1,   210,    16,    -1,    16,    -1,
-      -1,    85,    -1,    25,     4,    -1,    -1,    -1,   235,    16,
-       4,    -1,    -1,    -1,    -1,    -1,   236,     4,   237,    53,
-     184,    54,   238,   235,   187,   239,   191,    -1,    47,    53,
-     241,    54,    -1,    -1,   241,   242,    -1,    -1,    -1,     4,
-     243,   245,   246,   244,   137,    -1,   210,    -1,    -1,     4,
-     247,   246,    -1,    95,    37,   210,   138,   246,    -1,    -1,
-      37,   210,   138,    -1,    -1,   249,   250,    -1,   251,    -1,
-     250,   251,    -1,    53,   252,    54,   137,    -1,   261,   137,
-      -1,    -1,   254,   257,    -1,    -1,   256,   127,    53,   257,
-      54,    -1,   258,    -1,   257,   258,    -1,    53,   260,    54,
-     137,    -1,   123,    53,   260,    54,   137,    -1,   123,    53,
-     260,    54,   259,   137,    -1,   123,    -1,   259,   123,    -1,
-      -1,   261,   137,    -1,   125,    16,   261,   137,    -1,   126,
-      16,   261,   137,    -1,   125,    16,   261,   137,   126,    16,
-     261,   137,    -1,   124,    -1,     4,    -1,   261,   137,   124,
-      -1,   261,   137,     4,    -1,    -1,   261,   137,   121,     4,
-      53,   262,   261,   264,    54,    -1,    -1,   121,     4,    53,
-     263,   261,   264,    54,    -1,   125,    -1,   261,   137,   125,
-      -1,   126,    -1,   261,   137,   126,    -1,   121,    -1,   261,
-     137,   121,    -1,    -1,   137,    -1
+      67,    -1,    37,   231,   140,    -1,    -1,    37,   140,    -1,
+     212,   232,    16,    -1,   232,    16,    -1,    40,    37,   212,
+     140,   232,    16,    -1,    40,    37,   212,   140,    39,    37,
+     212,   140,   232,    16,    -1,   212,    16,    -1,    16,    -1,
+      -1,    87,    -1,    25,     4,    -1,    -1,    -1,   237,    16,
+       4,    -1,    -1,    -1,    -1,    -1,   238,     4,   239,    53,
+     186,    54,   240,   237,   189,   241,   193,    -1,    47,    53,
+     243,    54,    -1,    -1,   243,   244,    -1,    -1,    -1,     4,
+     245,   247,   248,   246,   139,    -1,   212,    -1,    -1,     4,
+     249,   248,    -1,    97,    37,   212,   140,   248,    -1,    -1,
+      37,   212,   140,    -1,    -1,   251,   252,    -1,   253,    -1,
+     252,   253,    -1,    53,   254,    54,   139,    -1,   263,   139,
+      -1,    -1,   256,   259,    -1,    -1,   258,   129,    53,   259,
+      54,    -1,   260,    -1,   259,   260,    -1,    53,   262,    54,
+     139,    -1,   125,    53,   262,    54,   139,    -1,   125,    53,
+     262,    54,   261,   139,    -1,   125,    -1,   261,   125,    -1,
+      -1,   263,   139,    -1,   127,    16,   263,   139,    -1,   128,
+      16,   263,   139,    -1,   127,    16,   263,   139,   128,    16,
+     263,   139,    -1,   126,    -1,     4,    -1,   263,   139,   126,
+      -1,   263,   139,     4,    -1,    -1,   263,   139,   123,     4,
+      53,   264,   263,   266,    54,    -1,    -1,   123,     4,    53,
+     265,   263,   266,    54,    -1,   127,    -1,   263,   139,   127,
+      -1,   128,    -1,   263,   139,   128,    -1,   123,    -1,   263,
+     139,   123,    -1,    -1,   139,    -1
 };
 
 /* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
-static const yytype_uint16 yyrline[] =
+static const unsigned short int yyrline[] =
 {
        0,   164,   164,   165,   166,   167,   168,   172,   176,   176,
      186,   186,   199,   200,   204,   205,   206,   209,   212,   213,
@@ -886,23 +815,23 @@
      811,   813,   815,   817,   819,   821,   823,   825,   827,   829,
      831,   833,   835,   837,   839,   841,   844,   846,   848,   850,
      852,   854,   856,   858,   860,   862,   864,   866,   875,   877,
-     879,   881,   883,   885,   887,   893,   894,   898,   899,   903,
-     904,   908,   909,   913,   914,   915,   916,   919,   923,   926,
-     932,   934,   919,   941,   943,   945,   950,   952,   940,   962,
-     964,   962,   972,   973,   974,   975,   976,   980,   981,   982,
-     986,   987,   992,   993,   998,   999,  1004,  1005,  1010,  1012,
-    1017,  1020,  1033,  1037,  1042,  1044,  1035,  1052,  1055,  1057,
-    1061,  1062,  1061,  1071,  1116,  1119,  1131,  1140,  1143,  1150,
-    1150,  1162,  1163,  1167,  1171,  1180,  1180,  1194,  1194,  1204,
-    1205,  1209,  1213,  1217,  1224,  1228,  1236,  1239,  1243,  1247,
-    1251,  1258,  1262,  1266,  1270,  1275,  1274,  1288,  1287,  1297,
-    1301,  1305,  1309,  1313,  1317,  1323,  1325
+     879,   881,   883,   885,   887,   889,   891,   897,   898,   902,
+     903,   907,   908,   912,   913,   917,   918,   919,   920,   923,
+     927,   930,   936,   938,   923,   945,   947,   949,   954,   956,
+     944,   966,   968,   966,   976,   977,   978,   979,   980,   984,
+     985,   986,   990,   991,   996,   997,  1002,  1003,  1008,  1009,
+    1014,  1016,  1021,  1024,  1037,  1041,  1046,  1048,  1039,  1056,
+    1059,  1061,  1065,  1066,  1065,  1075,  1120,  1123,  1135,  1144,
+    1147,  1154,  1154,  1166,  1167,  1171,  1175,  1184,  1184,  1198,
+    1198,  1208,  1209,  1213,  1217,  1221,  1228,  1232,  1240,  1243,
+    1247,  1251,  1255,  1262,  1266,  1270,  1274,  1279,  1278,  1292,
+    1291,  1301,  1305,  1309,  1313,  1317,  1321,  1327,  1329
 };
 #endif
 
 #if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
 /* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
 static const char *const yytname[] =
 {
   "$end", "error", "$undefined", "INT", "NAME", "LNAME", "'='", "OREQ",
@@ -916,50 +845,51 @@
   "FORCE_COMMON_ALLOCATION", "OUTPUT_ARCH", "INHIBIT_COMMON_ALLOCATION",
   "SEGMENT_START", "INCLUDE", "MEMORY", "NOLOAD", "DSECT", "COPY", "INFO",
   "OVERLAY", "DEFINED", "TARGET_K", "SEARCH_DIR", "MAP", "ENTRY", "NEXT",
-  "SIZEOF", "ALIGNOF", "ADDR", "LOADADDR", "MAX_K", "MIN_K", "STARTUP",
-  "HLL", "SYSLIB", "FLOAT", "NOFLOAT", "NOCROSSREFS", "ORIGIN", "FILL",
-  "LENGTH", "CREATE_OBJECT_SYMBOLS", "INPUT", "GROUP", "OUTPUT",
-  "CONSTRUCTORS", "ALIGNMOD", "AT", "SUBALIGN", "PROVIDE",
-  "PROVIDE_HIDDEN", "AS_NEEDED", "CHIP", "LIST", "SECT", "ABSOLUTE",
-  "LOAD", "NEWLINE", "ENDWORD", "ORDER", "NAMEWORD", "ASSERT_K", "FORMAT",
-  "PUBLIC", "DEFSYMEND", "BASE", "ALIAS", "TRUNCATE", "REL",
-  "INPUT_SCRIPT", "INPUT_MRI_SCRIPT", "INPUT_DEFSYM", "CASE", "EXTERN",
-  "START", "VERS_TAG", "VERS_IDENTIFIER", "GLOBAL", "LOCAL", "VERSIONK",
-  "INPUT_VERSION_SCRIPT", "KEEP", "ONLY_IF_RO", "ONLY_IF_RW", "SPECIAL",
-  "EXCLUDE_FILE", "CONSTANT", "INPUT_DYNAMIC_LIST", "','", "';'", "')'",
-  "'['", "']'", "'!'", "'~'", "$accept", "file", "filename", "defsym_expr",
-  "@1", "mri_script_file", "@2", "mri_script_lines", "mri_script_command",
-  "@3", "ordernamelist", "mri_load_name_list", "mri_abs_name_list",
-  "casesymlist", "extern_name_list", "@4", "extern_name_list_body",
-  "script_file", "@5", "ifile_list", "ifile_p1", "@6", "@7", "input_list",
-  "@8", "@9", "@10", "sections", "sec_or_group_p1", "statement_anywhere",
-  "@11", "wildcard_name", "wildcard_spec", "exclude_name_list",
-  "file_NAME_list", "input_section_spec_no_keep", "input_section_spec",
-  "@12", "statement", "@13", "statement_list", "statement_list_opt",
-  "length", "fill_exp", "fill_opt", "assign_op", "end", "assignment",
-  "opt_comma", "memory", "memory_spec_list", "memory_spec", "@14",
-  "origin_spec", "length_spec", "attributes_opt", "attributes_list",
-  "attributes_string", "startup", "high_level_library",
-  "high_level_library_NAME_list", "low_level_library",
-  "low_level_library_NAME_list", "floating_point_support",
-  "nocrossref_list", "mustbe_exp", "@15", "exp", "memspec_at_opt",
-  "opt_at", "opt_align", "opt_subalign", "sect_constraint", "section",
-  "@16", "@17", "@18", "@19", "@20", "@21", "@22", "@23", "@24", "@25",
-  "@26", "@27", "type", "atype", "opt_exp_with_type",
-  "opt_exp_without_type", "opt_nocrossrefs", "memspec_opt", "phdr_opt",
-  "overlay_section", "@28", "@29", "@30", "phdrs", "phdr_list", "phdr",
-  "@31", "@32", "phdr_type", "phdr_qualifiers", "phdr_val",
-  "dynamic_list_file", "@33", "dynamic_list_nodes", "dynamic_list_node",
-  "dynamic_list_tag", "version_script_file", "@34", "version", "@35",
-  "vers_nodes", "vers_node", "verdep", "vers_tag", "vers_defns", "@36",
-  "@37", "opt_semicolon", 0
+  "SIZEOF", "ALIGNOF", "ADDR", "LOADADDR", "MAX_K", "MIN_K", "CEILP2",
+  "NACL_MASK", "STARTUP", "HLL", "SYSLIB", "FLOAT", "NOFLOAT",
+  "NOCROSSREFS", "ORIGIN", "FILL", "LENGTH", "CREATE_OBJECT_SYMBOLS",
+  "INPUT", "GROUP", "OUTPUT", "CONSTRUCTORS", "ALIGNMOD", "AT", "SUBALIGN",
+  "PROVIDE", "PROVIDE_HIDDEN", "AS_NEEDED", "CHIP", "LIST", "SECT",
+  "ABSOLUTE", "LOAD", "NEWLINE", "ENDWORD", "ORDER", "NAMEWORD",
+  "ASSERT_K", "FORMAT", "PUBLIC", "DEFSYMEND", "BASE", "ALIAS", "TRUNCATE",
+  "REL", "INPUT_SCRIPT", "INPUT_MRI_SCRIPT", "INPUT_DEFSYM", "CASE",
+  "EXTERN", "START", "VERS_TAG", "VERS_IDENTIFIER", "GLOBAL", "LOCAL",
+  "VERSIONK", "INPUT_VERSION_SCRIPT", "KEEP", "ONLY_IF_RO", "ONLY_IF_RW",
+  "SPECIAL", "EXCLUDE_FILE", "CONSTANT", "INPUT_DYNAMIC_LIST", "','",
+  "';'", "')'", "'['", "']'", "'!'", "'~'", "$accept", "file", "filename",
+  "defsym_expr", "@1", "mri_script_file", "@2", "mri_script_lines",
+  "mri_script_command", "@3", "ordernamelist", "mri_load_name_list",
+  "mri_abs_name_list", "casesymlist", "extern_name_list", "@4",
+  "extern_name_list_body", "script_file", "@5", "ifile_list", "ifile_p1",
+  "@6", "@7", "input_list", "@8", "@9", "@10", "sections",
+  "sec_or_group_p1", "statement_anywhere", "@11", "wildcard_name",
+  "wildcard_spec", "exclude_name_list", "file_NAME_list",
+  "input_section_spec_no_keep", "input_section_spec", "@12", "statement",
+  "@13", "statement_list", "statement_list_opt", "length", "fill_exp",
+  "fill_opt", "assign_op", "end", "assignment", "opt_comma", "memory",
+  "memory_spec_list", "memory_spec", "@14", "origin_spec", "length_spec",
+  "attributes_opt", "attributes_list", "attributes_string", "startup",
+  "high_level_library", "high_level_library_NAME_list",
+  "low_level_library", "low_level_library_NAME_list",
+  "floating_point_support", "nocrossref_list", "mustbe_exp", "@15", "exp",
+  "memspec_at_opt", "opt_at", "opt_align", "opt_subalign",
+  "sect_constraint", "section", "@16", "@17", "@18", "@19", "@20", "@21",
+  "@22", "@23", "@24", "@25", "@26", "@27", "type", "atype",
+  "opt_exp_with_type", "opt_exp_without_type", "opt_nocrossrefs",
+  "memspec_opt", "phdr_opt", "overlay_section", "@28", "@29", "@30",
+  "phdrs", "phdr_list", "phdr", "@31", "@32", "phdr_type",
+  "phdr_qualifiers", "phdr_val", "dynamic_list_file", "@33",
+  "dynamic_list_nodes", "dynamic_list_node", "dynamic_list_tag",
+  "version_script_file", "@34", "version", "@35", "vers_nodes",
+  "vers_node", "verdep", "vers_tag", "vers_defns", "@36", "@37",
+  "opt_semicolon", 0
 };
 #endif
 
 # ifdef YYPRINT
 /* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
    token YYLEX-NUM.  */
-static const yytype_uint16 yytoknum[] =
+static const unsigned short int yytoknum[] =
 {
        0,   256,   257,   258,   259,   260,    61,   261,   262,   263,
      264,   265,   266,   267,   268,    63,    58,   269,   270,   124,
@@ -974,53 +904,53 @@
      339,   340,   341,   342,   343,   344,   345,   346,   347,   348,
      349,   350,   351,   352,   353,   354,   355,   356,   357,   358,
      359,   360,   361,   362,   363,   364,   365,   366,   367,   368,
-     369,   370,   371,   372,   373,   374,    44,    59,    41,    91,
-      93,    33,   126
+     369,   370,   371,   372,   373,   374,   375,   376,    44,    59,
+      41,    91,    93,    33,   126
 };
 # endif
 
 /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const yytype_uint16 yyr1[] =
+static const unsigned short int yyr1[] =
 {
-       0,   143,   144,   144,   144,   144,   144,   145,   147,   146,
-     149,   148,   150,   150,   151,   151,   151,   151,   151,   151,
-     151,   151,   151,   151,   151,   151,   151,   151,   151,   151,
-     151,   151,   151,   151,   151,   151,   151,   151,   151,   151,
-     152,   151,   151,   151,   153,   153,   153,   154,   154,   155,
-     155,   156,   156,   156,   158,   157,   159,   159,   159,   161,
-     160,   162,   162,   163,   163,   163,   163,   163,   163,   163,
-     163,   163,   163,   163,   163,   163,   163,   163,   163,   163,
-     163,   163,   164,   163,   163,   165,   163,   163,   163,   166,
-     166,   166,   166,   166,   166,   167,   166,   168,   166,   169,
-     166,   170,   171,   171,   171,   172,   172,   173,   172,   174,
-     174,   174,   175,   175,   175,   175,   175,   175,   175,   175,
-     175,   176,   176,   177,   177,   178,   178,   178,   179,   180,
-     179,   181,   181,   181,   181,   181,   181,   181,   181,   182,
-     181,   183,   183,   184,   184,   185,   185,   185,   185,   185,
-     186,   187,   187,   188,   188,   188,   188,   188,   188,   188,
-     188,   189,   189,   190,   190,   190,   190,   191,   191,   192,
-     193,   193,   193,   195,   194,   196,   197,   198,   198,   199,
-     199,   200,   200,   201,   202,   202,   203,   203,   204,   205,
-     205,   206,   206,   207,   207,   207,   209,   208,   210,   210,
-     210,   210,   210,   210,   210,   210,   210,   210,   210,   210,
-     210,   210,   210,   210,   210,   210,   210,   210,   210,   210,
-     210,   210,   210,   210,   210,   210,   210,   210,   210,   210,
-     210,   210,   210,   210,   210,   210,   210,   210,   210,   210,
-     210,   210,   210,   210,   210,   211,   211,   212,   212,   213,
-     213,   214,   214,   215,   215,   215,   215,   217,   218,   219,
-     220,   221,   216,   222,   223,   224,   225,   226,   216,   227,
-     228,   216,   229,   229,   229,   229,   229,   230,   230,   230,
-     231,   231,   231,   231,   232,   232,   233,   233,   234,   234,
-     235,   235,   236,   237,   238,   239,   236,   240,   241,   241,
-     243,   244,   242,   245,   246,   246,   246,   247,   247,   249,
-     248,   250,   250,   251,   252,   254,   253,   256,   255,   257,
-     257,   258,   258,   258,   259,   259,   260,   260,   260,   260,
-     260,   261,   261,   261,   261,   262,   261,   263,   261,   261,
-     261,   261,   261,   261,   261,   264,   264
+       0,   145,   146,   146,   146,   146,   146,   147,   149,   148,
+     151,   150,   152,   152,   153,   153,   153,   153,   153,   153,
+     153,   153,   153,   153,   153,   153,   153,   153,   153,   153,
+     153,   153,   153,   153,   153,   153,   153,   153,   153,   153,
+     154,   153,   153,   153,   155,   155,   155,   156,   156,   157,
+     157,   158,   158,   158,   160,   159,   161,   161,   161,   163,
+     162,   164,   164,   165,   165,   165,   165,   165,   165,   165,
+     165,   165,   165,   165,   165,   165,   165,   165,   165,   165,
+     165,   165,   166,   165,   165,   167,   165,   165,   165,   168,
+     168,   168,   168,   168,   168,   169,   168,   170,   168,   171,
+     168,   172,   173,   173,   173,   174,   174,   175,   174,   176,
+     176,   176,   177,   177,   177,   177,   177,   177,   177,   177,
+     177,   178,   178,   179,   179,   180,   180,   180,   181,   182,
+     181,   183,   183,   183,   183,   183,   183,   183,   183,   184,
+     183,   185,   185,   186,   186,   187,   187,   187,   187,   187,
+     188,   189,   189,   190,   190,   190,   190,   190,   190,   190,
+     190,   191,   191,   192,   192,   192,   192,   193,   193,   194,
+     195,   195,   195,   197,   196,   198,   199,   200,   200,   201,
+     201,   202,   202,   203,   204,   204,   205,   205,   206,   207,
+     207,   208,   208,   209,   209,   209,   211,   210,   212,   212,
+     212,   212,   212,   212,   212,   212,   212,   212,   212,   212,
+     212,   212,   212,   212,   212,   212,   212,   212,   212,   212,
+     212,   212,   212,   212,   212,   212,   212,   212,   212,   212,
+     212,   212,   212,   212,   212,   212,   212,   212,   212,   212,
+     212,   212,   212,   212,   212,   212,   212,   213,   213,   214,
+     214,   215,   215,   216,   216,   217,   217,   217,   217,   219,
+     220,   221,   222,   223,   218,   224,   225,   226,   227,   228,
+     218,   229,   230,   218,   231,   231,   231,   231,   231,   232,
+     232,   232,   233,   233,   233,   233,   234,   234,   235,   235,
+     236,   236,   237,   237,   238,   239,   240,   241,   238,   242,
+     243,   243,   245,   246,   244,   247,   248,   248,   248,   249,
+     249,   251,   250,   252,   252,   253,   254,   256,   255,   258,
+     257,   259,   259,   260,   260,   260,   261,   261,   262,   262,
+     262,   262,   262,   263,   263,   263,   263,   264,   263,   265,
+     263,   263,   263,   263,   263,   263,   263,   266,   266
 };
 
 /* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const yytype_uint8 yyr2[] =
+static const unsigned char yyr2[] =
 {
        0,     2,     2,     2,     2,     2,     2,     1,     0,     4,
        0,     2,     3,     0,     2,     4,     1,     1,     2,     1,
@@ -1046,652 +976,667 @@
        3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
        5,     3,     3,     4,     1,     1,     4,     4,     4,     4,
        4,     4,     4,     6,     6,     6,     4,     6,     4,     1,
-       6,     6,     6,     4,     4,     3,     0,     4,     0,     4,
-       0,     4,     0,     1,     1,     1,     0,     0,     0,     0,
-       0,     0,    19,     0,     0,     0,     0,     0,    18,     0,
-       0,     7,     1,     1,     1,     1,     1,     3,     0,     2,
-       3,     2,     6,    10,     2,     1,     0,     1,     2,     0,
-       0,     3,     0,     0,     0,     0,    11,     4,     0,     2,
-       0,     0,     6,     1,     0,     3,     5,     0,     3,     0,
-       2,     1,     2,     4,     2,     0,     2,     0,     5,     1,
-       2,     4,     5,     6,     1,     2,     0,     2,     4,     4,
-       8,     1,     1,     3,     3,     0,     9,     0,     7,     1,
-       3,     1,     3,     1,     3,     0,     1
+       6,     6,     4,     4,     6,     4,     4,     3,     0,     4,
+       0,     4,     0,     4,     0,     1,     1,     1,     0,     0,
+       0,     0,     0,     0,    19,     0,     0,     0,     0,     0,
+      18,     0,     0,     7,     1,     1,     1,     1,     1,     3,
+       0,     2,     3,     2,     6,    10,     2,     1,     0,     1,
+       2,     0,     0,     3,     0,     0,     0,     0,    11,     4,
+       0,     2,     0,     0,     6,     1,     0,     3,     5,     0,
+       3,     0,     2,     1,     2,     4,     2,     0,     2,     0,
+       5,     1,     2,     4,     5,     6,     1,     2,     0,     2,
+       4,     4,     8,     1,     1,     3,     3,     0,     9,     0,
+       7,     1,     3,     1,     3,     1,     3,     0,     1
 };
 
 /* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
    STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
    means the default is an error.  */
-static const yytype_uint16 yydefact[] =
+static const unsigned short int yydefact[] =
 {
-       0,    59,    10,     8,   315,   309,     0,     2,    62,     3,
+       0,    59,    10,     8,   317,   311,     0,     2,    62,     3,
       13,     6,     0,     4,     0,     5,     0,     1,    60,    11,
-       0,   326,     0,   316,   319,     0,   310,   311,     0,     0,
+       0,   328,     0,   318,   321,     0,   312,   313,     0,     0,
        0,     0,    79,     0,    80,     0,     0,     0,     0,     0,
        0,     0,     0,     0,   191,   192,     0,     0,    82,     0,
        0,     0,   107,     0,    72,    61,    64,    70,     0,    63,
       66,    67,    68,    69,    65,    71,     0,    16,     0,     0,
        0,     0,    17,     0,     0,     0,    19,    46,     0,     0,
-       0,     0,     0,     0,    51,    54,     0,     0,     0,   332,
-     343,   331,   339,   341,     0,     0,   326,   320,   339,   341,
-       0,     0,   312,   196,   160,   159,   158,   157,   156,   155,
-     154,   153,   196,   104,   298,     0,     0,     7,    85,     0,
+       0,     0,     0,     0,    51,    54,     0,     0,     0,   334,
+     345,   333,   341,   343,     0,     0,   328,   322,   341,   343,
+       0,     0,   314,   196,   160,   159,   158,   157,   156,   155,
+     154,   153,   196,   104,   300,     0,     0,     7,    85,     0,
        0,     0,     0,     0,     0,     0,   190,   193,     0,     0,
        0,     0,     0,     0,    54,   162,   161,   106,     0,     0,
       40,     0,   224,   239,     0,     0,     0,     0,     0,     0,
        0,     0,   225,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,    14,
-       0,    49,    31,    47,    32,    18,    33,    23,     0,    36,
-       0,    37,    52,    38,    39,     0,    42,    12,     9,     0,
-       0,     0,     0,   327,     0,     0,   314,   163,     0,   164,
-       0,     0,     0,     0,    62,   173,   172,     0,     0,     0,
-       0,     0,   185,   187,   168,   168,   193,     0,    89,    92,
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,    13,     0,     0,   202,   198,     0,     0,     0,     0,
+       0,    14,     0,    49,    31,    47,    32,    18,    33,    23,
+       0,    36,     0,    37,    52,    38,    39,     0,    42,    12,
+       9,     0,     0,     0,     0,   329,     0,     0,   316,   163,
+       0,   164,     0,     0,     0,     0,    62,   173,   172,     0,
+       0,     0,     0,     0,   185,   187,   168,   168,   193,     0,
+      89,    92,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,    13,     0,     0,   202,   198,     0,     0,
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,   201,   203,     0,     0,
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+     201,   203,     0,     0,     0,     0,     0,     0,     0,     0,
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-      25,     0,     0,    45,     0,     0,     0,    22,     0,     0,
-      56,    55,   337,     0,     0,   321,   334,   344,   333,   340,
-     342,     0,   313,   197,   257,   101,   263,   269,   103,   102,
-     300,   297,   299,     0,    76,    78,   317,   177,     0,    73,
-      74,    84,   105,   183,   167,   184,     0,   188,     0,   193,
-     194,    87,    95,    91,    94,     0,     0,    81,     0,    75,
-     196,   196,     0,    88,     0,    27,    28,    43,    29,    30,
-     199,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,    25,     0,     0,    45,     0,     0,
+       0,    22,     0,     0,    56,    55,   339,     0,     0,   323,
+     336,   346,   335,   342,   344,     0,   315,   197,   259,   101,
+     265,   271,   103,   102,   302,   299,   301,     0,    76,    78,
+     319,   177,     0,    73,    74,    84,   105,   183,   167,   184,
+       0,   188,     0,   193,   194,    87,    95,    91,    94,     0,
+       0,    81,     0,    75,   196,   196,     0,    88,     0,    27,
+      28,    43,    29,    30,   199,     0,     0,     0,     0,     0,
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,   222,   221,   219,   218,   217,   212,   211,   215,   216,
-     214,   213,   210,   209,   207,   208,   204,   205,   206,    15,
-      26,    24,    50,    48,    44,    20,    21,    35,    34,    53,
-      57,     0,     0,   328,   329,     0,   324,   322,     0,   278,
-       0,   278,     0,     0,    86,     0,     0,   169,     0,   170,
-     186,   189,   195,     0,    99,    90,    93,     0,    83,     0,
-       0,     0,   318,    41,     0,   232,   238,     0,     0,   236,
-       0,   223,   200,   227,   226,   228,   229,     0,     0,   243,
-     244,   231,     0,   230,     0,    58,   345,   342,   335,   325,
-     323,     0,     0,   278,     0,   248,   285,     0,   286,   270,
-     303,   304,     0,   181,     0,     0,   179,     0,   171,     0,
-       0,    97,   165,   166,     0,     0,     0,     0,     0,     0,
-       0,     0,   220,   346,     0,     0,     0,   272,   273,   274,
-     275,   276,   279,     0,     0,     0,     0,   281,     0,   250,
-     284,   287,   248,     0,   307,     0,   301,     0,   182,   178,
-     180,     0,   168,    96,     0,     0,   108,   233,   234,   235,
-     237,   240,   241,   242,   338,     0,   345,   277,     0,   280,
-       0,     0,   252,   252,   104,     0,   304,     0,     0,    77,
-     196,     0,   100,     0,   330,     0,   278,     0,     0,     0,
-     258,   264,     0,     0,   305,     0,   302,   175,     0,   174,
-      98,   336,     0,     0,   247,     0,     0,   256,     0,   271,
-     308,   304,   196,     0,   282,   249,     0,   253,   254,   255,
-       0,   265,   306,   176,     0,   251,   259,   292,   278,   143,
-       0,     0,   125,   111,   110,   145,   146,   147,   148,   149,
-       0,     0,     0,   132,   134,   139,     0,     0,   133,     0,
-     112,     0,   128,   136,   142,   144,     0,     0,     0,   293,
-     266,   283,     0,     0,   196,     0,   129,     0,   109,     0,
-     124,   168,     0,   141,   260,   196,   131,     0,   289,     0,
-       0,     0,     0,     0,     0,     0,     0,     0,   150,     0,
-       0,   122,     0,     0,   126,     0,   168,   289,     0,   143,
-       0,   246,     0,     0,   135,     0,   114,     0,     0,   115,
-     138,     0,   109,     0,     0,   121,   123,   127,   246,   137,
-       0,   288,     0,   290,     0,     0,     0,     0,     0,     0,
-     130,   113,   290,   294,     0,   152,     0,     0,     0,     0,
-       0,     0,   152,   290,   245,   196,     0,   267,   117,   116,
-       0,   118,   119,     0,   261,   152,   151,   291,   168,   120,
-     140,   168,   295,   268,   262,   168,   296
+       0,     0,     0,     0,     0,     0,     0,   222,   221,   219,
+     218,   217,   212,   211,   215,   216,   214,   213,   210,   209,
+     207,   208,   204,   205,   206,    15,    26,    24,    50,    48,
+      44,    20,    21,    35,    34,    53,    57,     0,     0,   330,
+     331,     0,   326,   324,     0,   280,     0,   280,     0,     0,
+      86,     0,     0,   169,     0,   170,   186,   189,   195,     0,
+      99,    90,    93,     0,    83,     0,     0,     0,   320,    41,
+       0,   232,   238,     0,     0,   236,     0,   223,   200,   227,
+     226,   228,   229,     0,     0,   242,   243,   245,   246,   231,
+       0,   230,     0,    58,   347,   344,   337,   327,   325,     0,
+       0,   280,     0,   250,   287,     0,   288,   272,   305,   306,
+       0,   181,     0,     0,   179,     0,   171,     0,     0,    97,
+     165,   166,     0,     0,     0,     0,     0,     0,     0,     0,
+     220,   348,     0,     0,     0,   274,   275,   276,   277,   278,
+     281,     0,     0,     0,     0,   283,     0,   252,   286,   289,
+     250,     0,   309,     0,   303,     0,   182,   178,   180,     0,
+     168,    96,     0,     0,   108,   233,   234,   235,   237,   240,
+     241,   244,   340,     0,   347,   279,     0,   282,     0,     0,
+     254,   254,   104,     0,   306,     0,     0,    77,   196,     0,
+     100,     0,   332,     0,   280,     0,     0,     0,   260,   266,
+       0,     0,   307,     0,   304,   175,     0,   174,    98,   338,
+       0,     0,   249,     0,     0,   258,     0,   273,   310,   306,
+     196,     0,   284,   251,     0,   255,   256,   257,     0,   267,
+     308,   176,     0,   253,   261,   294,   280,   143,     0,     0,
+     125,   111,   110,   145,   146,   147,   148,   149,     0,     0,
+       0,   132,   134,   139,     0,     0,   133,     0,   112,     0,
+     128,   136,   142,   144,     0,     0,     0,   295,   268,   285,
+       0,     0,   196,     0,   129,     0,   109,     0,   124,   168,
+       0,   141,   262,   196,   131,     0,   291,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,   150,     0,     0,   122,
+       0,     0,   126,     0,   168,   291,     0,   143,     0,   248,
+       0,     0,   135,     0,   114,     0,     0,   115,   138,     0,
+     109,     0,     0,   121,   123,   127,   248,   137,     0,   290,
+       0,   292,     0,     0,     0,     0,     0,     0,   130,   113,
+     292,   296,     0,   152,     0,     0,     0,     0,     0,     0,
+     152,   292,   247,   196,     0,   269,   117,   116,     0,   118,
+     119,     0,   263,   152,   151,   293,   168,   120,   140,   168,
+     297,   270,   264,   168,   298
 };
 
-/* YYDEFGOTO[NTERM-NUM].  */
-static const yytype_int16 yydefgoto[] =
+/* YYDEFGOTO[NTERM-NUM]. */
+static const short int yydefgoto[] =
 {
-      -1,     6,   118,    11,    12,     9,    10,    19,    87,   231,
-     175,   174,   172,   183,   184,   185,   291,     7,     8,    18,
-      55,   129,   204,   221,   423,   525,   480,    56,   200,    57,
-     133,   620,   621,   662,   641,   622,   623,   660,   624,   635,
-     625,   626,   627,   657,   717,   112,   137,    58,   665,    59,
-     318,   206,   317,   522,   569,   416,   475,   476,    60,    61,
-     214,    62,   215,    63,   217,   658,   198,   236,   693,   509,
-     542,   560,   590,   309,   409,   577,   599,   667,   731,   410,
-     578,   597,   648,   728,   411,   513,   503,   464,   465,   468,
-     512,   671,   705,   600,   647,   713,   735,    64,   201,   312,
-     412,   548,   471,   516,   546,    15,    16,    26,    27,   100,
-      13,    14,    65,    66,    23,    24,   408,    94,    95,   496,
-     402,   494
+      -1,     6,   118,    11,    12,     9,    10,    19,    87,   233,
+     177,   176,   174,   185,   186,   187,   295,     7,     8,    18,
+      55,   129,   206,   223,   429,   533,   488,    56,   202,    57,
+     133,   628,   629,   670,   649,   630,   631,   668,   632,   643,
+     633,   634,   635,   665,   725,   112,   137,    58,   673,    59,
+     322,   208,   321,   530,   577,   422,   483,   484,    60,    61,
+     216,    62,   217,    63,   219,   666,   200,   238,   701,   517,
+     550,   568,   598,   313,   415,   585,   607,   675,   739,   416,
+     586,   605,   656,   736,   417,   521,   511,   472,   473,   476,
+     520,   679,   713,   608,   655,   721,   743,    64,   203,   316,
+     418,   556,   479,   524,   554,    15,    16,    26,    27,   100,
+      13,    14,    65,    66,    23,    24,   414,    94,    95,   504,
+     408,   502
 };
 
 /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
    STATE-NUM.  */
-#define YYPACT_NINF -675
-static const yytype_int16 yypact[] =
+#define YYPACT_NINF -673
+static const short int yypact[] =
 {
-     293,  -675,  -675,  -675,  -675,  -675,    42,  -675,  -675,  -675,
-    -675,  -675,    46,  -675,   -18,  -675,    14,  -675,   736,  1472,
-      65,   104,    51,   -18,  -675,   206,    14,  -675,   445,    57,
-      63,    40,  -675,    86,  -675,   124,   119,   139,   140,   144,
-     189,   190,   196,   204,  -675,  -675,   209,   220,  -675,   223,
-     231,   236,  -675,   238,  -675,  -675,  -675,  -675,    -4,  -675,
-    -675,  -675,  -675,  -675,  -675,  -675,   153,  -675,   147,   124,
-     277,   613,  -675,   279,   280,   283,  -675,  -675,   285,   294,
-     296,   613,   298,   301,   302,  -675,   303,   205,   613,  -675,
-     305,  -675,   307,   308,   259,   180,   104,  -675,  -675,  -675,
-     264,   184,  -675,  -675,  -675,  -675,  -675,  -675,  -675,  -675,
-    -675,  -675,  -675,  -675,  -675,   321,   324,  -675,  -675,   331,
-     333,   124,   124,   338,   124,    16,  -675,   339,    20,   309,
-     124,   346,   348,   317,  -675,  -675,  -675,  -675,   311,    28,
-    -675,    35,  -675,  -675,   613,   613,   613,   320,   325,   328,
-     344,   345,  -675,   347,   350,   351,   355,   356,   357,   358,
-     363,   368,   369,   370,   371,   376,   395,   613,   613,  1295,
-     217,  -675,   225,  -675,   295,    10,  -675,  -675,   341,  1667,
-     299,  -675,  -675,   300,  -675,   381,  -675,  -675,  1667,   390,
-     206,   206,   310,   249,   380,   323,   249,  -675,   613,  -675,
-     394,    22,   -25,   326,  -675,  -675,  -675,   327,   329,   330,
-     332,   334,  -675,  -675,    73,   100,    11,   335,  -675,  -675,
-     408,    27,    20,   362,   440,   465,   613,   364,   -18,   613,
-     613,  -675,   613,   613,  -675,  -675,   929,   613,   613,   613,
-     613,   613,   480,   482,   613,   484,   489,   490,   491,   613,
-     613,   497,   500,   613,   613,   502,  -675,  -675,   613,   613,
-     613,   613,   613,   613,   613,   613,   613,   613,   613,   613,
-     613,   613,   613,   613,   613,   613,   613,   613,   613,   613,
-    1667,   506,   507,  -675,   511,   613,   613,  1667,   136,   512,
-    -675,    24,  -675,   384,   385,  -675,  -675,   514,  -675,  -675,
-    -675,   -75,  -675,  1667,   445,  -675,  -675,  -675,  -675,  -675,
-    -675,  -675,  -675,   519,  -675,  -675,   808,   488,    98,  -675,
-    -675,  -675,  -675,  -675,  -675,  -675,   124,  -675,   124,   339,
-    -675,  -675,  -675,  -675,  -675,   492,    32,  -675,    81,  -675,
-    -675,  -675,  1315,  -675,   -14,  1667,  1667,  1496,  1667,  1667,
-    -675,   745,   949,  1335,  1355,   969,   406,   388,   989,   393,
-     405,   410,   411,  1375,  1395,   412,   413,  1009,  1415,   422,
-    1627,  1494,  1516,  1682,   909,   701,   894,   894,   525,   525,
-     525,   525,   392,   392,   152,   152,  -675,  -675,  -675,  1667,
-    1667,  1667,  -675,  -675,  -675,  1667,  1667,  -675,  -675,  -675,
-    -675,   526,   206,   278,   249,   508,  -675,  -675,   -68,   459,
-     536,   459,   613,   427,  -675,     4,   548,  -675,   331,  -675,
-    -675,  -675,  -675,    20,  -675,  -675,  -675,   532,  -675,   432,
-     438,   573,  -675,  -675,   613,  -675,  -675,   613,   613,  -675,
-     613,  -675,  -675,  -675,  -675,  -675,  -675,   613,   613,  -675,
-    -675,  -675,   574,  -675,   613,  -675,   442,   564,  -675,  -675,
-    -675,    15,   544,  1604,   566,   503,  -675,  1647,   510,  -675,
-    1667,    25,   583,  -675,   588,     3,  -675,   513,  -675,   125,
-      20,  -675,  -675,  -675,   464,  1029,  1051,  1071,  1091,  1111,
-    1131,   467,  1667,   249,   543,   206,   206,  -675,  -675,  -675,
-    -675,  -675,  -675,   468,   613,   375,   587,  -675,   570,   580,
-    -675,  -675,   503,   555,   584,   586,  -675,   487,  -675,  -675,
-    -675,   620,   495,  -675,   133,    20,  -675,  -675,  -675,  -675,
-    -675,  -675,  -675,  -675,  -675,   496,   442,  -675,  1151,  -675,
-     613,   590,   540,   540,  -675,   613,    25,   613,   501,  -675,
-    -675,   549,  -675,   138,   249,   592,   212,  1173,   613,   591,
-    -675,  -675,   474,  1193,  -675,  1213,  -675,  -675,   634,  -675,
-    -675,  -675,   605,   631,  -675,  1233,   613,   113,   595,  -675,
-    -675,    25,  -675,   613,  -675,  -675,  1253,  -675,  -675,  -675,
-     596,  -675,  -675,  -675,  1273,  -675,  -675,  -675,   617,   652,
-      68,   639,   699,  -675,  -675,  -675,  -675,  -675,  -675,  -675,
-     621,   622,   623,  -675,  -675,  -675,   627,   629,  -675,   227,
-    -675,   632,  -675,  -675,  -675,   652,   603,   635,    -4,  -675,
-    -675,  -675,   304,   282,  -675,   637,  -675,   284,  -675,   638,
-    -675,   -93,   227,  -675,  -675,  -675,  -675,   618,   651,   642,
-     643,   545,   645,   547,   661,   663,   576,   577,  -675,   613,
-      83,  -675,    12,   297,  -675,   227,   114,   651,   579,   652,
-     698,   624,   284,   284,  -675,   284,  -675,   284,   284,  -675,
-    -675,  1435,   582,   599,   284,  -675,  -675,  -675,   624,  -675,
-     664,  -675,   696,  -675,   600,   604,    80,   606,   608,   739,
-    -675,  -675,  -675,  -675,   744,    43,   614,   615,   284,   619,
-     646,   648,    43,  -675,  -675,  -675,   747,  -675,  -675,  -675,
-     649,  -675,  -675,    -4,  -675,    43,  -675,  -675,   495,  -675,
-    -675,   495,  -675,  -675,  -675,   495,  -675
+     185,  -673,  -673,  -673,  -673,  -673,    43,  -673,  -673,  -673,
+    -673,  -673,    46,  -673,   -11,  -673,    19,  -673,   789,   875,
+      63,   119,    51,   -11,  -673,   128,    19,  -673,   884,    66,
+      71,   116,  -673,   176,  -673,   123,   125,   194,   201,   213,
+     220,   221,   226,   237,  -673,  -673,   249,   250,  -673,   251,
+     252,   254,  -673,   255,  -673,  -673,  -673,  -673,    96,  -673,
+    -673,  -673,  -673,  -673,  -673,  -673,   164,  -673,   304,   123,
+     305,   646,  -673,   309,   310,   312,  -673,  -673,   315,   316,
+     319,   646,   320,   322,   325,  -673,   328,   229,   646,  -673,
+     336,  -673,   326,   327,   287,   209,   119,  -673,  -673,  -673,
+     295,   218,  -673,  -673,  -673,  -673,  -673,  -673,  -673,  -673,
+    -673,  -673,  -673,  -673,  -673,   348,   352,  -673,  -673,   357,
+     363,   123,   123,   367,   123,    22,  -673,   372,    20,   343,
+     123,   383,   384,   353,  -673,  -673,  -673,  -673,   340,    28,
+    -673,    41,  -673,  -673,   646,   646,   646,   362,   364,   368,
+     369,   376,  -673,   379,   382,   393,   394,   395,   397,   399,
+     402,   403,   406,   407,   408,   409,   411,   412,   413,   646,
+     646,  1378,   222,  -673,   256,  -673,   262,    35,  -673,  -673,
+     347,  1622,   265,  -673,  -673,   313,  -673,   385,  -673,  -673,
+    1622,   380,   128,   128,   314,   211,   401,   317,   211,  -673,
+     646,  -673,   375,    33,    -3,   324,  -673,  -673,  -673,   329,
+     333,   338,   339,   341,  -673,  -673,    76,    89,    36,   354,
+    -673,  -673,   428,    16,    20,   356,   460,   470,   646,   361,
+     -11,   646,   646,  -673,   646,   646,  -673,  -673,   798,   646,
+     646,   646,   646,   646,   476,   488,   646,   498,   499,   504,
+     505,   646,   646,   646,   646,   506,   508,   646,   646,   510,
+    -673,  -673,   646,   646,   646,   646,   646,   646,   646,   646,
+     646,   646,   646,   646,   646,   646,   646,   646,   646,   646,
+     646,   646,   646,   646,  1622,   514,   515,  -673,   517,   646,
+     646,  1622,   138,   520,  -673,    47,  -673,   386,   389,  -673,
+    -673,   525,  -673,  -673,  -673,   -84,  -673,  1622,   884,  -673,
+    -673,  -673,  -673,  -673,  -673,  -673,  -673,   527,  -673,  -673,
+     863,   495,    82,  -673,  -673,  -673,  -673,  -673,  -673,  -673,
+     123,  -673,   123,   372,  -673,  -673,  -673,  -673,  -673,   496,
+      24,  -673,    27,  -673,  -673,  -673,  1398,  -673,   -18,  1622,
+    1622,  1571,  1622,  1622,  -673,   746,   986,  1418,  1438,  1006,
+     415,   398,  1026,   416,   418,   419,   429,  1458,  1500,  1046,
+    1066,   433,   434,  1086,  1520,   435,  1681,  1559,  1480,  1716,
+     637,  1729,  1740,  1740,   600,   600,   600,   600,   378,   378,
+     156,   156,  -673,  -673,  -673,  1622,  1622,  1622,  -673,  -673,
+    -673,  1622,  1622,  -673,  -673,  -673,  -673,   530,   128,   236,
+     211,   484,  -673,  -673,   -28,   467,   567,   467,   646,   438,
+    -673,     4,   523,  -673,   357,  -673,  -673,  -673,  -673,    20,
+    -673,  -673,  -673,   540,  -673,   441,   442,   547,  -673,  -673,
+     646,  -673,  -673,   646,   646,  -673,   646,  -673,  -673,  -673,
+    -673,  -673,  -673,   646,   646,  -673,  -673,  -673,  -673,  -673,
+     580,  -673,   646,  -673,   446,   570,  -673,  -673,  -673,    15,
+     550,  1593,   572,   502,  -673,  1701,   513,  -673,  1622,    18,
+     589,  -673,   598,     3,  -673,   519,  -673,   129,    20,  -673,
+    -673,  -673,   468,  1110,  1130,  1150,  1170,  1190,  1210,   469,
+    1622,   211,   558,   128,   128,  -673,  -673,  -673,  -673,  -673,
+    -673,   474,   646,   396,   602,  -673,   582,   583,  -673,  -673,
+     502,   571,   586,   599,  -673,   480,  -673,  -673,  -673,   620,
+     500,  -673,   135,    20,  -673,  -673,  -673,  -673,  -673,  -673,
+    -673,  -673,  -673,   512,   446,  -673,  1234,  -673,   646,   615,
+     539,   539,  -673,   646,    18,   646,   534,  -673,  -673,   549,
+    -673,   140,   211,   621,   225,  1254,   646,   616,  -673,  -673,
+     400,  1274,  -673,  1294,  -673,  -673,   648,  -673,  -673,  -673,
+     619,   658,  -673,  1314,   646,    90,   626,  -673,  -673,    18,
+    -673,   646,  -673,  -673,  1334,  -673,  -673,  -673,   627,  -673,
+    -673,  -673,  1358,  -673,  -673,  -673,   644,   703,    58,   666,
+     554,  -673,  -673,  -673,  -673,  -673,  -673,  -673,   649,   650,
+     651,  -673,  -673,  -673,   652,   653,  -673,   279,  -673,   654,
+    -673,  -673,  -673,   703,   638,   656,    96,  -673,  -673,  -673,
+     233,   366,  -673,   660,  -673,   217,  -673,   661,  -673,   -20,
+     279,  -673,  -673,  -673,  -673,   647,   674,   665,   667,   565,
+     671,   569,   675,   676,   575,   576,  -673,   646,    98,  -673,
+      12,   303,  -673,   279,   141,   674,   577,   703,   724,   632,
+     217,   217,  -673,   217,  -673,   217,   217,  -673,  -673,  1540,
+     590,   591,   217,  -673,  -673,  -673,   632,  -673,   678,  -673,
+     708,  -673,   597,   601,    44,   603,   609,   734,  -673,  -673,
+    -673,  -673,   735,    61,   610,   612,   217,   613,   618,   622,
+      61,  -673,  -673,  -673,   736,  -673,  -673,  -673,   641,  -673,
+    -673,    96,  -673,    61,  -673,  -673,   500,  -673,  -673,   500,
+    -673,  -673,  -673,   500,  -673
 };
 
 /* YYPGOTO[NTERM-NUM].  */
-static const yytype_int16 yypgoto[] =
+static const short int yypgoto[] =
 {
-    -675,  -675,   -64,  -675,  -675,  -675,  -675,   527,  -675,  -675,
-    -675,  -675,  -675,  -675,   625,  -675,  -675,  -675,  -675,   552,
-    -675,  -675,  -675,  -210,  -675,  -675,  -675,  -675,   244,  -194,
-    -675,   -43,  -407,   105,   148,   141,  -675,  -675,   171,  -675,
-    -675,   130,  -675,    85,  -674,  -675,  -606,  -569,  -211,  -675,
-    -675,  -297,  -675,  -675,  -675,  -675,  -675,   336,  -675,  -675,
-    -675,  -675,  -675,  -675,  -193,  -101,  -675,   -71,   115,   290,
-    -675,   261,  -675,  -675,  -675,  -675,  -675,  -675,  -675,  -675,
-    -675,  -675,  -675,  -675,  -675,  -675,  -675,  -450,   398,  -675,
-    -675,   143,  -588,  -675,  -675,  -675,  -675,  -675,  -675,  -675,
-    -675,  -675,  -675,  -513,  -675,  -675,  -675,  -675,   787,  -675,
-    -675,  -675,  -675,  -675,   594,   -22,  -675,   718,   -16,  -675,
-    -675,   287
+    -673,  -673,   -64,  -673,  -673,  -673,  -673,   509,  -673,  -673,
+    -673,  -673,  -673,  -673,   625,  -673,  -673,  -673,  -673,   578,
+    -673,  -673,  -673,  -212,  -673,  -673,  -673,  -673,   204,  -196,
+    -673,   -91,  -542,    77,   133,   117,  -673,  -673,   153,  -673,
+    -673,   110,  -673,    65,  -649,  -673,  -621,  -577,  -213,  -673,
+    -673,  -308,  -673,  -673,  -673,  -673,  -673,   308,  -673,  -673,
+    -673,  -673,  -673,  -673,  -195,  -101,  -673,   -71,    99,   276,
+    -673,   246,  -673,  -673,  -673,  -673,  -673,  -673,  -673,  -673,
+    -673,  -673,  -673,  -673,  -673,  -673,  -673,  -458,   387,  -673,
+    -673,   124,  -672,  -673,  -673,  -673,  -673,  -673,  -673,  -673,
+    -673,  -673,  -673,  -521,  -673,  -673,  -673,  -673,   774,  -673,
+    -673,  -673,  -673,  -673,   579,   -22,  -673,   705,   -16,  -673,
+    -673,   261
 };
 
 /* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
    positive, shift that token.  If negative, reduce the rule which
    number is the opposite.  If zero, do what YYDEFACT says.
    If YYTABLE_NINF, syntax error.  */
-#define YYTABLE_NINF -318
-static const yytype_int16 yytable[] =
+#define YYTABLE_NINF -320
+static const short int yytable[] =
 {
-     169,    97,   197,   326,   328,   140,   308,   473,   473,   101,
-     179,   199,   338,   506,   283,   216,   638,   188,   142,   143,
-     117,   419,   646,   330,   218,   219,   310,   603,   400,   514,
-     628,   333,   334,   564,   229,    21,   425,   426,   724,    21,
-     432,   232,    17,   324,   604,   144,   145,   664,   406,   715,
-      20,   732,   146,   147,   148,   459,   628,   208,   209,   716,
-     211,   213,   407,   149,   150,   151,   223,    25,   592,   460,
-     152,    88,   629,   234,   235,   153,   311,   115,   497,   498,
-     499,   500,   501,   154,   638,   333,   334,   682,   155,   156,
-     157,   158,   159,   160,   161,   603,   256,   257,   603,   280,
-     628,   162,   205,   163,    96,    22,   573,   287,    89,    22,
-     113,   313,   604,   314,   712,   604,   114,   730,   164,   220,
-     515,   478,   630,   116,   165,   725,   335,   303,   117,   333,
-     334,   427,   135,   136,   639,   611,   422,   333,   334,   397,
-     398,   519,   333,   334,   474,   474,   284,   329,   601,   166,
-     684,   139,   417,   502,   212,   342,   167,   168,   345,   346,
-     401,   348,   349,   336,   230,   337,   351,   352,   353,   354,
-     355,   233,   119,   358,   293,   294,   120,   121,   363,   364,
-     335,   122,   367,   368,   274,   275,   276,   370,   371,   372,
-     373,   374,   375,   376,   377,   378,   379,   380,   381,   382,
-     383,   384,   385,   386,   387,   388,   389,   390,   391,   324,
-      89,   325,   640,   479,   395,   396,   617,   336,   708,   428,
-     142,   143,   619,   278,   335,    90,   123,   124,    91,    92,
-      93,   638,   335,   125,   418,   640,   324,   335,   327,   429,
-     430,   126,   603,   587,   588,   589,   127,   144,   145,   505,
-     324,   572,   687,   296,   146,   147,   148,   128,   686,   604,
-     130,   336,   420,   523,   421,   149,   150,   151,   131,   336,
-     524,   552,   152,   132,   336,   134,   570,   153,   639,   611,
-     138,   141,   296,   170,   171,   154,   638,   173,   638,   176,
-     155,   156,   157,   158,   159,   160,   161,   603,   177,   603,
-     178,   638,   180,   162,   181,   163,   182,   186,   638,   189,
-     187,   551,   603,   192,   604,   553,   604,   193,   195,   603,
-     164,   196,    97,   190,   191,   202,   165,    90,   203,   604,
-      91,    98,    99,   654,   655,   205,   604,   207,   463,   467,
-     463,   470,   210,   216,   142,   143,   222,   285,   649,   650,
-     224,   166,   225,   279,   226,   649,   650,   237,   167,   168,
-     617,   281,   238,   485,   228,   239,   486,   487,   308,   488,
-     297,   144,   145,   298,   299,   300,   489,   490,   146,   147,
-     148,   240,   241,   492,   242,   290,   456,   243,   244,   149,
-     150,   151,   245,   246,   247,   248,   152,   651,   304,   297,
-     249,   153,   298,   299,   457,   250,   251,   252,   253,   154,
-       1,     2,     3,   254,   155,   156,   157,   158,   159,   160,
-     161,     4,   272,   273,   274,   275,   276,   162,     5,   163,
-     652,   282,   255,   538,   301,   288,   289,   652,   497,   498,
-     499,   500,   501,   292,   164,   332,   340,   295,   305,   567,
-     165,   103,   104,   105,   106,   107,   108,   109,   110,   111,
-     302,   306,   142,   143,   315,   319,    40,   320,   321,   557,
-     322,   341,   323,   331,   563,   166,   565,   286,   304,   535,
-     536,   593,   167,   168,   356,   307,   357,   575,   359,   144,
-     145,    50,    51,   360,   361,   362,   461,   147,   148,   462,
-     339,   365,   343,    52,   366,   586,   369,   149,   150,   151,
-     392,   393,   594,   502,   152,   394,   399,   733,   405,   153,
-     734,   403,   404,   413,   736,   415,   441,   154,   579,   424,
-     455,   443,   155,   156,   157,   158,   159,   160,   161,   142,
-     143,   306,   440,   444,   668,   162,    40,   163,   445,   446,
-     449,   450,   466,   270,   271,   272,   273,   274,   275,   276,
-     453,   458,   164,   472,   477,   307,   144,   145,   165,   481,
-     482,    50,    51,   146,   147,   148,   483,   484,   491,   493,
-     495,   504,   507,    52,   149,   150,   151,   517,   681,   653,
-     656,   152,   518,   166,   661,   511,   153,   534,   508,   521,
-     167,   168,   526,   539,   154,   533,   537,   540,   544,   155,
-     156,   157,   158,   159,   160,   161,   142,   143,   541,   685,
-     653,   545,   162,   547,   163,   549,   550,   558,   576,   694,
-     695,   324,   661,   554,   697,   698,   559,   568,   566,   164,
-     582,   701,   583,   144,   145,   165,   571,   584,   591,   596,
-     146,   147,   148,   685,   505,   631,   602,   644,   632,   633,
-     634,   149,   150,   151,   636,   720,   637,   603,   152,   642,
-     166,   669,   645,   153,   659,   663,   670,   167,   168,   672,
-     673,   154,   675,   674,   604,   676,   155,   156,   157,   158,
-     159,   160,   161,   605,   606,   607,   608,   609,   677,   162,
-     678,   163,   691,   610,   611,   103,   104,   105,   106,   107,
-     108,   109,   110,   111,   679,   680,   164,   689,   703,   692,
-    -125,   704,   165,   264,   265,   266,   267,   268,   269,   270,
-     271,   272,   273,   274,   275,   276,  -109,   700,   706,   612,
-      28,   613,   707,   711,   709,   614,   710,   166,   714,    50,
-      51,   727,   718,   719,   167,   168,   316,   721,   347,   227,
-     258,   615,   259,   260,   261,   262,   263,   264,   265,   266,
+     171,    97,   199,   330,   332,   140,   312,   481,   481,   101,
+     181,   201,   342,   514,   425,   654,   646,   190,   142,   143,
+     337,   338,   522,   334,   220,   221,   117,   611,   431,   432,
+     636,   337,   338,   572,   231,    21,   438,   314,   720,   287,
+     218,   412,    21,    17,   612,   144,   145,   234,   646,   733,
+      20,   406,   146,   147,   148,   413,   636,   210,   211,   611,
+     213,   215,   637,   149,   150,   151,   225,   723,   600,    88,
+     152,   732,    25,   236,   237,   153,   612,   724,   505,   506,
+     507,   508,   509,   154,   740,   648,   207,   315,   155,   156,
+     157,   158,   159,   160,   161,   162,   163,   467,   260,   261,
+     636,   284,   690,   164,    96,   165,   581,    22,   648,   291,
+     738,   468,   638,   611,    22,   523,   486,   339,   328,   113,
+     166,   222,   672,    89,   114,   433,   167,   117,   339,   307,
+     612,   694,    89,   337,   338,   317,   423,   318,   428,   337,
+     338,   403,   404,   527,   337,   338,   482,   482,   609,   647,
+     619,   168,   692,   115,   340,   510,   341,   346,   169,   170,
+     349,   350,   214,   352,   353,   340,   232,   434,   355,   356,
+     357,   358,   359,   288,   333,   362,   297,   298,   119,   235,
+     367,   368,   369,   370,   716,   407,   373,   374,   278,   279,
+     280,   376,   377,   378,   379,   380,   381,   382,   383,   384,
+     385,   386,   387,   388,   389,   390,   391,   392,   393,   394,
+     395,   396,   397,   116,   328,   300,   329,   487,   401,   402,
+     424,   646,   595,   596,   597,   142,   143,   328,   282,   331,
+     339,   120,   611,   625,   135,   136,   339,   646,   121,   627,
+     300,   339,    90,   435,   436,    91,    92,    93,   611,   612,
+     122,    90,   144,   145,    91,    98,    99,   123,   124,   146,
+     147,   148,   513,   125,   580,   612,   426,   340,   427,   531,
+     149,   150,   151,   340,   126,   560,   532,   152,   340,   328,
+     578,   695,   153,   646,   657,   658,   127,   128,   130,   131,
+     154,   132,   134,   138,   611,   155,   156,   157,   158,   159,
+     160,   161,   162,   163,     1,     2,     3,   646,   139,   141,
+     164,   612,   165,   172,   173,     4,   175,   559,   611,   178,
+     179,   561,     5,   180,   182,   183,    97,   166,   659,   184,
+     647,   619,   188,   167,   301,   612,   189,   302,   303,   304,
+     191,   194,   192,   193,   471,   475,   471,   478,   195,   197,
+     142,   143,   204,   289,   657,   658,   205,   198,   168,   301,
+     283,   207,   302,   303,   465,   169,   170,   209,   660,   493,
+     646,   212,   494,   495,   312,   496,   218,   144,   145,   308,
+     224,   611,   497,   498,   146,   147,   148,   226,   227,   294,
+     228,   500,   464,   230,   285,   149,   150,   151,   612,   239,
+     286,   240,   152,   292,   308,   241,   242,   153,   276,   277,
+     278,   279,   280,   243,   625,   154,   244,   662,   663,   245,
+     155,   156,   157,   158,   159,   160,   161,   162,   163,   309,
+     246,   247,   248,   296,   249,   164,   250,   165,   660,   251,
+     252,   546,   310,   253,   254,   255,   256,    40,   257,   258,
+     259,   293,   166,   299,   587,   305,   306,   575,   167,   505,
+     506,   507,   508,   509,   319,   336,   344,   310,   311,   323,
+     142,   143,    40,   324,    50,    51,   345,   565,   325,   326,
+     360,   327,   571,   168,   573,   290,    52,   543,   544,   601,
+     169,   170,   361,   311,   335,   583,   343,   144,   145,    50,
+      51,   347,   363,   364,   469,   147,   148,   470,   365,   366,
+     371,    52,   372,   594,   375,   149,   150,   151,   398,   399,
+     602,   400,   152,   741,   405,   409,   742,   153,   410,   411,
+     744,   419,   421,   430,   463,   154,   510,   466,   447,   485,
+     155,   156,   157,   158,   159,   160,   161,   162,   163,   661,
+     664,   492,   676,   446,   669,   164,   449,   165,   450,   451,
+     103,   104,   105,   106,   107,   108,   109,   110,   111,   452,
+     142,   143,   166,   457,   458,   461,   480,   489,   167,   693,
+     661,   490,   491,   474,   499,   501,   503,   512,   515,   702,
+     703,  -109,   669,   525,   705,   706,   689,   144,   145,   516,
+     519,   709,   526,   168,   146,   147,   148,   529,   534,   541,
+     169,   170,   542,   693,   545,   149,   150,   151,   547,   548,
+     557,   549,   152,   553,   552,   728,   558,   153,   274,   275,
+     276,   277,   278,   279,   280,   154,   555,   567,   328,   576,
+     155,   156,   157,   158,   159,   160,   161,   162,   163,   142,
+     143,   562,   566,   584,   590,   164,   591,   165,   267,   268,
+     269,   270,   271,   272,   273,   274,   275,   276,   277,   278,
+     279,   280,   166,   574,   592,   579,   144,   145,   167,   599,
+     604,   513,   639,   146,   147,   148,   640,   641,   642,   644,
+     645,   650,   652,   653,   149,   150,   151,   667,   671,   678,
+     677,   152,   680,   168,   681,   682,   153,   610,   683,   684,
+     169,   170,   685,   686,   154,   687,   688,   697,   611,   155,
+     156,   157,   158,   159,   160,   161,   162,   163,   699,   700,
+    -125,   708,   711,   712,   164,   612,   165,   714,   719,   722,
+     735,   715,   351,   717,   613,   614,   615,   616,   617,   718,
+     726,   166,   727,   729,   618,   619,   570,   167,   730,   229,
+     704,   262,   731,   263,   264,   265,   266,   267,   268,   269,
+     270,   271,   272,   273,   274,   275,   276,   277,   278,   279,
+     280,   737,   168,   674,   320,   691,   651,   698,   734,   169,
+     170,   528,   620,    28,   621,   710,   551,   569,   622,   696,
+     102,   196,    50,    51,   477,   563,     0,     0,     0,   348,
+       0,     0,     0,   262,   623,   263,   264,   265,   266,   267,
+     268,   269,   270,   271,   272,   273,   274,   275,   276,   277,
+     278,   279,   280,     0,   624,    29,    30,     0,   625,     0,
+       0,     0,   626,     0,   627,    31,    32,    33,    34,     0,
+      35,    36,     0,     0,     0,     0,     0,     0,    37,    38,
+      39,    40,     0,     0,     0,     0,     0,    28,     0,     0,
+       0,    41,    42,    43,    44,    45,    46,     0,     0,    67,
+       0,    47,    48,    49,   440,     0,   441,     0,    50,    51,
+     103,   104,   105,   106,   107,   108,   109,   110,   111,   420,
+      52,     0,     0,     0,     0,     0,     0,     0,     0,    29,
+      30,     0,    53,    68,     0,     0,     0,     0,  -319,    31,
+      32,    33,    34,     0,    35,    36,     0,     0,    54,     0,
+       0,     0,    37,    38,    39,    40,    69,     0,   354,     0,
+       0,     0,     0,     0,     0,    41,    42,    43,    44,    45,
+      46,     0,     0,     0,     0,    47,    48,    49,     0,     0,
+       0,     0,    50,    51,     0,     0,     0,     0,     0,     0,
+       0,    70,     0,     0,    52,     0,     0,    71,    72,    73,
+      74,    75,   -43,    76,    77,    78,    53,    79,    80,     0,
+      81,    82,    83,     0,     0,     0,     0,    84,    85,    86,
+       0,   262,    54,   263,   264,   265,   266,   267,   268,   269,
+     270,   271,   272,   273,   274,   275,   276,   277,   278,   279,
+     280,   262,     0,   263,   264,   265,   266,   267,   268,   269,
+     270,   271,   272,   273,   274,   275,   276,   277,   278,   279,
+     280,   262,     0,   263,   264,   265,   266,   267,   268,   269,
+     270,   271,   272,   273,   274,   275,   276,   277,   278,   279,
+     280,   262,     0,   263,   264,   265,   266,   267,   268,   269,
+     270,   271,   272,   273,   274,   275,   276,   277,   278,   279,
+     280,   262,     0,   263,   264,   265,   266,   267,   268,   269,
+     270,   271,   272,   273,   274,   275,   276,   277,   278,   279,
+     280,   262,     0,   263,   264,   265,   266,   267,   268,   269,
+     270,   271,   272,   273,   274,   275,   276,   277,   278,   279,
+     280,     0,     0,     0,     0,   262,   442,   263,   264,   265,
+     266,   267,   268,   269,   270,   271,   272,   273,   274,   275,
+     276,   277,   278,   279,   280,   262,   445,   263,   264,   265,
+     266,   267,   268,   269,   270,   271,   272,   273,   274,   275,
+     276,   277,   278,   279,   280,   262,   448,   263,   264,   265,
+     266,   267,   268,   269,   270,   271,   272,   273,   274,   275,
+     276,   277,   278,   279,   280,   262,   455,   263,   264,   265,
+     266,   267,   268,   269,   270,   271,   272,   273,   274,   275,
+     276,   277,   278,   279,   280,   262,   456,   263,   264,   265,
+     266,   267,   268,   269,   270,   271,   272,   273,   274,   275,
+     276,   277,   278,   279,   280,   262,   459,   263,   264,   265,
+     266,   267,   268,   269,   270,   271,   272,   273,   274,   275,
+     276,   277,   278,   279,   280,     0,     0,     0,     0,   262,
+     535,   263,   264,   265,   266,   267,   268,   269,   270,   271,
+     272,   273,   274,   275,   276,   277,   278,   279,   280,   262,
+     536,   263,   264,   265,   266,   267,   268,   269,   270,   271,
+     272,   273,   274,   275,   276,   277,   278,   279,   280,   262,
+     537,   263,   264,   265,   266,   267,   268,   269,   270,   271,
+     272,   273,   274,   275,   276,   277,   278,   279,   280,   262,
+     538,   263,   264,   265,   266,   267,   268,   269,   270,   271,
+     272,   273,   274,   275,   276,   277,   278,   279,   280,   262,
+     539,   263,   264,   265,   266,   267,   268,   269,   270,   271,
+     272,   273,   274,   275,   276,   277,   278,   279,   280,   262,
+     540,   263,   264,   265,   266,   267,   268,   269,   270,   271,
+     272,   273,   274,   275,   276,   277,   278,   279,   280,     0,
+       0,     0,     0,   262,   564,   263,   264,   265,   266,   267,
+     268,   269,   270,   271,   272,   273,   274,   275,   276,   277,
+     278,   279,   280,   262,   582,   263,   264,   265,   266,   267,
+     268,   269,   270,   271,   272,   273,   274,   275,   276,   277,
+     278,   279,   280,   262,   588,   263,   264,   265,   266,   267,
+     268,   269,   270,   271,   272,   273,   274,   275,   276,   277,
+     278,   279,   280,   262,   589,   263,   264,   265,   266,   267,
+     268,   269,   270,   271,   272,   273,   274,   275,   276,   277,
+     278,   279,   280,   262,   593,   263,   264,   265,   266,   267,
+     268,   269,   270,   271,   272,   273,   274,   275,   276,   277,
+     278,   279,   280,   262,   603,   263,   264,   265,   266,   267,
+     268,   269,   270,   271,   272,   273,   274,   275,   276,   277,
+     278,   279,   280,     0,     0,     0,     0,     0,   606,   265,
+     266,   267,   268,   269,   270,   271,   272,   273,   274,   275,
+     276,   277,   278,   279,   280,   262,   281,   263,   264,   265,
+     266,   267,   268,   269,   270,   271,   272,   273,   274,   275,
+     276,   277,   278,   279,   280,   262,   437,   263,   264,   265,
+     266,   267,   268,   269,   270,   271,   272,   273,   274,   275,
+     276,   277,   278,   279,   280,   262,   443,   263,   264,   265,
+     266,   267,   268,   269,   270,   271,   272,   273,   274,   275,
+     276,   277,   278,   279,   280,    67,   444,   264,   265,   266,
      267,   268,   269,   270,   271,   272,   273,   274,   275,   276,
-     696,   616,    29,    30,   722,   617,   723,   729,   562,   618,
-     666,   619,    31,    32,    33,    34,   643,    35,    36,   690,
-     726,   683,   543,   702,   561,    37,    38,    39,    40,   469,
-     688,   520,    28,   102,   194,     0,    41,    42,    43,    44,
-      45,    46,   344,   555,     0,     0,    47,    48,    49,     0,
-       0,     0,     0,    50,    51,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,   414,    52,     0,     0,     0,     0,
-       0,     0,     0,     0,    29,    30,     0,    53,     0,     0,
-       0,     0,     0,  -317,    31,    32,    33,    34,     0,    35,
-      36,     0,     0,    54,     0,     0,     0,    37,    38,    39,
-      40,   434,     0,   435,     0,     0,     0,     0,    41,    42,
-      43,    44,    45,    46,     0,     0,     0,     0,    47,    48,
-      49,     0,     0,     0,     0,    50,    51,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,    52,   266,   267,
-     268,   269,   270,   271,   272,   273,   274,   275,   276,    53,
+     277,   278,   279,   280,     0,     0,   453,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,   439,   262,    68,
      263,   264,   265,   266,   267,   268,   269,   270,   271,   272,
-     273,   274,   275,   276,   258,    54,   259,   260,   261,   262,
-     263,   264,   265,   266,   267,   268,   269,   270,   271,   272,
-     273,   274,   275,   276,   258,     0,   259,   260,   261,   262,
-     263,   264,   265,   266,   267,   268,   269,   270,   271,   272,
-     273,   274,   275,   276,   258,     0,   259,   260,   261,   262,
-     263,   264,   265,   266,   267,   268,   269,   270,   271,   272,
-     273,   274,   275,   276,   258,     0,   259,   260,   261,   262,
-     263,   264,   265,   266,   267,   268,   269,   270,   271,   272,
-     273,   274,   275,   276,   258,     0,   259,   260,   261,   262,
-     263,   264,   265,   266,   267,   268,   269,   270,   271,   272,
-     273,   274,   275,   276,   258,     0,   259,   260,   261,   262,
-     263,   264,   265,   266,   267,   268,   269,   270,   271,   272,
-     273,   274,   275,   276,     0,     0,   258,   350,   259,   260,
-     261,   262,   263,   264,   265,   266,   267,   268,   269,   270,
-     271,   272,   273,   274,   275,   276,   258,   436,   259,   260,
-     261,   262,   263,   264,   265,   266,   267,   268,   269,   270,
-     271,   272,   273,   274,   275,   276,   258,   439,   259,   260,
-     261,   262,   263,   264,   265,   266,   267,   268,   269,   270,
-     271,   272,   273,   274,   275,   276,   258,   442,   259,   260,
-     261,   262,   263,   264,   265,   266,   267,   268,   269,   270,
-     271,   272,   273,   274,   275,   276,   258,   451,   259,   260,
-     261,   262,   263,   264,   265,   266,   267,   268,   269,   270,
-     271,   272,   273,   274,   275,   276,   258,   527,   259,   260,
-     261,   262,   263,   264,   265,   266,   267,   268,   269,   270,
-     271,   272,   273,   274,   275,   276,     0,     0,   258,   528,
-     259,   260,   261,   262,   263,   264,   265,   266,   267,   268,
-     269,   270,   271,   272,   273,   274,   275,   276,   258,   529,
-     259,   260,   261,   262,   263,   264,   265,   266,   267,   268,
-     269,   270,   271,   272,   273,   274,   275,   276,   258,   530,
-     259,   260,   261,   262,   263,   264,   265,   266,   267,   268,
-     269,   270,   271,   272,   273,   274,   275,   276,   258,   531,
-     259,   260,   261,   262,   263,   264,   265,   266,   267,   268,
-     269,   270,   271,   272,   273,   274,   275,   276,   258,   532,
-     259,   260,   261,   262,   263,   264,   265,   266,   267,   268,
-     269,   270,   271,   272,   273,   274,   275,   276,   258,   556,
-     259,   260,   261,   262,   263,   264,   265,   266,   267,   268,
-     269,   270,   271,   272,   273,   274,   275,   276,     0,     0,
-     258,   574,   259,   260,   261,   262,   263,   264,   265,   266,
-     267,   268,   269,   270,   271,   272,   273,   274,   275,   276,
-     258,   580,   259,   260,   261,   262,   263,   264,   265,   266,
-     267,   268,   269,   270,   271,   272,   273,   274,   275,   276,
-     258,   581,   259,   260,   261,   262,   263,   264,   265,   266,
-     267,   268,   269,   270,   271,   272,   273,   274,   275,   276,
-     258,   585,   259,   260,   261,   262,   263,   264,   265,   266,
-     267,   268,   269,   270,   271,   272,   273,   274,   275,   276,
-     258,   595,   259,   260,   261,   262,   263,   264,   265,   266,
-     267,   268,   269,   270,   271,   272,   273,   274,   275,   276,
-     258,   598,   259,   260,   261,   262,   263,   264,   265,   266,
-     267,   268,   269,   270,   271,   272,   273,   274,   275,   276,
-     258,   277,   259,   260,   261,   262,   263,   264,   265,   266,
-     267,   268,   269,   270,   271,   272,   273,   274,   275,   276,
-     258,   431,   259,   260,   261,   262,   263,   264,   265,   266,
-     267,   268,   269,   270,   271,   272,   273,   274,   275,   276,
-       0,   437,     0,     0,     0,     0,    67,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,   438,     0,     0,     0,     0,     0,     0,     0,     0,
-      67,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-      68,   447,   260,   261,   262,   263,   264,   265,   266,   267,
-     268,   269,   270,   271,   272,   273,   274,   275,   276,     0,
-       0,   448,   433,    69,    68,   261,   262,   263,   264,   265,
-     266,   267,   268,   269,   270,   271,   272,   273,   274,   275,
-     276,   452,     0,     0,     0,     0,     0,    69,     0,     0,
-       0,     0,     0,     0,     0,     0,    70,     0,     0,     0,
-       0,   699,    71,    72,    73,    74,    75,   -43,    76,    77,
-      78,     0,    79,    80,     0,    81,    82,    83,     0,     0,
-      70,     0,    84,    85,    86,     0,    71,    72,    73,    74,
-      75,     0,    76,    77,    78,     0,    79,    80,     0,    81,
-      82,    83,     0,     0,     0,     0,    84,    85,    86,   258,
-       0,   259,   260,   261,   262,   263,   264,   265,   266,   267,
-     268,   269,   270,   271,   272,   273,   274,   275,   276,     0,
-       0,   505,   258,   454,   259,   260,   261,   262,   263,   264,
+     273,   274,   275,   276,   277,   278,   279,   280,     0,     0,
+     513,     0,    69,     0,     0,     0,     0,   262,   454,   263,
+     264,   265,   266,   267,   268,   269,   270,   271,   272,   273,
+     274,   275,   276,   277,   278,   279,   280,     0,   460,     0,
+       0,     0,     0,     0,     0,     0,     0,    70,     0,     0,
+       0,     0,     0,    71,    72,    73,    74,    75,   707,    76,
+      77,    78,     0,    79,    80,     0,    81,    82,    83,     0,
+       0,     0,     0,    84,    85,    86,   262,   462,   263,   264,
      265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
-     275,   276,   258,   510,   259,   260,   261,   262,   263,   264,
+     275,   276,   277,   278,   279,   280,   262,   518,   263,   264,
      265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
-     275,   276,   258,     0,   259,   260,   261,   262,   263,   264,
-     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
-     275,   276,   262,   263,   264,   265,   266,   267,   268,   269,
-     270,   271,   272,   273,   274,   275,   276
+     275,   276,   277,   278,   279,   280,   266,   267,   268,   269,
+     270,   271,   272,   273,   274,   275,   276,   277,   278,   279,
+     280,   268,   269,   270,   271,   272,   273,   274,   275,   276,
+     277,   278,   279,   280,   270,   271,   272,   273,   274,   275,
+     276,   277,   278,   279,   280
 };
 
-static const yytype_int16 yycheck[] =
+static const short int yycheck[] =
 {
-      71,    23,   103,   214,   215,    69,   200,     4,     4,    25,
-      81,   112,   222,   463,     4,     4,     4,    88,     3,     4,
-       4,   318,   628,   216,     4,     5,     4,    15,     4,     4,
-     599,     4,     5,   546,     6,    53,     4,     5,   712,    53,
-      54,     6,     0,   136,    32,    30,    31,   140,   123,     6,
-       4,   725,    37,    38,    39,   123,   625,   121,   122,    16,
-     124,   125,   137,    48,    49,    50,   130,    53,   581,   137,
-      55,     6,     4,   144,   145,    60,    54,    37,    63,    64,
-      65,    66,    67,    68,     4,     4,     5,     4,    73,    74,
-      75,    76,    77,    78,    79,    15,   167,   168,    15,   170,
-     669,    86,     4,    88,    53,   123,   556,   178,     4,   123,
-      53,   136,    32,   138,   702,    32,    53,   723,   103,    99,
-      95,   418,    54,    37,   109,   713,    99,   198,     4,     4,
-       5,    99,   136,   137,    51,    52,   329,     4,     5,     3,
-       4,   138,     4,     5,   141,   141,   136,   136,   598,   134,
-     138,     4,    54,   138,   138,   226,   141,   142,   229,   230,
-     136,   232,   233,   136,   136,   138,   237,   238,   239,   240,
-     241,   136,    53,   244,   190,   191,    37,    37,   249,   250,
-      99,    37,   253,   254,    32,    33,    34,   258,   259,   260,
-     261,   262,   263,   264,   265,   266,   267,   268,   269,   270,
-     271,   272,   273,   274,   275,   276,   277,   278,   279,   136,
-       4,   138,   619,   423,   285,   286,   133,   136,   138,   138,
-       3,     4,   139,     6,    99,   121,    37,    37,   124,   125,
-     126,     4,    99,    37,   136,   642,   136,    99,   138,   340,
-     341,    37,    15,   130,   131,   132,    37,    30,    31,    37,
-     136,    39,   138,     4,    37,    38,    39,    37,   665,    32,
-      37,   136,   326,   138,   328,    48,    49,    50,    37,   136,
-     480,   138,    55,    37,   136,    37,   138,    60,    51,    52,
-     127,     4,     4,     4,     4,    68,     4,     4,     4,     4,
-      73,    74,    75,    76,    77,    78,    79,    15,     4,    15,
-       4,     4,     4,    86,     3,    88,     4,     4,     4,     4,
-     105,   522,    15,    54,    32,   525,    32,   137,    54,    15,
-     103,   137,   344,    16,    16,     4,   109,   121,     4,    32,
-     124,   125,   126,    51,    52,     4,    32,     4,   409,   410,
-     411,   412,     4,     4,     3,     4,    37,     6,    51,    52,
-       4,   134,     4,   136,    37,    51,    52,    37,   141,   142,
-     133,   136,    37,   434,    53,    37,   437,   438,   562,   440,
-     121,    30,    31,   124,   125,   126,   447,   448,    37,    38,
-      39,    37,    37,   454,    37,     4,   402,    37,    37,    48,
-      49,    50,    37,    37,    37,    37,    55,    93,     4,   121,
-      37,    60,   124,   125,   126,    37,    37,    37,    37,    68,
-     117,   118,   119,    37,    73,    74,    75,    76,    77,    78,
-      79,   128,    30,    31,    32,    33,    34,    86,   135,    88,
-     133,   136,    37,   504,    54,   136,   136,   133,    63,    64,
-      65,    66,    67,    53,   103,    37,     6,   137,    54,   550,
-     109,     6,     7,     8,     9,    10,    11,    12,    13,    14,
-     137,    67,     3,     4,   138,   138,    72,   138,   138,   540,
-     138,     6,   138,   138,   545,   134,   547,   136,     4,   495,
-     496,   582,   141,   142,     4,    91,     4,   558,     4,    30,
-      31,    97,    98,     4,     4,     4,    37,    38,    39,    40,
-     138,     4,   138,   109,     4,   576,     4,    48,    49,    50,
-       4,     4,   583,   138,    55,     4,     4,   728,     4,    60,
-     731,   137,   137,     4,   735,    37,   138,    68,    54,    37,
-       4,   138,    73,    74,    75,    76,    77,    78,    79,     3,
-       4,    67,   136,   138,   645,    86,    72,    88,   138,   138,
-     138,   138,    16,    28,    29,    30,    31,    32,    33,    34,
-     138,    53,   103,   136,    16,    91,    30,    31,   109,    37,
-     138,    97,    98,    37,    38,    39,   138,     4,     4,   137,
-      16,    37,    16,   109,    48,    49,    50,     4,   659,   632,
-     633,    55,     4,   134,   637,    85,    60,    54,    95,    86,
-     141,   142,   138,    16,    68,   138,   138,    37,    53,    73,
-      74,    75,    76,    77,    78,    79,     3,     4,    38,   662,
-     663,    37,    86,    37,    88,   138,     6,    37,    37,   672,
-     673,   136,   675,   137,   677,   678,    96,    88,   137,   103,
-       6,   684,    37,    30,    31,   109,    54,    16,    53,    53,
-      37,    38,    39,   696,    37,    16,     4,    54,    37,    37,
-      37,    48,    49,    50,    37,   708,    37,    15,    55,    37,
-     134,    53,    37,    60,    37,    37,    25,   141,   142,    37,
-      37,    68,    37,   138,    32,   138,    73,    74,    75,    76,
-      77,    78,    79,    41,    42,    43,    44,    45,    37,    86,
-      37,    88,     4,    51,    52,     6,     7,     8,     9,    10,
-      11,    12,    13,    14,   138,   138,   103,   138,    54,    95,
-     138,    25,   109,    22,    23,    24,    25,    26,    27,    28,
-      29,    30,    31,    32,    33,    34,    37,   138,   138,    87,
-       4,    89,   138,     4,   138,    93,   138,   134,     4,    97,
-      98,     4,   138,   138,   141,   142,   204,   138,   231,   134,
-      15,   109,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-     675,   129,    46,    47,   138,   133,   138,   138,   544,   137,
-     642,   139,    56,    57,    58,    59,   625,    61,    62,   669,
-     715,   660,   512,   688,   543,    69,    70,    71,    72,   411,
-     667,   475,     4,    26,    96,    -1,    80,    81,    82,    83,
-      84,    85,   228,   536,    -1,    -1,    90,    91,    92,    -1,
-      -1,    -1,    -1,    97,    98,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,    -1,    36,   109,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,    -1,    46,    47,    -1,   121,    -1,    -1,
-      -1,    -1,    -1,   127,    56,    57,    58,    59,    -1,    61,
-      62,    -1,    -1,   137,    -1,    -1,    -1,    69,    70,    71,
-      72,   136,    -1,   138,    -1,    -1,    -1,    -1,    80,    81,
-      82,    83,    84,    85,    -1,    -1,    -1,    -1,    90,    91,
-      92,    -1,    -1,    -1,    -1,    97,    98,    -1,    -1,    -1,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,   109,    24,    25,
-      26,    27,    28,    29,    30,    31,    32,    33,    34,   121,
-      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
-      31,    32,    33,    34,    15,   137,    17,    18,    19,    20,
-      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
-      31,    32,    33,    34,    15,    -1,    17,    18,    19,    20,
-      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
-      31,    32,    33,    34,    15,    -1,    17,    18,    19,    20,
-      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
-      31,    32,    33,    34,    15,    -1,    17,    18,    19,    20,
-      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
-      31,    32,    33,    34,    15,    -1,    17,    18,    19,    20,
-      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
-      31,    32,    33,    34,    15,    -1,    17,    18,    19,    20,
+      71,    23,   103,   216,   217,    69,   202,     4,     4,    25,
+      81,   112,   224,   471,   322,   636,     4,    88,     3,     4,
+       4,     5,     4,   218,     4,     5,     4,    15,     4,     5,
+     607,     4,     5,   554,     6,    53,    54,     4,   710,     4,
+       4,   125,    53,     0,    32,    30,    31,     6,     4,   721,
+       4,     4,    37,    38,    39,   139,   633,   121,   122,    15,
+     124,   125,     4,    48,    49,    50,   130,     6,   589,     6,
+      55,   720,    53,   144,   145,    60,    32,    16,    63,    64,
+      65,    66,    67,    68,   733,   627,     4,    54,    73,    74,
+      75,    76,    77,    78,    79,    80,    81,   125,   169,   170,
+     677,   172,     4,    88,    53,    90,   564,   125,   650,   180,
+     731,   139,    54,    15,   125,    97,   424,   101,   138,    53,
+     105,   101,   142,     4,    53,   101,   111,     4,   101,   200,
+      32,   673,     4,     4,     5,   138,    54,   140,   333,     4,
+       5,     3,     4,   140,     4,     5,   143,   143,   606,    51,
+      52,   136,   140,    37,   138,   140,   140,   228,   143,   144,
+     231,   232,   140,   234,   235,   138,   138,   140,   239,   240,
+     241,   242,   243,   138,   138,   246,   192,   193,    53,   138,
+     251,   252,   253,   254,   140,   138,   257,   258,    32,    33,
+      34,   262,   263,   264,   265,   266,   267,   268,   269,   270,
+     271,   272,   273,   274,   275,   276,   277,   278,   279,   280,
+     281,   282,   283,    37,   138,     4,   140,   429,   289,   290,
+     138,     4,   132,   133,   134,     3,     4,   138,     6,   140,
+     101,    37,    15,   135,   138,   139,   101,     4,    37,   141,
+       4,   101,   123,   344,   345,   126,   127,   128,    15,    32,
+      37,   123,    30,    31,   126,   127,   128,    37,    37,    37,
+      38,    39,    37,    37,    39,    32,   330,   138,   332,   140,
+      48,    49,    50,   138,    37,   140,   488,    55,   138,   138,
+     140,   140,    60,     4,    51,    52,    37,    37,    37,    37,
+      68,    37,    37,   129,    15,    73,    74,    75,    76,    77,
+      78,    79,    80,    81,   119,   120,   121,     4,     4,     4,
+      88,    32,    90,     4,     4,   130,     4,   530,    15,     4,
+       4,   533,   137,     4,     4,     3,   348,   105,    95,     4,
+      51,    52,     4,   111,   123,    32,   107,   126,   127,   128,
+       4,    54,    16,    16,   415,   416,   417,   418,   139,    54,
+       3,     4,     4,     6,    51,    52,     4,   139,   136,   123,
+     138,     4,   126,   127,   128,   143,   144,     4,   135,   440,
+       4,     4,   443,   444,   570,   446,     4,    30,    31,     4,
+      37,    15,   453,   454,    37,    38,    39,     4,     4,     4,
+      37,   462,   408,    53,   138,    48,    49,    50,    32,    37,
+     138,    37,    55,   138,     4,    37,    37,    60,    30,    31,
+      32,    33,    34,    37,   135,    68,    37,    51,    52,    37,
+      73,    74,    75,    76,    77,    78,    79,    80,    81,    54,
+      37,    37,    37,    53,    37,    88,    37,    90,   135,    37,
+      37,   512,    67,    37,    37,    37,    37,    72,    37,    37,
+      37,   138,   105,   139,    54,    54,   139,   558,   111,    63,
+      64,    65,    66,    67,   140,    37,     6,    67,    93,   140,
+       3,     4,    72,   140,    99,   100,     6,   548,   140,   140,
+       4,   140,   553,   136,   555,   138,   111,   503,   504,   590,
+     143,   144,     4,    93,   140,   566,   140,    30,    31,    99,
+     100,   140,     4,     4,    37,    38,    39,    40,     4,     4,
+       4,   111,     4,   584,     4,    48,    49,    50,     4,     4,
+     591,     4,    55,   736,     4,   139,   739,    60,   139,     4,
+     743,     4,    37,    37,     4,    68,   140,    53,   140,    16,
+      73,    74,    75,    76,    77,    78,    79,    80,    81,   640,
+     641,     4,   653,   138,   645,    88,   140,    90,   140,   140,
+       6,     7,     8,     9,    10,    11,    12,    13,    14,   140,
+       3,     4,   105,   140,   140,   140,   138,    37,   111,   670,
+     671,   140,   140,    16,     4,   139,    16,    37,    16,   680,
+     681,    37,   683,     4,   685,   686,   667,    30,    31,    97,
+      87,   692,     4,   136,    37,    38,    39,    88,   140,   140,
+     143,   144,    54,   704,   140,    48,    49,    50,    16,    37,
+     140,    38,    55,    37,    53,   716,     6,    60,    28,    29,
+      30,    31,    32,    33,    34,    68,    37,    98,   138,    90,
+      73,    74,    75,    76,    77,    78,    79,    80,    81,     3,
+       4,   139,    37,    37,     6,    88,    37,    90,    21,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,    34,   105,   139,    16,    54,    30,    31,   111,    53,
+      53,    37,    16,    37,    38,    39,    37,    37,    37,    37,
+      37,    37,    54,    37,    48,    49,    50,    37,    37,    25,
+      53,    55,    37,   136,    37,   140,    60,     4,    37,   140,
+     143,   144,    37,    37,    68,   140,   140,   140,    15,    73,
+      74,    75,    76,    77,    78,    79,    80,    81,     4,    97,
+     140,   140,    54,    25,    88,    32,    90,   140,     4,     4,
+       4,   140,   233,   140,    41,    42,    43,    44,    45,   140,
+     140,   105,   140,   140,    51,    52,   552,   111,   140,   134,
+     683,    15,   140,    17,    18,    19,    20,    21,    22,    23,
+      24,    25,    26,    27,    28,    29,    30,    31,    32,    33,
+      34,   140,   136,   650,   206,   668,   633,   677,   723,   143,
+     144,   483,    89,     4,    91,   696,   520,   551,    95,   675,
+      26,    96,    99,   100,   417,   544,    -1,    -1,    -1,   230,
+      -1,    -1,    -1,    15,   111,    17,    18,    19,    20,    21,
+      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
+      32,    33,    34,    -1,   131,    46,    47,    -1,   135,    -1,
+      -1,    -1,   139,    -1,   141,    56,    57,    58,    59,    -1,
+      61,    62,    -1,    -1,    -1,    -1,    -1,    -1,    69,    70,
+      71,    72,    -1,    -1,    -1,    -1,    -1,     4,    -1,    -1,
+      -1,    82,    83,    84,    85,    86,    87,    -1,    -1,     4,
+      -1,    92,    93,    94,   138,    -1,   140,    -1,    99,   100,
+       6,     7,     8,     9,    10,    11,    12,    13,    14,    36,
+     111,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    46,
+      47,    -1,   123,    38,    -1,    -1,    -1,    -1,   129,    56,
+      57,    58,    59,    -1,    61,    62,    -1,    -1,   139,    -1,
+      -1,    -1,    69,    70,    71,    72,    61,    -1,   140,    -1,
+      -1,    -1,    -1,    -1,    -1,    82,    83,    84,    85,    86,
+      87,    -1,    -1,    -1,    -1,    92,    93,    94,    -1,    -1,
+      -1,    -1,    99,   100,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    96,    -1,    -1,   111,    -1,    -1,   102,   103,   104,
+     105,   106,   107,   108,   109,   110,   123,   112,   113,    -1,
+     115,   116,   117,    -1,    -1,    -1,    -1,   122,   123,   124,
+      -1,    15,   139,    17,    18,    19,    20,    21,    22,    23,
+      24,    25,    26,    27,    28,    29,    30,    31,    32,    33,
+      34,    15,    -1,    17,    18,    19,    20,    21,    22,    23,
+      24,    25,    26,    27,    28,    29,    30,    31,    32,    33,
+      34,    15,    -1,    17,    18,    19,    20,    21,    22,    23,
+      24,    25,    26,    27,    28,    29,    30,    31,    32,    33,
+      34,    15,    -1,    17,    18,    19,    20,    21,    22,    23,
+      24,    25,    26,    27,    28,    29,    30,    31,    32,    33,
+      34,    15,    -1,    17,    18,    19,    20,    21,    22,    23,
+      24,    25,    26,    27,    28,    29,    30,    31,    32,    33,
+      34,    15,    -1,    17,    18,    19,    20,    21,    22,    23,
+      24,    25,    26,    27,    28,    29,    30,    31,    32,    33,
+      34,    -1,    -1,    -1,    -1,    15,   140,    17,    18,    19,
+      20,    21,    22,    23,    24,    25,    26,    27,    28,    29,
+      30,    31,    32,    33,    34,    15,   140,    17,    18,    19,
+      20,    21,    22,    23,    24,    25,    26,    27,    28,    29,
+      30,    31,    32,    33,    34,    15,   140,    17,    18,    19,
+      20,    21,    22,    23,    24,    25,    26,    27,    28,    29,
+      30,    31,    32,    33,    34,    15,   140,    17,    18,    19,
+      20,    21,    22,    23,    24,    25,    26,    27,    28,    29,
+      30,    31,    32,    33,    34,    15,   140,    17,    18,    19,
+      20,    21,    22,    23,    24,    25,    26,    27,    28,    29,
+      30,    31,    32,    33,    34,    15,   140,    17,    18,    19,
+      20,    21,    22,    23,    24,    25,    26,    27,    28,    29,
+      30,    31,    32,    33,    34,    -1,    -1,    -1,    -1,    15,
+     140,    17,    18,    19,    20,    21,    22,    23,    24,    25,
+      26,    27,    28,    29,    30,    31,    32,    33,    34,    15,
+     140,    17,    18,    19,    20,    21,    22,    23,    24,    25,
+      26,    27,    28,    29,    30,    31,    32,    33,    34,    15,
+     140,    17,    18,    19,    20,    21,    22,    23,    24,    25,
+      26,    27,    28,    29,    30,    31,    32,    33,    34,    15,
+     140,    17,    18,    19,    20,    21,    22,    23,    24,    25,
+      26,    27,    28,    29,    30,    31,    32,    33,    34,    15,
+     140,    17,    18,    19,    20,    21,    22,    23,    24,    25,
+      26,    27,    28,    29,    30,    31,    32,    33,    34,    15,
+     140,    17,    18,    19,    20,    21,    22,    23,    24,    25,
+      26,    27,    28,    29,    30,    31,    32,    33,    34,    -1,
+      -1,    -1,    -1,    15,   140,    17,    18,    19,    20,    21,
+      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
+      32,    33,    34,    15,   140,    17,    18,    19,    20,    21,
+      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
+      32,    33,    34,    15,   140,    17,    18,    19,    20,    21,
+      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
+      32,    33,    34,    15,   140,    17,    18,    19,    20,    21,
+      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
+      32,    33,    34,    15,   140,    17,    18,    19,    20,    21,
+      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
+      32,    33,    34,    15,   140,    17,    18,    19,    20,    21,
+      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
+      32,    33,    34,    -1,    -1,    -1,    -1,    -1,   140,    19,
+      20,    21,    22,    23,    24,    25,    26,    27,    28,    29,
+      30,    31,    32,    33,    34,    15,   138,    17,    18,    19,
+      20,    21,    22,    23,    24,    25,    26,    27,    28,    29,
+      30,    31,    32,    33,    34,    15,   138,    17,    18,    19,
+      20,    21,    22,    23,    24,    25,    26,    27,    28,    29,
+      30,    31,    32,    33,    34,    15,   138,    17,    18,    19,
+      20,    21,    22,    23,    24,    25,    26,    27,    28,    29,
+      30,    31,    32,    33,    34,     4,   138,    18,    19,    20,
       21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
-      31,    32,    33,    34,    -1,    -1,    15,   138,    17,    18,
-      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
-      29,    30,    31,    32,    33,    34,    15,   138,    17,    18,
-      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
-      29,    30,    31,    32,    33,    34,    15,   138,    17,    18,
-      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
-      29,    30,    31,    32,    33,    34,    15,   138,    17,    18,
-      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
-      29,    30,    31,    32,    33,    34,    15,   138,    17,    18,
-      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
-      29,    30,    31,    32,    33,    34,    15,   138,    17,    18,
-      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
-      29,    30,    31,    32,    33,    34,    -1,    -1,    15,   138,
-      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
-      27,    28,    29,    30,    31,    32,    33,    34,    15,   138,
-      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
-      27,    28,    29,    30,    31,    32,    33,    34,    15,   138,
-      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
-      27,    28,    29,    30,    31,    32,    33,    34,    15,   138,
-      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
-      27,    28,    29,    30,    31,    32,    33,    34,    15,   138,
-      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
-      27,    28,    29,    30,    31,    32,    33,    34,    15,   138,
+      31,    32,    33,    34,    -1,    -1,   138,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    36,    15,    38,
       17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
       27,    28,    29,    30,    31,    32,    33,    34,    -1,    -1,
-      15,   138,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      15,   138,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      15,   138,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      15,   138,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      15,   138,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      15,   138,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      15,   136,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      15,   136,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      -1,   136,    -1,    -1,    -1,    -1,     4,    -1,    -1,    -1,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,   136,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-       4,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-      38,   136,    18,    19,    20,    21,    22,    23,    24,    25,
-      26,    27,    28,    29,    30,    31,    32,    33,    34,    -1,
-      -1,   136,    36,    61,    38,    19,    20,    21,    22,    23,
+      37,    -1,    61,    -1,    -1,    -1,    -1,    15,   138,    17,
+      18,    19,    20,    21,    22,    23,    24,    25,    26,    27,
+      28,    29,    30,    31,    32,    33,    34,    -1,   138,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    96,    -1,    -1,
+      -1,    -1,    -1,   102,   103,   104,   105,   106,   138,   108,
+     109,   110,    -1,   112,   113,    -1,   115,   116,   117,    -1,
+      -1,    -1,    -1,   122,   123,   124,    15,    16,    17,    18,
+      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
+      29,    30,    31,    32,    33,    34,    15,    16,    17,    18,
+      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
+      29,    30,    31,    32,    33,    34,    20,    21,    22,    23,
       24,    25,    26,    27,    28,    29,    30,    31,    32,    33,
-      34,   136,    -1,    -1,    -1,    -1,    -1,    61,    -1,    -1,
-      -1,    -1,    -1,    -1,    -1,    -1,    94,    -1,    -1,    -1,
-      -1,   136,   100,   101,   102,   103,   104,   105,   106,   107,
-     108,    -1,   110,   111,    -1,   113,   114,   115,    -1,    -1,
-      94,    -1,   120,   121,   122,    -1,   100,   101,   102,   103,
-     104,    -1,   106,   107,   108,    -1,   110,   111,    -1,   113,
-     114,   115,    -1,    -1,    -1,    -1,   120,   121,   122,    15,
-      -1,    17,    18,    19,    20,    21,    22,    23,    24,    25,
-      26,    27,    28,    29,    30,    31,    32,    33,    34,    -1,
-      -1,    37,    15,    16,    17,    18,    19,    20,    21,    22,
-      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
-      33,    34,    15,    16,    17,    18,    19,    20,    21,    22,
-      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
-      33,    34,    15,    -1,    17,    18,    19,    20,    21,    22,
-      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
-      33,    34,    20,    21,    22,    23,    24,    25,    26,    27,
-      28,    29,    30,    31,    32,    33,    34
+      34,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    34,    24,    25,    26,    27,    28,    29,
+      30,    31,    32,    33,    34
 };
 
 /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
    symbol of state STATE-NUM.  */
-static const yytype_uint16 yystos[] =
+static const unsigned short int yystos[] =
 {
-       0,   117,   118,   119,   128,   135,   144,   160,   161,   148,
-     149,   146,   147,   253,   254,   248,   249,     0,   162,   150,
-       4,    53,   123,   257,   258,    53,   250,   251,     4,    46,
+       0,   119,   120,   121,   130,   137,   146,   162,   163,   150,
+     151,   148,   149,   255,   256,   250,   251,     0,   164,   152,
+       4,    53,   125,   259,   260,    53,   252,   253,     4,    46,
       47,    56,    57,    58,    59,    61,    62,    69,    70,    71,
-      72,    80,    81,    82,    83,    84,    85,    90,    91,    92,
-      97,    98,   109,   121,   137,   163,   170,   172,   190,   192,
-     201,   202,   204,   206,   240,   255,   256,     4,    38,    61,
-      94,   100,   101,   102,   103,   104,   106,   107,   108,   110,
-     111,   113,   114,   115,   120,   121,   122,   151,     6,     4,
-     121,   124,   125,   126,   260,   261,    53,   258,   125,   126,
-     252,   261,   251,     6,     7,     8,     9,    10,    11,    12,
-      13,    14,   188,    53,    53,    37,    37,     4,   145,    53,
-      37,    37,    37,    37,    37,    37,    37,    37,    37,   164,
-      37,    37,    37,   173,    37,   136,   137,   189,   127,     4,
-     145,     4,     3,     4,    30,    31,    37,    38,    39,    48,
+      72,    82,    83,    84,    85,    86,    87,    92,    93,    94,
+      99,   100,   111,   123,   139,   165,   172,   174,   192,   194,
+     203,   204,   206,   208,   242,   257,   258,     4,    38,    61,
+      96,   102,   103,   104,   105,   106,   108,   109,   110,   112,
+     113,   115,   116,   117,   122,   123,   124,   153,     6,     4,
+     123,   126,   127,   128,   262,   263,    53,   260,   127,   128,
+     254,   263,   253,     6,     7,     8,     9,    10,    11,    12,
+      13,    14,   190,    53,    53,    37,    37,     4,   147,    53,
+      37,    37,    37,    37,    37,    37,    37,    37,    37,   166,
+      37,    37,    37,   175,    37,   138,   139,   191,   129,     4,
+     147,     4,     3,     4,    30,    31,    37,    38,    39,    48,
       49,    50,    55,    60,    68,    73,    74,    75,    76,    77,
-      78,    79,    86,    88,   103,   109,   134,   141,   142,   210,
-       4,     4,   155,     4,   154,   153,     4,     4,     4,   210,
-       4,     3,     4,   156,   157,   158,     4,   105,   210,     4,
-      16,    16,    54,   137,   260,    54,   137,   208,   209,   208,
-     171,   241,     4,     4,   165,     4,   194,     4,   145,   145,
-       4,   145,   138,   145,   203,   205,     4,   207,     4,     5,
-      99,   166,    37,   145,     4,     4,    37,   157,    53,     6,
-     136,   152,     6,   136,   210,   210,   210,    37,    37,    37,
+      78,    79,    80,    81,    88,    90,   105,   111,   136,   143,
+     144,   212,     4,     4,   157,     4,   156,   155,     4,     4,
+       4,   212,     4,     3,     4,   158,   159,   160,     4,   107,
+     212,     4,    16,    16,    54,   139,   262,    54,   139,   210,
+     211,   210,   173,   243,     4,     4,   167,     4,   196,     4,
+     147,   147,     4,   147,   140,   147,   205,   207,     4,   209,
+       4,     5,   101,   168,    37,   147,     4,     4,    37,   159,
+      53,     6,   138,   154,     6,   138,   212,   212,   212,    37,
       37,    37,    37,    37,    37,    37,    37,    37,    37,    37,
-      37,    37,    37,    37,    37,    37,   210,   210,    15,    17,
-      18,    19,    20,    21,    22,    23,    24,    25,    26,    27,
-      28,    29,    30,    31,    32,    33,    34,   136,     6,   136,
-     210,   136,   136,     4,   136,     6,   136,   210,   136,   136,
-       4,   159,    53,   261,   261,   137,     4,   121,   124,   125,
-     126,    54,   137,   210,     4,    54,    67,    91,   172,   216,
-       4,    54,   242,   136,   138,   138,   162,   195,   193,   138,
-     138,   138,   138,   138,   136,   138,   191,   138,   191,   136,
-     207,   138,    37,     4,     5,    99,   136,   138,   166,   138,
-       6,     6,   210,   138,   257,   210,   210,   150,   210,   210,
-     138,   210,   210,   210,   210,   210,     4,     4,   210,     4,
-       4,     4,     4,   210,   210,     4,     4,   210,   210,     4,
-     210,   210,   210,   210,   210,   210,   210,   210,   210,   210,
-     210,   210,   210,   210,   210,   210,   210,   210,   210,   210,
-     210,   210,     4,     4,     4,   210,   210,     3,     4,     4,
-       4,   136,   263,   137,   137,     4,   123,   137,   259,   217,
-     222,   227,   243,     4,    36,    37,   198,    54,   136,   194,
-     145,   145,   207,   167,    37,     4,     5,    99,   138,   208,
-     208,   136,    54,    36,   136,   138,   138,   136,   136,   138,
-     136,   138,   138,   138,   138,   138,   138,   136,   136,   138,
-     138,   138,   136,   138,    16,     4,   261,   126,    53,   123,
-     137,    37,    40,   210,   230,   231,    16,   210,   232,   231,
-     210,   245,   136,     4,   141,   199,   200,    16,   194,   166,
-     169,    37,   138,   138,     4,   210,   210,   210,   210,   210,
-     210,     4,   210,   137,   264,    16,   262,    63,    64,    65,
-      66,    67,   138,   229,    37,    37,   230,    16,    95,   212,
-      16,    85,   233,   228,     4,    95,   246,     4,     4,   138,
-     200,    86,   196,   138,   166,   168,   138,   138,   138,   138,
-     138,   138,   138,   138,    54,   261,   261,   138,   210,    16,
-      37,    38,   213,   212,    53,    37,   247,    37,   244,   138,
-       6,   191,   138,   166,   137,   264,   138,   210,    37,    96,
-     214,   214,   171,   210,   246,   210,   137,   208,    88,   197,
-     138,    54,    39,   230,   138,   210,    37,   218,   223,    54,
-     138,   138,     6,    37,    16,   138,   210,   130,   131,   132,
-     215,    53,   246,   208,   210,   138,    53,   224,   138,   219,
-     236,   230,     4,    15,    32,    41,    42,    43,    44,    45,
-      51,    52,    87,    89,    93,   109,   129,   133,   137,   139,
-     174,   175,   178,   179,   181,   183,   184,   185,   190,     4,
-      54,    16,    37,    37,    37,   182,    37,    37,     4,    51,
-     175,   177,    37,   181,    54,    37,   189,   237,   225,    51,
-      52,    93,   133,   174,    51,    52,   174,   186,   208,    37,
-     180,   174,   176,    37,   140,   191,   177,   220,   208,    53,
-      25,   234,    37,    37,   138,    37,   138,    37,    37,   138,
-     138,   210,     4,   178,   138,   174,   175,   138,   234,   138,
-     184,     4,    95,   211,   174,   174,   176,   174,   174,   136,
-     138,   174,   211,    54,    25,   235,   138,   138,   138,   138,
-     138,     4,   235,   238,     4,     6,    16,   187,   138,   138,
-     174,   138,   138,   138,   187,   235,   186,     4,   226,   138,
-     189,   221,   187,   191,   191,   239,   191
+      37,    37,    37,    37,    37,    37,    37,    37,    37,    37,
+     212,   212,    15,    17,    18,    19,    20,    21,    22,    23,
+      24,    25,    26,    27,    28,    29,    30,    31,    32,    33,
+      34,   138,     6,   138,   212,   138,   138,     4,   138,     6,
+     138,   212,   138,   138,     4,   161,    53,   263,   263,   139,
+       4,   123,   126,   127,   128,    54,   139,   212,     4,    54,
+      67,    93,   174,   218,     4,    54,   244,   138,   140,   140,
+     164,   197,   195,   140,   140,   140,   140,   140,   138,   140,
+     193,   140,   193,   138,   209,   140,    37,     4,     5,   101,
+     138,   140,   168,   140,     6,     6,   212,   140,   259,   212,
+     212,   152,   212,   212,   140,   212,   212,   212,   212,   212,
+       4,     4,   212,     4,     4,     4,     4,   212,   212,   212,
+     212,     4,     4,   212,   212,     4,   212,   212,   212,   212,
+     212,   212,   212,   212,   212,   212,   212,   212,   212,   212,
+     212,   212,   212,   212,   212,   212,   212,   212,     4,     4,
+       4,   212,   212,     3,     4,     4,     4,   138,   265,   139,
+     139,     4,   125,   139,   261,   219,   224,   229,   245,     4,
+      36,    37,   200,    54,   138,   196,   147,   147,   209,   169,
+      37,     4,     5,   101,   140,   210,   210,   138,    54,    36,
+     138,   140,   140,   138,   138,   140,   138,   140,   140,   140,
+     140,   140,   140,   138,   138,   140,   140,   140,   140,   140,
+     138,   140,    16,     4,   263,   128,    53,   125,   139,    37,
+      40,   212,   232,   233,    16,   212,   234,   233,   212,   247,
+     138,     4,   143,   201,   202,    16,   196,   168,   171,    37,
+     140,   140,     4,   212,   212,   212,   212,   212,   212,     4,
+     212,   139,   266,    16,   264,    63,    64,    65,    66,    67,
+     140,   231,    37,    37,   232,    16,    97,   214,    16,    87,
+     235,   230,     4,    97,   248,     4,     4,   140,   202,    88,
+     198,   140,   168,   170,   140,   140,   140,   140,   140,   140,
+     140,   140,    54,   263,   263,   140,   212,    16,    37,    38,
+     215,   214,    53,    37,   249,    37,   246,   140,     6,   193,
+     140,   168,   139,   266,   140,   212,    37,    98,   216,   216,
+     173,   212,   248,   212,   139,   210,    90,   199,   140,    54,
+      39,   232,   140,   212,    37,   220,   225,    54,   140,   140,
+       6,    37,    16,   140,   212,   132,   133,   134,   217,    53,
+     248,   210,   212,   140,    53,   226,   140,   221,   238,   232,
+       4,    15,    32,    41,    42,    43,    44,    45,    51,    52,
+      89,    91,    95,   111,   131,   135,   139,   141,   176,   177,
+     180,   181,   183,   185,   186,   187,   192,     4,    54,    16,
+      37,    37,    37,   184,    37,    37,     4,    51,   177,   179,
+      37,   183,    54,    37,   191,   239,   227,    51,    52,    95,
+     135,   176,    51,    52,   176,   188,   210,    37,   182,   176,
+     178,    37,   142,   193,   179,   222,   210,    53,    25,   236,
+      37,    37,   140,    37,   140,    37,    37,   140,   140,   212,
+       4,   180,   140,   176,   177,   140,   236,   140,   186,     4,
+      97,   213,   176,   176,   178,   176,   176,   138,   140,   176,
+     213,    54,    25,   237,   140,   140,   140,   140,   140,     4,
+     237,   240,     4,     6,    16,   189,   140,   140,   176,   140,
+     140,   140,   189,   237,   188,     4,   228,   140,   191,   223,
+     189,   193,   193,   241,   193
 };
 
 #define yyerrok		(yyerrstatus = 0)
@@ -1719,7 +1664,7 @@
       yychar = (Token);						\
       yylval = (Value);						\
       yytoken = YYTRANSLATE (yychar);				\
-      YYPOPSTACK (1);						\
+      YYPOPSTACK;						\
       goto yybackup;						\
     }								\
   else								\
@@ -1727,7 +1672,7 @@
       yyerror (YY_("syntax error: cannot back up")); \
       YYERROR;							\
     }								\
-while (YYID (0))
+while (0)
 
 
 #define YYTERROR	1
@@ -1742,7 +1687,7 @@
 #ifndef YYLLOC_DEFAULT
 # define YYLLOC_DEFAULT(Current, Rhs, N)				\
     do									\
-      if (YYID (N))                                                    \
+      if (N)								\
 	{								\
 	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
 	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
@@ -1756,7 +1701,7 @@
 	  (Current).first_column = (Current).last_column =		\
 	    YYRHSLOC (Rhs, 0).last_column;				\
 	}								\
-    while (YYID (0))
+    while (0)
 #endif
 
 
@@ -1768,8 +1713,8 @@
 # if YYLTYPE_IS_TRIVIAL
 #  define YY_LOCATION_PRINT(File, Loc)			\
      fprintf (File, "%d.%d-%d.%d",			\
-	      (Loc).first_line, (Loc).first_column,	\
-	      (Loc).last_line,  (Loc).last_column)
+              (Loc).first_line, (Loc).first_column,	\
+              (Loc).last_line,  (Loc).last_column)
 # else
 #  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
 # endif
@@ -1796,96 +1741,36 @@
 do {						\
   if (yydebug)					\
     YYFPRINTF Args;				\
-} while (YYID (0))
-
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
-do {									  \
-  if (yydebug)								  \
-    {									  \
-      YYFPRINTF (stderr, "%s ", Title);					  \
-      yy_symbol_print (stderr,						  \
-		  Type, Value); \
-      YYFPRINTF (stderr, "\n");						  \
-    }									  \
-} while (YYID (0))
+} while (0)
 
-
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
-
-/*ARGSUSED*/
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static void
-yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
-#else
-static void
-yy_symbol_value_print (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE const * const yyvaluep;
-#endif
-{
-  if (!yyvaluep)
-    return;
-# ifdef YYPRINT
-  if (yytype < YYNTOKENS)
-    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
-# else
-  YYUSE (yyoutput);
-# endif
-  switch (yytype)
-    {
-      default:
-	break;
-    }
-}
-
-
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
-
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static void
-yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
-#else
-static void
-yy_symbol_print (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE const * const yyvaluep;
-#endif
-{
-  if (yytype < YYNTOKENS)
-    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
-  else
-    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
-
-  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
-  YYFPRINTF (yyoutput, ")");
-}
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)		\
+do {								\
+  if (yydebug)							\
+    {								\
+      YYFPRINTF (stderr, "%s ", Title);				\
+      yysymprint (stderr,					\
+                  Type, Value);	\
+      YYFPRINTF (stderr, "\n");					\
+    }								\
+} while (0)
 
 /*------------------------------------------------------------------.
 | yy_stack_print -- Print the state stack from its BOTTOM up to its |
 | TOP (included).                                                   |
 `------------------------------------------------------------------*/
 
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
+#if defined (__STDC__) || defined (__cplusplus)
 static void
-yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
+yy_stack_print (short int *bottom, short int *top)
 #else
 static void
 yy_stack_print (bottom, top)
-    yytype_int16 *bottom;
-    yytype_int16 *top;
+    short int *bottom;
+    short int *top;
 #endif
 {
   YYFPRINTF (stderr, "Stack now");
-  for (; bottom <= top; ++bottom)
+  for (/* Nothing. */; bottom <= top; ++bottom)
     YYFPRINTF (stderr, " %d", *bottom);
   YYFPRINTF (stderr, "\n");
 }
@@ -1894,45 +1779,37 @@
 do {								\
   if (yydebug)							\
     yy_stack_print ((Bottom), (Top));				\
-} while (YYID (0))
+} while (0)
 
 
 /*------------------------------------------------.
 | Report that the YYRULE is going to be reduced.  |
 `------------------------------------------------*/
 
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
+#if defined (__STDC__) || defined (__cplusplus)
 static void
-yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+yy_reduce_print (int yyrule)
 #else
 static void
-yy_reduce_print (yyvsp, yyrule)
-    YYSTYPE *yyvsp;
+yy_reduce_print (yyrule)
     int yyrule;
 #endif
 {
-  int yynrhs = yyr2[yyrule];
   int yyi;
   unsigned long int yylno = yyrline[yyrule];
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
-	     yyrule - 1, yylno);
-  /* The symbols being reduced.  */
-  for (yyi = 0; yyi < yynrhs; yyi++)
-    {
-      fprintf (stderr, "   $%d = ", yyi + 1);
-      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
-		       &(yyvsp[(yyi + 1) - (yynrhs)])
-		       		       );
-      fprintf (stderr, "\n");
-    }
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu), ",
+             yyrule - 1, yylno);
+  /* Print the symbols being reduced, and their result.  */
+  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
+    YYFPRINTF (stderr, "%s ", yytname[yyrhs[yyi]]);
+  YYFPRINTF (stderr, "-> %s\n", yytname[yyr1[yyrule]]);
 }
 
 # define YY_REDUCE_PRINT(Rule)		\
 do {					\
   if (yydebug)				\
-    yy_reduce_print (yyvsp, Rule); \
-} while (YYID (0))
+    yy_reduce_print (Rule);		\
+} while (0)
 
 /* Nonzero means print parse trace.  It is left uninitialized so that
    multiple parsers can coexist.  */
@@ -1966,44 +1843,42 @@
 #if YYERROR_VERBOSE
 
 # ifndef yystrlen
-#  if defined __GLIBC__ && defined _STRING_H
+#  if defined (__GLIBC__) && defined (_STRING_H)
 #   define yystrlen strlen
 #  else
 /* Return the length of YYSTR.  */
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
 static YYSIZE_T
+#   if defined (__STDC__) || defined (__cplusplus)
 yystrlen (const char *yystr)
-#else
-static YYSIZE_T
+#   else
 yystrlen (yystr)
-    const char *yystr;
-#endif
+     const char *yystr;
+#   endif
 {
-  YYSIZE_T yylen;
-  for (yylen = 0; yystr[yylen]; yylen++)
+  const char *yys = yystr;
+
+  while (*yys++ != '\0')
     continue;
-  return yylen;
+
+  return yys - yystr - 1;
 }
 #  endif
 # endif
 
 # ifndef yystpcpy
-#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
 #   define yystpcpy stpcpy
 #  else
 /* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
    YYDEST.  */
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
 static char *
+#   if defined (__STDC__) || defined (__cplusplus)
 yystpcpy (char *yydest, const char *yysrc)
-#else
-static char *
+#   else
 yystpcpy (yydest, yysrc)
-    char *yydest;
-    const char *yysrc;
-#endif
+     char *yydest;
+     const char *yysrc;
+#   endif
 {
   char *yyd = yydest;
   const char *yys = yysrc;
@@ -2029,7 +1904,7 @@
 {
   if (*yystr == '"')
     {
-      YYSIZE_T yyn = 0;
+      size_t yyn = 0;
       char const *yyp = yystr;
 
       for (;;)
@@ -2064,123 +1939,53 @@
 }
 # endif
 
-/* Copy into YYRESULT an error message about the unexpected token
-   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
-   including the terminating null byte.  If YYRESULT is null, do not
-   copy anything; just return the number of bytes that would be
-   copied.  As a special case, return 0 if an ordinary "syntax error"
-   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
-   size calculation.  */
-static YYSIZE_T
-yysyntax_error (char *yyresult, int yystate, int yychar)
-{
-  int yyn = yypact[yystate];
+#endif /* YYERROR_VERBOSE */
 
-  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
-    return 0;
-  else
-    {
-      int yytype = YYTRANSLATE (yychar);
-      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
-      YYSIZE_T yysize = yysize0;
-      YYSIZE_T yysize1;
-      int yysize_overflow = 0;
-      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
-      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
-      int yyx;
-
-# if 0
-      /* This is so xgettext sees the translatable formats that are
-	 constructed on the fly.  */
-      YY_("syntax error, unexpected %s");
-      YY_("syntax error, unexpected %s, expecting %s");
-      YY_("syntax error, unexpected %s, expecting %s or %s");
-      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
-      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
-# endif
-      char *yyfmt;
-      char const *yyf;
-      static char const yyunexpected[] = "syntax error, unexpected %s";
-      static char const yyexpecting[] = ", expecting %s";
-      static char const yyor[] = " or %s";
-      char yyformat[sizeof yyunexpected
-		    + sizeof yyexpecting - 1
-		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
-		       * (sizeof yyor - 1))];
-      char const *yyprefix = yyexpecting;
-
-      /* Start YYX at -YYN if negative to avoid negative indexes in
-	 YYCHECK.  */
-      int yyxbegin = yyn < 0 ? -yyn : 0;
-
-      /* Stay within bounds of both yycheck and yytname.  */
-      int yychecklim = YYLAST - yyn + 1;
-      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-      int yycount = 1;
+
 
-      yyarg[0] = yytname[yytype];
-      yyfmt = yystpcpy (yyformat, yyunexpected);
+#if YYDEBUG
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
 
-      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-	  {
-	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
-	      {
-		yycount = 1;
-		yysize = yysize0;
-		yyformat[sizeof yyunexpected - 1] = '\0';
-		break;
-	      }
-	    yyarg[yycount++] = yytname[yyx];
-	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
-	    yysize_overflow |= (yysize1 < yysize);
-	    yysize = yysize1;
-	    yyfmt = yystpcpy (yyfmt, yyprefix);
-	    yyprefix = yyor;
-	  }
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yysymprint (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  /* Pacify ``unused variable'' warnings.  */
+  (void) yyvaluep;
 
-      yyf = YY_(yyformat);
-      yysize1 = yysize + yystrlen (yyf);
-      yysize_overflow |= (yysize1 < yysize);
-      yysize = yysize1;
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
 
-      if (yysize_overflow)
-	return YYSIZE_MAXIMUM;
 
-      if (yyresult)
-	{
-	  /* Avoid sprintf, as that infringes on the user's name space.
-	     Don't have undefined behavior even if the translation
-	     produced a string with the wrong number of "%s"s.  */
-	  char *yyp = yyresult;
-	  int yyi = 0;
-	  while ((*yyp = *yyf) != '\0')
-	    {
-	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
-		{
-		  yyp += yytnamerr (yyp, yyarg[yyi++]);
-		  yyf += 2;
-		}
-	      else
-		{
-		  yyp++;
-		  yyf++;
-		}
-	    }
-	}
-      return yysize;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# endif
+  switch (yytype)
+    {
+      default:
+        break;
     }
+  YYFPRINTF (yyoutput, ")");
 }
-#endif /* YYERROR_VERBOSE */
-
 
+#endif /* ! YYDEBUG */
 /*-----------------------------------------------.
 | Release the memory associated to this symbol.  |
 `-----------------------------------------------*/
 
-/*ARGSUSED*/
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
+#if defined (__STDC__) || defined (__cplusplus)
 static void
 yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
 #else
@@ -2191,7 +1996,8 @@
     YYSTYPE *yyvaluep;
 #endif
 {
-  YYUSE (yyvaluep);
+  /* Pacify ``unused variable'' warnings.  */
+  (void) yyvaluep;
 
   if (!yymsg)
     yymsg = "Deleting";
@@ -2201,7 +2007,7 @@
     {
 
       default:
-	break;
+        break;
     }
 }
 
@@ -2209,13 +2015,13 @@
 /* Prevent warnings from -Wmissing-prototypes.  */
 
 #ifdef YYPARSE_PARAM
-#if defined __STDC__ || defined __cplusplus
+# if defined (__STDC__) || defined (__cplusplus)
 int yyparse (void *YYPARSE_PARAM);
-#else
+# else
 int yyparse ();
-#endif
+# endif
 #else /* ! YYPARSE_PARAM */
-#if defined __STDC__ || defined __cplusplus
+#if defined (__STDC__) || defined (__cplusplus)
 int yyparse (void);
 #else
 int yyparse ();
@@ -2240,24 +2046,20 @@
 `----------*/
 
 #ifdef YYPARSE_PARAM
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-int
-yyparse (void *YYPARSE_PARAM)
-#else
-int
-yyparse (YYPARSE_PARAM)
-    void *YYPARSE_PARAM;
-#endif
+# if defined (__STDC__) || defined (__cplusplus)
+int yyparse (void *YYPARSE_PARAM)
+# else
+int yyparse (YYPARSE_PARAM)
+  void *YYPARSE_PARAM;
+# endif
 #else /* ! YYPARSE_PARAM */
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
+#if defined (__STDC__) || defined (__cplusplus)
 int
 yyparse (void)
 #else
 int
 yyparse ()
-
+    ;
 #endif
 #endif
 {
@@ -2269,12 +2071,6 @@
   int yyerrstatus;
   /* Look-ahead token as an internal (translated) token number.  */
   int yytoken = 0;
-#if YYERROR_VERBOSE
-  /* Buffer for error messages, and its allocated size.  */
-  char yymsgbuf[128];
-  char *yymsg = yymsgbuf;
-  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
-#endif
 
   /* Three stacks and their tools:
      `yyss': related to states,
@@ -2285,9 +2081,9 @@
      to reallocate them elsewhere.  */
 
   /* The state stack.  */
-  yytype_int16 yyssa[YYINITDEPTH];
-  yytype_int16 *yyss = yyssa;
-  yytype_int16 *yyssp;
+  short int yyssa[YYINITDEPTH];
+  short int *yyss = yyssa;
+  short int *yyssp;
 
   /* The semantic value stack.  */
   YYSTYPE yyvsa[YYINITDEPTH];
@@ -2296,7 +2092,7 @@
 
 
 
-#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+#define YYPOPSTACK   (yyvsp--, yyssp--)
 
   YYSIZE_T yystacksize = YYINITDEPTH;
 
@@ -2305,9 +2101,9 @@
   YYSTYPE yyval;
 
 
-  /* The number of symbols on the RHS of the reduced rule.
-     Keep to zero when no symbol should be popped.  */
-  int yylen = 0;
+  /* When reducing, the number of symbols on the RHS of the reduced
+     rule.  */
+  int yylen;
 
   YYDPRINTF ((stderr, "Starting parse\n"));
 
@@ -2331,7 +2127,8 @@
 `------------------------------------------------------------*/
  yynewstate:
   /* In all cases, when you get here, the value and location stacks
-     have just been pushed.  So pushing a state here evens the stacks.  */
+     have just been pushed. so pushing a state here evens the stacks.
+     */
   yyssp++;
 
  yysetstate:
@@ -2344,11 +2141,11 @@
 
 #ifdef yyoverflow
       {
-	/* Give user a chance to reallocate the stack.  Use copies of
+	/* Give user a chance to reallocate the stack. Use copies of
 	   these so that the &'s don't force the real ones into
 	   memory.  */
 	YYSTYPE *yyvs1 = yyvs;
-	yytype_int16 *yyss1 = yyss;
+	short int *yyss1 = yyss;
 
 
 	/* Each stack pointer address is followed by the size of the
@@ -2376,7 +2173,7 @@
 	yystacksize = YYMAXDEPTH;
 
       {
-	yytype_int16 *yyss1 = yyss;
+	short int *yyss1 = yyss;
 	union yyalloc *yyptr =
 	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
 	if (! yyptr)
@@ -2411,10 +2208,12 @@
 `-----------*/
 yybackup:
 
-  /* Do appropriate processing given the current state.  Read a
-     look-ahead token if we need one and don't already have one.  */
+/* Do appropriate processing given the current state.  */
+/* Read a look-ahead token if we need one and don't already have one.  */
+/* yyresume: */
 
   /* First try to decide what to do without reference to look-ahead token.  */
+
   yyn = yypact[yystate];
   if (yyn == YYPACT_NINF)
     goto yydefault;
@@ -2456,21 +2255,22 @@
   if (yyn == YYFINAL)
     YYACCEPT;
 
-  /* Count tokens shifted since error; after three, turn off error
-     status.  */
-  if (yyerrstatus)
-    yyerrstatus--;
-
   /* Shift the look-ahead token.  */
   YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
 
-  /* Discard the shifted token unless it is eof.  */
+  /* Discard the token being shifted unless it is eof.  */
   if (yychar != YYEOF)
     yychar = YYEMPTY;
 
-  yystate = yyn;
   *++yyvsp = yylval;
 
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  yystate = yyn;
   goto yynewstate;
 
 
@@ -2514,7 +2314,7 @@
 #line 178 "ldgram.y"
     {
 		  ldlex_popstate();
-		  lang_add_assignment(exp_assop((yyvsp[(3) - (4)].token),(yyvsp[(2) - (4)].name),(yyvsp[(4) - (4)].etree)));
+		  lang_add_assignment(exp_assop((yyvsp[-1].token),(yyvsp[-2].name),(yyvsp[0].etree)));
 		}
     break;
 
@@ -2538,7 +2338,7 @@
   case 16:
 #line 206 "ldgram.y"
     {
-			einfo(_("%P%F: unrecognised keyword in MRI style script '%s'\n"),(yyvsp[(1) - (1)].name));
+			einfo(_("%P%F: unrecognised keyword in MRI style script '%s'\n"),(yyvsp[0].name));
 			}
     break;
 
@@ -2551,87 +2351,87 @@
 
   case 20:
 #line 215 "ldgram.y"
-    { mri_public((yyvsp[(2) - (4)].name), (yyvsp[(4) - (4)].etree)); }
+    { mri_public((yyvsp[-2].name), (yyvsp[0].etree)); }
     break;
 
   case 21:
 #line 217 "ldgram.y"
-    { mri_public((yyvsp[(2) - (4)].name), (yyvsp[(4) - (4)].etree)); }
+    { mri_public((yyvsp[-2].name), (yyvsp[0].etree)); }
     break;
 
   case 22:
 #line 219 "ldgram.y"
-    { mri_public((yyvsp[(2) - (3)].name), (yyvsp[(3) - (3)].etree)); }
+    { mri_public((yyvsp[-1].name), (yyvsp[0].etree)); }
     break;
 
   case 23:
 #line 221 "ldgram.y"
-    { mri_format((yyvsp[(2) - (2)].name)); }
+    { mri_format((yyvsp[0].name)); }
     break;
 
   case 24:
 #line 223 "ldgram.y"
-    { mri_output_section((yyvsp[(2) - (4)].name), (yyvsp[(4) - (4)].etree));}
+    { mri_output_section((yyvsp[-2].name), (yyvsp[0].etree));}
     break;
 
   case 25:
 #line 225 "ldgram.y"
-    { mri_output_section((yyvsp[(2) - (3)].name), (yyvsp[(3) - (3)].etree));}
+    { mri_output_section((yyvsp[-1].name), (yyvsp[0].etree));}
     break;
 
   case 26:
 #line 227 "ldgram.y"
-    { mri_output_section((yyvsp[(2) - (4)].name), (yyvsp[(4) - (4)].etree));}
+    { mri_output_section((yyvsp[-2].name), (yyvsp[0].etree));}
     break;
 
   case 27:
 #line 229 "ldgram.y"
-    { mri_align((yyvsp[(2) - (4)].name),(yyvsp[(4) - (4)].etree)); }
+    { mri_align((yyvsp[-2].name),(yyvsp[0].etree)); }
     break;
 
   case 28:
 #line 231 "ldgram.y"
-    { mri_align((yyvsp[(2) - (4)].name),(yyvsp[(4) - (4)].etree)); }
+    { mri_align((yyvsp[-2].name),(yyvsp[0].etree)); }
     break;
 
   case 29:
 #line 233 "ldgram.y"
-    { mri_alignmod((yyvsp[(2) - (4)].name),(yyvsp[(4) - (4)].etree)); }
+    { mri_alignmod((yyvsp[-2].name),(yyvsp[0].etree)); }
     break;
 
   case 30:
 #line 235 "ldgram.y"
-    { mri_alignmod((yyvsp[(2) - (4)].name),(yyvsp[(4) - (4)].etree)); }
+    { mri_alignmod((yyvsp[-2].name),(yyvsp[0].etree)); }
     break;
 
   case 33:
 #line 239 "ldgram.y"
-    { mri_name((yyvsp[(2) - (2)].name)); }
+    { mri_name((yyvsp[0].name)); }
     break;
 
   case 34:
 #line 241 "ldgram.y"
-    { mri_alias((yyvsp[(2) - (4)].name),(yyvsp[(4) - (4)].name),0);}
+    { mri_alias((yyvsp[-2].name),(yyvsp[0].name),0);}
     break;
 
   case 35:
 #line 243 "ldgram.y"
-    { mri_alias ((yyvsp[(2) - (4)].name), 0, (int) (yyvsp[(4) - (4)].bigint).integer); }
+    { mri_alias ((yyvsp[-2].name), 0, (int) (yyvsp[0].bigint).integer); }
     break;
 
   case 36:
 #line 245 "ldgram.y"
-    { mri_base((yyvsp[(2) - (2)].etree)); }
+    { mri_base((yyvsp[0].etree)); }
     break;
 
   case 37:
 #line 247 "ldgram.y"
-    { mri_truncate ((unsigned int) (yyvsp[(2) - (2)].bigint).integer); }
+    { mri_truncate ((unsigned int) (yyvsp[0].bigint).integer); }
     break;
 
   case 40:
 #line 251 "ldgram.y"
-    { ldlex_script (); ldfile_open_command_file((yyvsp[(2) - (2)].name)); }
+    { ldlex_script (); ldfile_open_command_file((yyvsp[0].name)); }
     break;
 
   case 41:
@@ -2641,37 +2441,37 @@
 
   case 42:
 #line 255 "ldgram.y"
-    { lang_add_entry ((yyvsp[(2) - (2)].name), FALSE); }
+    { lang_add_entry ((yyvsp[0].name), FALSE); }
     break;
 
   case 44:
 #line 260 "ldgram.y"
-    { mri_order((yyvsp[(3) - (3)].name)); }
+    { mri_order((yyvsp[0].name)); }
     break;
 
   case 45:
 #line 261 "ldgram.y"
-    { mri_order((yyvsp[(2) - (2)].name)); }
+    { mri_order((yyvsp[0].name)); }
     break;
 
   case 47:
 #line 267 "ldgram.y"
-    { mri_load((yyvsp[(1) - (1)].name)); }
+    { mri_load((yyvsp[0].name)); }
     break;
 
   case 48:
 #line 268 "ldgram.y"
-    { mri_load((yyvsp[(3) - (3)].name)); }
+    { mri_load((yyvsp[0].name)); }
     break;
 
   case 49:
 #line 273 "ldgram.y"
-    { mri_only_load((yyvsp[(1) - (1)].name)); }
+    { mri_only_load((yyvsp[0].name)); }
     break;
 
   case 50:
 #line 275 "ldgram.y"
-    { mri_only_load((yyvsp[(3) - (3)].name)); }
+    { mri_only_load((yyvsp[0].name)); }
     break;
 
   case 51:
@@ -2691,17 +2491,17 @@
 
   case 56:
 #line 292 "ldgram.y"
-    { ldlang_add_undef ((yyvsp[(1) - (1)].name)); }
+    { ldlang_add_undef ((yyvsp[0].name)); }
     break;
 
   case 57:
 #line 294 "ldgram.y"
-    { ldlang_add_undef ((yyvsp[(2) - (2)].name)); }
+    { ldlang_add_undef ((yyvsp[0].name)); }
     break;
 
   case 58:
 #line 296 "ldgram.y"
-    { ldlang_add_undef ((yyvsp[(3) - (3)].name)); }
+    { ldlang_add_undef ((yyvsp[0].name)); }
     break;
 
   case 59:
@@ -2716,33 +2516,33 @@
 
   case 73:
 #line 323 "ldgram.y"
-    { lang_add_target((yyvsp[(3) - (4)].name)); }
+    { lang_add_target((yyvsp[-1].name)); }
     break;
 
   case 74:
 #line 325 "ldgram.y"
-    { ldfile_add_library_path ((yyvsp[(3) - (4)].name), FALSE); }
+    { ldfile_add_library_path ((yyvsp[-1].name), FALSE); }
     break;
 
   case 75:
 #line 327 "ldgram.y"
-    { lang_add_output((yyvsp[(3) - (4)].name), 1); }
+    { lang_add_output((yyvsp[-1].name), 1); }
     break;
 
   case 76:
 #line 329 "ldgram.y"
-    { lang_add_output_format ((yyvsp[(3) - (4)].name), (char *) NULL,
+    { lang_add_output_format ((yyvsp[-1].name), (char *) NULL,
 					    (char *) NULL, 1); }
     break;
 
   case 77:
 #line 332 "ldgram.y"
-    { lang_add_output_format ((yyvsp[(3) - (8)].name), (yyvsp[(5) - (8)].name), (yyvsp[(7) - (8)].name), 1); }
+    { lang_add_output_format ((yyvsp[-5].name), (yyvsp[-3].name), (yyvsp[-1].name), 1); }
     break;
 
   case 78:
 #line 334 "ldgram.y"
-    { ldfile_set_output_arch ((yyvsp[(3) - (4)].name), bfd_arch_unknown); }
+    { ldfile_set_output_arch ((yyvsp[-1].name), bfd_arch_unknown); }
     break;
 
   case 79:
@@ -2767,12 +2567,12 @@
 
   case 84:
 #line 345 "ldgram.y"
-    { lang_add_map((yyvsp[(3) - (4)].name)); }
+    { lang_add_map((yyvsp[-1].name)); }
     break;
 
   case 85:
 #line 347 "ldgram.y"
-    { ldlex_script (); ldfile_open_command_file((yyvsp[(2) - (2)].name)); }
+    { ldlex_script (); ldfile_open_command_file((yyvsp[0].name)); }
     break;
 
   case 86:
@@ -2783,43 +2583,43 @@
   case 87:
 #line 351 "ldgram.y"
     {
-		  lang_add_nocrossref ((yyvsp[(3) - (4)].nocrossref));
+		  lang_add_nocrossref ((yyvsp[-1].nocrossref));
 		}
     break;
 
   case 89:
 #line 359 "ldgram.y"
-    { lang_add_input_file((yyvsp[(1) - (1)].name),lang_input_file_is_search_file_enum,
+    { lang_add_input_file((yyvsp[0].name),lang_input_file_is_search_file_enum,
 				 (char *)NULL); }
     break;
 
   case 90:
 #line 362 "ldgram.y"
-    { lang_add_input_file((yyvsp[(3) - (3)].name),lang_input_file_is_search_file_enum,
+    { lang_add_input_file((yyvsp[0].name),lang_input_file_is_search_file_enum,
 				 (char *)NULL); }
     break;
 
   case 91:
 #line 365 "ldgram.y"
-    { lang_add_input_file((yyvsp[(2) - (2)].name),lang_input_file_is_search_file_enum,
+    { lang_add_input_file((yyvsp[0].name),lang_input_file_is_search_file_enum,
 				 (char *)NULL); }
     break;
 
   case 92:
 #line 368 "ldgram.y"
-    { lang_add_input_file((yyvsp[(1) - (1)].name),lang_input_file_is_l_enum,
+    { lang_add_input_file((yyvsp[0].name),lang_input_file_is_l_enum,
 				 (char *)NULL); }
     break;
 
   case 93:
 #line 371 "ldgram.y"
-    { lang_add_input_file((yyvsp[(3) - (3)].name),lang_input_file_is_l_enum,
+    { lang_add_input_file((yyvsp[0].name),lang_input_file_is_l_enum,
 				 (char *)NULL); }
     break;
 
   case 94:
 #line 374 "ldgram.y"
-    { lang_add_input_file((yyvsp[(2) - (2)].name),lang_input_file_is_l_enum,
+    { lang_add_input_file((yyvsp[0].name),lang_input_file_is_l_enum,
 				 (char *)NULL); }
     break;
 
@@ -2830,7 +2630,7 @@
 
   case 96:
 #line 379 "ldgram.y"
-    { as_needed = (yyvsp[(3) - (5)].integer); }
+    { as_needed = (yyvsp[-2].integer); }
     break;
 
   case 97:
@@ -2840,7 +2640,7 @@
 
   case 98:
 #line 383 "ldgram.y"
-    { as_needed = (yyvsp[(5) - (7)].integer); }
+    { as_needed = (yyvsp[-2].integer); }
     break;
 
   case 99:
@@ -2850,12 +2650,12 @@
 
   case 100:
 #line 387 "ldgram.y"
-    { as_needed = (yyvsp[(4) - (6)].integer); }
+    { as_needed = (yyvsp[-2].integer); }
     break;
 
   case 105:
 #line 402 "ldgram.y"
-    { lang_add_entry ((yyvsp[(3) - (4)].name), FALSE); }
+    { lang_add_entry ((yyvsp[-1].name), FALSE); }
     break;
 
   case 107:
@@ -2866,13 +2666,13 @@
   case 108:
 #line 405 "ldgram.y"
     { ldlex_popstate ();
-		  lang_add_assignment (exp_assert ((yyvsp[(4) - (7)].etree), (yyvsp[(6) - (7)].name))); }
+		  lang_add_assignment (exp_assert ((yyvsp[-3].etree), (yyvsp[-1].name))); }
     break;
 
   case 109:
 #line 413 "ldgram.y"
     {
-			  (yyval.cname) = (yyvsp[(1) - (1)].name);
+			  (yyval.cname) = (yyvsp[0].name);
 			}
     break;
 
@@ -2893,7 +2693,7 @@
   case 112:
 #line 428 "ldgram.y"
     {
-			  (yyval.wildcard).name = (yyvsp[(1) - (1)].cname);
+			  (yyval.wildcard).name = (yyvsp[0].cname);
 			  (yyval.wildcard).sorted = none;
 			  (yyval.wildcard).exclude_name_list = NULL;
 			}
@@ -2902,16 +2702,16 @@
   case 113:
 #line 434 "ldgram.y"
     {
-			  (yyval.wildcard).name = (yyvsp[(5) - (5)].cname);
+			  (yyval.wildcard).name = (yyvsp[0].cname);
 			  (yyval.wildcard).sorted = none;
-			  (yyval.wildcard).exclude_name_list = (yyvsp[(3) - (5)].name_list);
+			  (yyval.wildcard).exclude_name_list = (yyvsp[-2].name_list);
 			}
     break;
 
   case 114:
 #line 440 "ldgram.y"
     {
-			  (yyval.wildcard).name = (yyvsp[(3) - (4)].cname);
+			  (yyval.wildcard).name = (yyvsp[-1].cname);
 			  (yyval.wildcard).sorted = by_name;
 			  (yyval.wildcard).exclude_name_list = NULL;
 			}
@@ -2920,7 +2720,7 @@
   case 115:
 #line 446 "ldgram.y"
     {
-			  (yyval.wildcard).name = (yyvsp[(3) - (4)].cname);
+			  (yyval.wildcard).name = (yyvsp[-1].cname);
 			  (yyval.wildcard).sorted = by_alignment;
 			  (yyval.wildcard).exclude_name_list = NULL;
 			}
@@ -2929,7 +2729,7 @@
   case 116:
 #line 452 "ldgram.y"
     {
-			  (yyval.wildcard).name = (yyvsp[(5) - (7)].cname);
+			  (yyval.wildcard).name = (yyvsp[-2].cname);
 			  (yyval.wildcard).sorted = by_name_alignment;
 			  (yyval.wildcard).exclude_name_list = NULL;
 			}
@@ -2938,7 +2738,7 @@
   case 117:
 #line 458 "ldgram.y"
     {
-			  (yyval.wildcard).name = (yyvsp[(5) - (7)].cname);
+			  (yyval.wildcard).name = (yyvsp[-2].cname);
 			  (yyval.wildcard).sorted = by_name;
 			  (yyval.wildcard).exclude_name_list = NULL;
 			}
@@ -2947,7 +2747,7 @@
   case 118:
 #line 464 "ldgram.y"
     {
-			  (yyval.wildcard).name = (yyvsp[(5) - (7)].cname);
+			  (yyval.wildcard).name = (yyvsp[-2].cname);
 			  (yyval.wildcard).sorted = by_alignment_name;
 			  (yyval.wildcard).exclude_name_list = NULL;
 			}
@@ -2956,7 +2756,7 @@
   case 119:
 #line 470 "ldgram.y"
     {
-			  (yyval.wildcard).name = (yyvsp[(5) - (7)].cname);
+			  (yyval.wildcard).name = (yyvsp[-2].cname);
 			  (yyval.wildcard).sorted = by_alignment;
 			  (yyval.wildcard).exclude_name_list = NULL;
 			}
@@ -2965,9 +2765,9 @@
   case 120:
 #line 476 "ldgram.y"
     {
-			  (yyval.wildcard).name = (yyvsp[(7) - (8)].cname);
+			  (yyval.wildcard).name = (yyvsp[-1].cname);
 			  (yyval.wildcard).sorted = by_name;
-			  (yyval.wildcard).exclude_name_list = (yyvsp[(5) - (8)].name_list);
+			  (yyval.wildcard).exclude_name_list = (yyvsp[-3].name_list);
 			}
     break;
 
@@ -2976,8 +2776,8 @@
     {
 			  struct name_list *tmp;
 			  tmp = (struct name_list *) xmalloc (sizeof *tmp);
-			  tmp->name = (yyvsp[(2) - (2)].cname);
-			  tmp->next = (yyvsp[(1) - (2)].name_list);
+			  tmp->name = (yyvsp[0].cname);
+			  tmp->next = (yyvsp[-1].name_list);
 			  (yyval.name_list) = tmp;
 			}
     break;
@@ -2987,7 +2787,7 @@
     {
 			  struct name_list *tmp;
 			  tmp = (struct name_list *) xmalloc (sizeof *tmp);
-			  tmp->name = (yyvsp[(1) - (1)].cname);
+			  tmp->name = (yyvsp[0].cname);
 			  tmp->next = NULL;
 			  (yyval.name_list) = tmp;
 			}
@@ -2998,8 +2798,8 @@
     {
 			  struct wildcard_list *tmp;
 			  tmp = (struct wildcard_list *) xmalloc (sizeof *tmp);
-			  tmp->next = (yyvsp[(1) - (3)].wildcard_list);
-			  tmp->spec = (yyvsp[(3) - (3)].wildcard);
+			  tmp->next = (yyvsp[-2].wildcard_list);
+			  tmp->spec = (yyvsp[0].wildcard);
 			  (yyval.wildcard_list) = tmp;
 			}
     break;
@@ -3010,7 +2810,7 @@
 			  struct wildcard_list *tmp;
 			  tmp = (struct wildcard_list *) xmalloc (sizeof *tmp);
 			  tmp->next = NULL;
-			  tmp->spec = (yyvsp[(1) - (1)].wildcard);
+			  tmp->spec = (yyvsp[0].wildcard);
 			  (yyval.wildcard_list) = tmp;
 			}
     break;
@@ -3019,7 +2819,7 @@
 #line 525 "ldgram.y"
     {
 			  struct wildcard_spec tmp;
-			  tmp.name = (yyvsp[(1) - (1)].name);
+			  tmp.name = (yyvsp[0].name);
 			  tmp.exclude_name_list = NULL;
 			  tmp.sorted = none;
 			  lang_add_wild (&tmp, NULL, ldgram_had_keep);
@@ -3029,14 +2829,14 @@
   case 126:
 #line 533 "ldgram.y"
     {
-			  lang_add_wild (NULL, (yyvsp[(2) - (3)].wildcard_list), ldgram_had_keep);
+			  lang_add_wild (NULL, (yyvsp[-1].wildcard_list), ldgram_had_keep);
 			}
     break;
 
   case 127:
 #line 537 "ldgram.y"
     {
-			  lang_add_wild (&(yyvsp[(1) - (4)].wildcard), (yyvsp[(3) - (4)].wildcard_list), ldgram_had_keep);
+			  lang_add_wild (&(yyvsp[-3].wildcard), (yyvsp[-1].wildcard_list), ldgram_had_keep);
 			}
     break;
 
@@ -3076,14 +2876,14 @@
   case 137:
 #line 569 "ldgram.y"
     {
-			  lang_add_data ((int) (yyvsp[(1) - (4)].integer), (yyvsp[(3) - (4)].etree));
+			  lang_add_data ((int) (yyvsp[-3].integer), (yyvsp[-1].etree));
 			}
     break;
 
   case 138:
 #line 574 "ldgram.y"
     {
-			  lang_add_fill ((yyvsp[(3) - (4)].fill));
+			  lang_add_fill ((yyvsp[-1].fill));
 			}
     break;
 
@@ -3095,44 +2895,44 @@
   case 140:
 #line 578 "ldgram.y"
     { ldlex_popstate ();
-			  lang_add_assignment (exp_assert ((yyvsp[(4) - (8)].etree), (yyvsp[(6) - (8)].name))); }
+			  lang_add_assignment (exp_assert ((yyvsp[-4].etree), (yyvsp[-2].name))); }
     break;
 
   case 145:
 #line 594 "ldgram.y"
-    { (yyval.integer) = (yyvsp[(1) - (1)].token); }
+    { (yyval.integer) = (yyvsp[0].token); }
     break;
 
   case 146:
 #line 596 "ldgram.y"
-    { (yyval.integer) = (yyvsp[(1) - (1)].token); }
+    { (yyval.integer) = (yyvsp[0].token); }
     break;
 
   case 147:
 #line 598 "ldgram.y"
-    { (yyval.integer) = (yyvsp[(1) - (1)].token); }
+    { (yyval.integer) = (yyvsp[0].token); }
     break;
 
   case 148:
 #line 600 "ldgram.y"
-    { (yyval.integer) = (yyvsp[(1) - (1)].token); }
+    { (yyval.integer) = (yyvsp[0].token); }
     break;
 
   case 149:
 #line 602 "ldgram.y"
-    { (yyval.integer) = (yyvsp[(1) - (1)].token); }
+    { (yyval.integer) = (yyvsp[0].token); }
     break;
 
   case 150:
 #line 607 "ldgram.y"
     {
-		  (yyval.fill) = exp_get_fill ((yyvsp[(1) - (1)].etree), 0, "fill value");
+		  (yyval.fill) = exp_get_fill ((yyvsp[0].etree), 0, "fill value");
 		}
     break;
 
   case 151:
 #line 614 "ldgram.y"
-    { (yyval.fill) = (yyvsp[(2) - (2)].fill); }
+    { (yyval.fill) = (yyvsp[0].fill); }
     break;
 
   case 152:
@@ -3183,38 +2983,38 @@
   case 163:
 #line 644 "ldgram.y"
     {
-		  lang_add_assignment (exp_assop ((yyvsp[(2) - (3)].token), (yyvsp[(1) - (3)].name), (yyvsp[(3) - (3)].etree)));
+		  lang_add_assignment (exp_assop ((yyvsp[-1].token), (yyvsp[-2].name), (yyvsp[0].etree)));
 		}
     break;
 
   case 164:
 #line 648 "ldgram.y"
     {
-		  lang_add_assignment (exp_assop ('=', (yyvsp[(1) - (3)].name),
-						  exp_binop ((yyvsp[(2) - (3)].token),
+		  lang_add_assignment (exp_assop ('=', (yyvsp[-2].name),
+						  exp_binop ((yyvsp[-1].token),
 							     exp_nameop (NAME,
-									 (yyvsp[(1) - (3)].name)),
-							     (yyvsp[(3) - (3)].etree))));
+									 (yyvsp[-2].name)),
+							     (yyvsp[0].etree))));
 		}
     break;
 
   case 165:
 #line 656 "ldgram.y"
     {
-		  lang_add_assignment (exp_provide ((yyvsp[(3) - (6)].name), (yyvsp[(5) - (6)].etree), FALSE));
+		  lang_add_assignment (exp_provide ((yyvsp[-3].name), (yyvsp[-1].etree), FALSE));
 		}
     break;
 
   case 166:
 #line 660 "ldgram.y"
     {
-		  lang_add_assignment (exp_provide ((yyvsp[(3) - (6)].name), (yyvsp[(5) - (6)].etree), TRUE));
+		  lang_add_assignment (exp_provide ((yyvsp[-3].name), (yyvsp[-1].etree), TRUE));
 		}
     break;
 
   case 173:
 #line 682 "ldgram.y"
-    { region = lang_memory_region_lookup ((yyvsp[(1) - (1)].name), TRUE); }
+    { region = lang_memory_region_lookup ((yyvsp[0].name), TRUE); }
     break;
 
   case 174:
@@ -3225,7 +3025,7 @@
   case 175:
 #line 690 "ldgram.y"
     {
-		  region->origin = exp_get_vma ((yyvsp[(3) - (3)].etree), 0, "origin");
+		  region->origin = exp_get_vma ((yyvsp[0].etree), 0, "origin");
 		  region->current = region->origin;
 		}
     break;
@@ -3233,7 +3033,7 @@
   case 176:
 #line 698 "ldgram.y"
     {
-		  region->length = exp_get_vma ((yyvsp[(3) - (3)].etree), -1, "length");
+		  region->length = exp_get_vma ((yyvsp[0].etree), -1, "length");
 		}
     break;
 
@@ -3244,17 +3044,17 @@
 
   case 181:
 #line 716 "ldgram.y"
-    { lang_set_flags (region, (yyvsp[(1) - (1)].name), 0); }
+    { lang_set_flags (region, (yyvsp[0].name), 0); }
     break;
 
   case 182:
 #line 718 "ldgram.y"
-    { lang_set_flags (region, (yyvsp[(2) - (2)].name), 1); }
+    { lang_set_flags (region, (yyvsp[0].name), 1); }
     break;
 
   case 183:
 #line 723 "ldgram.y"
-    { lang_startup((yyvsp[(3) - (4)].name)); }
+    { lang_startup((yyvsp[-1].name)); }
     break;
 
   case 185:
@@ -3264,17 +3064,17 @@
 
   case 186:
 #line 734 "ldgram.y"
-    { ldemul_hll((yyvsp[(3) - (3)].name)); }
+    { ldemul_hll((yyvsp[0].name)); }
     break;
 
   case 187:
 #line 736 "ldgram.y"
-    { ldemul_hll((yyvsp[(1) - (1)].name)); }
+    { ldemul_hll((yyvsp[0].name)); }
     break;
 
   case 189:
 #line 744 "ldgram.y"
-    { ldemul_syslib((yyvsp[(3) - (3)].name)); }
+    { ldemul_syslib((yyvsp[0].name)); }
     break;
 
   case 191:
@@ -3300,8 +3100,8 @@
 		  struct lang_nocrossref *n;
 
 		  n = (struct lang_nocrossref *) xmalloc (sizeof *n);
-		  n->name = (yyvsp[(1) - (2)].name);
-		  n->next = (yyvsp[(2) - (2)].nocrossref);
+		  n->name = (yyvsp[-1].name);
+		  n->next = (yyvsp[0].nocrossref);
 		  (yyval.nocrossref) = n;
 		}
     break;
@@ -3312,8 +3112,8 @@
 		  struct lang_nocrossref *n;
 
 		  n = (struct lang_nocrossref *) xmalloc (sizeof *n);
-		  n->name = (yyvsp[(1) - (3)].name);
-		  n->next = (yyvsp[(3) - (3)].nocrossref);
+		  n->name = (yyvsp[-2].name);
+		  n->next = (yyvsp[0].nocrossref);
 		  (yyval.nocrossref) = n;
 		}
     break;
@@ -3325,142 +3125,142 @@
 
   case 197:
 #line 782 "ldgram.y"
-    { ldlex_popstate (); (yyval.etree)=(yyvsp[(2) - (2)].etree);}
+    { ldlex_popstate (); (yyval.etree)=(yyvsp[0].etree);}
     break;
 
   case 198:
 #line 787 "ldgram.y"
-    { (yyval.etree) = exp_unop ('-', (yyvsp[(2) - (2)].etree)); }
+    { (yyval.etree) = exp_unop ('-', (yyvsp[0].etree)); }
     break;
 
   case 199:
 #line 789 "ldgram.y"
-    { (yyval.etree) = (yyvsp[(2) - (3)].etree); }
+    { (yyval.etree) = (yyvsp[-1].etree); }
     break;
 
   case 200:
 #line 791 "ldgram.y"
-    { (yyval.etree) = exp_unop ((int) (yyvsp[(1) - (4)].integer),(yyvsp[(3) - (4)].etree)); }
+    { (yyval.etree) = exp_unop ((int) (yyvsp[-3].integer),(yyvsp[-1].etree)); }
     break;
 
   case 201:
 #line 793 "ldgram.y"
-    { (yyval.etree) = exp_unop ('!', (yyvsp[(2) - (2)].etree)); }
+    { (yyval.etree) = exp_unop ('!', (yyvsp[0].etree)); }
     break;
 
   case 202:
 #line 795 "ldgram.y"
-    { (yyval.etree) = (yyvsp[(2) - (2)].etree); }
+    { (yyval.etree) = (yyvsp[0].etree); }
     break;
 
   case 203:
 #line 797 "ldgram.y"
-    { (yyval.etree) = exp_unop ('~', (yyvsp[(2) - (2)].etree));}
+    { (yyval.etree) = exp_unop ('~', (yyvsp[0].etree));}
     break;
 
   case 204:
 #line 800 "ldgram.y"
-    { (yyval.etree) = exp_binop ('*', (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    { (yyval.etree) = exp_binop ('*', (yyvsp[-2].etree), (yyvsp[0].etree)); }
     break;
 
   case 205:
 #line 802 "ldgram.y"
-    { (yyval.etree) = exp_binop ('/', (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    { (yyval.etree) = exp_binop ('/', (yyvsp[-2].etree), (yyvsp[0].etree)); }
     break;
 
   case 206:
 #line 804 "ldgram.y"
-    { (yyval.etree) = exp_binop ('%', (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    { (yyval.etree) = exp_binop ('%', (yyvsp[-2].etree), (yyvsp[0].etree)); }
     break;
 
   case 207:
 #line 806 "ldgram.y"
-    { (yyval.etree) = exp_binop ('+', (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    { (yyval.etree) = exp_binop ('+', (yyvsp[-2].etree), (yyvsp[0].etree)); }
     break;
 
   case 208:
 #line 808 "ldgram.y"
-    { (yyval.etree) = exp_binop ('-' , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    { (yyval.etree) = exp_binop ('-' , (yyvsp[-2].etree), (yyvsp[0].etree)); }
     break;
 
   case 209:
 #line 810 "ldgram.y"
-    { (yyval.etree) = exp_binop (LSHIFT , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    { (yyval.etree) = exp_binop (LSHIFT , (yyvsp[-2].etree), (yyvsp[0].etree)); }
     break;
 
   case 210:
 #line 812 "ldgram.y"
-    { (yyval.etree) = exp_binop (RSHIFT , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    { (yyval.etree) = exp_binop (RSHIFT , (yyvsp[-2].etree), (yyvsp[0].etree)); }
     break;
 
   case 211:
 #line 814 "ldgram.y"
-    { (yyval.etree) = exp_binop (EQ , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    { (yyval.etree) = exp_binop (EQ , (yyvsp[-2].etree), (yyvsp[0].etree)); }
     break;
 
   case 212:
 #line 816 "ldgram.y"
-    { (yyval.etree) = exp_binop (NE , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    { (yyval.etree) = exp_binop (NE , (yyvsp[-2].etree), (yyvsp[0].etree)); }
     break;
 
   case 213:
 #line 818 "ldgram.y"
-    { (yyval.etree) = exp_binop (LE , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    { (yyval.etree) = exp_binop (LE , (yyvsp[-2].etree), (yyvsp[0].etree)); }
     break;
 
   case 214:
 #line 820 "ldgram.y"
-    { (yyval.etree) = exp_binop (GE , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    { (yyval.etree) = exp_binop (GE , (yyvsp[-2].etree), (yyvsp[0].etree)); }
     break;
 
   case 215:
 #line 822 "ldgram.y"
-    { (yyval.etree) = exp_binop ('<' , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    { (yyval.etree) = exp_binop ('<' , (yyvsp[-2].etree), (yyvsp[0].etree)); }
     break;
 
   case 216:
 #line 824 "ldgram.y"
-    { (yyval.etree) = exp_binop ('>' , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    { (yyval.etree) = exp_binop ('>' , (yyvsp[-2].etree), (yyvsp[0].etree)); }
     break;
 
   case 217:
 #line 826 "ldgram.y"
-    { (yyval.etree) = exp_binop ('&' , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    { (yyval.etree) = exp_binop ('&' , (yyvsp[-2].etree), (yyvsp[0].etree)); }
     break;
 
   case 218:
 #line 828 "ldgram.y"
-    { (yyval.etree) = exp_binop ('^' , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    { (yyval.etree) = exp_binop ('^' , (yyvsp[-2].etree), (yyvsp[0].etree)); }
     break;
 
   case 219:
 #line 830 "ldgram.y"
-    { (yyval.etree) = exp_binop ('|' , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    { (yyval.etree) = exp_binop ('|' , (yyvsp[-2].etree), (yyvsp[0].etree)); }
     break;
 
   case 220:
 #line 832 "ldgram.y"
-    { (yyval.etree) = exp_trinop ('?' , (yyvsp[(1) - (5)].etree), (yyvsp[(3) - (5)].etree), (yyvsp[(5) - (5)].etree)); }
+    { (yyval.etree) = exp_trinop ('?' , (yyvsp[-4].etree), (yyvsp[-2].etree), (yyvsp[0].etree)); }
     break;
 
   case 221:
 #line 834 "ldgram.y"
-    { (yyval.etree) = exp_binop (ANDAND , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    { (yyval.etree) = exp_binop (ANDAND , (yyvsp[-2].etree), (yyvsp[0].etree)); }
     break;
 
   case 222:
 #line 836 "ldgram.y"
-    { (yyval.etree) = exp_binop (OROR , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    { (yyval.etree) = exp_binop (OROR , (yyvsp[-2].etree), (yyvsp[0].etree)); }
     break;
 
   case 223:
 #line 838 "ldgram.y"
-    { (yyval.etree) = exp_nameop (DEFINED, (yyvsp[(3) - (4)].name)); }
+    { (yyval.etree) = exp_nameop (DEFINED, (yyvsp[-1].name)); }
     break;
 
   case 224:
 #line 840 "ldgram.y"
-    { (yyval.etree) = exp_bigintop ((yyvsp[(1) - (1)].bigint).integer, (yyvsp[(1) - (1)].bigint).str); }
+    { (yyval.etree) = exp_bigintop ((yyvsp[0].bigint).integer, (yyvsp[0].bigint).str); }
     break;
 
   case 225:
@@ -3470,57 +3270,57 @@
 
   case 226:
 #line 845 "ldgram.y"
-    { (yyval.etree) = exp_nameop (ALIGNOF,(yyvsp[(3) - (4)].name)); }
+    { (yyval.etree) = exp_nameop (ALIGNOF,(yyvsp[-1].name)); }
     break;
 
   case 227:
 #line 847 "ldgram.y"
-    { (yyval.etree) = exp_nameop (SIZEOF,(yyvsp[(3) - (4)].name)); }
+    { (yyval.etree) = exp_nameop (SIZEOF,(yyvsp[-1].name)); }
     break;
 
   case 228:
 #line 849 "ldgram.y"
-    { (yyval.etree) = exp_nameop (ADDR,(yyvsp[(3) - (4)].name)); }
+    { (yyval.etree) = exp_nameop (ADDR,(yyvsp[-1].name)); }
     break;
 
   case 229:
 #line 851 "ldgram.y"
-    { (yyval.etree) = exp_nameop (LOADADDR,(yyvsp[(3) - (4)].name)); }
+    { (yyval.etree) = exp_nameop (LOADADDR,(yyvsp[-1].name)); }
     break;
 
   case 230:
 #line 853 "ldgram.y"
-    { (yyval.etree) = exp_nameop (CONSTANT,(yyvsp[(3) - (4)].name)); }
+    { (yyval.etree) = exp_nameop (CONSTANT,(yyvsp[-1].name)); }
     break;
 
   case 231:
 #line 855 "ldgram.y"
-    { (yyval.etree) = exp_unop (ABSOLUTE, (yyvsp[(3) - (4)].etree)); }
+    { (yyval.etree) = exp_unop (ABSOLUTE, (yyvsp[-1].etree)); }
     break;
 
   case 232:
 #line 857 "ldgram.y"
-    { (yyval.etree) = exp_unop (ALIGN_K,(yyvsp[(3) - (4)].etree)); }
+    { (yyval.etree) = exp_unop (ALIGN_K,(yyvsp[-1].etree)); }
     break;
 
   case 233:
 #line 859 "ldgram.y"
-    { (yyval.etree) = exp_binop (ALIGN_K,(yyvsp[(3) - (6)].etree),(yyvsp[(5) - (6)].etree)); }
+    { (yyval.etree) = exp_binop (ALIGN_K,(yyvsp[-3].etree),(yyvsp[-1].etree)); }
     break;
 
   case 234:
 #line 861 "ldgram.y"
-    { (yyval.etree) = exp_binop (DATA_SEGMENT_ALIGN, (yyvsp[(3) - (6)].etree), (yyvsp[(5) - (6)].etree)); }
+    { (yyval.etree) = exp_binop (DATA_SEGMENT_ALIGN, (yyvsp[-3].etree), (yyvsp[-1].etree)); }
     break;
 
   case 235:
 #line 863 "ldgram.y"
-    { (yyval.etree) = exp_binop (DATA_SEGMENT_RELRO_END, (yyvsp[(5) - (6)].etree), (yyvsp[(3) - (6)].etree)); }
+    { (yyval.etree) = exp_binop (DATA_SEGMENT_RELRO_END, (yyvsp[-1].etree), (yyvsp[-3].etree)); }
     break;
 
   case 236:
 #line 865 "ldgram.y"
-    { (yyval.etree) = exp_unop (DATA_SEGMENT_END, (yyvsp[(3) - (4)].etree)); }
+    { (yyval.etree) = exp_unop (DATA_SEGMENT_END, (yyvsp[-1].etree)); }
     break;
 
   case 237:
@@ -3531,338 +3331,348 @@
 			     that allows us to reuse more code in
 			     fold_binary.  */
 			  (yyval.etree) = exp_binop (SEGMENT_START,
-					  (yyvsp[(5) - (6)].etree),
-					  exp_nameop (NAME, (yyvsp[(3) - (6)].name))); }
+					  (yyvsp[-1].etree),
+					  exp_nameop (NAME, (yyvsp[-3].name))); }
     break;
 
   case 238:
 #line 876 "ldgram.y"
-    { (yyval.etree) = exp_unop (ALIGN_K,(yyvsp[(3) - (4)].etree)); }
+    { (yyval.etree) = exp_unop (ALIGN_K,(yyvsp[-1].etree)); }
     break;
 
   case 239:
 #line 878 "ldgram.y"
-    { (yyval.etree) = exp_nameop (NAME,(yyvsp[(1) - (1)].name)); }
+    { (yyval.etree) = exp_nameop (NAME,(yyvsp[0].name)); }
     break;
 
   case 240:
 #line 880 "ldgram.y"
-    { (yyval.etree) = exp_binop (MAX_K, (yyvsp[(3) - (6)].etree), (yyvsp[(5) - (6)].etree) ); }
+    { (yyval.etree) = exp_binop (MAX_K, (yyvsp[-3].etree), (yyvsp[-1].etree) ); }
     break;
 
   case 241:
 #line 882 "ldgram.y"
-    { (yyval.etree) = exp_binop (MIN_K, (yyvsp[(3) - (6)].etree), (yyvsp[(5) - (6)].etree) ); }
+    { (yyval.etree) = exp_binop (MIN_K, (yyvsp[-3].etree), (yyvsp[-1].etree) ); }
     break;
 
   case 242:
 #line 884 "ldgram.y"
-    { (yyval.etree) = exp_assert ((yyvsp[(3) - (6)].etree), (yyvsp[(5) - (6)].name)); }
+    { (yyval.etree) = exp_unop (CEILP2, (yyvsp[-1].etree)); }
     break;
 
   case 243:
 #line 886 "ldgram.y"
-    { (yyval.etree) = exp_nameop (ORIGIN, (yyvsp[(3) - (4)].name)); }
+    { (yyval.etree) = exp_unop (NACL_MASK, (yyvsp[-1].etree)); }
     break;
 
   case 244:
 #line 888 "ldgram.y"
-    { (yyval.etree) = exp_nameop (LENGTH, (yyvsp[(3) - (4)].name)); }
+    { (yyval.etree) = exp_assert ((yyvsp[-3].etree), (yyvsp[-1].name)); }
     break;
 
   case 245:
-#line 893 "ldgram.y"
-    { (yyval.name) = (yyvsp[(3) - (3)].name); }
+#line 890 "ldgram.y"
+    { (yyval.etree) = exp_nameop (ORIGIN, (yyvsp[-1].name)); }
     break;
 
   case 246:
-#line 894 "ldgram.y"
-    { (yyval.name) = 0; }
+#line 892 "ldgram.y"
+    { (yyval.etree) = exp_nameop (LENGTH, (yyvsp[-1].name)); }
     break;
 
   case 247:
-#line 898 "ldgram.y"
-    { (yyval.etree) = (yyvsp[(3) - (4)].etree); }
+#line 897 "ldgram.y"
+    { (yyval.name) = (yyvsp[0].name); }
     break;
 
   case 248:
-#line 899 "ldgram.y"
-    { (yyval.etree) = 0; }
+#line 898 "ldgram.y"
+    { (yyval.name) = 0; }
     break;
 
   case 249:
-#line 903 "ldgram.y"
-    { (yyval.etree) = (yyvsp[(3) - (4)].etree); }
+#line 902 "ldgram.y"
+    { (yyval.etree) = (yyvsp[-1].etree); }
     break;
 
   case 250:
-#line 904 "ldgram.y"
+#line 903 "ldgram.y"
     { (yyval.etree) = 0; }
     break;
 
   case 251:
-#line 908 "ldgram.y"
-    { (yyval.etree) = (yyvsp[(3) - (4)].etree); }
+#line 907 "ldgram.y"
+    { (yyval.etree) = (yyvsp[-1].etree); }
     break;
 
   case 252:
-#line 909 "ldgram.y"
+#line 908 "ldgram.y"
     { (yyval.etree) = 0; }
     break;
 
   case 253:
-#line 913 "ldgram.y"
-    { (yyval.token) = ONLY_IF_RO; }
+#line 912 "ldgram.y"
+    { (yyval.etree) = (yyvsp[-1].etree); }
     break;
 
   case 254:
-#line 914 "ldgram.y"
-    { (yyval.token) = ONLY_IF_RW; }
+#line 913 "ldgram.y"
+    { (yyval.etree) = 0; }
     break;
 
   case 255:
-#line 915 "ldgram.y"
-    { (yyval.token) = SPECIAL; }
+#line 917 "ldgram.y"
+    { (yyval.token) = ONLY_IF_RO; }
     break;
 
   case 256:
-#line 916 "ldgram.y"
-    { (yyval.token) = 0; }
+#line 918 "ldgram.y"
+    { (yyval.token) = ONLY_IF_RW; }
     break;
 
   case 257:
 #line 919 "ldgram.y"
-    { ldlex_expression(); }
+    { (yyval.token) = SPECIAL; }
     break;
 
   case 258:
+#line 920 "ldgram.y"
+    { (yyval.token) = 0; }
+    break;
+
+  case 259:
 #line 923 "ldgram.y"
+    { ldlex_expression(); }
+    break;
+
+  case 260:
+#line 927 "ldgram.y"
     { ldlex_popstate (); ldlex_script (); }
     break;
 
-  case 259:
-#line 926 "ldgram.y"
+  case 261:
+#line 930 "ldgram.y"
     {
-			  lang_enter_output_section_statement((yyvsp[(1) - (9)].name), (yyvsp[(3) - (9)].etree),
+			  lang_enter_output_section_statement((yyvsp[-8].name), (yyvsp[-6].etree),
 							      sectype,
-							      (yyvsp[(5) - (9)].etree), (yyvsp[(6) - (9)].etree), (yyvsp[(4) - (9)].etree), (yyvsp[(8) - (9)].token));
+							      (yyvsp[-4].etree), (yyvsp[-3].etree), (yyvsp[-5].etree), (yyvsp[-1].token));
 			}
     break;
 
-  case 260:
-#line 932 "ldgram.y"
+  case 262:
+#line 936 "ldgram.y"
     { ldlex_popstate (); ldlex_expression (); }
     break;
 
-  case 261:
-#line 934 "ldgram.y"
+  case 263:
+#line 938 "ldgram.y"
     {
 		  ldlex_popstate ();
-		  lang_leave_output_section_statement ((yyvsp[(17) - (17)].fill), (yyvsp[(14) - (17)].name), (yyvsp[(16) - (17)].section_phdr), (yyvsp[(15) - (17)].name));
+		  lang_leave_output_section_statement ((yyvsp[0].fill), (yyvsp[-3].name), (yyvsp[-1].section_phdr), (yyvsp[-2].name));
 		}
     break;
 
-  case 262:
-#line 939 "ldgram.y"
+  case 264:
+#line 943 "ldgram.y"
     {}
     break;
 
-  case 263:
-#line 941 "ldgram.y"
+  case 265:
+#line 945 "ldgram.y"
     { ldlex_expression (); }
     break;
 
-  case 264:
-#line 943 "ldgram.y"
+  case 266:
+#line 947 "ldgram.y"
     { ldlex_popstate (); ldlex_script (); }
     break;
 
-  case 265:
-#line 945 "ldgram.y"
+  case 267:
+#line 949 "ldgram.y"
     {
-			  lang_enter_overlay ((yyvsp[(3) - (8)].etree), (yyvsp[(6) - (8)].etree));
+			  lang_enter_overlay ((yyvsp[-5].etree), (yyvsp[-2].etree));
 			}
     break;
 
-  case 266:
-#line 950 "ldgram.y"
+  case 268:
+#line 954 "ldgram.y"
     { ldlex_popstate (); ldlex_expression (); }
     break;
 
-  case 267:
-#line 952 "ldgram.y"
+  case 269:
+#line 956 "ldgram.y"
     {
 			  ldlex_popstate ();
-			  lang_leave_overlay ((yyvsp[(5) - (16)].etree), (int) (yyvsp[(4) - (16)].integer),
-					      (yyvsp[(16) - (16)].fill), (yyvsp[(13) - (16)].name), (yyvsp[(15) - (16)].section_phdr), (yyvsp[(14) - (16)].name));
+			  lang_leave_overlay ((yyvsp[-11].etree), (int) (yyvsp[-12].integer),
+					      (yyvsp[0].fill), (yyvsp[-3].name), (yyvsp[-1].section_phdr), (yyvsp[-2].name));
 			}
     break;
 
-  case 269:
-#line 962 "ldgram.y"
+  case 271:
+#line 966 "ldgram.y"
     { ldlex_expression (); }
     break;
 
-  case 270:
-#line 964 "ldgram.y"
+  case 272:
+#line 968 "ldgram.y"
     {
 		  ldlex_popstate ();
-		  lang_add_assignment (exp_assop ('=', ".", (yyvsp[(3) - (3)].etree)));
+		  lang_add_assignment (exp_assop ('=', ".", (yyvsp[0].etree)));
 		}
     break;
 
-  case 272:
-#line 972 "ldgram.y"
-    { sectype = noload_section; }
-    break;
-
-  case 273:
-#line 973 "ldgram.y"
-    { sectype = noalloc_section; }
-    break;
-
   case 274:
-#line 974 "ldgram.y"
-    { sectype = noalloc_section; }
+#line 976 "ldgram.y"
+    { sectype = noload_section; }
     break;
 
   case 275:
-#line 975 "ldgram.y"
+#line 977 "ldgram.y"
     { sectype = noalloc_section; }
     break;
 
   case 276:
-#line 976 "ldgram.y"
+#line 978 "ldgram.y"
     { sectype = noalloc_section; }
     break;
 
-  case 278:
-#line 981 "ldgram.y"
-    { sectype = normal_section; }
+  case 277:
+#line 979 "ldgram.y"
+    { sectype = noalloc_section; }
     break;
 
-  case 279:
-#line 982 "ldgram.y"
-    { sectype = normal_section; }
+  case 278:
+#line 980 "ldgram.y"
+    { sectype = noalloc_section; }
     break;
 
   case 280:
-#line 986 "ldgram.y"
-    { (yyval.etree) = (yyvsp[(1) - (3)].etree); }
+#line 985 "ldgram.y"
+    { sectype = normal_section; }
     break;
 
   case 281:
-#line 987 "ldgram.y"
-    { (yyval.etree) = (etree_type *)NULL;  }
+#line 986 "ldgram.y"
+    { sectype = normal_section; }
     break;
 
   case 282:
-#line 992 "ldgram.y"
-    { (yyval.etree) = (yyvsp[(3) - (6)].etree); }
+#line 990 "ldgram.y"
+    { (yyval.etree) = (yyvsp[-2].etree); }
     break;
 
   case 283:
-#line 994 "ldgram.y"
-    { (yyval.etree) = (yyvsp[(3) - (10)].etree); }
+#line 991 "ldgram.y"
+    { (yyval.etree) = (etree_type *)NULL;  }
     break;
 
   case 284:
-#line 998 "ldgram.y"
-    { (yyval.etree) = (yyvsp[(1) - (2)].etree); }
+#line 996 "ldgram.y"
+    { (yyval.etree) = (yyvsp[-3].etree); }
     break;
 
   case 285:
-#line 999 "ldgram.y"
-    { (yyval.etree) = (etree_type *) NULL;  }
+#line 998 "ldgram.y"
+    { (yyval.etree) = (yyvsp[-7].etree); }
     break;
 
   case 286:
-#line 1004 "ldgram.y"
-    { (yyval.integer) = 0; }
+#line 1002 "ldgram.y"
+    { (yyval.etree) = (yyvsp[-1].etree); }
     break;
 
   case 287:
-#line 1006 "ldgram.y"
-    { (yyval.integer) = 1; }
+#line 1003 "ldgram.y"
+    { (yyval.etree) = (etree_type *) NULL;  }
     break;
 
   case 288:
-#line 1011 "ldgram.y"
-    { (yyval.name) = (yyvsp[(2) - (2)].name); }
+#line 1008 "ldgram.y"
+    { (yyval.integer) = 0; }
     break;
 
   case 289:
-#line 1012 "ldgram.y"
-    { (yyval.name) = DEFAULT_MEMORY_REGION; }
+#line 1010 "ldgram.y"
+    { (yyval.integer) = 1; }
     break;
 
   case 290:
-#line 1017 "ldgram.y"
+#line 1015 "ldgram.y"
+    { (yyval.name) = (yyvsp[0].name); }
+    break;
+
+  case 291:
+#line 1016 "ldgram.y"
+    { (yyval.name) = DEFAULT_MEMORY_REGION; }
+    break;
+
+  case 292:
+#line 1021 "ldgram.y"
     {
 		  (yyval.section_phdr) = NULL;
 		}
     break;
 
-  case 291:
-#line 1021 "ldgram.y"
+  case 293:
+#line 1025 "ldgram.y"
     {
 		  struct lang_output_section_phdr_list *n;
 
 		  n = ((struct lang_output_section_phdr_list *)
 		       xmalloc (sizeof *n));
-		  n->name = (yyvsp[(3) - (3)].name);
+		  n->name = (yyvsp[0].name);
 		  n->used = FALSE;
-		  n->next = (yyvsp[(1) - (3)].section_phdr);
+		  n->next = (yyvsp[-2].section_phdr);
 		  (yyval.section_phdr) = n;
 		}
     break;
 
-  case 293:
-#line 1037 "ldgram.y"
+  case 295:
+#line 1041 "ldgram.y"
     {
 			  ldlex_script ();
-			  lang_enter_overlay_section ((yyvsp[(2) - (2)].name));
+			  lang_enter_overlay_section ((yyvsp[0].name));
 			}
     break;
 
-  case 294:
-#line 1042 "ldgram.y"
+  case 296:
+#line 1046 "ldgram.y"
     { ldlex_popstate (); ldlex_expression (); }
     break;
 
-  case 295:
-#line 1044 "ldgram.y"
+  case 297:
+#line 1048 "ldgram.y"
     {
 			  ldlex_popstate ();
-			  lang_leave_overlay_section ((yyvsp[(9) - (9)].fill), (yyvsp[(8) - (9)].section_phdr));
+			  lang_leave_overlay_section ((yyvsp[0].fill), (yyvsp[-1].section_phdr));
 			}
     break;
 
-  case 300:
-#line 1061 "ldgram.y"
+  case 302:
+#line 1065 "ldgram.y"
     { ldlex_expression (); }
     break;
 
-  case 301:
-#line 1062 "ldgram.y"
+  case 303:
+#line 1066 "ldgram.y"
     { ldlex_popstate (); }
     break;
 
-  case 302:
-#line 1064 "ldgram.y"
+  case 304:
+#line 1068 "ldgram.y"
     {
-		  lang_new_phdr ((yyvsp[(1) - (6)].name), (yyvsp[(3) - (6)].etree), (yyvsp[(4) - (6)].phdr).filehdr, (yyvsp[(4) - (6)].phdr).phdrs, (yyvsp[(4) - (6)].phdr).at,
-				 (yyvsp[(4) - (6)].phdr).flags);
+		  lang_new_phdr ((yyvsp[-5].name), (yyvsp[-3].etree), (yyvsp[-2].phdr).filehdr, (yyvsp[-2].phdr).phdrs, (yyvsp[-2].phdr).at,
+				 (yyvsp[-2].phdr).flags);
 		}
     break;
 
-  case 303:
-#line 1072 "ldgram.y"
+  case 305:
+#line 1076 "ldgram.y"
     {
-		  (yyval.etree) = (yyvsp[(1) - (1)].etree);
+		  (yyval.etree) = (yyvsp[0].etree);
 
-		  if ((yyvsp[(1) - (1)].etree)->type.node_class == etree_name
-		      && (yyvsp[(1) - (1)].etree)->type.node_code == NAME)
+		  if ((yyvsp[0].etree)->type.node_class == etree_name
+		      && (yyvsp[0].etree)->type.node_code == NAME)
 		    {
 		      const char *s;
 		      unsigned int i;
@@ -3873,7 +3683,7 @@
 			  "PT_PHDR", "PT_TLS"
 			};
 
-		      s = (yyvsp[(1) - (1)].etree)->name.name;
+		      s = (yyvsp[0].etree)->name.name;
 		      for (i = 0;
 			   i < sizeof phdr_types / sizeof phdr_types[0];
 			   i++)
@@ -3900,287 +3710,289 @@
 		}
     break;
 
-  case 304:
-#line 1116 "ldgram.y"
+  case 306:
+#line 1120 "ldgram.y"
     {
 		  memset (&(yyval.phdr), 0, sizeof (struct phdr_info));
 		}
     break;
 
-  case 305:
-#line 1120 "ldgram.y"
+  case 307:
+#line 1124 "ldgram.y"
     {
-		  (yyval.phdr) = (yyvsp[(3) - (3)].phdr);
-		  if (strcmp ((yyvsp[(1) - (3)].name), "FILEHDR") == 0 && (yyvsp[(2) - (3)].etree) == NULL)
+		  (yyval.phdr) = (yyvsp[0].phdr);
+		  if (strcmp ((yyvsp[-2].name), "FILEHDR") == 0 && (yyvsp[-1].etree) == NULL)
 		    (yyval.phdr).filehdr = TRUE;
-		  else if (strcmp ((yyvsp[(1) - (3)].name), "PHDRS") == 0 && (yyvsp[(2) - (3)].etree) == NULL)
+		  else if (strcmp ((yyvsp[-2].name), "PHDRS") == 0 && (yyvsp[-1].etree) == NULL)
 		    (yyval.phdr).phdrs = TRUE;
-		  else if (strcmp ((yyvsp[(1) - (3)].name), "FLAGS") == 0 && (yyvsp[(2) - (3)].etree) != NULL)
-		    (yyval.phdr).flags = (yyvsp[(2) - (3)].etree);
+		  else if (strcmp ((yyvsp[-2].name), "FLAGS") == 0 && (yyvsp[-1].etree) != NULL)
+		    (yyval.phdr).flags = (yyvsp[-1].etree);
 		  else
-		    einfo (_("%X%P:%S: PHDRS syntax error at `%s'\n"), (yyvsp[(1) - (3)].name));
+		    einfo (_("%X%P:%S: PHDRS syntax error at `%s'\n"), (yyvsp[-2].name));
 		}
     break;
 
-  case 306:
-#line 1132 "ldgram.y"
+  case 308:
+#line 1136 "ldgram.y"
     {
-		  (yyval.phdr) = (yyvsp[(5) - (5)].phdr);
-		  (yyval.phdr).at = (yyvsp[(3) - (5)].etree);
+		  (yyval.phdr) = (yyvsp[0].phdr);
+		  (yyval.phdr).at = (yyvsp[-2].etree);
 		}
     break;
 
-  case 307:
-#line 1140 "ldgram.y"
+  case 309:
+#line 1144 "ldgram.y"
     {
 		  (yyval.etree) = NULL;
 		}
     break;
 
-  case 308:
-#line 1144 "ldgram.y"
+  case 310:
+#line 1148 "ldgram.y"
     {
-		  (yyval.etree) = (yyvsp[(2) - (3)].etree);
+		  (yyval.etree) = (yyvsp[-1].etree);
 		}
     break;
 
-  case 309:
-#line 1150 "ldgram.y"
+  case 311:
+#line 1154 "ldgram.y"
     {
 		  ldlex_version_file ();
 		  PUSH_ERROR (_("dynamic list"));
 		}
     break;
 
-  case 310:
-#line 1155 "ldgram.y"
+  case 312:
+#line 1159 "ldgram.y"
     {
 		  ldlex_popstate ();
 		  POP_ERROR ();
 		}
     break;
 
-  case 314:
-#line 1172 "ldgram.y"
+  case 316:
+#line 1176 "ldgram.y"
     {
-		  lang_append_dynamic_list ((yyvsp[(1) - (2)].versyms));
+		  lang_append_dynamic_list ((yyvsp[-1].versyms));
 		}
     break;
 
-  case 315:
-#line 1180 "ldgram.y"
+  case 317:
+#line 1184 "ldgram.y"
     {
 		  ldlex_version_file ();
 		  PUSH_ERROR (_("VERSION script"));
 		}
     break;
 
-  case 316:
-#line 1185 "ldgram.y"
+  case 318:
+#line 1189 "ldgram.y"
     {
 		  ldlex_popstate ();
 		  POP_ERROR ();
 		}
     break;
 
-  case 317:
-#line 1194 "ldgram.y"
+  case 319:
+#line 1198 "ldgram.y"
     {
 		  ldlex_version_script ();
 		}
     break;
 
-  case 318:
-#line 1198 "ldgram.y"
+  case 320:
+#line 1202 "ldgram.y"
     {
 		  ldlex_popstate ();
 		}
     break;
 
-  case 321:
-#line 1210 "ldgram.y"
-    {
-		  lang_register_vers_node (NULL, (yyvsp[(2) - (4)].versnode), NULL);
-		}
-    break;
-
-  case 322:
-#line 1214 "ldgram.y"
-    {
-		  lang_register_vers_node ((yyvsp[(1) - (5)].name), (yyvsp[(3) - (5)].versnode), NULL);
-		}
-    break;
-
   case 323:
-#line 1218 "ldgram.y"
+#line 1214 "ldgram.y"
     {
-		  lang_register_vers_node ((yyvsp[(1) - (6)].name), (yyvsp[(3) - (6)].versnode), (yyvsp[(5) - (6)].deflist));
+		  lang_register_vers_node (NULL, (yyvsp[-2].versnode), NULL);
 		}
     break;
 
   case 324:
-#line 1225 "ldgram.y"
+#line 1218 "ldgram.y"
     {
-		  (yyval.deflist) = lang_add_vers_depend (NULL, (yyvsp[(1) - (1)].name));
+		  lang_register_vers_node ((yyvsp[-4].name), (yyvsp[-2].versnode), NULL);
 		}
     break;
 
   case 325:
-#line 1229 "ldgram.y"
+#line 1222 "ldgram.y"
     {
-		  (yyval.deflist) = lang_add_vers_depend ((yyvsp[(1) - (2)].deflist), (yyvsp[(2) - (2)].name));
+		  lang_register_vers_node ((yyvsp[-5].name), (yyvsp[-3].versnode), (yyvsp[-1].deflist));
 		}
     break;
 
   case 326:
-#line 1236 "ldgram.y"
+#line 1229 "ldgram.y"
     {
-		  (yyval.versnode) = lang_new_vers_node (NULL, NULL);
+		  (yyval.deflist) = lang_add_vers_depend (NULL, (yyvsp[0].name));
 		}
     break;
 
   case 327:
-#line 1240 "ldgram.y"
+#line 1233 "ldgram.y"
     {
-		  (yyval.versnode) = lang_new_vers_node ((yyvsp[(1) - (2)].versyms), NULL);
+		  (yyval.deflist) = lang_add_vers_depend ((yyvsp[-1].deflist), (yyvsp[0].name));
 		}
     break;
 
   case 328:
-#line 1244 "ldgram.y"
+#line 1240 "ldgram.y"
     {
-		  (yyval.versnode) = lang_new_vers_node ((yyvsp[(3) - (4)].versyms), NULL);
+		  (yyval.versnode) = lang_new_vers_node (NULL, NULL);
 		}
     break;
 
   case 329:
-#line 1248 "ldgram.y"
+#line 1244 "ldgram.y"
     {
-		  (yyval.versnode) = lang_new_vers_node (NULL, (yyvsp[(3) - (4)].versyms));
+		  (yyval.versnode) = lang_new_vers_node ((yyvsp[-1].versyms), NULL);
 		}
     break;
 
   case 330:
-#line 1252 "ldgram.y"
+#line 1248 "ldgram.y"
     {
-		  (yyval.versnode) = lang_new_vers_node ((yyvsp[(3) - (8)].versyms), (yyvsp[(7) - (8)].versyms));
+		  (yyval.versnode) = lang_new_vers_node ((yyvsp[-1].versyms), NULL);
 		}
     break;
 
   case 331:
-#line 1259 "ldgram.y"
+#line 1252 "ldgram.y"
     {
-		  (yyval.versyms) = lang_new_vers_pattern (NULL, (yyvsp[(1) - (1)].name), ldgram_vers_current_lang, FALSE);
+		  (yyval.versnode) = lang_new_vers_node (NULL, (yyvsp[-1].versyms));
 		}
     break;
 
   case 332:
-#line 1263 "ldgram.y"
+#line 1256 "ldgram.y"
     {
-		  (yyval.versyms) = lang_new_vers_pattern (NULL, (yyvsp[(1) - (1)].name), ldgram_vers_current_lang, TRUE);
+		  (yyval.versnode) = lang_new_vers_node ((yyvsp[-5].versyms), (yyvsp[-1].versyms));
 		}
     break;
 
   case 333:
-#line 1267 "ldgram.y"
+#line 1263 "ldgram.y"
     {
-		  (yyval.versyms) = lang_new_vers_pattern ((yyvsp[(1) - (3)].versyms), (yyvsp[(3) - (3)].name), ldgram_vers_current_lang, FALSE);
+		  (yyval.versyms) = lang_new_vers_pattern (NULL, (yyvsp[0].name), ldgram_vers_current_lang, FALSE);
 		}
     break;
 
   case 334:
-#line 1271 "ldgram.y"
+#line 1267 "ldgram.y"
     {
-		  (yyval.versyms) = lang_new_vers_pattern ((yyvsp[(1) - (3)].versyms), (yyvsp[(3) - (3)].name), ldgram_vers_current_lang, TRUE);
+		  (yyval.versyms) = lang_new_vers_pattern (NULL, (yyvsp[0].name), ldgram_vers_current_lang, TRUE);
 		}
     break;
 
   case 335:
-#line 1275 "ldgram.y"
+#line 1271 "ldgram.y"
     {
-			  (yyval.name) = ldgram_vers_current_lang;
-			  ldgram_vers_current_lang = (yyvsp[(4) - (5)].name);
-			}
+		  (yyval.versyms) = lang_new_vers_pattern ((yyvsp[-2].versyms), (yyvsp[0].name), ldgram_vers_current_lang, FALSE);
+		}
     break;
 
   case 336:
-#line 1280 "ldgram.y"
+#line 1275 "ldgram.y"
     {
-			  struct bfd_elf_version_expr *pat;
-			  for (pat = (yyvsp[(7) - (9)].versyms); pat->next != NULL; pat = pat->next);
-			  pat->next = (yyvsp[(1) - (9)].versyms);
-			  (yyval.versyms) = (yyvsp[(7) - (9)].versyms);
-			  ldgram_vers_current_lang = (yyvsp[(6) - (9)].name);
-			}
+		  (yyval.versyms) = lang_new_vers_pattern ((yyvsp[-2].versyms), (yyvsp[0].name), ldgram_vers_current_lang, TRUE);
+		}
     break;
 
   case 337:
-#line 1288 "ldgram.y"
+#line 1279 "ldgram.y"
     {
 			  (yyval.name) = ldgram_vers_current_lang;
-			  ldgram_vers_current_lang = (yyvsp[(2) - (3)].name);
+			  ldgram_vers_current_lang = (yyvsp[-1].name);
 			}
     break;
 
   case 338:
-#line 1293 "ldgram.y"
+#line 1284 "ldgram.y"
     {
-			  (yyval.versyms) = (yyvsp[(5) - (7)].versyms);
-			  ldgram_vers_current_lang = (yyvsp[(4) - (7)].name);
+			  struct bfd_elf_version_expr *pat;
+			  for (pat = (yyvsp[-2].versyms); pat->next != NULL; pat = pat->next);
+			  pat->next = (yyvsp[-8].versyms);
+			  (yyval.versyms) = (yyvsp[-2].versyms);
+			  ldgram_vers_current_lang = (yyvsp[-3].name);
 			}
     break;
 
   case 339:
-#line 1298 "ldgram.y"
+#line 1292 "ldgram.y"
     {
-		  (yyval.versyms) = lang_new_vers_pattern (NULL, "global", ldgram_vers_current_lang, FALSE);
-		}
+			  (yyval.name) = ldgram_vers_current_lang;
+			  ldgram_vers_current_lang = (yyvsp[-1].name);
+			}
     break;
 
   case 340:
+#line 1297 "ldgram.y"
+    {
+			  (yyval.versyms) = (yyvsp[-2].versyms);
+			  ldgram_vers_current_lang = (yyvsp[-3].name);
+			}
+    break;
+
+  case 341:
 #line 1302 "ldgram.y"
     {
-		  (yyval.versyms) = lang_new_vers_pattern ((yyvsp[(1) - (3)].versyms), "global", ldgram_vers_current_lang, FALSE);
+		  (yyval.versyms) = lang_new_vers_pattern (NULL, "global", ldgram_vers_current_lang, FALSE);
 		}
     break;
 
-  case 341:
+  case 342:
 #line 1306 "ldgram.y"
     {
-		  (yyval.versyms) = lang_new_vers_pattern (NULL, "local", ldgram_vers_current_lang, FALSE);
+		  (yyval.versyms) = lang_new_vers_pattern ((yyvsp[-2].versyms), "global", ldgram_vers_current_lang, FALSE);
 		}
     break;
 
-  case 342:
+  case 343:
 #line 1310 "ldgram.y"
     {
-		  (yyval.versyms) = lang_new_vers_pattern ((yyvsp[(1) - (3)].versyms), "local", ldgram_vers_current_lang, FALSE);
+		  (yyval.versyms) = lang_new_vers_pattern (NULL, "local", ldgram_vers_current_lang, FALSE);
 		}
     break;
 
-  case 343:
+  case 344:
 #line 1314 "ldgram.y"
     {
-		  (yyval.versyms) = lang_new_vers_pattern (NULL, "extern", ldgram_vers_current_lang, FALSE);
+		  (yyval.versyms) = lang_new_vers_pattern ((yyvsp[-2].versyms), "local", ldgram_vers_current_lang, FALSE);
 		}
     break;
 
-  case 344:
+  case 345:
 #line 1318 "ldgram.y"
     {
-		  (yyval.versyms) = lang_new_vers_pattern ((yyvsp[(1) - (3)].versyms), "extern", ldgram_vers_current_lang, FALSE);
+		  (yyval.versyms) = lang_new_vers_pattern (NULL, "extern", ldgram_vers_current_lang, FALSE);
+		}
+    break;
+
+  case 346:
+#line 1322 "ldgram.y"
+    {
+		  (yyval.versyms) = lang_new_vers_pattern ((yyvsp[-2].versyms), "extern", ldgram_vers_current_lang, FALSE);
 		}
     break;
 
 
-/* Line 1267 of yacc.c.  */
-#line 4178 "ldgram.c"
       default: break;
     }
-  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
 
-  YYPOPSTACK (yylen);
-  yylen = 0;
+/* Line 1126 of yacc.c.  */
+#line 3991 "ldgram.c"
+
+  yyvsp -= yylen;
+  yyssp -= yylen;
+
+
   YY_STACK_PRINT (yyss, yyssp);
 
   *++yyvsp = yyval;
@@ -4209,41 +4021,110 @@
   if (!yyerrstatus)
     {
       ++yynerrs;
-#if ! YYERROR_VERBOSE
-      yyerror (YY_("syntax error"));
-#else
-      {
-	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
-	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
-	  {
-	    YYSIZE_T yyalloc = 2 * yysize;
-	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
-	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
-	    if (yymsg != yymsgbuf)
-	      YYSTACK_FREE (yymsg);
-	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
-	    if (yymsg)
-	      yymsg_alloc = yyalloc;
-	    else
+#if YYERROR_VERBOSE
+      yyn = yypact[yystate];
+
+      if (YYPACT_NINF < yyn && yyn < YYLAST)
+	{
+	  int yytype = YYTRANSLATE (yychar);
+	  YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+	  YYSIZE_T yysize = yysize0;
+	  YYSIZE_T yysize1;
+	  int yysize_overflow = 0;
+	  char *yymsg = 0;
+#	  define YYERROR_VERBOSE_ARGS_MAXIMUM 5
+	  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+	  int yyx;
+
+#if 0
+	  /* This is so xgettext sees the translatable formats that are
+	     constructed on the fly.  */
+	  YY_("syntax error, unexpected %s");
+	  YY_("syntax error, unexpected %s, expecting %s");
+	  YY_("syntax error, unexpected %s, expecting %s or %s");
+	  YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+	  YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+#endif
+	  char *yyfmt;
+	  char const *yyf;
+	  static char const yyunexpected[] = "syntax error, unexpected %s";
+	  static char const yyexpecting[] = ", expecting %s";
+	  static char const yyor[] = " or %s";
+	  char yyformat[sizeof yyunexpected
+			+ sizeof yyexpecting - 1
+			+ ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+			   * (sizeof yyor - 1))];
+	  char const *yyprefix = yyexpecting;
+
+	  /* Start YYX at -YYN if negative to avoid negative indexes in
+	     YYCHECK.  */
+	  int yyxbegin = yyn < 0 ? -yyn : 0;
+
+	  /* Stay within bounds of both yycheck and yytname.  */
+	  int yychecklim = YYLAST - yyn;
+	  int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+	  int yycount = 1;
+
+	  yyarg[0] = yytname[yytype];
+	  yyfmt = yystpcpy (yyformat, yyunexpected);
+
+	  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
 	      {
-		yymsg = yymsgbuf;
-		yymsg_alloc = sizeof yymsgbuf;
+		if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+		  {
+		    yycount = 1;
+		    yysize = yysize0;
+		    yyformat[sizeof yyunexpected - 1] = '\0';
+		    break;
+		  }
+		yyarg[yycount++] = yytname[yyx];
+		yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+		yysize_overflow |= yysize1 < yysize;
+		yysize = yysize1;
+		yyfmt = yystpcpy (yyfmt, yyprefix);
+		yyprefix = yyor;
 	      }
-	  }
 
-	if (0 < yysize && yysize <= yymsg_alloc)
-	  {
-	    (void) yysyntax_error (yymsg, yystate, yychar);
-	    yyerror (yymsg);
-	  }
-	else
-	  {
-	    yyerror (YY_("syntax error"));
-	    if (yysize != 0)
+	  yyf = YY_(yyformat);
+	  yysize1 = yysize + yystrlen (yyf);
+	  yysize_overflow |= yysize1 < yysize;
+	  yysize = yysize1;
+
+	  if (!yysize_overflow && yysize <= YYSTACK_ALLOC_MAXIMUM)
+	    yymsg = (char *) YYSTACK_ALLOC (yysize);
+	  if (yymsg)
+	    {
+	      /* Avoid sprintf, as that infringes on the user's name space.
+		 Don't have undefined behavior even if the translation
+		 produced a string with the wrong number of "%s"s.  */
+	      char *yyp = yymsg;
+	      int yyi = 0;
+	      while ((*yyp = *yyf))
+		{
+		  if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		    {
+		      yyp += yytnamerr (yyp, yyarg[yyi++]);
+		      yyf += 2;
+		    }
+		  else
+		    {
+		      yyp++;
+		      yyf++;
+		    }
+		}
+	      yyerror (yymsg);
+	      YYSTACK_FREE (yymsg);
+	    }
+	  else
+	    {
+	      yyerror (YY_("syntax error"));
 	      goto yyexhaustedlab;
-	  }
-      }
-#endif
+	    }
+	}
+      else
+#endif /* YYERROR_VERBOSE */
+	yyerror (YY_("syntax error"));
     }
 
 
@@ -4254,15 +4135,14 @@
 	 error, discard it.  */
 
       if (yychar <= YYEOF)
-	{
+        {
 	  /* Return failure if at end of input.  */
 	  if (yychar == YYEOF)
 	    YYABORT;
-	}
+        }
       else
 	{
-	  yydestruct ("Error: discarding",
-		      yytoken, &yylval);
+	  yydestruct ("Error: discarding", yytoken, &yylval);
 	  yychar = YYEMPTY;
 	}
     }
@@ -4280,14 +4160,11 @@
   /* Pacify compilers like GCC when the user code never invokes
      YYERROR and the label yyerrorlab therefore never appears in user
      code.  */
-  if (/*CONSTCOND*/ 0)
+  if (0)
      goto yyerrorlab;
 
-  /* Do not reclaim the symbols of the rule which action triggered
-     this YYERROR.  */
-  YYPOPSTACK (yylen);
-  yylen = 0;
-  YY_STACK_PRINT (yyss, yyssp);
+yyvsp -= yylen;
+  yyssp -= yylen;
   yystate = *yyssp;
   goto yyerrlab1;
 
@@ -4317,9 +4194,8 @@
 	YYABORT;
 
 
-      yydestruct ("Error: popping",
-		  yystos[yystate], yyvsp);
-      YYPOPSTACK (1);
+      yydestruct ("Error: popping", yystos[yystate], yyvsp);
+      YYPOPSTACK;
       yystate = *yyssp;
       YY_STACK_PRINT (yyss, yyssp);
     }
@@ -4330,7 +4206,7 @@
   *++yyvsp = yylval;
 
 
-  /* Shift the error token.  */
+  /* Shift the error token. */
   YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
 
   yystate = yyn;
@@ -4365,30 +4241,21 @@
   if (yychar != YYEOF && yychar != YYEMPTY)
      yydestruct ("Cleanup: discarding lookahead",
 		 yytoken, &yylval);
-  /* Do not reclaim the symbols of the rule which action triggered
-     this YYABORT or YYACCEPT.  */
-  YYPOPSTACK (yylen);
-  YY_STACK_PRINT (yyss, yyssp);
   while (yyssp != yyss)
     {
       yydestruct ("Cleanup: popping",
 		  yystos[*yyssp], yyvsp);
-      YYPOPSTACK (1);
+      YYPOPSTACK;
     }
 #ifndef yyoverflow
   if (yyss != yyssa)
     YYSTACK_FREE (yyss);
 #endif
-#if YYERROR_VERBOSE
-  if (yymsg != yymsgbuf)
-    YYSTACK_FREE (yymsg);
-#endif
-  /* Make sure YYID is used.  */
-  return YYID (yyresult);
+  return yyresult;
 }
 
 
-#line 1328 "ldgram.y"
+#line 1332 "ldgram.y"
 
 void
 yyerror(arg)
diff -Naur ../PRISTINE/binutils-2.18/ld/ldgram.h binutils-2.18/ld/ldgram.h
--- ../PRISTINE/binutils-2.18/ld/ldgram.h	2007-08-06 13:39:31.000000000 -0700
+++ binutils-2.18/ld/ldgram.h	2009-01-09 17:32:43.719512000 -0800
@@ -1,9 +1,7 @@
-/* A Bison parser, made by GNU Bison 2.3.  */
+/* A Bison parser, made by GNU Bison 2.1.  */
 
-/* Skeleton interface for Bison's Yacc-like parsers in C
-
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
-   Free Software Foundation, Inc.
+/* Skeleton parser for Yacc-like parsing with Bison,
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -20,18 +18,10 @@
    Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.  */
 
-/* As a special exception, you may create a larger work that contains
-   part or all of the Bison parser skeleton and distribute that work
-   under terms of your choice, so long as that work isn't itself a
-   parser generator using the skeleton or a modified version thereof
-   as a parser skeleton.  Alternatively, if you modify or redistribute
-   the parser skeleton itself, you may (at your option) remove this
-   special exception, which will cause the skeleton and the resulting
-   Bison output files to be licensed under the GNU General Public
-   License without this special exception.
-
-   This special exception was added by the Free Software Foundation in
-   version 2.2 of Bison.  */
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
 
 /* Tokens.  */
 #ifndef YYTOKENTYPE
@@ -100,62 +90,64 @@
      LOADADDR = 316,
      MAX_K = 317,
      MIN_K = 318,
-     STARTUP = 319,
-     HLL = 320,
-     SYSLIB = 321,
-     FLOAT = 322,
-     NOFLOAT = 323,
-     NOCROSSREFS = 324,
-     ORIGIN = 325,
-     FILL = 326,
-     LENGTH = 327,
-     CREATE_OBJECT_SYMBOLS = 328,
-     INPUT = 329,
-     GROUP = 330,
-     OUTPUT = 331,
-     CONSTRUCTORS = 332,
-     ALIGNMOD = 333,
-     AT = 334,
-     SUBALIGN = 335,
-     PROVIDE = 336,
-     PROVIDE_HIDDEN = 337,
-     AS_NEEDED = 338,
-     CHIP = 339,
-     LIST = 340,
-     SECT = 341,
-     ABSOLUTE = 342,
-     LOAD = 343,
-     NEWLINE = 344,
-     ENDWORD = 345,
-     ORDER = 346,
-     NAMEWORD = 347,
-     ASSERT_K = 348,
-     FORMAT = 349,
-     PUBLIC = 350,
-     DEFSYMEND = 351,
-     BASE = 352,
-     ALIAS = 353,
-     TRUNCATE = 354,
-     REL = 355,
-     INPUT_SCRIPT = 356,
-     INPUT_MRI_SCRIPT = 357,
-     INPUT_DEFSYM = 358,
-     CASE = 359,
-     EXTERN = 360,
-     START = 361,
-     VERS_TAG = 362,
-     VERS_IDENTIFIER = 363,
-     GLOBAL = 364,
-     LOCAL = 365,
-     VERSIONK = 366,
-     INPUT_VERSION_SCRIPT = 367,
-     KEEP = 368,
-     ONLY_IF_RO = 369,
-     ONLY_IF_RW = 370,
-     SPECIAL = 371,
-     EXCLUDE_FILE = 372,
-     CONSTANT = 373,
-     INPUT_DYNAMIC_LIST = 374
+     CEILP2 = 319,
+     NACL_MASK = 320,
+     STARTUP = 321,
+     HLL = 322,
+     SYSLIB = 323,
+     FLOAT = 324,
+     NOFLOAT = 325,
+     NOCROSSREFS = 326,
+     ORIGIN = 327,
+     FILL = 328,
+     LENGTH = 329,
+     CREATE_OBJECT_SYMBOLS = 330,
+     INPUT = 331,
+     GROUP = 332,
+     OUTPUT = 333,
+     CONSTRUCTORS = 334,
+     ALIGNMOD = 335,
+     AT = 336,
+     SUBALIGN = 337,
+     PROVIDE = 338,
+     PROVIDE_HIDDEN = 339,
+     AS_NEEDED = 340,
+     CHIP = 341,
+     LIST = 342,
+     SECT = 343,
+     ABSOLUTE = 344,
+     LOAD = 345,
+     NEWLINE = 346,
+     ENDWORD = 347,
+     ORDER = 348,
+     NAMEWORD = 349,
+     ASSERT_K = 350,
+     FORMAT = 351,
+     PUBLIC = 352,
+     DEFSYMEND = 353,
+     BASE = 354,
+     ALIAS = 355,
+     TRUNCATE = 356,
+     REL = 357,
+     INPUT_SCRIPT = 358,
+     INPUT_MRI_SCRIPT = 359,
+     INPUT_DEFSYM = 360,
+     CASE = 361,
+     EXTERN = 362,
+     START = 363,
+     VERS_TAG = 364,
+     VERS_IDENTIFIER = 365,
+     GLOBAL = 366,
+     LOCAL = 367,
+     VERSIONK = 368,
+     INPUT_VERSION_SCRIPT = 369,
+     KEEP = 370,
+     ONLY_IF_RO = 371,
+     ONLY_IF_RW = 372,
+     SPECIAL = 373,
+     EXCLUDE_FILE = 374,
+     CONSTANT = 375,
+     INPUT_DYNAMIC_LIST = 376
    };
 #endif
 /* Tokens.  */
@@ -220,70 +212,71 @@
 #define LOADADDR 316
 #define MAX_K 317
 #define MIN_K 318
-#define STARTUP 319
-#define HLL 320
-#define SYSLIB 321
-#define FLOAT 322
-#define NOFLOAT 323
-#define NOCROSSREFS 324
-#define ORIGIN 325
-#define FILL 326
-#define LENGTH 327
-#define CREATE_OBJECT_SYMBOLS 328
-#define INPUT 329
-#define GROUP 330
-#define OUTPUT 331
-#define CONSTRUCTORS 332
-#define ALIGNMOD 333
-#define AT 334
-#define SUBALIGN 335
-#define PROVIDE 336
-#define PROVIDE_HIDDEN 337
-#define AS_NEEDED 338
-#define CHIP 339
-#define LIST 340
-#define SECT 341
-#define ABSOLUTE 342
-#define LOAD 343
-#define NEWLINE 344
-#define ENDWORD 345
-#define ORDER 346
-#define NAMEWORD 347
-#define ASSERT_K 348
-#define FORMAT 349
-#define PUBLIC 350
-#define DEFSYMEND 351
-#define BASE 352
-#define ALIAS 353
-#define TRUNCATE 354
-#define REL 355
-#define INPUT_SCRIPT 356
-#define INPUT_MRI_SCRIPT 357
-#define INPUT_DEFSYM 358
-#define CASE 359
-#define EXTERN 360
-#define START 361
-#define VERS_TAG 362
-#define VERS_IDENTIFIER 363
-#define GLOBAL 364
-#define LOCAL 365
-#define VERSIONK 366
-#define INPUT_VERSION_SCRIPT 367
-#define KEEP 368
-#define ONLY_IF_RO 369
-#define ONLY_IF_RW 370
-#define SPECIAL 371
-#define EXCLUDE_FILE 372
-#define CONSTANT 373
-#define INPUT_DYNAMIC_LIST 374
+#define CEILP2 319
+#define NACL_MASK 320
+#define STARTUP 321
+#define HLL 322
+#define SYSLIB 323
+#define FLOAT 324
+#define NOFLOAT 325
+#define NOCROSSREFS 326
+#define ORIGIN 327
+#define FILL 328
+#define LENGTH 329
+#define CREATE_OBJECT_SYMBOLS 330
+#define INPUT 331
+#define GROUP 332
+#define OUTPUT 333
+#define CONSTRUCTORS 334
+#define ALIGNMOD 335
+#define AT 336
+#define SUBALIGN 337
+#define PROVIDE 338
+#define PROVIDE_HIDDEN 339
+#define AS_NEEDED 340
+#define CHIP 341
+#define LIST 342
+#define SECT 343
+#define ABSOLUTE 344
+#define LOAD 345
+#define NEWLINE 346
+#define ENDWORD 347
+#define ORDER 348
+#define NAMEWORD 349
+#define ASSERT_K 350
+#define FORMAT 351
+#define PUBLIC 352
+#define DEFSYMEND 353
+#define BASE 354
+#define ALIAS 355
+#define TRUNCATE 356
+#define REL 357
+#define INPUT_SCRIPT 358
+#define INPUT_MRI_SCRIPT 359
+#define INPUT_DEFSYM 360
+#define CASE 361
+#define EXTERN 362
+#define START 363
+#define VERS_TAG 364
+#define VERS_IDENTIFIER 365
+#define GLOBAL 366
+#define LOCAL 367
+#define VERSIONK 368
+#define INPUT_VERSION_SCRIPT 369
+#define KEEP 370
+#define ONLY_IF_RO 371
+#define ONLY_IF_RW 372
+#define SPECIAL 373
+#define EXCLUDE_FILE 374
+#define CONSTANT 375
+#define INPUT_DYNAMIC_LIST 376
 
 
 
 
-#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
-typedef union YYSTYPE
+#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
 #line 66 "ldgram.y"
-{
+typedef union YYSTYPE {
   bfd_vma integer;
   struct big_int
     {
@@ -310,10 +303,9 @@
   struct bfd_elf_version_deps *deflist;
   struct bfd_elf_version_expr *versyms;
   struct bfd_elf_version_tree *versnode;
-}
-/* Line 1489 of yacc.c.  */
-#line 316 "ldgram.h"
-	YYSTYPE;
+} YYSTYPE;
+/* Line 1447 of yacc.c.  */
+#line 309 "ldgram.h"
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
 # define YYSTYPE_IS_TRIVIAL 1
@@ -321,3 +313,5 @@
 
 extern YYSTYPE yylval;
 
+
+
diff -Naur ../PRISTINE/binutils-2.18/ld/ldgram.y binutils-2.18/ld/ldgram.y
--- ../PRISTINE/binutils-2.18/ld/ldgram.y	2007-08-06 13:00:20.000000000 -0700
+++ binutils-2.18/ld/ldgram.y	2009-01-09 17:32:43.739493000 -0800
@@ -138,7 +138,7 @@
 %token NOLOAD DSECT COPY INFO OVERLAY
 %token DEFINED TARGET_K SEARCH_DIR MAP ENTRY
 %token <integer> NEXT
-%token SIZEOF ALIGNOF ADDR LOADADDR MAX_K MIN_K
+%token SIZEOF ALIGNOF ADDR LOADADDR MAX_K MIN_K CEILP2 NACL_MASK
 %token STARTUP HLL SYSLIB FLOAT NOFLOAT NOCROSSREFS
 %token ORIGIN FILL
 %token LENGTH CREATE_OBJECT_SYMBOLS INPUT GROUP OUTPUT CONSTRUCTORS
@@ -880,6 +880,10 @@
 			{ $$ = exp_binop (MAX_K, $3, $5 ); }
 	|	MIN_K '(' exp ',' exp ')'
 			{ $$ = exp_binop (MIN_K, $3, $5 ); }
+	|	CEILP2 '(' exp ')'
+			{ $$ = exp_unop (CEILP2, $3); }
+        |	NACL_MASK '(' exp ')'
+			{ $$ = exp_unop (NACL_MASK, $3); }
 	|	ASSERT_K '(' exp ',' NAME ')'
 			{ $$ = exp_assert ($3, $5); }
 	|	ORIGIN '(' NAME ')'
diff -Naur ../PRISTINE/binutils-2.18/ld/ldlex.c binutils-2.18/ld/ldlex.c
--- ../PRISTINE/binutils-2.18/ld/ldlex.c	2007-08-06 13:39:31.000000000 -0700
+++ binutils-2.18/ld/ldlex.c	2009-01-09 17:32:43.757484000 -0800
@@ -8,7 +8,7 @@
 #define FLEX_SCANNER
 #define YY_FLEX_MAJOR_VERSION 2
 #define YY_FLEX_MINOR_VERSION 5
-#define YY_FLEX_SUBMINOR_VERSION 33
+#define YY_FLEX_SUBMINOR_VERSION 31
 #if YY_FLEX_SUBMINOR_VERSION > 0
 #define FLEX_BETA
 #endif
@@ -30,15 +30,7 @@
 
 /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
 
-#if __STDC_VERSION__ >= 199901L
-
-/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
- * if you want the limit (max/min) macros for int types. 
- */
-#ifndef __STDC_LIMIT_MACROS
-#define __STDC_LIMIT_MACROS 1
-#endif
-
+#if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
 #include <inttypes.h>
 typedef int8_t flex_int8_t;
 typedef uint8_t flex_uint8_t;
@@ -142,10 +134,6 @@
 #define YY_BUF_SIZE 16384
 #endif
 
-/* The state buf must be large enough to hold one state per character in the main buffer.
- */
-#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
-
 #ifndef YY_TYPEDEF_YY_BUFFER_STATE
 #define YY_TYPEDEF_YY_BUFFER_STATE
 typedef struct yy_buffer_state *YY_BUFFER_STATE;
@@ -279,7 +267,7 @@
 
 /* Points to current character in buffer. */
 static char *yy_c_buf_p = (char *) 0;
-static int yy_init = 0;		/* whether we need to initialize */
+static int yy_init = 1;		/* whether we need to initialize */
 static int yy_start = 0;	/* start state number */
 
 /* Flag which is used to allow yywrap()'s to do buffer switches
@@ -363,8 +351,8 @@
 	*yy_cp = '\0'; \
 	(yy_c_buf_p) = yy_cp;
 
-#define YY_NUM_RULES 186
-#define YY_END_OF_BUFFER 187
+#define YY_NUM_RULES 188
+#define YY_END_OF_BUFFER 189
 /* This struct is not used in this scanner,
    but its presence is necessary. */
 struct yy_trans_info
@@ -372,177 +360,180 @@
 	flex_int32_t yy_verify;
 	flex_int32_t yy_nxt;
 	};
-static yyconst flex_int16_t yy_accept[1536] =
+static yyconst flex_int16_t yy_accept[1562] =
     {   0,
-        0,    0,  166,  166,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,  187,  186,
-      184,  169,  168,   32,  184,  166,   38,   29,   44,   43,
-       34,   35,   28,   36,  166,   37,    8,    8,   45,   46,
-       39,   40,   27,   33,  166,  166,  166,  166,  166,  166,
-      166,  166,  166,  166,  166,  166,  166,  166,  166,  166,
-      166,  166,  166,   10,    9,  166,  111,  109,  166,   42,
-       30,   41,   31,  185,  169,   32,  185,  164,   38,   29,
-       44,   43,   34,   35,   28,   36,  164,   37,    8,    8,
-       45,   46,   39,   40,   27,   33,  164,  164,  164,  164,
+        0,    0,  168,  168,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,  189,  188,
+      186,  171,  170,   32,  186,  168,   38,   29,   44,   43,
+       34,   35,   28,   36,  168,   37,    8,    8,   45,   46,
+       39,   40,   27,   33,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,   10,    9,  168,  113,  111,  168,   42,
+       30,   41,   31,  187,  171,   32,  187,  166,   38,   29,
+       44,   43,   34,   35,   28,   36,  166,   37,    8,    8,
+       45,   46,   39,   40,   27,   33,  166,  166,  166,  166,
 
-      164,  164,  164,  164,  164,  164,  164,  164,  164,  164,
-      164,   10,    9,  164,  164,   42,   30,   41,   31,  162,
-       36,  162,   37,    8,    8,  162,  162,  162,  162,  162,
-      162,  162,  162,  162,  162,  162,  162,  162,  162,  162,
-      162,  162,  162,  162,  162,  111,  109,  162,   31,    4,
-        3,    2,    4,    5,  123,  122,  161,   34,   35,   28,
-       36,  161,   37,    8,    8,   45,   46,   40,   33,  161,
-      161,  161,  161,  161,  161,  161,  161,  161,  161,  161,
-      161,   10,    9,  161,  161,  161,  161,  161,  161,  161,
-      161,  161,  161,  161,   31,  183,  181,  182,  184,  176,
-
-      175,  170,  177,  178,  174,  174,  174,  174,  179,  180,
-      169,   15,    0,  167,  166,    8,   26,   24,   22,   20,
-       21,    1,   23,    8,    8,  166,   18,   17,   14,   16,
-       19,  166,  166,  166,  166,  115,  166,  166,  166,  166,
-      166,  166,  166,  166,  166,  166,  166,  166,  166,  166,
-      166,  166,  166,  166,  166,  166,  166,  166,  166,  166,
       166,  166,  166,  166,  166,  166,  166,  166,  166,  166,
-      166,  166,  166,  166,  166,  166,  166,  166,  166,  166,
-      166,   25,   13,  164,    6,   22,   20,   21,    0,    1,
-       23,    8,    0,    7,    7,    8,    7,   14,  164,    7,
-
-        7,    7,  164,  164,  115,    7,  164,  164,    7,  164,
-      164,  164,    7,  164,  164,  164,  164,  164,  164,  164,
+      166,   10,    9,  166,  166,   42,   30,   41,   31,  164,
+       36,  164,   37,    8,    8,  164,  164,  164,  164,  164,
       164,  164,  164,  164,  164,  164,  164,  164,  164,  164,
-        7,  164,  162,    8,    0,   23,    8,    0,  162,  162,
-      162,  162,  115,  162,  162,  162,  162,  162,  162,  162,
-      162,  162,  162,  162,  162,  162,  162,  162,  162,  162,
-      162,  162,  162,  162,  162,  162,  162,  162,  162,  162,
-      162,  162,  162,  162,  162,  162,  162,  162,  162,  162,
-      162,  162,  162,  162,  162,  162,  162,  162,  162,    4,
-        4,  122,  122,  161,    6,  124,   22,  125,  161,    7,
-
-        7,    7,  161,  161,  161,    7,  161,    7,    7,  161,
-      161,  161,  161,  161,  161,  161,  161,    7,  161,  161,
-      161,    7,  161,    7,    7,  161,  161,  161,  161,  161,
-      161,  161,  161,  183,  182,  175,  174,    0,  174,  174,
-      174,   11,   12,  166,  166,  166,  166,  166,  166,  166,
-      166,  166,  166,  166,  166,  166,  166,  166,  166,  166,
-      166,  166,  166,  166,   87,  166,  166,  166,  166,  166,
-      166,  166,  166,   69,  166,  166,  166,  166,  166,  166,
-      166,  166,  166,  166,  166,  166,  166,  166,  166,  166,
+      164,  164,  164,  164,  164,  113,  111,  164,   31,    4,
+        3,    2,    4,    5,  125,  124,  163,   34,   35,   28,
+       36,  163,   37,    8,    8,   45,   46,   40,   33,  163,
+      163,  163,  163,  163,  163,  163,  163,  163,  163,  163,
+      163,   10,    9,  163,  163,  163,  163,  163,  163,  163,
+      163,  163,  163,  163,   31,  185,  183,  184,  186,  178,
+
+      177,  172,  179,  180,  176,  176,  176,  176,  181,  182,
+      171,   15,    0,  169,  168,    8,   26,   24,   22,   20,
+       21,    1,   23,    8,    8,  168,   18,   17,   14,   16,
+       19,  168,  168,  168,  168,  117,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,   25,   13,  166,    6,   22,   20,   21,    0,    1,
+       23,    8,    0,    7,    7,    8,    7,   14,  166,    7,
+
+        7,    7,  166,  166,  117,    7,  166,  166,  166,    7,
+      166,  166,  166,    7,  166,  166,  166,  166,  166,  166,
       166,  166,  166,  166,  166,  166,  166,  166,  166,  166,
+      166,  166,    7,  166,  164,    8,    0,   23,    8,    0,
+      164,  164,  164,  164,  117,  164,  164,  164,  164,  164,
+      164,  164,  164,  164,  164,  164,  164,  164,  164,  164,
+      164,  164,  164,  164,  164,  164,  164,  164,  164,  164,
+      164,  164,  164,  164,  164,  164,  164,  164,  164,  164,
+      164,  164,  164,  164,  164,  164,  164,  164,  164,  164,
+      164,  164,  164,    4,    4,  124,  124,  163,    6,  126,
 
-      112,  110,  166,    8,  165,    8,  164,    7,  164,  164,
+       22,  127,  163,    7,    7,    7,  163,  163,  163,    7,
+      163,    7,    7,  163,  163,  163,  163,  163,  163,  163,
+      163,    7,  163,  163,  163,    7,  163,    7,    7,  163,
+      163,  163,  163,  163,  163,  163,  163,  185,  184,  177,
+      176,    0,  176,  176,  176,   11,   12,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,   89,  168,
+      168,  168,  168,  168,  168,  168,  168,   71,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+
+      168,  168,  168,  168,  114,  112,  168,    8,  167,    8,
+      166,    7,  166,  166,  166,  166,  166,  166,  166,  166,
+      166,  166,  166,  166,  166,  166,  166,  166,  166,   60,
+       61,  166,  166,  166,  166,  166,  166,  166,  166,  166,
+      166,  166,  166,  166,  166,    8,  165,  164,  164,  164,
+      164,  164,  164,  164,  164,  164,  164,  164,  164,  164,
+      164,  164,  164,  164,  164,  164,  164,  164,  164,   89,
+      164,  164,  164,  164,  164,  164,  164,  164,   71,   60,
+      164,   61,  164,  164,  164,  164,  164,  164,  164,  164,
       164,  164,  164,  164,  164,  164,  164,  164,  164,  164,
-      164,  164,  164,  164,   60,   61,  164,  164,  164,  164,
-      164,  164,  164,  164,  164,  164,  164,  164,  164,    8,
-      163,  162,  162,  162,  162,  162,  162,  162,  162,  162,
-      162,  162,  162,  162,  162,  162,  162,  162,  162,  162,
-      162,  162,   87,  162,  162,  162,  162,  162,  162,  162,
-      162,   69,   60,  162,   61,  162,  162,  162,  162,  162,
-      162,  162,  162,  162,  162,  162,  162,  162,  162,  162,
-      162,  162,  162,  162,  162,  162,  162,  162,  162,  162,
-
-      112,  110,  162,    4,    8,  161,  161,  161,  161,  161,
-      126,  161,  161,  161,  161,  161,  161,  161,  161,  161,
-      161,  161,  161,  161,  161,  161,  143,  161,  161,  161,
-      161,  161,  161,  161,  161,  161,  161,  174,  174,  174,
-      166,   57,  166,  166,  166,   51,  166,   94,  166,  103,
-      166,  166,  166,  166,  166,  166,  166,   83,  166,  166,
-      166,  166,  104,  166,  166,  119,  166,  166,   92,  166,
-       65,  166,  166,  166,  166,  166,  166,  166,  166,  166,
-       90,  166,  166,  166,  166,  166,  100,  166,  166,  166,
-      166,  166,  166,  166,  166,  166,  164,   57,  164,  164,
-
-      164,   51,  164,  164,  103,  164,  164,  164,  164,  164,
-      104,  119,  164,  164,   65,  164,  164,  164,  164,  164,
-      164,  164,  164,  164,  164,  164,  164,  162,   57,  162,
-      162,  162,   51,  162,   94,  162,  103,  162,  162,  162,
-      162,  162,  162,  162,   83,  162,  162,  162,  162,  104,
-      162,  162,  119,  162,  162,   92,  162,   65,  162,  162,
-      162,  162,  162,  162,  162,  162,  162,   90,  162,  162,
-      162,  162,  162,  100,  162,  162,  162,  162,  162,  162,
-      162,  162,  162,  161,  161,  161,  130,  138,  129,  161,
-      161,  140,  133,  136,  161,  161,  141,  161,  161,  161,
-
-      161,  161,  147,  155,  146,  161,  161,  158,  150,  153,
-      161,  161,  159,  161,  161,  174,  174,  174,  166,   53,
-      166,  166,   50,  166,  166,  166,  166,  102,   63,  166,
-      166,   89,  166,   75,  166,  166,   74,  166,  166,  166,
-      166,  166,  166,  166,  166,  166,  166,  114,  166,  166,
-      166,  166,   93,  166,  166,  166,   91,  166,  166,  166,
-      166,  166,  166,  166,  164,   53,  164,  164,   50,  164,
-      164,  164,  102,  164,   75,  164,  164,  164,  164,  164,
-      164,  164,  164,  164,  164,  164,  164,  164,  164,  162,
-       53,  162,  162,   50,  162,  162,  162,  162,  102,   63,
-
-      162,  162,   89,  162,   75,  162,  162,   74,  162,  162,
-      162,  162,  162,  162,  162,  162,  162,  162,  114,  162,
-      162,  162,  162,   93,  162,  162,  162,   91,  162,  162,
-      162,  162,  162,  162,  162,  161,  131,  128,  161,  161,
-      140,  140,  135,  161,  139,  161,  161,  148,  145,  161,
-      161,  158,  158,  152,  161,  157,  161,  174,  174,  172,
-      166,  166,   62,  166,  166,  166,  166,  166,  166,  166,
-       64,  166,  166,  166,   52,  166,   47,  166,  166,  101,
-      166,   48,   73,  166,  166,  166,  166,  166,   70,  166,
-      166,  166,  166,   88,   71,  166,  166,  166,  164,  164,
-
-       62,  164,  164,  164,  164,  164,   52,  164,  164,  101,
-      164,   48,  164,  164,  164,   70,  164,  164,  164,  164,
-      162,  162,   62,  162,  162,  162,  162,  162,  162,  162,
-       64,  162,  162,  162,   52,  162,   47,  162,  162,  101,
-      162,   48,   73,  162,  162,  162,  162,  162,   70,  162,
-      162,  162,  162,   88,   71,  162,  162,  162,  161,  161,
-       64,  137,  134,  161,  161,  161,  156,  154,  151,  161,
-      173,  171,  166,   59,  166,  166,  166,  166,  166,   77,
-      166,  166,  113,  166,  166,  166,   95,  166,  166,   97,
-      117,  166,  166,  166,  166,  166,  108,   84,  166,   49,
-
-      166,  166,  164,   59,  164,  164,  164,   77,  164,  164,
-      164,  164,  105,  117,  164,  164,  108,  164,  164,  164,
-      162,   59,  162,  162,  162,  162,  162,   77,  162,  162,
-      113,  162,  162,  162,   95,  162,  162,   97,  117,  162,
-      162,  162,  162,  162,  108,   84,  162,   49,  162,  162,
-      161,  161,  161,  161,  161,  161,  142,  166,  121,  166,
-      166,  166,  166,  166,  166,   58,  166,  166,  166,  166,
-      166,  166,   82,  166,  166,  166,  116,  160,  166,  142,
-      164,  121,  164,  164,   58,  164,  164,  164,  164,  164,
-      116,  160,  164,  142,  162,  121,  162,  162,  162,  162,
-
-      162,  162,   58,  162,  162,  162,  162,  162,  162,   82,
-      162,  162,  162,  116,  160,  162,  142,  127,  132,  160,
-      144,  149,   76,  166,  166,  166,  166,  166,  166,  166,
+
+      164,  164,  164,  164,  164,  164,  164,  164,  114,  112,
+      164,    4,    8,  163,  163,  163,  163,  163,  128,  163,
+      163,  163,  163,  163,  163,  163,  163,  163,  163,  163,
+      163,  163,  163,  163,  145,  163,  163,  163,  163,  163,
+      163,  163,  163,  163,  163,  176,  176,  176,  168,   57,
+      168,  168,  168,   51,  168,   96,  168,  105,  168,  168,
+      168,  168,  168,  168,  168,   85,  168,  168,  168,  168,
+      106,  168,  168,  121,  168,  168,   94,  168,   67,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,   92,  168,
+      168,  168,  168,  168,  102,  168,  168,  168,  168,  168,
+
+      168,  168,  168,  168,  166,   57,  166,  166,  166,   51,
+      166,  166,  166,  105,  166,  166,  166,  166,  166,  106,
+      121,  166,  166,  166,   67,  166,  166,  166,  166,  166,
+      166,  166,  166,  166,  166,  166,  166,  164,   57,  164,
+      164,  164,   51,  164,   96,  164,  164,  105,  164,  164,
+      164,  164,  164,  164,  164,   85,  164,  164,  164,  164,
+      106,  164,  164,  121,  164,  164,   94,  164,  164,   67,
+      164,  164,  164,  164,  164,  164,  164,  164,  164,   92,
+      164,  164,  164,  164,  164,  102,  164,  164,  164,  164,
+      164,  164,  164,  164,  164,  163,  163,  163,  132,  140,
+
+      131,  163,  163,  142,  135,  138,  163,  163,  143,  163,
+      163,  163,  163,  163,  149,  157,  148,  163,  163,  160,
+      152,  155,  163,  163,  161,  163,  163,  176,  176,  176,
+      168,   53,  168,  168,   50,  168,  168,  168,  168,  104,
+       65,  168,  168,   91,  168,   77,  168,  168,   76,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  116,
+      168,  168,  168,  168,   95,  168,  168,  168,   93,  168,
+      168,  168,  168,  168,  168,  168,  166,   53,  166,  166,
+       50,  166,  166,  166,  166,  104,  166,   77,  166,  166,
       166,  166,  166,  166,  166,  166,  166,  166,  166,  166,
-       76,  164,  164,  164,  164,  164,  164,  164,  164,   76,
-      162,  162,  162,  162,  162,  162,  162,  162,  162,  162,
-      162,  162,  162,  162,  162,  162,  162,  166,  166,  166,
-      166,  166,  166,  166,  106,  107,  166,  166,  166,   72,
-      166,  166,  166,  166,  166,  164,  164,  164,  106,  107,
-      164,  164,  164,  164,  162,  162,  162,  162,  162,  162,
-
-      162,  106,  107,  162,  162,  162,   72,  162,  162,  162,
-      162,  162,  166,  166,  166,  166,  166,  166,   96,   86,
-      166,  166,  166,  166,  166,  166,  166,  164,  164,   96,
-      164,  164,  164,  164,  162,  162,  162,  162,  162,  162,
-       96,   86,  162,  162,  162,  162,  162,  162,  162,   79,
-      166,  166,  120,  166,  166,  166,  166,  166,  166,  166,
-       98,  166,  164,  120,  164,  164,  164,  164,   79,  162,
-      162,  120,  162,  162,  162,  162,  162,  162,  162,   98,
-      162,  166,  166,  166,  166,   85,  166,   68,  166,  166,
-      166,  164,  164,   68,  164,  164,  162,  162,  162,  162,
-
-       85,  162,   68,  162,  162,  162,  166,  166,  166,  166,
-      166,  166,  118,   67,  166,   66,  164,  164,  164,  118,
-       67,   66,  162,  162,  162,  162,  162,  162,  118,   67,
-      162,   66,  166,  166,  166,  166,  166,  166,  166,  164,
-      164,  164,  162,  162,  162,  162,  162,  162,  162,  166,
-      166,   56,  166,  166,  166,  166,  164,   56,  164,  162,
-      162,   56,  162,  162,  162,  162,  166,  166,  166,  166,
-      166,   99,  164,  164,  162,  162,  162,  162,  162,   99,
-      166,   54,  166,  166,  166,   54,  164,  162,   54,  162,
-      162,  162,  166,  166,  166,  166,  164,  162,  162,  162,
-
-      162,  166,  166,  166,  166,  164,  162,  162,  162,  162,
-       78,  166,  166,  166,  164,   78,  162,  162,  162,   55,
-      166,  166,   55,   55,  162,  162,   80,  166,   80,  162,
-      166,  162,   81,   81,    0
+
+      166,  166,  166,  164,   53,  164,  164,   50,  164,  164,
+      164,  164,  164,  104,   65,  164,  164,   91,  164,   77,
+      164,  164,   76,  164,  164,  164,  164,  164,  164,  164,
+      164,  164,  164,  164,  116,  164,  164,  164,  164,   95,
+      164,  164,  164,   93,  164,  164,  164,  164,  164,  164,
+      164,  163,  133,  130,  163,  163,  142,  142,  137,  163,
+      141,  163,  163,  150,  147,  163,  163,  160,  160,  154,
+      163,  159,  163,  176,  176,  174,  168,  168,   64,  168,
+      168,  168,  168,  168,  168,  168,   66,  168,  168,  168,
+       52,  168,   47,  168,  168,  103,  168,   48,   75,  168,
+
+      168,  168,  168,  168,   72,  168,  168,  168,  168,   90,
+       73,  168,  168,  168,  166,  166,   64,  166,   62,  166,
+      166,  166,  166,   52,  166,  166,  166,  103,  166,   48,
+      166,  166,  166,   72,  166,  166,  166,  166,  164,  164,
+       64,  164,   62,  164,  164,  164,  164,  164,  164,   66,
+      164,  164,  164,   52,  164,   47,  164,  164,  164,  103,
+      164,   48,   75,  164,  164,  164,  164,  164,   72,  164,
+      164,  164,  164,   90,   73,  164,  164,  164,  163,  163,
+       66,  139,  136,  163,  163,  163,  158,  156,  153,  163,
+      175,  173,  168,   59,  168,  168,  168,  168,  168,   79,
+
+      168,  168,  115,  168,  168,  168,   97,  168,  168,   99,
+      119,  168,  168,  168,  168,  168,  110,   86,  168,   49,
+      168,  168,  166,   59,  166,  166,  166,   79,  166,  166,
+      166,  166,  166,  107,  119,  166,  166,  110,  166,  166,
+      166,  164,   59,  164,  164,  164,  164,  164,   79,  164,
+      164,  115,  164,  164,  164,  164,   97,  164,  164,   99,
+      119,  164,  164,  164,  164,  164,  110,   86,  164,   49,
+      164,  164,  163,  163,  163,  163,  163,  163,  144,  168,
+      123,  168,  168,  168,  168,  168,  168,   58,  168,  168,
+      168,  168,  168,  168,   84,  168,  168,  168,  118,  162,
+
+      168,  144,  166,  123,  166,  166,   58,  166,  166,  166,
+      166,  166,  166,  118,  162,  166,  144,  164,  123,  164,
+      164,  164,  164,  164,  164,   58,  164,  164,  164,  164,
+      164,  164,  164,   84,  164,  164,  164,  118,  162,  164,
+      144,  129,  134,  162,  146,  151,   78,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,   78,  166,  166,   63,  166,  166,
+      166,  166,  166,  166,   78,  164,  164,  164,  164,  164,
+      164,   63,  164,  164,  164,  164,  164,  164,  164,  164,
+      164,  164,  164,  168,  168,  168,  168,  168,  168,  168,
+
+      108,  109,  168,  168,  168,   74,  168,  168,  168,  168,
+      168,  166,  166,  166,  108,  109,  166,  166,  166,  166,
+      164,  164,  164,  164,  164,  164,  164,  108,  109,  164,
+      164,  164,   74,  164,  164,  164,  164,  164,  168,  168,
+      168,  168,  168,  168,   98,   88,  168,  168,  168,  168,
+      168,  168,  168,  166,  166,   98,  166,  166,  166,  166,
+      164,  164,  164,  164,  164,  164,   98,   88,  164,  164,
+      164,  164,  164,  164,  164,   81,  168,  168,  122,  168,
+      168,  168,  168,  168,  168,  168,  100,  168,  166,  122,
+      166,  166,  166,  166,   81,  164,  164,  122,  164,  164,
+
+      164,  164,  164,  164,  164,  100,  164,  168,  168,  168,
+      168,   87,  168,   70,  168,  168,  168,  166,  166,   70,
+      166,  166,  164,  164,  164,  164,   87,  164,   70,  164,
+      164,  164,  168,  168,  168,  168,  168,  168,  120,   69,
+      168,   68,  166,  166,  166,  120,   69,   68,  164,  164,
+      164,  164,  164,  164,  120,   69,  164,   68,  168,  168,
+      168,  168,  168,  168,  168,  166,  166,  166,  164,  164,
+      164,  164,  164,  164,  164,  168,  168,   56,  168,  168,
+      168,  168,  166,   56,  166,  164,  164,   56,  164,  164,
+      164,  164,  168,  168,  168,  168,  168,  101,  166,  166,
+
+      164,  164,  164,  164,  164,  101,  168,   54,  168,  168,
+      168,   54,  166,  164,   54,  164,  164,  164,  168,  168,
+      168,  168,  166,  164,  164,  164,  164,  168,  168,  168,
+      168,  166,  164,  164,  164,  164,   80,  168,  168,  168,
+      166,   80,  164,  164,  164,   55,  168,  168,   55,   55,
+      164,  164,   82,  168,   82,  164,  168,  164,   83,   83,
+        0
     } ;
 
 static yyconst flex_int32_t yy_ec[256] =
@@ -551,16 +542,16 @@
         1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    2,    4,    5,    6,    7,    8,    9,    1,   10,
-       11,   12,   13,   14,   15,   16,   17,   18,   19,   19,
-       19,   19,   19,   19,   19,   19,   19,   20,   21,   22,
-       23,   24,   25,    1,   26,   27,   28,   29,   30,   31,
-       32,   33,   34,   35,   36,   37,   38,   39,   40,   41,
-       42,   43,   44,   45,   46,   47,   48,   49,   50,   51,
-       52,   53,   54,   55,   56,    1,   57,   58,   59,   60,
-
-       61,   62,   63,   64,   65,   16,   66,   67,   68,   69,
-       70,   71,   16,   72,   73,   74,   75,   16,   16,   76,
-       16,   77,   78,   79,   80,   81,    1,    1,    1,    1,
+       11,   12,   13,   14,   15,   16,   17,   18,   19,   20,
+       19,   19,   19,   19,   19,   19,   19,   21,   22,   23,
+       24,   25,   26,    1,   27,   28,   29,   30,   31,   32,
+       33,   34,   35,   36,   37,   38,   39,   40,   41,   42,
+       43,   44,   45,   46,   47,   48,   49,   50,   51,   52,
+       53,   54,   55,   56,   57,    1,   58,   59,   60,   61,
+
+       62,   63,   64,   65,   66,   16,   67,   68,   69,   70,
+       71,   72,   16,   73,   74,   75,   76,   16,   16,   77,
+       16,   78,   79,   80,   81,   82,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
@@ -577,657 +568,670 @@
         1,    1,    1,    1,    1
     } ;
 
-static yyconst flex_int32_t yy_meta[82] =
+static yyconst flex_int32_t yy_meta[83] =
     {   0,
         1,    1,    2,    3,    1,    1,    4,    1,    1,    1,
-        1,    5,    6,    7,    8,    9,   10,   11,   11,    8,
-        1,    1,    7,    1,    5,   11,   11,   11,   11,   11,
-       11,    9,    9,    9,    9,    9,    9,    9,    9,    9,
-        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
-        9,    8,    4,    8,    3,    9,   11,   11,   11,   11,
+        1,    5,    6,    7,    8,    9,   10,   11,   11,   11,
+        8,    1,    1,    7,    1,    5,   11,   11,   11,   11,
        11,   11,    9,    9,    9,    9,    9,    9,    9,    9,
-        9,    9,    9,    9,    9,    9,    9,    1,    1,    1,
-       10
+        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
+        9,    9,    8,    4,    8,    3,    9,   11,   11,   11,
+       11,   11,   11,    9,    9,    9,    9,    9,    9,    9,
+        9,    9,    9,    9,    9,    9,    9,    9,    1,    1,
+        1,   10
     } ;
 
-static yyconst flex_int16_t yy_base[1560] =
+static yyconst flex_int16_t yy_base[1586] =
     {   0,
-        0,    0,    0,    0,   81,    0,  162,    0,  243,  323,
-      403,    0,  271,  273,  484,  565,  646,  727, 2496, 2497,
-     2497, 2493, 2497, 2471, 2488,  791, 2497,  260, 2497, 2497,
-     2469, 2468,    0, 2467,    0,  247,  321,  492,    0, 2497,
-      249, 2466,  257,    0,  255,  252,  251,  275,  254,  270,
-     2445, 2450, 2447, 2455,  266,  282,  320,  270,  319, 2438,
-      350, 2457, 2452,    0,    0, 2423, 2419, 2407, 2413, 2497,
-      288, 2497,    0, 2497, 2475, 2453, 2470,  836, 2497,  345,
-     2497, 2497, 2451, 2450, 2497,  291,    0,  341,  881,  211,
-     2497, 2497,  333, 2449,  342, 2497,  940,  487,  506,  565,
-
-      577,  571, 2428, 2431, 2439,  331,  347,  339,  476, 2425,
-      352, 2497, 2497,  644, 2402, 2497,  295, 2497,    0,  999,
-      477,    0,  376,  735,  747,  596,  492,  477,  515,  473,
-      515, 2423, 2428, 2425, 2433,  517,  567,  573,  585,  594,
-     2416,  645, 2435, 2430, 2401, 2397, 2385, 2391,    0, 1044,
-     2497, 2497,    0, 2497, 2497, 2452, 1089, 2431, 2430, 2497,
-     2429,    0, 2428,    0,  442, 2497,    0, 2427, 2497, 1134,
-      635,  666,  602,  657,  671,  500, 2423, 2405, 2401,  551,
-     2403, 2497, 2497,  685,  677,  732,  694,  730,  250, 2388,
-     2372, 2368,  302, 2370,    0, 2439, 2497,    0, 2428, 2497,
-
-        0, 2497, 2497, 2497, 2419,  536,  505,  541, 2497, 2497,
-     2436, 2497, 2432, 2497,    0, 1193, 2497, 2497,    0,    0,
-        0,    0,    0,  757,    0,  736, 2413, 2497,    0, 2497,
-     2412, 2390, 2404, 2398,  586,    0, 2392, 2390, 2384,  566,
-     2398, 2382, 2395, 2395, 2379,  608, 2386, 2382, 2378, 2380,
-     2382,  727, 2388, 2378,  346, 2375, 2377, 2365,  646, 2376,
-     2378, 2366, 2380, 2380, 2368, 2381,  691, 2366, 2354, 2361,
-     2373, 2356, 2375, 2373, 2355, 2355, 2354, 2323, 2326, 2331,
-     2316, 2497, 2497,    0, 1244, 2497, 2497, 2497,    0, 2497,
-     2497,  478,  808,    0, 2497, 2497,    0, 2497,  787,  841,
-
-      844,    0, 2358,  594,    0,  889, 2352, 2350,  641,  917,
-      976, 2359, 2360, 2347, 2355, 2355, 2345, 2357, 2333, 2342,
-     2331,  673, 2342, 2344, 2347, 2336, 2343, 2323, 2343, 2345,
-      949, 2294,    0, 1295,    0,    0,  884,    0, 2326, 2340,
-     2334,  735,    0, 2328, 2326, 2320,  677, 2334, 2318, 2331,
-     2331, 2315,  711, 2322, 2318, 2314, 2316, 2318,  802, 2324,
-     2314,  738,  656, 2314, 2312, 2301,  750, 2312, 2314, 2302,
-     2316, 2316, 2304, 2317,  754, 2302, 2290, 2297, 2309, 2292,
-     2311, 2309, 2291, 2291, 2290, 2259, 2262, 2267, 2252,    0,
-     1346, 2325, 2497,    0, 1397,    0,    0,    0,  801,  888,
-
-      802,    0, 2293,  928,  937, 2292, 2296, 2279, 2280, 2278,
-     2295, 2282, 2290, 2291, 2289, 2290, 2269,  810, 2249,  832,
-      850, 2248, 2252, 2237, 2238, 2236, 2251, 2239, 2246, 2247,
-     2245, 2246, 2227, 2299,    0,    0, 2280, 2279,  816,  722,
-      656, 2497, 2497, 2258, 2254, 2264, 2265, 2255, 2264, 2264,
-     2261, 2246, 2239, 2262, 2261, 2252, 2257, 2241, 2246, 2252,
-     2244, 2254, 2251, 2232,    0, 2240, 2236, 2241, 2228, 2232,
-     2240, 2242, 2238,    0, 2229, 2223, 2224, 2229, 2225, 2214,
-     2231, 2221, 2218, 2217, 2212, 2229, 2214, 2211, 2217, 2211,
-     2223, 2207, 2223, 2224, 2206, 2222, 2210, 2214, 2201, 2174,
-
-        0,    0, 2182,    0,    0,  970, 2202, 1004, 2209, 2210,
-     2200, 2209, 2209, 2192, 2185, 2208, 1008, 2205, 2195, 2185,
-     2190, 2188, 2196, 2198,    0,    0, 2181, 2182, 2184, 2173,
-     2190, 2178, 2173, 2181, 2188, 2189, 2190, 2145, 2153,    0,
-        0, 2173, 2169, 2179, 2180, 2170, 2179, 2179, 2176, 2161,
-     2154, 2177, 2176, 2167, 2172, 2156, 2161, 2167, 2159, 2169,
-     2166, 2147,    0, 2155, 2151, 2156, 2143, 2147, 2155, 2157,
-     2153,    0,    0, 2144,    0, 2138, 2139, 2144, 2140, 2129,
-     2146, 2136, 2133, 2132, 2127, 2144, 2129, 2126, 2132, 2126,
-     2138, 2122, 2138, 2139, 2121, 2137, 2125, 2129, 2116, 2089,
-
-        0,    0, 2097,    0,    0, 2117,  808, 2126, 2125, 2113,
-        0, 2123, 2114, 2106, 2121, 2119, 2118, 2110, 2101, 2102,
-     2105, 2073,  872, 2081, 2080, 2069,    0, 2078, 2070, 2063,
-     2076, 2074, 2073, 2066, 2058, 2059, 2061,  700,  821,  742,
-     2092,    0, 2089, 2084, 2096,    0, 2089,    0, 2079,    0,
-     2078, 2066, 2082, 2075, 2069, 2072, 2074,    0, 2071, 2085,
-     2073, 2067,    0, 2085, 2066,    0, 2065, 2083,    0, 2065,
-        0, 2067, 2066, 2079, 2048, 2069, 2056, 2064, 2056, 2065,
-        0, 2070, 2063, 2066, 2050, 2054, 2037, 2058, 2062, 2045,
-     2052, 2054, 2057, 2052, 2018, 2014, 2046,    0, 2043, 2038,
-
-     2050,    0, 2043, 2033,    0, 2021, 2037, 2030, 2028, 2032,
-        0,    0, 2027, 2045,    0, 2030, 2043, 2012, 2033, 2029,
-     2031, 2034, 2023, 2028, 2024, 1993, 1989, 2021,    0, 2018,
-     2013, 2025,    0, 2018,    0, 2008,    0, 2007, 1995, 2011,
-     2004, 1998, 2001, 2003,    0, 2000, 2014, 2002, 1996,    0,
-     2014, 1995,    0, 1994, 2012,    0, 1994,    0, 1996, 1995,
-     2008, 1977, 1998, 1985, 1993, 1985, 1994,    0, 1999, 1992,
-     1995, 1979, 1983, 1966, 1987, 1991, 1965, 1962, 1954, 1947,
-     1935, 1896, 1891, 1921, 1911, 1915,    0,    0,    0, 1906,
-     1912, 1465,    0,    0, 1884, 1882,    0, 1865, 1880, 1825,
-
-     1818, 1821,    0,    0,    0, 1817, 1824, 1545,    0,    0,
-     1803,  213,    0,  211,  335,  841,  825,  860,  467,  508,
-      508,  569,    0,  832,  604,  591,  628,    0,    0,  671,
-      758,    0,  742,    0,  783,  808,    0,  823,  831,  822,
-      847,  866,  872,  870,  867,  879,  902,    0,  902,  903,
-      897,  909,    0,  922,  929,  934,    0,  917,  941,  952,
-      937,  943,  912,  926,  944,  951,  947,  965,    0,  970,
-      965,  981,    0,  983,    0,  981,  986,  975,  994,  990,
-      993, 1008, 1010, 1001, 1012, 1018, 1012,  975,  989, 1008,
-     1015, 1019, 1035,    0, 1040, 1037, 1024, 1039,    0,    0,
-
-     1047, 1038,    0, 1022,    0, 1050, 1046,    0, 1048, 1053,
-     1034, 1041, 1060, 1058, 1054, 1050, 1045, 1065,    0, 1063,
-     1060, 1054, 1056,    0, 1065, 1070, 1072,    0, 1053, 1066,
-     1082, 1065, 1071, 1037, 1051, 1068,    0, 1083, 1083, 1078,
-        0, 1625,    0, 1096,    0, 1099, 1051,    0, 1059, 1059,
-     1055,    0, 1705,    0, 1071,    0, 1074, 1112, 1113, 1114,
-     1090, 1105,    0, 1108, 1099, 1093, 1084, 1111, 1113, 1113,
-        0, 1116, 1115, 1109,    0, 1126,    0, 1112, 1112,    0,
-     1127,    0, 1103, 1116, 1138, 1113, 1131, 1127, 1117, 1125,
-     1139, 1136, 1146,    0,    0, 1140, 1108, 1128, 1140, 1155,
-
-        0, 1158, 1149, 1159, 1161, 1167,    0, 1170, 1156,    0,
-     1170,    0, 1152, 1173, 1160, 1150, 1170, 1176, 1135, 1157,
-     1169, 1184,    0, 1187, 1178, 1172, 1169, 1196, 1198, 1198,
-        0, 1202, 1202, 1188,    0, 1205,    0, 1191, 1191,    0,
-     1206,    0, 1182, 1189, 1210, 1185, 1203, 1198, 1188, 1195,
-     1209, 1206, 1216,    0,    0, 1210, 1182, 1201, 1213, 1220,
-        0,    0,    0, 1219, 1191, 1196,    0,    0,    0, 1193,
-     1248, 1249, 1246,    0, 1247, 1233, 1251, 1241, 1251,    0,
-     1228, 1245,    0, 1230, 1244, 1245,    0, 1233, 1264,    0,
-     1235, 1263, 1249, 1238, 1263, 1241,    0,    0, 1259,    0,
-
-     1238, 1236, 1277,    0, 1278, 1264, 1279,    0, 1259, 1273,
-     1274, 1262,    0, 1263, 1264, 1294,    0, 1289, 1268, 1266,
-     1302,    0, 1304, 1290, 1308, 1297, 1306,    0, 1283, 1300,
-        0, 1285, 1299, 1300,    0, 1288, 1319,    0, 1290, 1318,
-     1304, 1293, 1318, 1302,    0,    0, 1320,    0, 1299, 1298,
-     1336, 1338, 1338, 1308, 1310, 1310,    0, 1349,    0, 1334,
-     1353, 1343, 1352, 1347, 1358,    0, 1357, 1345, 1346, 1350,
-     1358, 1358,    0, 1349, 1364, 1370,    0,    0, 1334,    0,
-     1368,    0, 1360, 1368,    0, 1370, 1358, 1369, 1366, 1381,
-        0,    0, 1352,    0, 1388,    0, 1373, 1392, 1382, 1390,
-
-     1384, 1401,    0, 1400, 1388, 1389, 1394, 1403, 1403,    0,
-     1394, 1409, 1414,    0,    0, 1380,    0,    0,    0,    0,
-        0,    0,    0, 1402, 1408, 1414, 1411, 1408, 1407, 1417,
-     1412, 1421, 1407, 1417, 1418, 1417, 1438, 1431, 1446, 1421,
-        0, 1450, 1447, 1451, 1443, 1450, 1440, 1466, 1436,    0,
-     1454, 1460, 1466, 1463, 1460, 1459, 1469, 1461, 1474, 1460,
-     1470, 1462, 1461, 1481, 1471, 1484, 1454, 1469, 1483, 1475,
-     1478, 1476, 1479, 1474,    0,    0, 1486, 1483, 1493,    0,
-     1497, 1495, 1491, 1488, 1467, 1489, 1492, 1486,    0,    0,
-     1502, 1506, 1504, 1474, 1492, 1506, 1498, 1501, 1499, 1502,
-
-     1497,    0,    0, 1509, 1510, 1523,    0, 1532, 1531, 1527,
-     1524, 1503, 1520, 1537, 1526, 1542, 1534, 1536,    0,    0,
-     1549, 1547, 1534, 1548, 1547, 1550, 1520, 1537, 1553,    0,
-     1555, 1542, 1556, 1526, 1544, 1561, 1545, 1561, 1553, 1555,
-        0,    0, 1568, 1566, 1553, 1567, 1566, 1569, 1540,    0,
-     1557, 1547,    0, 1548, 1565, 1561, 1577, 1563, 1566, 1571,
-        0, 1539, 1556,    0, 1583, 1569, 1572, 1544,    0, 1572,
-     1562,    0, 1563, 1580, 1576, 1592, 1583, 1589, 1599,    0,
-     1568, 1585, 1625, 1616, 1604,    0, 1605,    0, 1601, 1614,
-     1580, 1628, 1617,    0, 1613, 1586, 1604, 1635, 1636, 1624,
-
-        0, 1625,    0, 1622, 1629, 1596, 1626, 1635, 1634, 1644,
-     1638, 1620,    0,    0, 1647,    0, 1642, 1642, 1652,    0,
-        0,    0, 1639, 1647, 1646, 1656, 1650, 1632,    0,    0,
-     1659,    0, 1640, 1657, 1663, 1656, 1657, 1669, 1657, 1663,
-     1669, 1662, 1650, 1667, 1673, 1671, 1675, 1692, 1681, 1683,
-     1690,    0, 1680, 1684, 1688, 1686, 1700,    0, 1690, 1696,
-     1703,    0, 1693, 1697, 1701, 1694, 1713, 1702, 1702, 1715,
-     1707,    0, 1706, 1706, 1720, 1709, 1709, 1722, 1714,    0,
-     1712,    0, 1697, 1728, 1715,    0, 1700, 1717,    0, 1702,
-     1733, 1721, 1725, 1733, 1719, 1737, 1736, 1730, 1738, 1724,
-
-     1742, 1727, 1733, 1739, 1748, 1736, 1732, 1738, 1744, 1753,
-        0, 1751, 1741, 1737, 1757,    0, 1758, 1748, 1744,    0,
-     1751, 1757,    0,    0, 1753, 1759,    0, 1754,    0, 1755,
-     1757, 1758,    0,    0, 2497, 1797, 1808, 1819, 1830, 1841,
-     1852, 1860, 1868, 1876, 1884, 1895, 1903, 1914, 1925, 1936,
-     1939, 1948, 1956, 1862, 1964, 1975, 1986, 1997, 2008
+        0,    0,    0,    0,   82,    0,  164,    0,  246,  327,
+      408,    0,  275,  277,  490,  572,  654,  736, 2557, 2558,
+     2558, 2554, 2558, 2531, 2549,  801, 2558,  264, 2558, 2558,
+     2529, 2528,    0, 2527,    0,  250,  581,  499,    0, 2558,
+      252, 2526,  260,    0,  259,  255,  254,  255,  263,  273,
+     2505, 2510, 2507, 2515,  276,  285,  278,  315,  276, 2498,
+      326, 2517, 2512,    0,    0, 2483, 2479, 2467, 2473, 2558,
+      291, 2558,    0, 2558, 2536, 2513, 2531,  847, 2558,  334,
+     2558, 2558, 2511, 2510, 2558,  297,    0,  352,  893,  241,
+     2558, 2558,  299, 2509,  350, 2558,  953,  351,  357,  494,
+
+      503,  576, 2488, 2491, 2499,  353,  343,  496,  486, 2485,
+      516, 2558, 2558,  652, 2462, 2558,  320, 2558,    0, 1013,
+      482,    0,  380,  745,  757,  655,  572,  511,  534,  351,
+      519, 2483, 2488, 2485, 2493,  571,  578,  588,  590,  598,
+     2476,  661, 2495, 2490, 2461, 2457, 2445, 2451,    0, 1059,
+     2558, 2558,    0, 2558, 2558, 2513, 1105, 2491, 2490, 2558,
+     2489,    0, 2488,    0,  316, 2558,    0, 2487, 2558, 1151,
+      608,  686,  605,  677,  653,  364, 2483, 2465, 2461,  489,
+     2463, 2558, 2558,  724,  611,  661,  702,  740,  493, 2448,
+     2432, 2428,  541, 2430,    0, 2500, 2558,    0, 2489, 2558,
+
+        0, 2558, 2558, 2558, 2479,  567,  619,  546, 2558, 2558,
+     2497, 2558, 2493, 2558,    0, 1211, 2558, 2558,    0,    0,
+        0,    0,    0,  768,    0,  730, 2473, 2558,    0, 2558,
+     2472, 2450, 2464, 2458,  664,    0, 2452, 2450, 2444,  605,
+     2458, 2442, 2455, 2455, 2439,  595, 2446, 2442, 2438, 2440,
+     2442,  807, 2448, 2438,  683, 2435, 2437, 2425,  742, 2436,
+     2438, 2426, 2440, 2440, 2428, 2441,  811, 2426, 2414, 2421,
+     2433, 2416, 2435, 2433, 2415, 2415, 2414, 2383, 2386, 2391,
+     2376, 2558, 2558,    0, 1263, 2558, 2558, 2558,    0, 2558,
+     2558,  479,  864,    0, 2558, 2558,    0, 2558,  763,  842,
+
+      929,    0, 2418,  686,    0,  962, 2412, 2410,  991,  644,
+     1018, 1021, 2419, 2420, 2407, 2415, 2415, 2405, 2417, 2393,
+     2402, 2412, 2390,  632, 2401, 2403, 2406, 2395, 2402, 2382,
+     2402, 2404, 1024, 2353,    0, 1315,    0,    0,  878,    0,
+     2385, 2399, 2393,  728,    0, 2387, 2385, 2379, 2389,  783,
+     2392, 2376, 2389, 2389, 2373,  760, 2380, 2376, 2372, 2374,
+     2376,  813, 2382, 2372,  763,  760, 2372, 2370, 2380, 2358,
+      814, 2369, 2371, 2359, 2373, 2373, 2361, 2374,  821, 2359,
+     2347, 2354, 2366, 2349, 2368, 2366, 2348, 2348, 2347, 2316,
+     2319, 2324, 2309,    0, 1367, 2383, 2558,    0, 1419,    0,
+
+        0,    0,  830,  857,  843,    0, 2350,  890,  891, 2349,
+     2353, 2336, 2337, 2335, 2352, 2339, 2347, 2348, 2346, 2347,
+     2326,  866, 2306,  948,  951, 2305, 2309, 2294, 2295, 2293,
+     2308, 2296, 2303, 2304, 2302, 2303, 2284, 2357,    0,    0,
+     2337, 2336,  869,  868,  813, 2558, 2558, 2315, 2311, 2321,
+     2322, 2312, 2321, 2321, 2318, 2303, 2296, 2319, 2318, 2309,
+     2314, 2298, 2303, 2309, 2301, 2311, 2308, 2289,    0, 2297,
+     2293, 2298, 2285, 2289, 2297, 2299, 2295,    0, 2286, 2280,
+     2281, 2286, 2282, 2271, 2288, 2278, 2275, 2274, 2269, 2286,
+     2271, 2268, 2274, 2268, 2280, 2264, 2280, 2281, 2263, 2279,
+
+     2267, 2271, 2258, 2231,    0,    0, 2239,    0,    0,  926,
+     2259, 1055, 2266, 2267, 2257, 2266, 2266, 2256, 2248, 2241,
+     2264, 1067, 2261, 2251, 2241, 2246, 2244, 2252, 2254,    0,
+        0, 2245, 2236, 2237, 2239, 2228, 2245, 2233, 2228, 2236,
+     2243, 2244, 2245, 2200, 2208,    0,    0, 2228, 2224, 2234,
+     2235, 2225, 2234, 2234, 2231, 2223, 2215, 2208, 2231, 2230,
+     2221, 2226, 2210, 2215, 2221, 2213, 2223, 2220, 2201,    0,
+     2209, 2205, 2210, 2197, 2201, 2209, 2211, 2207,    0,    0,
+     2198,    0, 2200, 2191, 2192, 2197, 2193, 2182, 2199, 2189,
+     2186, 2185, 2180, 2197, 2182, 2179, 2185, 2179, 2191, 2175,
+
+     2191, 2192, 2174, 2190, 2178, 2182, 2169, 2142,    0,    0,
+     2150,    0,    0, 2170,  824, 2179, 2178, 2166,    0, 2176,
+     2167, 2159, 2174, 2172, 2171, 2163, 2154, 2155, 2158, 2126,
+      828, 2134, 2133, 2122,    0, 2131, 2123, 2116, 2129, 2127,
+     2126, 2119, 2111, 2112, 2114,  667,  707,  835, 2145,    0,
+     2142, 2137, 2149,    0, 2142,    0, 2132,    0, 2131, 2119,
+     2135, 2128, 2122, 2125, 2127,    0, 2124, 2138, 2126, 2120,
+        0, 2138, 2119,    0, 2118, 2136,    0, 2118,    0, 2120,
+     2119, 2132, 2101, 2122, 2109, 2117, 2109, 2118,    0, 2123,
+     2116, 2119, 2103, 2107, 2090, 2111, 2115, 2098, 2105, 2107,
+
+     2110, 2105, 2071, 2067, 2099,    0, 2096, 2091, 2103,    0,
+     2096, 2090, 2085,    0, 2073, 2089, 2082, 2080, 2084,    0,
+        0, 2079, 2097, 2066,    0, 2081, 2094, 2063, 2084, 2080,
+     2082, 2085, 2074, 2079, 2075, 2044, 2040, 2072,    0, 2069,
+     2064, 2076,    0, 2069,    0, 2063, 2058,    0, 2057, 2045,
+     2061, 2054, 2048, 2051, 2053,    0, 2050, 2064, 2052, 2046,
+        0, 2064, 2045,    0, 2044, 2062,    0, 2044, 2030,    0,
+     2045, 2044, 2057, 2026, 2047, 2034, 2033, 2015, 2014,    0,
+     2009, 1995, 1993, 1976, 1978, 1959, 1980, 1980, 1953, 1950,
+     1942, 1940, 1934, 1885, 1881, 1913, 1905, 1902,    0,    0,
+
+        0, 1892,  236, 1488,    0,    0,  252,  289,    0,  344,
+      468,  460,  488,  538,    0,    0,    0,  538,  608, 1569,
+        0,    0,  633,  659,    0,  657,  688,  895,  879,  870,
+      704,  729,  735,  782,    0,  922,  796,  808,  838,    0,
+        0,  869,  886,    0,  885,    0,  916,  913,    0,  916,
+      931,  918,  932,  951,  958,  961,  957,  955,  975,    0,
+      974,  971,  965,  969,    0,  978,  989,  993,    0,  976,
+      992, 1000,  988,  994,  962,  976, 1000, 1009, 1009, 1026,
+        0, 1038, 1033, 1016, 1034,    0, 1038,    0, 1046, 1051,
+     1043, 1039, 1062, 1059, 1056, 1076, 1074, 1066, 1075, 1081,
+
+     1074, 1034, 1048, 1067, 1074, 1070, 1095,    0, 1107, 1101,
+     1098, 1085, 1100,    0,    0, 1108, 1099,    0, 1083,    0,
+     1111, 1107,    0, 1109, 1114, 1095, 1108, 1103, 1122, 1120,
+     1116, 1112, 1107, 1127,    0, 1125, 1122, 1116, 1118,    0,
+     1127, 1132, 1134,    0, 1115, 1137, 1145, 1128, 1134, 1100,
+     1114, 1137,    0, 1147, 1147, 1142,    0, 1650,    0, 1161,
+        0, 1164, 1117,    0, 1125, 1125, 1121,    0, 1731,    0,
+     1137,    0, 1140, 1179, 1178, 1181, 1157, 1172,    0, 1175,
+     1166, 1160, 1151, 1184, 1187, 1187,    0, 1190, 1189, 1175,
+        0, 1193,    0, 1179, 1179,    0, 1194,    0, 1170, 1181,
+
+     1202, 1177, 1195, 1190, 1180, 1193, 1207, 1205, 1218,    0,
+        0, 1212, 1178, 1197, 1209, 1224,    0, 1227,    0, 1218,
+     1228, 1230, 1230,    0, 1232, 1236, 1219,    0, 1233,    0,
+     1215, 1236, 1222, 1218, 1238, 1244, 1204, 1227, 1239, 1254,
+        0, 1257,    0, 1248, 1242, 1239, 1266, 1268, 1268,    0,
+     1272, 1272, 1258,    0, 1275,    0, 1279, 1262, 1262,    0,
+     1277,    0, 1253, 1260, 1281, 1256, 1274, 1269, 1259, 1266,
+     1280, 1277, 1287,    0,    0, 1287, 1253, 1272, 1285, 1295,
+        0,    0,    0, 1291, 1263, 1268,    0,    0,    0, 1265,
+     1320, 1327, 1318,    0, 1319, 1305, 1324, 1314, 1323,    0,
+
+     1300, 1317,    0, 1302, 1316, 1317,    0, 1305, 1336,    0,
+     1307, 1335, 1321, 1310, 1335, 1313,    0,    0, 1331,    0,
+     1310, 1314, 1349,    0, 1350, 1337, 1355,    0, 1332, 1346,
+     1346, 1348, 1336,    0, 1343, 1344, 1368,    0, 1363, 1343,
+     1342, 1377,    0, 1378, 1364, 1382, 1371, 1380,    0, 1357,
+     1374,    0, 1359, 1373, 1373, 1375,    0, 1363, 1408,    0,
+     1364, 1392, 1378, 1367, 1397, 1375,    0,    0, 1393,    0,
+     1379, 1377, 1412, 1414, 1414, 1390, 1392, 1392,    0, 1425,
+        0, 1411, 1431, 1421, 1429, 1423, 1434,    0, 1433, 1421,
+     1422, 1426, 1434, 1434,    0, 1425, 1440, 1445,    0,    0,
+
+     1411,    0, 1444,    0, 1436, 1444,    0, 1446, 1453, 1443,
+     1457, 1450, 1470,    0,    0, 1441,    0, 1474,    0, 1459,
+     1478, 1468, 1476, 1470, 1486,    0, 1479, 1486, 1474, 1475,
+     1479, 1487, 1487,    0, 1478, 1493, 1498,    0,    0, 1464,
+        0,    0,    0,    0,    0,    0,    0, 1486, 1492, 1498,
+     1495, 1492, 1491, 1501, 1493, 1506, 1492, 1502, 1495, 1494,
+     1514, 1505, 1518, 1488,    0, 1516, 1513,    0, 1517, 1509,
+     1516, 1506, 1526, 1496,    0, 1514, 1520, 1526, 1524, 1521,
+     1520,    0, 1530, 1523, 1534, 1521, 1531, 1532, 1536, 1557,
+     1547, 1559, 1529, 1544, 1558, 1550, 1558, 1556, 1559, 1554,
+
+        0,    0, 1566, 1562, 1572,    0, 1576, 1574, 1570, 1567,
+     1546, 1568, 1571, 1565,    0,    0, 1581, 1585, 1583, 1553,
+     1571, 1585, 1577, 1580, 1578, 1581, 1576,    0,    0, 1588,
+     1584, 1594,    0, 1599, 1597, 1593, 1590, 1569, 1586, 1603,
+     1587, 1603, 1595, 1597,    0,    0, 1610, 1608, 1595, 1609,
+     1608, 1611, 1581, 1598, 1614,    0, 1616, 1603, 1622, 1595,
+     1618, 1636, 1620, 1636, 1628, 1630,    0,    0, 1643, 1641,
+     1633, 1647, 1646, 1649, 1619,    0, 1636, 1626,    0, 1627,
+     1644, 1640, 1656, 1642, 1645, 1650,    0, 1618, 1635,    0,
+     1662, 1648, 1651, 1623,    0, 1651, 1641,    0, 1642, 1659,
+
+     1655, 1671, 1657, 1660, 1665,    0, 1634, 1651, 1682, 1683,
+     1671,    0, 1672,    0, 1669, 1676, 1642, 1690, 1678,    0,
+     1674, 1646, 1665, 1717, 1696, 1684,    0, 1685,    0, 1682,
+     1689, 1664, 1701, 1709, 1709, 1719, 1713, 1695,    0,    0,
+     1727,    0, 1721, 1720, 1731,    0,    0,    0, 1718, 1726,
+     1725, 1735, 1729, 1711,    0,    0, 1738,    0, 1719, 1736,
+     1742, 1735, 1736, 1748, 1736, 1742, 1748, 1741, 1729, 1746,
+     1752, 1745, 1746, 1758, 1746, 1749, 1756,    0, 1746, 1750,
+     1754, 1747, 1761,    0, 1751, 1757, 1764,    0, 1754, 1758,
+     1762, 1755, 1774, 1763, 1763, 1776, 1768,    0, 1767, 1767,
+
+     1781, 1773, 1773, 1786, 1778,    0, 1776,    0, 1761, 1792,
+     1779,    0, 1764, 1781,    0, 1766, 1797, 1784, 1788, 1796,
+     1782, 1800, 1799, 1793, 1801, 1787, 1805, 1790, 1796, 1802,
+     1811, 1799, 1795, 1801, 1807, 1816,    0, 1814, 1804, 1800,
+     1817,    0, 1818, 1808, 1804,    0, 1811, 1817,    0,    0,
+     1813, 1819,    0, 1814,    0, 1815, 1817, 1818,    0,    0,
+     2558, 1858, 1869, 1880, 1891, 1902, 1913, 1921, 1929, 1937,
+     1945, 1956, 1964, 1975, 1986, 1997, 2000, 2009, 2017, 1923,
+     2025, 2036, 2047, 2058, 2069
     } ;
 
-static yyconst flex_int16_t yy_def[1560] =
+static yyconst flex_int16_t yy_def[1586] =
     {   0,
-     1536, 1536, 1535,    3, 1535,    5, 1535,    7, 1537, 1537,
-     1535,   11, 1538, 1538, 1539, 1539, 1540, 1540, 1535, 1535,
-     1535, 1535, 1535, 1535, 1541, 1542, 1535, 1535, 1535, 1535,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1535,
-     1535, 1542, 1535, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1535,
-     1535, 1535, 1542, 1535, 1535, 1535, 1541, 1543, 1535, 1535,
-     1535, 1535, 1535, 1535, 1535, 1535, 1543, 1543, 1535,   89,
-     1535, 1535, 1535, 1535, 1535, 1535, 1543,   97,   97,   97,
-
-       97,   97, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543,
-     1543, 1535, 1535,   97, 1543, 1535, 1535, 1535, 1543, 1544,
-     1535, 1544, 1544, 1535, 1535, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1545,
-     1535, 1535, 1545, 1535, 1535, 1546, 1547, 1548, 1535, 1535,
-     1535, 1547, 1547,   89,   89, 1535, 1549, 1535, 1535, 1547,
-      170,  170,  170,  170,  170, 1547, 1547, 1547, 1547, 1547,
-     1547, 1535, 1535,  170,  170,  170,  170,  170, 1547, 1547,
-     1547, 1547, 1547, 1547, 1547, 1535, 1535, 1550, 1535, 1535,
-
-     1551, 1535, 1535, 1535, 1552, 1552, 1552, 1552, 1535, 1535,
-     1535, 1535, 1541, 1535, 1542, 1542, 1535, 1535, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542,  216, 1535, 1535, 1542, 1535,
-     1535, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1535, 1535, 1543, 1543, 1535, 1535, 1535, 1553, 1535,
-     1535,   89,   89,  293, 1535, 1535, 1554, 1535,   97,   97,
-
-       97, 1543, 1543, 1543, 1543,   97, 1543, 1543, 1543,   97,
-       97, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543,
-     1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543,
-       97, 1543, 1544, 1544, 1555, 1544, 1535, 1554, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1545,
-     1545, 1546, 1535, 1547, 1547, 1548, 1548, 1549,  170,  170,
-
-      170, 1547, 1547,  170,  170, 1547, 1547, 1547, 1547, 1547,
-     1547, 1547, 1547, 1547, 1547, 1547, 1547,  170, 1547,  170,
-      170, 1547, 1547, 1547, 1547, 1547, 1547, 1547, 1547, 1547,
-     1547, 1547, 1547, 1535, 1550, 1551, 1552, 1535, 1552, 1552,
-     1552, 1535, 1535, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-
-     1542, 1542, 1542, 1543, 1553, 1554, 1543,   97, 1543, 1543,
-     1543, 1543, 1543, 1543, 1543, 1543,   97, 1543, 1543, 1543,
-     1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543,
-     1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1544,
-     1555, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-
-     1544, 1544, 1544, 1545, 1547, 1547, 1547, 1547, 1547, 1547,
-     1547, 1547, 1547, 1547, 1547, 1547, 1547, 1547, 1547, 1547,
-     1547, 1547, 1547, 1547, 1547, 1547, 1547, 1547, 1547, 1547,
-     1547, 1547, 1547, 1547, 1547, 1547, 1547, 1552, 1552, 1552,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1543, 1543, 1543, 1543,
-
-     1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543,
-     1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543,
-     1543, 1543, 1543, 1543, 1543, 1543, 1543, 1544, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1544, 1547, 1547, 1547, 1547, 1547, 1547, 1547,
-     1547, 1556, 1547, 1547, 1547, 1547, 1547, 1547, 1547, 1547,
-
-     1547, 1547, 1547, 1547, 1547, 1547, 1547, 1557, 1547, 1547,
-     1547, 1547, 1547, 1547, 1547, 1552, 1552, 1552, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1543, 1543, 1543, 1543, 1543, 1543,
-     1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543,
-     1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1547, 1547, 1547, 1547, 1547,
-     1558, 1556, 1547, 1547, 1547, 1547, 1547, 1547, 1547, 1547,
-     1547, 1559, 1557, 1547, 1547, 1547, 1547, 1552, 1552, 1552,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1543, 1543,
-
-     1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543,
-     1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1547, 1547,
-     1547, 1547, 1547, 1547, 1547, 1547, 1547, 1547, 1547, 1547,
-     1552, 1552, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-
-     1542, 1542, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543,
-     1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1547, 1547, 1547, 1547, 1547, 1547, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1543,
-     1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543,
-     1543, 1543, 1543, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1547, 1547, 1547, 1547,
-     1547, 1547, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1543, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1543, 1543, 1543, 1543, 1543,
-     1543, 1543, 1543, 1543, 1544, 1544, 1544, 1544, 1544, 1544,
-
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1543, 1543, 1543,
-     1543, 1543, 1543, 1543, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1542, 1543, 1543, 1543, 1543, 1543, 1543, 1544, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1543, 1543, 1543, 1543, 1543, 1544, 1544, 1544, 1544,
-
-     1544, 1544, 1544, 1544, 1544, 1544, 1542, 1542, 1542, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1543, 1543, 1543, 1543,
-     1543, 1543, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1544,
-     1544, 1544, 1542, 1542, 1542, 1542, 1542, 1542, 1542, 1543,
-     1543, 1543, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1542,
-     1542, 1542, 1542, 1542, 1542, 1542, 1543, 1543, 1543, 1544,
-     1544, 1544, 1544, 1544, 1544, 1544, 1542, 1542, 1542, 1542,
-     1542, 1542, 1543, 1543, 1544, 1544, 1544, 1544, 1544, 1544,
-     1542, 1542, 1542, 1542, 1542, 1543, 1543, 1544, 1544, 1544,
-     1544, 1544, 1542, 1542, 1542, 1542, 1543, 1544, 1544, 1544,
-
-     1544, 1542, 1542, 1542, 1542, 1543, 1544, 1544, 1544, 1544,
-     1542, 1542, 1542, 1542, 1543, 1544, 1544, 1544, 1544, 1542,
-     1542, 1542, 1543, 1544, 1544, 1544, 1542, 1542, 1544, 1544,
-     1542, 1544, 1542, 1544,    0, 1535, 1535, 1535, 1535, 1535,
-     1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535,
-     1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535
+     1562, 1562, 1561,    3, 1561,    5, 1561,    7, 1563, 1563,
+     1561,   11, 1564, 1564, 1565, 1565, 1566, 1566, 1561, 1561,
+     1561, 1561, 1561, 1561, 1567, 1568, 1561, 1561, 1561, 1561,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1561,
+     1561, 1568, 1561, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1561,
+     1561, 1561, 1568, 1561, 1561, 1561, 1567, 1569, 1561, 1561,
+     1561, 1561, 1561, 1561, 1561, 1561, 1569, 1569, 1561,   89,
+     1561, 1561, 1561, 1561, 1561, 1561, 1569,   97,   97,   97,
+
+       97,   97, 1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569,
+     1569, 1561, 1561,   97, 1569, 1561, 1561, 1561, 1569, 1570,
+     1561, 1570, 1570, 1561, 1561, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1571,
+     1561, 1561, 1571, 1561, 1561, 1572, 1573, 1574, 1561, 1561,
+     1561, 1573, 1573,   89,   89, 1561, 1575, 1561, 1561, 1573,
+      170,  170,  170,  170,  170, 1573, 1573, 1573, 1573, 1573,
+     1573, 1561, 1561,  170,  170,  170,  170,  170, 1573, 1573,
+     1573, 1573, 1573, 1573, 1573, 1561, 1561, 1576, 1561, 1561,
+
+     1577, 1561, 1561, 1561, 1578, 1578, 1578, 1578, 1561, 1561,
+     1561, 1561, 1567, 1561, 1568, 1568, 1561, 1561, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568,  216, 1561, 1561, 1568, 1561,
+     1561, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1561, 1561, 1569, 1569, 1561, 1561, 1561, 1579, 1561,
+     1561,   89,   89,  293, 1561, 1561, 1580, 1561,   97,   97,
+
+       97, 1569, 1569, 1569, 1569,   97, 1569, 1569,   97, 1569,
+       97,   97, 1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569,
+     1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569,
+     1569, 1569,   97, 1569, 1570, 1570, 1581, 1570, 1561, 1580,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1571, 1571, 1572, 1561, 1573, 1573, 1574,
+
+     1574, 1575,  170,  170,  170, 1573, 1573,  170,  170, 1573,
+     1573, 1573, 1573, 1573, 1573, 1573, 1573, 1573, 1573, 1573,
+     1573,  170, 1573,  170,  170, 1573, 1573, 1573, 1573, 1573,
+     1573, 1573, 1573, 1573, 1573, 1573, 1573, 1561, 1576, 1577,
+     1578, 1561, 1578, 1578, 1578, 1561, 1561, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1569, 1579, 1580,
+     1569,   97, 1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569,
+     1569,   97, 1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569,
+     1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569,
+     1569, 1569, 1569, 1569, 1569, 1570, 1581, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1571, 1573, 1573, 1573, 1573, 1573, 1573, 1573, 1573,
+     1573, 1573, 1573, 1573, 1573, 1573, 1573, 1573, 1573, 1573,
+     1573, 1573, 1573, 1573, 1573, 1573, 1573, 1573, 1573, 1573,
+     1573, 1573, 1573, 1573, 1573, 1578, 1578, 1578, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+
+     1568, 1568, 1568, 1568, 1569, 1569, 1569, 1569, 1569, 1569,
+     1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569,
+     1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569,
+     1569, 1569, 1569, 1569, 1569, 1569, 1569, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1573, 1573, 1573, 1573, 1573,
+
+     1573, 1573, 1573, 1582, 1573, 1573, 1573, 1573, 1573, 1573,
+     1573, 1573, 1573, 1573, 1573, 1573, 1573, 1573, 1573, 1583,
+     1573, 1573, 1573, 1573, 1573, 1573, 1573, 1578, 1578, 1578,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1569, 1569, 1569, 1569,
+     1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569,
+     1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569,
+
+     1569, 1569, 1569, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1573, 1573, 1573, 1573, 1573, 1584, 1582, 1573, 1573,
+     1573, 1573, 1573, 1573, 1573, 1573, 1573, 1585, 1583, 1573,
+     1573, 1573, 1573, 1578, 1578, 1578, 1568, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1569, 1569, 1569, 1569, 1569, 1569,
+     1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569,
+     1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1573, 1573,
+     1573, 1573, 1573, 1573, 1573, 1573, 1573, 1573, 1573, 1573,
+     1578, 1578, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569,
+     1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569,
+     1569, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1573, 1573, 1573, 1573, 1573, 1573, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+
+     1568, 1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569,
+     1569, 1569, 1569, 1569, 1569, 1569, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1573, 1573, 1573, 1573, 1573, 1573, 1568, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1569, 1569, 1569, 1569, 1569, 1569,
+     1569, 1569, 1569, 1569, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569, 1569,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1568, 1569, 1569, 1569, 1569, 1569, 1569, 1569,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1569, 1569,
+     1569, 1569, 1569, 1569, 1570, 1570, 1570, 1570, 1570, 1570,
+
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1568, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1568, 1568, 1569, 1569, 1569,
+     1569, 1569, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1568, 1568, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1569, 1569, 1569, 1569, 1569, 1569, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1568, 1568,
+     1568, 1568, 1568, 1568, 1568, 1569, 1569, 1569, 1570, 1570,
+     1570, 1570, 1570, 1570, 1570, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1569, 1569, 1569, 1570, 1570, 1570, 1570, 1570,
+     1570, 1570, 1568, 1568, 1568, 1568, 1568, 1568, 1569, 1569,
+
+     1570, 1570, 1570, 1570, 1570, 1570, 1568, 1568, 1568, 1568,
+     1568, 1569, 1569, 1570, 1570, 1570, 1570, 1570, 1568, 1568,
+     1568, 1568, 1569, 1570, 1570, 1570, 1570, 1568, 1568, 1568,
+     1568, 1569, 1570, 1570, 1570, 1570, 1568, 1568, 1568, 1568,
+     1569, 1570, 1570, 1570, 1570, 1568, 1568, 1568, 1569, 1570,
+     1570, 1570, 1568, 1568, 1570, 1570, 1568, 1570, 1568, 1570,
+        0, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561,
+     1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561,
+     1561, 1561, 1561, 1561, 1561
     } ;
 
-static yyconst flex_int16_t yy_nxt[2579] =
+static yyconst flex_int16_t yy_nxt[2641] =
     {   0,
        21,   22,   23,   24,   25,   21,   26,   27,   28,   29,
-       30,   31,   32,   33,   34,   35,   36,   37,   38,   39,
-       40,   41,   42,   43,   44,   45,   46,   47,   48,   49,
-       50,   51,   52,   53,   35,   54,   55,   56,   57,   58,
-       59,   60,   35,   61,   62,   35,   63,   35,   35,   35,
-       35,   64,   35,   65,   21,   35,   66,   35,   35,   35,
-       35,   35,   35,   35,   35,   35,   67,   35,   35,   68,
-       35,   35,   69,   35,   35,   35,   35,   70,   71,   72,
-       73,   74,   75,   23,   76,   77,   74,   78,   79,   80,
-       81,   82,   83,   84,   85,   86,   87,   88,   89,   90,
-
-       91,   92,   93,   94,   95,   96,   97,   98,   99,  100,
-      101,  102,  103,   87,  104,   87,  105,  106,  107,  108,
-      109,  110,   87,   87,  111,   87,   87,   87,   87,   87,
-       87,   87,  112,   87,  113,   74,   87,  114,  102,  102,
-      102,  102,  102,   87,   87,   87,   87,   87,   87,   87,
-       87,   87,   87,  115,   87,   87,   87,   87,  116,  117,
-      118,  119,   74,   75,   23,   76,   77,   74,  120,   79,
-       80,   81,   82,   83,   84,   85,  121,  122,  123,  124,
-      125,   91,   92,   93,   94,   95,   96,  126,  127,  128,
-      129,  130,  131,  132,  133,  134,  122,  135,  136,  137,
-
-      138,  139,  140,  141,  122,  142,  143,  122,  144,  122,
-      122,  122,  122,  112,  122,  113,   74,  122,  145,  122,
-      122,  122,  122,  122,  122,  122,  122,  122,  146,  122,
-      122,  147,  122,  122,  148,  122,  122,  122,  122,  116,
-      117,  118,  149,   74,   74,   20,   74,   74,   74,  150,
-       74,   74,   74,   74,   74,  151,   74,  152,  222,  295,
-      124,  125,   74,   74,   74,  154,   74,   74,  217,  223,
-      227,  228,  196,  197,  196,  197,  198,  955,  198,  230,
-      231,  232,  218,  233,  956,  237,  295,  199,  238,  199,
-      240,  234,  245,  241,   74,  254,   74,   74,  235,  236,
-
-      242,  239,  246,  247,  243,  255,  248,  256,  260,  249,
-      282,  257,  261,  288,  426,  262,  263,  282,  244,  427,
-       74,   74,   74,   74,   74,   20,   74,   74,   74,  150,
-       74,   74,   74,   74,   74,  151,   74,  152,  224,  224,
-      124,  125,   74,   74,   74,  154,   74,   74,  200,  258,
-      200,  264,  290,  217,  227,  228,  225,  289,  225,  259,
-      317,  265,  431,  291,  230,  231,  283,  218,  321,  226,
-      318,  472,  319,  283,   74,  432,   74,   74,  322,  267,
-      320,  327,  268,  269,  473,  328,  225,  290,  225,  270,
-      271,  272,  329,  957,  273,  274,  226,  330,  336,  275,
-
-       74,   74,   74,   21,   22,  155,   24,   21,  156,  157,
-       27,   28,   29,   30,  158,  159,  160,  161,  162,  163,
-      164,  165,  166,  167,   41,  168,   43,  169,  170,  171,
-      172,  173,  174,  175,  162,  162,  162,  162,  162,  176,
-      162,  177,  178,  179,  162,  162,  180,  181,  162,  162,
-      162,  162,  162,  162,  182,  162,  183,   21,  162,  184,
-      185,  186,  173,  187,  188,  162,  162,  162,  162,  189,
-      162,  190,  191,  192,  162,  193,  194,  162,  162,  162,
-       70,   71,   72,  195,   21,  196,  197,   21,   21,  198,
-      295,   21,   21,   21,   21,   21,   21,  202,   21,  288,
-
-      199,   21,   21,  202,  202,   21,   21,   21,   21,  224,
-      224,  352,  961,  306,  323,  306,  347,  295,  324,  348,
-      307,  353,  325,  308,  438,  344,  295,  225,  345,  225,
-      284,  284,  306,  410,  306,   21,   21,   21,   21,  411,
-      349,  346,  284,  335,  350,  309,  361,  962,  354,  284,
-      284,  355,  963,  295,  356,  438,  362,  225,  351,  225,
-      438,  203,   21,  204,   21,   21,  196,  197,   21,   21,
-      198,  440,   21,   21,   21,   21,   21,   21,  202,   21,
-      415,  199,   21,   21,  202,  202,   21,   21,   21,   21,
-      310,  306,  363,  306,  311,  416,  364,  306,  964,  306,
-
-      365,  284,  366,  306,  452,  306,  453,  284,  312,  284,
-      441,  439,  367,  284,  284,  284,   21,   21,   21,   21,
-      284,  284,  339,  368,  340,  313,  372,  369,  401,  447,
-      370,  371,  341,  967,  968,  459,  373,  510,  394,  342,
-      343,  448,  203,   21,  204,   21,   21,  196,  197,  511,
-       25,  198,  460,   21,   21,   21,   21,  969,   21,  202,
-      404,  401,  199,   21,   21,  202,  202,   21,   21,   21,
-      306,  394,  306,  477,  375,  438,  478,  376,  377,  514,
-      284,  515,  479,  401,  378,  379,  380,  284,  284,  381,
-      382,  405,  401,  394,  383,  407,  572,  401,  406,  970,
-
-      528,  331,  394,  401,  573,  408,  206,  394,  207,  529,
-      409,  401,  208,  394,  640,  550,  487,  551,  488,  438,
-      401,  394,  489,  209,   21,  210,   21,   21,  196,  197,
-      394,   25,  198,  420,   21,   21,   21,   21,  557,   21,
-      202,  438,  418,  199,   21,   21,  202,  202,   21,   21,
-       21,  419,  337,  337,  466,  558,  401,  467,  401,  468,
-      816,  438,  423,  570,  337,  337,  394,  469,  394,  424,
-      296,  215,  296,  215,  224,  224,  571,  577,  545,  587,
-      578,  588,  296,  338,  296,  589,  579,  206,  421,  207,
-      546,  639,  225,  208,  225,  422,  971,  972,  818,  425,
-
-      296,  215,  296,  215,  209,   21,  210,   21,  216,  216,
-      338,  973,  296,  306,  296,  306,  216,  216,  216,  216,
-      216,  216,  225,  284,  225,  293,  293,  401,  401,  564,
-      284,  284,  565,  785,  566,  438,  401,  394,  394,  786,
-      438,  974,  567, 1535,  438, 1535,  394,  216,  216,  216,
-      216,  216,  216,  285,  285,  975,  295,  965,  401,  976,
-      438,  285,  285,  285,  285,  285,  285,  306,  394,  306,
-      306,  977,  508, 1535,  966, 1535,  401,  284,  817,  438,
-      284,  959,  622,  295,  507,  284,  394,  284,  284,  638,
-      978,  979,  285,  285,  285,  285,  285,  285,  292,  292,
-
-      980,  337,  337,  981,  624,  982,  293,  294,  293,  294,
-      293,  293,  958,  295,  401,  306,  296,  306,  296,  296,
-      295,  296,  625,  983,  394,  284,  960,  984,  801,  297,
-      985,  606,  284,  284,  802,  986,  987,  293,  294,  293,
-      294,  293,  293,  306,  295,  306,  296,  988,  296,  296,
-      295,  296,  989,  284,  401,  990,  297,  299,  299,  991,
-      284,  516,  992,  401,  394,  299,  300,  299,  301,  299,
-      299,  608,  302,  394,  993,  306,  303,  306,  994,  302,
-      609,  995,  996,  304,  305,  284,  997,  998,  302,  999,
-     1000, 1001,  284,  284, 1002, 1003,  299,  306,  299,  306,
-
-      299,  299,  306,  302,  306,  296,  517,  296, 1004,  302,
-     1005, 1006,  284, 1007, 1008,  302,  334,  334, 1009,  284,
-      284,  538, 1010, 1011,  334,  334,  334,  334,  334,  334,
-      306, 1012,  306, 1013,  306,  296,  306,  296, 1014, 1015,
-      284,  707, 1016, 1017,  284, 1018,  698,  284,  284, 1019,
-     1020,  284,  284, 1021, 1022,  334,  334,  334,  334,  334,
-      334,  391,  391, 1023, 1024, 1025, 1027, 1028, 1029,  391,
-      391,  391,  391,  391,  391, 1030, 1031, 1032, 1033, 1034,
-     1035, 1036, 1026, 1037, 1038, 1039, 1040, 1041, 1042, 1043,
-     1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053,
-
-      391,  391,  391,  391,  391,  391,  395,  395, 1054, 1055,
-     1056, 1057, 1058, 1059,  395,  395,  395,  395,  395,  395,
-     1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069,
-     1070,  438,  438,  438, 1073, 1074, 1075, 1076, 1077, 1078,
-     1079, 1080, 1081, 1082, 1083,  395,  395,  395,  395,  395,
-      395,  399,  399, 1084, 1085, 1086, 1087, 1088, 1089,  399,
-      400,  399,  401,  399,  399, 1090,  402, 1091, 1092, 1093,
-      403, 1094, 1095,  402, 1096, 1097, 1098, 1099, 1100, 1072,
-     1071, 1101,  402, 1102, 1103, 1104, 1105, 1106, 1107, 1108,
-      399,  401,  399,  401,  399,  399, 1109,  402, 1110, 1111,
-
-     1112, 1113, 1114,  402, 1115, 1116, 1117, 1118, 1119,  402,
-      216,  216, 1120, 1121, 1122, 1123, 1124, 1125,  216,  216,
-      216,  216,  216,  216, 1126, 1127, 1128, 1129,  225, 1130,
-      225, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139,
-     1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148,  216,
-      216,  216,  216,  216,  216, 1149, 1150, 1151,  225, 1152,
-      225,  285,  285, 1153, 1154, 1155, 1156,  438,  438,  285,
-      285,  285,  285,  285,  285, 1157, 1158, 1159, 1160,  504,
-     1161,  504, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169,
-     1171, 1172, 1173, 1174, 1170, 1175, 1176, 1177, 1178, 1179,
-
-      285,  285,  285,  285,  285,  285, 1180, 1181, 1182,  504,
-     1183,  504,  334,  334, 1184, 1185, 1186, 1187, 1188, 1189,
-      334,  334,  334,  334,  334,  334, 1190, 1191, 1192, 1193,
-      540, 1194,  540, 1195, 1196, 1197, 1198, 1199, 1200, 1201,
-     1202, 1203, 1204, 1205, 1206, 1208, 1209, 1210, 1211, 1207,
-     1212,  334,  334,  334,  334,  334,  334, 1213, 1214, 1215,
-      540, 1216,  540,  391,  391, 1217, 1218, 1219, 1220, 1221,
-     1222,  391,  391,  391,  391,  391,  391, 1223, 1224, 1225,
-     1226,  604, 1227,  604, 1228, 1229, 1230, 1231, 1232, 1233,
-     1234, 1235, 1236, 1237, 1240, 1238, 1241, 1242, 1243, 1244,
-
-     1245, 1246,  391,  391,  391,  391,  391,  391, 1239, 1247,
-     1248,  604, 1249,  604,  395,  395, 1250, 1251, 1252, 1253,
-     1254, 1255,  395,  395,  395,  395,  395,  395, 1256, 1257,
-     1258, 1259,  605, 1260,  605, 1261, 1262, 1263, 1264, 1265,
-     1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1277, 1278,
-     1279, 1275, 1266,  395,  395,  395,  395,  395,  395, 1276,
-     1280, 1281,  605, 1282,  605,  941,  941, 1283,  941,  941,
-      941, 1284,  941,  941,  941,  941,  941, 1285,  941, 1286,
-     1287, 1288, 1289, 1291, 1292,  941,  941,  941,  941,  941,
-     1290, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301,
-
-     1302, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1303, 1311,
-     1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320,  941,
-     1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330,
-     1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340,
-     1341, 1342,  941,  941,  941,  952,  952, 1343,  952,  952,
-      952, 1344,  952,  952,  952,  952,  952, 1345,  952, 1346,
-     1347, 1348, 1349, 1350, 1351,  952,  952,  952,  952,  952,
-     1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361,
-     1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371,
-     1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380,  952,
-
-     1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390,
-     1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400,
-     1401, 1402,  952,  952,  952,  941,  941, 1403,  941,  941,
-      941, 1404,  941,  941,  941,  941,  941, 1405,  941, 1406,
-     1407, 1411, 1412, 1413, 1414,  941,  941,  941,  941,  941,
-     1408, 1415, 1416, 1417, 1409, 1420, 1421, 1418, 1422, 1423,
-     1424, 1427, 1428, 1429, 1425, 1430, 1431, 1410, 1432, 1433,
-     1419, 1434, 1435, 1436, 1437, 1438, 1439, 1426, 1440,  941,
-     1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450,
-     1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460,
-
-     1461, 1462,  941,  941,  941,  952,  952, 1463,  952,  952,
-      952, 1464,  952,  952,  952,  952,  952, 1465,  952, 1466,
-     1467, 1468, 1469, 1470, 1471,  952,  952,  952,  952,  952,
-     1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481,
-     1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491,
-     1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500,  952,
-     1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510,
-     1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520,
-     1521, 1522,  952,  952,  952, 1523, 1524, 1525, 1526, 1527,
-     1528, 1529, 1530, 1531, 1532, 1533, 1534,   20,   20,   20,
-
-       20,   20,   20,   20,   20,   20,   20,   20,  153,  153,
-      153,  153,  153,  153,  153,  153,  153,  153,  153,   21,
+       30,   31,   32,   33,   34,   35,   36,   37,   38,   38,
+       39,   40,   41,   42,   43,   44,   45,   46,   47,   48,
+       49,   50,   51,   52,   53,   35,   54,   55,   56,   57,
+       58,   59,   60,   35,   61,   62,   35,   63,   35,   35,
+       35,   35,   64,   35,   65,   21,   35,   66,   35,   35,
+       35,   35,   35,   35,   35,   35,   35,   67,   35,   35,
+       68,   35,   35,   69,   35,   35,   35,   35,   70,   71,
+       72,   73,   74,   75,   23,   76,   77,   74,   78,   79,
+       80,   81,   82,   83,   84,   85,   86,   87,   88,   89,
+
+       90,   90,   91,   92,   93,   94,   95,   96,   97,   98,
+       99,  100,  101,  102,  103,   87,  104,   87,  105,  106,
+      107,  108,  109,  110,   87,   87,  111,   87,   87,   87,
+       87,   87,   87,   87,  112,   87,  113,   74,   87,  114,
+      102,  102,  102,  102,  102,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,  115,   87,   87,   87,   87,
+      116,  117,  118,  119,   74,   75,   23,   76,   77,   74,
+      120,   79,   80,   81,   82,   83,   84,   85,  121,  122,
+      123,  124,  125,  125,   91,   92,   93,   94,   95,   96,
+      126,  127,  128,  129,  130,  131,  132,  133,  134,  122,
+
+      135,  136,  137,  138,  139,  140,  141,  122,  142,  143,
+      122,  144,  122,  122,  122,  122,  112,  122,  113,   74,
+      122,  145,  122,  122,  122,  122,  122,  122,  122,  122,
+      122,  146,  122,  122,  147,  122,  122,  148,  122,  122,
+      122,  122,  116,  117,  118,  149,   74,   74,   20,   74,
+       74,   74,  150,   74,   74,   74,   74,   74,  151,   74,
+      152,  222,  956,  124,  125,  125,   74,   74,   74,  154,
+       74,   74,  217,  223,  227,  228,  196,  197,  196,  197,
+      198,  242,  198,  230,  231,  243,  232,  218,  233,  237,
+      295,  199,  238,  199,  240,  959,  234,  241,   74,  244,
+
+       74,   74,  245,  235,  236,  239,  254,  247,  258,  264,
+      248,  256,  246,  249,  282,  257,  255,  295,  259,  265,
+      288,  227,  228,  960,   74,   74,   74,   74,   74,   20,
+       74,   74,   74,  150,   74,   74,   74,   74,   74,  151,
+       74,  152,  217,  282,  124,  125,  125,   74,   74,   74,
+      154,   74,   74,  200,  260,  200,  267,  218,  261,  268,
+      269,  262,  263,  290,  289,  295,  270,  271,  272,  320,
+      283,  273,  274,  230,  231,  291,  275,  321,  306,   74,
+      306,   74,   74,  318,  306,  307,  306,  309,  308,  961,
+      355,  290,  295,  319,  284,  284,  284,  310,  414,  283,
+
+      356,  284,  284,  338,  415,   74,   74,   74,   21,   22,
+      155,   24,   21,  156,  157,   27,   28,   29,   30,  158,
+      159,  160,  161,  162,  163,  164,  165,  165,  166,  167,
+       41,  168,   43,  169,  170,  171,  172,  173,  174,  175,
+      162,  162,  162,  162,  162,  176,  162,  177,  178,  179,
+      162,  162,  180,  181,  162,  162,  162,  162,  162,  162,
+      182,  162,  183,   21,  162,  184,  185,  186,  173,  187,
+      188,  162,  162,  162,  162,  189,  162,  190,  191,  192,
+      162,  193,  194,  162,  162,  162,   70,   71,   72,  195,
+       21,  196,  197,   21,   21,  198,  962,   21,   21,   21,
+
+       21,   21,   21,  202,   21,  288,  199,   21,   21,   21,
+      202,  202,   21,   21,   21,   21,  224,  224,  224,  419,
+      311,  306,  322,  306,  312,  325,  323,  963,  295,  326,
+      306,  284,  306,  327,  420,  225,  324,  225,  313,  284,
+      284,  349,   21,   21,   21,   21,  329,  284,  284,  337,
+      330,  350,  314,  357,  351,  295,  358,  331,  430,  359,
+      352,  964,  332,  431,  353,  225,  442,  225,  203,   21,
+      204,   21,   21,  196,  197,   21,   21,  198,  354,   21,
+       21,   21,   21,   21,   21,  202,   21,  442,  199,   21,
+       21,   21,  202,  202,   21,   21,   21,   21,  224,  224,
+
+      224,  364,  435,  306,  366,  306,  346,  965,  367,  347,
+      966,  365,  368,  284,  369,  436,  445,  225,  370,  225,
+      284,  284,  348,  463,   21,   21,   21,   21,  371,  372,
+      226,  376,  405,  373,  408,  405,  374,  375,  405,  442,
+      464,  377,  398,  443,  456,  398,  457,  225,  398,  225,
+      203,   21,  204,   21,   21,  196,  197,  226,   25,  198,
+      534,   21,   21,   21,   21,  967,   21,  202,  424,  535,
+      199,   21,   21,   21,  202,  202,   21,   21,   21,  306,
+      405,  306,  341,  519,  342,  520,  444,  442,  405,  284,
+      398,  379,  343,  413,  380,  381,  284,  284,  398,  344,
+
+      345,  382,  383,  384,  405,  970,  385,  386,  451,  476,
+      333,  387,  409,  405,  398,  206,  411,  207,  425,  410,
+      452,  208,  477,  398,  971,  426,  412,  442,  828,  405,
+      514,  972,  209,   21,  210,   21,   21,  196,  197,  398,
+       25,  198,  515,   21,   21,   21,   21,  973,   21,  202,
+      977,  405,  199,   21,   21,   21,  202,  202,   21,   21,
+       21,  398,  339,  339,  339,  829,  215,  405,  215,  978,
+      481,  427,  551,  482,  339,  339,  339,  398,  428,  483,
+      979,  296,  422,  296,  552,  224,  224,  224,  564,  577,
+      306,  423,  306,  296,  340,  296,  215,  206,  215,  207,
+
+      284,  579,  578,  208,  225,  565,  225,  284,  284,  580,
+      429,  296,  980,  296,  209,   21,  210,   21,  216,  216,
+      216,  340,  557,  296,  558,  296,  983,  216,  216,  216,
+      216,  216,  216,  442,  225,  470,  225,  491,  471,  492,
+      472,  571,  585,  493,  572,  586,  573,  595,  473,  596,
+      797,  587,  984,  597,  574,  442,  798,  405,  216,  216,
+      216,  216,  216,  216,  285,  285,  285,  398,  985,  306,
+      405,  306,  648,  285,  285,  285,  285,  285,  285,  284,
+      398,  293,  293,  293,  405,  813,  511,  284,  442,  442,
+      442,  814,  830,  405,  398,  339,  339,  339,  986,  442,
+
+     1561,  614, 1561,  398,  285,  285,  285,  285,  285,  285,
+      292,  292,  292,  295,  296,  442,  296,  405,  405,  293,
+      294,  293,  294,  293,  293,  987,  295,  398,  398,  296,
+     1561,  296, 1561,  295,  616,  617,  975,  976,  647,  630,
+      295,  988,  297,  646,  296,  989,  296,  990,  981,  991,
+      293,  294,  293,  294,  293,  293,  306,  295,  512,  296,
+      992,  296,  296,  295,  296,  982,  284,  974,  993,  297,
+      299,  299,  299,  284,  284,  405,  994,  995,  405,  299,
+      300,  299,  301,  299,  299,  398,  302,  996,  398,  306,
+      303,  306,  296,  302,  296,  997,  998,  304,  305,  284,
+
+      999, 1000,  302, 1001, 1002, 1003,  284,  284, 1004, 1005,
+      299,  306,  299,  306,  299,  299, 1006,  302,  306, 1007,
+      306,  632, 1008,  302,  633,  518, 1009, 1010,  284,  302,
+      336,  336,  336, 1011, 1012,  284,  284, 1013, 1014,  336,
+      336,  336,  336,  336,  336,  306, 1015,  306,  306, 1016,
+      306,  306,  522,  306, 1017,  284, 1018, 1019,  284, 1020,
+     1021,  284,  284,  521, 1022,  284,  284, 1023,  284,  284,
+      336,  336,  336,  336,  336,  336,  395,  395,  395, 1024,
+     1025, 1026,  306, 1027,  306,  395,  395,  395,  395,  395,
+      395, 1028,  284, 1029,  306, 1030,  306,  544,  706,  284,
+
+      284,  716, 1031, 1032,  284, 1033, 1034, 1035, 1036, 1037,
+     1038,  284,  284, 1039, 1040, 1041,  395,  395,  395,  395,
+      395,  395,  399,  399,  399, 1042, 1043, 1044, 1046, 1047,
+     1048,  399,  399,  399,  399,  399,  399, 1049, 1050, 1051,
+     1052, 1053, 1054, 1055, 1045, 1056, 1057, 1058, 1059, 1060,
+     1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070,
+     1071, 1072,  399,  399,  399,  399,  399,  399,  403,  403,
+      403, 1073, 1074, 1075, 1076, 1077, 1078,  403,  404,  403,
+      405,  403,  403, 1079,  406, 1080, 1081, 1082,  407, 1083,
+     1084,  406, 1085, 1086, 1087, 1088, 1089, 1090,  442,  442,
+
+      406,  442, 1093, 1094, 1095, 1096, 1097, 1098,  403,  405,
+      403,  405,  403,  403, 1099,  406, 1100, 1101, 1102, 1103,
+     1104,  406, 1105, 1106, 1107, 1108, 1109,  406,  216,  216,
+      216, 1110, 1111, 1112, 1113, 1114, 1115,  216,  216,  216,
+      216,  216,  216, 1116, 1117, 1092, 1118,  225, 1091,  225,
+     1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128,
+     1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136,  216,  216,
+      216,  216,  216,  216, 1137, 1138, 1139,  225, 1140,  225,
+      285,  285,  285, 1141, 1142, 1143, 1144, 1145, 1146,  285,
+      285,  285,  285,  285,  285, 1147, 1148, 1149, 1150,  508,
+
+     1151,  508, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159,
+     1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169,
+      285,  285,  285,  285,  285,  285, 1170, 1171, 1172,  508,
+     1173,  508,  336,  336,  336, 1174, 1175, 1176, 1177, 1178,
+      442,  336,  336,  336,  336,  336,  336,  442, 1179, 1180,
+     1181,  546, 1182,  546, 1183, 1184, 1185, 1186, 1187, 1188,
+     1189, 1190, 1191, 1193, 1194, 1195, 1196, 1192, 1197, 1198,
+     1199, 1200,  336,  336,  336,  336,  336,  336, 1201, 1202,
+     1203,  546, 1204,  546,  395,  395,  395, 1205, 1206, 1207,
+     1208, 1209, 1210,  395,  395,  395,  395,  395,  395, 1211,
+
+     1212, 1213, 1214,  612, 1215,  612, 1216, 1217, 1218, 1219,
+     1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229,
+     1232, 1233, 1234, 1235,  395,  395,  395,  395,  395,  395,
+     1236, 1237, 1238,  612, 1230,  612,  399,  399,  399, 1231,
+     1239, 1240, 1241, 1242, 1243,  399,  399,  399,  399,  399,
+      399, 1244, 1245, 1246, 1247,  613, 1248,  613, 1249, 1250,
+     1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260,
+     1261, 1262, 1264, 1265, 1266, 1267,  399,  399,  399,  399,
+      399,  399, 1268, 1269, 1263,  613, 1270,  613,  957,  957,
+     1271,  957,  957,  957, 1272,  957,  957,  957,  957,  957,
+
+     1273,  957, 1274, 1275, 1276, 1277, 1278, 1279, 1280,  957,
+      957,  957,  957,  957, 1281, 1282, 1283, 1284, 1285, 1286,
+     1287, 1288, 1289, 1290, 1291, 1293, 1294, 1295, 1296, 1297,
+     1298, 1299, 1300, 1301, 1303, 1304, 1305, 1292, 1306, 1307,
+     1308, 1302, 1309,  957, 1310, 1311, 1312, 1313, 1314, 1315,
+     1317, 1318, 1319, 1320, 1321, 1322, 1323, 1316, 1324, 1325,
+     1326, 1327, 1330, 1328, 1331, 1332,  957,  957,  957,  968,
+      968, 1329,  968,  968,  968, 1333,  968,  968,  968,  968,
+      968, 1334,  968, 1335, 1336, 1337, 1338, 1339, 1340, 1341,
+      968,  968,  968,  968,  968, 1342, 1343, 1344, 1345, 1346,
+
+     1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356,
+     1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366,
+     1367, 1368, 1369, 1370,  968, 1371, 1372, 1373, 1374, 1375,
+     1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385,
+     1386, 1387, 1388, 1389, 1390, 1391, 1392,  968,  968,  968,
+      957,  957, 1393,  957,  957,  957, 1394,  957,  957,  957,
+      957,  957, 1395,  957, 1396, 1397, 1398, 1399, 1400, 1401,
+     1402,  957,  957,  957,  957,  957, 1403, 1404, 1405, 1406,
+     1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416,
+     1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426,
+
+     1427, 1428, 1429, 1430, 1431,  957, 1432, 1433, 1434, 1437,
+     1438, 1439, 1435, 1440, 1441, 1442, 1443, 1446, 1447, 1448,
+     1444, 1449, 1453, 1454, 1455, 1436, 1456, 1457,  957,  957,
+      957,  968,  968, 1445,  968,  968,  968, 1458,  968,  968,
+      968,  968,  968, 1450,  968, 1459, 1460, 1451, 1461, 1462,
+     1463, 1464,  968,  968,  968,  968,  968, 1465, 1466, 1467,
+     1452, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476,
+     1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486,
+     1487, 1488, 1489, 1490, 1491, 1492,  968, 1493, 1494, 1495,
+     1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505,
+
+     1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514,  968,
+      968,  968, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522,
+     1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532,
+     1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542,
+     1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552,
+     1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560,   20,   20,
+       20,   20,   20,   20,   20,   20,   20,   20,   20,  153,
+      153,  153,  153,  153,  153,  153,  153,  153,  153,  153,
        21,   21,   21,   21,   21,   21,   21,   21,   21,   21,
-      201,  201,  201,  201,  201,  201,  201,  201,  201,  201,
-      201,  205,  205,  205,  205,  205,  205,  205,  205,  205,
-      205,  205,  213,  213,  213,  213,  213,  213,  213,  213,
-      213,  213,  213,  215,  215,  215,  215,  215,  215,  215,
-      215,  284,  506,  284,  954,  284,  284,  284,  284,  333,
-      951,  333,  333,  333,  333,  333,  333,  390,  950,  949,
-      948,  947,  390,  390,  390,  392,  392,  392,  392,  392,
-
-      392,  392,  392,  392,  392,  392,  394,  946,  394,  945,
-      394,  394,  394,  394,  396,  944,  396,  396,  396,  396,
-      396,  396,  396,  396,  396,  398,  943,  398,  398,  398,
-      398,  398,  398,  398,  398,  398,  435,  940,  435,  435,
-      435,  435,  435,  435,  435,  435,  435,  436,  939,  436,
-      437,  437,  437,  938,  937,  437,  437,  936,  437,  505,
-      935,  505,  934,  505,  505,  505,  505,  541,  933,  541,
-      541,  541,  541,  541,  541,  942,  932,  942,  942,  942,
-      942,  942,  942,  942,  942,  942,  953,  931,  953,  953,
-      953,  953,  953,  953,  953,  953,  953,  941,  930,  941,
-
-      941,  941,  941,  941,  941,  941,  941,  941,  952,  929,
-      952,  952,  952,  952,  952,  952,  952,  952,  952,  928,
-      927,  926,  925,  924,  923,  922,  921,  920,  919,  918,
-      917,  916,  915,  914,  913,  912,  911,  910,  909,  908,
-      907,  906,  905,  904,  903,  902,  901,  900,  899,  898,
-      897,  896,  895,  894,  893,  892,  891,  890,  889,  888,
-      887,  886,  885,  884,  883,  882,  881,  880,  879,  878,
-      877,  876,  875,  874,  873,  872,  871,  870,  869,  868,
-      867,  866,  865,  864,  863,  862,  861,  860,  859,  858,
-      857,  856,  855,  854,  853,  852,  851,  850,  849,  848,
-
-      847,  846,  845,  844,  843,  842,  841,  840,  839,  838,
-      837,  836,  835,  834,  833,  832,  831,  830,  829,  828,
-      827,  826,  825,  824,  823,  822,  821,  820,  819,  815,
-      814,  813,  812,  811,  810,  809,  808,  807,  806,  805,
-      804,  803,  800,  799,  798,  797,  796,  795,  794,  793,
-      792,  791,  790,  789,  788,  787,  784,  783,  782,  781,
-      780,  779,  778,  777,  776,  775,  774,  773,  772,  771,
-      770,  769,  768,  767,  766,  765,  764,  763,  762,  761,
-      760,  759,  758,  757,  756,  755,  754,  753,  752,  751,
-      750,  749,  748,  747,  746,  745,  744,  743,  742,  741,
-
-      740,  739,  738,  737,  736,  735,  734,  733,  732,  731,
-      730,  729,  728,  727,  726,  725,  724,  723,  722,  721,
-      720,  719,  718,  717,  716,  715,  714,  713,  712,  711,
-      710,  709,  708,  706,  705,  704,  703,  702,  701,  700,
-      699,  697,  696,  695,  694,  693,  692,  691,  690,  689,
-      688,  687,  686,  685,  684,  683,  682,  681,  680,  679,
-      678,  677,  676,  675,  674,  673,  672,  671,  670,  669,
-      668,  667,  666,  665,  664,  663,  662,  661,  660,  659,
-      658,  657,  656,  655,  654,  653,  652,  651,  650,  649,
-      648,  647,  646,  645,  644,  643,  642,  641,  437,  438,
-
-      434,  637,  636,  635,  634,  633,  632,  631,  630,  629,
-      628,  627,  626,  623,  621,  620,  619,  618,  617,  616,
-      615,  614,  613,  612,  611,  610,  607,  393,  603,  602,
-      601,  600,  599,  598,  597,  596,  595,  594,  593,  592,
-      591,  590,  586,  585,  584,  583,  582,  581,  580,  576,
-      575,  574,  569,  568,  563,  562,  561,  560,  559,  556,
-      555,  554,  553,  552,  549,  548,  547,  544,  543,  542,
-      539,  537,  536,  535,  534,  533,  532,  531,  530,  527,
-      526,  525,  524,  523,  522,  521,  520,  519,  518,  513,
-      512,  509,  503,  502,  501,  500,  499,  498,  497,  496,
-
-      495,  494,  493,  492,  491,  490,  486,  485,  484,  483,
-      482,  481,  480,  476,  475,  474,  471,  470,  465,  464,
-      463,  462,  461,  458,  457,  456,  455,  454,  451,  450,
-      449,  446,  445,  444,  443,  442,  214,  211,  438,  290,
-      434,  433,  430,  429,  428,  417,  414,  413,  412,  298,
-      291,  288,  287,  397,  393,  389,  388,  387,  386,  385,
-      384,  374,  360,  359,  358,  357,  332,  326,  316,  315,
-      314,  298,  287,  286,  214,  212,  211,  281,  280,  279,
-      278,  277,  276,  266,  253,  252,  251,  250,  229,  221,
-      220,  219,  214,  212,  211, 1535,   19, 1535, 1535, 1535,
-
-     1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535,
-     1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535,
-     1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535,
-     1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535,
-     1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535,
-     1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535,
-     1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535,
-     1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535
+       21,  201,  201,  201,  201,  201,  201,  201,  201,  201,
+
+      201,  201,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  213,  213,  213,  213,  213,  213,  213,
+      213,  213,  213,  213,  215,  215,  215,  215,  215,  215,
+      215,  215,  284,  510,  284,  955,  284,  284,  284,  284,
+      335,  954,  335,  335,  335,  335,  335,  335,  394,  953,
+      952,  951,  950,  394,  394,  394,  396,  396,  396,  396,
+      396,  396,  396,  396,  396,  396,  396,  398,  949,  398,
+      948,  398,  398,  398,  398,  400,  947,  400,  400,  400,
+      400,  400,  400,  400,  400,  400,  402,  946,  402,  402,
+      402,  402,  402,  402,  402,  402,  402,  439,  945,  439,
+
+      439,  439,  439,  439,  439,  439,  439,  439,  440,  944,
+      440,  441,  441,  441,  943,  942,  441,  441,  941,  441,
+      509,  940,  509,  939,  509,  509,  509,  509,  547,  938,
+      547,  547,  547,  547,  547,  547,  958,  937,  958,  958,
+      958,  958,  958,  958,  958,  958,  958,  969,  936,  969,
+      969,  969,  969,  969,  969,  969,  969,  969,  957,  935,
+      957,  957,  957,  957,  957,  957,  957,  957,  957,  968,
+      934,  968,  968,  968,  968,  968,  968,  968,  968,  968,
+      933,  932,  931,  930,  929,  928,  927,  926,  925,  924,
+      923,  922,  921,  920,  919,  918,  917,  916,  915,  914,
+
+      913,  912,  911,  910,  909,  908,  907,  906,  905,  904,
+      903,  902,  901,  900,  899,  898,  897,  896,  895,  894,
+      893,  892,  891,  890,  889,  888,  887,  886,  885,  884,
+      883,  882,  881,  880,  879,  878,  877,  876,  875,  874,
+      873,  872,  871,  870,  869,  868,  867,  866,  865,  864,
+      863,  862,  861,  860,  859,  858,  857,  856,  855,  854,
+      853,  852,  851,  850,  849,  848,  847,  846,  845,  844,
+      843,  842,  841,  840,  839,  838,  837,  836,  835,  834,
+      833,  832,  831,  827,  826,  825,  824,  823,  822,  821,
+      820,  819,  818,  817,  816,  815,  812,  811,  810,  809,
+
+      808,  807,  806,  805,  804,  803,  802,  801,  800,  799,
+      796,  795,  794,  793,  792,  791,  790,  789,  788,  787,
+      786,  785,  784,  783,  782,  781,  780,  779,  778,  777,
+      776,  775,  774,  773,  772,  771,  770,  769,  768,  767,
+      766,  765,  764,  763,  762,  761,  760,  759,  758,  757,
+      756,  755,  754,  753,  752,  751,  750,  749,  748,  747,
+      746,  745,  744,  743,  742,  741,  740,  739,  738,  737,
+      736,  735,  734,  733,  732,  731,  730,  729,  728,  727,
+      726,  725,  724,  723,  722,  721,  720,  719,  718,  717,
+      715,  714,  713,  712,  711,  710,  709,  708,  707,  705,
+
+      704,  703,  702,  701,  700,  699,  698,  697,  696,  695,
+      694,  693,  692,  691,  690,  689,  688,  687,  686,  685,
+      684,  683,  682,  681,  680,  679,  678,  677,  676,  675,
+      674,  673,  672,  671,  670,  669,  668,  667,  666,  665,
+      664,  663,  662,  661,  660,  659,  658,  657,  656,  655,
+      654,  653,  652,  651,  650,  649,  441,  442,  438,  645,
+      644,  643,  642,  641,  640,  639,  638,  637,  636,  635,
+      634,  631,  629,  628,  627,  626,  625,  624,  623,  622,
+      621,  620,  619,  618,  615,  397,  611,  610,  609,  608,
+      607,  606,  605,  604,  603,  602,  601,  600,  599,  598,
+
+      594,  593,  592,  591,  590,  589,  588,  584,  583,  582,
+      581,  576,  575,  570,  569,  568,  567,  566,  563,  562,
+      561,  560,  559,  556,  555,  554,  553,  550,  549,  548,
+      545,  543,  542,  541,  540,  539,  538,  537,  536,  533,
+      532,  531,  530,  529,  528,  527,  526,  525,  524,  523,
+      517,  516,  513,  507,  506,  505,  504,  503,  502,  501,
+      500,  499,  498,  497,  496,  495,  494,  490,  489,  488,
+      487,  486,  485,  484,  480,  479,  478,  475,  474,  469,
+      468,  467,  466,  465,  462,  461,  460,  459,  458,  455,
+      454,  453,  450,  449,  448,  447,  446,  214,  211,  442,
+
+      290,  438,  437,  434,  433,  432,  421,  418,  417,  416,
+      298,  291,  288,  287,  401,  397,  393,  392,  391,  390,
+      389,  388,  378,  363,  362,  361,  360,  334,  328,  317,
+      316,  315,  298,  287,  286,  214,  212,  211,  281,  280,
+      279,  278,  277,  276,  266,  253,  252,  251,  250,  229,
+      221,  220,  219,  214,  212,  211, 1561,   19, 1561, 1561,
+     1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561,
+     1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561,
+     1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561,
+     1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561,
+
+     1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561,
+     1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561,
+     1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561,
+     1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561
     } ;
 
-static yyconst flex_int16_t yy_chk[2579] =
+static yyconst flex_int16_t yy_chk[2641] =
     {   0,
         3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
         3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
@@ -1237,7 +1241,7 @@
         3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
         3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
         3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+        3,    3,    5,    5,    5,    5,    5,    5,    5,    5,
         5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
 
         5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
@@ -1246,7 +1250,7 @@
         5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
         5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
         5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
-        5,    5,    7,    7,    7,    7,    7,    7,    7,    7,
+        5,    5,    5,    5,    7,    7,    7,    7,    7,    7,
         7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
         7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
         7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
@@ -1255,25 +1259,26 @@
         7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
         7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
         7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
-        7,    7,    7,    9,    9,    9,    9,    9,    9,    9,
-        9,    9,    9,    9,    9,    9,    9,    9,   36,   90,
-        9,    9,    9,    9,    9,    9,    9,    9,   28,   36,
-       41,   41,   13,   13,   14,   14,   13,  812,   14,   43,
-       43,   45,   28,   45,  814,   46,   90,   13,   46,   14,
-       47,   45,   49,   47,    9,   55,    9,    9,   45,   45,
-
-       48,   46,   49,   50,   48,   55,   50,   56,   58,   50,
-       71,   56,   58,   86,  189,   58,   58,  117,   48,  189,
-        9,    9,    9,   10,   10,   10,   10,   10,   10,   10,
-       10,   10,   10,   10,   10,   10,   10,   10,   37,   37,
-       10,   10,   10,   10,   10,   10,   10,   10,   13,   57,
-       14,   59,   88,   80,   93,   93,   37,   86,   37,   57,
-      106,   59,  193,   88,   95,   95,   71,   80,  108,   37,
-      106,  255,  107,  117,   10,  193,   10,   10,  108,   61,
-      107,  111,   61,   61,  255,  111,   37,  123,   37,   61,
-       61,   61,  111,  815,   61,   61,   37,  111,  123,   61,
+        7,    7,    7,    7,    7,    7,    9,    9,    9,    9,
+        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
+        9,   36,  803,    9,    9,    9,    9,    9,    9,    9,
+        9,    9,   28,   36,   41,   41,   13,   13,   14,   14,
+       13,   48,   14,   43,   43,   48,   45,   28,   45,   46,
+       90,   13,   46,   14,   47,  807,   45,   47,    9,   48,
+
+        9,    9,   49,   45,   45,   46,   55,   50,   57,   59,
+       50,   56,   49,   50,   71,   56,   55,   90,   57,   59,
+       86,   93,   93,  808,    9,    9,    9,   10,   10,   10,
+       10,   10,   10,   10,   10,   10,   10,   10,   10,   10,
+       10,   10,   80,  117,   10,   10,   10,   10,   10,   10,
+       10,   10,   10,   13,   58,   14,   61,   80,   58,   61,
+       61,   58,   58,   88,   86,  165,   61,   61,   61,  107,
+       71,   61,   61,   95,   95,   88,   61,  107,   98,   10,
+       98,   10,   10,  106,   99,   98,   99,   99,   98,  810,
+      130,  123,  165,  106,   99,   98,   98,   99,  176,  117,
 
-       10,   10,   10,   11,   11,   11,   11,   11,   11,   11,
+      130,   99,   99,  123,  176,   10,   10,   10,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
        11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
        11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
        11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
@@ -1281,237 +1286,243 @@
        11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
        11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
        11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
-       11,   11,   11,   11,   15,   15,   15,   15,   15,   15,
-      165,   15,   15,   15,   15,   15,   15,   15,   15,  121,
+       15,   15,   15,   15,   15,   15,  811,   15,   15,   15,
 
-       15,   15,   15,   15,   15,   15,   15,   15,   15,   38,
-       38,  130,  819,   98,  109,   98,  128,  165,  109,  128,
-       98,  130,  109,   98,  207,  127,  292,   38,  127,   38,
-       98,   98,   99,  176,   99,   15,   15,   15,   15,  176,
-      129,  127,   99,  121,  129,   99,  136,  820,  131,   99,
-       99,  131,  821,  292,  131,  206,  136,   38,  129,   38,
-      208,   15,   15,   15,   15,   16,   16,   16,   16,   16,
-       16,  207,   16,   16,   16,   16,   16,   16,   16,   16,
-      180,   16,   16,   16,   16,   16,   16,   16,   16,   16,
-      100,  100,  137,  100,  100,  180,  137,  102,  822,  102,
-
-      137,  100,  138,  101,  240,  101,  240,  102,  100,  100,
-      208,  206,  138,  101,  102,  102,   16,   16,   16,   16,
-      101,  101,  126,  139,  126,  101,  140,  139,  173,  235,
-      139,  139,  126,  825,  826,  246,  140,  304,  173,  126,
-      126,  235,   16,   16,   16,   16,   17,   17,   17,  304,
-       17,   17,  246,   17,   17,   17,   17,  827,   17,   17,
-      171,  171,   17,   17,   17,   17,   17,   17,   17,   17,
-      114,  171,  114,  259,  142,  441,  259,  142,  142,  309,
-      114,  309,  259,  174,  142,  142,  142,  114,  114,  142,
-      142,  172,  172,  174,  142,  174,  363,  175,  172,  830,
-
-      322,  114,  172,  185,  363,  174,   17,  175,   17,  322,
-      175,  184,   17,  185,  441,  347,  267,  347,  267,  638,
-      187,  184,  267,   17,   17,   17,   17,   18,   18,   18,
-      187,   18,   18,  185,   18,   18,   18,   18,  353,   18,
-       18,  440,  184,   18,   18,   18,   18,   18,   18,   18,
-       18,  184,  124,  124,  252,  353,  188,  252,  186,  252,
-      638,  640,  187,  362,  125,  125,  188,  252,  186,  187,
-      124,  226,  124,  226,  224,  224,  362,  367,  342,  375,
-      367,  375,  125,  124,  125,  375,  367,   18,  186,   18,
-      342,  440,  224,   18,  224,  186,  831,  833,  640,  188,
-
-      124,  226,  124,  226,   18,   18,   18,   18,   26,   26,
-      124,  835,  125,  299,  125,  299,   26,   26,   26,   26,
-       26,   26,  224,  299,  224,  293,  293,  399,  401,  359,
-      299,  299,  359,  607,  359,  439,  418,  399,  401,  607,
-      639,  836,  359,  293,  817,  293,  418,   26,   26,   26,
-       26,   26,   26,   78,   78,  838,  293,  824,  420,  839,
-      816,   78,   78,   78,   78,   78,   78,  300,  420,  300,
-      301,  840,  301,  293,  824,  293,  421,  300,  639,  818,
-      301,  817,  418,  293,  300,  300,  421,  301,  301,  439,
-      841,  842,   78,   78,   78,   78,   78,   78,   89,   89,
-
-      843,  337,  337,  844,  420,  845,   89,   89,   89,   89,
-       89,   89,  816,   89,  400,  306,   89,  306,   89,  337,
-       89,  337,  421,  846,  400,  306,  818,  847,  623,   89,
-      849,  400,  306,  306,  623,  850,  851,   89,   89,   89,
-       89,   89,   89,  310,   89,  310,   89,  852,   89,  337,
-       89,  337,  854,  310,  404,  855,   89,   97,   97,  856,
-      310,  310,  858,  405,  404,   97,   97,   97,   97,   97,
-       97,  404,   97,  405,  859,  331,   97,  331,  860,   97,
-      405,  861,  862,   97,   97,  331,  863,  864,   97,  865,
-      866,  867,  331,  331,  868,  870,   97,   97,   97,   97,
-
-       97,   97,  311,   97,  311,  506,  311,  506,  871,   97,
-      872,  874,  311,  876,  877,   97,  120,  120,  878,  311,
-      311,  331,  879,  880,  120,  120,  120,  120,  120,  120,
-      508,  881,  508,  882,  517,  506,  517,  506,  883,  884,
-      508,  517,  885,  886,  517,  887,  508,  508,  508,  888,
-      889,  517,  517,  890,  891,  120,  120,  120,  120,  120,
-      120,  150,  150,  892,  893,  895,  896,  897,  898,  150,
-      150,  150,  150,  150,  150,  901,  902,  904,  906,  907,
-      909,  910,  895,  911,  912,  913,  914,  915,  916,  917,
-      918,  920,  921,  922,  923,  925,  926,  927,  929,  930,
-
-      150,  150,  150,  150,  150,  150,  157,  157,  931,  932,
-      933,  934,  935,  936,  157,  157,  157,  157,  157,  157,
-      938,  939,  940,  944,  946,  947,  949,  950,  951,  955,
-      957,  958,  959,  960,  961,  962,  964,  965,  966,  967,
-      968,  969,  970,  972,  973,  157,  157,  157,  157,  157,
-      157,  170,  170,  974,  976,  978,  979,  981,  983,  170,
-      170,  170,  170,  170,  170,  984,  170,  985,  986,  987,
-      170,  988,  989,  170,  990,  991,  992,  993,  996,  959,
-      958,  997,  170,  998,  999, 1000, 1002, 1003, 1004, 1005,
-      170,  170,  170,  170,  170,  170, 1006,  170, 1008, 1009,
-
-     1011, 1013, 1014,  170, 1015, 1016, 1017, 1018, 1019,  170,
-      216,  216, 1020, 1021, 1022, 1024, 1025, 1026,  216,  216,
-      216,  216,  216,  216, 1027, 1028, 1029, 1030,  216, 1032,
-      216, 1033, 1034, 1036, 1038, 1039, 1041, 1043, 1044, 1045,
-     1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1056,  216,
-      216,  216,  216,  216,  216, 1057, 1058, 1059,  216, 1060,
-      216,  285,  285, 1064, 1065, 1066, 1070, 1071, 1072,  285,
-      285,  285,  285,  285,  285, 1073, 1075, 1076, 1077,  285,
-     1078,  285, 1079, 1081, 1082, 1084, 1085, 1086, 1088, 1089,
-     1091, 1092, 1093, 1094, 1089, 1095, 1096, 1099, 1101, 1102,
-
-      285,  285,  285,  285,  285,  285, 1103, 1105, 1106,  285,
-     1107,  285,  334,  334, 1109, 1110, 1111, 1112, 1114, 1115,
-      334,  334,  334,  334,  334,  334, 1116, 1118, 1119, 1120,
-      334, 1121,  334, 1123, 1124, 1125, 1126, 1127, 1129, 1130,
-     1132, 1133, 1134, 1136, 1137, 1139, 1140, 1141, 1142, 1137,
-     1143,  334,  334,  334,  334,  334,  334, 1144, 1147, 1149,
-      334, 1150,  334,  391,  391, 1151, 1152, 1153, 1154, 1155,
-     1156,  391,  391,  391,  391,  391,  391, 1158, 1160, 1161,
-     1162,  391, 1163,  391, 1164, 1165, 1167, 1168, 1169, 1170,
-     1171, 1172, 1174, 1175, 1179, 1176, 1181, 1183, 1184, 1186,
-
-     1187, 1188,  391,  391,  391,  391,  391,  391, 1176, 1189,
-     1190,  391, 1193,  391,  395,  395, 1195, 1197, 1198, 1199,
-     1200, 1201,  395,  395,  395,  395,  395,  395, 1202, 1204,
-     1205, 1206,  395, 1207,  395, 1208, 1209, 1211, 1212, 1213,
-     1216, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1232, 1233,
-     1234, 1231, 1213,  395,  395,  395,  395,  395,  395, 1231,
-     1235, 1236,  395, 1237,  395,  792,  792, 1238,  792,  792,
-      792, 1239,  792,  792,  792,  792,  792, 1240,  792, 1242,
-     1243, 1244, 1245, 1246, 1247,  792,  792,  792,  792,  792,
-     1245, 1248, 1249, 1251, 1252, 1253, 1254, 1255, 1256, 1257,
-
-     1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1258, 1266,
-     1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1277,  792,
-     1278, 1279, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288,
-     1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300,
-     1301, 1304,  792,  792,  792,  808,  808, 1305,  808,  808,
-      808, 1306,  808,  808,  808,  808,  808, 1308,  808, 1309,
-     1310, 1311, 1312, 1313, 1314,  808,  808,  808,  808,  808,
-     1315, 1316, 1317, 1318, 1321, 1322, 1323, 1324, 1325, 1326,
-     1327, 1328, 1329, 1331, 1332, 1333, 1334, 1335, 1336, 1337,
-     1338, 1339, 1340, 1343, 1344, 1345, 1346, 1347, 1348,  808,
-
-     1349, 1351, 1352, 1354, 1355, 1356, 1357, 1358, 1359, 1360,
-     1362, 1363, 1365, 1366, 1367, 1368, 1370, 1371, 1373, 1374,
-     1375, 1376,  808,  808,  808,  942,  942, 1377,  942,  942,
-      942, 1378,  942,  942,  942,  942,  942, 1379,  942, 1381,
-     1382, 1384, 1385, 1387, 1389,  942,  942,  942,  942,  942,
-     1383, 1390, 1391, 1392, 1383, 1393, 1395, 1392, 1396, 1397,
-     1398, 1399, 1400, 1402, 1398, 1404, 1405, 1383, 1406, 1407,
-     1392, 1408, 1409, 1410, 1411, 1412, 1415, 1398, 1417,  942,
-     1418, 1419, 1423, 1424, 1425, 1426, 1427, 1428, 1431, 1433,
-     1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443,
-
-     1444, 1445,  942,  942,  942,  953,  953, 1446,  953,  953,
-      953, 1447,  953,  953,  953,  953,  953, 1448,  953, 1449,
-     1450, 1451, 1453, 1454, 1455,  953,  953,  953,  953,  953,
-     1456, 1457, 1459, 1460, 1461, 1463, 1464, 1465, 1466, 1467,
-     1468, 1469, 1470, 1471, 1473, 1474, 1475, 1476, 1477, 1478,
-     1479, 1481, 1483, 1484, 1485, 1487, 1488, 1490, 1491,  953,
-     1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501,
-     1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1512,
-     1513, 1514,  953,  953,  953, 1515, 1517, 1518, 1519, 1521,
-     1522, 1525, 1526, 1528, 1530, 1531, 1532, 1536, 1536, 1536,
-
-     1536, 1536, 1536, 1536, 1536, 1536, 1536, 1536, 1537, 1537,
-     1537, 1537, 1537, 1537, 1537, 1537, 1537, 1537, 1537, 1538,
-     1538, 1538, 1538, 1538, 1538, 1538, 1538, 1538, 1538, 1538,
-     1539, 1539, 1539, 1539, 1539, 1539, 1539, 1539, 1539, 1539,
-     1539, 1540, 1540, 1540, 1540, 1540, 1540, 1540, 1540, 1540,
-     1540, 1540, 1541, 1541, 1541, 1541, 1541, 1541, 1541, 1541,
-     1541, 1541, 1541, 1542, 1542, 1542, 1542, 1542, 1542, 1542,
-     1542, 1543, 1554, 1543,  811, 1543, 1543, 1543, 1543, 1544,
-      807, 1544, 1544, 1544, 1544, 1544, 1544, 1545,  806,  802,
-      801,  800, 1545, 1545, 1545, 1546, 1546, 1546, 1546, 1546,
-
-     1546, 1546, 1546, 1546, 1546, 1546, 1547,  799, 1547,  798,
-     1547, 1547, 1547, 1547, 1548,  796, 1548, 1548, 1548, 1548,
-     1548, 1548, 1548, 1548, 1548, 1549,  795, 1549, 1549, 1549,
-     1549, 1549, 1549, 1549, 1549, 1549, 1550,  791, 1550, 1550,
-     1550, 1550, 1550, 1550, 1550, 1550, 1550, 1551,  790, 1551,
-     1552, 1552, 1552,  786,  785, 1552, 1552,  784, 1552, 1553,
-      783, 1553,  782, 1553, 1553, 1553, 1553, 1555,  781, 1555,
-     1555, 1555, 1555, 1555, 1555, 1556,  780, 1556, 1556, 1556,
-     1556, 1556, 1556, 1556, 1556, 1556, 1557,  779, 1557, 1557,
-     1557, 1557, 1557, 1557, 1557, 1557, 1557, 1558,  778, 1558,
-
-     1558, 1558, 1558, 1558, 1558, 1558, 1558, 1558, 1559,  777,
-     1559, 1559, 1559, 1559, 1559, 1559, 1559, 1559, 1559,  776,
-      775,  774,  773,  772,  771,  770,  769,  767,  766,  765,
-      764,  763,  762,  761,  760,  759,  757,  755,  754,  752,
-      751,  749,  748,  747,  746,  744,  743,  742,  741,  740,
-      739,  738,  736,  734,  732,  731,  730,  728,  727,  726,
-      725,  724,  723,  722,  721,  720,  719,  718,  717,  716,
-      714,  713,  710,  709,  708,  707,  706,  704,  703,  701,
-      700,  699,  697,  696,  695,  694,  693,  692,  691,  690,
-      689,  688,  687,  686,  685,  684,  683,  682,  680,  679,
-
-      678,  677,  676,  675,  674,  673,  672,  670,  668,  667,
-      665,  664,  662,  661,  660,  659,  657,  656,  655,  654,
-      653,  652,  651,  649,  647,  645,  644,  643,  641,  637,
-      636,  635,  634,  633,  632,  631,  630,  629,  628,  626,
-      625,  624,  622,  621,  620,  619,  618,  617,  616,  615,
-      614,  613,  612,  610,  609,  608,  606,  603,  600,  599,
-      598,  597,  596,  595,  594,  593,  592,  591,  590,  589,
-      588,  587,  586,  585,  584,  583,  582,  581,  580,  579,
-      578,  577,  576,  574,  571,  570,  569,  568,  567,  566,
-      565,  564,  562,  561,  560,  559,  558,  557,  556,  555,
-
-      554,  553,  552,  551,  550,  549,  548,  547,  546,  545,
-      544,  543,  542,  539,  538,  537,  536,  535,  534,  533,
-      532,  531,  530,  529,  528,  527,  524,  523,  522,  521,
-      520,  519,  518,  516,  515,  514,  513,  512,  511,  510,
-      509,  507,  503,  500,  499,  498,  497,  496,  495,  494,
-      493,  492,  491,  490,  489,  488,  487,  486,  485,  484,
-      483,  482,  481,  480,  479,  478,  477,  476,  475,  473,
-      472,  471,  470,  469,  468,  467,  466,  464,  463,  462,
-      461,  460,  459,  458,  457,  456,  455,  454,  453,  452,
-      451,  450,  449,  448,  447,  446,  445,  444,  438,  437,
-
-      434,  433,  432,  431,  430,  429,  428,  427,  426,  425,
-      424,  423,  422,  419,  417,  416,  415,  414,  413,  412,
-      411,  410,  409,  408,  407,  406,  403,  392,  389,  388,
-      387,  386,  385,  384,  383,  382,  381,  380,  379,  378,
-      377,  376,  374,  373,  372,  371,  370,  369,  368,  366,
-      365,  364,  361,  360,  358,  357,  356,  355,  354,  352,
-      351,  350,  349,  348,  346,  345,  344,  341,  340,  339,
-      332,  330,  329,  328,  327,  326,  325,  324,  323,  321,
-      320,  319,  318,  317,  316,  315,  314,  313,  312,  308,
-      307,  303,  281,  280,  279,  278,  277,  276,  275,  274,
-
-      273,  272,  271,  270,  269,  268,  266,  265,  264,  263,
-      262,  261,  260,  258,  257,  256,  254,  253,  251,  250,
-      249,  248,  247,  245,  244,  243,  242,  241,  239,  238,
-      237,  234,  233,  232,  231,  227,  213,  211,  205,  199,
-      196,  194,  192,  191,  190,  181,  179,  178,  177,  168,
-      163,  161,  159,  158,  156,  148,  147,  146,  145,  144,
-      143,  141,  135,  134,  133,  132,  115,  110,  105,  104,
-      103,   94,   84,   83,   77,   76,   75,   69,   68,   67,
-       66,   63,   62,   60,   54,   53,   52,   51,   42,   34,
-       32,   31,   25,   24,   22,   19, 1535, 1535, 1535, 1535,
-
-     1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535,
-     1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535,
-     1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535,
-     1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535,
-     1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535,
-     1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535,
-     1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535,
-     1535, 1535, 1535, 1535, 1535, 1535, 1535, 1535
+       15,   15,   15,   15,   15,  121,   15,   15,   15,   15,
+       15,   15,   15,   15,   15,   15,   38,   38,   38,  180,
+      100,  100,  108,  100,  100,  109,  108,  812,  292,  109,
+      101,  100,  101,  109,  180,   38,  108,   38,  100,  100,
+      101,  128,   15,   15,   15,   15,  111,  101,  101,  121,
+      111,  128,  101,  131,  128,  292,  131,  111,  189,  131,
+      129,  813,  111,  189,  129,   38,  208,   38,   15,   15,
+       15,   15,   16,   16,   16,   16,   16,   16,  129,   16,
+       16,   16,   16,   16,   16,   16,   16,  206,   16,   16,
+       16,   16,   16,   16,   16,   16,   16,   16,   37,   37,
+
+       37,  136,  193,  102,  137,  102,  127,  814,  137,  127,
+      818,  136,  137,  102,  138,  193,  208,   37,  138,   37,
+      102,  102,  127,  246,   16,   16,   16,   16,  138,  139,
+       37,  140,  173,  139,  171,  171,  139,  139,  185,  207,
+      246,  140,  173,  206,  240,  171,  240,   37,  185,   37,
+       16,   16,   16,   16,   17,   17,   17,   37,   17,   17,
+      324,   17,   17,   17,   17,  819,   17,   17,  185,  324,
+       17,   17,   17,   17,   17,   17,   17,   17,   17,  114,
+      175,  114,  126,  310,  126,  310,  207,  646,  186,  114,
+      175,  142,  126,  175,  142,  142,  114,  114,  186,  126,
+
+      126,  142,  142,  142,  174,  823,  142,  142,  235,  255,
+      114,  142,  172,  172,  174,   17,  174,   17,  186,  172,
+      235,   17,  255,  172,  824,  186,  174,  647,  646,  187,
+      304,  826,   17,   17,   17,   17,   18,   18,   18,  187,
+       18,   18,  304,   18,   18,   18,   18,  827,   18,   18,
+      831,  184,   18,   18,   18,   18,   18,   18,   18,   18,
+       18,  184,  124,  124,  124,  647,  226,  188,  226,  832,
+      259,  187,  344,  259,  125,  125,  125,  188,  187,  259,
+      833,  124,  184,  124,  344,  224,  224,  224,  356,  365,
+      299,  184,  299,  125,  124,  125,  226,   18,  226,   18,
+
+      299,  366,  365,   18,  224,  356,  224,  299,  299,  366,
+      188,  124,  834,  124,   18,   18,   18,   18,   26,   26,
+       26,  124,  350,  125,  350,  125,  837,   26,   26,   26,
+       26,   26,   26,  445,  224,  252,  224,  267,  252,  267,
+      252,  362,  371,  267,  362,  371,  362,  379,  252,  379,
+      615,  371,  838,  379,  362,  648,  615,  403,   26,   26,
+       26,   26,   26,   26,   78,   78,   78,  403,  839,  300,
+      405,  300,  445,   78,   78,   78,   78,   78,   78,  300,
+      405,  293,  293,  293,  404,  631,  300,  300,  444,  443,
+      830,  631,  648,  422,  404,  339,  339,  339,  842,  829,
+
+      293,  404,  293,  422,   78,   78,   78,   78,   78,   78,
+       89,   89,   89,  293,  339,  828,  339,  408,  409,   89,
+       89,   89,   89,   89,   89,  843,   89,  408,  409,   89,
+      293,   89,  293,   89,  408,  409,  829,  830,  444,  422,
+      293,  845,   89,  443,  339,  847,  339,  848,  836,  850,
+       89,   89,   89,   89,   89,   89,  301,   89,  301,   89,
+      851,   89,  510,   89,  510,  836,  301,  828,  852,   89,
+       97,   97,   97,  301,  301,  424,  853,  854,  425,   97,
+       97,   97,   97,   97,   97,  424,   97,  855,  425,  306,
+       97,  306,  510,   97,  510,  856,  857,   97,   97,  306,
+
+      858,  859,   97,  861,  862,  863,  306,  306,  864,  866,
+       97,   97,   97,   97,   97,   97,  867,   97,  309,  868,
+      309,  424,  870,   97,  425,  309,  871,  872,  309,   97,
+      120,  120,  120,  873,  874,  309,  309,  875,  876,  120,
+      120,  120,  120,  120,  120,  311,  877,  311,  312,  878,
+      312,  333,  312,  333,  879,  311,  880,  882,  312,  883,
+      884,  333,  311,  311,  885,  312,  312,  887,  333,  333,
+      120,  120,  120,  120,  120,  120,  150,  150,  150,  889,
+      890,  891,  512,  892,  512,  150,  150,  150,  150,  150,
+      150,  893,  512,  894,  522,  895,  522,  333,  512,  512,
+
+      512,  522,  896,  897,  522,  898,  899,  900,  901,  902,
+      903,  522,  522,  904,  905,  906,  150,  150,  150,  150,
+      150,  150,  157,  157,  157,  907,  909,  910,  911,  912,
+      913,  157,  157,  157,  157,  157,  157,  916,  917,  919,
+      921,  922,  924,  925,  910,  926,  927,  928,  929,  930,
+      931,  932,  933,  934,  936,  937,  938,  939,  941,  942,
+      943,  945,  157,  157,  157,  157,  157,  157,  170,  170,
+      170,  946,  947,  948,  949,  950,  951,  170,  170,  170,
+      170,  170,  170,  952,  170,  954,  955,  956,  170,  960,
+      962,  170,  963,  965,  966,  967,  971,  973,  975,  974,
+
+      170,  976,  977,  978,  980,  981,  982,  983,  170,  170,
+      170,  170,  170,  170,  984,  170,  985,  986,  988,  989,
+      990,  170,  992,  994,  995,  997,  999,  170,  216,  216,
+      216, 1000, 1001, 1002, 1003, 1004, 1005,  216,  216,  216,
+      216,  216,  216, 1006, 1007,  975, 1008,  216,  974,  216,
+     1009, 1012, 1013, 1014, 1015, 1016, 1018, 1020, 1021, 1022,
+     1023, 1025, 1026, 1027, 1029, 1031, 1032, 1033,  216,  216,
+      216,  216,  216,  216, 1034, 1035, 1036,  216, 1037,  216,
+      285,  285,  285, 1038, 1039, 1040, 1042, 1044, 1045,  285,
+      285,  285,  285,  285,  285, 1046, 1047, 1048, 1049,  285,
+
+     1051,  285, 1052, 1053, 1055, 1057, 1058, 1059, 1061, 1063,
+     1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073,
+      285,  285,  285,  285,  285,  285, 1076, 1077, 1078,  285,
+     1079,  285,  336,  336,  336, 1080, 1084, 1085, 1086, 1090,
+     1091,  336,  336,  336,  336,  336,  336, 1092, 1093, 1095,
+     1096,  336, 1097,  336, 1098, 1099, 1101, 1102, 1104, 1105,
+     1106, 1108, 1109, 1111, 1112, 1113, 1114, 1109, 1115, 1116,
+     1119, 1121,  336,  336,  336,  336,  336,  336, 1122, 1123,
+     1125,  336, 1126,  336,  395,  395,  395, 1127, 1129, 1130,
+     1131, 1132, 1133,  395,  395,  395,  395,  395,  395, 1135,
+
+     1136, 1137, 1139,  395, 1140,  395, 1141, 1142, 1144, 1145,
+     1146, 1147, 1148, 1150, 1151, 1153, 1154, 1155, 1156, 1158,
+     1161, 1162, 1163, 1164,  395,  395,  395,  395,  395,  395,
+     1165, 1166, 1169,  395, 1159,  395,  399,  399,  399, 1159,
+     1171, 1172, 1173, 1174, 1175,  399,  399,  399,  399,  399,
+      399, 1176, 1177, 1178, 1180,  399, 1182,  399, 1183, 1184,
+     1185, 1186, 1187, 1189, 1190, 1191, 1192, 1193, 1194, 1196,
+     1197, 1198, 1201, 1203, 1205, 1206,  399,  399,  399,  399,
+      399,  399, 1208, 1209, 1198,  399, 1210,  399,  804,  804,
+     1211,  804,  804,  804, 1212,  804,  804,  804,  804,  804,
+
+     1213,  804, 1216, 1218, 1220, 1221, 1222, 1223, 1224,  804,
+      804,  804,  804,  804, 1225, 1227, 1228, 1229, 1230, 1231,
+     1232, 1233, 1235, 1236, 1237, 1240, 1248, 1249, 1250, 1251,
+     1252, 1253, 1254, 1255, 1256, 1257, 1258, 1237, 1259, 1260,
+     1261, 1255, 1262,  804, 1263, 1264, 1266, 1267, 1269, 1270,
+     1271, 1272, 1273, 1274, 1276, 1277, 1278, 1270, 1279, 1280,
+     1281, 1283, 1285, 1284, 1286, 1287,  804,  804,  804,  820,
+      820, 1284,  820,  820,  820, 1288,  820,  820,  820,  820,
+      820, 1289,  820, 1290, 1291, 1292, 1293, 1294, 1295, 1296,
+      820,  820,  820,  820,  820, 1297, 1298, 1299, 1300, 1303,
+
+     1304, 1305, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314,
+     1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326,
+     1327, 1330, 1331, 1332,  820, 1334, 1335, 1336, 1337, 1338,
+     1339, 1340, 1341, 1342, 1343, 1344, 1347, 1348, 1349, 1350,
+     1351, 1352, 1353, 1354, 1355, 1357, 1358,  820,  820,  820,
+      958,  958, 1359,  958,  958,  958, 1360,  958,  958,  958,
+      958,  958, 1361,  958, 1362, 1363, 1364, 1365, 1366, 1369,
+     1370,  958,  958,  958,  958,  958, 1371, 1372, 1373, 1374,
+     1375, 1377, 1378, 1380, 1381, 1382, 1383, 1384, 1385, 1386,
+     1388, 1389, 1391, 1392, 1393, 1394, 1396, 1397, 1399, 1400,
+
+     1401, 1402, 1403, 1404, 1405,  958, 1407, 1408, 1409, 1410,
+     1411, 1413, 1409, 1415, 1416, 1417, 1418, 1419, 1421, 1422,
+     1418, 1423, 1425, 1426, 1428, 1409, 1430, 1431,  958,  958,
+      958,  969,  969, 1418,  969,  969,  969, 1432,  969,  969,
+      969,  969,  969, 1424,  969, 1433, 1434, 1424, 1435, 1436,
+     1437, 1438,  969,  969,  969,  969,  969, 1441, 1443, 1444,
+     1424, 1445, 1449, 1450, 1451, 1452, 1453, 1454, 1457, 1459,
+     1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469,
+     1470, 1471, 1472, 1473, 1474, 1475,  969, 1476, 1477, 1479,
+     1480, 1481, 1482, 1483, 1485, 1486, 1487, 1489, 1490, 1491,
+
+     1492, 1493, 1494, 1495, 1496, 1497, 1499, 1500, 1501,  969,
+      969,  969, 1502, 1503, 1504, 1505, 1507, 1509, 1510, 1511,
+     1513, 1514, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523,
+     1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533,
+     1534, 1535, 1536, 1538, 1539, 1540, 1541, 1543, 1544, 1545,
+     1547, 1548, 1551, 1552, 1554, 1556, 1557, 1558, 1562, 1562,
+     1562, 1562, 1562, 1562, 1562, 1562, 1562, 1562, 1562, 1563,
+     1563, 1563, 1563, 1563, 1563, 1563, 1563, 1563, 1563, 1563,
+     1564, 1564, 1564, 1564, 1564, 1564, 1564, 1564, 1564, 1564,
+     1564, 1565, 1565, 1565, 1565, 1565, 1565, 1565, 1565, 1565,
+
+     1565, 1565, 1566, 1566, 1566, 1566, 1566, 1566, 1566, 1566,
+     1566, 1566, 1566, 1567, 1567, 1567, 1567, 1567, 1567, 1567,
+     1567, 1567, 1567, 1567, 1568, 1568, 1568, 1568, 1568, 1568,
+     1568, 1568, 1569, 1580, 1569,  802, 1569, 1569, 1569, 1569,
+     1570,  798, 1570, 1570, 1570, 1570, 1570, 1570, 1571,  797,
+      796,  795,  794, 1571, 1571, 1571, 1572, 1572, 1572, 1572,
+     1572, 1572, 1572, 1572, 1572, 1572, 1572, 1573,  793, 1573,
+      792, 1573, 1573, 1573, 1573, 1574,  791, 1574, 1574, 1574,
+     1574, 1574, 1574, 1574, 1574, 1574, 1575,  790, 1575, 1575,
+     1575, 1575, 1575, 1575, 1575, 1575, 1575, 1576,  789, 1576,
+
+     1576, 1576, 1576, 1576, 1576, 1576, 1576, 1576, 1577,  788,
+     1577, 1578, 1578, 1578,  787,  786, 1578, 1578,  785, 1578,
+     1579,  784, 1579,  783, 1579, 1579, 1579, 1579, 1581,  782,
+     1581, 1581, 1581, 1581, 1581, 1581, 1582,  781, 1582, 1582,
+     1582, 1582, 1582, 1582, 1582, 1582, 1582, 1583,  779, 1583,
+     1583, 1583, 1583, 1583, 1583, 1583, 1583, 1583, 1584,  778,
+     1584, 1584, 1584, 1584, 1584, 1584, 1584, 1584, 1584, 1585,
+      777, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585, 1585,
+      776,  775,  774,  773,  772,  771,  769,  768,  766,  765,
+      763,  762,  760,  759,  758,  757,  755,  754,  753,  752,
+
+      751,  750,  749,  747,  746,  744,  742,  741,  740,  738,
+      737,  736,  735,  734,  733,  732,  731,  730,  729,  728,
+      727,  726,  724,  723,  722,  719,  718,  717,  716,  715,
+      713,  712,  711,  709,  708,  707,  705,  704,  703,  702,
+      701,  700,  699,  698,  697,  696,  695,  694,  693,  692,
+      691,  690,  688,  687,  686,  685,  684,  683,  682,  681,
+      680,  678,  676,  675,  673,  672,  670,  669,  668,  667,
+      665,  664,  663,  662,  661,  660,  659,  657,  655,  653,
+      652,  651,  649,  645,  644,  643,  642,  641,  640,  639,
+      638,  637,  636,  634,  633,  632,  630,  629,  628,  627,
+
+      626,  625,  624,  623,  622,  621,  620,  618,  617,  616,
+      614,  611,  608,  607,  606,  605,  604,  603,  602,  601,
+      600,  599,  598,  597,  596,  595,  594,  593,  592,  591,
+      590,  589,  588,  587,  586,  585,  584,  583,  581,  578,
+      577,  576,  575,  574,  573,  572,  571,  569,  568,  567,
+      566,  565,  564,  563,  562,  561,  560,  559,  558,  557,
+      556,  555,  554,  553,  552,  551,  550,  549,  548,  545,
+      544,  543,  542,  541,  540,  539,  538,  537,  536,  535,
+      534,  533,  532,  529,  528,  527,  526,  525,  524,  523,
+      521,  520,  519,  518,  517,  516,  515,  514,  513,  511,
+
+      507,  504,  503,  502,  501,  500,  499,  498,  497,  496,
+      495,  494,  493,  492,  491,  490,  489,  488,  487,  486,
+      485,  484,  483,  482,  481,  480,  479,  477,  476,  475,
+      474,  473,  472,  471,  470,  468,  467,  466,  465,  464,
+      463,  462,  461,  460,  459,  458,  457,  456,  455,  454,
+      453,  452,  451,  450,  449,  448,  442,  441,  438,  437,
+      436,  435,  434,  433,  432,  431,  430,  429,  428,  427,
+      426,  423,  421,  420,  419,  418,  417,  416,  415,  414,
+      413,  412,  411,  410,  407,  396,  393,  392,  391,  390,
+      389,  388,  387,  386,  385,  384,  383,  382,  381,  380,
+
+      378,  377,  376,  375,  374,  373,  372,  370,  369,  368,
+      367,  364,  363,  361,  360,  359,  358,  357,  355,  354,
+      353,  352,  351,  349,  348,  347,  346,  343,  342,  341,
+      334,  332,  331,  330,  329,  328,  327,  326,  325,  323,
+      322,  321,  320,  319,  318,  317,  316,  315,  314,  313,
+      308,  307,  303,  281,  280,  279,  278,  277,  276,  275,
+      274,  273,  272,  271,  270,  269,  268,  266,  265,  264,
+      263,  262,  261,  260,  258,  257,  256,  254,  253,  251,
+      250,  249,  248,  247,  245,  244,  243,  242,  241,  239,
+      238,  237,  234,  233,  232,  231,  227,  213,  211,  205,
+
+      199,  196,  194,  192,  191,  190,  181,  179,  178,  177,
+      168,  163,  161,  159,  158,  156,  148,  147,  146,  145,
+      144,  143,  141,  135,  134,  133,  132,  115,  110,  105,
+      104,  103,   94,   84,   83,   77,   76,   75,   69,   68,
+       67,   66,   63,   62,   60,   54,   53,   52,   51,   42,
+       34,   32,   31,   25,   24,   22,   19, 1561, 1561, 1561,
+     1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561,
+     1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561,
+     1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561,
+     1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561,
+
+     1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561,
+     1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561,
+     1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561,
+     1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561, 1561
     } ;
 
 static yy_state_type yy_last_accepting_state;
@@ -1627,7 +1638,7 @@
 
 
 
-#line 1631 "ldlex.c"
+#line 1642 "ldlex.c"
 
 #define INITIAL 0
 #define SCRIPT 1
@@ -1651,8 +1662,6 @@
 #define YY_EXTRA_TYPE void *
 #endif
 
-static int yy_init_globals (void );
-
 /* Macros after this point can all be overridden by user definitions in
  * section 1.
  */
@@ -1807,11 +1816,11 @@
 	}
     }
 
-#line 1811 "ldlex.c"
+#line 1820 "ldlex.c"
 
-	if ( !(yy_init) )
+	if ( (yy_init) )
 		{
-		(yy_init) = 1;
+		(yy_init) = 0;
 
 #ifdef YY_USER_INIT
 		YY_USER_INIT;
@@ -1860,13 +1869,13 @@
 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 				{
 				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 1536 )
+				if ( yy_current_state >= 1562 )
 					yy_c = yy_meta[(unsigned int) yy_c];
 				}
 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
 			++yy_cp;
 			}
-		while ( yy_base[yy_current_state] != 2497 );
+		while ( yy_base[yy_current_state] != 2558 );
 
 yy_find_action:
 		yy_act = yy_accept[yy_current_state];
@@ -2254,192 +2263,192 @@
 case 62:
 YY_RULE_SETUP
 #line 256 "ldlex.l"
-{ RTOKEN(ASSERT_K); }
+{ RTOKEN(CEILP2); }
 	YY_BREAK
 case 63:
 YY_RULE_SETUP
 #line 257 "ldlex.l"
-{ RTOKEN(ENTRY);}
+{ RTOKEN(NACL_MASK);}
 	YY_BREAK
 case 64:
 YY_RULE_SETUP
 #line 258 "ldlex.l"
-{ RTOKEN(EXTERN);}
+{ RTOKEN(ASSERT_K); }
 	YY_BREAK
 case 65:
 YY_RULE_SETUP
 #line 259 "ldlex.l"
-{ RTOKEN(NEXT);}
+{ RTOKEN(ENTRY);}
 	YY_BREAK
 case 66:
 YY_RULE_SETUP
 #line 260 "ldlex.l"
-{ RTOKEN(SIZEOF_HEADERS);}
+{ RTOKEN(EXTERN);}
 	YY_BREAK
 case 67:
 YY_RULE_SETUP
 #line 261 "ldlex.l"
-{ RTOKEN(SIZEOF_HEADERS);}
+{ RTOKEN(NEXT);}
 	YY_BREAK
 case 68:
 YY_RULE_SETUP
 #line 262 "ldlex.l"
-{ RTOKEN(SEGMENT_START);}
+{ RTOKEN(SIZEOF_HEADERS);}
 	YY_BREAK
 case 69:
 YY_RULE_SETUP
 #line 263 "ldlex.l"
-{ RTOKEN(MAP);}
+{ RTOKEN(SIZEOF_HEADERS);}
 	YY_BREAK
 case 70:
 YY_RULE_SETUP
 #line 264 "ldlex.l"
-{ RTOKEN(SIZEOF);}
+{ RTOKEN(SEGMENT_START);}
 	YY_BREAK
 case 71:
 YY_RULE_SETUP
 #line 265 "ldlex.l"
-{ RTOKEN(TARGET_K);}
+{ RTOKEN(MAP);}
 	YY_BREAK
 case 72:
 YY_RULE_SETUP
 #line 266 "ldlex.l"
-{ RTOKEN(SEARCH_DIR);}
+{ RTOKEN(SIZEOF);}
 	YY_BREAK
 case 73:
 YY_RULE_SETUP
 #line 267 "ldlex.l"
-{ RTOKEN(OUTPUT);}
+{ RTOKEN(TARGET_K);}
 	YY_BREAK
 case 74:
 YY_RULE_SETUP
 #line 268 "ldlex.l"
-{ RTOKEN(INPUT);}
+{ RTOKEN(SEARCH_DIR);}
 	YY_BREAK
 case 75:
 YY_RULE_SETUP
 #line 269 "ldlex.l"
-{ RTOKEN(GROUP);}
+{ RTOKEN(OUTPUT);}
 	YY_BREAK
 case 76:
 YY_RULE_SETUP
 #line 270 "ldlex.l"
-{ RTOKEN(AS_NEEDED);}
+{ RTOKEN(INPUT);}
 	YY_BREAK
 case 77:
 YY_RULE_SETUP
 #line 271 "ldlex.l"
-{ RTOKEN(DEFINED);}
+{ RTOKEN(GROUP);}
 	YY_BREAK
 case 78:
 YY_RULE_SETUP
 #line 272 "ldlex.l"
-{ RTOKEN(CREATE_OBJECT_SYMBOLS);}
+{ RTOKEN(AS_NEEDED);}
 	YY_BREAK
 case 79:
 YY_RULE_SETUP
 #line 273 "ldlex.l"
-{ RTOKEN( CONSTRUCTORS);}
+{ RTOKEN(DEFINED);}
 	YY_BREAK
 case 80:
 YY_RULE_SETUP
 #line 274 "ldlex.l"
-{ RTOKEN(FORCE_COMMON_ALLOCATION);}
+{ RTOKEN(CREATE_OBJECT_SYMBOLS);}
 	YY_BREAK
 case 81:
 YY_RULE_SETUP
 #line 275 "ldlex.l"
-{ RTOKEN(INHIBIT_COMMON_ALLOCATION);}
+{ RTOKEN( CONSTRUCTORS);}
 	YY_BREAK
 case 82:
 YY_RULE_SETUP
 #line 276 "ldlex.l"
-{ RTOKEN(SECTIONS);}
+{ RTOKEN(FORCE_COMMON_ALLOCATION);}
 	YY_BREAK
 case 83:
 YY_RULE_SETUP
 #line 277 "ldlex.l"
-{ RTOKEN(FILL);}
+{ RTOKEN(INHIBIT_COMMON_ALLOCATION);}
 	YY_BREAK
 case 84:
 YY_RULE_SETUP
 #line 278 "ldlex.l"
-{ RTOKEN(STARTUP);}
+{ RTOKEN(SECTIONS);}
 	YY_BREAK
 case 85:
 YY_RULE_SETUP
 #line 279 "ldlex.l"
-{ RTOKEN(OUTPUT_FORMAT);}
+{ RTOKEN(FILL);}
 	YY_BREAK
 case 86:
 YY_RULE_SETUP
 #line 280 "ldlex.l"
-{ RTOKEN( OUTPUT_ARCH);}
+{ RTOKEN(STARTUP);}
 	YY_BREAK
 case 87:
 YY_RULE_SETUP
 #line 281 "ldlex.l"
-{ RTOKEN(HLL);}
+{ RTOKEN(OUTPUT_FORMAT);}
 	YY_BREAK
 case 88:
 YY_RULE_SETUP
 #line 282 "ldlex.l"
-{ RTOKEN(SYSLIB);}
+{ RTOKEN( OUTPUT_ARCH);}
 	YY_BREAK
 case 89:
 YY_RULE_SETUP
 #line 283 "ldlex.l"
-{ RTOKEN(FLOAT);}
+{ RTOKEN(HLL);}
 	YY_BREAK
 case 90:
 YY_RULE_SETUP
 #line 284 "ldlex.l"
-{ RTOKEN( QUAD);}
+{ RTOKEN(SYSLIB);}
 	YY_BREAK
 case 91:
 YY_RULE_SETUP
 #line 285 "ldlex.l"
-{ RTOKEN( SQUAD);}
+{ RTOKEN(FLOAT);}
 	YY_BREAK
 case 92:
 YY_RULE_SETUP
 #line 286 "ldlex.l"
-{ RTOKEN( LONG);}
+{ RTOKEN( QUAD);}
 	YY_BREAK
 case 93:
 YY_RULE_SETUP
 #line 287 "ldlex.l"
-{ RTOKEN( SHORT);}
+{ RTOKEN( SQUAD);}
 	YY_BREAK
 case 94:
 YY_RULE_SETUP
 #line 288 "ldlex.l"
-{ RTOKEN( BYTE);}
+{ RTOKEN( LONG);}
 	YY_BREAK
 case 95:
 YY_RULE_SETUP
 #line 289 "ldlex.l"
-{ RTOKEN(NOFLOAT);}
+{ RTOKEN( SHORT);}
 	YY_BREAK
 case 96:
 YY_RULE_SETUP
 #line 290 "ldlex.l"
-{ RTOKEN(NOCROSSREFS);}
+{ RTOKEN( BYTE);}
 	YY_BREAK
 case 97:
 YY_RULE_SETUP
 #line 291 "ldlex.l"
-{ RTOKEN(OVERLAY); }
+{ RTOKEN(NOFLOAT);}
 	YY_BREAK
 case 98:
 YY_RULE_SETUP
 #line 292 "ldlex.l"
-{ RTOKEN(SORT_BY_NAME); }
+{ RTOKEN(NOCROSSREFS);}
 	YY_BREAK
 case 99:
 YY_RULE_SETUP
 #line 293 "ldlex.l"
-{ RTOKEN(SORT_BY_ALIGNMENT); }
+{ RTOKEN(OVERLAY); }
 	YY_BREAK
 case 100:
 YY_RULE_SETUP
@@ -2449,349 +2458,359 @@
 case 101:
 YY_RULE_SETUP
 #line 295 "ldlex.l"
-{ RTOKEN(NOLOAD);}
+{ RTOKEN(SORT_BY_ALIGNMENT); }
 	YY_BREAK
 case 102:
 YY_RULE_SETUP
 #line 296 "ldlex.l"
-{ RTOKEN(DSECT);}
+{ RTOKEN(SORT_BY_NAME); }
 	YY_BREAK
 case 103:
 YY_RULE_SETUP
 #line 297 "ldlex.l"
-{ RTOKEN(COPY);}
+{ RTOKEN(NOLOAD);}
 	YY_BREAK
 case 104:
 YY_RULE_SETUP
 #line 298 "ldlex.l"
-{ RTOKEN(INFO);}
+{ RTOKEN(DSECT);}
 	YY_BREAK
 case 105:
 YY_RULE_SETUP
 #line 299 "ldlex.l"
-{ RTOKEN(OVERLAY);}
+{ RTOKEN(COPY);}
 	YY_BREAK
 case 106:
 YY_RULE_SETUP
 #line 300 "ldlex.l"
-{ RTOKEN(ONLY_IF_RO); }
+{ RTOKEN(INFO);}
 	YY_BREAK
 case 107:
 YY_RULE_SETUP
 #line 301 "ldlex.l"
-{ RTOKEN(ONLY_IF_RW); }
+{ RTOKEN(OVERLAY);}
 	YY_BREAK
 case 108:
 YY_RULE_SETUP
 #line 302 "ldlex.l"
-{ RTOKEN(SPECIAL); }
+{ RTOKEN(ONLY_IF_RO); }
 	YY_BREAK
 case 109:
 YY_RULE_SETUP
 #line 303 "ldlex.l"
-{ RTOKEN(ORIGIN);}
+{ RTOKEN(ONLY_IF_RW); }
 	YY_BREAK
 case 110:
 YY_RULE_SETUP
 #line 304 "ldlex.l"
-{ RTOKEN(ORIGIN);}
+{ RTOKEN(SPECIAL); }
 	YY_BREAK
 case 111:
 YY_RULE_SETUP
 #line 305 "ldlex.l"
-{ RTOKEN( LENGTH);}
+{ RTOKEN(ORIGIN);}
 	YY_BREAK
 case 112:
 YY_RULE_SETUP
 #line 306 "ldlex.l"
-{ RTOKEN( LENGTH);}
+{ RTOKEN(ORIGIN);}
 	YY_BREAK
 case 113:
 YY_RULE_SETUP
 #line 307 "ldlex.l"
-{ RTOKEN(INCLUDE);}
+{ RTOKEN( LENGTH);}
 	YY_BREAK
 case 114:
 YY_RULE_SETUP
 #line 308 "ldlex.l"
-{ RTOKEN (PHDRS); }
+{ RTOKEN( LENGTH);}
 	YY_BREAK
 case 115:
 YY_RULE_SETUP
 #line 309 "ldlex.l"
-{ RTOKEN(AT);}
+{ RTOKEN(INCLUDE);}
 	YY_BREAK
 case 116:
 YY_RULE_SETUP
 #line 310 "ldlex.l"
-{ RTOKEN(SUBALIGN);}
+{ RTOKEN (PHDRS); }
 	YY_BREAK
 case 117:
 YY_RULE_SETUP
 #line 311 "ldlex.l"
-{ RTOKEN(PROVIDE); }
+{ RTOKEN(AT);}
 	YY_BREAK
 case 118:
 YY_RULE_SETUP
 #line 312 "ldlex.l"
-{ RTOKEN(PROVIDE_HIDDEN); }
+{ RTOKEN(SUBALIGN);}
 	YY_BREAK
 case 119:
 YY_RULE_SETUP
 #line 313 "ldlex.l"
-{ RTOKEN(KEEP); }
+{ RTOKEN(PROVIDE); }
 	YY_BREAK
 case 120:
 YY_RULE_SETUP
 #line 314 "ldlex.l"
-{ RTOKEN(EXCLUDE_FILE); }
+{ RTOKEN(PROVIDE_HIDDEN); }
 	YY_BREAK
 case 121:
 YY_RULE_SETUP
 #line 315 "ldlex.l"
-{ RTOKEN(CONSTANT);}
+{ RTOKEN(KEEP); }
 	YY_BREAK
 case 122:
-/* rule 122 can match eol */
 YY_RULE_SETUP
 #line 316 "ldlex.l"
-{ ++ lineno; }
+{ RTOKEN(EXCLUDE_FILE); }
 	YY_BREAK
 case 123:
-/* rule 123 can match eol */
 YY_RULE_SETUP
 #line 317 "ldlex.l"
-{ ++ lineno;  RTOKEN(NEWLINE); }
+{ RTOKEN(CONSTANT);}
 	YY_BREAK
 case 124:
+/* rule 124 can match eol */
 YY_RULE_SETUP
 #line 318 "ldlex.l"
-{ /* Mri comment line */ }
+{ ++ lineno; }
 	YY_BREAK
 case 125:
+/* rule 125 can match eol */
 YY_RULE_SETUP
 #line 319 "ldlex.l"
-{ /* Mri comment line */ }
+{ ++ lineno;  RTOKEN(NEWLINE); }
 	YY_BREAK
 case 126:
 YY_RULE_SETUP
 #line 320 "ldlex.l"
-{ RTOKEN(ENDWORD); }
+{ /* Mri comment line */ }
 	YY_BREAK
 case 127:
 YY_RULE_SETUP
 #line 321 "ldlex.l"
-{ RTOKEN(ALIGNMOD);}
+{ /* Mri comment line */ }
 	YY_BREAK
 case 128:
 YY_RULE_SETUP
 #line 322 "ldlex.l"
-{ RTOKEN(ALIGN_K);}
+{ RTOKEN(ENDWORD); }
 	YY_BREAK
 case 129:
 YY_RULE_SETUP
 #line 323 "ldlex.l"
-{ RTOKEN(CHIP); }
+{ RTOKEN(ALIGNMOD);}
 	YY_BREAK
 case 130:
 YY_RULE_SETUP
 #line 324 "ldlex.l"
-{ RTOKEN(BASE); }
+{ RTOKEN(ALIGN_K);}
 	YY_BREAK
 case 131:
 YY_RULE_SETUP
 #line 325 "ldlex.l"
-{ RTOKEN(ALIAS); }
+{ RTOKEN(CHIP); }
 	YY_BREAK
 case 132:
 YY_RULE_SETUP
 #line 326 "ldlex.l"
-{ RTOKEN(TRUNCATE); }
+{ RTOKEN(BASE); }
 	YY_BREAK
 case 133:
 YY_RULE_SETUP
 #line 327 "ldlex.l"
-{ RTOKEN(LOAD); }
+{ RTOKEN(ALIAS); }
 	YY_BREAK
 case 134:
 YY_RULE_SETUP
 #line 328 "ldlex.l"
-{ RTOKEN(PUBLIC); }
+{ RTOKEN(TRUNCATE); }
 	YY_BREAK
 case 135:
 YY_RULE_SETUP
 #line 329 "ldlex.l"
-{ RTOKEN(ORDER); }
+{ RTOKEN(LOAD); }
 	YY_BREAK
 case 136:
 YY_RULE_SETUP
 #line 330 "ldlex.l"
-{ RTOKEN(NAMEWORD); }
+{ RTOKEN(PUBLIC); }
 	YY_BREAK
 case 137:
 YY_RULE_SETUP
 #line 331 "ldlex.l"
-{ RTOKEN(FORMAT); }
+{ RTOKEN(ORDER); }
 	YY_BREAK
 case 138:
 YY_RULE_SETUP
 #line 332 "ldlex.l"
-{ RTOKEN(CASE); }
+{ RTOKEN(NAMEWORD); }
 	YY_BREAK
 case 139:
 YY_RULE_SETUP
 #line 333 "ldlex.l"
-{ RTOKEN(START); }
+{ RTOKEN(FORMAT); }
 	YY_BREAK
 case 140:
 YY_RULE_SETUP
 #line 334 "ldlex.l"
-{ RTOKEN(LIST); /* LIST and ignore to end of line */ }
+{ RTOKEN(CASE); }
 	YY_BREAK
 case 141:
 YY_RULE_SETUP
 #line 335 "ldlex.l"
-{ RTOKEN(SECT); }
+{ RTOKEN(START); }
 	YY_BREAK
 case 142:
 YY_RULE_SETUP
 #line 336 "ldlex.l"
-{ RTOKEN(ABSOLUTE); }
+{ RTOKEN(LIST); /* LIST and ignore to end of line */ }
 	YY_BREAK
 case 143:
 YY_RULE_SETUP
 #line 337 "ldlex.l"
-{ RTOKEN(ENDWORD); }
+{ RTOKEN(SECT); }
 	YY_BREAK
 case 144:
 YY_RULE_SETUP
 #line 338 "ldlex.l"
-{ RTOKEN(ALIGNMOD);}
+{ RTOKEN(ABSOLUTE); }
 	YY_BREAK
 case 145:
 YY_RULE_SETUP
 #line 339 "ldlex.l"
-{ RTOKEN(ALIGN_K);}
+{ RTOKEN(ENDWORD); }
 	YY_BREAK
 case 146:
 YY_RULE_SETUP
 #line 340 "ldlex.l"
-{ RTOKEN(CHIP); }
+{ RTOKEN(ALIGNMOD);}
 	YY_BREAK
 case 147:
 YY_RULE_SETUP
 #line 341 "ldlex.l"
-{ RTOKEN(BASE); }
+{ RTOKEN(ALIGN_K);}
 	YY_BREAK
 case 148:
 YY_RULE_SETUP
 #line 342 "ldlex.l"
-{ RTOKEN(ALIAS); }
+{ RTOKEN(CHIP); }
 	YY_BREAK
 case 149:
 YY_RULE_SETUP
 #line 343 "ldlex.l"
-{ RTOKEN(TRUNCATE); }
+{ RTOKEN(BASE); }
 	YY_BREAK
 case 150:
 YY_RULE_SETUP
 #line 344 "ldlex.l"
-{ RTOKEN(LOAD); }
+{ RTOKEN(ALIAS); }
 	YY_BREAK
 case 151:
 YY_RULE_SETUP
 #line 345 "ldlex.l"
-{ RTOKEN(PUBLIC); }
+{ RTOKEN(TRUNCATE); }
 	YY_BREAK
 case 152:
 YY_RULE_SETUP
 #line 346 "ldlex.l"
-{ RTOKEN(ORDER); }
+{ RTOKEN(LOAD); }
 	YY_BREAK
 case 153:
 YY_RULE_SETUP
 #line 347 "ldlex.l"
-{ RTOKEN(NAMEWORD); }
+{ RTOKEN(PUBLIC); }
 	YY_BREAK
 case 154:
 YY_RULE_SETUP
 #line 348 "ldlex.l"
-{ RTOKEN(FORMAT); }
+{ RTOKEN(ORDER); }
 	YY_BREAK
 case 155:
 YY_RULE_SETUP
 #line 349 "ldlex.l"
-{ RTOKEN(CASE); }
+{ RTOKEN(NAMEWORD); }
 	YY_BREAK
 case 156:
 YY_RULE_SETUP
 #line 350 "ldlex.l"
-{ RTOKEN(EXTERN); }
+{ RTOKEN(FORMAT); }
 	YY_BREAK
 case 157:
 YY_RULE_SETUP
 #line 351 "ldlex.l"
-{ RTOKEN(START); }
+{ RTOKEN(CASE); }
 	YY_BREAK
 case 158:
 YY_RULE_SETUP
 #line 352 "ldlex.l"
-{ RTOKEN(LIST); /* LIST and ignore to end of line */ }
+{ RTOKEN(EXTERN); }
 	YY_BREAK
 case 159:
 YY_RULE_SETUP
 #line 353 "ldlex.l"
-{ RTOKEN(SECT); }
+{ RTOKEN(START); }
 	YY_BREAK
 case 160:
 YY_RULE_SETUP
 #line 354 "ldlex.l"
-{ RTOKEN(ABSOLUTE); }
+{ RTOKEN(LIST); /* LIST and ignore to end of line */ }
 	YY_BREAK
 case 161:
 YY_RULE_SETUP
+#line 355 "ldlex.l"
+{ RTOKEN(SECT); }
+	YY_BREAK
+case 162:
+YY_RULE_SETUP
 #line 356 "ldlex.l"
+{ RTOKEN(ABSOLUTE); }
+	YY_BREAK
+case 163:
+YY_RULE_SETUP
+#line 358 "ldlex.l"
 {
 /* Filename without commas, needed to parse mri stuff */
 				 yylval.name = xstrdup (yytext);
 				  return NAME;
 				}
 	YY_BREAK
-case 162:
+case 164:
 YY_RULE_SETUP
-#line 363 "ldlex.l"
+#line 365 "ldlex.l"
 {
 				 yylval.name = xstrdup (yytext);
 				  return NAME;
 				}
 	YY_BREAK
-case 163:
+case 165:
 YY_RULE_SETUP
-#line 367 "ldlex.l"
+#line 369 "ldlex.l"
 {
 				  yylval.name = xstrdup (yytext + 2);
 				  return LNAME;
 				}
 	YY_BREAK
-case 164:
+case 166:
 YY_RULE_SETUP
-#line 371 "ldlex.l"
+#line 373 "ldlex.l"
 {
 				 yylval.name = xstrdup (yytext);
 				  return NAME;
 				}
 	YY_BREAK
-case 165:
+case 167:
 YY_RULE_SETUP
-#line 375 "ldlex.l"
+#line 377 "ldlex.l"
 {
 				  yylval.name = xstrdup (yytext + 2);
 				  return LNAME;
 				}
 	YY_BREAK
-case 166:
+case 168:
 YY_RULE_SETUP
-#line 379 "ldlex.l"
+#line 381 "ldlex.l"
 {
 		/* Annoyingly, this pattern can match comments, and we have
 		   longest match issues to consider.  So if the first two
@@ -2809,10 +2828,10 @@
 		  }
 	}
 	YY_BREAK
-case 167:
-/* rule 167 can match eol */
+case 169:
+/* rule 169 can match eol */
 YY_RULE_SETUP
-#line 396 "ldlex.l"
+#line 398 "ldlex.l"
 {
 					/* No matter the state, quotes
 					   give what's inside */
@@ -2821,94 +2840,94 @@
 					return NAME;
 				}
 	YY_BREAK
-case 168:
-/* rule 168 can match eol */
+case 170:
+/* rule 170 can match eol */
 YY_RULE_SETUP
-#line 403 "ldlex.l"
+#line 405 "ldlex.l"
 { lineno++;}
 	YY_BREAK
-case 169:
+case 171:
 YY_RULE_SETUP
-#line 404 "ldlex.l"
+#line 406 "ldlex.l"
 { }
 	YY_BREAK
-case 170:
+case 172:
 YY_RULE_SETUP
-#line 406 "ldlex.l"
+#line 408 "ldlex.l"
 { return *yytext; }
 	YY_BREAK
-case 171:
+case 173:
 YY_RULE_SETUP
-#line 408 "ldlex.l"
+#line 410 "ldlex.l"
 { RTOKEN(GLOBAL); }
 	YY_BREAK
-case 172:
+case 174:
 YY_RULE_SETUP
-#line 410 "ldlex.l"
+#line 412 "ldlex.l"
 { RTOKEN(LOCAL); }
 	YY_BREAK
-case 173:
+case 175:
 YY_RULE_SETUP
-#line 412 "ldlex.l"
+#line 414 "ldlex.l"
 { RTOKEN(EXTERN); }
 	YY_BREAK
-case 174:
+case 176:
 YY_RULE_SETUP
-#line 414 "ldlex.l"
+#line 416 "ldlex.l"
 { yylval.name = xstrdup (yytext);
 				  return VERS_IDENTIFIER; }
 	YY_BREAK
-case 175:
+case 177:
 YY_RULE_SETUP
-#line 417 "ldlex.l"
+#line 419 "ldlex.l"
 { yylval.name = xstrdup (yytext);
 				  return VERS_TAG; }
 	YY_BREAK
-case 176:
+case 178:
 YY_RULE_SETUP
-#line 420 "ldlex.l"
+#line 422 "ldlex.l"
 { BEGIN(VERS_SCRIPT); return *yytext; }
 	YY_BREAK
-case 177:
+case 179:
 YY_RULE_SETUP
-#line 422 "ldlex.l"
+#line 424 "ldlex.l"
 { BEGIN(VERS_NODE);
 				  vers_node_nesting = 0;
 				  return *yytext;
 				}
 	YY_BREAK
-case 178:
+case 180:
 YY_RULE_SETUP
-#line 426 "ldlex.l"
+#line 428 "ldlex.l"
 { return *yytext; }
 	YY_BREAK
-case 179:
+case 181:
 YY_RULE_SETUP
-#line 427 "ldlex.l"
+#line 429 "ldlex.l"
 { vers_node_nesting++; return *yytext; }
 	YY_BREAK
-case 180:
+case 182:
 YY_RULE_SETUP
-#line 428 "ldlex.l"
+#line 430 "ldlex.l"
 { if (--vers_node_nesting < 0)
 				    BEGIN(VERS_SCRIPT);
 				  return *yytext;
 				}
 	YY_BREAK
-case 181:
-/* rule 181 can match eol */
+case 183:
+/* rule 183 can match eol */
 YY_RULE_SETUP
-#line 433 "ldlex.l"
+#line 435 "ldlex.l"
 { lineno++; }
 	YY_BREAK
-case 182:
+case 184:
 YY_RULE_SETUP
-#line 435 "ldlex.l"
+#line 437 "ldlex.l"
 { /* Eat up comments */ }
 	YY_BREAK
-case 183:
+case 185:
 YY_RULE_SETUP
-#line 437 "ldlex.l"
+#line 439 "ldlex.l"
 { /* Eat up whitespace */ }
 	YY_BREAK
 case YY_STATE_EOF(INITIAL):
@@ -2920,7 +2939,7 @@
 case YY_STATE_EOF(VERS_START):
 case YY_STATE_EOF(VERS_SCRIPT):
 case YY_STATE_EOF(VERS_NODE):
-#line 439 "ldlex.l"
+#line 441 "ldlex.l"
 {
   include_stack_ptr--;
 
@@ -2939,22 +2958,22 @@
   return END;
 }
 	YY_BREAK
-case 184:
+case 186:
 YY_RULE_SETUP
-#line 457 "ldlex.l"
+#line 459 "ldlex.l"
 lex_warn_invalid (" in script", yytext);
 	YY_BREAK
-case 185:
+case 187:
 YY_RULE_SETUP
-#line 458 "ldlex.l"
+#line 460 "ldlex.l"
 lex_warn_invalid (" in expression", yytext);
 	YY_BREAK
-case 186:
+case 188:
 YY_RULE_SETUP
-#line 460 "ldlex.l"
+#line 462 "ldlex.l"
 ECHO;
 	YY_BREAK
-#line 2958 "ldlex.c"
+#line 2977 "ldlex.c"
 
 	case YY_END_OF_BUFFER:
 		{
@@ -3183,7 +3202,7 @@
 
 		/* Read in more data. */
 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
-			(yy_n_chars), (size_t) num_to_read );
+			(yy_n_chars), num_to_read );
 
 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
 		}
@@ -3236,7 +3255,7 @@
 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 			{
 			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 1536 )
+			if ( yy_current_state >= 1562 )
 				yy_c = yy_meta[(unsigned int) yy_c];
 			}
 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
@@ -3264,11 +3283,11 @@
 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 		{
 		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 1536 )
+		if ( yy_current_state >= 1562 )
 			yy_c = yy_meta[(unsigned int) yy_c];
 		}
 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 1535);
+	yy_is_jam = (yy_current_state == 1561);
 
 	return yy_is_jam ? 0 : yy_current_state;
 }
@@ -3684,16 +3703,16 @@
 
 /** Setup the input buffer state to scan a string. The next call to yylex() will
  * scan from a @e copy of @a str.
- * @param yystr a NUL-terminated string to scan
+ * @param str a NUL-terminated string to scan
  * 
  * @return the newly allocated buffer state object.
  * @note If you want to scan bytes that may contain NUL values, then use
  *       yy_scan_bytes() instead.
  */
-YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
+YY_BUFFER_STATE yy_scan_string (yyconst char * yy_str )
 {
     
-	return yy_scan_bytes(yystr,strlen(yystr) );
+	return yy_scan_bytes(yy_str,strlen(yy_str) );
 }
 
 /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
@@ -3703,7 +3722,7 @@
  * 
  * @return the newly allocated buffer state object.
  */
-YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+YY_BUFFER_STATE yy_scan_bytes  (yyconst char * bytes, int  len )
 {
 	YY_BUFFER_STATE b;
 	char *buf;
@@ -3711,15 +3730,15 @@
 	int i;
     
 	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = _yybytes_len + 2;
+	n = len + 2;
 	buf = (char *) yyalloc(n  );
 	if ( ! buf )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
 
-	for ( i = 0; i < _yybytes_len; ++i )
-		buf[i] = yybytes[i];
+	for ( i = 0; i < len; ++i )
+		buf[i] = bytes[i];
 
-	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
 
 	b = yy_scan_buffer(buf,n );
 	if ( ! b )
@@ -3840,34 +3859,6 @@
         yy_flex_debug = bdebug ;
 }
 
-static int yy_init_globals (void)
-{
-        /* Initialization is the same as for the non-reentrant scanner.
-     * This function is called from yylex_destroy(), so don't allocate here.
-     */
-
-    (yy_buffer_stack) = 0;
-    (yy_buffer_stack_top) = 0;
-    (yy_buffer_stack_max) = 0;
-    (yy_c_buf_p) = (char *) 0;
-    (yy_init) = 0;
-    (yy_start) = 0;
-
-/* Defined in main.c */
-#ifdef YY_STDINIT
-    yyin = stdin;
-    yyout = stdout;
-#else
-    yyin = (FILE *) 0;
-    yyout = (FILE *) 0;
-#endif
-
-    /* For future reference: Set errno on error, since we are called by
-     * yylex_init()
-     */
-    return 0;
-}
-
 /* yylex_destroy is for both reentrant and non-reentrant scanners. */
 int yylex_destroy  (void)
 {
@@ -3883,10 +3874,6 @@
 	yyfree((yy_buffer_stack) );
 	(yy_buffer_stack) = NULL;
 
-    /* Reset the globals. This is important in a non-reentrant scanner so the next time
-     * yylex() is called, initialization will occur. */
-    yy_init_globals( );
-
     return 0;
 }
 
@@ -3898,7 +3885,7 @@
 static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
 {
 	register int i;
-	for ( i = 0; i < n; ++i )
+    	for ( i = 0; i < n; ++i )
 		s1[i] = s2[i];
 }
 #endif
@@ -3907,7 +3894,7 @@
 static int yy_flex_strlen (yyconst char * s )
 {
 	register int n;
-	for ( n = 0; s[n]; ++n )
+    	for ( n = 0; s[n]; ++n )
 		;
 
 	return n;
@@ -3938,7 +3925,19 @@
 
 #define YYTABLES_NAME "yytables"
 
-#line 460 "ldlex.l"
+#undef YY_NEW_FILE
+#undef YY_FLUSH_BUFFER
+#undef yy_set_bol
+#undef yy_new_buffer
+#undef yy_set_interactive
+#undef yytext_ptr
+#undef YY_DO_BEFORE_ACTION
+
+#ifdef YY_DECL_IS_OURS
+#undef YY_DECL_IS_OURS
+#undef YY_DECL
+#endif
+#line 462 "ldlex.l"
 
 
 
diff -Naur ../PRISTINE/binutils-2.18/ld/ldlex.l binutils-2.18/ld/ldlex.l
--- ../PRISTINE/binutils-2.18/ld/ldlex.l	2007-08-06 13:00:21.000000000 -0700
+++ binutils-2.18/ld/ldlex.l	2009-01-09 17:32:43.763471000 -0800
@@ -253,6 +253,8 @@
 <EXPRESSION,BOTH,SCRIPT>"ALIGNOF"	{ RTOKEN(ALIGNOF); }
 <EXPRESSION,BOTH>"MAX"			{ RTOKEN(MAX_K); }
 <EXPRESSION,BOTH>"MIN"			{ RTOKEN(MIN_K); }
+<EXPRESSION,BOTH>"CEILP2"			{ RTOKEN(CEILP2); }
+<EXPRESSION,BOTH>"NACL_MASK"	{ RTOKEN(NACL_MASK);}
 <EXPRESSION,BOTH,SCRIPT>"ASSERT"	{ RTOKEN(ASSERT_K); }
 <BOTH,SCRIPT>"ENTRY"			{ RTOKEN(ENTRY);}
 <BOTH,SCRIPT,MRI>"EXTERN"		{ RTOKEN(EXTERN);}
diff -Naur ../PRISTINE/binutils-2.18/ld/scripttempl/naclelf.sc binutils-2.18/ld/scripttempl/naclelf.sc
--- ../PRISTINE/binutils-2.18/ld/scripttempl/naclelf.sc	1969-12-31 16:00:00.000000000 -0800
+++ binutils-2.18/ld/scripttempl/naclelf.sc	2009-01-09 17:32:43.784455000 -0800
@@ -0,0 +1,552 @@
+#
+# Unusual variables checked by this code:
+#	NOP - four byte opcode for no-op (defaults to 0)
+#	NO_SMALL_DATA - no .sbss/.sbss2/.sdata/.sdata2 sections if not
+#		empty.
+#	SMALL_DATA_CTOR - .ctors contains small data.
+#	SMALL_DATA_DTOR - .dtors contains small data.
+#	DATA_ADDR - if end-of-text-plus-one-page isn't right for data start
+#	INITIAL_READONLY_SECTIONS - at start of text segment
+#	OTHER_READONLY_SECTIONS - other than .text .init .rodata ...
+#		(e.g., .PARISC.milli)
+#	OTHER_TEXT_SECTIONS - these get put in .text when relocating
+#	OTHER_READWRITE_SECTIONS - other than .data .bss .ctors .sdata ...
+#		(e.g., .PARISC.global)
+#	OTHER_RELRO_SECTIONS - other than .data.rel.ro ...
+#		(e.g. PPC32 .fixup, .got[12])
+#	OTHER_BSS_SECTIONS - other than .bss .sbss ...
+#	ATTRS_SECTIONS - at the end
+#	OTHER_SECTIONS - at the end
+#	EXECUTABLE_SYMBOLS - symbols that must be defined for an
+#		executable (e.g., _DYNAMIC_LINK)
+#       TEXT_START_ADDR - the first byte of the text segment, after any
+#               headers.
+#       TEXT_BASE_ADDRESS - the first byte of the text segment.
+#	TEXT_START_SYMBOLS - symbols that appear at the start of the
+#		.text section.
+#	DATA_START_SYMBOLS - symbols that appear at the start of the
+#		.data section.
+#	DATA_END_SYMBOLS - symbols that appear at the end of the
+#		writeable data sections.
+#	OTHER_GOT_SYMBOLS - symbols defined just before .got.
+#	OTHER_GOT_SECTIONS - sections just after .got.
+#	OTHER_SDATA_SECTIONS - sections just after .sdata.
+#	OTHER_BSS_SYMBOLS - symbols that appear at the start of the
+#		.bss section besides __bss_start.
+#	DATA_PLT - .plt should be in data segment, not text segment.
+#	PLT_BEFORE_GOT - .plt just before .got when .plt is in data segement.
+#	BSS_PLT - .plt should be in bss segment
+#	TEXT_DYNAMIC - .dynamic in text segment, not data segment.
+#	EMBEDDED - whether this is for an embedded system. 
+#	SHLIB_TEXT_START_ADDR - if set, add to SIZEOF_HEADERS to set
+#		start address of shared library.
+#	INPUT_FILES - INPUT command of files to always include
+#	WRITABLE_RODATA - if set, the .rodata section should be writable
+#	INIT_START, INIT_END -  statements just before and just after
+# 	combination of .init sections.
+#	FINI_START, FINI_END - statements just before and just after
+# 	combination of .fini sections.
+#	STACK_ADDR - start of a .stack section.
+#	OTHER_SYMBOLS - symbols to place right at the end of the script.
+#	ETEXT_NAME - name of a symbol for the end of the text section,
+#		normally etext.
+#	SEPARATE_GOTPLT - if set, .got.plt should be separate output section,
+#		so that .got can be in the RELRO area.  It should be set to
+#		the number of bytes in the beginning of .got.plt which can be
+#		in the RELRO area as well.
+#	USER_LABEL_PREFIX - prefix to add to user-visible symbols.
+#
+# When adding sections, do note that the names of some sections are used
+# when specifying the start address of the next.
+#
+
+#  Many sections come in three flavours.  There is the 'real' section,
+#  like ".data".  Then there are the per-procedure or per-variable
+#  sections, generated by -ffunction-sections and -fdata-sections in GCC,
+#  and useful for --gc-sections, which for a variable "foo" might be
+#  ".data.foo".  Then there are the linkonce sections, for which the linker
+#  eliminates duplicates, which are named like ".gnu.linkonce.d.foo".
+#  The exact correspondences are:
+#
+#  Section	Linkonce section
+#  .text	.gnu.linkonce.t.foo
+#  .rodata	.gnu.linkonce.r.foo
+#  .data	.gnu.linkonce.d.foo
+#  .bss		.gnu.linkonce.b.foo
+#  .sdata	.gnu.linkonce.s.foo
+#  .sbss	.gnu.linkonce.sb.foo
+#  .sdata2	.gnu.linkonce.s2.foo
+#  .sbss2	.gnu.linkonce.sb2.foo
+#  .debug_info	.gnu.linkonce.wi.foo
+#  .tdata	.gnu.linkonce.td.foo
+#  .tbss	.gnu.linkonce.tb.foo
+#  .lrodata	.gnu.linkonce.lr.foo
+#  .ldata	.gnu.linkonce.l.foo
+#  .lbss	.gnu.linkonce.lb.foo
+#
+#  Each of these can also have corresponding .rel.* and .rela.* sections.
+
+test -z "$ENTRY" && ENTRY=_start
+test -z "${BIG_OUTPUT_FORMAT}" && BIG_OUTPUT_FORMAT=${OUTPUT_FORMAT}
+test -z "${LITTLE_OUTPUT_FORMAT}" && LITTLE_OUTPUT_FORMAT=${OUTPUT_FORMAT}
+if [ -z "$MACHINE" ]; then OUTPUT_ARCH=${ARCH}; else OUTPUT_ARCH=${ARCH}:${MACHINE}; fi
+test -z "${ELFSIZE}" && ELFSIZE=32
+test -z "${ALIGNMENT}" && ALIGNMENT="${ELFSIZE} / 8"
+test "$LD_FLAG" = "N" && DATA_ADDR=.
+test -z "${ETEXT_NAME}" && ETEXT_NAME=etext
+test -n "$CREATE_SHLIB$CREATE_PIE" && test -n "$SHLIB_DATA_ADDR" && COMMONPAGESIZE=""
+test -z "$CREATE_SHLIB$CREATE_PIE" && test -n "$DATA_ADDR" && COMMONPAGESIZE=""
+test -n "$RELRO_NOW" && unset SEPARATE_GOTPLT
+test -z "$ATTRS_SECTIONS" && ATTRS_SECTIONS=".gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }"
+DATA_SEGMENT_ALIGN="ALIGN(${SEGMENT_SIZE}) + (. & (${MAXPAGESIZE} - 1))"
+DATA_SEGMENT_RELRO_END=""
+DATA_SEGMENT_END=""
+if test -n "${COMMONPAGESIZE}"; then
+  DATA_SEGMENT_ALIGN="ALIGN (${SEGMENT_SIZE}) - ((${MAXPAGESIZE} - .) & (${MAXPAGESIZE} - 1)); . = DATA_SEGMENT_ALIGN (${MAXPAGESIZE}, ${COMMONPAGESIZE})"
+  DATA_SEGMENT_END=". = DATA_SEGMENT_END (.);"
+  DATA_SEGMENT_RELRO_END=". = DATA_SEGMENT_RELRO_END (${SEPARATE_GOTPLT-0}, .);"
+fi
+if test -z "${INITIAL_READONLY_SECTIONS}${CREATE_SHLIB}"; then
+  INITIAL_READONLY_SECTIONS=".interp       ${RELOCATING-0} : { *(.interp) }"
+fi
+if test -z "$PLT"; then
+  PLT=".plt          ${RELOCATING-0} : { *(.plt) }"
+fi
+test -n "${DATA_PLT-${BSS_PLT-text}}" && TEXT_PLT=yes
+if test -z "$GOT"; then
+  if test -z "$SEPARATE_GOTPLT"; then
+    GOT=".got          ${RELOCATING-0} : { *(.got.plt) *(.got) }"
+  else
+    GOT=".got          ${RELOCATING-0} : { *(.got) }"
+    GOTPLT=".got.plt      ${RELOCATING-0} : { *(.got.plt) }"
+  fi
+fi
+DYNAMIC=".dynamic      ${RELOCATING-0} : { *(.dynamic) }"
+RODATA=".rodata       ${RELOCATING-0} : { *(.rodata${RELOCATING+ .rodata.* .gnu.linkonce.r.*}) }"
+DATARELRO=".data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro* .gnu.linkonce.d.rel.ro.*) }"
+DISCARDED="/DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) }"
+if test -z "${NO_SMALL_DATA}"; then
+  SBSS=".sbss         ${RELOCATING-0} :
+  {
+    ${RELOCATING+${SBSS_START_SYMBOLS}}
+    ${CREATE_SHLIB+*(.sbss2 .sbss2.* .gnu.linkonce.sb2.*)}
+    *(.dynsbss)
+    *(.sbss${RELOCATING+ .sbss.* .gnu.linkonce.sb.*})
+    *(.scommon)
+    ${RELOCATING+${SBSS_END_SYMBOLS}}
+  }"
+  SBSS2=".sbss2        ${RELOCATING-0} : { *(.sbss2${RELOCATING+ .sbss2.* .gnu.linkonce.sb2.*}) }"
+  SDATA="/* We want the small data sections together, so single-instruction offsets
+     can access them all, and initialized data all before uninitialized, so
+     we can shorten the on-disk segment size.  */
+  .sdata        ${RELOCATING-0} : 
+  {
+    ${RELOCATING+${SDATA_START_SYMBOLS}}
+    ${CREATE_SHLIB+*(.sdata2 .sdata2.* .gnu.linkonce.s2.*)}
+    *(.sdata${RELOCATING+ .sdata.* .gnu.linkonce.s.*})
+  }"
+  SDATA2=".sdata2       ${RELOCATING-0} :
+  {
+    ${RELOCATING+${SDATA2_START_SYMBOLS}}
+    *(.sdata2${RELOCATING+ .sdata2.* .gnu.linkonce.s2.*})
+  }"
+  REL_SDATA=".rel.sdata    ${RELOCATING-0} : { *(.rel.sdata${RELOCATING+ .rel.sdata.* .rel.gnu.linkonce.s.*}) }
+  .rela.sdata   ${RELOCATING-0} : { *(.rela.sdata${RELOCATING+ .rela.sdata.* .rela.gnu.linkonce.s.*}) }"
+  REL_SBSS=".rel.sbss     ${RELOCATING-0} : { *(.rel.sbss${RELOCATING+ .rel.sbss.* .rel.gnu.linkonce.sb.*}) }
+  .rela.sbss    ${RELOCATING-0} : { *(.rela.sbss${RELOCATING+ .rela.sbss.* .rela.gnu.linkonce.sb.*}) }"
+  REL_SDATA2=".rel.sdata2   ${RELOCATING-0} : { *(.rel.sdata2${RELOCATING+ .rel.sdata2.* .rel.gnu.linkonce.s2.*}) }
+  .rela.sdata2  ${RELOCATING-0} : { *(.rela.sdata2${RELOCATING+ .rela.sdata2.* .rela.gnu.linkonce.s2.*}) }"
+  REL_SBSS2=".rel.sbss2    ${RELOCATING-0} : { *(.rel.sbss2${RELOCATING+ .rel.sbss2.* .rel.gnu.linkonce.sb2.*}) }
+  .rela.sbss2   ${RELOCATING-0} : { *(.rela.sbss2${RELOCATING+ .rela.sbss2.* .rela.gnu.linkonce.sb2.*}) }"
+else
+  NO_SMALL_DATA=" "
+fi
+if test -z "${DATA_GOT}"; then
+  if test -n "${NO_SMALL_DATA}"; then
+    DATA_GOT=" "
+  fi
+fi
+if test -z "${SDATA_GOT}"; then
+  if test -z "${NO_SMALL_DATA}"; then
+    SDATA_GOT=" "
+  fi
+fi
+test -n "$SEPARATE_GOTPLT" && SEPARATE_GOTPLT=" "
+test "${LARGE_SECTIONS}" = "yes" && REL_LARGE="
+  .rel.ldata    ${RELOCATING-0} : { *(.rel.ldata${RELOCATING+ .rel.ldata.* .rel.gnu.linkonce.l.*}) }
+  .rela.ldata   ${RELOCATING-0} : { *(.rela.ldata${RELOCATING+ .rela.ldata.* .rela.gnu.linkonce.l.*}) }
+  .rel.lbss     ${RELOCATING-0} : { *(.rel.lbss${RELOCATING+ .rel.lbss.* .rel.gnu.linkonce.lb.*}) }
+  .rela.lbss    ${RELOCATING-0} : { *(.rela.lbss${RELOCATING+ .rela.lbss.* .rela.gnu.linkonce.lb.*}) }
+  .rel.lrodata  ${RELOCATING-0} : { *(.rel.lrodata${RELOCATING+ .rel.lrodata.* .rel.gnu.linkonce.lr.*}) }
+  .rela.lrodata ${RELOCATING-0} : { *(.rela.lrodata${RELOCATING+ .rela.lrodata.* .rela.gnu.linkonce.lr.*}) }"
+test "${LARGE_SECTIONS}" = "yes" && OTHER_BSS_SECTIONS="
+  ${OTHER_BSS_SECTIONS}
+  .lbss ${RELOCATING-0} :
+  {
+    *(.dynlbss)
+    *(.lbss${RELOCATING+ .lbss.* .gnu.linkonce.lb.*})
+    *(LARGE_COMMON)
+  }"
+test "${LARGE_SECTIONS}" = "yes" && LARGE_SECTIONS="
+  .lrodata ${RELOCATING-0} ${RELOCATING+ALIGN(${MAXPAGESIZE}) + (. & (${MAXPAGESIZE} - 1))} :
+  {
+    *(.lrodata${RELOCATING+ .lrodata.* .gnu.linkonce.lr.*})
+  }
+  .ldata ${RELOCATING-0} ${RELOCATING+ALIGN(${MAXPAGESIZE}) + (. & (${MAXPAGESIZE} - 1))} :
+  {
+    *(.ldata${RELOCATING+ .ldata.* .gnu.linkonce.l.*})
+    ${RELOCATING+. = ALIGN(. != 0 ? ${ALIGNMENT} : 1);}
+  }"
+CTOR=".ctors        ${CONSTRUCTING-0} : 
+  {
+    ${CONSTRUCTING+${CTOR_START}}
+    /* gcc uses crtbegin.o to find the start of
+       the constructors, so we make sure it is
+       first.  Because this is a wildcard, it
+       doesn't matter if the user does not
+       actually link against crtbegin.o; the
+       linker won't look for a file to match a
+       wildcard.  The wildcard also means that it
+       doesn't matter which directory crtbegin.o
+       is in.  */
+
+    KEEP (*crtbegin.o(.ctors))
+    KEEP (*crtbegin?.o(.ctors))
+
+    /* We don't want to include the .ctor section from
+       the crtend.o file until after the sorted ctors.
+       The .ctor section from the crtend file contains the
+       end of ctors marker and it must be last */
+
+    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o $OTHER_EXCLUDE_FILES) .ctors))
+    KEEP (*(SORT(.ctors.*)))
+    KEEP (*(.ctors))
+    ${CONSTRUCTING+${CTOR_END}}
+  }"
+DTOR=".dtors        ${CONSTRUCTING-0} :
+  {
+    ${CONSTRUCTING+${DTOR_START}}
+    KEEP (*crtbegin.o(.dtors))
+    KEEP (*crtbegin?.o(.dtors))
+    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o $OTHER_EXCLUDE_FILES) .dtors))
+    KEEP (*(SORT(.dtors.*)))
+    KEEP (*(.dtors))
+    ${CONSTRUCTING+${DTOR_END}}
+  }"
+STACK="  .stack        ${RELOCATING-0}${RELOCATING+${STACK_ADDR}} :
+  {
+    ${RELOCATING+_stack = .;}
+    *(.stack)
+  }"
+
+# if this is for an embedded system (or nacl), don't add SIZEOF_HEADERS.
+if [ -z "$EMBEDDED" ]; then
+   test -z "${TEXT_BASE_ADDRESS}" && TEXT_BASE_ADDRESS="${TEXT_START_ADDR}"
+else
+   test -z "${TEXT_BASE_ADDRESS}" && TEXT_BASE_ADDRESS="${TEXT_START_ADDR}"
+fi
+
+cat <<EOF
+OUTPUT_FORMAT("${OUTPUT_FORMAT}", "${BIG_OUTPUT_FORMAT}",
+	      "${LITTLE_OUTPUT_FORMAT}")
+OUTPUT_ARCH(${OUTPUT_ARCH})
+ENTRY(${ENTRY})
+
+${RELOCATING+${LIB_SEARCH_DIRS}}
+${RELOCATING+${EXECUTABLE_SYMBOLS}}
+${RELOCATING+${INPUT_FILES}}
+${RELOCATING- /* For some reason, the Solaris linker makes bad executables
+  if gld -r is used and the intermediate file has sections starting
+  at non-zero addresses.  Could be a Solaris ld bug, could be a GNU ld
+  bug.  But for now assigning the zero vmas works.  */}
+
+PHDRS
+{
+  headers PT_PHDR FILEHDR PHDRS ;  /* put the headers in a non-loadable seg */
+  text    PT_LOAD FLAGS(5) ;       /* read + execute */
+  rodata  PT_LOAD FLAGS(4) ;       /* read */
+  data    PT_LOAD FLAGS(6) ;       /* read + write */
+  /* TODO(sehr): do we need a stack? */
+}
+
+SECTIONS
+{
+  /* Read-only sections, merged into text segment: */
+  ${CREATE_SHLIB-${CREATE_PIE-${RELOCATING+PROVIDE (__executable_start = ${TEXT_START_ADDR}); . = ${TEXT_BASE_ADDRESS};}}}
+  ${CREATE_SHLIB+${RELOCATING+. = ${SHLIB_TEXT_START_ADDR:-0} + SIZEOF_HEADERS;}}
+  ${CREATE_PIE+${RELOCATING+. = ${SHLIB_TEXT_START_ADDR:-0} + SIZEOF_HEADERS;}}
+  ${INITIAL_READONLY_SECTIONS}
+  .note.gnu.build-id : { *(.note.gnu.build-id) }
+  ${TEXT_DYNAMIC+${DYNAMIC}}
+  .hash         ${RELOCATING-0} : { *(.hash) }
+  .gnu.hash     ${RELOCATING-0} : { *(.gnu.hash) }
+  .dynsym       ${RELOCATING-0} : { *(.dynsym) }
+  .dynstr       ${RELOCATING-0} : { *(.dynstr) }
+  .gnu.version  ${RELOCATING-0} : { *(.gnu.version) }
+  .gnu.version_d ${RELOCATING-0}: { *(.gnu.version_d) }
+  .gnu.version_r ${RELOCATING-0}: { *(.gnu.version_r) }
+
+EOF
+if [ "x$COMBRELOC" = x ]; then
+  COMBRELOCCAT=cat
+else
+  COMBRELOCCAT="cat > $COMBRELOC"
+fi
+eval $COMBRELOCCAT <<EOF
+  .rel.init     ${RELOCATING-0} : { *(.rel.init) }
+  .rela.init    ${RELOCATING-0} : { *(.rela.init) }
+  .rel.text     ${RELOCATING-0} : { *(.rel.text${RELOCATING+ .rel.text.* .rel.gnu.linkonce.t.*}) }
+  .rela.text    ${RELOCATING-0} : { *(.rela.text${RELOCATING+ .rela.text.* .rela.gnu.linkonce.t.*}) }
+  .rel.fini     ${RELOCATING-0} : { *(.rel.fini) }
+  .rela.fini    ${RELOCATING-0} : { *(.rela.fini) }
+  .rel.rodata   ${RELOCATING-0} : { *(.rel.rodata${RELOCATING+ .rel.rodata.* .rel.gnu.linkonce.r.*}) }
+  .rela.rodata  ${RELOCATING-0} : { *(.rela.rodata${RELOCATING+ .rela.rodata.* .rela.gnu.linkonce.r.*}) }
+  ${OTHER_READONLY_RELOC_SECTIONS}
+  .rel.data.rel.ro ${RELOCATING-0} : { *(.rel.data.rel.ro${RELOCATING+* .rel.gnu.linkonce.d.rel.ro.*}) }
+  .rela.data.rel.ro ${RELOCATING-0} : { *(.rela.data.rel.ro${RELOCATING+* .rela.gnu.linkonce.d.rel.ro.*}) }
+  .rel.data     ${RELOCATING-0} : { *(.rel.data${RELOCATING+ .rel.data.* .rel.gnu.linkonce.d.*}) }
+  .rela.data    ${RELOCATING-0} : { *(.rela.data${RELOCATING+ .rela.data.* .rela.gnu.linkonce.d.*}) }
+  .rel.tdata	${RELOCATING-0} : { *(.rel.tdata${RELOCATING+ .rel.tdata.* .rel.gnu.linkonce.td.*}) }
+  .rela.tdata	${RELOCATING-0} : { *(.rela.tdata${RELOCATING+ .rela.tdata.* .rela.gnu.linkonce.td.*}) }
+  .rel.tbss	${RELOCATING-0} : { *(.rel.tbss${RELOCATING+ .rel.tbss.* .rel.gnu.linkonce.tb.*}) }
+  .rela.tbss	${RELOCATING-0} : { *(.rela.tbss${RELOCATING+ .rela.tbss.* .rela.gnu.linkonce.tb.*}) }
+  .rel.ctors    ${RELOCATING-0} : { *(.rel.ctors) }
+  .rela.ctors   ${RELOCATING-0} : { *(.rela.ctors) }
+  .rel.dtors    ${RELOCATING-0} : { *(.rel.dtors) }
+  .rela.dtors   ${RELOCATING-0} : { *(.rela.dtors) }
+  .rel.got      ${RELOCATING-0} : { *(.rel.got) }
+  .rela.got     ${RELOCATING-0} : { *(.rela.got) }
+  ${OTHER_GOT_RELOC_SECTIONS}
+  ${REL_SDATA}
+  ${REL_SBSS}
+  ${REL_SDATA2}
+  ${REL_SBSS2}
+  .rel.bss      ${RELOCATING-0} : { *(.rel.bss${RELOCATING+ .rel.bss.* .rel.gnu.linkonce.b.*}) }
+  .rela.bss     ${RELOCATING-0} : { *(.rela.bss${RELOCATING+ .rela.bss.* .rela.gnu.linkonce.b.*}) }
+  ${REL_LARGE}
+EOF
+if [ -n "$COMBRELOC" ]; then
+cat <<EOF
+  .rel.dyn      ${RELOCATING-0} :
+    {
+EOF
+sed -e '/^[ 	]*[{}][ 	]*$/d;/:[ 	]*$/d;/\.rela\./d;s/^.*: { *\(.*\)}$/      \1/' $COMBRELOC
+cat <<EOF
+    }
+  .rela.dyn     ${RELOCATING-0} :
+    {
+EOF
+sed -e '/^[ 	]*[{}][ 	]*$/d;/:[ 	]*$/d;/\.rel\./d;s/^.*: { *\(.*\)}/      \1/' $COMBRELOC
+cat <<EOF
+    }
+EOF
+fi
+cat <<EOF
+  .rel.plt      ${RELOCATING-0} : { *(.rel.plt) }
+  .rela.plt     ${RELOCATING-0} : { *(.rela.plt) }
+  ${OTHER_PLT_RELOC_SECTIONS}
+
+  .init         ${RELOCATING-0} : 
+  { 
+    ${RELOCATING+${INIT_START}}
+    KEEP (*(.init))
+    ${RELOCATING+${INIT_END}}
+  } :text =${NOP-0}
+
+  ${TEXT_PLT+${PLT}}
+  ${TINY_READONLY_SECTION}
+  .text         ${RELOCATING-0} :
+  {
+    ${RELOCATING+${TEXT_START_SYMBOLS}}
+    *(.text .stub${RELOCATING+ .text.* .gnu.linkonce.t.*})
+    KEEP (*(.text.*personality*))
+    /* .gnu.warning sections are handled specially by elf32.em.  */
+    *(.gnu.warning)
+    ${RELOCATING+${OTHER_TEXT_SECTIONS}}
+  } =${NOP-0}
+  .fini         ${RELOCATING-0} :
+  {
+    ${RELOCATING+${FINI_START}}
+    KEEP (*(.fini))
+    ${RELOCATING+${FINI_END}}
+  } =${NOP-0}
+  ${RELOCATING+PROVIDE (__${ETEXT_NAME} = .);}
+  ${RELOCATING+PROVIDE (_${ETEXT_NAME} = .);}
+  ${RELOCATING+PROVIDE (${ETEXT_NAME} = .);}
+  ${RELOCATING+. = DEFINED (__executable_start) ? 
+                     ALIGN(CEILP2(. - __executable_start)) : .;}
+  ${RELOCATING+PROVIDE (__nacl_and_mask =
+                          DEFINED (__executable_start) ?
+                            NACL_MASK (. - __executable_start) : 0xffffffff);}
+  ${RELOCATING+. = ALIGN(${MAXPAGESIZE});} /* nacl wants page alignment */
+  ${WRITABLE_RODATA-${RODATA}} :rodata
+  .rodata1      ${RELOCATING-0} : { *(.rodata1) }
+  .nacl_rpc_methods : { *(.nacl_rpc_methods) }
+  ${CREATE_SHLIB-${SDATA2}}
+  ${CREATE_SHLIB-${SBSS2}}
+  ${OTHER_READONLY_SECTIONS}
+  .eh_frame_hdr : { *(.eh_frame_hdr) }
+  .eh_frame     ${RELOCATING-0} : ONLY_IF_RO { KEEP (*(.eh_frame)) }
+  .gcc_except_table ${RELOCATING-0} : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }
+
+  /* Adjust the address for the data segment.  We want to adjust up to
+     the same address within the page on the next page up.  */
+  ${CREATE_SHLIB-${CREATE_PIE-${RELOCATING+. = ${DATA_ADDR-${DATA_SEGMENT_ALIGN}};}}}
+  ${CREATE_SHLIB+${RELOCATING+. = ${SHLIB_DATA_ADDR-${DATA_SEGMENT_ALIGN}};}}
+  ${CREATE_PIE+${RELOCATING+. = ${SHLIB_DATA_ADDR-${DATA_SEGMENT_ALIGN}};}}
+
+  /* Exception handling  */
+  .eh_frame     ${RELOCATING-0} : ONLY_IF_RW { KEEP (*(.eh_frame)) }
+  .gcc_except_table ${RELOCATING-0} : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }
+
+  /* Thread Local Storage sections  */
+  .tdata	${RELOCATING-0} : {
+    ${RELOCATING+PROVIDE (__tls_template_start = .);}
+    *(.tdata${RELOCATING+ .tdata.* .gnu.linkonce.td.*})
+    ${RELOCATING+PROVIDE (__tls_template_tdata_end = .);}
+  }
+  .tbss		${RELOCATING-0} : { *(.tbss${RELOCATING+ .tbss.* .gnu.linkonce.tb.*})${RELOCATING+ *(.tcommon)} }
+  /* The total size of the TLS template area must be a multiple of 32 */
+  /* . does not advance for tbss because it is not loaded. */
+  ${RELOCATING+PROVIDE (__tls_template_end =
+                           __tls_template_start +
+                           (((. + SIZEOF(.tbss)) - __tls_template_start + 31) &
+                            ~(31))
+                          );}
+
+  .preinit_array   ${RELOCATING-0} :
+  {
+    ${RELOCATING+${CREATE_SHLIB-PROVIDE_HIDDEN (${USER_LABEL_PREFIX}__preinit_array_start = .);}}
+    KEEP (*(.preinit_array))
+    ${RELOCATING+${CREATE_SHLIB-PROVIDE_HIDDEN (${USER_LABEL_PREFIX}__preinit_array_end = .);}}
+  }
+  .init_array   ${RELOCATING-0} :
+  {
+     ${RELOCATING+${CREATE_SHLIB-PROVIDE_HIDDEN (${USER_LABEL_PREFIX}__init_array_start = .);}}
+     KEEP (*(SORT(.init_array.*)))
+     KEEP (*(.init_array))
+     ${RELOCATING+${CREATE_SHLIB-PROVIDE_HIDDEN (${USER_LABEL_PREFIX}__init_array_end = .);}}
+  }
+  .fini_array   ${RELOCATING-0} :
+  {
+    ${RELOCATING+${CREATE_SHLIB-PROVIDE_HIDDEN (${USER_LABEL_PREFIX}__fini_array_start = .);}}
+    KEEP (*(.fini_array))
+    KEEP (*(SORT(.fini_array.*)))
+    ${RELOCATING+${CREATE_SHLIB-PROVIDE_HIDDEN (${USER_LABEL_PREFIX}__fini_array_end = .);}}
+  }
+  ${SMALL_DATA_CTOR-${RELOCATING+${CTOR}}}
+  ${SMALL_DATA_DTOR-${RELOCATING+${DTOR}}}
+  .jcr          ${RELOCATING-0} : { KEEP (*(.jcr)) }
+
+  ${RELOCATING+${DATARELRO}}
+  ${OTHER_RELRO_SECTIONS}
+  ${TEXT_DYNAMIC-${DYNAMIC}}
+  ${DATA_GOT+${RELRO_NOW+${GOT}}}
+  ${DATA_GOT+${RELRO_NOW+${GOTPLT}}}
+  ${DATA_GOT+${RELRO_NOW-${SEPARATE_GOTPLT+${GOT}}}}
+  ${RELOCATING+${DATA_SEGMENT_RELRO_END}}
+  ${DATA_GOT+${RELRO_NOW-${SEPARATE_GOTPLT-${GOT}}}}
+  ${DATA_GOT+${RELRO_NOW-${GOTPLT}}}
+
+  ${DATA_PLT+${PLT_BEFORE_GOT-${PLT}}}
+
+  ${RELOCATING+. = ALIGN(${MAXPAGESIZE});} /* nacl wants page alignment */
+  .data         ${RELOCATING-0} :
+  {
+    ${RELOCATING+${DATA_START_SYMBOLS}}
+    *(.data${RELOCATING+ .data.* .gnu.linkonce.d.*})
+    ${RELOCATING+KEEP (*(.gnu.linkonce.d.*personality*))}
+    ${CONSTRUCTING+SORT(CONSTRUCTORS)}
+  } :data
+  .data1        ${RELOCATING-0} : { *(.data1) }
+  ${WRITABLE_RODATA+${RODATA}}
+  ${OTHER_READWRITE_SECTIONS}
+  ${SMALL_DATA_CTOR+${RELOCATING+${CTOR}}}
+  ${SMALL_DATA_DTOR+${RELOCATING+${DTOR}}}
+  ${DATA_PLT+${PLT_BEFORE_GOT+${PLT}}}
+  ${SDATA_GOT+${RELOCATING+${OTHER_GOT_SYMBOLS}}}
+  ${SDATA_GOT+${GOT}}
+  ${SDATA_GOT+${OTHER_GOT_SECTIONS}}
+  ${SDATA}
+  ${OTHER_SDATA_SECTIONS}
+  ${RELOCATING+${DATA_END_SYMBOLS-${USER_LABEL_PREFIX}_edata = .; PROVIDE (${USER_LABEL_PREFIX}edata = .);}}
+  ${RELOCATING+__bss_start = .;}
+  ${RELOCATING+${OTHER_BSS_SYMBOLS}}
+  ${SBSS}
+  ${BSS_PLT+${PLT}}
+  .bss          ${RELOCATING-0} :
+  {
+   *(.dynbss)
+   *(.bss${RELOCATING+ .bss.* .gnu.linkonce.b.*})
+   *(COMMON)
+   /* Align here to ensure that the .bss section occupies space up to
+      _end.  Align after .bss to ensure correct alignment even if the
+      .bss section disappears because there are no input sections.
+      FIXME: Why do we need it? When there is no .bss section, we don't
+      pad the .data section.  */
+   ${RELOCATING+. = ALIGN(. != 0 ? ${ALIGNMENT} : 1);}
+  }
+  ${OTHER_BSS_SECTIONS}
+  ${RELOCATING+${OTHER_BSS_END_SYMBOLS}}
+  ${RELOCATING+. = ALIGN(${ALIGNMENT});}
+  ${LARGE_SECTIONS}
+  ${RELOCATING+. = ALIGN(${ALIGNMENT});}
+  ${RELOCATING+${OTHER_END_SYMBOLS}}
+  ${RELOCATING+${END_SYMBOLS-${USER_LABEL_PREFIX}_end = .; PROVIDE (${USER_LABEL_PREFIX}end = .);}}
+  ${RELOCATING+${DATA_SEGMENT_END}}
+
+  /* Stabs debugging sections.  */
+  .stab          0 : { *(.stab) }
+  .stabstr       0 : { *(.stabstr) }
+  .stab.excl     0 : { *(.stab.excl) }
+  .stab.exclstr  0 : { *(.stab.exclstr) }
+  .stab.index    0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+
+  .comment       0 : { *(.comment) }
+
+  /* DWARF debug sections.
+     Symbols in the DWARF debugging sections are relative to the beginning
+     of the section so we begin them at 0.  */
+
+  /* DWARF 1 */
+  .debug          0 : { *(.debug) }
+  .line           0 : { *(.line) }
+
+  /* GNU DWARF 1 extensions */
+  .debug_srcinfo  0 : { *(.debug_srcinfo) }
+  .debug_sfnames  0 : { *(.debug_sfnames) }
+
+  /* DWARF 1.1 and DWARF 2 */
+  .debug_aranges  0 : { *(.debug_aranges) }
+  .debug_pubnames 0 : { *(.debug_pubnames) }
+
+  /* DWARF 2 */
+  .debug_info     0 : { *(.debug_info${RELOCATING+ .gnu.linkonce.wi.*}) }
+  .debug_abbrev   0 : { *(.debug_abbrev) }
+  .debug_line     0 : { *(.debug_line) }
+  .debug_frame    0 : { *(.debug_frame) }
+  .debug_str      0 : { *(.debug_str) }
+  .debug_loc      0 : { *(.debug_loc) }
+  .debug_macinfo  0 : { *(.debug_macinfo) }
+
+  /* SGI/MIPS DWARF 2 extensions */
+  .debug_weaknames 0 : { *(.debug_weaknames) }
+  .debug_funcnames 0 : { *(.debug_funcnames) }
+  .debug_typenames 0 : { *(.debug_typenames) }
+  .debug_varnames  0 : { *(.debug_varnames) }
+
+  /* DWARF 3 */
+  .debug_pubtypes 0 : { *(.debug_pubtypes) }
+  .debug_ranges   0 : { *(.debug_ranges) }
+
+  ${TINY_DATA_SECTION}
+  ${TINY_BSS_SECTION}
+
+  ${STACK_ADDR+${STACK}}
+  ${ATTRS_SECTIONS}
+  ${OTHER_SECTIONS}
+  ${RELOCATING+${OTHER_SYMBOLS}}
+  ${RELOCATING+${DISCARDED}}
+}
+EOF
diff -Naur ../PRISTINE/binutils-2.18/opcodes/i386-opc.tbl binutils-2.18/opcodes/i386-opc.tbl
--- ../PRISTINE/binutils-2.18/opcodes/i386-opc.tbl	2007-08-12 17:11:33.000000000 -0700
+++ binutils-2.18/opcodes/i386-opc.tbl	2009-01-09 17:32:43.806441000 -0800
@@ -200,6 +200,10 @@
 or, 2, 0xc, None, 0, W|No_sSuf|No_xSuf, { Imm8|Imm16|Imm32|Imm32S, Acc }
 or, 2, 0x80, 0x1, 0, W|Modrm|No_sSuf|No_xSuf, { Imm8|Imm16|Imm32|Imm32S, Reg8|Reg16|Reg32|Reg64|BaseIndex|Disp8|Disp16|Disp32|Disp32S }
 
+// Native client support instructions.
+nacland, 2, 0x81, 0x4, 0, D|W|Modrm|No_sSuf|No_xSuf, { Imm32, Reg32 }
+naclor, 2, 0x81, 0x1, 0, D|W|Modrm|No_sSuf|No_xSuf, { Imm32, Reg32 }
+
 xor, 2, 0x30, None, 0, D|W|Modrm|No_sSuf|No_xSuf, { Reg8|Reg16|Reg32|Reg64, Reg8|Reg16|Reg32|Reg64|BaseIndex|Disp8|Disp16|Disp32|Disp32S }
 xor, 2, 0x83, 0x6, 0, Modrm|No_bSuf|No_sSuf|No_xSuf, { Imm8S, Reg16|Reg32|Reg64|BaseIndex|Disp8|Disp16|Disp32|Disp32S }
 xor, 2, 0x34, None, 0, W|No_sSuf|No_xSuf, { Imm8|Imm16|Imm32|Imm32S, Acc }
diff -Naur ../PRISTINE/binutils-2.18/opcodes/i386-tbl.h binutils-2.18/opcodes/i386-tbl.h
--- ../PRISTINE/binutils-2.18/opcodes/i386-tbl.h	2007-08-12 17:11:33.000000000 -0700
+++ binutils-2.18/opcodes/i386-tbl.h	2009-01-09 17:32:43.837404000 -0800
@@ -4306,6 +4306,20 @@
   { "xstore", 0, 0xfa7, 0xc0, Cpu686|CpuPadLock,
     No_bSuf|No_wSuf|No_lSuf|No_sSuf|No_qSuf|No_xSuf|IsString|ImmExt,
     { 0 } },
+  // Native client support instructions.
+  { "nacland", 2, 0x81, 0x4, 0,
+    D|W|Modrm|No_sSuf|No_xSuf,
+    { Imm32, Reg32 }},
+  { "naclor", 2, 0x81, 0x1, 0,
+    D|W|Modrm|No_sSuf|No_xSuf,
+    { Imm32, Reg32 }},
+  { "naclcall", 1, 0xff, 0x2, 0,
+    Modrm|DefaultSize|No_bSuf|No_lSuf|No_qSuf|No_sSuf|No_xSuf,
+    { Reg32 }},
+  { "nacljmp", 1, 0xff, 0x4, 0,
+    Modrm|DefaultSize|No_bSuf|No_lSuf|No_qSuf|No_sSuf|No_xSuf,
+    { Reg32 }},
+
   { NULL, 0, 0, 0, 0, 0, { 0 } }
 };
 
