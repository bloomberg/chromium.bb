==== (added) binutils-2.19.91.20091006/binutils/arlex.c ====
--- /dev/null	2009-05-01 06:17:58.000000000 +0200
+++ binutils-2.19.91.20091006/binutils/arlex.c	2009-10-07 07:56:54.000000000 +0200
@@ -0,0 +1,2072 @@
+
+#line 3 "arlex.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart(yyin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#define YY_BUF_SIZE 16384
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int yyleng;
+
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart (FILE *input_file  );
+void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
+void yy_delete_buffer (YY_BUFFER_STATE b  );
+void yy_flush_buffer (YY_BUFFER_STATE b  );
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state (void );
+
+static void yyensure_buffer_stack (void );
+static void yy_load_buffer_state (void );
+static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
+
+void *yyalloc (yy_size_t  );
+void *yyrealloc (void *,yy_size_t  );
+void yyfree (void *  );
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+typedef unsigned char YY_CHAR;
+
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int yylineno;
+
+int yylineno = 1;
+
+extern char *yytext;
+#define yytext_ptr yytext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	yyleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 40
+#define YY_END_OF_BUFFER 41
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[177] =
+    {   0,
+        0,    0,   41,   40,   39,   38,   35,   32,   33,   36,
+       40,   34,   37,   35,   35,   35,   35,   35,   35,   35,
+       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
+       35,   35,   35,   35,   35,   35,   36,   31,   37,   35,
+       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
+       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
+       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
+       35,   35,    7,   35,   35,   35,   35,   35,   35,   35,
+       35,   35,   35,   35,   35,   35,   22,   35,   35,   35,
+       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
+
+       35,   35,   35,   10,   11,   12,   35,   15,   35,   35,
+       35,   35,   35,   35,   35,   35,   35,   25,   26,   27,
+       35,   30,   35,   35,   35,    3,   35,   35,   35,   35,
+       35,   35,   35,   35,   35,   18,   35,   35,   35,   35,
+       35,   35,   35,    1,    2,    4,    5,   35,   35,   35,
+       35,   35,   16,   17,   19,   20,   35,   35,   35,   35,
+       35,   35,    8,    9,   13,   14,   35,   23,   24,   28,
+       29,   35,   35,    6,   21,    0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    3,    1,    1,    1,    4,    1,    1,    1,    5,
+        6,    7,    8,    9,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,   10,    1,
+        1,    1,    1,    1,   11,   12,   13,   14,   15,   16,
+        4,   17,   18,    4,    4,   19,   20,   21,   22,   23,
+        4,   24,   25,   26,   27,   28,    4,   29,   30,    4,
+        1,    4,    1,    1,    4,    1,   31,   32,   33,   34,
+
+       35,   36,    4,   37,   38,    4,    4,   39,   40,   41,
+       42,   43,    4,   44,   45,   46,   47,   48,    4,   49,
+       50,    4,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[51] =
+    {   0,
+        1,    2,    1,    3,    1,    1,    1,    1,    1,    1,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3
+    } ;
+
+static yyconst flex_int16_t yy_base[180] =
+    {   0,
+        0,    0,  193,  194,  194,  194,    0,  194,  194,    0,
+      190,  194,    0,  177,   32,   37,   32,  163,  174,  170,
+      164,  171,  174,  169,  149,   15,   22,   17,  135,  146,
+      142,  136,  143,  146,  141,    0,    0,  194,    0,  161,
+      159,  158,  153,  147,  156,  143,  149,  148,  141,  150,
+      141,  135,  138,  127,  125,  124,  119,  113,  122,  109,
+      115,  114,  107,  116,  107,  101,  104,   43,  136,  135,
+      130,  129,    0,  119,  123,  118,  114,  118,  119,  122,
+      124,   25,  104,  103,   98,   97,    0,   87,   91,   86,
+       82,   86,   87,   90,   92,  105,  100,   97,   94,   93,
+
+      105,  106,  102,    0,    0,    0,  104,    0,   92,   75,
+       70,   67,   64,   63,   75,   76,   72,    0,    0,    0,
+       74,    0,   62,   91,   88,    0,   86,   85,   73,   85,
+       79,   83,   70,   62,   59,    0,   57,   56,   44,   56,
+       50,   54,   41,    0,    0,    0,    0,   63,   58,   59,
+       67,   66,    0,    0,    0,    0,   38,   33,   34,   42,
+       41,   51,    0,    0,    0,    0,   30,    0,    0,    0,
+        0,   43,   21,    0,    0,  194,   65,   66,   69
+    } ;
+
+static yyconst flex_int16_t yy_def[180] =
+    {   0,
+      176,    1,  176,  176,  176,  176,  177,  176,  176,  178,
+      176,  176,  179,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,  177,  178,  176,  179,  177,
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,  177,  177,  177,  177,  177,
+      177,  177,  177,  177,  177,    0,  176,  176,  176
+    } ;
+
+static yyconst flex_int16_t yy_nxt[245] =
+    {   0,
+        4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
+       14,    7,   15,   16,   17,   18,   19,    7,   20,    7,
+        7,   21,    7,   22,   23,    7,    7,   24,    7,    7,
+       25,    7,   26,   27,   28,   29,   30,    7,   31,    7,
+        7,   32,    7,   33,   34,    7,    7,   35,    7,    7,
+       41,   43,   45,   55,   44,   42,   57,   59,   56,   58,
+       46,   96,   97,  110,  111,   60,   37,   36,   37,   39,
+      175,   39,  174,  173,  172,  171,  170,  169,  168,  167,
+      166,  165,  164,  163,  162,  161,  160,  159,  158,  157,
+      156,  155,  154,  153,  152,  151,  150,  149,  148,  147,
+
+      146,  145,  144,  143,  142,  141,  140,  139,  138,  137,
+      136,  135,  134,  133,  132,  131,  130,  129,  128,  127,
+      126,  125,  124,  123,  122,  121,  120,  119,  118,  117,
+      116,  115,  114,  113,  112,  109,  108,  107,  106,  105,
+      104,  103,  102,  101,  100,   99,   98,   95,   94,   93,
+       92,   91,   90,   89,   88,   87,   86,   85,   84,   83,
+       82,   81,   80,   79,   78,   77,   76,   75,   74,   73,
+       72,   71,   70,   69,   68,   67,   66,   65,   64,   63,
+       62,   61,   54,   53,   52,   51,   50,   49,   48,   47,
+       40,   38,  176,    3,  176,  176,  176,  176,  176,  176,
+
+      176,  176,  176,  176,  176,  176,  176,  176,  176,  176,
+      176,  176,  176,  176,  176,  176,  176,  176,  176,  176,
+      176,  176,  176,  176,  176,  176,  176,  176,  176,  176,
+      176,  176,  176,  176,  176,  176,  176,  176,  176,  176,
+      176,  176,  176,  176
+    } ;
+
+static yyconst flex_int16_t yy_chk[245] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+       15,   16,   17,   26,   16,   15,   27,   28,   26,   27,
+       17,   68,   68,   82,   82,   28,  178,  177,  178,  179,
+      173,  179,  172,  167,  162,  161,  160,  159,  158,  157,
+      152,  151,  150,  149,  148,  143,  142,  141,  140,  139,
+      138,  137,  135,  134,  133,  132,  131,  130,  129,  128,
+
+      127,  125,  124,  123,  121,  117,  116,  115,  114,  113,
+      112,  111,  110,  109,  107,  103,  102,  101,  100,   99,
+       98,   97,   96,   95,   94,   93,   92,   91,   90,   89,
+       88,   86,   85,   84,   83,   81,   80,   79,   78,   77,
+       76,   75,   74,   72,   71,   70,   69,   67,   66,   65,
+       64,   63,   62,   61,   60,   59,   58,   57,   56,   55,
+       54,   53,   52,   51,   50,   49,   48,   47,   46,   45,
+       44,   43,   42,   41,   40,   35,   34,   33,   32,   31,
+       30,   29,   25,   24,   23,   22,   21,   20,   19,   18,
+       14,   11,    3,  176,  176,  176,  176,  176,  176,  176,
+
+      176,  176,  176,  176,  176,  176,  176,  176,  176,  176,
+      176,  176,  176,  176,  176,  176,  176,  176,  176,  176,
+      176,  176,  176,  176,  176,  176,  176,  176,  176,  176,
+      176,  176,  176,  176,  176,  176,  176,  176,  176,  176,
+      176,  176,  176,  176
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int yy_flex_debug;
+int yy_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "arlex.l"
+#line 2 "arlex.l"
+/* arlex.l - Strange script language lexer */
+
+/* Copyright 1992, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2007
+   Free Software Foundation, Inc.
+
+   This file is part of GNU Binutils.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+
+/* Contributed by Steve Chamberlain <sac@cygnus.com>.  */
+
+#define DONTDECLARE_MALLOC
+#include "ansidecl.h"
+#include "libiberty.h"
+#include "arparse.h"
+
+#define YY_NO_UNPUT
+
+extern int yylex (void);
+
+int linenumber;
+#line 595 "arlex.c"
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy (void );
+
+int yyget_debug (void );
+
+void yyset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE yyget_extra (void );
+
+void yyset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *yyget_in (void );
+
+void yyset_in  (FILE * in_str  );
+
+FILE *yyget_out (void );
+
+void yyset_out  (FILE * out_str  );
+
+int yyget_leng (void );
+
+char *yyget_text (void );
+
+int yyget_lineno (void );
+
+void yyset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap (void );
+#else
+extern int yywrap (void );
+#endif
+#endif
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO fwrite( yytext, yyleng, 1, yyout )
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		int n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 42 "arlex.l"
+
+
+#line 780 "arlex.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer(yyin,YY_BUF_SIZE );
+		}
+
+		yy_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of yytext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 177 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 194 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 44 "arlex.l"
+{ return ADDLIB; }
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 45 "arlex.l"
+{ return ADDMOD; }
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 46 "arlex.l"
+{ return CLEAR; }
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 47 "arlex.l"
+{ return CREATE; }
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 48 "arlex.l"
+{ return DELETE; }
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 49 "arlex.l"
+{ return DIRECTORY; }
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 50 "arlex.l"
+{ return END; }
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 51 "arlex.l"
+{ return EXTRACT; }
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 52 "arlex.l"
+{ return FULLDIR; }
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 53 "arlex.l"
+{ return HELP; }
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 54 "arlex.l"
+{ return LIST; }
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 55 "arlex.l"
+{ return OPEN; }
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 56 "arlex.l"
+{ return REPLACE; }
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 57 "arlex.l"
+{ return VERBOSE; }
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 58 "arlex.l"
+{ return SAVE; }
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 59 "arlex.l"
+{ return ADDLIB; }
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 60 "arlex.l"
+{ return ADDMOD; }
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 61 "arlex.l"
+{ return CLEAR; }
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 62 "arlex.l"
+{ return CREATE; }
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 63 "arlex.l"
+{ return DELETE; }
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+#line 64 "arlex.l"
+{ return DIRECTORY; }
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+#line 65 "arlex.l"
+{ return END; }
+	YY_BREAK
+case 23:
+YY_RULE_SETUP
+#line 66 "arlex.l"
+{ return EXTRACT; }
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+#line 67 "arlex.l"
+{ return FULLDIR; }
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+#line 68 "arlex.l"
+{ return HELP; }
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+#line 69 "arlex.l"
+{ return LIST; }
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+#line 70 "arlex.l"
+{ return OPEN; }
+	YY_BREAK
+case 28:
+YY_RULE_SETUP
+#line 71 "arlex.l"
+{ return REPLACE; }
+	YY_BREAK
+case 29:
+YY_RULE_SETUP
+#line 72 "arlex.l"
+{ return VERBOSE; }
+	YY_BREAK
+case 30:
+YY_RULE_SETUP
+#line 73 "arlex.l"
+{ return SAVE; }
+	YY_BREAK
+case 31:
+/* rule 31 can match eol */
+YY_RULE_SETUP
+#line 74 "arlex.l"
+{ linenumber ++; }
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+#line 75 "arlex.l"
+{ return '('; }
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+#line 76 "arlex.l"
+{ return ')'; }
+	YY_BREAK
+case 34:
+YY_RULE_SETUP
+#line 77 "arlex.l"
+{ return ','; }
+	YY_BREAK
+case 35:
+YY_RULE_SETUP
+#line 78 "arlex.l"
+{ 	
+		yylval.name =  xstrdup (yytext);
+		return FILENAME;
+		}
+	YY_BREAK
+case 36:
+YY_RULE_SETUP
+#line 82 "arlex.l"
+{ }
+	YY_BREAK
+case 37:
+YY_RULE_SETUP
+#line 83 "arlex.l"
+{ }
+	YY_BREAK
+case 38:
+YY_RULE_SETUP
+#line 84 "arlex.l"
+{ }
+	YY_BREAK
+case 39:
+/* rule 39 can match eol */
+YY_RULE_SETUP
+#line 85 "arlex.l"
+{ linenumber ++; return NEWLINE; }	
+	YY_BREAK
+case 40:
+YY_RULE_SETUP
+#line 87 "arlex.l"
+ECHO;
+	YY_BREAK
+#line 1068 "arlex.c"
+case YY_STATE_EOF(INITIAL):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( yywrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of yylex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart(yyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 177 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 177 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 176);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up yytext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart(yyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void yyrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer(yyin,YY_BUF_SIZE );
+	}
+
+	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
+	yy_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void yy_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * 
+ */
+    void yy_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yyfree((void *) b->yy_ch_buf  );
+
+	yyfree((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	yy_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void yypop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void yyensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
+{
+    
+	return yy_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) yyalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
+{
+        
+    return yylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int yyget_leng  (void)
+{
+        return yyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *yyget_text  (void)
+{
+        return yytext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void yyset_lineno (int  line_number )
+{
+    
+    yylineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  in_str )
+{
+        yyin = in_str ;
+}
+
+void yyset_out (FILE *  out_str )
+{
+        yyout = out_str ;
+}
+
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
+
+void yyset_debug (int  bdebug )
+{
+        yy_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = (FILE *) 0;
+    yyout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *yyalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *yyrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void yyfree (void * ptr )
+{
+	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 87 "arlex.l"
+
+
+#ifndef yywrap
+/* Needed for lex, though not flex. */
+int yywrap(void) { return 1; }
+#endif
+
==== (added) binutils-2.19.91.20091006/binutils/arparse.c ====
--- /dev/null	2009-05-01 06:17:58.000000000 +0200
+++ binutils-2.19.91.20091006/binutils/arparse.c	2009-10-07 07:56:53.000000000 +0200
@@ -0,0 +1,1825 @@
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.4.1"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+
+
+/* Copy the first part of user declarations.  */
+
+/* Line 189 of yacc.c  */
+#line 1 "arparse.y"
+
+/* arparse.y - Stange script language parser */
+
+/* Copyright 1992, 1993, 1995, 1997, 1999, 2002, 2003, 2005, 2007
+   Free Software Foundation, Inc.
+
+   This file is part of GNU Binutils.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+
+/* Contributed by Steve Chamberlain
+   		  sac@cygnus.com
+
+*/
+#define DONTDECLARE_MALLOC
+#include "sysdep.h"
+#include "bfd.h"
+#include "arsup.h"
+extern int verbose;
+extern int yylex (void);
+static int yyerror (const char *);
+
+
+/* Line 189 of yacc.c  */
+#line 111 "arparse.c"
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     NEWLINE = 258,
+     VERBOSE = 259,
+     FILENAME = 260,
+     ADDLIB = 261,
+     LIST = 262,
+     ADDMOD = 263,
+     CLEAR = 264,
+     CREATE = 265,
+     DELETE = 266,
+     DIRECTORY = 267,
+     END = 268,
+     EXTRACT = 269,
+     FULLDIR = 270,
+     HELP = 271,
+     QUIT = 272,
+     REPLACE = 273,
+     SAVE = 274,
+     OPEN = 275
+   };
+#endif
+/* Tokens.  */
+#define NEWLINE 258
+#define VERBOSE 259
+#define FILENAME 260
+#define ADDLIB 261
+#define LIST 262
+#define ADDMOD 263
+#define CLEAR 264
+#define CREATE 265
+#define DELETE 266
+#define DIRECTORY 267
+#define END 268
+#define EXTRACT 269
+#define FULLDIR 270
+#define HELP 271
+#define QUIT 272
+#define REPLACE 273
+#define SAVE 274
+#define OPEN 275
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 214 of yacc.c  */
+#line 38 "arparse.y"
+
+  char *name;
+struct list *list ;
+
+
+
+
+/* Line 214 of yacc.c  */
+#line 195 "arparse.c"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 264 of yacc.c  */
+#line 207 "arparse.c"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
+{
+  return yyi;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  3
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   34
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  24
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  22
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  42
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  53
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   275
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+      21,    22,     2,     2,    23,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint8 yyprhs[] =
+{
+       0,     0,     3,     4,     7,    10,    11,    14,    16,    18,
+      20,    22,    24,    26,    28,    30,    32,    34,    36,    38,
+      40,    42,    44,    45,    48,    51,    53,    56,    59,    61,
+      63,    66,    69,    73,    78,    80,    81,    85,    86,    90,
+      91,    93,    94
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      25,     0,    -1,    -1,    26,    27,    -1,    27,    28,    -1,
+      -1,    29,     3,    -1,    37,    -1,    38,    -1,    45,    -1,
+      40,    -1,    39,    -1,    32,    -1,    34,    -1,    36,    -1,
+      30,    -1,    31,    -1,    33,    -1,    35,    -1,    13,    -1,
+       1,    -1,     5,    -1,    -1,    14,    43,    -1,    18,    43,
+      -1,     9,    -1,    11,    43,    -1,     8,    43,    -1,     7,
+      -1,    19,    -1,    20,     5,    -1,    10,     5,    -1,     6,
+       5,    42,    -1,    12,     5,    42,    41,    -1,     5,    -1,
+      -1,    21,    43,    22,    -1,    -1,    43,    44,     5,    -1,
+      -1,    23,    -1,    -1,     4,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint8 yyrline[] =
+{
+       0,    69,    69,    69,    73,    74,    78,    82,    83,    84,
+      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,
+      95,    96,    97,   102,   107,   112,   117,   121,   126,   131,
+     138,   143,   149,   153,   160,   162,   166,   169,   173,   179,
+     184,   185,   190
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "NEWLINE", "VERBOSE", "FILENAME",
+  "ADDLIB", "LIST", "ADDMOD", "CLEAR", "CREATE", "DELETE", "DIRECTORY",
+  "END", "EXTRACT", "FULLDIR", "HELP", "QUIT", "REPLACE", "SAVE", "OPEN",
+  "'('", "')'", "','", "$accept", "start", "$@1", "session",
+  "command_line", "command", "extract_command", "replace_command",
+  "clear_command", "delete_command", "addmod_command", "list_command",
+  "save_command", "open_command", "create_command", "addlib_command",
+  "directory_command", "optional_filename", "modulelist", "modulename",
+  "optcomma", "verbose_command", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,    40,    41,    44
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    24,    26,    25,    27,    27,    28,    29,    29,    29,
+      29,    29,    29,    29,    29,    29,    29,    29,    29,    29,
+      29,    29,    29,    30,    31,    32,    33,    34,    35,    36,
+      37,    38,    39,    40,    41,    41,    42,    42,    43,    43,
+      44,    44,    45
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     0,     2,     2,     0,     2,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     0,     2,     2,     1,     2,     2,     1,     1,
+       2,     2,     3,     4,     1,     0,     3,     0,     3,     0,
+       1,     0,     1
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       2,     0,     5,     1,     0,    20,    42,    21,     0,    28,
+      39,    25,     0,    39,     0,    19,    39,    39,    29,     0,
+       4,     0,    15,    16,    12,    17,    13,    18,    14,     7,
+       8,    11,    10,     9,    37,    27,    31,    26,    37,    23,
+      24,    30,     6,    39,    32,    40,     0,    35,    41,    38,
+      34,    33,    36
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
+{
+      -1,     1,     2,     4,    20,    21,    22,    23,    24,    25,
+      26,    27,    28,    29,    30,    31,    32,    51,    44,    35,
+      46,    33
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -14
+static const yytype_int8 yypact[] =
+{
+     -14,     1,   -14,   -14,     5,   -14,   -14,   -14,     2,   -14,
+     -14,   -14,    21,   -14,    22,   -14,   -14,   -14,   -14,    23,
+     -14,    26,   -14,   -14,   -14,   -14,   -14,   -14,   -14,   -14,
+     -14,   -14,   -14,   -14,    10,    -3,   -14,    -3,    10,    -3,
+      -3,   -14,   -14,   -14,   -14,   -14,    27,    28,    -1,   -14,
+     -14,   -14,   -14
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+     -14,   -14,   -14,   -14,   -14,   -14,   -14,   -14,   -14,   -14,
+     -14,   -14,   -14,   -14,   -14,   -14,   -14,   -14,    -4,   -13,
+     -14,   -14
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -42
+static const yytype_int8 yytable[] =
+{
+      37,     3,   -41,    39,    40,    -3,     5,    34,   -22,     6,
+       7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
+      45,    52,    45,    17,    18,    19,    36,    38,    41,    42,
+      48,    43,    49,    50,    47
+};
+
+static const yytype_uint8 yycheck[] =
+{
+      13,     0,     5,    16,    17,     0,     1,     5,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      23,    22,    23,    18,    19,    20,     5,     5,     5,     3,
+      43,    21,     5,     5,    38
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,    25,    26,     0,    27,     1,     4,     5,     6,     7,
+       8,     9,    10,    11,    12,    13,    14,    18,    19,    20,
+      28,    29,    30,    31,    32,    33,    34,    35,    36,    37,
+      38,    39,    40,    45,     5,    43,     5,    43,     5,    43,
+      43,     5,     3,    21,    42,    23,    44,    42,    43,     5,
+       5,    41,    22
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+#else
+static void
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+
+      default:
+	break;
+    }
+}
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*-------------------------.
+| yyparse or yypush_parse.  |
+`-------------------------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+
+
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 2:
+
+/* Line 1455 of yacc.c  */
+#line 69 "arparse.y"
+    { prompt(); }
+    break;
+
+  case 6:
+
+/* Line 1455 of yacc.c  */
+#line 78 "arparse.y"
+    { prompt(); }
+    break;
+
+  case 19:
+
+/* Line 1455 of yacc.c  */
+#line 94 "arparse.y"
+    { ar_end(); return 0; }
+    break;
+
+  case 21:
+
+/* Line 1455 of yacc.c  */
+#line 96 "arparse.y"
+    { yyerror("foo"); }
+    break;
+
+  case 23:
+
+/* Line 1455 of yacc.c  */
+#line 103 "arparse.y"
+    { ar_extract((yyvsp[(2) - (2)].list)); }
+    break;
+
+  case 24:
+
+/* Line 1455 of yacc.c  */
+#line 108 "arparse.y"
+    { ar_replace((yyvsp[(2) - (2)].list)); }
+    break;
+
+  case 25:
+
+/* Line 1455 of yacc.c  */
+#line 113 "arparse.y"
+    { ar_clear(); }
+    break;
+
+  case 26:
+
+/* Line 1455 of yacc.c  */
+#line 118 "arparse.y"
+    { ar_delete((yyvsp[(2) - (2)].list)); }
+    break;
+
+  case 27:
+
+/* Line 1455 of yacc.c  */
+#line 122 "arparse.y"
+    { ar_addmod((yyvsp[(2) - (2)].list)); }
+    break;
+
+  case 28:
+
+/* Line 1455 of yacc.c  */
+#line 127 "arparse.y"
+    { ar_list(); }
+    break;
+
+  case 29:
+
+/* Line 1455 of yacc.c  */
+#line 132 "arparse.y"
+    { ar_save(); }
+    break;
+
+  case 30:
+
+/* Line 1455 of yacc.c  */
+#line 139 "arparse.y"
+    { ar_open((yyvsp[(2) - (2)].name),0); }
+    break;
+
+  case 31:
+
+/* Line 1455 of yacc.c  */
+#line 144 "arparse.y"
+    { ar_open((yyvsp[(2) - (2)].name),1); }
+    break;
+
+  case 32:
+
+/* Line 1455 of yacc.c  */
+#line 150 "arparse.y"
+    { ar_addlib((yyvsp[(2) - (3)].name),(yyvsp[(3) - (3)].list)); }
+    break;
+
+  case 33:
+
+/* Line 1455 of yacc.c  */
+#line 154 "arparse.y"
+    { ar_directory((yyvsp[(2) - (4)].name), (yyvsp[(3) - (4)].list), (yyvsp[(4) - (4)].name)); }
+    break;
+
+  case 34:
+
+/* Line 1455 of yacc.c  */
+#line 161 "arparse.y"
+    { (yyval.name) = (yyvsp[(1) - (1)].name); }
+    break;
+
+  case 35:
+
+/* Line 1455 of yacc.c  */
+#line 162 "arparse.y"
+    { (yyval.name) = 0; }
+    break;
+
+  case 36:
+
+/* Line 1455 of yacc.c  */
+#line 167 "arparse.y"
+    { (yyval.list) = (yyvsp[(2) - (3)].list); }
+    break;
+
+  case 37:
+
+/* Line 1455 of yacc.c  */
+#line 169 "arparse.y"
+    { (yyval.list) = 0; }
+    break;
+
+  case 38:
+
+/* Line 1455 of yacc.c  */
+#line 174 "arparse.y"
+    { 	struct list *n  = (struct list *) malloc(sizeof(struct list));
+			n->next = (yyvsp[(1) - (3)].list); 
+			n->name = (yyvsp[(3) - (3)].name);
+			(yyval.list) = n;
+		 }
+    break;
+
+  case 39:
+
+/* Line 1455 of yacc.c  */
+#line 179 "arparse.y"
+    { (yyval.list) = 0; }
+    break;
+
+  case 42:
+
+/* Line 1455 of yacc.c  */
+#line 191 "arparse.y"
+    { verbose = !verbose; }
+    break;
+
+
+
+/* Line 1455 of yacc.c  */
+#line 1603 "arparse.c"
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined(yyoverflow) || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+
+/* Line 1675 of yacc.c  */
+#line 195 "arparse.y"
+
+
+static int
+yyerror (const char *x ATTRIBUTE_UNUSED)
+{
+  extern int linenumber;
+
+  printf (_("Syntax error in archive script, line %d\n"), linenumber + 1);
+  return 0;
+}
+
==== (added) binutils-2.19.91.20091006/binutils/arparse.h ====
--- /dev/null	2009-05-01 06:17:58.000000000 +0200
+++ binutils-2.19.91.20091006/binutils/arparse.h	2009-10-07 07:56:53.000000000 +0200
@@ -0,0 +1,108 @@
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
+
+/* Skeleton interface for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     NEWLINE = 258,
+     VERBOSE = 259,
+     FILENAME = 260,
+     ADDLIB = 261,
+     LIST = 262,
+     ADDMOD = 263,
+     CLEAR = 264,
+     CREATE = 265,
+     DELETE = 266,
+     DIRECTORY = 267,
+     END = 268,
+     EXTRACT = 269,
+     FULLDIR = 270,
+     HELP = 271,
+     QUIT = 272,
+     REPLACE = 273,
+     SAVE = 274,
+     OPEN = 275
+   };
+#endif
+/* Tokens.  */
+#define NEWLINE 258
+#define VERBOSE 259
+#define FILENAME 260
+#define ADDLIB 261
+#define LIST 262
+#define ADDMOD 263
+#define CLEAR 264
+#define CREATE 265
+#define DELETE 266
+#define DIRECTORY 267
+#define END 268
+#define EXTRACT 269
+#define FULLDIR 270
+#define HELP 271
+#define QUIT 272
+#define REPLACE 273
+#define SAVE 274
+#define OPEN 275
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 1676 of yacc.c  */
+#line 38 "arparse.y"
+
+  char *name;
+struct list *list ;
+
+
+
+
+/* Line 1676 of yacc.c  */
+#line 100 "arparse.h"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+extern YYSTYPE yylval;
+
+
==== (added) binutils-2.19.91.20091006/binutils/defparse.c ====
--- /dev/null	2009-05-01 06:17:58.000000000 +0200
+++ binutils-2.19.91.20091006/binutils/defparse.c	2009-10-07 08:18:04.000000000 +0200
@@ -0,0 +1,2044 @@
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.4.1"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+
+
+/* Copy the first part of user declarations.  */
+
+/* Line 189 of yacc.c  */
+#line 1 "defparse.y"
+ /* defparse.y - parser for .def files */
+
+/* Copyright 1995, 1997, 1998, 1999, 2001, 2004, 2005, 2007
+   Free Software Foundation, Inc.
+   
+   This file is part of GNU Binutils.
+   
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libiberty.h"
+#include "dlltool.h"
+
+
+/* Line 189 of yacc.c  */
+#line 102 "defparse.c"
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     NAME = 258,
+     LIBRARY = 259,
+     DESCRIPTION = 260,
+     STACKSIZE = 261,
+     HEAPSIZE = 262,
+     CODE = 263,
+     DATA = 264,
+     SECTIONS = 265,
+     EXPORTS = 266,
+     IMPORTS = 267,
+     VERSIONK = 268,
+     BASE = 269,
+     CONSTANT = 270,
+     READ = 271,
+     WRITE = 272,
+     EXECUTE = 273,
+     SHARED = 274,
+     NONSHARED = 275,
+     NONAME = 276,
+     PRIVATE = 277,
+     SINGLE = 278,
+     MULTIPLE = 279,
+     INITINSTANCE = 280,
+     INITGLOBAL = 281,
+     TERMINSTANCE = 282,
+     TERMGLOBAL = 283,
+     ID = 284,
+     NUMBER = 285
+   };
+#endif
+/* Tokens.  */
+#define NAME 258
+#define LIBRARY 259
+#define DESCRIPTION 260
+#define STACKSIZE 261
+#define HEAPSIZE 262
+#define CODE 263
+#define DATA 264
+#define SECTIONS 265
+#define EXPORTS 266
+#define IMPORTS 267
+#define VERSIONK 268
+#define BASE 269
+#define CONSTANT 270
+#define READ 271
+#define WRITE 272
+#define EXECUTE 273
+#define SHARED 274
+#define NONSHARED 275
+#define NONAME 276
+#define PRIVATE 277
+#define SINGLE 278
+#define MULTIPLE 279
+#define INITINSTANCE 280
+#define INITGLOBAL 281
+#define TERMINSTANCE 282
+#define TERMGLOBAL 283
+#define ID 284
+#define NUMBER 285
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 214 of yacc.c  */
+#line 29 "defparse.y"
+
+  char *id;
+  int number;
+
+
+
+/* Line 214 of yacc.c  */
+#line 205 "defparse.c"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 264 of yacc.c  */
+#line 217 "defparse.c"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
+{
+  return yyi;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  38
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   114
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  35
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  23
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  68
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  98
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   285
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,    33,     2,    31,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,    32,     2,     2,    34,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint8 yyprhs[] =
+{
+       0,     0,     3,     6,     8,    12,    17,    20,    23,    27,
+      31,    34,    37,    40,    43,    46,    51,    52,    55,    63,
+      66,    68,    76,    84,    90,    96,   102,   108,   112,   116,
+     119,   121,   124,   128,   130,   132,   133,   136,   137,   139,
+     141,   143,   145,   147,   149,   151,   153,   154,   156,   157,
+     159,   160,   162,   163,   165,   169,   170,   173,   174,   177,
+     182,   183,   187,   188,   189,   193,   195,   197,   199
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      36,     0,    -1,    36,    37,    -1,    37,    -1,     3,    52,
+      55,    -1,     4,    52,    55,    56,    -1,    11,    38,    -1,
+       5,    29,    -1,     6,    30,    46,    -1,     7,    30,    46,
+      -1,     8,    44,    -1,     9,    44,    -1,    10,    42,    -1,
+      12,    40,    -1,    13,    30,    -1,    13,    30,    31,    30,
+      -1,    -1,    38,    39,    -1,    29,    54,    53,    49,    48,
+      50,    51,    -1,    40,    41,    -1,    41,    -1,    29,    32,
+      29,    31,    29,    31,    29,    -1,    29,    32,    29,    31,
+      29,    31,    30,    -1,    29,    32,    29,    31,    29,    -1,
+      29,    32,    29,    31,    30,    -1,    29,    31,    29,    31,
+      29,    -1,    29,    31,    29,    31,    30,    -1,    29,    31,
+      29,    -1,    29,    31,    30,    -1,    42,    43,    -1,    43,
+      -1,    29,    44,    -1,    44,    45,    47,    -1,    47,    -1,
+      33,    -1,    -1,    33,    30,    -1,    -1,    16,    -1,    17,
+      -1,    18,    -1,    19,    -1,    20,    -1,    23,    -1,    24,
+      -1,    15,    -1,    -1,    21,    -1,    -1,     9,    -1,    -1,
+      22,    -1,    -1,    29,    -1,    29,    31,    29,    -1,    -1,
+      34,    30,    -1,    -1,    32,    29,    -1,    32,    29,    31,
+      29,    -1,    -1,    14,    32,    30,    -1,    -1,    -1,    56,
+      45,    57,    -1,    25,    -1,    26,    -1,    27,    -1,    28,
+      -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint8 yyrline[] =
+{
+       0,    46,    46,    47,    51,    52,    53,    54,    55,    56,
+      57,    58,    59,    60,    61,    62,    66,    68,    72,    76,
+      77,    81,    82,    83,    84,    85,    86,    87,    88,    92,
+      93,    97,   101,   102,   106,   107,   109,   110,   114,   115,
+     116,   117,   118,   119,   120,   124,   125,   129,   130,   134,
+     135,   139,   140,   143,   144,   150,   154,   155,   159,   160,
+     166,   169,   170,   173,   175,   179,   180,   181,   182
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "NAME", "LIBRARY", "DESCRIPTION",
+  "STACKSIZE", "HEAPSIZE", "CODE", "DATA", "SECTIONS", "EXPORTS",
+  "IMPORTS", "VERSIONK", "BASE", "CONSTANT", "READ", "WRITE", "EXECUTE",
+  "SHARED", "NONSHARED", "NONAME", "PRIVATE", "SINGLE", "MULTIPLE",
+  "INITINSTANCE", "INITGLOBAL", "TERMINSTANCE", "TERMGLOBAL", "ID",
+  "NUMBER", "'.'", "'='", "','", "'@'", "$accept", "start", "command",
+  "explist", "expline", "implist", "impline", "seclist", "secline",
+  "attr_list", "opt_comma", "opt_number", "attr", "opt_CONSTANT",
+  "opt_NONAME", "opt_DATA", "opt_PRIVATE", "opt_name", "opt_ordinal",
+  "opt_equal_name", "opt_base", "option_list", "option", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,    46,    61,    44,    64
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    35,    36,    36,    37,    37,    37,    37,    37,    37,
+      37,    37,    37,    37,    37,    37,    38,    38,    39,    40,
+      40,    41,    41,    41,    41,    41,    41,    41,    41,    42,
+      42,    43,    44,    44,    45,    45,    46,    46,    47,    47,
+      47,    47,    47,    47,    47,    48,    48,    49,    49,    50,
+      50,    51,    51,    52,    52,    52,    53,    53,    54,    54,
+      54,    55,    55,    56,    56,    57,    57,    57,    57
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     2,     1,     3,     4,     2,     2,     3,     3,
+       2,     2,     2,     2,     2,     4,     0,     2,     7,     2,
+       1,     7,     7,     5,     5,     5,     5,     3,     3,     2,
+       1,     2,     3,     1,     1,     0,     2,     0,     1,     1,
+       1,     1,     1,     1,     1,     1,     0,     1,     0,     1,
+       0,     1,     0,     1,     3,     0,     2,     0,     2,     4,
+       0,     3,     0,     0,     3,     1,     1,     1,     1
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       0,    55,    55,     0,     0,     0,     0,     0,     0,    16,
+       0,     0,     0,     3,    53,    62,    62,     7,    37,    37,
+      38,    39,    40,    41,    42,    43,    44,    10,    33,    11,
+       0,    12,    30,     6,     0,    13,    20,    14,     1,     2,
+       0,     0,     4,    63,     0,     8,     9,    34,     0,    31,
+      29,    60,    17,     0,     0,    19,     0,    54,     0,     5,
+      36,    32,     0,    57,    27,    28,     0,    15,    61,     0,
+      58,     0,    48,     0,     0,    65,    66,    67,    68,    64,
+       0,    56,    47,    46,    25,    26,    23,    24,    59,    45,
+      50,     0,    49,    52,    21,    22,    51,    18
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
+{
+      -1,    12,    13,    33,    52,    35,    36,    31,    32,    27,
+      48,    45,    28,    90,    83,    93,    97,    15,    72,    63,
+      42,    59,    79
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -26
+static const yytype_int8 yypact[] =
+{
+      32,   -12,   -12,    17,    -8,    33,    -4,    -4,    35,   -26,
+      36,    37,    21,   -26,    38,    48,    48,   -26,    39,    39,
+     -26,   -26,   -26,   -26,   -26,   -26,   -26,   -15,   -26,   -15,
+      -4,    35,   -26,    41,   -25,    36,   -26,    40,   -26,   -26,
+      44,    34,   -26,   -26,    45,   -26,   -26,   -26,    -4,   -15,
+     -26,    42,   -26,   -19,    47,   -26,    49,   -26,    50,    22,
+     -26,   -26,    52,    43,    51,   -26,    53,   -26,   -26,    26,
+      54,    56,    57,    27,    29,   -26,   -26,   -26,   -26,   -26,
+      58,   -26,   -26,    68,   -26,   -26,    59,   -26,   -26,   -26,
+      79,    31,   -26,    46,   -26,   -26,   -26,   -26
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+     -26,   -26,    77,   -26,   -26,   -26,    60,   -26,    61,    -7,
+      55,    72,    62,   -26,   -26,   -26,   -26,    91,   -26,   -26,
+      78,   -26,   -26
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -36
+static const yytype_int8 yytable[] =
+{
+      29,   -35,   -35,   -35,   -35,   -35,    53,    54,   -35,   -35,
+      64,    65,    20,    21,    22,    23,    24,    14,    47,    25,
+      26,    38,    18,    49,     1,     2,     3,     4,     5,     6,
+       7,     8,     9,    10,    11,     1,     2,     3,     4,     5,
+       6,     7,     8,     9,    10,    11,    17,   -35,   -35,   -35,
+     -35,    75,    76,    77,    78,    47,    84,    85,    86,    87,
+      94,    95,    41,    19,    30,    34,    58,    37,    96,    40,
+      51,    56,    44,    57,    62,    60,    66,    71,    82,    67,
+      68,    70,    73,    89,    74,    80,    81,    88,    92,    39,
+      91,    46,    50,    16,    43,    55,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+      61,     0,     0,     0,    69
+};
+
+static const yytype_int8 yycheck[] =
+{
+       7,    16,    17,    18,    19,    20,    31,    32,    23,    24,
+      29,    30,    16,    17,    18,    19,    20,    29,    33,    23,
+      24,     0,    30,    30,     3,     4,     5,     6,     7,     8,
+       9,    10,    11,    12,    13,     3,     4,     5,     6,     7,
+       8,     9,    10,    11,    12,    13,    29,    25,    26,    27,
+      28,    25,    26,    27,    28,    33,    29,    30,    29,    30,
+      29,    30,    14,    30,    29,    29,    32,    30,    22,    31,
+      29,    31,    33,    29,    32,    30,    29,    34,    21,    30,
+      30,    29,    31,    15,    31,    31,    30,    29,     9,    12,
+      31,    19,    31,     2,    16,    35,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      48,    -1,    -1,    -1,    59
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,     3,     4,     5,     6,     7,     8,     9,    10,    11,
+      12,    13,    36,    37,    29,    52,    52,    29,    30,    30,
+      16,    17,    18,    19,    20,    23,    24,    44,    47,    44,
+      29,    42,    43,    38,    29,    40,    41,    30,     0,    37,
+      31,    14,    55,    55,    33,    46,    46,    33,    45,    44,
+      43,    29,    39,    31,    32,    41,    31,    29,    32,    56,
+      30,    47,    32,    54,    29,    30,    29,    30,    30,    45,
+      29,    34,    53,    31,    31,    25,    26,    27,    28,    57,
+      31,    30,    21,    49,    29,    30,    29,    30,    29,    15,
+      48,    31,     9,    50,    29,    30,    22,    51
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+#else
+static void
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+
+      default:
+	break;
+    }
+}
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*-------------------------.
+| yyparse or yypush_parse.  |
+`-------------------------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+
+
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 4:
+
+/* Line 1455 of yacc.c  */
+#line 51 "defparse.y"
+    { def_name ((yyvsp[(2) - (3)].id), (yyvsp[(3) - (3)].number)); }
+    break;
+
+  case 5:
+
+/* Line 1455 of yacc.c  */
+#line 52 "defparse.y"
+    { def_library ((yyvsp[(2) - (4)].id), (yyvsp[(3) - (4)].number)); }
+    break;
+
+  case 7:
+
+/* Line 1455 of yacc.c  */
+#line 54 "defparse.y"
+    { def_description ((yyvsp[(2) - (2)].id));}
+    break;
+
+  case 8:
+
+/* Line 1455 of yacc.c  */
+#line 55 "defparse.y"
+    { def_stacksize ((yyvsp[(2) - (3)].number), (yyvsp[(3) - (3)].number));}
+    break;
+
+  case 9:
+
+/* Line 1455 of yacc.c  */
+#line 56 "defparse.y"
+    { def_heapsize ((yyvsp[(2) - (3)].number), (yyvsp[(3) - (3)].number));}
+    break;
+
+  case 10:
+
+/* Line 1455 of yacc.c  */
+#line 57 "defparse.y"
+    { def_code ((yyvsp[(2) - (2)].number));}
+    break;
+
+  case 11:
+
+/* Line 1455 of yacc.c  */
+#line 58 "defparse.y"
+    { def_data ((yyvsp[(2) - (2)].number));}
+    break;
+
+  case 14:
+
+/* Line 1455 of yacc.c  */
+#line 61 "defparse.y"
+    { def_version ((yyvsp[(2) - (2)].number),0);}
+    break;
+
+  case 15:
+
+/* Line 1455 of yacc.c  */
+#line 62 "defparse.y"
+    { def_version ((yyvsp[(2) - (4)].number),(yyvsp[(4) - (4)].number));}
+    break;
+
+  case 18:
+
+/* Line 1455 of yacc.c  */
+#line 73 "defparse.y"
+    { def_exports ((yyvsp[(1) - (7)].id), (yyvsp[(2) - (7)].id), (yyvsp[(3) - (7)].number), (yyvsp[(4) - (7)].number), (yyvsp[(5) - (7)].number), (yyvsp[(6) - (7)].number), (yyvsp[(7) - (7)].number));}
+    break;
+
+  case 21:
+
+/* Line 1455 of yacc.c  */
+#line 81 "defparse.y"
+    { def_import ((yyvsp[(1) - (7)].id),(yyvsp[(3) - (7)].id),(yyvsp[(5) - (7)].id),(yyvsp[(7) - (7)].id), 0); }
+    break;
+
+  case 22:
+
+/* Line 1455 of yacc.c  */
+#line 82 "defparse.y"
+    { def_import ((yyvsp[(1) - (7)].id),(yyvsp[(3) - (7)].id),(yyvsp[(5) - (7)].id), 0,(yyvsp[(7) - (7)].number)); }
+    break;
+
+  case 23:
+
+/* Line 1455 of yacc.c  */
+#line 83 "defparse.y"
+    { def_import ((yyvsp[(1) - (5)].id),(yyvsp[(3) - (5)].id), 0,(yyvsp[(5) - (5)].id), 0); }
+    break;
+
+  case 24:
+
+/* Line 1455 of yacc.c  */
+#line 84 "defparse.y"
+    { def_import ((yyvsp[(1) - (5)].id),(yyvsp[(3) - (5)].id), 0, 0,(yyvsp[(5) - (5)].number)); }
+    break;
+
+  case 25:
+
+/* Line 1455 of yacc.c  */
+#line 85 "defparse.y"
+    { def_import ( 0,(yyvsp[(1) - (5)].id),(yyvsp[(3) - (5)].id),(yyvsp[(5) - (5)].id), 0); }
+    break;
+
+  case 26:
+
+/* Line 1455 of yacc.c  */
+#line 86 "defparse.y"
+    { def_import ( 0,(yyvsp[(1) - (5)].id),(yyvsp[(3) - (5)].id), 0,(yyvsp[(5) - (5)].number)); }
+    break;
+
+  case 27:
+
+/* Line 1455 of yacc.c  */
+#line 87 "defparse.y"
+    { def_import ( 0,(yyvsp[(1) - (3)].id), 0,(yyvsp[(3) - (3)].id), 0); }
+    break;
+
+  case 28:
+
+/* Line 1455 of yacc.c  */
+#line 88 "defparse.y"
+    { def_import ( 0,(yyvsp[(1) - (3)].id), 0, 0,(yyvsp[(3) - (3)].number)); }
+    break;
+
+  case 31:
+
+/* Line 1455 of yacc.c  */
+#line 97 "defparse.y"
+    { def_section ((yyvsp[(1) - (2)].id),(yyvsp[(2) - (2)].number));}
+    break;
+
+  case 36:
+
+/* Line 1455 of yacc.c  */
+#line 109 "defparse.y"
+    { (yyval.number)=(yyvsp[(2) - (2)].number);}
+    break;
+
+  case 37:
+
+/* Line 1455 of yacc.c  */
+#line 110 "defparse.y"
+    { (yyval.number)=-1;}
+    break;
+
+  case 38:
+
+/* Line 1455 of yacc.c  */
+#line 114 "defparse.y"
+    { (yyval.number) = 1; }
+    break;
+
+  case 39:
+
+/* Line 1455 of yacc.c  */
+#line 115 "defparse.y"
+    { (yyval.number) = 2; }
+    break;
+
+  case 40:
+
+/* Line 1455 of yacc.c  */
+#line 116 "defparse.y"
+    { (yyval.number) = 4; }
+    break;
+
+  case 41:
+
+/* Line 1455 of yacc.c  */
+#line 117 "defparse.y"
+    { (yyval.number) = 8; }
+    break;
+
+  case 42:
+
+/* Line 1455 of yacc.c  */
+#line 118 "defparse.y"
+    { (yyval.number) = 0; }
+    break;
+
+  case 43:
+
+/* Line 1455 of yacc.c  */
+#line 119 "defparse.y"
+    { (yyval.number) = 0; }
+    break;
+
+  case 44:
+
+/* Line 1455 of yacc.c  */
+#line 120 "defparse.y"
+    { (yyval.number) = 0; }
+    break;
+
+  case 45:
+
+/* Line 1455 of yacc.c  */
+#line 124 "defparse.y"
+    {(yyval.number)=1;}
+    break;
+
+  case 46:
+
+/* Line 1455 of yacc.c  */
+#line 125 "defparse.y"
+    {(yyval.number)=0;}
+    break;
+
+  case 47:
+
+/* Line 1455 of yacc.c  */
+#line 129 "defparse.y"
+    {(yyval.number)=1;}
+    break;
+
+  case 48:
+
+/* Line 1455 of yacc.c  */
+#line 130 "defparse.y"
+    {(yyval.number)=0;}
+    break;
+
+  case 49:
+
+/* Line 1455 of yacc.c  */
+#line 134 "defparse.y"
+    { (yyval.number) = 1; }
+    break;
+
+  case 50:
+
+/* Line 1455 of yacc.c  */
+#line 135 "defparse.y"
+    { (yyval.number) = 0; }
+    break;
+
+  case 51:
+
+/* Line 1455 of yacc.c  */
+#line 139 "defparse.y"
+    { (yyval.number) = 1; }
+    break;
+
+  case 52:
+
+/* Line 1455 of yacc.c  */
+#line 140 "defparse.y"
+    { (yyval.number) = 0; }
+    break;
+
+  case 53:
+
+/* Line 1455 of yacc.c  */
+#line 143 "defparse.y"
+    { (yyval.id) =(yyvsp[(1) - (1)].id); }
+    break;
+
+  case 54:
+
+/* Line 1455 of yacc.c  */
+#line 145 "defparse.y"
+    { 
+	    char *name = xmalloc (strlen ((yyvsp[(1) - (3)].id)) + 1 + strlen ((yyvsp[(3) - (3)].id)) + 1);
+	    sprintf (name, "%s.%s", (yyvsp[(1) - (3)].id), (yyvsp[(3) - (3)].id));
+	    (yyval.id) = name;
+	  }
+    break;
+
+  case 55:
+
+/* Line 1455 of yacc.c  */
+#line 150 "defparse.y"
+    { (yyval.id)=""; }
+    break;
+
+  case 56:
+
+/* Line 1455 of yacc.c  */
+#line 154 "defparse.y"
+    { (yyval.number)=(yyvsp[(2) - (2)].number);}
+    break;
+
+  case 57:
+
+/* Line 1455 of yacc.c  */
+#line 155 "defparse.y"
+    { (yyval.number)=-1;}
+    break;
+
+  case 58:
+
+/* Line 1455 of yacc.c  */
+#line 159 "defparse.y"
+    { (yyval.id) = (yyvsp[(2) - (2)].id); }
+    break;
+
+  case 59:
+
+/* Line 1455 of yacc.c  */
+#line 161 "defparse.y"
+    { 
+	    char *name = xmalloc (strlen ((yyvsp[(2) - (4)].id)) + 1 + strlen ((yyvsp[(4) - (4)].id)) + 1);
+	    sprintf (name, "%s.%s", (yyvsp[(2) - (4)].id), (yyvsp[(4) - (4)].id));
+	    (yyval.id) = name;
+	  }
+    break;
+
+  case 60:
+
+/* Line 1455 of yacc.c  */
+#line 166 "defparse.y"
+    { (yyval.id) =  0; }
+    break;
+
+  case 61:
+
+/* Line 1455 of yacc.c  */
+#line 169 "defparse.y"
+    { (yyval.number)= (yyvsp[(3) - (3)].number);}
+    break;
+
+  case 62:
+
+/* Line 1455 of yacc.c  */
+#line 170 "defparse.y"
+    { (yyval.number)=-1;}
+    break;
+
+
+
+/* Line 1455 of yacc.c  */
+#line 1835 "defparse.c"
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined(yyoverflow) || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+
==== (added) binutils-2.19.91.20091006/binutils/defparse.h ====
--- /dev/null	2009-05-01 06:17:58.000000000 +0200
+++ binutils-2.19.91.20091006/binutils/defparse.h	2009-10-07 08:18:04.000000000 +0200
@@ -0,0 +1,127 @@
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
+
+/* Skeleton interface for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     NAME = 258,
+     LIBRARY = 259,
+     DESCRIPTION = 260,
+     STACKSIZE = 261,
+     HEAPSIZE = 262,
+     CODE = 263,
+     DATA = 264,
+     SECTIONS = 265,
+     EXPORTS = 266,
+     IMPORTS = 267,
+     VERSIONK = 268,
+     BASE = 269,
+     CONSTANT = 270,
+     READ = 271,
+     WRITE = 272,
+     EXECUTE = 273,
+     SHARED = 274,
+     NONSHARED = 275,
+     NONAME = 276,
+     PRIVATE = 277,
+     SINGLE = 278,
+     MULTIPLE = 279,
+     INITINSTANCE = 280,
+     INITGLOBAL = 281,
+     TERMINSTANCE = 282,
+     TERMGLOBAL = 283,
+     ID = 284,
+     NUMBER = 285
+   };
+#endif
+/* Tokens.  */
+#define NAME 258
+#define LIBRARY 259
+#define DESCRIPTION 260
+#define STACKSIZE 261
+#define HEAPSIZE 262
+#define CODE 263
+#define DATA 264
+#define SECTIONS 265
+#define EXPORTS 266
+#define IMPORTS 267
+#define VERSIONK 268
+#define BASE 269
+#define CONSTANT 270
+#define READ 271
+#define WRITE 272
+#define EXECUTE 273
+#define SHARED 274
+#define NONSHARED 275
+#define NONAME 276
+#define PRIVATE 277
+#define SINGLE 278
+#define MULTIPLE 279
+#define INITINSTANCE 280
+#define INITGLOBAL 281
+#define TERMINSTANCE 282
+#define TERMGLOBAL 283
+#define ID 284
+#define NUMBER 285
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 1676 of yacc.c  */
+#line 29 "defparse.y"
+
+  char *id;
+  int number;
+
+
+
+/* Line 1676 of yacc.c  */
+#line 119 "defparse.h"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+extern YYSTYPE yylval;
+
+
==== (added) binutils-2.19.91.20091006/binutils/mcparse.c ====
--- /dev/null	2009-05-01 06:17:58.000000000 +0200
+++ binutils-2.19.91.20091006/binutils/mcparse.c	2009-10-07 08:18:05.000000000 +0200
@@ -0,0 +1,2295 @@
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.4.1"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+
+
+/* Copy the first part of user declarations.  */
+
+/* Line 189 of yacc.c  */
+#line 1 "mcparse.y"
+ /* mcparse.y -- parser for Windows mc files
+  Copyright 2007
+  Free Software Foundation, Inc.
+  
+  Parser for Windows mc files
+  Written by Kai Tietz, Onevision.
+  
+  This file is part of GNU Binutils.
+  
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 3 of the License, or
+  (at your option) any later version.
+  
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+  
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+  02110-1301, USA.  */
+
+/* This is a parser for Windows rc files.  It is based on the parser
+   by Gunther Ebert <gunther.ebert@ixos-leipzig.de>.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "bucomm.h"
+#include "libiberty.h"
+#include "windmc.h"
+#include "safe-ctype.h"
+
+static rc_uint_type mc_last_id = 0;
+static rc_uint_type mc_sefa_val = 0;
+static unichar *mc_last_symbol = NULL;
+static const mc_keyword *mc_cur_severity = NULL;
+static const mc_keyword *mc_cur_facility = NULL;
+static mc_node *cur_node = NULL;
+
+
+
+/* Line 189 of yacc.c  */
+#line 117 "mcparse.c"
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     NL = 258,
+     MCIDENT = 259,
+     MCFILENAME = 260,
+     MCLINE = 261,
+     MCCOMMENT = 262,
+     MCTOKEN = 263,
+     MCENDLINE = 264,
+     MCLANGUAGENAMES = 265,
+     MCFACILITYNAMES = 266,
+     MCSEVERITYNAMES = 267,
+     MCOUTPUTBASE = 268,
+     MCMESSAGEIDTYPEDEF = 269,
+     MCLANGUAGE = 270,
+     MCMESSAGEID = 271,
+     MCSEVERITY = 272,
+     MCFACILITY = 273,
+     MCSYMBOLICNAME = 274,
+     MCNUMBER = 275
+   };
+#endif
+/* Tokens.  */
+#define NL 258
+#define MCIDENT 259
+#define MCFILENAME 260
+#define MCLINE 261
+#define MCCOMMENT 262
+#define MCTOKEN 263
+#define MCENDLINE 264
+#define MCLANGUAGENAMES 265
+#define MCFACILITYNAMES 266
+#define MCSEVERITYNAMES 267
+#define MCOUTPUTBASE 268
+#define MCMESSAGEIDTYPEDEF 269
+#define MCLANGUAGE 270
+#define MCMESSAGEID 271
+#define MCSEVERITY 272
+#define MCFACILITY 273
+#define MCSYMBOLICNAME 274
+#define MCNUMBER 275
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 214 of yacc.c  */
+#line 45 "mcparse.y"
+
+  rc_uint_type ival;
+  unichar *ustr;
+  const mc_keyword *tok;
+  mc_node *nod;
+
+
+
+/* Line 214 of yacc.c  */
+#line 202 "mcparse.c"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 264 of yacc.c  */
+#line 214 "mcparse.c"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
+{
+  return yyi;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  3
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   114
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  26
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  29
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  82
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  125
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   275
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+      22,    23,     2,    25,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,    24,     2,
+       2,    21,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint16 yyprhs[] =
+{
+       0,     0,     3,     5,     6,     9,    11,    13,    15,    17,
+      23,    29,    33,    36,    42,    48,    52,    55,    61,    67,
+      71,    74,    78,    82,    86,    89,    91,    94,    96,   101,
+     105,   108,   110,   113,   115,   120,   124,   127,   129,   132,
+     134,   141,   148,   153,   157,   160,   161,   164,   167,   168,
+     173,   177,   181,   184,   185,   187,   190,   193,   194,   197,
+     200,   203,   207,   211,   215,   217,   220,   225,   227,   230,
+     232,   235,   237,   240,   246,   252,   258,   263,   266,   268,
+     270,   271,   272
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      27,     0,    -1,    28,    -1,    -1,    28,    29,    -1,    30,
+      -1,    38,    -1,    49,    -1,     1,    -1,    12,    21,    22,
+      31,    23,    -1,    12,    21,    22,    31,     1,    -1,    12,
+      21,     1,    -1,    12,     1,    -1,    10,    21,    22,    35,
+      23,    -1,    10,    21,    22,    35,     1,    -1,    10,    21,
+       1,    -1,    10,     1,    -1,    11,    21,    22,    33,    23,
+      -1,    11,    21,    22,    33,     1,    -1,    11,    21,     1,
+      -1,    11,     1,    -1,    13,    21,    20,    -1,    14,    21,
+       4,    -1,    14,    21,     1,    -1,    14,     1,    -1,    32,
+      -1,    31,    32,    -1,     1,    -1,    51,    21,    20,    37,
+      -1,    51,    21,     1,    -1,    51,     1,    -1,    34,    -1,
+      33,    34,    -1,     1,    -1,    51,    21,    20,    37,    -1,
+      51,    21,     1,    -1,    51,     1,    -1,    36,    -1,    35,
+      36,    -1,     1,    -1,    51,    21,    20,    54,    24,     5,
+      -1,    51,    21,    20,    54,    24,     1,    -1,    51,    21,
+      20,     1,    -1,    51,    21,     1,    -1,    51,     1,    -1,
+      -1,    24,     4,    -1,    24,     1,    -1,    -1,    40,    42,
+      39,    46,    -1,    16,    21,    41,    -1,    16,    21,     1,
+      -1,    16,     1,    -1,    -1,    20,    -1,    25,    20,    -1,
+      25,     1,    -1,    -1,    42,    43,    -1,    42,    44,    -1,
+      42,    45,    -1,    17,    21,     8,    -1,    18,    21,     8,
+      -1,    19,    21,     4,    -1,    47,    -1,    46,    47,    -1,
+      50,    53,    48,     9,    -1,     6,    -1,    48,     6,    -1,
+       1,    -1,    48,     1,    -1,     7,    -1,    49,     7,    -1,
+      15,    52,    21,     8,     3,    -1,    15,    52,    21,     4,
+       3,    -1,    15,    52,    21,    51,     1,    -1,    15,    52,
+      21,     1,    -1,    15,     1,    -1,     4,    -1,     8,    -1,
+      -1,    -1,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,    67,    67,    70,    72,    74,    75,    76,    81,    85,
+      86,    87,    88,    89,    90,    91,    92,    93,    94,    95,
+      96,    97,   103,   107,   111,   118,   119,   120,   124,   128,
+     129,   133,   134,   135,   139,   143,   144,   148,   149,   150,
+     154,   158,   159,   160,   161,   166,   169,   173,   178,   177,
+     190,   191,   192,   196,   199,   203,   207,   212,   219,   225,
+     231,   239,   247,   255,   262,   263,   267,   277,   281,   293,
+     294,   297,   298,   312,   316,   321,   326,   331,   338,   339,
+     343,   347,   351
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "NL", "MCIDENT", "MCFILENAME", "MCLINE",
+  "MCCOMMENT", "MCTOKEN", "MCENDLINE", "MCLANGUAGENAMES",
+  "MCFACILITYNAMES", "MCSEVERITYNAMES", "MCOUTPUTBASE",
+  "MCMESSAGEIDTYPEDEF", "MCLANGUAGE", "MCMESSAGEID", "MCSEVERITY",
+  "MCFACILITY", "MCSYMBOLICNAME", "MCNUMBER", "'='", "'('", "')'", "':'",
+  "'+'", "$accept", "input", "entities", "entity", "global_section",
+  "severitymaps", "severitymap", "facilitymaps", "facilitymap", "langmaps",
+  "langmap", "alias_name", "message", "$@1", "id", "vid", "sefasy_def",
+  "severity", "facility", "symbol", "lang_entities", "lang_entity",
+  "lines", "comments", "lang", "token", "lex_want_nl", "lex_want_line",
+  "lex_want_filename", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,    61,    40,    41,    58,    43
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    26,    27,    28,    28,    29,    29,    29,    29,    30,
+      30,    30,    30,    30,    30,    30,    30,    30,    30,    30,
+      30,    30,    30,    30,    30,    31,    31,    31,    32,    32,
+      32,    33,    33,    33,    34,    34,    34,    35,    35,    35,
+      36,    36,    36,    36,    36,    37,    37,    37,    39,    38,
+      40,    40,    40,    41,    41,    41,    41,    42,    42,    42,
+      42,    43,    44,    45,    46,    46,    47,    48,    48,    48,
+      48,    49,    49,    50,    50,    50,    50,    50,    51,    51,
+      52,    53,    54
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     1,     0,     2,     1,     1,     1,     1,     5,
+       5,     3,     2,     5,     5,     3,     2,     5,     5,     3,
+       2,     3,     3,     3,     2,     1,     2,     1,     4,     3,
+       2,     1,     2,     1,     4,     3,     2,     1,     2,     1,
+       6,     6,     4,     3,     2,     0,     2,     2,     0,     4,
+       3,     3,     2,     0,     1,     2,     2,     0,     2,     2,
+       2,     3,     3,     3,     1,     2,     4,     1,     2,     1,
+       2,     1,     2,     5,     5,     5,     4,     2,     1,     1,
+       0,     0,     0
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       3,     0,     0,     1,     8,    71,     0,     0,     0,     0,
+       0,     0,     4,     5,     6,    57,     7,    16,     0,    20,
+       0,    12,     0,     0,    24,     0,    52,     0,    48,    72,
+      15,     0,    19,     0,    11,     0,    21,    23,    22,    51,
+      54,     0,    50,     0,     0,     0,     0,    58,    59,    60,
+      39,    78,    79,     0,    37,     0,    33,     0,    31,     0,
+      27,     0,    25,     0,    56,    55,     0,     0,     0,     0,
+      49,    64,    81,    14,    13,    38,    44,     0,    18,    17,
+      32,    36,     0,    10,     9,    26,    30,     0,    61,    62,
+      63,    77,     0,    65,     0,    43,     0,    35,    45,    29,
+      45,     0,    69,    67,     0,    42,     0,     0,    34,    28,
+      76,    78,    79,     0,    70,    68,    66,     0,    47,    46,
+      74,    73,    75,    41,    40
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
+{
+      -1,     1,     2,    12,    13,    61,    62,    57,    58,    53,
+      54,   108,    14,    46,    15,    42,    28,    47,    48,    49,
+      70,    71,   104,    16,    72,    55,    92,    94,   106
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -34
+static const yytype_int8 yypact[] =
+{
+     -34,    62,    70,   -34,   -34,   -34,    15,    22,    30,   -15,
+      34,    37,   -34,   -34,   -34,   -34,    56,   -34,    10,   -34,
+      12,   -34,    20,    25,   -34,    52,   -34,     0,    80,   -34,
+     -34,    71,   -34,    84,   -34,    86,   -34,   -34,   -34,   -34,
+     -34,    45,   -34,     1,    68,    74,    76,   -34,   -34,   -34,
+     -34,   -34,   -34,     4,   -34,    38,   -34,     6,   -34,    39,
+     -34,    29,   -34,    40,   -34,   -34,    93,    94,    99,    43,
+      76,   -34,   -34,   -34,   -34,   -34,   -34,    46,   -34,   -34,
+     -34,   -34,    47,   -34,   -34,   -34,   -34,    49,   -34,   -34,
+     -34,   -34,    83,   -34,     3,   -34,     2,   -34,    81,   -34,
+      81,    92,   -34,   -34,    48,   -34,    82,    72,   -34,   -34,
+     -34,   104,   105,   108,   -34,   -34,   -34,    73,   -34,   -34,
+     -34,   -34,   -34,   -34,   -34
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+     -34,   -34,   -34,   -34,   -34,   -34,    50,   -34,    53,   -34,
+      59,    13,   -34,   -34,   -34,   -34,   -34,   -34,   -34,   -34,
+     -34,    44,   -34,   -34,   -34,   -33,   -34,   -34,   -34
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -83
+static const yytype_int8 yytable[] =
+{
+      59,    39,    63,   105,   102,    73,    23,    78,    51,   103,
+      51,    30,    52,    32,    52,   -53,    17,   -53,   -53,   -53,
+      40,    34,    66,    19,    59,    41,   -82,    74,    63,    79,
+      83,    21,    31,    51,    33,    24,    18,    52,    26,    76,
+      81,    86,    35,    20,    91,    36,    64,    95,    97,   114,
+      99,    22,    84,    37,   115,    25,    38,   116,    27,    77,
+      82,    87,     3,    29,   -80,    65,    96,    98,   113,   100,
+      -2,     4,    50,   118,   123,    51,   119,     5,   124,    52,
+       6,     7,     8,     9,    10,    56,    11,    60,    51,    67,
+      51,    69,    52,   110,    52,    68,   111,    43,    44,    45,
+     112,    88,    89,    90,   101,   107,   117,   120,   121,   122,
+      80,    85,    75,   109,    93
+};
+
+static const yytype_uint8 yycheck[] =
+{
+      33,     1,    35,     1,     1,     1,    21,     1,     4,     6,
+       4,     1,     8,     1,     8,    15,     1,    17,    18,    19,
+      20,     1,    21,     1,    57,    25,    24,    23,    61,    23,
+       1,     1,    22,     4,    22,     1,    21,     8,     1,     1,
+       1,     1,    22,    21,     1,    20,     1,     1,     1,     1,
+       1,    21,    23,     1,     6,    21,     4,     9,    21,    21,
+      21,    21,     0,     7,    21,    20,    20,    20,   101,    20,
+       0,     1,     1,     1,     1,     4,     4,     7,     5,     8,
+      10,    11,    12,    13,    14,     1,    16,     1,     4,    21,
+       4,    15,     8,     1,     8,    21,     4,    17,    18,    19,
+       8,     8,     8,     4,    21,    24,    24,     3,     3,     1,
+      57,    61,    53,   100,    70
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,    27,    28,     0,     1,     7,    10,    11,    12,    13,
+      14,    16,    29,    30,    38,    40,    49,     1,    21,     1,
+      21,     1,    21,    21,     1,    21,     1,    21,    42,     7,
+       1,    22,     1,    22,     1,    22,    20,     1,     4,     1,
+      20,    25,    41,    17,    18,    19,    39,    43,    44,    45,
+       1,     4,     8,    35,    36,    51,     1,    33,    34,    51,
+       1,    31,    32,    51,     1,    20,    21,    21,    21,    15,
+      46,    47,    50,     1,    23,    36,     1,    21,     1,    23,
+      34,     1,    21,     1,    23,    32,     1,    21,     8,     8,
+       4,     1,    52,    47,    53,     1,    20,     1,    20,     1,
+      20,    21,     1,     6,    48,     1,    54,    24,    37,    37,
+       1,     4,     8,    51,     1,     6,     9,    24,     1,     4,
+       3,     3,     1,     1,     5
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+#else
+static void
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+
+      default:
+	break;
+    }
+}
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*-------------------------.
+| yyparse or yypush_parse.  |
+`-------------------------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+
+
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 7:
+
+/* Line 1455 of yacc.c  */
+#line 77 "mcparse.y"
+    {
+	    cur_node = mc_add_node ();
+	    cur_node->user_text = (yyvsp[(1) - (1)].ustr);
+	  }
+    break;
+
+  case 8:
+
+/* Line 1455 of yacc.c  */
+#line 81 "mcparse.y"
+    { mc_fatal ("syntax error"); }
+    break;
+
+  case 10:
+
+/* Line 1455 of yacc.c  */
+#line 86 "mcparse.y"
+    { mc_fatal ("missing ')' in SeverityNames"); }
+    break;
+
+  case 11:
+
+/* Line 1455 of yacc.c  */
+#line 87 "mcparse.y"
+    { mc_fatal ("missing '(' in SeverityNames"); }
+    break;
+
+  case 12:
+
+/* Line 1455 of yacc.c  */
+#line 88 "mcparse.y"
+    { mc_fatal ("missing '=' for SeverityNames"); }
+    break;
+
+  case 14:
+
+/* Line 1455 of yacc.c  */
+#line 90 "mcparse.y"
+    { mc_fatal ("missing ')' in LanguageNames"); }
+    break;
+
+  case 15:
+
+/* Line 1455 of yacc.c  */
+#line 91 "mcparse.y"
+    { mc_fatal ("missing '(' in LanguageNames"); }
+    break;
+
+  case 16:
+
+/* Line 1455 of yacc.c  */
+#line 92 "mcparse.y"
+    { mc_fatal ("missing '=' for LanguageNames"); }
+    break;
+
+  case 18:
+
+/* Line 1455 of yacc.c  */
+#line 94 "mcparse.y"
+    { mc_fatal ("missing ')' in FacilityNames"); }
+    break;
+
+  case 19:
+
+/* Line 1455 of yacc.c  */
+#line 95 "mcparse.y"
+    { mc_fatal ("missing '(' in FacilityNames"); }
+    break;
+
+  case 20:
+
+/* Line 1455 of yacc.c  */
+#line 96 "mcparse.y"
+    { mc_fatal ("missing '=' for FacilityNames"); }
+    break;
+
+  case 21:
+
+/* Line 1455 of yacc.c  */
+#line 98 "mcparse.y"
+    {
+	    if ((yyvsp[(3) - (3)].ival) != 10 && (yyvsp[(3) - (3)].ival) != 16)
+	      mc_fatal ("OutputBase allows 10 or 16 as value");
+	    mcset_out_values_are_decimal = ((yyvsp[(3) - (3)].ival) == 10 ? 1 : 0);
+	  }
+    break;
+
+  case 22:
+
+/* Line 1455 of yacc.c  */
+#line 104 "mcparse.y"
+    {
+	    mcset_msg_id_typedef = (yyvsp[(3) - (3)].ustr);
+	  }
+    break;
+
+  case 23:
+
+/* Line 1455 of yacc.c  */
+#line 108 "mcparse.y"
+    {
+	    mc_fatal ("MessageIdTypedef expects an identifier");
+	  }
+    break;
+
+  case 24:
+
+/* Line 1455 of yacc.c  */
+#line 112 "mcparse.y"
+    {
+	    mc_fatal ("missing '=' for MessageIdTypedef");
+	  }
+    break;
+
+  case 27:
+
+/* Line 1455 of yacc.c  */
+#line 120 "mcparse.y"
+    { mc_fatal ("severity ident missing"); }
+    break;
+
+  case 28:
+
+/* Line 1455 of yacc.c  */
+#line 125 "mcparse.y"
+    {
+	    mc_add_keyword ((yyvsp[(1) - (4)].ustr), MCTOKEN, "severity", (yyvsp[(3) - (4)].ival), (yyvsp[(4) - (4)].ustr));
+	  }
+    break;
+
+  case 29:
+
+/* Line 1455 of yacc.c  */
+#line 128 "mcparse.y"
+    { mc_fatal ("severity number missing"); }
+    break;
+
+  case 30:
+
+/* Line 1455 of yacc.c  */
+#line 129 "mcparse.y"
+    { mc_fatal ("severity missing '='"); }
+    break;
+
+  case 33:
+
+/* Line 1455 of yacc.c  */
+#line 135 "mcparse.y"
+    { mc_fatal ("missing ident in FacilityNames"); }
+    break;
+
+  case 34:
+
+/* Line 1455 of yacc.c  */
+#line 140 "mcparse.y"
+    {
+	    mc_add_keyword ((yyvsp[(1) - (4)].ustr), MCTOKEN, "facility", (yyvsp[(3) - (4)].ival), (yyvsp[(4) - (4)].ustr));
+	  }
+    break;
+
+  case 35:
+
+/* Line 1455 of yacc.c  */
+#line 143 "mcparse.y"
+    { mc_fatal ("facility number missing"); }
+    break;
+
+  case 36:
+
+/* Line 1455 of yacc.c  */
+#line 144 "mcparse.y"
+    { mc_fatal ("facility missing '='"); }
+    break;
+
+  case 39:
+
+/* Line 1455 of yacc.c  */
+#line 150 "mcparse.y"
+    { mc_fatal ("missing ident in LanguageNames"); }
+    break;
+
+  case 40:
+
+/* Line 1455 of yacc.c  */
+#line 155 "mcparse.y"
+    {
+	    mc_add_keyword ((yyvsp[(1) - (6)].ustr), MCTOKEN, "language", (yyvsp[(3) - (6)].ival), (yyvsp[(6) - (6)].ustr));
+	  }
+    break;
+
+  case 41:
+
+/* Line 1455 of yacc.c  */
+#line 158 "mcparse.y"
+    { mc_fatal ("missing filename in LanguageNames"); }
+    break;
+
+  case 42:
+
+/* Line 1455 of yacc.c  */
+#line 159 "mcparse.y"
+    { mc_fatal ("missing ':' in LanguageNames"); }
+    break;
+
+  case 43:
+
+/* Line 1455 of yacc.c  */
+#line 160 "mcparse.y"
+    { mc_fatal ("missing language code in LanguageNames"); }
+    break;
+
+  case 44:
+
+/* Line 1455 of yacc.c  */
+#line 161 "mcparse.y"
+    { mc_fatal ("missing '=' for LanguageNames"); }
+    break;
+
+  case 45:
+
+/* Line 1455 of yacc.c  */
+#line 166 "mcparse.y"
+    {
+	    (yyval.ustr) = NULL;
+	  }
+    break;
+
+  case 46:
+
+/* Line 1455 of yacc.c  */
+#line 170 "mcparse.y"
+    {
+	    (yyval.ustr) = (yyvsp[(2) - (2)].ustr);
+	  }
+    break;
+
+  case 47:
+
+/* Line 1455 of yacc.c  */
+#line 173 "mcparse.y"
+    { mc_fatal ("illegal token in identifier"); (yyval.ustr) = NULL; }
+    break;
+
+  case 48:
+
+/* Line 1455 of yacc.c  */
+#line 178 "mcparse.y"
+    {
+	    cur_node = mc_add_node ();
+	    cur_node->symbol = mc_last_symbol;
+	    cur_node->facility = mc_cur_facility;
+	    cur_node->severity = mc_cur_severity;
+	    cur_node->id = ((yyvsp[(1) - (2)].ival) & 0xffffUL);
+	    cur_node->vid = ((yyvsp[(1) - (2)].ival) & 0xffffUL) | mc_sefa_val;
+	    mc_last_id = (yyvsp[(1) - (2)].ival);
+	  }
+    break;
+
+  case 50:
+
+/* Line 1455 of yacc.c  */
+#line 190 "mcparse.y"
+    { (yyval.ival) = (yyvsp[(3) - (3)].ival); }
+    break;
+
+  case 51:
+
+/* Line 1455 of yacc.c  */
+#line 191 "mcparse.y"
+    { mc_fatal ("missing number in MessageId"); (yyval.ival) = 0; }
+    break;
+
+  case 52:
+
+/* Line 1455 of yacc.c  */
+#line 192 "mcparse.y"
+    { mc_fatal ("missing '=' for MessageId"); (yyval.ival) = 0; }
+    break;
+
+  case 53:
+
+/* Line 1455 of yacc.c  */
+#line 196 "mcparse.y"
+    {
+	    (yyval.ival) = ++mc_last_id;
+	  }
+    break;
+
+  case 54:
+
+/* Line 1455 of yacc.c  */
+#line 200 "mcparse.y"
+    {
+	    (yyval.ival) = (yyvsp[(1) - (1)].ival);
+	  }
+    break;
+
+  case 55:
+
+/* Line 1455 of yacc.c  */
+#line 204 "mcparse.y"
+    {
+	    (yyval.ival) = mc_last_id + (yyvsp[(2) - (2)].ival);
+	  }
+    break;
+
+  case 56:
+
+/* Line 1455 of yacc.c  */
+#line 207 "mcparse.y"
+    { mc_fatal ("missing number after MessageId '+'"); }
+    break;
+
+  case 57:
+
+/* Line 1455 of yacc.c  */
+#line 212 "mcparse.y"
+    {
+	    (yyval.ival) = 0;
+	    mc_sefa_val = (mcset_custom_bit ? 1 : 0) << 29;
+	    mc_last_symbol = NULL;
+	    mc_cur_severity = NULL;
+	    mc_cur_facility = NULL;
+	  }
+    break;
+
+  case 58:
+
+/* Line 1455 of yacc.c  */
+#line 220 "mcparse.y"
+    {
+	    if ((yyvsp[(1) - (2)].ival) & 1)
+	      mc_warn (_("duplicate definition of Severity"));
+	    (yyval.ival) = (yyvsp[(1) - (2)].ival) | 1;
+	  }
+    break;
+
+  case 59:
+
+/* Line 1455 of yacc.c  */
+#line 226 "mcparse.y"
+    {
+	    if ((yyvsp[(1) - (2)].ival) & 2)
+	      mc_warn (_("duplicate definition of Facility"));
+	    (yyval.ival) = (yyvsp[(1) - (2)].ival) | 2;
+	  }
+    break;
+
+  case 60:
+
+/* Line 1455 of yacc.c  */
+#line 232 "mcparse.y"
+    {
+	    if ((yyvsp[(1) - (2)].ival) & 4)
+	      mc_warn (_("duplicate definition of SymbolicName"));
+	    (yyval.ival) = (yyvsp[(1) - (2)].ival) | 4;
+	  }
+    break;
+
+  case 61:
+
+/* Line 1455 of yacc.c  */
+#line 240 "mcparse.y"
+    {
+	    mc_sefa_val &= ~ (0x3UL << 30);
+	    mc_sefa_val |= (((yyvsp[(3) - (3)].tok)->nval & 0x3UL) << 30);
+	    mc_cur_severity = (yyvsp[(3) - (3)].tok);
+	  }
+    break;
+
+  case 62:
+
+/* Line 1455 of yacc.c  */
+#line 248 "mcparse.y"
+    {
+	    mc_sefa_val &= ~ (0xfffUL << 16);
+	    mc_sefa_val |= (((yyvsp[(3) - (3)].tok)->nval & 0xfffUL) << 16);
+	    mc_cur_facility = (yyvsp[(3) - (3)].tok);
+	  }
+    break;
+
+  case 63:
+
+/* Line 1455 of yacc.c  */
+#line 256 "mcparse.y"
+    {
+	  mc_last_symbol = (yyvsp[(3) - (3)].ustr);
+	}
+    break;
+
+  case 66:
+
+/* Line 1455 of yacc.c  */
+#line 268 "mcparse.y"
+    {
+	    mc_node_lang *h;
+	    h = mc_add_node_lang (cur_node, (yyvsp[(1) - (4)].tok), cur_node->vid);
+	    h->message = (yyvsp[(3) - (4)].ustr);
+	    if (mcset_max_message_length != 0 && unichar_len (h->message) > mcset_max_message_length)
+	      mc_warn ("message length to long");
+	  }
+    break;
+
+  case 67:
+
+/* Line 1455 of yacc.c  */
+#line 278 "mcparse.y"
+    {
+	    (yyval.ustr) = (yyvsp[(1) - (1)].ustr);
+	  }
+    break;
+
+  case 68:
+
+/* Line 1455 of yacc.c  */
+#line 282 "mcparse.y"
+    {
+	    unichar *h;
+	    rc_uint_type l1,l2;
+	    l1 = unichar_len ((yyvsp[(1) - (2)].ustr));
+	    l2 = unichar_len ((yyvsp[(2) - (2)].ustr));
+	    h = (unichar *) res_alloc ((l1 + l2 + 1) * sizeof (unichar));
+	    if (l1) memcpy (h, (yyvsp[(1) - (2)].ustr), l1 * sizeof (unichar));
+	    if (l2) memcpy (&h[l1], (yyvsp[(2) - (2)].ustr), l2 * sizeof (unichar));
+	    h[l1 + l2] = 0;
+	    (yyval.ustr) = h;
+	  }
+    break;
+
+  case 69:
+
+/* Line 1455 of yacc.c  */
+#line 293 "mcparse.y"
+    { mc_fatal ("missing end of message text"); (yyval.ustr) = NULL; }
+    break;
+
+  case 70:
+
+/* Line 1455 of yacc.c  */
+#line 294 "mcparse.y"
+    { mc_fatal ("missing end of message text"); (yyval.ustr) = (yyvsp[(1) - (2)].ustr); }
+    break;
+
+  case 71:
+
+/* Line 1455 of yacc.c  */
+#line 297 "mcparse.y"
+    { (yyval.ustr) = (yyvsp[(1) - (1)].ustr); }
+    break;
+
+  case 72:
+
+/* Line 1455 of yacc.c  */
+#line 299 "mcparse.y"
+    {
+	    unichar *h;
+	    rc_uint_type l1,l2;
+	    l1 = unichar_len ((yyvsp[(1) - (2)].ustr));
+	    l2 = unichar_len ((yyvsp[(2) - (2)].ustr));
+	    h = (unichar *) res_alloc ((l1 + l2 + 1) * sizeof (unichar));
+	    if (l1) memcpy (h, (yyvsp[(1) - (2)].ustr), l1 * sizeof (unichar));
+	    if (l2) memcpy (&h[l1], (yyvsp[(2) - (2)].ustr), l2 * sizeof (unichar));
+	    h[l1 + l2] = 0;
+	    (yyval.ustr) = h;
+	  }
+    break;
+
+  case 73:
+
+/* Line 1455 of yacc.c  */
+#line 313 "mcparse.y"
+    {
+	    (yyval.tok) = (yyvsp[(4) - (5)].tok);
+	  }
+    break;
+
+  case 74:
+
+/* Line 1455 of yacc.c  */
+#line 317 "mcparse.y"
+    {
+	    (yyval.tok) = NULL;
+	    mc_fatal (_("undeclared language identifier"));
+	  }
+    break;
+
+  case 75:
+
+/* Line 1455 of yacc.c  */
+#line 322 "mcparse.y"
+    {
+	    (yyval.tok) = NULL;
+	    mc_fatal ("missing newline after Language");
+	  }
+    break;
+
+  case 76:
+
+/* Line 1455 of yacc.c  */
+#line 327 "mcparse.y"
+    {
+	    (yyval.tok) = NULL;
+	    mc_fatal ("missing ident for Language");
+	  }
+    break;
+
+  case 77:
+
+/* Line 1455 of yacc.c  */
+#line 332 "mcparse.y"
+    {
+	    (yyval.tok) = NULL;
+	    mc_fatal ("missing '=' for Language");
+	  }
+    break;
+
+  case 78:
+
+/* Line 1455 of yacc.c  */
+#line 338 "mcparse.y"
+    { (yyval.ustr) = (yyvsp[(1) - (1)].ustr); }
+    break;
+
+  case 79:
+
+/* Line 1455 of yacc.c  */
+#line 339 "mcparse.y"
+    { (yyval.ustr) = (yyvsp[(1) - (1)].tok)->usz; }
+    break;
+
+  case 80:
+
+/* Line 1455 of yacc.c  */
+#line 343 "mcparse.y"
+    { mclex_want_nl = 1; }
+    break;
+
+  case 81:
+
+/* Line 1455 of yacc.c  */
+#line 347 "mcparse.y"
+    { mclex_want_line = 1; }
+    break;
+
+  case 82:
+
+/* Line 1455 of yacc.c  */
+#line 351 "mcparse.y"
+    { mclex_want_filename = 1; }
+    break;
+
+
+
+/* Line 1455 of yacc.c  */
+#line 2080 "mcparse.c"
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined(yyoverflow) || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+
+/* Line 1675 of yacc.c  */
+#line 354 "mcparse.y"
+
+
+/* Something else.  */
+
==== (added) binutils-2.19.91.20091006/binutils/mcparse.h ====
--- /dev/null	2009-05-01 06:17:58.000000000 +0200
+++ binutils-2.19.91.20091006/binutils/mcparse.h	2009-10-07 08:18:05.000000000 +0200
@@ -0,0 +1,109 @@
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
+
+/* Skeleton interface for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     NL = 258,
+     MCIDENT = 259,
+     MCFILENAME = 260,
+     MCLINE = 261,
+     MCCOMMENT = 262,
+     MCTOKEN = 263,
+     MCENDLINE = 264,
+     MCLANGUAGENAMES = 265,
+     MCFACILITYNAMES = 266,
+     MCSEVERITYNAMES = 267,
+     MCOUTPUTBASE = 268,
+     MCMESSAGEIDTYPEDEF = 269,
+     MCLANGUAGE = 270,
+     MCMESSAGEID = 271,
+     MCSEVERITY = 272,
+     MCFACILITY = 273,
+     MCSYMBOLICNAME = 274,
+     MCNUMBER = 275
+   };
+#endif
+/* Tokens.  */
+#define NL 258
+#define MCIDENT 259
+#define MCFILENAME 260
+#define MCLINE 261
+#define MCCOMMENT 262
+#define MCTOKEN 263
+#define MCENDLINE 264
+#define MCLANGUAGENAMES 265
+#define MCFACILITYNAMES 266
+#define MCSEVERITYNAMES 267
+#define MCOUTPUTBASE 268
+#define MCMESSAGEIDTYPEDEF 269
+#define MCLANGUAGE 270
+#define MCMESSAGEID 271
+#define MCSEVERITY 272
+#define MCFACILITY 273
+#define MCSYMBOLICNAME 274
+#define MCNUMBER 275
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 1676 of yacc.c  */
+#line 45 "mcparse.y"
+
+  rc_uint_type ival;
+  unichar *ustr;
+  const mc_keyword *tok;
+  mc_node *nod;
+
+
+
+/* Line 1676 of yacc.c  */
+#line 101 "mcparse.h"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+extern YYSTYPE yylval;
+
+
==== (added) binutils-2.19.91.20091006/binutils/rcparse.c ====
--- /dev/null	2009-05-01 06:17:58.000000000 +0200
+++ binutils-2.19.91.20091006/binutils/rcparse.c	2009-10-07 08:18:05.000000000 +0200
@@ -0,0 +1,5101 @@
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.4.1"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+
+
+/* Copy the first part of user declarations.  */
+
+/* Line 189 of yacc.c  */
+#line 1 "rcparse.y"
+ /* rcparse.y -- parser for Windows rc files
+   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2007, 2008
+   Free Software Foundation, Inc.
+   Written by Ian Lance Taylor, Cygnus Support.
+   Extended by Kai Tietz, Onevision.
+
+   This file is part of GNU Binutils.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+
+/* This is a parser for Windows rc files.  It is based on the parser
+   by Gunther Ebert <gunther.ebert@ixos-leipzig.de>.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "bucomm.h"
+#include "libiberty.h"
+#include "windres.h"
+#include "safe-ctype.h"
+
+/* The current language.  */
+
+static unsigned short language;
+
+/* The resource information during a sub statement.  */
+
+static rc_res_res_info sub_res_info;
+
+/* Dialog information.  This is built by the nonterminals styles and
+   controls.  */
+
+static rc_dialog dialog;
+
+/* This is used when building a style.  It is modified by the
+   nonterminal styleexpr.  */
+
+static unsigned long style;
+
+/* These are used when building a control.  They are set before using
+   control_params.  */
+
+static rc_uint_type base_style;
+static rc_uint_type default_style;
+static rc_res_id class;
+static rc_res_id res_text_field;
+static unichar null_unichar;
+
+/* This is used for COMBOBOX, LISTBOX and EDITTEXT which
+   do not allow resource 'text' field in control definition. */
+static const rc_res_id res_null_text = { 1, {{0, &null_unichar}}};
+
+
+
+/* Line 189 of yacc.c  */
+#line 141 "rcparse.c"
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     BEG = 258,
+     END = 259,
+     ACCELERATORS = 260,
+     VIRTKEY = 261,
+     ASCII = 262,
+     NOINVERT = 263,
+     SHIFT = 264,
+     CONTROL = 265,
+     ALT = 266,
+     BITMAP = 267,
+     CURSOR = 268,
+     DIALOG = 269,
+     DIALOGEX = 270,
+     EXSTYLE = 271,
+     CAPTION = 272,
+     CLASS = 273,
+     STYLE = 274,
+     AUTO3STATE = 275,
+     AUTOCHECKBOX = 276,
+     AUTORADIOBUTTON = 277,
+     CHECKBOX = 278,
+     COMBOBOX = 279,
+     CTEXT = 280,
+     DEFPUSHBUTTON = 281,
+     EDITTEXT = 282,
+     GROUPBOX = 283,
+     LISTBOX = 284,
+     LTEXT = 285,
+     PUSHBOX = 286,
+     PUSHBUTTON = 287,
+     RADIOBUTTON = 288,
+     RTEXT = 289,
+     SCROLLBAR = 290,
+     STATE3 = 291,
+     USERBUTTON = 292,
+     BEDIT = 293,
+     HEDIT = 294,
+     IEDIT = 295,
+     FONT = 296,
+     ICON = 297,
+     ANICURSOR = 298,
+     ANIICON = 299,
+     DLGINCLUDE = 300,
+     DLGINIT = 301,
+     FONTDIR = 302,
+     HTML = 303,
+     MANIFEST = 304,
+     PLUGPLAY = 305,
+     VXD = 306,
+     TOOLBAR = 307,
+     BUTTON = 308,
+     LANGUAGE = 309,
+     CHARACTERISTICS = 310,
+     VERSIONK = 311,
+     MENU = 312,
+     MENUEX = 313,
+     MENUITEM = 314,
+     SEPARATOR = 315,
+     POPUP = 316,
+     CHECKED = 317,
+     GRAYED = 318,
+     HELP = 319,
+     INACTIVE = 320,
+     MENUBARBREAK = 321,
+     MENUBREAK = 322,
+     MESSAGETABLE = 323,
+     RCDATA = 324,
+     STRINGTABLE = 325,
+     VERSIONINFO = 326,
+     FILEVERSION = 327,
+     PRODUCTVERSION = 328,
+     FILEFLAGSMASK = 329,
+     FILEFLAGS = 330,
+     FILEOS = 331,
+     FILETYPE = 332,
+     FILESUBTYPE = 333,
+     BLOCKSTRINGFILEINFO = 334,
+     BLOCKVARFILEINFO = 335,
+     VALUE = 336,
+     BLOCK = 337,
+     MOVEABLE = 338,
+     FIXED = 339,
+     PURE = 340,
+     IMPURE = 341,
+     PRELOAD = 342,
+     LOADONCALL = 343,
+     DISCARDABLE = 344,
+     NOT = 345,
+     QUOTEDUNISTRING = 346,
+     QUOTEDSTRING = 347,
+     STRING = 348,
+     NUMBER = 349,
+     SIZEDUNISTRING = 350,
+     SIZEDSTRING = 351,
+     IGNORED_TOKEN = 352,
+     NEG = 353
+   };
+#endif
+/* Tokens.  */
+#define BEG 258
+#define END 259
+#define ACCELERATORS 260
+#define VIRTKEY 261
+#define ASCII 262
+#define NOINVERT 263
+#define SHIFT 264
+#define CONTROL 265
+#define ALT 266
+#define BITMAP 267
+#define CURSOR 268
+#define DIALOG 269
+#define DIALOGEX 270
+#define EXSTYLE 271
+#define CAPTION 272
+#define CLASS 273
+#define STYLE 274
+#define AUTO3STATE 275
+#define AUTOCHECKBOX 276
+#define AUTORADIOBUTTON 277
+#define CHECKBOX 278
+#define COMBOBOX 279
+#define CTEXT 280
+#define DEFPUSHBUTTON 281
+#define EDITTEXT 282
+#define GROUPBOX 283
+#define LISTBOX 284
+#define LTEXT 285
+#define PUSHBOX 286
+#define PUSHBUTTON 287
+#define RADIOBUTTON 288
+#define RTEXT 289
+#define SCROLLBAR 290
+#define STATE3 291
+#define USERBUTTON 292
+#define BEDIT 293
+#define HEDIT 294
+#define IEDIT 295
+#define FONT 296
+#define ICON 297
+#define ANICURSOR 298
+#define ANIICON 299
+#define DLGINCLUDE 300
+#define DLGINIT 301
+#define FONTDIR 302
+#define HTML 303
+#define MANIFEST 304
+#define PLUGPLAY 305
+#define VXD 306
+#define TOOLBAR 307
+#define BUTTON 308
+#define LANGUAGE 309
+#define CHARACTERISTICS 310
+#define VERSIONK 311
+#define MENU 312
+#define MENUEX 313
+#define MENUITEM 314
+#define SEPARATOR 315
+#define POPUP 316
+#define CHECKED 317
+#define GRAYED 318
+#define HELP 319
+#define INACTIVE 320
+#define MENUBARBREAK 321
+#define MENUBREAK 322
+#define MESSAGETABLE 323
+#define RCDATA 324
+#define STRINGTABLE 325
+#define VERSIONINFO 326
+#define FILEVERSION 327
+#define PRODUCTVERSION 328
+#define FILEFLAGSMASK 329
+#define FILEFLAGS 330
+#define FILEOS 331
+#define FILETYPE 332
+#define FILESUBTYPE 333
+#define BLOCKSTRINGFILEINFO 334
+#define BLOCKVARFILEINFO 335
+#define VALUE 336
+#define BLOCK 337
+#define MOVEABLE 338
+#define FIXED 339
+#define PURE 340
+#define IMPURE 341
+#define PRELOAD 342
+#define LOADONCALL 343
+#define DISCARDABLE 344
+#define NOT 345
+#define QUOTEDUNISTRING 346
+#define QUOTEDSTRING 347
+#define STRING 348
+#define NUMBER 349
+#define SIZEDUNISTRING 350
+#define SIZEDSTRING 351
+#define IGNORED_TOKEN 352
+#define NEG 353
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 214 of yacc.c  */
+#line 69 "rcparse.y"
+
+  rc_accelerator acc;
+  rc_accelerator *pacc;
+  rc_dialog_control *dialog_control;
+  rc_menuitem *menuitem;
+  struct
+  {
+    rc_rcdata_item *first;
+    rc_rcdata_item *last;
+  } rcdata;
+  rc_rcdata_item *rcdata_item;
+  rc_fixed_versioninfo *fixver;
+  rc_ver_info *verinfo;
+  rc_ver_stringinfo *verstring;
+  rc_ver_varinfo *vervar;
+  rc_toolbar_item *toobar_item;
+  rc_res_id id;
+  rc_res_res_info res_info;
+  struct
+  {
+    rc_uint_type on;
+    rc_uint_type off;
+  } memflags;
+  struct
+  {
+    rc_uint_type val;
+    /* Nonzero if this number was explicitly specified as long.  */
+    int dword;
+  } i;
+  rc_uint_type il;
+  rc_uint_type is;
+  const char *s;
+  struct
+  {
+    rc_uint_type length;
+    const char *s;
+  } ss;
+  unichar *uni;
+  struct
+  {
+    rc_uint_type length;
+    const unichar *s;
+  } suni;
+
+
+
+/* Line 214 of yacc.c  */
+#line 420 "rcparse.c"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 264 of yacc.c  */
+#line 432 "rcparse.c"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
+{
+  return yyi;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  2
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   835
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  112
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  99
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  270
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  515
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   353
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,   105,   100,     2,
+     110,   111,   103,   101,   108,   102,     2,   104,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,   109,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,    99,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,    98,     2,   106,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
+      45,    46,    47,    48,    49,    50,    51,    52,    53,    54,
+      55,    56,    57,    58,    59,    60,    61,    62,    63,    64,
+      65,    66,    67,    68,    69,    70,    71,    72,    73,    74,
+      75,    76,    77,    78,    79,    80,    81,    82,    83,    84,
+      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,
+      95,    96,    97,   107
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint16 yyprhs[] =
+{
+       0,     0,     3,     4,     7,    10,    13,    16,    19,    22,
+      25,    28,    31,    34,    37,    40,    43,    46,    49,    56,
+      57,    60,    63,    68,    70,    72,    74,    78,    81,    83,
+      85,    87,    89,    91,    93,    98,   103,   104,   118,   119,
+     133,   134,   149,   150,   154,   155,   159,   163,   167,   171,
+     175,   181,   188,   196,   205,   209,   213,   218,   222,   223,
+     226,   227,   232,   233,   238,   239,   244,   245,   250,   251,
+     256,   257,   261,   273,   286,   287,   292,   293,   298,   299,
+     303,   304,   309,   310,   315,   322,   331,   342,   354,   355,
+     360,   361,   365,   366,   371,   372,   377,   378,   383,   384,
+     389,   390,   395,   396,   400,   401,   406,   407,   423,   430,
+     439,   449,   452,   453,   456,   458,   460,   461,   465,   466,
+     470,   471,   475,   476,   480,   485,   490,   494,   501,   502,
+     505,   510,   513,   520,   521,   525,   528,   530,   532,   534,
+     536,   538,   540,   547,   548,   551,   554,   558,   564,   567,
+     573,   580,   588,   598,   603,   604,   607,   608,   610,   612,
+     614,   616,   620,   624,   628,   631,   632,   639,   640,   644,
+     649,   652,   654,   656,   658,   660,   662,   664,   666,   668,
+     670,   672,   679,   684,   693,   694,   698,   701,   708,   709,
+     716,   723,   727,   731,   735,   739,   743,   744,   753,   761,
+     762,   768,   769,   773,   775,   777,   779,   781,   784,   786,
+     789,   790,   793,   797,   802,   806,   807,   810,   811,   814,
+     816,   818,   820,   822,   824,   826,   828,   830,   832,   834,
+     837,   839,   841,   843,   846,   848,   851,   853,   856,   860,
+     865,   867,   871,   872,   874,   877,   879,   881,   885,   888,
+     891,   895,   899,   903,   907,   911,   915,   919,   923,   926,
+     928,   930,   934,   937,   941,   945,   949,   953,   957,   961,
+     965
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int16 yyrhs[] =
+{
+     113,     0,    -1,    -1,   113,   114,    -1,   113,   120,    -1,
+     113,   121,    -1,   113,   122,    -1,   113,   162,    -1,   113,
+     163,    -1,   113,   164,    -1,   113,   165,    -1,   113,   170,
+      -1,   113,   173,    -1,   113,   178,    -1,   113,   183,    -1,
+     113,   182,    -1,   113,   185,    -1,   113,    97,    -1,   190,
+       5,   193,     3,   115,     4,    -1,    -1,   115,   116,    -1,
+     117,   208,    -1,   117,   208,   108,   118,    -1,    92,    -1,
+     209,    -1,   119,    -1,   118,   108,   119,    -1,   118,   119,
+      -1,     6,    -1,     7,    -1,     8,    -1,     9,    -1,    10,
+      -1,    11,    -1,   190,    12,   195,   197,    -1,   190,    13,
+     194,   197,    -1,    -1,   190,    14,   195,   126,   209,   205,
+     205,   205,   123,   127,     3,   128,     4,    -1,    -1,   190,
+      15,   195,   126,   209,   205,   205,   205,   124,   127,     3,
+     128,     4,    -1,    -1,   190,    15,   195,   126,   209,   205,
+     205,   205,   205,   125,   127,     3,   128,     4,    -1,    -1,
+      16,   109,   206,    -1,    -1,   127,    17,   198,    -1,   127,
+      18,   190,    -1,   127,    19,   202,    -1,   127,    16,   206,
+      -1,   127,    18,   198,    -1,   127,    41,   206,   108,   198,
+      -1,   127,    41,   206,   108,   198,   205,    -1,   127,    41,
+     206,   108,   198,   205,   205,    -1,   127,    41,   206,   108,
+     198,   205,   205,   205,    -1,   127,    57,   190,    -1,   127,
+      55,   206,    -1,   127,    54,   206,   205,    -1,   127,    56,
+     206,    -1,    -1,   128,   129,    -1,    -1,    20,   153,   130,
+     151,    -1,    -1,    21,   153,   131,   151,    -1,    -1,    22,
+     153,   132,   151,    -1,    -1,    38,   153,   133,   151,    -1,
+      -1,    23,   153,   134,   151,    -1,    -1,    24,   135,   151,
+      -1,    10,   153,   206,   152,   156,   205,   205,   205,   205,
+     204,   155,    -1,    10,   153,   206,   152,   156,   205,   205,
+     205,   205,   205,   205,   155,    -1,    -1,    25,   153,   136,
+     151,    -1,    -1,    26,   153,   137,   151,    -1,    -1,    27,
+     138,   151,    -1,    -1,    28,   153,   139,   151,    -1,    -1,
+      39,   153,   140,   151,    -1,    42,   192,   206,   205,   205,
+     155,    -1,    42,   192,   206,   205,   205,   205,   205,   155,
+      -1,    42,   192,   206,   205,   205,   205,   205,   158,   204,
+     155,    -1,    42,   192,   206,   205,   205,   205,   205,   158,
+     205,   205,   155,    -1,    -1,    40,   153,   141,   151,    -1,
+      -1,    29,   142,   151,    -1,    -1,    30,   153,   143,   151,
+      -1,    -1,    31,   153,   144,   151,    -1,    -1,    32,   153,
+     145,   151,    -1,    -1,    33,   153,   146,   151,    -1,    -1,
+      34,   153,   147,   151,    -1,    -1,    35,   148,   151,    -1,
+      -1,    36,   153,   149,   151,    -1,    -1,    37,   192,   206,
+     108,   206,   108,   206,   108,   206,   108,   206,   108,   150,
+     202,   204,    -1,   206,   205,   205,   205,   205,   155,    -1,
+     206,   205,   205,   205,   205,   160,   204,   155,    -1,   206,
+     205,   205,   205,   205,   160,   205,   205,   155,    -1,   108,
+     154,    -1,    -1,   154,   108,    -1,   209,    -1,   198,    -1,
+      -1,     3,   174,     4,    -1,    -1,   108,   157,   202,    -1,
+      -1,   108,   159,   202,    -1,    -1,   108,   161,   202,    -1,
+     190,    41,   194,   197,    -1,   190,    42,   194,   197,    -1,
+      54,   206,   205,    -1,   190,    57,   193,     3,   166,     4,
+      -1,    -1,   166,   167,    -1,    59,   198,   205,   168,    -1,
+      59,    60,    -1,    61,   198,   168,     3,   166,     4,    -1,
+      -1,   168,   108,   169,    -1,   168,   169,    -1,    62,    -1,
+      63,    -1,    64,    -1,    65,    -1,    66,    -1,    67,    -1,
+     190,    58,   193,     3,   171,     4,    -1,    -1,   171,   172,
+      -1,    59,   198,    -1,    59,   198,   205,    -1,    59,   198,
+     205,   205,   204,    -1,    59,    60,    -1,    61,   198,     3,
+     171,     4,    -1,    61,   198,   205,     3,   171,     4,    -1,
+      61,   198,   205,   205,     3,   171,     4,    -1,    61,   198,
+     205,   205,   205,   204,     3,   171,     4,    -1,   190,    68,
+     195,   197,    -1,    -1,   175,   176,    -1,    -1,   177,    -1,
+     200,    -1,   201,    -1,   207,    -1,   177,   108,   200,    -1,
+     177,   108,   201,    -1,   177,   108,   207,    -1,   177,   108,
+      -1,    -1,    70,   193,     3,   179,   180,     4,    -1,    -1,
+     180,   206,   198,    -1,   180,   206,   108,   198,    -1,   180,
+       1,    -1,   190,    -1,    48,    -1,    69,    -1,    49,    -1,
+      50,    -1,    51,    -1,    45,    -1,    46,    -1,    43,    -1,
+      44,    -1,   190,   181,   193,     3,   174,     4,    -1,   190,
+     181,   193,   197,    -1,   190,    52,   193,   206,   205,     3,
+     184,     4,    -1,    -1,   184,    53,   190,    -1,   184,    60,
+      -1,   190,    71,   186,     3,   187,     4,    -1,    -1,   186,
+      72,   206,   205,   205,   205,    -1,   186,    73,   206,   205,
+     205,   205,    -1,   186,    74,   206,    -1,   186,    75,   206,
+      -1,   186,    76,   206,    -1,   186,    77,   206,    -1,   186,
+      78,   206,    -1,    -1,   187,    79,     3,    82,     3,   188,
+       4,     4,    -1,   187,    80,     3,    81,   198,   189,     4,
+      -1,    -1,   188,    81,   198,   108,   198,    -1,    -1,   189,
+     205,   205,    -1,   209,    -1,   191,    -1,   199,    -1,    93,
+      -1,   209,   108,    -1,   191,    -1,   191,   108,    -1,    -1,
+     193,   196,    -1,   193,    55,   206,    -1,   193,    54,   206,
+     205,    -1,   193,    56,   206,    -1,    -1,   194,   196,    -1,
+      -1,   195,   196,    -1,    83,    -1,    84,    -1,    85,    -1,
+      86,    -1,    87,    -1,    88,    -1,    89,    -1,    92,    -1,
+      93,    -1,   199,    -1,   198,   199,    -1,    91,    -1,    92,
+      -1,    96,    -1,   200,    96,    -1,    95,    -1,   201,    95,
+      -1,   203,    -1,    90,   203,    -1,   202,    98,   203,    -1,
+     202,    98,    90,   203,    -1,    94,    -1,   110,   206,   111,
+      -1,    -1,   205,    -1,   108,   206,    -1,   207,    -1,    94,
+      -1,   110,   207,   111,    -1,   106,   207,    -1,   102,   207,
+      -1,   207,   103,   207,    -1,   207,   104,   207,    -1,   207,
+     105,   207,    -1,   207,   101,   207,    -1,   207,   102,   207,
+      -1,   207,   100,   207,    -1,   207,    99,   207,    -1,   207,
+      98,   207,    -1,   108,   209,    -1,   210,    -1,    94,    -1,
+     110,   207,   111,    -1,   106,   207,    -1,   210,   103,   207,
+      -1,   210,   104,   207,    -1,   210,   105,   207,    -1,   210,
+     101,   207,    -1,   210,   102,   207,    -1,   210,   100,   207,
+      -1,   210,    99,   207,    -1,   210,    98,   207,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   177,   177,   179,   180,   181,   182,   183,   184,   185,
+     186,   187,   188,   189,   190,   191,   192,   193,   199,   210,
+     213,   234,   239,   251,   271,   281,   285,   290,   297,   301,
+     306,   310,   314,   318,   327,   339,   353,   351,   378,   376,
+     405,   403,   435,   438,   444,   446,   452,   456,   461,   465,
+     469,   482,   497,   512,   527,   531,   535,   539,   545,   547,
+     559,   558,   571,   570,   583,   582,   595,   594,   610,   609,
+     622,   621,   635,   646,   656,   655,   668,   667,   680,   679,
+     692,   691,   704,   703,   718,   723,   729,   735,   742,   741,
+     757,   756,   769,   768,   781,   780,   792,   791,   804,   803,
+     816,   815,   828,   827,   840,   839,   853,   851,   872,   883,
+     894,   906,   917,   920,   924,   929,   939,   942,   952,   951,
+     958,   957,   964,   963,   971,   983,   996,  1005,  1016,  1019,
+    1036,  1040,  1044,  1052,  1055,  1059,  1066,  1070,  1074,  1078,
+    1082,  1086,  1095,  1106,  1109,  1126,  1130,  1134,  1138,  1142,
+    1146,  1150,  1154,  1164,  1177,  1177,  1189,  1193,  1200,  1208,
+    1216,  1224,  1233,  1242,  1251,  1261,  1260,  1265,  1267,  1272,
+    1277,  1285,  1289,  1294,  1299,  1304,  1309,  1314,  1319,  1324,
+    1329,  1340,  1347,  1357,  1363,  1364,  1383,  1408,  1419,  1424,
+    1430,  1436,  1441,  1446,  1451,  1456,  1471,  1474,  1478,  1486,
+    1489,  1497,  1500,  1509,  1514,  1523,  1527,  1537,  1542,  1546,
+    1557,  1563,  1569,  1574,  1579,  1590,  1595,  1607,  1612,  1624,
+    1629,  1634,  1639,  1644,  1649,  1654,  1664,  1668,  1676,  1681,
+    1696,  1700,  1709,  1713,  1725,  1729,  1751,  1755,  1759,  1763,
+    1770,  1774,  1784,  1787,  1796,  1805,  1814,  1818,  1822,  1827,
+    1832,  1837,  1842,  1847,  1852,  1857,  1862,  1867,  1878,  1887,
+    1898,  1902,  1906,  1911,  1916,  1921,  1926,  1931,  1936,  1941,
+    1946
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "BEG", "END", "ACCELERATORS", "VIRTKEY",
+  "ASCII", "NOINVERT", "SHIFT", "CONTROL", "ALT", "BITMAP", "CURSOR",
+  "DIALOG", "DIALOGEX", "EXSTYLE", "CAPTION", "CLASS", "STYLE",
+  "AUTO3STATE", "AUTOCHECKBOX", "AUTORADIOBUTTON", "CHECKBOX", "COMBOBOX",
+  "CTEXT", "DEFPUSHBUTTON", "EDITTEXT", "GROUPBOX", "LISTBOX", "LTEXT",
+  "PUSHBOX", "PUSHBUTTON", "RADIOBUTTON", "RTEXT", "SCROLLBAR", "STATE3",
+  "USERBUTTON", "BEDIT", "HEDIT", "IEDIT", "FONT", "ICON", "ANICURSOR",
+  "ANIICON", "DLGINCLUDE", "DLGINIT", "FONTDIR", "HTML", "MANIFEST",
+  "PLUGPLAY", "VXD", "TOOLBAR", "BUTTON", "LANGUAGE", "CHARACTERISTICS",
+  "VERSIONK", "MENU", "MENUEX", "MENUITEM", "SEPARATOR", "POPUP",
+  "CHECKED", "GRAYED", "HELP", "INACTIVE", "MENUBARBREAK", "MENUBREAK",
+  "MESSAGETABLE", "RCDATA", "STRINGTABLE", "VERSIONINFO", "FILEVERSION",
+  "PRODUCTVERSION", "FILEFLAGSMASK", "FILEFLAGS", "FILEOS", "FILETYPE",
+  "FILESUBTYPE", "BLOCKSTRINGFILEINFO", "BLOCKVARFILEINFO", "VALUE",
+  "BLOCK", "MOVEABLE", "FIXED", "PURE", "IMPURE", "PRELOAD", "LOADONCALL",
+  "DISCARDABLE", "NOT", "QUOTEDUNISTRING", "QUOTEDSTRING", "STRING",
+  "NUMBER", "SIZEDUNISTRING", "SIZEDSTRING", "IGNORED_TOKEN", "'|'", "'^'",
+  "'&'", "'+'", "'-'", "'*'", "'/'", "'%'", "'~'", "NEG", "','", "'='",
+  "'('", "')'", "$accept", "input", "accelerator", "acc_entries",
+  "acc_entry", "acc_event", "acc_options", "acc_option", "bitmap",
+  "cursor", "dialog", "$@1", "$@2", "$@3", "exstyle", "styles", "controls",
+  "control", "$@4", "$@5", "$@6", "$@7", "$@8", "$@9", "$@10", "$@11",
+  "$@12", "$@13", "$@14", "$@15", "$@16", "$@17", "$@18", "$@19", "$@20",
+  "$@21", "$@22", "$@23", "$@24", "control_params", "cresid", "optresidc",
+  "resid", "opt_control_data", "control_styleexpr", "$@25",
+  "icon_styleexpr", "$@26", "control_params_styleexpr", "$@27", "font",
+  "icon", "language", "menu", "menuitems", "menuitem", "menuitem_flags",
+  "menuitem_flag", "menuex", "menuexitems", "menuexitem", "messagetable",
+  "optrcdata_data", "$@28", "optrcdata_data_int", "rcdata_data",
+  "stringtable", "$@29", "string_data", "rcdata_id", "user", "toolbar",
+  "toolbar_data", "versioninfo", "fixedverinfo", "verblocks", "vervals",
+  "vertrans", "id", "resname", "resref", "suboptions",
+  "memflags_move_discard", "memflags_move", "memflag", "file_name",
+  "res_unicode_string_concat", "res_unicode_string", "sizedstring",
+  "sizedunistring", "styleexpr", "parennumber", "optcnumexpr", "cnumexpr",
+  "numexpr", "sizednumexpr", "cposnumexpr", "posnumexpr",
+  "sizedposnumexpr", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
+     295,   296,   297,   298,   299,   300,   301,   302,   303,   304,
+     305,   306,   307,   308,   309,   310,   311,   312,   313,   314,
+     315,   316,   317,   318,   319,   320,   321,   322,   323,   324,
+     325,   326,   327,   328,   329,   330,   331,   332,   333,   334,
+     335,   336,   337,   338,   339,   340,   341,   342,   343,   344,
+     345,   346,   347,   348,   349,   350,   351,   352,   124,    94,
+      38,    43,    45,    42,    47,    37,   126,   353,    44,    61,
+      40,    41
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,   112,   113,   113,   113,   113,   113,   113,   113,   113,
+     113,   113,   113,   113,   113,   113,   113,   113,   114,   115,
+     115,   116,   116,   117,   117,   118,   118,   118,   119,   119,
+     119,   119,   119,   119,   120,   121,   123,   122,   124,   122,
+     125,   122,   126,   126,   127,   127,   127,   127,   127,   127,
+     127,   127,   127,   127,   127,   127,   127,   127,   128,   128,
+     130,   129,   131,   129,   132,   129,   133,   129,   134,   129,
+     135,   129,   129,   129,   136,   129,   137,   129,   138,   129,
+     139,   129,   140,   129,   129,   129,   129,   129,   141,   129,
+     142,   129,   143,   129,   144,   129,   145,   129,   146,   129,
+     147,   129,   148,   129,   149,   129,   150,   129,   151,   151,
+     151,   152,   153,   153,   154,   154,   155,   155,   157,   156,
+     159,   158,   161,   160,   162,   163,   164,   165,   166,   166,
+     167,   167,   167,   168,   168,   168,   169,   169,   169,   169,
+     169,   169,   170,   171,   171,   172,   172,   172,   172,   172,
+     172,   172,   172,   173,   175,   174,   176,   176,   177,   177,
+     177,   177,   177,   177,   177,   179,   178,   180,   180,   180,
+     180,   181,   181,   181,   181,   181,   181,   181,   181,   181,
+     181,   182,   182,   183,   184,   184,   184,   185,   186,   186,
+     186,   186,   186,   186,   186,   186,   187,   187,   187,   188,
+     188,   189,   189,   190,   190,   191,   191,   192,   192,   192,
+     193,   193,   193,   193,   193,   194,   194,   195,   195,   196,
+     196,   196,   196,   196,   196,   196,   197,   197,   198,   198,
+     199,   199,   200,   200,   201,   201,   202,   202,   202,   202,
+     203,   203,   204,   204,   205,   206,   207,   207,   207,   207,
+     207,   207,   207,   207,   207,   207,   207,   207,   208,   209,
+     210,   210,   210,   210,   210,   210,   210,   210,   210,   210,
+     210
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     0,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     6,     0,
+       2,     2,     4,     1,     1,     1,     3,     2,     1,     1,
+       1,     1,     1,     1,     4,     4,     0,    13,     0,    13,
+       0,    14,     0,     3,     0,     3,     3,     3,     3,     3,
+       5,     6,     7,     8,     3,     3,     4,     3,     0,     2,
+       0,     4,     0,     4,     0,     4,     0,     4,     0,     4,
+       0,     3,    11,    12,     0,     4,     0,     4,     0,     3,
+       0,     4,     0,     4,     6,     8,    10,    11,     0,     4,
+       0,     3,     0,     4,     0,     4,     0,     4,     0,     4,
+       0,     4,     0,     3,     0,     4,     0,    15,     6,     8,
+       9,     2,     0,     2,     1,     1,     0,     3,     0,     3,
+       0,     3,     0,     3,     4,     4,     3,     6,     0,     2,
+       4,     2,     6,     0,     3,     2,     1,     1,     1,     1,
+       1,     1,     6,     0,     2,     2,     3,     5,     2,     5,
+       6,     7,     9,     4,     0,     2,     0,     1,     1,     1,
+       1,     3,     3,     3,     2,     0,     6,     0,     3,     4,
+       2,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     6,     4,     8,     0,     3,     2,     6,     0,     6,
+       6,     3,     3,     3,     3,     3,     0,     8,     7,     0,
+       5,     0,     3,     1,     1,     1,     1,     2,     1,     2,
+       0,     2,     3,     4,     3,     0,     2,     0,     2,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     2,
+       1,     1,     1,     2,     1,     2,     1,     2,     3,     4,
+       1,     3,     0,     1,     2,     1,     1,     3,     2,     2,
+       3,     3,     3,     3,     3,     3,     3,     3,     2,     1,
+       1,     3,     2,     3,     3,     3,     3,     3,     3,     3,
+       3
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint16 yydefact[] =
+{
+       2,     0,     1,     0,   210,   230,   231,   206,   260,    17,
+       0,     0,     3,     4,     5,     6,     7,     8,     9,    10,
+      11,    12,    13,    15,    14,    16,     0,   204,   205,   203,
+     259,   246,     0,     0,     0,     0,   245,     0,   262,     0,
+     210,   217,   215,   217,   217,   215,   215,   179,   180,   177,
+     178,   172,   174,   175,   176,   210,   210,   210,   217,   173,
+     188,   210,   171,     0,     0,     0,     0,     0,     0,     0,
+       0,   249,   248,     0,     0,   126,     0,     0,     0,     0,
+       0,     0,     0,     0,   165,     0,     0,     0,   219,   220,
+     221,   222,   223,   224,   225,   211,   261,     0,     0,     0,
+      42,    42,     0,     0,     0,     0,     0,     0,     0,     0,
+     270,   269,   268,   266,   267,   263,   264,   265,   247,   244,
+     257,   256,   255,   253,   254,   250,   251,   252,   167,     0,
+     212,   214,    19,   226,   227,   218,    34,   216,    35,     0,
+       0,     0,   124,   125,     0,   128,   143,   153,   196,     0,
+       0,     0,     0,     0,     0,     0,   154,   182,     0,   213,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+     191,   192,   193,   194,   195,     0,   156,   170,   166,     0,
+      18,    23,    20,     0,    24,    43,     0,     0,   184,   127,
+       0,     0,   129,   142,     0,     0,   144,   187,     0,     0,
+       0,     0,   181,   234,   232,   155,   157,   158,   159,   160,
+       0,   168,   228,     0,    21,     0,     0,     0,   131,     0,
+     133,   148,   145,     0,     0,     0,     0,     0,   164,   233,
+     235,   169,   229,   258,     0,    36,    38,   183,     0,   186,
+     133,     0,   146,   143,     0,     0,     0,   189,   190,   161,
+     162,   163,    28,    29,    30,    31,    32,    33,    22,    25,
+      44,    44,    40,   185,   130,   128,   136,   137,   138,   139,
+     140,   141,     0,   135,   242,     0,   143,     0,   199,   201,
+       0,    27,     0,     0,    44,     0,   134,   147,   243,   149,
+       0,   143,   242,     0,     0,    26,    58,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    58,     0,   132,   150,
+       0,     0,     0,     0,   198,     0,     0,    48,    45,    46,
+      49,   205,     0,   240,     0,    47,   236,     0,     0,    55,
+      57,    54,     0,    58,   151,   143,   197,     0,   202,    37,
+     112,   112,   112,   112,   112,    70,   112,   112,    78,   112,
+      90,   112,   112,   112,   112,   112,   102,   112,     0,   112,
+     112,   112,     0,    59,   237,     0,     0,     0,    56,    39,
+       0,     0,     0,     0,     0,   115,   114,    60,    62,    64,
+      68,     0,    74,    76,     0,    80,     0,    92,    94,    96,
+      98,   100,     0,   104,   208,     0,     0,    66,    82,    88,
+       0,   241,     0,   238,    50,    41,   152,   200,     0,   113,
+       0,     0,     0,     0,    71,     0,     0,     0,    79,     0,
+      91,     0,     0,     0,     0,     0,   103,     0,   209,     0,
+     207,     0,     0,     0,     0,   239,    51,     0,     0,    61,
+      63,    65,    69,     0,    75,    77,    81,    93,    95,    97,
+      99,   101,   105,     0,    67,    83,    89,     0,    52,   111,
+     118,     0,     0,     0,   116,    53,     0,     0,     0,     0,
+     154,    84,     0,   119,     0,   116,     0,     0,   116,     0,
+     122,   108,   242,     0,   117,   120,    85,   242,   242,     0,
+     116,   243,     0,     0,   116,   243,   116,   243,   123,   109,
+     116,     0,   121,    86,   116,    72,   116,   110,     0,    87,
+      73,   106,     0,   242,   107
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,     1,    12,   160,   182,   183,   258,   259,    13,    14,
+      15,   260,   261,   284,   140,   282,   316,   363,   410,   411,
+     412,   431,   413,   381,   416,   417,   384,   419,   432,   433,
+     386,   421,   422,   423,   424,   425,   392,   427,   512,   414,
+     438,   373,   374,   471,   461,   466,   487,   493,   482,   489,
+      16,    17,    18,    19,   165,   192,   241,   273,    20,   166,
+     196,    21,   175,   176,   205,   206,    22,   128,   158,    61,
+      23,    24,   217,    25,   108,   167,   293,   294,    26,    27,
+     395,    37,    99,    98,    95,   136,   375,   212,   207,   208,
+     325,   326,   287,   288,   415,    36,   214,   376,    30
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -309
+static const yytype_int16 yypact[] =
+{
+    -309,    68,  -309,   338,  -309,  -309,  -309,  -309,  -309,  -309,
+     338,   338,  -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,
+    -309,  -309,  -309,  -309,  -309,  -309,   458,  -309,  -309,  -309,
+     605,  -309,   338,   338,   338,   -92,   642,   230,  -309,   534,
+    -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,
+    -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,
+    -309,  -309,  -309,   338,   338,   338,   338,   338,   338,   338,
+     338,  -309,  -309,   695,   338,  -309,   338,   338,   338,   338,
+     338,   338,   338,   338,  -309,   338,   338,   338,  -309,  -309,
+    -309,  -309,  -309,  -309,  -309,  -309,  -309,   329,   724,   724,
+     242,   242,   724,   724,   499,   434,   457,   724,   192,   250,
+     392,   718,   318,   174,   174,  -309,  -309,  -309,  -309,  -309,
+     392,   718,   318,   174,   174,  -309,  -309,  -309,  -309,   -92,
+    -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,   -81,
+     263,   263,  -309,  -309,   -92,  -309,  -309,  -309,  -309,   338,
+     338,   338,   338,   338,   338,   338,  -309,  -309,     6,  -309,
+      13,   338,   -92,   -92,    48,     8,   105,    35,   -92,   -92,
+    -309,  -309,  -309,  -309,  -309,    53,   373,  -309,  -309,   -38,
+    -309,  -309,  -309,   -48,  -309,  -309,   -92,   -92,  -309,  -309,
+     -36,     7,  -309,  -309,    80,     7,  -309,  -309,    60,   103,
+     -92,   -92,  -309,  -309,  -309,  -309,    17,    38,    47,   642,
+       7,     7,  -309,   263,    65,   -92,   -92,    -1,  -309,   163,
+       7,  -309,   163,    12,    74,    94,   -92,   -92,   373,  -309,
+    -309,     7,  -309,  -309,   818,  -309,   -92,  -309,   253,  -309,
+    -309,   184,   -92,  -309,     5,   177,     7,  -309,  -309,    38,
+      47,   642,  -309,  -309,  -309,  -309,  -309,  -309,    25,  -309,
+    -309,  -309,  -309,  -309,   155,  -309,  -309,  -309,  -309,  -309,
+    -309,  -309,   768,  -309,   -92,   120,  -309,    10,  -309,     7,
+     818,  -309,   556,   562,  -309,   137,  -309,  -309,  -309,  -309,
+     141,  -309,   -92,    21,     2,  -309,  -309,   338,     7,   253,
+     -46,   338,   338,   338,   338,   253,  -309,   573,  -309,  -309,
+     153,   188,   172,     7,  -309,   -92,   655,  -309,     7,  -309,
+       7,    40,    27,  -309,   338,    99,  -309,    93,   -92,  -309,
+    -309,  -309,   692,  -309,  -309,  -309,  -309,   168,  -309,  -309,
+     258,   258,   258,   258,   258,  -309,   258,   258,  -309,   258,
+    -309,   258,   258,   258,   258,   258,  -309,   258,   253,   258,
+     258,   258,   253,  -309,  -309,    95,    98,     7,  -309,  -309,
+     729,   173,     7,   338,   102,     7,  -309,  -309,  -309,  -309,
+    -309,   338,  -309,  -309,   338,  -309,   338,  -309,  -309,  -309,
+    -309,  -309,   338,  -309,   117,   338,   123,  -309,  -309,  -309,
+     338,  -309,    27,  -309,   163,  -309,  -309,     7,   128,  -309,
+     338,   338,   338,   338,  -309,   -92,   338,   338,  -309,   338,
+    -309,   338,   338,   338,   338,   338,  -309,   338,  -309,   131,
+    -309,   338,   338,   338,   -92,  -309,   -92,   258,   132,  -309,
+    -309,  -309,  -309,   -92,  -309,  -309,  -309,  -309,  -309,  -309,
+    -309,  -309,  -309,   338,  -309,  -309,  -309,   -92,   -92,  -309,
+    -309,   -92,   -92,   149,    18,  -309,   -46,   -92,   -92,   338,
+    -309,  -309,   -92,    99,   -92,    19,   154,   203,    20,   -92,
+    -309,  -309,   -92,   338,  -309,  -309,  -309,   -92,   -92,   -46,
+     225,   -92,   165,   -46,   225,   -92,   225,   -92,    99,  -309,
+     225,   338,    99,  -309,   225,  -309,   225,  -309,   182,  -309,
+    -309,  -309,   -46,   -71,  -309
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int16 yypgoto[] =
+{
+    -309,  -309,  -309,  -309,  -309,  -309,  -309,  -240,  -309,  -309,
+    -309,  -309,  -309,  -309,   144,  -235,  -295,  -309,  -309,  -309,
+    -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,
+    -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,   239,
+    -309,   431,  -156,  -100,  -309,  -309,  -309,  -309,  -309,  -309,
+    -309,  -309,  -309,  -309,    26,  -309,    56,    39,  -309,  -196,
+    -309,  -309,  -173,  -309,  -309,  -309,  -309,  -309,  -309,  -309,
+    -309,  -309,  -309,  -309,  -309,  -309,  -309,  -309,   -25,  -265,
+     -55,   232,     0,   333,   432,   375,  -129,     4,    82,    84,
+    -237,  -308,  -283,   -33,    -3,     9,  -309,     3,  -309
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -229
+static const yytype_int16 yytable[] =
+{
+      35,    62,    75,   237,    29,    28,   314,   177,   276,   311,
+     178,   332,   189,   291,   364,   243,    74,   180,   281,    38,
+      39,   470,   470,   470,   218,   312,   283,   366,   161,    29,
+      28,   252,   253,   254,   255,   256,   257,    74,   370,   197,
+     295,    71,    72,    73,   322,   102,   103,   275,   323,   307,
+     211,   188,   238,     5,     6,     5,     6,   202,   403,   239,
+     213,   219,   220,   224,   324,   222,   223,   190,     2,   191,
+     210,   119,   110,   111,   112,   113,   114,   115,   116,   117,
+     290,   231,   129,   130,   131,   120,   121,   122,   123,   124,
+     125,   126,   127,   394,   435,   310,   159,   394,     5,     6,
+      31,   144,   313,     5,     6,   181,   225,     8,    32,   193,
+      74,   164,    33,    74,   198,   199,    34,   279,    74,    10,
+      74,   323,     3,    11,   289,   228,    74,   480,   485,   186,
+     187,  -228,  -228,   280,   229,   200,   201,   324,     4,   371,
+     221,   308,   230,   162,   163,   309,   168,   169,   170,   171,
+     172,   173,   174,   215,   216,   179,   245,   334,   185,     5,
+       6,     7,     8,   184,   194,     9,   195,   226,   227,   318,
+     320,     5,     6,   234,    10,   246,   336,   406,    11,   194,
+     278,   195,   235,   236,   337,   209,   240,   265,   402,   242,
+     244,   335,   323,   247,   248,   148,   190,   366,   191,   490,
+     194,   367,   195,   262,   494,   496,   401,   484,   324,   274,
+     409,   277,   194,   263,   195,   232,   233,   266,   267,   268,
+     269,   270,   271,   232,   232,   428,   232,   232,   470,   473,
+     514,   430,   194,    84,   195,   232,   437,   251,   404,   453,
+     460,    29,    28,   407,   292,   141,   266,   267,   268,   269,
+     270,   271,   498,   156,     5,     6,   502,   469,   139,     5,
+       6,   315,   483,   272,   149,   150,   151,   152,   153,   154,
+     155,    74,    97,   501,   319,   513,   372,    81,    82,    83,
+     331,   459,   338,   232,    85,    86,    87,   104,   105,   106,
+     511,   285,   272,   109,   317,   368,   264,   477,   327,   328,
+     329,   330,    29,   321,    85,    86,    87,   400,    29,    28,
+     249,   286,   250,    88,    89,    90,    91,    92,    93,    94,
+       0,   365,   232,     0,   232,    88,    89,    90,    91,    92,
+      93,    94,   132,    88,    89,    90,    91,    92,    93,    94,
+       0,   232,   133,   134,     5,     6,     7,     8,     0,     5,
+       6,     0,     8,     0,     0,     0,     0,     8,     0,    10,
+       0,   396,    28,    11,    10,   396,    28,     0,    11,    10,
+     408,   436,     0,    11,     0,   481,   100,   101,   486,   232,
+       0,     0,   443,    85,    86,    87,     0,     0,     0,     0,
+     499,   107,   429,     0,   503,     0,   505,   434,     0,     0,
+     507,   457,     0,   458,   509,     0,   510,     0,   232,     0,
+     462,   232,    88,    89,    90,    91,    92,    93,    94,    79,
+      80,    81,    82,    83,   464,   465,     0,     0,   467,   468,
+       0,   472,    31,     0,   474,   475,     0,   145,     0,   478,
+      32,   479,     0,     0,    33,     0,   488,     0,    34,   491,
+     463,     0,     0,     0,   495,   497,     0,     0,   500,     0,
+     146,     0,   504,    40,   506,     0,   476,    31,   203,   204,
+      41,    42,    43,    44,   138,    32,     0,   142,   143,    33,
+     492,     0,   147,    34,   157,     0,     0,     0,    85,    86,
+      87,    77,    78,    79,    80,    81,    82,    83,   508,    45,
+      46,    47,    48,    49,    50,     0,    51,    52,    53,    54,
+      55,    85,    86,    87,     0,    56,    57,    88,    89,    90,
+      91,    92,    93,    94,     0,     0,    58,    59,     0,    60,
+     135,   137,   135,   135,   137,   137,     0,     0,     0,   135,
+      88,    89,    90,    91,    92,    93,    94,     0,     0,     5,
+       6,     7,     8,    85,    86,    87,     0,     0,     0,   296,
+       0,     0,     0,     0,    10,   306,     0,     0,    11,     0,
+       0,     0,   297,   298,   299,   300,   333,     0,   297,   298,
+     299,   300,    88,    89,    90,    91,    92,    93,    94,   297,
+     298,   299,   300,    31,     0,     0,     0,   301,     0,     0,
+       0,    32,     0,   301,     0,    33,     0,     0,     0,    34,
+     302,   303,   304,   305,   301,     0,   302,   303,   304,   305,
+       0,     0,     0,   418,     0,   420,     0,   302,   303,   304,
+     305,   426,    76,    77,    78,    79,    80,    81,    82,    83,
+       0,     0,     0,     0,     0,    96,     0,     0,     0,   439,
+     440,   441,   442,     0,     0,   444,   445,     0,   446,   339,
+     447,   448,   449,   450,   451,   340,   452,     0,     0,     0,
+     454,   455,   456,     0,     0,   341,   342,   343,   344,   345,
+     346,   347,   348,   349,   350,   351,   352,   353,   354,   355,
+     356,   357,   358,   359,   360,   361,   369,   362,     0,     0,
+       0,     0,   340,    63,    64,    65,    66,    67,    68,    69,
+      70,     0,   341,   342,   343,   344,   345,   346,   347,   348,
+     349,   350,   351,   352,   353,   354,   355,   356,   357,   358,
+     359,   360,   361,   405,   362,     0,     0,     0,     0,   340,
+      76,    77,    78,    79,    80,    81,    82,    83,     0,   341,
+     342,   343,   344,   345,   346,   347,   348,   349,   350,   351,
+     352,   353,   354,   355,   356,   357,   358,   359,   360,   361,
+       0,   362,   377,   378,   379,   380,     0,   382,   383,     0,
+     385,     0,   387,   388,   389,   390,   391,     0,   393,     0,
+     397,   398,   399,    76,    77,    78,    79,    80,    81,    82,
+      83,     0,     0,     0,     0,     0,   118,    88,    89,    90,
+      91,    92,    93,    94,     0,     0,   133,   134,    78,    79,
+      80,    81,    82,    83,   252,   253,   254,   255,   256,   257,
+     266,   267,   268,   269,   270,   271
+};
+
+static const yytype_int16 yycheck[] =
+{
+       3,    26,    35,     4,     1,     1,     4,     1,     3,   292,
+       4,   306,     4,     3,   322,     3,   108,     4,   258,    10,
+      11,     3,     3,     3,    60,     4,   261,    98,   109,    26,
+      26,     6,     7,     8,     9,    10,    11,   108,   333,     4,
+     280,    32,    33,    34,    90,    45,    46,   243,    94,   284,
+     179,     3,    53,    91,    92,    91,    92,     4,   366,    60,
+     108,   190,   191,     3,   110,   194,   195,    59,     0,    61,
+     108,    74,    63,    64,    65,    66,    67,    68,    69,    70,
+     276,   210,    85,    86,    87,    76,    77,    78,    79,    80,
+      81,    82,    83,   358,   402,   291,   129,   362,    91,    92,
+      94,   104,    81,    91,    92,    92,     3,    94,   102,     4,
+     108,   144,   106,   108,    79,    80,   110,   246,   108,   106,
+     108,    94,    54,   110,     4,   108,   108,   108,   108,   162,
+     163,    91,    92,   108,    96,   168,   169,   110,    70,   335,
+      60,     4,    95,   140,   141,     4,   149,   150,   151,   152,
+     153,   154,   155,   186,   187,   158,    82,     4,   161,    91,
+      92,    93,    94,   160,    59,    97,    61,   200,   201,   298,
+     299,    91,    92,   108,   106,    81,     4,     4,   110,    59,
+       3,    61,   215,   216,   313,   176,   219,     3,    90,   222,
+     223,     3,    94,   226,   227,     3,    59,    98,    61,   482,
+      59,   108,    61,   236,   487,   488,   111,     4,   110,   242,
+     108,   244,    59,   238,    61,   211,   213,    62,    63,    64,
+      65,    66,    67,   219,   220,   108,   222,   223,     3,   466,
+     513,   108,    59,     3,    61,   231,   108,   228,   367,   108,
+     108,   238,   238,   372,   277,   101,    62,    63,    64,    65,
+      66,    67,   489,     3,    91,    92,   493,   108,    16,    91,
+      92,   294,   108,   108,    72,    73,    74,    75,    76,    77,
+      78,   108,    40,   108,   299,   512,   108,   103,   104,   105,
+     305,   437,   315,   279,    54,    55,    56,    55,    56,    57,
+     108,   265,   108,    61,   297,   328,   240,   470,   301,   302,
+     303,   304,   299,   299,    54,    55,    56,   362,   305,   305,
+     228,   272,   228,    83,    84,    85,    86,    87,    88,    89,
+      -1,   324,   318,    -1,   320,    83,    84,    85,    86,    87,
+      88,    89,     3,    83,    84,    85,    86,    87,    88,    89,
+      -1,   337,    92,    93,    91,    92,    93,    94,    -1,    91,
+      92,    -1,    94,    -1,    -1,    -1,    -1,    94,    -1,   106,
+      -1,   358,   358,   110,   106,   362,   362,    -1,   110,   106,
+     373,   404,    -1,   110,    -1,   475,    43,    44,   478,   375,
+      -1,    -1,   415,    54,    55,    56,    -1,    -1,    -1,    -1,
+     490,    58,   395,    -1,   494,    -1,   496,   400,    -1,    -1,
+     500,   434,    -1,   436,   504,    -1,   506,    -1,   404,    -1,
+     443,   407,    83,    84,    85,    86,    87,    88,    89,   101,
+     102,   103,   104,   105,   457,   458,    -1,    -1,   461,   462,
+      -1,   464,    94,    -1,   467,   468,    -1,     3,    -1,   472,
+     102,   474,    -1,    -1,   106,    -1,   479,    -1,   110,   482,
+     453,    -1,    -1,    -1,   487,   488,    -1,    -1,   491,    -1,
+       3,    -1,   495,     5,   497,    -1,   469,    94,    95,    96,
+      12,    13,    14,    15,    99,   102,    -1,   102,   103,   106,
+     483,    -1,   107,   110,   109,    -1,    -1,    -1,    54,    55,
+      56,    99,   100,   101,   102,   103,   104,   105,   501,    41,
+      42,    43,    44,    45,    46,    -1,    48,    49,    50,    51,
+      52,    54,    55,    56,    -1,    57,    58,    83,    84,    85,
+      86,    87,    88,    89,    -1,    -1,    68,    69,    -1,    71,
+      98,    99,   100,   101,   102,   103,    -1,    -1,    -1,   107,
+      83,    84,    85,    86,    87,    88,    89,    -1,    -1,    91,
+      92,    93,    94,    54,    55,    56,    -1,    -1,    -1,     3,
+      -1,    -1,    -1,    -1,   106,     3,    -1,    -1,   110,    -1,
+      -1,    -1,    16,    17,    18,    19,     3,    -1,    16,    17,
+      18,    19,    83,    84,    85,    86,    87,    88,    89,    16,
+      17,    18,    19,    94,    -1,    -1,    -1,    41,    -1,    -1,
+      -1,   102,    -1,    41,    -1,   106,    -1,    -1,    -1,   110,
+      54,    55,    56,    57,    41,    -1,    54,    55,    56,    57,
+      -1,    -1,    -1,   384,    -1,   386,    -1,    54,    55,    56,
+      57,   392,    98,    99,   100,   101,   102,   103,   104,   105,
+      -1,    -1,    -1,    -1,    -1,   111,    -1,    -1,    -1,   410,
+     411,   412,   413,    -1,    -1,   416,   417,    -1,   419,     4,
+     421,   422,   423,   424,   425,    10,   427,    -1,    -1,    -1,
+     431,   432,   433,    -1,    -1,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,     4,    42,    -1,    -1,
+      -1,    -1,    10,    98,    99,   100,   101,   102,   103,   104,
+     105,    -1,    20,    21,    22,    23,    24,    25,    26,    27,
+      28,    29,    30,    31,    32,    33,    34,    35,    36,    37,
+      38,    39,    40,     4,    42,    -1,    -1,    -1,    -1,    10,
+      98,    99,   100,   101,   102,   103,   104,   105,    -1,    20,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    34,    35,    36,    37,    38,    39,    40,
+      -1,    42,   341,   342,   343,   344,    -1,   346,   347,    -1,
+     349,    -1,   351,   352,   353,   354,   355,    -1,   357,    -1,
+     359,   360,   361,    98,    99,   100,   101,   102,   103,   104,
+     105,    -1,    -1,    -1,    -1,    -1,   111,    83,    84,    85,
+      86,    87,    88,    89,    -1,    -1,    92,    93,   100,   101,
+     102,   103,   104,   105,     6,     7,     8,     9,    10,    11,
+      62,    63,    64,    65,    66,    67
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,   113,     0,    54,    70,    91,    92,    93,    94,    97,
+     106,   110,   114,   120,   121,   122,   162,   163,   164,   165,
+     170,   173,   178,   182,   183,   185,   190,   191,   199,   209,
+     210,    94,   102,   106,   110,   206,   207,   193,   207,   207,
+       5,    12,    13,    14,    15,    41,    42,    43,    44,    45,
+      46,    48,    49,    50,    51,    52,    57,    58,    68,    69,
+      71,   181,   190,    98,    99,   100,   101,   102,   103,   104,
+     105,   207,   207,   207,   108,   205,    98,    99,   100,   101,
+     102,   103,   104,   105,     3,    54,    55,    56,    83,    84,
+      85,    86,    87,    88,    89,   196,   111,   193,   195,   194,
+     195,   195,   194,   194,   193,   193,   193,   195,   186,   193,
+     207,   207,   207,   207,   207,   207,   207,   207,   111,   206,
+     207,   207,   207,   207,   207,   207,   207,   207,   179,   206,
+     206,   206,     3,    92,    93,   196,   197,   196,   197,    16,
+     126,   126,   197,   197,   206,     3,     3,   197,     3,    72,
+      73,    74,    75,    76,    77,    78,     3,   197,   180,   205,
+     115,   109,   209,   209,   205,   166,   171,   187,   206,   206,
+     206,   206,   206,   206,   206,   174,   175,     1,     4,   206,
+       4,    92,   116,   117,   209,   206,   205,   205,     3,     4,
+      59,    61,   167,     4,    59,    61,   172,     4,    79,    80,
+     205,   205,     4,    95,    96,   176,   177,   200,   201,   207,
+     108,   198,   199,   108,   208,   205,   205,   184,    60,   198,
+     198,    60,   198,   198,     3,     3,   205,   205,   108,    96,
+      95,   198,   199,   209,   108,   205,   205,     4,    53,    60,
+     205,   168,   205,     3,   205,    82,    81,   205,   205,   200,
+     201,   207,     6,     7,     8,     9,    10,    11,   118,   119,
+     123,   124,   205,   190,   168,     3,    62,    63,    64,    65,
+      66,    67,   108,   169,   205,   171,     3,   205,     3,   198,
+     108,   119,   127,   127,   125,   166,   169,   204,   205,     4,
+     171,     3,   205,   188,   189,   119,     3,    16,    17,    18,
+      19,    41,    54,    55,    56,    57,     3,   127,     4,     4,
+     171,   204,     4,    81,     4,   205,   128,   206,   198,   190,
+     198,   199,    90,    94,   110,   202,   203,   206,   206,   206,
+     206,   190,   128,     3,     4,     3,     4,   198,   205,     4,
+      10,    20,    21,    22,    23,    24,    25,    26,    27,    28,
+      29,    30,    31,    32,    33,    34,    35,    36,    37,    38,
+      39,    40,    42,   129,   203,   206,    98,   108,   205,     4,
+     128,   171,   108,   153,   154,   198,   209,   153,   153,   153,
+     153,   135,   153,   153,   138,   153,   142,   153,   153,   153,
+     153,   153,   148,   153,   191,   192,   209,   153,   153,   153,
+     192,   111,    90,   203,   198,     4,     4,   198,   206,   108,
+     130,   131,   132,   134,   151,   206,   136,   137,   151,   139,
+     151,   143,   144,   145,   146,   147,   151,   149,   108,   206,
+     108,   133,   140,   141,   206,   203,   205,   108,   152,   151,
+     151,   151,   151,   205,   151,   151,   151,   151,   151,   151,
+     151,   151,   151,   108,   151,   151,   151,   205,   205,   154,
+     108,   156,   205,   206,   205,   205,   157,   205,   205,   108,
+       3,   155,   205,   202,   205,   205,   206,   174,   205,   205,
+     108,   155,   160,   108,     4,   108,   155,   158,   205,   161,
+     204,   205,   206,   159,   204,   205,   204,   205,   202,   155,
+     205,   108,   202,   155,   205,   155,   205,   155,   206,   155,
+     155,   108,   150,   202,   204
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+#else
+static void
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+
+      default:
+	break;
+    }
+}
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*-------------------------.
+| yyparse or yypush_parse.  |
+`-------------------------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+
+
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 18:
+
+/* Line 1455 of yacc.c  */
+#line 200 "rcparse.y"
+    {
+	    define_accelerator ((yyvsp[(1) - (6)].id), &(yyvsp[(3) - (6)].res_info), (yyvsp[(5) - (6)].pacc));
+	    if (yychar != YYEMPTY)
+	      YYERROR;
+	    rcparse_discard_strings ();
+	  }
+    break;
+
+  case 19:
+
+/* Line 1455 of yacc.c  */
+#line 210 "rcparse.y"
+    {
+	    (yyval.pacc) = NULL;
+	  }
+    break;
+
+  case 20:
+
+/* Line 1455 of yacc.c  */
+#line 214 "rcparse.y"
+    {
+	    rc_accelerator *a;
+
+	    a = (rc_accelerator *) res_alloc (sizeof *a);
+	    *a = (yyvsp[(2) - (2)].acc);
+	    if ((yyvsp[(1) - (2)].pacc) == NULL)
+	      (yyval.pacc) = a;
+	    else
+	      {
+		rc_accelerator **pp;
+
+		for (pp = &(yyvsp[(1) - (2)].pacc)->next; *pp != NULL; pp = &(*pp)->next)
+		  ;
+		*pp = a;
+		(yyval.pacc) = (yyvsp[(1) - (2)].pacc);
+	      }
+	  }
+    break;
+
+  case 21:
+
+/* Line 1455 of yacc.c  */
+#line 235 "rcparse.y"
+    {
+	    (yyval.acc) = (yyvsp[(1) - (2)].acc);
+	    (yyval.acc).id = (yyvsp[(2) - (2)].il);
+	  }
+    break;
+
+  case 22:
+
+/* Line 1455 of yacc.c  */
+#line 240 "rcparse.y"
+    {
+	    (yyval.acc) = (yyvsp[(1) - (4)].acc);
+	    (yyval.acc).id = (yyvsp[(2) - (4)].il);
+	    (yyval.acc).flags |= (yyvsp[(4) - (4)].is);
+	    if (((yyval.acc).flags & ACC_VIRTKEY) == 0
+		&& ((yyval.acc).flags & (ACC_SHIFT | ACC_CONTROL)) != 0)
+	      rcparse_warning (_("inappropriate modifiers for non-VIRTKEY"));
+	  }
+    break;
+
+  case 23:
+
+/* Line 1455 of yacc.c  */
+#line 252 "rcparse.y"
+    {
+	    const char *s = (yyvsp[(1) - (1)].s);
+	    char ch;
+
+	    (yyval.acc).next = NULL;
+	    (yyval.acc).id = 0;
+	    ch = *s;
+	    if (ch != '^')
+	      (yyval.acc).flags = 0;
+	    else
+	      {
+		(yyval.acc).flags = ACC_CONTROL | ACC_VIRTKEY;
+		++s;
+		ch = TOUPPER (s[0]);
+	      }
+	    (yyval.acc).key = ch;
+	    if (s[1] != '\0')
+	      rcparse_warning (_("accelerator should only be one character"));
+	  }
+    break;
+
+  case 24:
+
+/* Line 1455 of yacc.c  */
+#line 272 "rcparse.y"
+    {
+	    (yyval.acc).next = NULL;
+	    (yyval.acc).flags = 0;
+	    (yyval.acc).id = 0;
+	    (yyval.acc).key = (yyvsp[(1) - (1)].il);
+	  }
+    break;
+
+  case 25:
+
+/* Line 1455 of yacc.c  */
+#line 282 "rcparse.y"
+    {
+	    (yyval.is) = (yyvsp[(1) - (1)].is);
+	  }
+    break;
+
+  case 26:
+
+/* Line 1455 of yacc.c  */
+#line 286 "rcparse.y"
+    {
+	    (yyval.is) = (yyvsp[(1) - (3)].is) | (yyvsp[(3) - (3)].is);
+	  }
+    break;
+
+  case 27:
+
+/* Line 1455 of yacc.c  */
+#line 291 "rcparse.y"
+    {
+	    (yyval.is) = (yyvsp[(1) - (2)].is) | (yyvsp[(2) - (2)].is);
+	  }
+    break;
+
+  case 28:
+
+/* Line 1455 of yacc.c  */
+#line 298 "rcparse.y"
+    {
+	    (yyval.is) = ACC_VIRTKEY;
+	  }
+    break;
+
+  case 29:
+
+/* Line 1455 of yacc.c  */
+#line 302 "rcparse.y"
+    {
+	    /* This is just the absence of VIRTKEY.  */
+	    (yyval.is) = 0;
+	  }
+    break;
+
+  case 30:
+
+/* Line 1455 of yacc.c  */
+#line 307 "rcparse.y"
+    {
+	    (yyval.is) = ACC_NOINVERT;
+	  }
+    break;
+
+  case 31:
+
+/* Line 1455 of yacc.c  */
+#line 311 "rcparse.y"
+    {
+	    (yyval.is) = ACC_SHIFT;
+	  }
+    break;
+
+  case 32:
+
+/* Line 1455 of yacc.c  */
+#line 315 "rcparse.y"
+    {
+	    (yyval.is) = ACC_CONTROL;
+	  }
+    break;
+
+  case 33:
+
+/* Line 1455 of yacc.c  */
+#line 319 "rcparse.y"
+    {
+	    (yyval.is) = ACC_ALT;
+	  }
+    break;
+
+  case 34:
+
+/* Line 1455 of yacc.c  */
+#line 328 "rcparse.y"
+    {
+	    define_bitmap ((yyvsp[(1) - (4)].id), &(yyvsp[(3) - (4)].res_info), (yyvsp[(4) - (4)].s));
+	    if (yychar != YYEMPTY)
+	      YYERROR;
+	    rcparse_discard_strings ();
+	  }
+    break;
+
+  case 35:
+
+/* Line 1455 of yacc.c  */
+#line 340 "rcparse.y"
+    {
+	    define_cursor ((yyvsp[(1) - (4)].id), &(yyvsp[(3) - (4)].res_info), (yyvsp[(4) - (4)].s));
+	    if (yychar != YYEMPTY)
+	      YYERROR;
+	    rcparse_discard_strings ();
+	  }
+    break;
+
+  case 36:
+
+/* Line 1455 of yacc.c  */
+#line 353 "rcparse.y"
+    {
+	      memset (&dialog, 0, sizeof dialog);
+	      dialog.x = (yyvsp[(5) - (8)].il);
+	      dialog.y = (yyvsp[(6) - (8)].il);
+	      dialog.width = (yyvsp[(7) - (8)].il);
+	      dialog.height = (yyvsp[(8) - (8)].il);
+	      dialog.style = WS_POPUP | WS_BORDER | WS_SYSMENU;
+	      dialog.exstyle = (yyvsp[(4) - (8)].il);
+	      dialog.menu.named = 1;
+	      dialog.class.named = 1;
+	      dialog.font = NULL;
+	      dialog.ex = NULL;
+	      dialog.controls = NULL;
+	      sub_res_info = (yyvsp[(3) - (8)].res_info);
+	      style = 0;
+	    }
+    break;
+
+  case 37:
+
+/* Line 1455 of yacc.c  */
+#line 370 "rcparse.y"
+    {
+	    define_dialog ((yyvsp[(1) - (13)].id), &sub_res_info, &dialog);
+	    if (yychar != YYEMPTY)
+	      YYERROR;
+	    rcparse_discard_strings ();
+	  }
+    break;
+
+  case 38:
+
+/* Line 1455 of yacc.c  */
+#line 378 "rcparse.y"
+    {
+	      memset (&dialog, 0, sizeof dialog);
+	      dialog.x = (yyvsp[(5) - (8)].il);
+	      dialog.y = (yyvsp[(6) - (8)].il);
+	      dialog.width = (yyvsp[(7) - (8)].il);
+	      dialog.height = (yyvsp[(8) - (8)].il);
+	      dialog.style = WS_POPUP | WS_BORDER | WS_SYSMENU;
+	      dialog.exstyle = (yyvsp[(4) - (8)].il);
+	      dialog.menu.named = 1;
+	      dialog.class.named = 1;
+	      dialog.font = NULL;
+	      dialog.ex = ((rc_dialog_ex *)
+			   res_alloc (sizeof (rc_dialog_ex)));
+	      memset (dialog.ex, 0, sizeof (rc_dialog_ex));
+	      dialog.controls = NULL;
+	      sub_res_info = (yyvsp[(3) - (8)].res_info);
+	      style = 0;
+	    }
+    break;
+
+  case 39:
+
+/* Line 1455 of yacc.c  */
+#line 397 "rcparse.y"
+    {
+	    define_dialog ((yyvsp[(1) - (13)].id), &sub_res_info, &dialog);
+	    if (yychar != YYEMPTY)
+	      YYERROR;
+	    rcparse_discard_strings ();
+	  }
+    break;
+
+  case 40:
+
+/* Line 1455 of yacc.c  */
+#line 405 "rcparse.y"
+    {
+	      memset (&dialog, 0, sizeof dialog);
+	      dialog.x = (yyvsp[(5) - (9)].il);
+	      dialog.y = (yyvsp[(6) - (9)].il);
+	      dialog.width = (yyvsp[(7) - (9)].il);
+	      dialog.height = (yyvsp[(8) - (9)].il);
+	      dialog.style = WS_POPUP | WS_BORDER | WS_SYSMENU;
+	      dialog.exstyle = (yyvsp[(4) - (9)].il);
+	      dialog.menu.named = 1;
+	      dialog.class.named = 1;
+	      dialog.font = NULL;
+	      dialog.ex = ((rc_dialog_ex *)
+			   res_alloc (sizeof (rc_dialog_ex)));
+	      memset (dialog.ex, 0, sizeof (rc_dialog_ex));
+	      dialog.ex->help = (yyvsp[(9) - (9)].il);
+	      dialog.controls = NULL;
+	      sub_res_info = (yyvsp[(3) - (9)].res_info);
+	      style = 0;
+	    }
+    break;
+
+  case 41:
+
+/* Line 1455 of yacc.c  */
+#line 425 "rcparse.y"
+    {
+	    define_dialog ((yyvsp[(1) - (14)].id), &sub_res_info, &dialog);
+	    if (yychar != YYEMPTY)
+	      YYERROR;
+	    rcparse_discard_strings ();
+	  }
+    break;
+
+  case 42:
+
+/* Line 1455 of yacc.c  */
+#line 435 "rcparse.y"
+    {
+	    (yyval.il) = 0;
+	  }
+    break;
+
+  case 43:
+
+/* Line 1455 of yacc.c  */
+#line 439 "rcparse.y"
+    {
+	    (yyval.il) = (yyvsp[(3) - (3)].il);
+	  }
+    break;
+
+  case 45:
+
+/* Line 1455 of yacc.c  */
+#line 447 "rcparse.y"
+    {
+	    dialog.style |= WS_CAPTION;
+	    style |= WS_CAPTION;
+	    dialog.caption = (yyvsp[(3) - (3)].uni);
+	  }
+    break;
+
+  case 46:
+
+/* Line 1455 of yacc.c  */
+#line 453 "rcparse.y"
+    {
+	    dialog.class = (yyvsp[(3) - (3)].id);
+	  }
+    break;
+
+  case 47:
+
+/* Line 1455 of yacc.c  */
+#line 458 "rcparse.y"
+    {
+	    dialog.style = style;
+	  }
+    break;
+
+  case 48:
+
+/* Line 1455 of yacc.c  */
+#line 462 "rcparse.y"
+    {
+	    dialog.exstyle = (yyvsp[(3) - (3)].il);
+	  }
+    break;
+
+  case 49:
+
+/* Line 1455 of yacc.c  */
+#line 466 "rcparse.y"
+    {
+	    res_unistring_to_id (& dialog.class, (yyvsp[(3) - (3)].uni));
+	  }
+    break;
+
+  case 50:
+
+/* Line 1455 of yacc.c  */
+#line 470 "rcparse.y"
+    {
+	    dialog.style |= DS_SETFONT;
+	    style |= DS_SETFONT;
+	    dialog.pointsize = (yyvsp[(3) - (5)].il);
+	    dialog.font = (yyvsp[(5) - (5)].uni);
+	    if (dialog.ex != NULL)
+	      {
+		dialog.ex->weight = 0;
+		dialog.ex->italic = 0;
+		dialog.ex->charset = 1;
+	      }
+	  }
+    break;
+
+  case 51:
+
+/* Line 1455 of yacc.c  */
+#line 483 "rcparse.y"
+    {
+	    dialog.style |= DS_SETFONT;
+	    style |= DS_SETFONT;
+	    dialog.pointsize = (yyvsp[(3) - (6)].il);
+	    dialog.font = (yyvsp[(5) - (6)].uni);
+	    if (dialog.ex == NULL)
+	      rcparse_warning (_("extended FONT requires DIALOGEX"));
+	    else
+	      {
+		dialog.ex->weight = (yyvsp[(6) - (6)].il);
+		dialog.ex->italic = 0;
+		dialog.ex->charset = 1;
+	      }
+	  }
+    break;
+
+  case 52:
+
+/* Line 1455 of yacc.c  */
+#line 498 "rcparse.y"
+    {
+	    dialog.style |= DS_SETFONT;
+	    style |= DS_SETFONT;
+	    dialog.pointsize = (yyvsp[(3) - (7)].il);
+	    dialog.font = (yyvsp[(5) - (7)].uni);
+	    if (dialog.ex == NULL)
+	      rcparse_warning (_("extended FONT requires DIALOGEX"));
+	    else
+	      {
+		dialog.ex->weight = (yyvsp[(6) - (7)].il);
+		dialog.ex->italic = (yyvsp[(7) - (7)].il);
+		dialog.ex->charset = 1;
+	      }
+	  }
+    break;
+
+  case 53:
+
+/* Line 1455 of yacc.c  */
+#line 513 "rcparse.y"
+    {
+	    dialog.style |= DS_SETFONT;
+	    style |= DS_SETFONT;
+	    dialog.pointsize = (yyvsp[(3) - (8)].il);
+	    dialog.font = (yyvsp[(5) - (8)].uni);
+	    if (dialog.ex == NULL)
+	      rcparse_warning (_("extended FONT requires DIALOGEX"));
+	    else
+	      {
+		dialog.ex->weight = (yyvsp[(6) - (8)].il);
+		dialog.ex->italic = (yyvsp[(7) - (8)].il);
+		dialog.ex->charset = (yyvsp[(8) - (8)].il);
+	      }
+	  }
+    break;
+
+  case 54:
+
+/* Line 1455 of yacc.c  */
+#line 528 "rcparse.y"
+    {
+	    dialog.menu = (yyvsp[(3) - (3)].id);
+	  }
+    break;
+
+  case 55:
+
+/* Line 1455 of yacc.c  */
+#line 532 "rcparse.y"
+    {
+	    sub_res_info.characteristics = (yyvsp[(3) - (3)].il);
+	  }
+    break;
+
+  case 56:
+
+/* Line 1455 of yacc.c  */
+#line 536 "rcparse.y"
+    {
+	    sub_res_info.language = (yyvsp[(3) - (4)].il) | ((yyvsp[(4) - (4)].il) << SUBLANG_SHIFT);
+	  }
+    break;
+
+  case 57:
+
+/* Line 1455 of yacc.c  */
+#line 540 "rcparse.y"
+    {
+	    sub_res_info.version = (yyvsp[(3) - (3)].il);
+	  }
+    break;
+
+  case 59:
+
+/* Line 1455 of yacc.c  */
+#line 548 "rcparse.y"
+    {
+	    rc_dialog_control **pp;
+
+	    for (pp = &dialog.controls; *pp != NULL; pp = &(*pp)->next)
+	      ;
+	    *pp = (yyvsp[(2) - (2)].dialog_control);
+	  }
+    break;
+
+  case 60:
+
+/* Line 1455 of yacc.c  */
+#line 559 "rcparse.y"
+    {
+	      default_style = BS_AUTO3STATE | WS_TABSTOP;
+	      base_style = BS_AUTO3STATE;
+	      class.named = 0;
+	      class.u.id = CTL_BUTTON;
+	      res_text_field = (yyvsp[(2) - (2)].id);	
+	    }
+    break;
+
+  case 61:
+
+/* Line 1455 of yacc.c  */
+#line 567 "rcparse.y"
+    {
+	    (yyval.dialog_control) = (yyvsp[(4) - (4)].dialog_control);
+	  }
+    break;
+
+  case 62:
+
+/* Line 1455 of yacc.c  */
+#line 571 "rcparse.y"
+    {
+	      default_style = BS_AUTOCHECKBOX | WS_TABSTOP;
+	      base_style = BS_AUTOCHECKBOX;
+	      class.named = 0;
+	      class.u.id = CTL_BUTTON;
+	      res_text_field = (yyvsp[(2) - (2)].id);	
+	    }
+    break;
+
+  case 63:
+
+/* Line 1455 of yacc.c  */
+#line 579 "rcparse.y"
+    {
+	    (yyval.dialog_control) = (yyvsp[(4) - (4)].dialog_control);
+	  }
+    break;
+
+  case 64:
+
+/* Line 1455 of yacc.c  */
+#line 583 "rcparse.y"
+    {
+	      default_style = BS_AUTORADIOBUTTON | WS_TABSTOP;
+	      base_style = BS_AUTORADIOBUTTON;
+	      class.named = 0;
+	      class.u.id = CTL_BUTTON;
+	      res_text_field = (yyvsp[(2) - (2)].id);	
+	    }
+    break;
+
+  case 65:
+
+/* Line 1455 of yacc.c  */
+#line 591 "rcparse.y"
+    {
+	    (yyval.dialog_control) = (yyvsp[(4) - (4)].dialog_control);
+	  }
+    break;
+
+  case 66:
+
+/* Line 1455 of yacc.c  */
+#line 595 "rcparse.y"
+    {
+	      default_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
+	      base_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
+	      class.named = 0;
+	      class.u.id = CTL_EDIT;
+	      res_text_field = (yyvsp[(2) - (2)].id);	
+	    }
+    break;
+
+  case 67:
+
+/* Line 1455 of yacc.c  */
+#line 603 "rcparse.y"
+    {
+	    (yyval.dialog_control) = (yyvsp[(4) - (4)].dialog_control);
+	    if (dialog.ex == NULL)
+	      rcparse_warning (_("BEDIT requires DIALOGEX"));
+	    res_string_to_id (&(yyval.dialog_control)->class, "BEDIT");
+	  }
+    break;
+
+  case 68:
+
+/* Line 1455 of yacc.c  */
+#line 610 "rcparse.y"
+    {
+	      default_style = BS_CHECKBOX | WS_TABSTOP;
+	      base_style = BS_CHECKBOX | WS_TABSTOP;
+	      class.named = 0;
+	      class.u.id = CTL_BUTTON;
+	      res_text_field = (yyvsp[(2) - (2)].id);	
+	    }
+    break;
+
+  case 69:
+
+/* Line 1455 of yacc.c  */
+#line 618 "rcparse.y"
+    {
+	    (yyval.dialog_control) = (yyvsp[(4) - (4)].dialog_control);
+	  }
+    break;
+
+  case 70:
+
+/* Line 1455 of yacc.c  */
+#line 622 "rcparse.y"
+    {
+	      /* This is as per MSDN documentation.  With some (???)
+		 versions of MS rc.exe their is no default style.  */
+	      default_style = CBS_SIMPLE | WS_TABSTOP;
+	      base_style = 0;
+	      class.named = 0;
+	      class.u.id = CTL_COMBOBOX;
+	      res_text_field = res_null_text;	
+	    }
+    break;
+
+  case 71:
+
+/* Line 1455 of yacc.c  */
+#line 632 "rcparse.y"
+    {
+	    (yyval.dialog_control) = (yyvsp[(3) - (3)].dialog_control);
+	  }
+    break;
+
+  case 72:
+
+/* Line 1455 of yacc.c  */
+#line 637 "rcparse.y"
+    {
+	    (yyval.dialog_control) = define_control ((yyvsp[(2) - (11)].id), (yyvsp[(3) - (11)].il), (yyvsp[(6) - (11)].il), (yyvsp[(7) - (11)].il), (yyvsp[(8) - (11)].il), (yyvsp[(9) - (11)].il), (yyvsp[(4) - (11)].id), style, (yyvsp[(10) - (11)].il));
+	    if ((yyvsp[(11) - (11)].rcdata_item) != NULL)
+	      {
+		if (dialog.ex == NULL)
+		  rcparse_warning (_("control data requires DIALOGEX"));
+		(yyval.dialog_control)->data = (yyvsp[(11) - (11)].rcdata_item);
+	      }
+	  }
+    break;
+
+  case 73:
+
+/* Line 1455 of yacc.c  */
+#line 648 "rcparse.y"
+    {
+	    (yyval.dialog_control) = define_control ((yyvsp[(2) - (12)].id), (yyvsp[(3) - (12)].il), (yyvsp[(6) - (12)].il), (yyvsp[(7) - (12)].il), (yyvsp[(8) - (12)].il), (yyvsp[(9) - (12)].il), (yyvsp[(4) - (12)].id), style, (yyvsp[(10) - (12)].il));
+	    if (dialog.ex == NULL)
+	      rcparse_warning (_("help ID requires DIALOGEX"));
+	    (yyval.dialog_control)->help = (yyvsp[(11) - (12)].il);
+	    (yyval.dialog_control)->data = (yyvsp[(12) - (12)].rcdata_item);
+	  }
+    break;
+
+  case 74:
+
+/* Line 1455 of yacc.c  */
+#line 656 "rcparse.y"
+    {
+	      default_style = SS_CENTER | WS_GROUP;
+	      base_style = SS_CENTER;
+	      class.named = 0;
+	      class.u.id = CTL_STATIC;
+	      res_text_field = (yyvsp[(2) - (2)].id);	
+	    }
+    break;
+
+  case 75:
+
+/* Line 1455 of yacc.c  */
+#line 664 "rcparse.y"
+    {
+	    (yyval.dialog_control) = (yyvsp[(4) - (4)].dialog_control);
+	  }
+    break;
+
+  case 76:
+
+/* Line 1455 of yacc.c  */
+#line 668 "rcparse.y"
+    {
+	      default_style = BS_DEFPUSHBUTTON | WS_TABSTOP;
+	      base_style = BS_DEFPUSHBUTTON | WS_TABSTOP;
+	      class.named = 0;
+	      class.u.id = CTL_BUTTON;
+	      res_text_field = (yyvsp[(2) - (2)].id);	
+	    }
+    break;
+
+  case 77:
+
+/* Line 1455 of yacc.c  */
+#line 676 "rcparse.y"
+    {
+	    (yyval.dialog_control) = (yyvsp[(4) - (4)].dialog_control);
+	  }
+    break;
+
+  case 78:
+
+/* Line 1455 of yacc.c  */
+#line 680 "rcparse.y"
+    {
+	      default_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
+	      base_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
+	      class.named = 0;
+	      class.u.id = CTL_EDIT;
+	      res_text_field = res_null_text;	
+	    }
+    break;
+
+  case 79:
+
+/* Line 1455 of yacc.c  */
+#line 688 "rcparse.y"
+    {
+	    (yyval.dialog_control) = (yyvsp[(3) - (3)].dialog_control);
+	  }
+    break;
+
+  case 80:
+
+/* Line 1455 of yacc.c  */
+#line 692 "rcparse.y"
+    {
+	      default_style = BS_GROUPBOX;
+	      base_style = BS_GROUPBOX;
+	      class.named = 0;
+	      class.u.id = CTL_BUTTON;
+	      res_text_field = (yyvsp[(2) - (2)].id);	
+	    }
+    break;
+
+  case 81:
+
+/* Line 1455 of yacc.c  */
+#line 700 "rcparse.y"
+    {
+	    (yyval.dialog_control) = (yyvsp[(4) - (4)].dialog_control);
+	  }
+    break;
+
+  case 82:
+
+/* Line 1455 of yacc.c  */
+#line 704 "rcparse.y"
+    {
+	      default_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
+	      base_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
+	      class.named = 0;
+	      class.u.id = CTL_EDIT;
+	      res_text_field = (yyvsp[(2) - (2)].id);	
+	    }
+    break;
+
+  case 83:
+
+/* Line 1455 of yacc.c  */
+#line 712 "rcparse.y"
+    {
+	    (yyval.dialog_control) = (yyvsp[(4) - (4)].dialog_control);
+	    if (dialog.ex == NULL)
+	      rcparse_warning (_("IEDIT requires DIALOGEX"));
+	    res_string_to_id (&(yyval.dialog_control)->class, "HEDIT");
+	  }
+    break;
+
+  case 84:
+
+/* Line 1455 of yacc.c  */
+#line 719 "rcparse.y"
+    {
+	    (yyval.dialog_control) = define_icon_control ((yyvsp[(2) - (6)].id), (yyvsp[(3) - (6)].il), (yyvsp[(4) - (6)].il), (yyvsp[(5) - (6)].il), 0, 0, 0, (yyvsp[(6) - (6)].rcdata_item),
+				      dialog.ex);
+          }
+    break;
+
+  case 85:
+
+/* Line 1455 of yacc.c  */
+#line 725 "rcparse.y"
+    {
+	    (yyval.dialog_control) = define_icon_control ((yyvsp[(2) - (8)].id), (yyvsp[(3) - (8)].il), (yyvsp[(4) - (8)].il), (yyvsp[(5) - (8)].il), 0, 0, 0, (yyvsp[(8) - (8)].rcdata_item),
+				      dialog.ex);
+          }
+    break;
+
+  case 86:
+
+/* Line 1455 of yacc.c  */
+#line 731 "rcparse.y"
+    {
+	    (yyval.dialog_control) = define_icon_control ((yyvsp[(2) - (10)].id), (yyvsp[(3) - (10)].il), (yyvsp[(4) - (10)].il), (yyvsp[(5) - (10)].il), style, (yyvsp[(9) - (10)].il), 0, (yyvsp[(10) - (10)].rcdata_item),
+				      dialog.ex);
+          }
+    break;
+
+  case 87:
+
+/* Line 1455 of yacc.c  */
+#line 737 "rcparse.y"
+    {
+	    (yyval.dialog_control) = define_icon_control ((yyvsp[(2) - (11)].id), (yyvsp[(3) - (11)].il), (yyvsp[(4) - (11)].il), (yyvsp[(5) - (11)].il), style, (yyvsp[(9) - (11)].il), (yyvsp[(10) - (11)].il), (yyvsp[(11) - (11)].rcdata_item),
+				      dialog.ex);
+          }
+    break;
+
+  case 88:
+
+/* Line 1455 of yacc.c  */
+#line 742 "rcparse.y"
+    {
+	      default_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
+	      base_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
+	      class.named = 0;
+	      class.u.id = CTL_EDIT;
+	      res_text_field = (yyvsp[(2) - (2)].id);	
+	    }
+    break;
+
+  case 89:
+
+/* Line 1455 of yacc.c  */
+#line 750 "rcparse.y"
+    {
+	    (yyval.dialog_control) = (yyvsp[(4) - (4)].dialog_control);
+	    if (dialog.ex == NULL)
+	      rcparse_warning (_("IEDIT requires DIALOGEX"));
+	    res_string_to_id (&(yyval.dialog_control)->class, "IEDIT");
+	  }
+    break;
+
+  case 90:
+
+/* Line 1455 of yacc.c  */
+#line 757 "rcparse.y"
+    {
+	      default_style = LBS_NOTIFY | WS_BORDER;
+	      base_style = LBS_NOTIFY | WS_BORDER;
+	      class.named = 0;
+	      class.u.id = CTL_LISTBOX;
+	      res_text_field = res_null_text;	
+	    }
+    break;
+
+  case 91:
+
+/* Line 1455 of yacc.c  */
+#line 765 "rcparse.y"
+    {
+	    (yyval.dialog_control) = (yyvsp[(3) - (3)].dialog_control);
+	  }
+    break;
+
+  case 92:
+
+/* Line 1455 of yacc.c  */
+#line 769 "rcparse.y"
+    {
+	      default_style = SS_LEFT | WS_GROUP;
+	      base_style = SS_LEFT;
+	      class.named = 0;
+	      class.u.id = CTL_STATIC;
+	      res_text_field = (yyvsp[(2) - (2)].id);	
+	    }
+    break;
+
+  case 93:
+
+/* Line 1455 of yacc.c  */
+#line 777 "rcparse.y"
+    {
+	    (yyval.dialog_control) = (yyvsp[(4) - (4)].dialog_control);
+	  }
+    break;
+
+  case 94:
+
+/* Line 1455 of yacc.c  */
+#line 781 "rcparse.y"
+    {
+	      default_style = BS_PUSHBOX | WS_TABSTOP;
+	      base_style = BS_PUSHBOX;
+	      class.named = 0;
+	      class.u.id = CTL_BUTTON;
+	    }
+    break;
+
+  case 95:
+
+/* Line 1455 of yacc.c  */
+#line 788 "rcparse.y"
+    {
+	    (yyval.dialog_control) = (yyvsp[(4) - (4)].dialog_control);
+	  }
+    break;
+
+  case 96:
+
+/* Line 1455 of yacc.c  */
+#line 792 "rcparse.y"
+    {
+	      default_style = BS_PUSHBUTTON | WS_TABSTOP;
+	      base_style = BS_PUSHBUTTON | WS_TABSTOP;
+	      class.named = 0;
+	      class.u.id = CTL_BUTTON;
+	      res_text_field = (yyvsp[(2) - (2)].id);	
+	    }
+    break;
+
+  case 97:
+
+/* Line 1455 of yacc.c  */
+#line 800 "rcparse.y"
+    {
+	    (yyval.dialog_control) = (yyvsp[(4) - (4)].dialog_control);
+	  }
+    break;
+
+  case 98:
+
+/* Line 1455 of yacc.c  */
+#line 804 "rcparse.y"
+    {
+	      default_style = BS_RADIOBUTTON | WS_TABSTOP;
+	      base_style = BS_RADIOBUTTON;
+	      class.named = 0;
+	      class.u.id = CTL_BUTTON;
+	      res_text_field = (yyvsp[(2) - (2)].id);	
+	    }
+    break;
+
+  case 99:
+
+/* Line 1455 of yacc.c  */
+#line 812 "rcparse.y"
+    {
+	    (yyval.dialog_control) = (yyvsp[(4) - (4)].dialog_control);
+	  }
+    break;
+
+  case 100:
+
+/* Line 1455 of yacc.c  */
+#line 816 "rcparse.y"
+    {
+	      default_style = SS_RIGHT | WS_GROUP;
+	      base_style = SS_RIGHT;
+	      class.named = 0;
+	      class.u.id = CTL_STATIC;
+	      res_text_field = (yyvsp[(2) - (2)].id);	
+	    }
+    break;
+
+  case 101:
+
+/* Line 1455 of yacc.c  */
+#line 824 "rcparse.y"
+    {
+	    (yyval.dialog_control) = (yyvsp[(4) - (4)].dialog_control);
+	  }
+    break;
+
+  case 102:
+
+/* Line 1455 of yacc.c  */
+#line 828 "rcparse.y"
+    {
+	      default_style = SBS_HORZ;
+	      base_style = 0;
+	      class.named = 0;
+	      class.u.id = CTL_SCROLLBAR;
+	      res_text_field = res_null_text;	
+	    }
+    break;
+
+  case 103:
+
+/* Line 1455 of yacc.c  */
+#line 836 "rcparse.y"
+    {
+	    (yyval.dialog_control) = (yyvsp[(3) - (3)].dialog_control);
+	  }
+    break;
+
+  case 104:
+
+/* Line 1455 of yacc.c  */
+#line 840 "rcparse.y"
+    {
+	      default_style = BS_3STATE | WS_TABSTOP;
+	      base_style = BS_3STATE;
+	      class.named = 0;
+	      class.u.id = CTL_BUTTON;
+	      res_text_field = (yyvsp[(2) - (2)].id);	
+	    }
+    break;
+
+  case 105:
+
+/* Line 1455 of yacc.c  */
+#line 848 "rcparse.y"
+    {
+	    (yyval.dialog_control) = (yyvsp[(4) - (4)].dialog_control);
+	  }
+    break;
+
+  case 106:
+
+/* Line 1455 of yacc.c  */
+#line 853 "rcparse.y"
+    { style = WS_CHILD | WS_VISIBLE; }
+    break;
+
+  case 107:
+
+/* Line 1455 of yacc.c  */
+#line 855 "rcparse.y"
+    {
+	    rc_res_id cid;
+	    cid.named = 0;
+	    cid.u.id = CTL_BUTTON;
+	    (yyval.dialog_control) = define_control ((yyvsp[(2) - (15)].id), (yyvsp[(3) - (15)].il), (yyvsp[(5) - (15)].il), (yyvsp[(7) - (15)].il), (yyvsp[(9) - (15)].il), (yyvsp[(11) - (15)].il), cid,
+				 style, (yyvsp[(15) - (15)].il));
+	  }
+    break;
+
+  case 108:
+
+/* Line 1455 of yacc.c  */
+#line 873 "rcparse.y"
+    {
+	    (yyval.dialog_control) = define_control (res_text_field, (yyvsp[(1) - (6)].il), (yyvsp[(2) - (6)].il), (yyvsp[(3) - (6)].il), (yyvsp[(4) - (6)].il), (yyvsp[(5) - (6)].il), class,
+				 default_style | WS_CHILD | WS_VISIBLE, 0);
+	    if ((yyvsp[(6) - (6)].rcdata_item) != NULL)
+	      {
+		if (dialog.ex == NULL)
+		  rcparse_warning (_("control data requires DIALOGEX"));
+		(yyval.dialog_control)->data = (yyvsp[(6) - (6)].rcdata_item);
+	      }
+	  }
+    break;
+
+  case 109:
+
+/* Line 1455 of yacc.c  */
+#line 885 "rcparse.y"
+    {
+	    (yyval.dialog_control) = define_control (res_text_field, (yyvsp[(1) - (8)].il), (yyvsp[(2) - (8)].il), (yyvsp[(3) - (8)].il), (yyvsp[(4) - (8)].il), (yyvsp[(5) - (8)].il), class, style, (yyvsp[(7) - (8)].il));
+	    if ((yyvsp[(8) - (8)].rcdata_item) != NULL)
+	      {
+		if (dialog.ex == NULL)
+		  rcparse_warning (_("control data requires DIALOGEX"));
+		(yyval.dialog_control)->data = (yyvsp[(8) - (8)].rcdata_item);
+	      }
+	  }
+    break;
+
+  case 110:
+
+/* Line 1455 of yacc.c  */
+#line 896 "rcparse.y"
+    {
+	    (yyval.dialog_control) = define_control (res_text_field, (yyvsp[(1) - (9)].il), (yyvsp[(2) - (9)].il), (yyvsp[(3) - (9)].il), (yyvsp[(4) - (9)].il), (yyvsp[(5) - (9)].il), class, style, (yyvsp[(7) - (9)].il));
+	    if (dialog.ex == NULL)
+	      rcparse_warning (_("help ID requires DIALOGEX"));
+	    (yyval.dialog_control)->help = (yyvsp[(8) - (9)].il);
+	    (yyval.dialog_control)->data = (yyvsp[(9) - (9)].rcdata_item);
+	  }
+    break;
+
+  case 111:
+
+/* Line 1455 of yacc.c  */
+#line 907 "rcparse.y"
+    {
+	    if ((yyvsp[(2) - (2)].id).named)
+	      res_unistring_to_id (&(yyval.id), (yyvsp[(2) - (2)].id).u.n.name);
+	    else
+	      (yyval.id)=(yyvsp[(2) - (2)].id);
+	  }
+    break;
+
+  case 112:
+
+/* Line 1455 of yacc.c  */
+#line 917 "rcparse.y"
+    {
+	    res_string_to_id (&(yyval.id), "");
+	  }
+    break;
+
+  case 113:
+
+/* Line 1455 of yacc.c  */
+#line 920 "rcparse.y"
+    { (yyval.id)=(yyvsp[(1) - (2)].id); }
+    break;
+
+  case 114:
+
+/* Line 1455 of yacc.c  */
+#line 925 "rcparse.y"
+    {
+	    (yyval.id).named = 0;
+	    (yyval.id).u.id = (yyvsp[(1) - (1)].il);
+	  }
+    break;
+
+  case 115:
+
+/* Line 1455 of yacc.c  */
+#line 930 "rcparse.y"
+    {
+	    (yyval.id).named = 1;
+	    (yyval.id).u.n.name = (yyvsp[(1) - (1)].uni);
+	    (yyval.id).u.n.length = unichar_len ((yyvsp[(1) - (1)].uni));
+	  }
+    break;
+
+  case 116:
+
+/* Line 1455 of yacc.c  */
+#line 939 "rcparse.y"
+    {
+	    (yyval.rcdata_item) = NULL;
+	  }
+    break;
+
+  case 117:
+
+/* Line 1455 of yacc.c  */
+#line 943 "rcparse.y"
+    {
+	    (yyval.rcdata_item) = (yyvsp[(2) - (3)].rcdata).first;
+	  }
+    break;
+
+  case 118:
+
+/* Line 1455 of yacc.c  */
+#line 952 "rcparse.y"
+    { style = WS_CHILD | WS_VISIBLE; }
+    break;
+
+  case 120:
+
+/* Line 1455 of yacc.c  */
+#line 958 "rcparse.y"
+    { style = SS_ICON | WS_CHILD | WS_VISIBLE; }
+    break;
+
+  case 122:
+
+/* Line 1455 of yacc.c  */
+#line 964 "rcparse.y"
+    { style = base_style | WS_CHILD | WS_VISIBLE; }
+    break;
+
+  case 124:
+
+/* Line 1455 of yacc.c  */
+#line 972 "rcparse.y"
+    {
+	    define_font ((yyvsp[(1) - (4)].id), &(yyvsp[(3) - (4)].res_info), (yyvsp[(4) - (4)].s));
+	    if (yychar != YYEMPTY)
+	      YYERROR;
+	    rcparse_discard_strings ();
+	  }
+    break;
+
+  case 125:
+
+/* Line 1455 of yacc.c  */
+#line 984 "rcparse.y"
+    {
+	    define_icon ((yyvsp[(1) - (4)].id), &(yyvsp[(3) - (4)].res_info), (yyvsp[(4) - (4)].s));
+	    if (yychar != YYEMPTY)
+	      YYERROR;
+	    rcparse_discard_strings ();
+	  }
+    break;
+
+  case 126:
+
+/* Line 1455 of yacc.c  */
+#line 997 "rcparse.y"
+    {
+	    language = (yyvsp[(2) - (3)].il) | ((yyvsp[(3) - (3)].il) << SUBLANG_SHIFT);
+	  }
+    break;
+
+  case 127:
+
+/* Line 1455 of yacc.c  */
+#line 1006 "rcparse.y"
+    {
+	    define_menu ((yyvsp[(1) - (6)].id), &(yyvsp[(3) - (6)].res_info), (yyvsp[(5) - (6)].menuitem));
+	    if (yychar != YYEMPTY)
+	      YYERROR;
+	    rcparse_discard_strings ();
+	  }
+    break;
+
+  case 128:
+
+/* Line 1455 of yacc.c  */
+#line 1016 "rcparse.y"
+    {
+	    (yyval.menuitem) = NULL;
+	  }
+    break;
+
+  case 129:
+
+/* Line 1455 of yacc.c  */
+#line 1020 "rcparse.y"
+    {
+	    if ((yyvsp[(1) - (2)].menuitem) == NULL)
+	      (yyval.menuitem) = (yyvsp[(2) - (2)].menuitem);
+	    else
+	      {
+		rc_menuitem **pp;
+
+		for (pp = &(yyvsp[(1) - (2)].menuitem)->next; *pp != NULL; pp = &(*pp)->next)
+		  ;
+		*pp = (yyvsp[(2) - (2)].menuitem);
+		(yyval.menuitem) = (yyvsp[(1) - (2)].menuitem);
+	      }
+	  }
+    break;
+
+  case 130:
+
+/* Line 1455 of yacc.c  */
+#line 1037 "rcparse.y"
+    {
+	    (yyval.menuitem) = define_menuitem ((yyvsp[(2) - (4)].uni), (yyvsp[(3) - (4)].il), (yyvsp[(4) - (4)].is), 0, 0, NULL);
+	  }
+    break;
+
+  case 131:
+
+/* Line 1455 of yacc.c  */
+#line 1041 "rcparse.y"
+    {
+	    (yyval.menuitem) = define_menuitem (NULL, 0, 0, 0, 0, NULL);
+	  }
+    break;
+
+  case 132:
+
+/* Line 1455 of yacc.c  */
+#line 1045 "rcparse.y"
+    {
+	    (yyval.menuitem) = define_menuitem ((yyvsp[(2) - (6)].uni), 0, (yyvsp[(3) - (6)].is), 0, 0, (yyvsp[(5) - (6)].menuitem));
+	  }
+    break;
+
+  case 133:
+
+/* Line 1455 of yacc.c  */
+#line 1052 "rcparse.y"
+    {
+	    (yyval.is) = 0;
+	  }
+    break;
+
+  case 134:
+
+/* Line 1455 of yacc.c  */
+#line 1056 "rcparse.y"
+    {
+	    (yyval.is) = (yyvsp[(1) - (3)].is) | (yyvsp[(3) - (3)].is);
+	  }
+    break;
+
+  case 135:
+
+/* Line 1455 of yacc.c  */
+#line 1060 "rcparse.y"
+    {
+	    (yyval.is) = (yyvsp[(1) - (2)].is) | (yyvsp[(2) - (2)].is);
+	  }
+    break;
+
+  case 136:
+
+/* Line 1455 of yacc.c  */
+#line 1067 "rcparse.y"
+    {
+	    (yyval.is) = MENUITEM_CHECKED;
+	  }
+    break;
+
+  case 137:
+
+/* Line 1455 of yacc.c  */
+#line 1071 "rcparse.y"
+    {
+	    (yyval.is) = MENUITEM_GRAYED;
+	  }
+    break;
+
+  case 138:
+
+/* Line 1455 of yacc.c  */
+#line 1075 "rcparse.y"
+    {
+	    (yyval.is) = MENUITEM_HELP;
+	  }
+    break;
+
+  case 139:
+
+/* Line 1455 of yacc.c  */
+#line 1079 "rcparse.y"
+    {
+	    (yyval.is) = MENUITEM_INACTIVE;
+	  }
+    break;
+
+  case 140:
+
+/* Line 1455 of yacc.c  */
+#line 1083 "rcparse.y"
+    {
+	    (yyval.is) = MENUITEM_MENUBARBREAK;
+	  }
+    break;
+
+  case 141:
+
+/* Line 1455 of yacc.c  */
+#line 1087 "rcparse.y"
+    {
+	    (yyval.is) = MENUITEM_MENUBREAK;
+	  }
+    break;
+
+  case 142:
+
+/* Line 1455 of yacc.c  */
+#line 1096 "rcparse.y"
+    {
+	    define_menu ((yyvsp[(1) - (6)].id), &(yyvsp[(3) - (6)].res_info), (yyvsp[(5) - (6)].menuitem));
+	    if (yychar != YYEMPTY)
+	      YYERROR;
+	    rcparse_discard_strings ();
+	  }
+    break;
+
+  case 143:
+
+/* Line 1455 of yacc.c  */
+#line 1106 "rcparse.y"
+    {
+	    (yyval.menuitem) = NULL;
+	  }
+    break;
+
+  case 144:
+
+/* Line 1455 of yacc.c  */
+#line 1110 "rcparse.y"
+    {
+	    if ((yyvsp[(1) - (2)].menuitem) == NULL)
+	      (yyval.menuitem) = (yyvsp[(2) - (2)].menuitem);
+	    else
+	      {
+		rc_menuitem **pp;
+
+		for (pp = &(yyvsp[(1) - (2)].menuitem)->next; *pp != NULL; pp = &(*pp)->next)
+		  ;
+		*pp = (yyvsp[(2) - (2)].menuitem);
+		(yyval.menuitem) = (yyvsp[(1) - (2)].menuitem);
+	      }
+	  }
+    break;
+
+  case 145:
+
+/* Line 1455 of yacc.c  */
+#line 1127 "rcparse.y"
+    {
+	    (yyval.menuitem) = define_menuitem ((yyvsp[(2) - (2)].uni), 0, 0, 0, 0, NULL);
+	  }
+    break;
+
+  case 146:
+
+/* Line 1455 of yacc.c  */
+#line 1131 "rcparse.y"
+    {
+	    (yyval.menuitem) = define_menuitem ((yyvsp[(2) - (3)].uni), (yyvsp[(3) - (3)].il), 0, 0, 0, NULL);
+	  }
+    break;
+
+  case 147:
+
+/* Line 1455 of yacc.c  */
+#line 1135 "rcparse.y"
+    {
+	    (yyval.menuitem) = define_menuitem ((yyvsp[(2) - (5)].uni), (yyvsp[(3) - (5)].il), (yyvsp[(4) - (5)].il), (yyvsp[(5) - (5)].il), 0, NULL);
+	  }
+    break;
+
+  case 148:
+
+/* Line 1455 of yacc.c  */
+#line 1139 "rcparse.y"
+    {
+ 	    (yyval.menuitem) = define_menuitem (NULL, 0, 0, 0, 0, NULL);
+ 	  }
+    break;
+
+  case 149:
+
+/* Line 1455 of yacc.c  */
+#line 1143 "rcparse.y"
+    {
+	    (yyval.menuitem) = define_menuitem ((yyvsp[(2) - (5)].uni), 0, 0, 0, 0, (yyvsp[(4) - (5)].menuitem));
+	  }
+    break;
+
+  case 150:
+
+/* Line 1455 of yacc.c  */
+#line 1147 "rcparse.y"
+    {
+	    (yyval.menuitem) = define_menuitem ((yyvsp[(2) - (6)].uni), (yyvsp[(3) - (6)].il), 0, 0, 0, (yyvsp[(5) - (6)].menuitem));
+	  }
+    break;
+
+  case 151:
+
+/* Line 1455 of yacc.c  */
+#line 1151 "rcparse.y"
+    {
+	    (yyval.menuitem) = define_menuitem ((yyvsp[(2) - (7)].uni), (yyvsp[(3) - (7)].il), (yyvsp[(4) - (7)].il), 0, 0, (yyvsp[(6) - (7)].menuitem));
+	  }
+    break;
+
+  case 152:
+
+/* Line 1455 of yacc.c  */
+#line 1156 "rcparse.y"
+    {
+	    (yyval.menuitem) = define_menuitem ((yyvsp[(2) - (9)].uni), (yyvsp[(3) - (9)].il), (yyvsp[(4) - (9)].il), (yyvsp[(5) - (9)].il), (yyvsp[(6) - (9)].il), (yyvsp[(8) - (9)].menuitem));
+	  }
+    break;
+
+  case 153:
+
+/* Line 1455 of yacc.c  */
+#line 1165 "rcparse.y"
+    {
+	    define_messagetable ((yyvsp[(1) - (4)].id), &(yyvsp[(3) - (4)].res_info), (yyvsp[(4) - (4)].s));
+	    if (yychar != YYEMPTY)
+	      YYERROR;
+	    rcparse_discard_strings ();
+	  }
+    break;
+
+  case 154:
+
+/* Line 1455 of yacc.c  */
+#line 1177 "rcparse.y"
+    {
+	    rcparse_rcdata ();
+	  }
+    break;
+
+  case 155:
+
+/* Line 1455 of yacc.c  */
+#line 1181 "rcparse.y"
+    {
+	    rcparse_normal ();
+	    (yyval.rcdata) = (yyvsp[(2) - (2)].rcdata);
+	  }
+    break;
+
+  case 156:
+
+/* Line 1455 of yacc.c  */
+#line 1189 "rcparse.y"
+    {
+	    (yyval.rcdata).first = NULL;
+	    (yyval.rcdata).last = NULL;
+	  }
+    break;
+
+  case 157:
+
+/* Line 1455 of yacc.c  */
+#line 1194 "rcparse.y"
+    {
+	    (yyval.rcdata) = (yyvsp[(1) - (1)].rcdata);
+	  }
+    break;
+
+  case 158:
+
+/* Line 1455 of yacc.c  */
+#line 1201 "rcparse.y"
+    {
+	    rc_rcdata_item *ri;
+
+	    ri = define_rcdata_string ((yyvsp[(1) - (1)].ss).s, (yyvsp[(1) - (1)].ss).length);
+	    (yyval.rcdata).first = ri;
+	    (yyval.rcdata).last = ri;
+	  }
+    break;
+
+  case 159:
+
+/* Line 1455 of yacc.c  */
+#line 1209 "rcparse.y"
+    {
+	    rc_rcdata_item *ri;
+
+	    ri = define_rcdata_unistring ((yyvsp[(1) - (1)].suni).s, (yyvsp[(1) - (1)].suni).length);
+	    (yyval.rcdata).first = ri;
+	    (yyval.rcdata).last = ri;
+	  }
+    break;
+
+  case 160:
+
+/* Line 1455 of yacc.c  */
+#line 1217 "rcparse.y"
+    {
+	    rc_rcdata_item *ri;
+
+	    ri = define_rcdata_number ((yyvsp[(1) - (1)].i).val, (yyvsp[(1) - (1)].i).dword);
+	    (yyval.rcdata).first = ri;
+	    (yyval.rcdata).last = ri;
+	  }
+    break;
+
+  case 161:
+
+/* Line 1455 of yacc.c  */
+#line 1225 "rcparse.y"
+    {
+	    rc_rcdata_item *ri;
+
+	    ri = define_rcdata_string ((yyvsp[(3) - (3)].ss).s, (yyvsp[(3) - (3)].ss).length);
+	    (yyval.rcdata).first = (yyvsp[(1) - (3)].rcdata).first;
+	    (yyvsp[(1) - (3)].rcdata).last->next = ri;
+	    (yyval.rcdata).last = ri;
+	  }
+    break;
+
+  case 162:
+
+/* Line 1455 of yacc.c  */
+#line 1234 "rcparse.y"
+    {
+	    rc_rcdata_item *ri;
+
+	    ri = define_rcdata_unistring ((yyvsp[(3) - (3)].suni).s, (yyvsp[(3) - (3)].suni).length);
+	    (yyval.rcdata).first = (yyvsp[(1) - (3)].rcdata).first;
+	    (yyvsp[(1) - (3)].rcdata).last->next = ri;
+	    (yyval.rcdata).last = ri;
+	  }
+    break;
+
+  case 163:
+
+/* Line 1455 of yacc.c  */
+#line 1243 "rcparse.y"
+    {
+	    rc_rcdata_item *ri;
+
+	    ri = define_rcdata_number ((yyvsp[(3) - (3)].i).val, (yyvsp[(3) - (3)].i).dword);
+	    (yyval.rcdata).first = (yyvsp[(1) - (3)].rcdata).first;
+	    (yyvsp[(1) - (3)].rcdata).last->next = ri;
+	    (yyval.rcdata).last = ri;
+	  }
+    break;
+
+  case 164:
+
+/* Line 1455 of yacc.c  */
+#line 1252 "rcparse.y"
+    {
+	    (yyval.rcdata)=(yyvsp[(1) - (2)].rcdata);
+	  }
+    break;
+
+  case 165:
+
+/* Line 1455 of yacc.c  */
+#line 1261 "rcparse.y"
+    { sub_res_info = (yyvsp[(2) - (3)].res_info); }
+    break;
+
+  case 168:
+
+/* Line 1455 of yacc.c  */
+#line 1268 "rcparse.y"
+    {
+	    define_stringtable (&sub_res_info, (yyvsp[(2) - (3)].il), (yyvsp[(3) - (3)].uni));
+	    rcparse_discard_strings ();
+	  }
+    break;
+
+  case 169:
+
+/* Line 1455 of yacc.c  */
+#line 1273 "rcparse.y"
+    {
+	    define_stringtable (&sub_res_info, (yyvsp[(2) - (4)].il), (yyvsp[(4) - (4)].uni));
+	    rcparse_discard_strings ();
+	  }
+    break;
+
+  case 170:
+
+/* Line 1455 of yacc.c  */
+#line 1278 "rcparse.y"
+    {
+	    rcparse_warning (_("invalid stringtable resource."));
+	    abort ();
+	  }
+    break;
+
+  case 171:
+
+/* Line 1455 of yacc.c  */
+#line 1286 "rcparse.y"
+    {
+	    (yyval.id)=(yyvsp[(1) - (1)].id);
+	  }
+    break;
+
+  case 172:
+
+/* Line 1455 of yacc.c  */
+#line 1290 "rcparse.y"
+    {
+	  (yyval.id).named = 0;
+	  (yyval.id).u.id = 23;
+	}
+    break;
+
+  case 173:
+
+/* Line 1455 of yacc.c  */
+#line 1295 "rcparse.y"
+    {
+          (yyval.id).named = 0;
+          (yyval.id).u.id = RT_RCDATA;
+        }
+    break;
+
+  case 174:
+
+/* Line 1455 of yacc.c  */
+#line 1300 "rcparse.y"
+    {
+          (yyval.id).named = 0;
+          (yyval.id).u.id = RT_MANIFEST;
+        }
+    break;
+
+  case 175:
+
+/* Line 1455 of yacc.c  */
+#line 1305 "rcparse.y"
+    {
+          (yyval.id).named = 0;
+          (yyval.id).u.id = RT_PLUGPLAY;
+        }
+    break;
+
+  case 176:
+
+/* Line 1455 of yacc.c  */
+#line 1310 "rcparse.y"
+    {
+          (yyval.id).named = 0;
+          (yyval.id).u.id = RT_VXD;
+        }
+    break;
+
+  case 177:
+
+/* Line 1455 of yacc.c  */
+#line 1315 "rcparse.y"
+    {
+          (yyval.id).named = 0;
+          (yyval.id).u.id = RT_DLGINCLUDE;
+        }
+    break;
+
+  case 178:
+
+/* Line 1455 of yacc.c  */
+#line 1320 "rcparse.y"
+    {
+          (yyval.id).named = 0;
+          (yyval.id).u.id = RT_DLGINIT;
+        }
+    break;
+
+  case 179:
+
+/* Line 1455 of yacc.c  */
+#line 1325 "rcparse.y"
+    {
+          (yyval.id).named = 0;
+          (yyval.id).u.id = RT_ANICURSOR;
+        }
+    break;
+
+  case 180:
+
+/* Line 1455 of yacc.c  */
+#line 1330 "rcparse.y"
+    {
+          (yyval.id).named = 0;
+          (yyval.id).u.id = RT_ANIICON;
+        }
+    break;
+
+  case 181:
+
+/* Line 1455 of yacc.c  */
+#line 1341 "rcparse.y"
+    {
+	    define_user_data ((yyvsp[(1) - (6)].id), (yyvsp[(2) - (6)].id), &(yyvsp[(3) - (6)].res_info), (yyvsp[(5) - (6)].rcdata).first);
+	    if (yychar != YYEMPTY)
+	      YYERROR;
+	    rcparse_discard_strings ();
+	  }
+    break;
+
+  case 182:
+
+/* Line 1455 of yacc.c  */
+#line 1348 "rcparse.y"
+    {
+	    define_user_file ((yyvsp[(1) - (4)].id), (yyvsp[(2) - (4)].id), &(yyvsp[(3) - (4)].res_info), (yyvsp[(4) - (4)].s));
+	    if (yychar != YYEMPTY)
+	      YYERROR;
+	    rcparse_discard_strings ();
+	  }
+    break;
+
+  case 183:
+
+/* Line 1455 of yacc.c  */
+#line 1358 "rcparse.y"
+    {
+	  define_toolbar ((yyvsp[(1) - (8)].id), &(yyvsp[(3) - (8)].res_info), (yyvsp[(4) - (8)].il), (yyvsp[(5) - (8)].il), (yyvsp[(7) - (8)].toobar_item));
+	}
+    break;
+
+  case 184:
+
+/* Line 1455 of yacc.c  */
+#line 1363 "rcparse.y"
+    { (yyval.toobar_item)= NULL; }
+    break;
+
+  case 185:
+
+/* Line 1455 of yacc.c  */
+#line 1365 "rcparse.y"
+    {
+	  rc_toolbar_item *c,*n;
+	  c = (yyvsp[(1) - (3)].toobar_item);
+	  n= (rc_toolbar_item *)
+	      res_alloc (sizeof (rc_toolbar_item));
+	  if (c != NULL)
+	    while (c->next != NULL)
+	      c = c->next;
+	  n->prev = c;
+	  n->next = NULL;
+	  if (c != NULL)
+	    c->next = n;
+	  n->id = (yyvsp[(3) - (3)].id);
+	  if ((yyvsp[(1) - (3)].toobar_item) == NULL)
+	    (yyval.toobar_item) = n;
+	  else
+	    (yyval.toobar_item) = (yyvsp[(1) - (3)].toobar_item);
+	}
+    break;
+
+  case 186:
+
+/* Line 1455 of yacc.c  */
+#line 1384 "rcparse.y"
+    {
+	  rc_toolbar_item *c,*n;
+	  c = (yyvsp[(1) - (2)].toobar_item);
+	  n= (rc_toolbar_item *)
+	      res_alloc (sizeof (rc_toolbar_item));
+	  if (c != NULL)
+	    while (c->next != NULL)
+	      c = c->next;
+	  n->prev = c;
+	  n->next = NULL;
+	  if (c != NULL)
+	    c->next = n;
+	  n->id.named = 0;
+	  n->id.u.id = 0;
+	  if ((yyvsp[(1) - (2)].toobar_item) == NULL)
+	    (yyval.toobar_item) = n;
+	  else
+	    (yyval.toobar_item) = (yyvsp[(1) - (2)].toobar_item);
+	}
+    break;
+
+  case 187:
+
+/* Line 1455 of yacc.c  */
+#line 1409 "rcparse.y"
+    {
+	    define_versioninfo ((yyvsp[(1) - (6)].id), language, (yyvsp[(3) - (6)].fixver), (yyvsp[(5) - (6)].verinfo));
+	    if (yychar != YYEMPTY)
+	      YYERROR;
+	    rcparse_discard_strings ();
+	  }
+    break;
+
+  case 188:
+
+/* Line 1455 of yacc.c  */
+#line 1419 "rcparse.y"
+    {
+	    (yyval.fixver) = ((rc_fixed_versioninfo *)
+		  res_alloc (sizeof (rc_fixed_versioninfo)));
+	    memset ((yyval.fixver), 0, sizeof (rc_fixed_versioninfo));
+	  }
+    break;
+
+  case 189:
+
+/* Line 1455 of yacc.c  */
+#line 1425 "rcparse.y"
+    {
+	    (yyvsp[(1) - (6)].fixver)->file_version_ms = ((yyvsp[(3) - (6)].il) << 16) | (yyvsp[(4) - (6)].il);
+	    (yyvsp[(1) - (6)].fixver)->file_version_ls = ((yyvsp[(5) - (6)].il) << 16) | (yyvsp[(6) - (6)].il);
+	    (yyval.fixver) = (yyvsp[(1) - (6)].fixver);
+	  }
+    break;
+
+  case 190:
+
+/* Line 1455 of yacc.c  */
+#line 1431 "rcparse.y"
+    {
+	    (yyvsp[(1) - (6)].fixver)->product_version_ms = ((yyvsp[(3) - (6)].il) << 16) | (yyvsp[(4) - (6)].il);
+	    (yyvsp[(1) - (6)].fixver)->product_version_ls = ((yyvsp[(5) - (6)].il) << 16) | (yyvsp[(6) - (6)].il);
+	    (yyval.fixver) = (yyvsp[(1) - (6)].fixver);
+	  }
+    break;
+
+  case 191:
+
+/* Line 1455 of yacc.c  */
+#line 1437 "rcparse.y"
+    {
+	    (yyvsp[(1) - (3)].fixver)->file_flags_mask = (yyvsp[(3) - (3)].il);
+	    (yyval.fixver) = (yyvsp[(1) - (3)].fixver);
+	  }
+    break;
+
+  case 192:
+
+/* Line 1455 of yacc.c  */
+#line 1442 "rcparse.y"
+    {
+	    (yyvsp[(1) - (3)].fixver)->file_flags = (yyvsp[(3) - (3)].il);
+	    (yyval.fixver) = (yyvsp[(1) - (3)].fixver);
+	  }
+    break;
+
+  case 193:
+
+/* Line 1455 of yacc.c  */
+#line 1447 "rcparse.y"
+    {
+	    (yyvsp[(1) - (3)].fixver)->file_os = (yyvsp[(3) - (3)].il);
+	    (yyval.fixver) = (yyvsp[(1) - (3)].fixver);
+	  }
+    break;
+
+  case 194:
+
+/* Line 1455 of yacc.c  */
+#line 1452 "rcparse.y"
+    {
+	    (yyvsp[(1) - (3)].fixver)->file_type = (yyvsp[(3) - (3)].il);
+	    (yyval.fixver) = (yyvsp[(1) - (3)].fixver);
+	  }
+    break;
+
+  case 195:
+
+/* Line 1455 of yacc.c  */
+#line 1457 "rcparse.y"
+    {
+	    (yyvsp[(1) - (3)].fixver)->file_subtype = (yyvsp[(3) - (3)].il);
+	    (yyval.fixver) = (yyvsp[(1) - (3)].fixver);
+	  }
+    break;
+
+  case 196:
+
+/* Line 1455 of yacc.c  */
+#line 1471 "rcparse.y"
+    {
+	    (yyval.verinfo) = NULL;
+	  }
+    break;
+
+  case 197:
+
+/* Line 1455 of yacc.c  */
+#line 1475 "rcparse.y"
+    {
+	    (yyval.verinfo) = append_ver_stringfileinfo ((yyvsp[(1) - (8)].verinfo), (yyvsp[(4) - (8)].s), (yyvsp[(6) - (8)].verstring));
+	  }
+    break;
+
+  case 198:
+
+/* Line 1455 of yacc.c  */
+#line 1479 "rcparse.y"
+    {
+	    (yyval.verinfo) = append_ver_varfileinfo ((yyvsp[(1) - (7)].verinfo), (yyvsp[(5) - (7)].uni), (yyvsp[(6) - (7)].vervar));
+	  }
+    break;
+
+  case 199:
+
+/* Line 1455 of yacc.c  */
+#line 1486 "rcparse.y"
+    {
+	    (yyval.verstring) = NULL;
+	  }
+    break;
+
+  case 200:
+
+/* Line 1455 of yacc.c  */
+#line 1490 "rcparse.y"
+    {
+	    (yyval.verstring) = append_verval ((yyvsp[(1) - (5)].verstring), (yyvsp[(3) - (5)].uni), (yyvsp[(5) - (5)].uni));
+	  }
+    break;
+
+  case 201:
+
+/* Line 1455 of yacc.c  */
+#line 1497 "rcparse.y"
+    {
+	    (yyval.vervar) = NULL;
+	  }
+    break;
+
+  case 202:
+
+/* Line 1455 of yacc.c  */
+#line 1501 "rcparse.y"
+    {
+	    (yyval.vervar) = append_vertrans ((yyvsp[(1) - (3)].vervar), (yyvsp[(2) - (3)].il), (yyvsp[(3) - (3)].il));
+	  }
+    break;
+
+  case 203:
+
+/* Line 1455 of yacc.c  */
+#line 1510 "rcparse.y"
+    {
+	    (yyval.id).named = 0;
+	    (yyval.id).u.id = (yyvsp[(1) - (1)].il);
+	  }
+    break;
+
+  case 204:
+
+/* Line 1455 of yacc.c  */
+#line 1515 "rcparse.y"
+    {
+	    res_unistring_to_id (&(yyval.id), (yyvsp[(1) - (1)].uni));
+	  }
+    break;
+
+  case 205:
+
+/* Line 1455 of yacc.c  */
+#line 1524 "rcparse.y"
+    {
+	    (yyval.uni) = (yyvsp[(1) - (1)].uni);
+	  }
+    break;
+
+  case 206:
+
+/* Line 1455 of yacc.c  */
+#line 1528 "rcparse.y"
+    {
+	    unichar *h = NULL;
+	    unicode_from_ascii ((rc_uint_type *) NULL, &h, (yyvsp[(1) - (1)].s));
+	    (yyval.uni) = h;
+	  }
+    break;
+
+  case 207:
+
+/* Line 1455 of yacc.c  */
+#line 1538 "rcparse.y"
+    {
+	    (yyval.id).named = 0;
+	    (yyval.id).u.id = (yyvsp[(1) - (2)].il);
+	  }
+    break;
+
+  case 208:
+
+/* Line 1455 of yacc.c  */
+#line 1543 "rcparse.y"
+    {
+	    res_unistring_to_id (&(yyval.id), (yyvsp[(1) - (1)].uni));
+	  }
+    break;
+
+  case 209:
+
+/* Line 1455 of yacc.c  */
+#line 1547 "rcparse.y"
+    {
+	    res_unistring_to_id (&(yyval.id), (yyvsp[(1) - (2)].uni));
+	  }
+    break;
+
+  case 210:
+
+/* Line 1455 of yacc.c  */
+#line 1557 "rcparse.y"
+    {
+	    memset (&(yyval.res_info), 0, sizeof (rc_res_res_info));
+	    (yyval.res_info).language = language;
+	    /* FIXME: Is this the right default?  */
+	    (yyval.res_info).memflags = MEMFLAG_MOVEABLE | MEMFLAG_PURE | MEMFLAG_DISCARDABLE;
+	  }
+    break;
+
+  case 211:
+
+/* Line 1455 of yacc.c  */
+#line 1564 "rcparse.y"
+    {
+	    (yyval.res_info) = (yyvsp[(1) - (2)].res_info);
+	    (yyval.res_info).memflags |= (yyvsp[(2) - (2)].memflags).on;
+	    (yyval.res_info).memflags &=~ (yyvsp[(2) - (2)].memflags).off;
+	  }
+    break;
+
+  case 212:
+
+/* Line 1455 of yacc.c  */
+#line 1570 "rcparse.y"
+    {
+	    (yyval.res_info) = (yyvsp[(1) - (3)].res_info);
+	    (yyval.res_info).characteristics = (yyvsp[(3) - (3)].il);
+	  }
+    break;
+
+  case 213:
+
+/* Line 1455 of yacc.c  */
+#line 1575 "rcparse.y"
+    {
+	    (yyval.res_info) = (yyvsp[(1) - (4)].res_info);
+	    (yyval.res_info).language = (yyvsp[(3) - (4)].il) | ((yyvsp[(4) - (4)].il) << SUBLANG_SHIFT);
+	  }
+    break;
+
+  case 214:
+
+/* Line 1455 of yacc.c  */
+#line 1580 "rcparse.y"
+    {
+	    (yyval.res_info) = (yyvsp[(1) - (3)].res_info);
+	    (yyval.res_info).version = (yyvsp[(3) - (3)].il);
+	  }
+    break;
+
+  case 215:
+
+/* Line 1455 of yacc.c  */
+#line 1590 "rcparse.y"
+    {
+	    memset (&(yyval.res_info), 0, sizeof (rc_res_res_info));
+	    (yyval.res_info).language = language;
+	    (yyval.res_info).memflags = MEMFLAG_MOVEABLE | MEMFLAG_DISCARDABLE;
+	  }
+    break;
+
+  case 216:
+
+/* Line 1455 of yacc.c  */
+#line 1596 "rcparse.y"
+    {
+	    (yyval.res_info) = (yyvsp[(1) - (2)].res_info);
+	    (yyval.res_info).memflags |= (yyvsp[(2) - (2)].memflags).on;
+	    (yyval.res_info).memflags &=~ (yyvsp[(2) - (2)].memflags).off;
+	  }
+    break;
+
+  case 217:
+
+/* Line 1455 of yacc.c  */
+#line 1607 "rcparse.y"
+    {
+	    memset (&(yyval.res_info), 0, sizeof (rc_res_res_info));
+	    (yyval.res_info).language = language;
+	    (yyval.res_info).memflags = MEMFLAG_MOVEABLE | MEMFLAG_PURE | MEMFLAG_DISCARDABLE;
+	  }
+    break;
+
+  case 218:
+
+/* Line 1455 of yacc.c  */
+#line 1613 "rcparse.y"
+    {
+	    (yyval.res_info) = (yyvsp[(1) - (2)].res_info);
+	    (yyval.res_info).memflags |= (yyvsp[(2) - (2)].memflags).on;
+	    (yyval.res_info).memflags &=~ (yyvsp[(2) - (2)].memflags).off;
+	  }
+    break;
+
+  case 219:
+
+/* Line 1455 of yacc.c  */
+#line 1625 "rcparse.y"
+    {
+	    (yyval.memflags).on = MEMFLAG_MOVEABLE;
+	    (yyval.memflags).off = 0;
+	  }
+    break;
+
+  case 220:
+
+/* Line 1455 of yacc.c  */
+#line 1630 "rcparse.y"
+    {
+	    (yyval.memflags).on = 0;
+	    (yyval.memflags).off = MEMFLAG_MOVEABLE;
+	  }
+    break;
+
+  case 221:
+
+/* Line 1455 of yacc.c  */
+#line 1635 "rcparse.y"
+    {
+	    (yyval.memflags).on = MEMFLAG_PURE;
+	    (yyval.memflags).off = 0;
+	  }
+    break;
+
+  case 222:
+
+/* Line 1455 of yacc.c  */
+#line 1640 "rcparse.y"
+    {
+	    (yyval.memflags).on = 0;
+	    (yyval.memflags).off = MEMFLAG_PURE;
+	  }
+    break;
+
+  case 223:
+
+/* Line 1455 of yacc.c  */
+#line 1645 "rcparse.y"
+    {
+	    (yyval.memflags).on = MEMFLAG_PRELOAD;
+	    (yyval.memflags).off = 0;
+	  }
+    break;
+
+  case 224:
+
+/* Line 1455 of yacc.c  */
+#line 1650 "rcparse.y"
+    {
+	    (yyval.memflags).on = 0;
+	    (yyval.memflags).off = MEMFLAG_PRELOAD;
+	  }
+    break;
+
+  case 225:
+
+/* Line 1455 of yacc.c  */
+#line 1655 "rcparse.y"
+    {
+	    (yyval.memflags).on = MEMFLAG_DISCARDABLE;
+	    (yyval.memflags).off = 0;
+	  }
+    break;
+
+  case 226:
+
+/* Line 1455 of yacc.c  */
+#line 1665 "rcparse.y"
+    {
+	    (yyval.s) = (yyvsp[(1) - (1)].s);
+	  }
+    break;
+
+  case 227:
+
+/* Line 1455 of yacc.c  */
+#line 1669 "rcparse.y"
+    {
+	    (yyval.s) = (yyvsp[(1) - (1)].s);
+	  }
+    break;
+
+  case 228:
+
+/* Line 1455 of yacc.c  */
+#line 1677 "rcparse.y"
+    {
+	    (yyval.uni) = (yyvsp[(1) - (1)].uni);
+	  }
+    break;
+
+  case 229:
+
+/* Line 1455 of yacc.c  */
+#line 1682 "rcparse.y"
+    {
+	    rc_uint_type l1 = unichar_len ((yyvsp[(1) - (2)].uni));
+	    rc_uint_type l2 = unichar_len ((yyvsp[(2) - (2)].uni));
+	    unichar *h = (unichar *) res_alloc ((l1 + l2 + 1) * sizeof (unichar));
+	    if (l1 != 0)
+	      memcpy (h, (yyvsp[(1) - (2)].uni), l1 * sizeof (unichar));
+	    if (l2 != 0)
+	      memcpy (h + l1, (yyvsp[(2) - (2)].uni), l2  * sizeof (unichar));
+	    h[l1 + l2] = 0;
+	    (yyval.uni) = h;
+	  }
+    break;
+
+  case 230:
+
+/* Line 1455 of yacc.c  */
+#line 1697 "rcparse.y"
+    {
+	    (yyval.uni) = unichar_dup ((yyvsp[(1) - (1)].uni));
+	  }
+    break;
+
+  case 231:
+
+/* Line 1455 of yacc.c  */
+#line 1701 "rcparse.y"
+    {
+	    unichar *h = NULL;
+	    unicode_from_ascii ((rc_uint_type *) NULL, &h, (yyvsp[(1) - (1)].s));
+	    (yyval.uni) = h;
+	  }
+    break;
+
+  case 232:
+
+/* Line 1455 of yacc.c  */
+#line 1710 "rcparse.y"
+    {
+	    (yyval.ss) = (yyvsp[(1) - (1)].ss);
+	  }
+    break;
+
+  case 233:
+
+/* Line 1455 of yacc.c  */
+#line 1714 "rcparse.y"
+    {
+	    rc_uint_type l = (yyvsp[(1) - (2)].ss).length + (yyvsp[(2) - (2)].ss).length;
+	    char *h = (char *) res_alloc (l);
+	    memcpy (h, (yyvsp[(1) - (2)].ss).s, (yyvsp[(1) - (2)].ss).length);
+	    memcpy (h + (yyvsp[(1) - (2)].ss).length, (yyvsp[(2) - (2)].ss).s, (yyvsp[(2) - (2)].ss).length);
+	    (yyval.ss).s = h;
+	    (yyval.ss).length = l;
+	  }
+    break;
+
+  case 234:
+
+/* Line 1455 of yacc.c  */
+#line 1726 "rcparse.y"
+    {
+	    (yyval.suni) = (yyvsp[(1) - (1)].suni);
+	  }
+    break;
+
+  case 235:
+
+/* Line 1455 of yacc.c  */
+#line 1730 "rcparse.y"
+    {
+	    rc_uint_type l = (yyvsp[(1) - (2)].suni).length + (yyvsp[(2) - (2)].suni).length;
+	    unichar *h = (unichar *) res_alloc (l * sizeof (unichar));
+	    memcpy (h, (yyvsp[(1) - (2)].suni).s, (yyvsp[(1) - (2)].suni).length * sizeof (unichar));
+	    memcpy (h + (yyvsp[(1) - (2)].suni).length, (yyvsp[(2) - (2)].suni).s, (yyvsp[(2) - (2)].suni).length  * sizeof (unichar));
+	    (yyval.suni).s = h;
+	    (yyval.suni).length = l;
+	  }
+    break;
+
+  case 236:
+
+/* Line 1455 of yacc.c  */
+#line 1752 "rcparse.y"
+    {
+	    style |= (yyvsp[(1) - (1)].il);
+	  }
+    break;
+
+  case 237:
+
+/* Line 1455 of yacc.c  */
+#line 1756 "rcparse.y"
+    {
+	    style &=~ (yyvsp[(2) - (2)].il);
+	  }
+    break;
+
+  case 238:
+
+/* Line 1455 of yacc.c  */
+#line 1760 "rcparse.y"
+    {
+	    style |= (yyvsp[(3) - (3)].il);
+	  }
+    break;
+
+  case 239:
+
+/* Line 1455 of yacc.c  */
+#line 1764 "rcparse.y"
+    {
+	    style &=~ (yyvsp[(4) - (4)].il);
+	  }
+    break;
+
+  case 240:
+
+/* Line 1455 of yacc.c  */
+#line 1771 "rcparse.y"
+    {
+	    (yyval.il) = (yyvsp[(1) - (1)].i).val;
+	  }
+    break;
+
+  case 241:
+
+/* Line 1455 of yacc.c  */
+#line 1775 "rcparse.y"
+    {
+	    (yyval.il) = (yyvsp[(2) - (3)].il);
+	  }
+    break;
+
+  case 242:
+
+/* Line 1455 of yacc.c  */
+#line 1784 "rcparse.y"
+    {
+	    (yyval.il) = 0;
+	  }
+    break;
+
+  case 243:
+
+/* Line 1455 of yacc.c  */
+#line 1788 "rcparse.y"
+    {
+	    (yyval.il) = (yyvsp[(1) - (1)].il);
+	  }
+    break;
+
+  case 244:
+
+/* Line 1455 of yacc.c  */
+#line 1797 "rcparse.y"
+    {
+	    (yyval.il) = (yyvsp[(2) - (2)].il);
+	  }
+    break;
+
+  case 245:
+
+/* Line 1455 of yacc.c  */
+#line 1806 "rcparse.y"
+    {
+	    (yyval.il) = (yyvsp[(1) - (1)].i).val;
+	  }
+    break;
+
+  case 246:
+
+/* Line 1455 of yacc.c  */
+#line 1815 "rcparse.y"
+    {
+	    (yyval.i) = (yyvsp[(1) - (1)].i);
+	  }
+    break;
+
+  case 247:
+
+/* Line 1455 of yacc.c  */
+#line 1819 "rcparse.y"
+    {
+	    (yyval.i) = (yyvsp[(2) - (3)].i);
+	  }
+    break;
+
+  case 248:
+
+/* Line 1455 of yacc.c  */
+#line 1823 "rcparse.y"
+    {
+	    (yyval.i).val = ~ (yyvsp[(2) - (2)].i).val;
+	    (yyval.i).dword = (yyvsp[(2) - (2)].i).dword;
+	  }
+    break;
+
+  case 249:
+
+/* Line 1455 of yacc.c  */
+#line 1828 "rcparse.y"
+    {
+	    (yyval.i).val = - (yyvsp[(2) - (2)].i).val;
+	    (yyval.i).dword = (yyvsp[(2) - (2)].i).dword;
+	  }
+    break;
+
+  case 250:
+
+/* Line 1455 of yacc.c  */
+#line 1833 "rcparse.y"
+    {
+	    (yyval.i).val = (yyvsp[(1) - (3)].i).val * (yyvsp[(3) - (3)].i).val;
+	    (yyval.i).dword = (yyvsp[(1) - (3)].i).dword || (yyvsp[(3) - (3)].i).dword;
+	  }
+    break;
+
+  case 251:
+
+/* Line 1455 of yacc.c  */
+#line 1838 "rcparse.y"
+    {
+	    (yyval.i).val = (yyvsp[(1) - (3)].i).val / (yyvsp[(3) - (3)].i).val;
+	    (yyval.i).dword = (yyvsp[(1) - (3)].i).dword || (yyvsp[(3) - (3)].i).dword;
+	  }
+    break;
+
+  case 252:
+
+/* Line 1455 of yacc.c  */
+#line 1843 "rcparse.y"
+    {
+	    (yyval.i).val = (yyvsp[(1) - (3)].i).val % (yyvsp[(3) - (3)].i).val;
+	    (yyval.i).dword = (yyvsp[(1) - (3)].i).dword || (yyvsp[(3) - (3)].i).dword;
+	  }
+    break;
+
+  case 253:
+
+/* Line 1455 of yacc.c  */
+#line 1848 "rcparse.y"
+    {
+	    (yyval.i).val = (yyvsp[(1) - (3)].i).val + (yyvsp[(3) - (3)].i).val;
+	    (yyval.i).dword = (yyvsp[(1) - (3)].i).dword || (yyvsp[(3) - (3)].i).dword;
+	  }
+    break;
+
+  case 254:
+
+/* Line 1455 of yacc.c  */
+#line 1853 "rcparse.y"
+    {
+	    (yyval.i).val = (yyvsp[(1) - (3)].i).val - (yyvsp[(3) - (3)].i).val;
+	    (yyval.i).dword = (yyvsp[(1) - (3)].i).dword || (yyvsp[(3) - (3)].i).dword;
+	  }
+    break;
+
+  case 255:
+
+/* Line 1455 of yacc.c  */
+#line 1858 "rcparse.y"
+    {
+	    (yyval.i).val = (yyvsp[(1) - (3)].i).val & (yyvsp[(3) - (3)].i).val;
+	    (yyval.i).dword = (yyvsp[(1) - (3)].i).dword || (yyvsp[(3) - (3)].i).dword;
+	  }
+    break;
+
+  case 256:
+
+/* Line 1455 of yacc.c  */
+#line 1863 "rcparse.y"
+    {
+	    (yyval.i).val = (yyvsp[(1) - (3)].i).val ^ (yyvsp[(3) - (3)].i).val;
+	    (yyval.i).dword = (yyvsp[(1) - (3)].i).dword || (yyvsp[(3) - (3)].i).dword;
+	  }
+    break;
+
+  case 257:
+
+/* Line 1455 of yacc.c  */
+#line 1868 "rcparse.y"
+    {
+	    (yyval.i).val = (yyvsp[(1) - (3)].i).val | (yyvsp[(3) - (3)].i).val;
+	    (yyval.i).dword = (yyvsp[(1) - (3)].i).dword || (yyvsp[(3) - (3)].i).dword;
+	  }
+    break;
+
+  case 258:
+
+/* Line 1455 of yacc.c  */
+#line 1879 "rcparse.y"
+    {
+	    (yyval.il) = (yyvsp[(2) - (2)].il);
+	  }
+    break;
+
+  case 259:
+
+/* Line 1455 of yacc.c  */
+#line 1888 "rcparse.y"
+    {
+	    (yyval.il) = (yyvsp[(1) - (1)].i).val;
+	  }
+    break;
+
+  case 260:
+
+/* Line 1455 of yacc.c  */
+#line 1899 "rcparse.y"
+    {
+	    (yyval.i) = (yyvsp[(1) - (1)].i);
+	  }
+    break;
+
+  case 261:
+
+/* Line 1455 of yacc.c  */
+#line 1903 "rcparse.y"
+    {
+	    (yyval.i) = (yyvsp[(2) - (3)].i);
+	  }
+    break;
+
+  case 262:
+
+/* Line 1455 of yacc.c  */
+#line 1907 "rcparse.y"
+    {
+	    (yyval.i).val = ~ (yyvsp[(2) - (2)].i).val;
+	    (yyval.i).dword = (yyvsp[(2) - (2)].i).dword;
+	  }
+    break;
+
+  case 263:
+
+/* Line 1455 of yacc.c  */
+#line 1912 "rcparse.y"
+    {
+	    (yyval.i).val = (yyvsp[(1) - (3)].i).val * (yyvsp[(3) - (3)].i).val;
+	    (yyval.i).dword = (yyvsp[(1) - (3)].i).dword || (yyvsp[(3) - (3)].i).dword;
+	  }
+    break;
+
+  case 264:
+
+/* Line 1455 of yacc.c  */
+#line 1917 "rcparse.y"
+    {
+	    (yyval.i).val = (yyvsp[(1) - (3)].i).val / (yyvsp[(3) - (3)].i).val;
+	    (yyval.i).dword = (yyvsp[(1) - (3)].i).dword || (yyvsp[(3) - (3)].i).dword;
+	  }
+    break;
+
+  case 265:
+
+/* Line 1455 of yacc.c  */
+#line 1922 "rcparse.y"
+    {
+	    (yyval.i).val = (yyvsp[(1) - (3)].i).val % (yyvsp[(3) - (3)].i).val;
+	    (yyval.i).dword = (yyvsp[(1) - (3)].i).dword || (yyvsp[(3) - (3)].i).dword;
+	  }
+    break;
+
+  case 266:
+
+/* Line 1455 of yacc.c  */
+#line 1927 "rcparse.y"
+    {
+	    (yyval.i).val = (yyvsp[(1) - (3)].i).val + (yyvsp[(3) - (3)].i).val;
+	    (yyval.i).dword = (yyvsp[(1) - (3)].i).dword || (yyvsp[(3) - (3)].i).dword;
+	  }
+    break;
+
+  case 267:
+
+/* Line 1455 of yacc.c  */
+#line 1932 "rcparse.y"
+    {
+	    (yyval.i).val = (yyvsp[(1) - (3)].i).val - (yyvsp[(3) - (3)].i).val;
+	    (yyval.i).dword = (yyvsp[(1) - (3)].i).dword || (yyvsp[(3) - (3)].i).dword;
+	  }
+    break;
+
+  case 268:
+
+/* Line 1455 of yacc.c  */
+#line 1937 "rcparse.y"
+    {
+	    (yyval.i).val = (yyvsp[(1) - (3)].i).val & (yyvsp[(3) - (3)].i).val;
+	    (yyval.i).dword = (yyvsp[(1) - (3)].i).dword || (yyvsp[(3) - (3)].i).dword;
+	  }
+    break;
+
+  case 269:
+
+/* Line 1455 of yacc.c  */
+#line 1942 "rcparse.y"
+    {
+	    (yyval.i).val = (yyvsp[(1) - (3)].i).val ^ (yyvsp[(3) - (3)].i).val;
+	    (yyval.i).dword = (yyvsp[(1) - (3)].i).dword || (yyvsp[(3) - (3)].i).dword;
+	  }
+    break;
+
+  case 270:
+
+/* Line 1455 of yacc.c  */
+#line 1947 "rcparse.y"
+    {
+	    (yyval.i).val = (yyvsp[(1) - (3)].i).val | (yyvsp[(3) - (3)].i).val;
+	    (yyval.i).dword = (yyvsp[(1) - (3)].i).dword || (yyvsp[(3) - (3)].i).dword;
+	  }
+    break;
+
+
+
+/* Line 1455 of yacc.c  */
+#line 4880 "rcparse.c"
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined(yyoverflow) || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+
+/* Line 1675 of yacc.c  */
+#line 1953 "rcparse.y"
+
+
+/* Set the language from the command line.  */
+
+void
+rcparse_set_language (int lang)
+{
+  language = lang;
+}
+
==== (added) binutils-2.19.91.20091006/binutils/rcparse.h ====
--- /dev/null	2009-05-01 06:17:58.000000000 +0200
+++ binutils-2.19.91.20091006/binutils/rcparse.h	2009-10-07 08:18:05.000000000 +0200
@@ -0,0 +1,303 @@
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
+
+/* Skeleton interface for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     BEG = 258,
+     END = 259,
+     ACCELERATORS = 260,
+     VIRTKEY = 261,
+     ASCII = 262,
+     NOINVERT = 263,
+     SHIFT = 264,
+     CONTROL = 265,
+     ALT = 266,
+     BITMAP = 267,
+     CURSOR = 268,
+     DIALOG = 269,
+     DIALOGEX = 270,
+     EXSTYLE = 271,
+     CAPTION = 272,
+     CLASS = 273,
+     STYLE = 274,
+     AUTO3STATE = 275,
+     AUTOCHECKBOX = 276,
+     AUTORADIOBUTTON = 277,
+     CHECKBOX = 278,
+     COMBOBOX = 279,
+     CTEXT = 280,
+     DEFPUSHBUTTON = 281,
+     EDITTEXT = 282,
+     GROUPBOX = 283,
+     LISTBOX = 284,
+     LTEXT = 285,
+     PUSHBOX = 286,
+     PUSHBUTTON = 287,
+     RADIOBUTTON = 288,
+     RTEXT = 289,
+     SCROLLBAR = 290,
+     STATE3 = 291,
+     USERBUTTON = 292,
+     BEDIT = 293,
+     HEDIT = 294,
+     IEDIT = 295,
+     FONT = 296,
+     ICON = 297,
+     ANICURSOR = 298,
+     ANIICON = 299,
+     DLGINCLUDE = 300,
+     DLGINIT = 301,
+     FONTDIR = 302,
+     HTML = 303,
+     MANIFEST = 304,
+     PLUGPLAY = 305,
+     VXD = 306,
+     TOOLBAR = 307,
+     BUTTON = 308,
+     LANGUAGE = 309,
+     CHARACTERISTICS = 310,
+     VERSIONK = 311,
+     MENU = 312,
+     MENUEX = 313,
+     MENUITEM = 314,
+     SEPARATOR = 315,
+     POPUP = 316,
+     CHECKED = 317,
+     GRAYED = 318,
+     HELP = 319,
+     INACTIVE = 320,
+     MENUBARBREAK = 321,
+     MENUBREAK = 322,
+     MESSAGETABLE = 323,
+     RCDATA = 324,
+     STRINGTABLE = 325,
+     VERSIONINFO = 326,
+     FILEVERSION = 327,
+     PRODUCTVERSION = 328,
+     FILEFLAGSMASK = 329,
+     FILEFLAGS = 330,
+     FILEOS = 331,
+     FILETYPE = 332,
+     FILESUBTYPE = 333,
+     BLOCKSTRINGFILEINFO = 334,
+     BLOCKVARFILEINFO = 335,
+     VALUE = 336,
+     BLOCK = 337,
+     MOVEABLE = 338,
+     FIXED = 339,
+     PURE = 340,
+     IMPURE = 341,
+     PRELOAD = 342,
+     LOADONCALL = 343,
+     DISCARDABLE = 344,
+     NOT = 345,
+     QUOTEDUNISTRING = 346,
+     QUOTEDSTRING = 347,
+     STRING = 348,
+     NUMBER = 349,
+     SIZEDUNISTRING = 350,
+     SIZEDSTRING = 351,
+     IGNORED_TOKEN = 352,
+     NEG = 353
+   };
+#endif
+/* Tokens.  */
+#define BEG 258
+#define END 259
+#define ACCELERATORS 260
+#define VIRTKEY 261
+#define ASCII 262
+#define NOINVERT 263
+#define SHIFT 264
+#define CONTROL 265
+#define ALT 266
+#define BITMAP 267
+#define CURSOR 268
+#define DIALOG 269
+#define DIALOGEX 270
+#define EXSTYLE 271
+#define CAPTION 272
+#define CLASS 273
+#define STYLE 274
+#define AUTO3STATE 275
+#define AUTOCHECKBOX 276
+#define AUTORADIOBUTTON 277
+#define CHECKBOX 278
+#define COMBOBOX 279
+#define CTEXT 280
+#define DEFPUSHBUTTON 281
+#define EDITTEXT 282
+#define GROUPBOX 283
+#define LISTBOX 284
+#define LTEXT 285
+#define PUSHBOX 286
+#define PUSHBUTTON 287
+#define RADIOBUTTON 288
+#define RTEXT 289
+#define SCROLLBAR 290
+#define STATE3 291
+#define USERBUTTON 292
+#define BEDIT 293
+#define HEDIT 294
+#define IEDIT 295
+#define FONT 296
+#define ICON 297
+#define ANICURSOR 298
+#define ANIICON 299
+#define DLGINCLUDE 300
+#define DLGINIT 301
+#define FONTDIR 302
+#define HTML 303
+#define MANIFEST 304
+#define PLUGPLAY 305
+#define VXD 306
+#define TOOLBAR 307
+#define BUTTON 308
+#define LANGUAGE 309
+#define CHARACTERISTICS 310
+#define VERSIONK 311
+#define MENU 312
+#define MENUEX 313
+#define MENUITEM 314
+#define SEPARATOR 315
+#define POPUP 316
+#define CHECKED 317
+#define GRAYED 318
+#define HELP 319
+#define INACTIVE 320
+#define MENUBARBREAK 321
+#define MENUBREAK 322
+#define MESSAGETABLE 323
+#define RCDATA 324
+#define STRINGTABLE 325
+#define VERSIONINFO 326
+#define FILEVERSION 327
+#define PRODUCTVERSION 328
+#define FILEFLAGSMASK 329
+#define FILEFLAGS 330
+#define FILEOS 331
+#define FILETYPE 332
+#define FILESUBTYPE 333
+#define BLOCKSTRINGFILEINFO 334
+#define BLOCKVARFILEINFO 335
+#define VALUE 336
+#define BLOCK 337
+#define MOVEABLE 338
+#define FIXED 339
+#define PURE 340
+#define IMPURE 341
+#define PRELOAD 342
+#define LOADONCALL 343
+#define DISCARDABLE 344
+#define NOT 345
+#define QUOTEDUNISTRING 346
+#define QUOTEDSTRING 347
+#define STRING 348
+#define NUMBER 349
+#define SIZEDUNISTRING 350
+#define SIZEDSTRING 351
+#define IGNORED_TOKEN 352
+#define NEG 353
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 1676 of yacc.c  */
+#line 69 "rcparse.y"
+
+  rc_accelerator acc;
+  rc_accelerator *pacc;
+  rc_dialog_control *dialog_control;
+  rc_menuitem *menuitem;
+  struct
+  {
+    rc_rcdata_item *first;
+    rc_rcdata_item *last;
+  } rcdata;
+  rc_rcdata_item *rcdata_item;
+  rc_fixed_versioninfo *fixver;
+  rc_ver_info *verinfo;
+  rc_ver_stringinfo *verstring;
+  rc_ver_varinfo *vervar;
+  rc_toolbar_item *toobar_item;
+  rc_res_id id;
+  rc_res_res_info res_info;
+  struct
+  {
+    rc_uint_type on;
+    rc_uint_type off;
+  } memflags;
+  struct
+  {
+    rc_uint_type val;
+    /* Nonzero if this number was explicitly specified as long.  */
+    int dword;
+  } i;
+  rc_uint_type il;
+  rc_uint_type is;
+  const char *s;
+  struct
+  {
+    rc_uint_type length;
+    const char *s;
+  } ss;
+  unichar *uni;
+  struct
+  {
+    rc_uint_type length;
+    const unichar *s;
+  } suni;
+
+
+
+/* Line 1676 of yacc.c  */
+#line 295 "rcparse.h"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+extern YYSTYPE yylval;
+
+
==== (added) binutils-2.19.91.20091006/binutils/sysinfo.c ====
--- /dev/null	2009-05-01 06:17:58.000000000 +0200
+++ binutils-2.19.91.20091006/binutils/sysinfo.c	2009-10-07 08:18:03.000000000 +0200
@@ -0,0 +1,2013 @@
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.4.1"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+
+
+/* Copy the first part of user declarations.  */
+
+/* Line 189 of yacc.c  */
+#line 21 "sysinfo.y"
+
+#include <stdio.h>
+#include <stdlib.h>
+
+static char writecode;
+static char *it;
+static int code;
+static char * repeat;
+static char *oldrepeat;
+static char *name;
+static int rdepth;
+static char *names[] = {" ","[n]","[n][m]"};
+static char *pnames[]= {"","*","**"};
+
+static int yyerror (char *s);
+extern int yylex (void);
+
+
+/* Line 189 of yacc.c  */
+#line 92 "sysinfo.c"
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     COND = 258,
+     REPEAT = 259,
+     TYPE = 260,
+     NAME = 261,
+     NUMBER = 262,
+     UNIT = 263
+   };
+#endif
+/* Tokens.  */
+#define COND 258
+#define REPEAT 259
+#define TYPE 260
+#define NAME 261
+#define NUMBER 262
+#define UNIT 263
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 214 of yacc.c  */
+#line 40 "sysinfo.y"
+
+ int i;
+ char *s;
+
+
+
+/* Line 214 of yacc.c  */
+#line 151 "sysinfo.c"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 264 of yacc.c  */
+#line 163 "sysinfo.c"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
+{
+  return yyi;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  3
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   38
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  11
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  19
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  27
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  55
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   263
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       5,     6,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       7,     8,     9,    10
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint8 yyprhs[] =
+{
+       0,     0,     3,     4,     7,    10,    11,    12,    19,    22,
+      25,    28,    29,    30,    37,    38,    45,    46,    57,    59,
+      60,    64,    67,    71,    72,    73,    77,    78
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      12,     0,    -1,    -1,    13,    14,    -1,    15,    14,    -1,
+      -1,    -1,     5,     8,     9,    16,    17,     6,    -1,    22,
+      17,    -1,    20,    17,    -1,    18,    17,    -1,    -1,    -1,
+       5,     4,     8,    19,    17,     6,    -1,    -1,     5,     3,
+       8,    21,    17,     6,    -1,    -1,     5,    25,     5,    24,
+      26,     6,    27,    23,    28,     6,    -1,     7,    -1,    -1,
+       5,     8,     6,    -1,     9,    10,    -1,     5,     8,     6,
+      -1,    -1,    -1,     5,    29,     6,    -1,    -1,    29,     5,
+       8,     8,     6,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,    54,    54,    54,    92,    93,    98,    97,   175,   176,
+     177,   178,   182,   181,   229,   228,   256,   255,   363,   364,
+     368,   373,   379,   380,   383,   384,   386,   388
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "COND", "REPEAT", "'('", "')'", "TYPE",
+  "NAME", "NUMBER", "UNIT", "$accept", "top", "$@1", "it_list", "it",
+  "$@2", "it_field_list", "repeat_it_field", "$@3", "cond_it_field", "$@4",
+  "it_field", "$@5", "attr_type", "attr_desc", "attr_size", "attr_id",
+  "enums", "enum_list", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,    40,    41,   260,   261,   262,
+     263
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    11,    13,    12,    14,    14,    16,    15,    17,    17,
+      17,    17,    19,    18,    21,    20,    23,    22,    24,    24,
+      25,    26,    27,    27,    28,    28,    29,    29
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     0,     2,     2,     0,     0,     6,     2,     2,
+       2,     0,     0,     6,     0,     6,     0,    10,     1,     0,
+       3,     2,     3,     0,     0,     3,     0,     5
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       2,     0,     5,     1,     0,     3,     5,     0,     4,     6,
+      11,     0,     0,    11,    11,    11,     0,     0,     0,     0,
+       7,    10,     9,     8,    14,    12,     0,    19,    11,    11,
+      20,    18,     0,     0,     0,     0,     0,    15,    13,    21,
+      23,     0,    16,     0,    24,    22,    26,     0,     0,    17,
+       0,    25,     0,     0,    27
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
+{
+      -1,     1,     2,     5,     6,    10,    12,    13,    29,    14,
+      28,    15,    44,    32,    19,    36,    42,    47,    48
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -14
+static const yytype_int8 yypact[] =
+{
+     -14,     8,     4,   -14,     2,   -14,     4,     3,   -14,   -14,
+       6,     0,     7,     6,     6,     6,     9,    10,    11,    15,
+     -14,   -14,   -14,   -14,   -14,   -14,    16,    14,     6,     6,
+     -14,   -14,     5,    17,    18,    19,    20,   -14,   -14,   -14,
+      22,    23,   -14,    24,    27,   -14,   -14,    28,     1,   -14,
+      25,   -14,    29,    30,   -14
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+     -14,   -14,   -14,    32,   -14,   -14,   -13,   -14,   -14,   -14,
+     -14,   -14,   -14,   -14,   -14,   -14,   -14,   -14,   -14
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -1
+static const yytype_uint8 yytable[] =
+{
+      21,    22,    23,    16,    17,    18,    50,    51,     3,     4,
+       7,    11,     9,    20,    35,    33,    34,    24,    25,    26,
+      27,    31,    30,    37,    38,     0,    40,    41,     0,    39,
+      45,    43,    46,    52,    49,     0,    54,    53,     8
+};
+
+static const yytype_int8 yycheck[] =
+{
+      13,    14,    15,     3,     4,     5,     5,     6,     0,     5,
+       8,     5,     9,     6,     9,    28,    29,     8,     8,     8,
+       5,     7,     6,     6,     6,    -1,     6,     5,    -1,    10,
+       6,     8,     5,     8,     6,    -1,     6,     8,     6
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,    12,    13,     0,     5,    14,    15,     8,    14,     9,
+      16,     5,    17,    18,    20,    22,     3,     4,     5,    25,
+       6,    17,    17,    17,     8,     8,     8,     5,    21,    19,
+       6,     7,    24,    17,    17,     9,    26,     6,     6,    10,
+       6,     5,    27,     8,    23,     6,     5,    28,    29,     6,
+       5,     6,     8,     8,     6
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+#else
+static void
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+
+      default:
+	break;
+    }
+}
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*-------------------------.
+| yyparse or yypush_parse.  |
+`-------------------------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+
+
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 2:
+
+/* Line 1455 of yacc.c  */
+#line 54 "sysinfo.y"
+    {
+  switch (writecode)
+    {
+    case 'i':
+      printf("#ifdef SYSROFF_SWAP_IN\n");
+      break; 
+    case 'p':
+      printf("#ifdef SYSROFF_p\n");
+      break; 
+    case 'd':
+      break;
+    case 'g':
+      printf("#ifdef SYSROFF_SWAP_OUT\n");
+      break;
+    case 'c':
+      printf("#ifdef SYSROFF_PRINT\n");
+      printf("#include <stdio.h>\n");
+      printf("#include <stdlib.h>\n");
+      printf("#include <ansidecl.h>\n");
+      break;
+    }
+ }
+    break;
+
+  case 3:
+
+/* Line 1455 of yacc.c  */
+#line 76 "sysinfo.y"
+    {
+  switch (writecode) {
+  case 'i':
+  case 'p':
+  case 'g':
+  case 'c':
+    printf("#endif\n");
+    break; 
+  case 'd':
+    break;
+  }
+}
+    break;
+
+  case 6:
+
+/* Line 1455 of yacc.c  */
+#line 98 "sysinfo.y"
+    {
+	it = (yyvsp[(2) - (3)].s); code = (yyvsp[(3) - (3)].i);
+	switch (writecode) 
+	  {
+	  case 'd':
+	    printf("\n\n\n#define IT_%s_CODE 0x%x\n", it,code);
+	    printf("struct IT_%s;\n", it);
+	    printf("extern void sysroff_swap_%s_in PARAMS ((struct IT_%s *));\n",
+		   (yyvsp[(2) - (3)].s), it);
+	    printf("extern void sysroff_swap_%s_out PARAMS ((FILE *, struct IT_%s *));\n",
+		   (yyvsp[(2) - (3)].s), it);
+	    printf("extern void sysroff_print_%s_out PARAMS ((struct IT_%s *));\n",
+		   (yyvsp[(2) - (3)].s), it);
+	    printf("struct IT_%s { \n", it);
+	    break;
+	  case 'i':
+	    printf("void sysroff_swap_%s_in(ptr)\n",(yyvsp[(2) - (3)].s));
+	    printf("struct IT_%s *ptr;\n", it);
+	    printf("{\n");
+	    printf("unsigned char raw[255];\n");
+	    printf("\tint idx = 0 ;\n");
+	    printf("\tint size;\n");
+	    printf("memset(raw,0,255);\n");	
+	    printf("memset(ptr,0,sizeof(*ptr));\n");
+	    printf("size = fillup(raw);\n");
+	    break;
+	  case 'g':
+	    printf("void sysroff_swap_%s_out(file,ptr)\n",(yyvsp[(2) - (3)].s));
+	    printf("FILE * file;\n");
+	    printf("struct IT_%s *ptr;\n", it);
+	    printf("{\n");
+	    printf("\tunsigned char raw[255];\n");
+	    printf("\tint idx = 16 ;\n");
+	    printf("\tmemset (raw, 0, 255);\n");
+	    printf("\tcode = IT_%s_CODE;\n", it);
+	    break;
+	  case 'o':
+	    printf("void sysroff_swap_%s_out(abfd,ptr)\n",(yyvsp[(2) - (3)].s));
+	    printf("bfd * abfd;\n");
+	    printf("struct IT_%s *ptr;\n",it);
+	    printf("{\n");
+	    printf("int idx = 0 ;\n");
+	    break;
+	  case 'c':
+	    printf("void sysroff_print_%s_out(ptr)\n",(yyvsp[(2) - (3)].s));
+	    printf("struct IT_%s *ptr;\n", it);
+	    printf("{\n");
+	    printf("itheader(\"%s\", IT_%s_CODE);\n",(yyvsp[(2) - (3)].s),(yyvsp[(2) - (3)].s));
+	    break;
+
+	  case 't':
+	    break;
+	  }
+
+      }
+    break;
+
+  case 7:
+
+/* Line 1455 of yacc.c  */
+#line 155 "sysinfo.y"
+    {
+  switch (writecode) {
+  case 'd': 
+    printf("};\n");
+    break;
+  case 'g':
+    printf("\tchecksum(file,raw, idx, IT_%s_CODE);\n", it);
+    
+  case 'i':
+
+  case 'o':
+  case 'c':
+    printf("}\n");
+  }
+}
+    break;
+
+  case 12:
+
+/* Line 1455 of yacc.c  */
+#line 182 "sysinfo.y"
+    {
+	  rdepth++;
+	  switch (writecode) 
+	    {
+	    case 'c':
+	      if (rdepth==1)
+	      printf("\tprintf(\"repeat %%d\\n\", %s);\n",(yyvsp[(3) - (3)].s));
+	      if (rdepth==2)
+	      printf("\tprintf(\"repeat %%d\\n\", %s[n]);\n",(yyvsp[(3) - (3)].s));
+	    case 'i':
+	    case 'g':
+	    case 'o':
+
+	      if (rdepth==1) 
+		{
+	      printf("\t{ int n; for (n = 0; n < %s; n++) {\n",    (yyvsp[(3) - (3)].s));
+	    }
+	      if (rdepth == 2) {
+	      printf("\t{ int m; for (m = 0; m < %s[n]; m++) {\n",    (yyvsp[(3) - (3)].s));
+	    }		
+
+	      break;
+	    }
+
+	  oldrepeat = repeat;
+         repeat = (yyvsp[(3) - (3)].s);
+	}
+    break;
+
+  case 13:
+
+/* Line 1455 of yacc.c  */
+#line 212 "sysinfo.y"
+    {
+	  repeat = oldrepeat;
+	  oldrepeat =0;
+	  rdepth--;
+	  switch (writecode)
+	    {
+	    case 'i':
+	    case 'g':
+	    case 'o':
+	    case 'c':
+	  printf("\t}}\n");
+	}
+	}
+    break;
+
+  case 14:
+
+/* Line 1455 of yacc.c  */
+#line 229 "sysinfo.y"
+    {
+	  switch (writecode) 
+	    {
+	    case 'i':
+	    case 'g':
+	    case 'o':
+	    case 'c':
+	      printf("\tif (%s) {\n", (yyvsp[(3) - (3)].s));
+	      break;
+	    }
+	}
+    break;
+
+  case 15:
+
+/* Line 1455 of yacc.c  */
+#line 242 "sysinfo.y"
+    {
+	  switch (writecode)
+	    {
+	    case 'i':
+	    case 'g':
+	    case 'o':
+	    case 'c':
+	  printf("\t}\n");
+	}
+	}
+    break;
+
+  case 16:
+
+/* Line 1455 of yacc.c  */
+#line 256 "sysinfo.y"
+    {name = (yyvsp[(7) - (7)].s); }
+    break;
+
+  case 17:
+
+/* Line 1455 of yacc.c  */
+#line 258 "sysinfo.y"
+    {
+	  char *desc = (yyvsp[(2) - (10)].s);
+	  char *type = (yyvsp[(4) - (10)].s);
+	  int size = (yyvsp[(5) - (10)].i);
+	  char *id = (yyvsp[(7) - (10)].s);
+char *p = names[rdepth];
+char *ptr = pnames[rdepth];
+	  switch (writecode) 
+	    {
+	    case 'g':
+	      if (size % 8) 
+		{
+		  
+		  printf("\twriteBITS(ptr->%s%s,raw,&idx,%d);\n",
+			 id,
+			 names[rdepth], size);
+
+		}
+	      else {
+		printf("\twrite%s(ptr->%s%s,raw,&idx,%d,file);\n",
+		       type,
+		       id,
+		       names[rdepth],size/8);
+		}
+	      break;	      
+	    case 'i':
+	      {
+
+		if (rdepth >= 1)
+
+		  {
+		    printf("if (!ptr->%s) ptr->%s = (%s*)xcalloc(%s, sizeof(ptr->%s[0]));\n", 
+			   id, 
+			   id,
+			   type,
+			   repeat,
+			   id);
+		  }
+
+		if (rdepth == 2)
+		  {
+		    printf("if (!ptr->%s[n]) ptr->%s[n] = (%s**)xcalloc(%s[n], sizeof(ptr->%s[n][0]));\n", 
+			   id, 
+			   id,
+			   type,
+			   repeat,
+			   id);
+		  }
+
+	      }
+
+	      if (size % 8) 
+		{
+		  printf("\tptr->%s%s = getBITS(raw,&idx, %d,size);\n",
+			 id,
+			 names[rdepth], 
+			 size);
+		}
+	      else {
+		printf("\tptr->%s%s = get%s(raw,&idx, %d,size);\n",
+		       id,
+		       names[rdepth],
+		       type,
+		       size/8);
+		}
+	      break;
+	    case 'o':
+	      printf("\tput%s(raw,%d,%d,&idx,ptr->%s%s);\n", type,size/8,size%8,id,names[rdepth]);
+	      break;
+	    case 'd':
+	      if (repeat) 
+		printf("\t/* repeat %s */\n", repeat);
+
+		  if (type[0] == 'I') {
+		  printf("\tint %s%s; \t/* %s */\n",ptr,id, desc);
+		}
+		  else if (type[0] =='C') {
+		  printf("\tchar %s*%s;\t /* %s */\n",ptr,id, desc);
+		}
+	      else {
+		printf("\tbarray %s%s;\t /* %s */\n",ptr,id, desc);
+	      }
+		  break;
+		case 'c':
+	      printf("tabout();\n");
+		  printf("\tprintf(\"/*%-30s*/ ptr->%s = \");\n", desc, id);
+
+		  if (type[0] == 'I')
+		  printf("\tprintf(\"%%d\\n\",ptr->%s%s);\n", id,p);
+		  else   if (type[0] == 'C')
+		  printf("\tprintf(\"%%s\\n\",ptr->%s%s);\n", id,p);
+
+		  else   if (type[0] == 'B') 
+		    {
+		  printf("\tpbarray(&ptr->%s%s);\n", id,p);
+		}
+	      else abort();
+		  break;
+		}
+	}
+    break;
+
+  case 18:
+
+/* Line 1455 of yacc.c  */
+#line 363 "sysinfo.y"
+    { (yyval.s) = (yyvsp[(1) - (1)].s); }
+    break;
+
+  case 19:
+
+/* Line 1455 of yacc.c  */
+#line 364 "sysinfo.y"
+    { (yyval.s) = "INT";}
+    break;
+
+  case 20:
+
+/* Line 1455 of yacc.c  */
+#line 369 "sysinfo.y"
+    { (yyval.s) = (yyvsp[(2) - (3)].s); }
+    break;
+
+  case 21:
+
+/* Line 1455 of yacc.c  */
+#line 374 "sysinfo.y"
+    { (yyval.i) = (yyvsp[(1) - (2)].i) * (yyvsp[(2) - (2)].i); }
+    break;
+
+  case 22:
+
+/* Line 1455 of yacc.c  */
+#line 379 "sysinfo.y"
+    { (yyval.s) = (yyvsp[(2) - (3)].s); }
+    break;
+
+  case 23:
+
+/* Line 1455 of yacc.c  */
+#line 380 "sysinfo.y"
+    { (yyval.s) = "dummy";}
+    break;
+
+  case 27:
+
+/* Line 1455 of yacc.c  */
+#line 388 "sysinfo.y"
+    { 
+	  switch (writecode) 
+	    {
+	    case 'd':
+	      printf("#define %s %s\n", (yyvsp[(3) - (5)].s),(yyvsp[(4) - (5)].s));
+	      break;
+	    case 'c':
+		printf("if (ptr->%s%s == %s) { tabout(); printf(\"%s\\n\");}\n", name, names[rdepth],(yyvsp[(4) - (5)].s),(yyvsp[(3) - (5)].s));
+	    }
+	}
+    break;
+
+
+
+/* Line 1455 of yacc.c  */
+#line 1768 "sysinfo.c"
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined(yyoverflow) || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+
+/* Line 1675 of yacc.c  */
+#line 403 "sysinfo.y"
+
+/* four modes
+
+   -d write structure definitions for sysroff in host format
+   -i write functions to swap into sysroff format in
+   -o write functions to swap into sysroff format out
+   -c write code to print info in human form */
+
+int yydebug;
+
+int 
+main (int ac, char **av)
+{
+  yydebug=0;
+  if (ac > 1)
+    writecode = av[1][1];
+if (writecode == 'd')
+  {
+    printf("typedef struct { unsigned char *data; int len; } barray; \n");
+    printf("typedef  int INT;\n");
+    printf("typedef  char * CHARS;\n");
+
+  }
+  yyparse();
+return 0;
+}
+
+static int
+yyerror (char *s)
+{
+  fprintf(stderr, "%s\n" , s);
+  return 0;
+}
+
==== (added) binutils-2.19.91.20091006/binutils/sysinfo.h ====
--- /dev/null	2009-05-01 06:17:58.000000000 +0200
+++ binutils-2.19.91.20091006/binutils/sysinfo.h	2009-10-07 08:18:03.000000000 +0200
@@ -0,0 +1,83 @@
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
+
+/* Skeleton interface for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     COND = 258,
+     REPEAT = 259,
+     TYPE = 260,
+     NAME = 261,
+     NUMBER = 262,
+     UNIT = 263
+   };
+#endif
+/* Tokens.  */
+#define COND 258
+#define REPEAT 259
+#define TYPE 260
+#define NAME 261
+#define NUMBER 262
+#define UNIT 263
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 1676 of yacc.c  */
+#line 40 "sysinfo.y"
+
+ int i;
+ char *s;
+
+
+
+/* Line 1676 of yacc.c  */
+#line 75 "sysinfo.h"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+extern YYSTYPE yylval;
+
+
==== (added) binutils-2.19.91.20091006/binutils/syslex.c ====
--- /dev/null	2009-05-01 06:17:58.000000000 +0200
+++ binutils-2.19.91.20091006/binutils/syslex.c	2009-10-07 08:18:04.000000000 +0200
@@ -0,0 +1,1940 @@
+
+#line 3 "syslex.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart(yyin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#define YY_BUF_SIZE 16384
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int yyleng;
+
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart (FILE *input_file  );
+void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
+void yy_delete_buffer (YY_BUFFER_STATE b  );
+void yy_flush_buffer (YY_BUFFER_STATE b  );
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state (void );
+
+static void yyensure_buffer_stack (void );
+static void yy_load_buffer_state (void );
+static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
+
+void *yyalloc (yy_size_t  );
+void *yyrealloc (void *,yy_size_t  );
+void yyfree (void *  );
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+typedef unsigned char YY_CHAR;
+
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int yylineno;
+
+int yylineno = 1;
+
+extern char *yytext;
+#define yytext_ptr yytext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	yyleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 25
+#define YY_END_OF_BUFFER 26
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[81] =
+    {   0,
+        0,    0,   26,   25,    7,    8,    5,   25,    1,    2,
+       11,   11,    6,    3,    4,   25,   25,   25,   25,   25,
+       25,   25,    0,    9,   11,    0,    6,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,   10,    0,    0,
+       13,    0,    0,    0,    0,   16,    0,    0,    0,    0,
+        0,   12,   15,    0,   23,    0,    0,    0,    0,    0,
+        0,   14,   18,    0,    0,    0,    0,    0,   17,    0,
+       24,    0,    0,    0,   20,   22,    0,   21,   19,    0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    4,    1,    5,    1,    1,    1,    1,    1,    6,
+        7,    1,    1,    1,    1,    1,    1,    8,    9,    9,
+        9,    9,    9,    9,    9,    9,    9,    1,   10,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+       11,    1,   12,    1,    1,    1,   13,   14,   15,   16,
+
+       17,   18,   19,   20,   21,    1,    1,   22,    1,   23,
+       24,   25,    1,   26,   27,   28,   29,   30,    1,   31,
+       32,   33,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[34] =
+    {   0,
+        1,    1,    2,    1,    1,    1,    1,    3,    3,    1,
+        1,    1,    3,    3,    3,    3,    3,    3,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1
+    } ;
+
+static yyconst flex_int16_t yy_base[84] =
+    {   0,
+        0,    0,  100,  101,  101,  101,  101,   94,  101,  101,
+       26,   28,    0,  101,  101,   82,   26,   18,   74,   79,
+       78,   81,   88,  101,   32,    0,    0,   76,   65,   62,
+       61,   75,   20,   59,   61,   66,   58,    0,   57,   56,
+       54,   63,   53,   62,   54,  101,   59,   48,   53,   46,
+       59,  101,   44,   43,  101,   41,   55,   46,   53,   44,
+       31,  101,  101,   39,   27,   21,   39,   19,  101,   35,
+      101,   33,   26,   29,  101,  101,   28,  101,  101,  101,
+       58,   61,   41
+    } ;
+
+static yyconst flex_int16_t yy_def[84] =
+    {   0,
+       80,    1,   80,   80,   80,   80,   80,   81,   80,   80,
+       80,   80,   82,   80,   80,   80,   80,   80,   80,   80,
+       80,   80,   81,   80,   80,   83,   82,   80,   80,   80,
+       80,   80,   80,   80,   80,   80,   80,   83,   80,   80,
+       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
+       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
+       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
+       80,   80,   80,   80,   80,   80,   80,   80,   80,    0,
+       80,   80,   80
+    } ;
+
+static yyconst flex_int16_t yy_nxt[135] =
+    {   0,
+        4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
+       14,   15,   16,   17,   18,    4,    4,    4,    4,    4,
+       19,    4,    4,    4,    4,   20,   21,    4,    4,   22,
+        4,    4,    4,   25,   25,   25,   25,   32,   29,   25,
+       25,   33,   44,   38,   79,   78,   30,   77,   45,   76,
+       75,   74,   73,   72,   71,   70,   26,   31,   23,   23,
+       23,   27,   69,   27,   68,   67,   66,   65,   64,   63,
+       62,   61,   60,   59,   58,   57,   56,   55,   54,   53,
+       52,   51,   50,   49,   48,   47,   46,   43,   42,   41,
+       40,   39,   24,   37,   36,   35,   34,   28,   24,   80,
+
+        3,   80,   80,   80,   80,   80,   80,   80,   80,   80,
+       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
+       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
+       80,   80,   80,   80
+    } ;
+
+static yyconst flex_int16_t yy_chk[135] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,   11,   11,   12,   12,   18,   17,   25,
+       25,   18,   33,   83,   77,   74,   17,   73,   33,   72,
+       70,   68,   67,   66,   65,   64,   11,   17,   81,   81,
+       81,   82,   61,   82,   60,   59,   58,   57,   56,   54,
+       53,   51,   50,   49,   48,   47,   45,   44,   43,   42,
+       41,   40,   39,   37,   36,   35,   34,   32,   31,   30,
+       29,   28,   23,   22,   21,   20,   19,   16,    8,    3,
+
+       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
+       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
+       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
+       80,   80,   80,   80
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int yy_flex_debug;
+int yy_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "syslex.l"
+#line 2 "syslex.l"
+/* Copyright 2001, 2003, 2005, 2007 Free Software Foundation, Inc.
+
+   This file is part of GNU Binutils.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GLD; see the file COPYING.  If not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include "config.h"
+#ifdef HAVE_STRING_H
+#include <string.h>
+#else
+#ifdef HAVE_STRINGS_H
+#include <strings.h>
+#endif
+#endif
+#include "sysinfo.h"
+
+#define YY_NO_UNPUT
+
+#ifndef yywrap
+static int yywrap (void) { return 1; }
+#endif
+
+extern int yylex (void);
+#line 538 "syslex.c"
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy (void );
+
+int yyget_debug (void );
+
+void yyset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE yyget_extra (void );
+
+void yyset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *yyget_in (void );
+
+void yyset_in  (FILE * in_str  );
+
+FILE *yyget_out (void );
+
+void yyset_out  (FILE * out_str  );
+
+int yyget_leng (void );
+
+char *yyget_text (void );
+
+int yyget_lineno (void );
+
+void yyset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap (void );
+#else
+extern int yywrap (void );
+#endif
+#endif
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO fwrite( yytext, yyleng, 1, yyout )
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		int n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 39 "syslex.l"
+
+#line 722 "syslex.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer(yyin,YY_BUF_SIZE );
+		}
+
+		yy_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of yytext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 81 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 101 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 40 "syslex.l"
+{ return '(';}
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 41 "syslex.l"
+{ return ')';}
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 42 "syslex.l"
+{ return '[';}
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 43 "syslex.l"
+{ return ']';}
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 44 "syslex.l"
+{ ; }
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 45 "syslex.l"
+{ ; } 
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 46 "syslex.l"
+{ ; }
+	YY_BREAK
+case 8:
+/* rule 8 can match eol */
+YY_RULE_SETUP
+#line 47 "syslex.l"
+{ ; }
+	YY_BREAK
+case 9:
+/* rule 9 can match eol */
+YY_RULE_SETUP
+#line 48 "syslex.l"
+{
+	yylval.s = malloc (yyleng - 1);
+	memcpy (yylval.s, yytext + 1, yyleng - 2);
+	yylval.s[yyleng - 2] = '\0';
+        return NAME;
+	}
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 55 "syslex.l"
+{
+        yylval.i = strtol(yytext,0,16);
+	return  NUMBER;
+	}
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 60 "syslex.l"
+{
+        yylval.i = atoi(yytext);
+	return  NUMBER;
+	}
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 66 "syslex.l"
+{ yylval.i =1 ;return UNIT;}
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 67 "syslex.l"
+{ yylval.i = 1; return UNIT;}
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 68 "syslex.l"
+{ yylval.i= 8; return UNIT;}
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 69 "syslex.l"
+{ yylval.i = 8; return UNIT;}
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 71 "syslex.l"
+{ yylval.s = "INT"; return TYPE;}
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 72 "syslex.l"
+{ yylval.s = "BARRAY"; return TYPE;}
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 73 "syslex.l"
+{ yylval.s = "CHARS"; return TYPE;}
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 74 "syslex.l"
+{ yylval.i = 0; return NUMBER;}
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 75 "syslex.l"
+{ yylval.i = -4; return NUMBER;}
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+#line 76 "syslex.l"
+{ yylval.i = -2; return NUMBER; }
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+#line 77 "syslex.l"
+{ yylval.i = -1; return NUMBER; }
+	YY_BREAK
+case 23:
+YY_RULE_SETUP
+#line 78 "syslex.l"
+{ return COND;}
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+#line 79 "syslex.l"
+{ return REPEAT;}
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+#line 80 "syslex.l"
+ECHO;
+	YY_BREAK
+#line 943 "syslex.c"
+case YY_STATE_EOF(INITIAL):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( yywrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of yylex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart(yyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 81 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 81 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 80);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up yytext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart(yyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void yyrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer(yyin,YY_BUF_SIZE );
+	}
+
+	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
+	yy_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void yy_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * 
+ */
+    void yy_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yyfree((void *) b->yy_ch_buf  );
+
+	yyfree((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	yy_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void yypop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void yyensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
+{
+    
+	return yy_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) yyalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
+{
+        
+    return yylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int yyget_leng  (void)
+{
+        return yyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *yyget_text  (void)
+{
+        return yytext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void yyset_lineno (int  line_number )
+{
+    
+    yylineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  in_str )
+{
+        yyin = in_str ;
+}
+
+void yyset_out (FILE *  out_str )
+{
+        yyout = out_str ;
+}
+
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
+
+void yyset_debug (int  bdebug )
+{
+        yy_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = (FILE *) 0;
+    yyout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *yyalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *yyrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void yyfree (void * ptr )
+{
+	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 80 "syslex.l"
==== (added) binutils-2.19.91.20091006/ld/deffilep.c ====
--- /dev/null	2009-05-01 06:17:58.000000000 +0200
+++ binutils-2.19.91.20091006/ld/deffilep.c	2009-10-07 08:19:45.000000000 +0200
@@ -0,0 +1,3050 @@
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.4.1"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+
+
+/* Copy the first part of user declarations.  */
+
+/* Line 189 of yacc.c  */
+#line 1 "deffilep.y"
+ /* deffilep.y - parser for .def files */
+
+/*   Copyright 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006,
+     2007, 2009 Free Software Foundation, Inc.
+
+     This file is part of GNU Binutils.
+
+     This program is free software; you can redistribute it and/or modify
+     it under the terms of the GNU General Public License as published by
+     the Free Software Foundation; either version 3 of the License, or
+     (at your option) any later version.
+
+     This program is distributed in the hope that it will be useful,
+     but WITHOUT ANY WARRANTY; without even the implied warranty of
+     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+     GNU General Public License for more details.
+
+     You should have received a copy of the GNU General Public License
+     along with this program; if not, write to the Free Software
+     Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+     MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "libiberty.h"
+#include "safe-ctype.h"
+#include "bfd.h"
+#include "ld.h"
+#include "ldmisc.h"
+#include "deffile.h"
+
+#define TRACE 0
+
+#define ROUND_UP(a, b) (((a)+((b)-1))&~((b)-1))
+
+/* Remap normal yacc parser interface names (yyparse, yylex, yyerror, etc),
+   as well as gratuitiously global symbol names, so we can have multiple
+   yacc generated parsers in ld.  Note that these are only the variables
+   produced by yacc.  If other parser generators (bison, byacc, etc) produce
+   additional global names that conflict at link time, then those parser
+   generators need to be fixed instead of adding those names to this list.  */
+
+#define	yymaxdepth def_maxdepth
+#define	yyparse	def_parse
+#define	yylex	def_lex
+#define	yyerror	def_error
+#define	yylval	def_lval
+#define	yychar	def_char
+#define	yydebug	def_debug
+#define	yypact	def_pact	
+#define	yyr1	def_r1			
+#define	yyr2	def_r2			
+#define	yydef	def_def		
+#define	yychk	def_chk		
+#define	yypgo	def_pgo		
+#define	yyact	def_act		
+#define	yyexca	def_exca
+#define yyerrflag def_errflag
+#define yynerrs	def_nerrs
+#define	yyps	def_ps
+#define	yypv	def_pv
+#define	yys	def_s
+#define	yy_yys	def_yys
+#define	yystate	def_state
+#define	yytmp	def_tmp
+#define	yyv	def_v
+#define	yy_yyv	def_yyv
+#define	yyval	def_val
+#define	yylloc	def_lloc
+#define yyreds	def_reds		/* With YYDEBUG defined.  */
+#define yytoks	def_toks		/* With YYDEBUG defined.  */
+#define yylhs	def_yylhs
+#define yylen	def_yylen
+#define yydefred def_yydefred
+#define yydgoto	def_yydgoto
+#define yysindex def_yysindex
+#define yyrindex def_yyrindex
+#define yygindex def_yygindex
+#define yytable	 def_yytable
+#define yycheck	 def_yycheck
+
+static void def_description (const char *);
+static void def_exports (const char *, const char *, int, int);
+static void def_heapsize (int, int);
+static void def_import (const char *, const char *, const char *, const char *,
+			int);
+static void def_image_name (const char *, int, int);
+static void def_section (const char *, int);
+static void def_section_alt (const char *, const char *);
+static void def_stacksize (int, int);
+static void def_version (int, int);
+static void def_directive (char *);
+static void def_aligncomm (char *str, int align);
+static int def_parse (void);
+static int def_error (const char *);
+static int def_lex (void);
+
+static int lex_forced_token = 0;
+static const char *lex_parse_string = 0;
+static const char *lex_parse_string_end = 0;
+
+
+
+/* Line 189 of yacc.c  */
+#line 176 "deffilep.c"
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     NAME = 258,
+     LIBRARY = 259,
+     DESCRIPTION = 260,
+     STACKSIZE_K = 261,
+     HEAPSIZE = 262,
+     CODE = 263,
+     DATAU = 264,
+     DATAL = 265,
+     SECTIONS = 266,
+     EXPORTS = 267,
+     IMPORTS = 268,
+     VERSIONK = 269,
+     BASE = 270,
+     CONSTANTU = 271,
+     CONSTANTL = 272,
+     PRIVATEU = 273,
+     PRIVATEL = 274,
+     ALIGNCOMM = 275,
+     READ = 276,
+     WRITE = 277,
+     EXECUTE = 278,
+     SHARED = 279,
+     NONAMEU = 280,
+     NONAMEL = 281,
+     DIRECTIVE = 282,
+     ID = 283,
+     DIGITS = 284
+   };
+#endif
+/* Tokens.  */
+#define NAME 258
+#define LIBRARY 259
+#define DESCRIPTION 260
+#define STACKSIZE_K 261
+#define HEAPSIZE 262
+#define CODE 263
+#define DATAU 264
+#define DATAL 265
+#define SECTIONS 266
+#define EXPORTS 267
+#define IMPORTS 268
+#define VERSIONK 269
+#define BASE 270
+#define CONSTANTU 271
+#define CONSTANTL 272
+#define PRIVATEU 273
+#define PRIVATEL 274
+#define ALIGNCOMM 275
+#define READ 276
+#define WRITE 277
+#define EXECUTE 278
+#define SHARED 279
+#define NONAMEU 280
+#define NONAMEL 281
+#define DIRECTIVE 282
+#define ID 283
+#define DIGITS 284
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 214 of yacc.c  */
+#line 103 "deffilep.y"
+
+  char *id;
+  int number;
+  char *digits;
+
+
+
+/* Line 214 of yacc.c  */
+#line 278 "deffilep.c"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 264 of yacc.c  */
+#line 290 "deffilep.c"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
+{
+  return yyi;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  44
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   107
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  34
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  24
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  71
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  107
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   284
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,    31,     2,    30,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,    32,     2,     2,    33,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint8 yyprhs[] =
+{
+       0,     0,     3,     6,     8,    12,    16,    19,    23,    27,
+      30,    33,    36,    39,    42,    45,    50,    53,    58,    59,
+      61,    64,    70,    74,    75,    77,    79,    81,    83,    85,
+      87,    89,    91,    94,    96,   104,   112,   118,   124,   130,
+     134,   137,   139,   142,   145,   149,   151,   153,   154,   157,
+     158,   160,   162,   164,   166,   168,   172,   173,   176,   177,
+     180,   181,   185,   186,   188,   192,   194,   199,   201,   202,
+     204,   205
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      35,     0,    -1,    35,    36,    -1,    36,    -1,     3,    49,
+      52,    -1,     4,    49,    52,    -1,     5,    28,    -1,     6,
+      57,    47,    -1,     7,    57,    47,    -1,     8,    45,    -1,
+       9,    45,    -1,    11,    43,    -1,    12,    37,    -1,    13,
+      41,    -1,    14,    57,    -1,    14,    57,    30,    57,    -1,
+      27,    28,    -1,    20,    54,    31,    57,    -1,    -1,    38,
+      -1,    37,    38,    -1,    53,    51,    50,    46,    39,    -1,
+      40,    46,    39,    -1,    -1,    25,    -1,    26,    -1,    16,
+      -1,    17,    -1,     9,    -1,    10,    -1,    18,    -1,    19,
+      -1,    41,    42,    -1,    42,    -1,    28,    32,    28,    30,
+      28,    30,    28,    -1,    28,    32,    28,    30,    28,    30,
+      57,    -1,    28,    32,    28,    30,    28,    -1,    28,    32,
+      28,    30,    57,    -1,    28,    30,    28,    30,    28,    -1,
+      28,    30,    28,    -1,    43,    44,    -1,    44,    -1,    28,
+      45,    -1,    28,    28,    -1,    45,    46,    48,    -1,    48,
+      -1,    31,    -1,    -1,    31,    57,    -1,    -1,    21,    -1,
+      22,    -1,    23,    -1,    24,    -1,    28,    -1,    28,    30,
+      28,    -1,    -1,    33,    57,    -1,    -1,    32,    53,    -1,
+      -1,    15,    32,    57,    -1,    -1,    28,    -1,    53,    30,
+      28,    -1,    28,    -1,    54,    30,    55,    56,    -1,    29,
+      -1,    -1,    28,    -1,    -1,    29,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   123,   123,   124,   128,   129,   130,   131,   132,   133,
+     134,   135,   136,   137,   138,   139,   140,   141,   145,   147,
+     148,   155,   162,   163,   166,   167,   168,   169,   170,   171,
+     172,   173,   176,   177,   181,   182,   183,   184,   185,   186,
+     190,   191,   195,   196,   200,   201,   205,   206,   208,   209,
+     213,   214,   215,   216,   219,   220,   226,   230,   231,   235,
+     236,   239,   240,   243,   244,   252,   253,   261,   262,   265,
+     266,   269
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "NAME", "LIBRARY", "DESCRIPTION",
+  "STACKSIZE_K", "HEAPSIZE", "CODE", "DATAU", "DATAL", "SECTIONS",
+  "EXPORTS", "IMPORTS", "VERSIONK", "BASE", "CONSTANTU", "CONSTANTL",
+  "PRIVATEU", "PRIVATEL", "ALIGNCOMM", "READ", "WRITE", "EXECUTE",
+  "SHARED", "NONAMEU", "NONAMEL", "DIRECTIVE", "ID", "DIGITS", "'.'",
+  "','", "'='", "'@'", "$accept", "start", "command", "explist", "expline",
+  "exp_opt_list", "exp_opt", "implist", "impline", "seclist", "secline",
+  "attr_list", "opt_comma", "opt_number", "attr", "opt_name",
+  "opt_ordinal", "opt_equal_name", "opt_base", "dot_name", "anylang_id",
+  "opt_digits", "opt_id", "NUMBER", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+      46,    44,    61,    64
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    34,    35,    35,    36,    36,    36,    36,    36,    36,
+      36,    36,    36,    36,    36,    36,    36,    36,    37,    37,
+      37,    38,    39,    39,    40,    40,    40,    40,    40,    40,
+      40,    40,    41,    41,    42,    42,    42,    42,    42,    42,
+      43,    43,    44,    44,    45,    45,    46,    46,    47,    47,
+      48,    48,    48,    48,    49,    49,    49,    50,    50,    51,
+      51,    52,    52,    53,    53,    54,    54,    55,    55,    56,
+      56,    57
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     2,     1,     3,     3,     2,     3,     3,     2,
+       2,     2,     2,     2,     2,     4,     2,     4,     0,     1,
+       2,     5,     3,     0,     1,     1,     1,     1,     1,     1,
+       1,     1,     2,     1,     7,     7,     5,     5,     5,     3,
+       2,     1,     2,     2,     3,     1,     1,     0,     2,     0,
+       1,     1,     1,     1,     1,     3,     0,     2,     0,     2,
+       0,     3,     0,     1,     3,     1,     4,     1,     0,     1,
+       0,     1
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       0,    56,    56,     0,     0,     0,     0,     0,     0,    18,
+       0,     0,     0,     0,     0,     3,    54,    62,    62,     6,
+      71,    49,    49,    50,    51,    52,    53,     9,    45,    10,
+       0,    11,    41,    63,    12,    19,    60,     0,    13,    33,
+      14,    65,     0,    16,     1,     2,     0,     0,     4,     5,
+       0,     7,     8,    46,     0,    43,    42,    40,    20,     0,
+       0,    58,     0,     0,    32,     0,    68,     0,    55,     0,
+      48,    44,    64,    59,     0,    47,    39,     0,    15,    67,
+      70,    17,    61,    57,    23,     0,     0,    69,    66,    28,
+      29,    26,    27,    30,    31,    24,    25,    21,    47,    38,
+      36,    37,    23,     0,    22,    34,    35
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
+{
+      -1,    14,    15,    34,    35,    97,    98,    38,    39,    31,
+      32,    27,    54,    51,    28,    17,    75,    61,    48,    36,
+      42,    80,    88,    21
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -74
+static const yytype_int8 yypact[] =
+{
+      29,   -27,   -27,   -23,   -15,   -15,    30,    30,     2,    11,
+      19,   -15,    27,    33,     4,   -74,    -7,    48,    48,   -74,
+     -74,    26,    26,   -74,   -74,   -74,   -74,    -2,   -74,    -2,
+      55,     2,   -74,   -74,    11,   -74,    14,    18,    19,   -74,
+      50,   -74,    -3,   -74,   -74,   -74,    54,    52,   -74,   -74,
+     -15,   -74,   -74,   -74,    30,   -74,    -2,   -74,   -74,    57,
+      11,    53,    59,    60,   -74,   -15,    61,   -15,   -74,   -15,
+     -74,   -74,   -74,    62,   -15,    58,    63,    64,   -74,   -74,
+      67,   -74,   -74,   -74,    49,    68,    42,   -74,   -74,   -74,
+     -74,   -74,   -74,   -74,   -74,   -74,   -74,   -74,    58,   -74,
+      69,   -74,    49,    44,   -74,   -74,   -74
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+     -74,   -74,    77,   -74,    66,    -1,   -74,   -74,    65,   -74,
+      71,    -4,   -73,    75,    51,   102,   -74,   -74,    88,    47,
+     -74,   -74,   -74,    -5
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -48
+static const yytype_int8 yytable[] =
+{
+      22,    16,    84,    29,    44,    19,    40,     1,     2,     3,
+       4,     5,     6,     7,    20,     8,     9,    10,    11,   -47,
+     -47,   -47,   -47,    46,    12,   102,    56,    66,    67,    53,
+      30,    13,     1,     2,     3,     4,     5,     6,     7,    33,
+       8,     9,    10,    11,    59,    70,    60,    37,    62,    12,
+      63,    23,    24,    25,    26,    41,    13,    50,    89,    90,
+      78,    43,    81,    47,    82,    91,    92,    93,    94,    83,
+     100,    20,   105,    20,    95,    96,    23,    24,    25,    26,
+      65,   101,    68,    55,    69,    72,    74,    76,    77,    53,
+      79,    45,    59,    85,    86,    87,    99,    52,   106,   103,
+      58,   104,    57,    64,    18,    71,    49,    73
+};
+
+static const yytype_uint8 yycheck[] =
+{
+       5,    28,    75,     7,     0,    28,    11,     3,     4,     5,
+       6,     7,     8,     9,    29,    11,    12,    13,    14,    21,
+      22,    23,    24,    30,    20,    98,    30,    30,    31,    31,
+      28,    27,     3,     4,     5,     6,     7,     8,     9,    28,
+      11,    12,    13,    14,    30,    50,    32,    28,    30,    20,
+      32,    21,    22,    23,    24,    28,    27,    31,     9,    10,
+      65,    28,    67,    15,    69,    16,    17,    18,    19,    74,
+      28,    29,    28,    29,    25,    26,    21,    22,    23,    24,
+      30,    86,    28,    28,    32,    28,    33,    28,    28,    31,
+      29,    14,    30,    30,    30,    28,    28,    22,   103,    30,
+      34,   102,    31,    38,     2,    54,    18,    60
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,     3,     4,     5,     6,     7,     8,     9,    11,    12,
+      13,    14,    20,    27,    35,    36,    28,    49,    49,    28,
+      29,    57,    57,    21,    22,    23,    24,    45,    48,    45,
+      28,    43,    44,    28,    37,    38,    53,    28,    41,    42,
+      57,    28,    54,    28,     0,    36,    30,    15,    52,    52,
+      31,    47,    47,    31,    46,    28,    45,    44,    38,    30,
+      32,    51,    30,    32,    42,    30,    30,    31,    28,    32,
+      57,    48,    28,    53,    33,    50,    28,    28,    57,    29,
+      55,    57,    57,    57,    46,    30,    30,    28,    56,     9,
+      10,    16,    17,    18,    19,    25,    26,    39,    40,    28,
+      28,    57,    46,    30,    39,    28,    57
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+#else
+static void
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+
+      default:
+	break;
+    }
+}
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*-------------------------.
+| yyparse or yypush_parse.  |
+`-------------------------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+
+
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 4:
+
+/* Line 1455 of yacc.c  */
+#line 128 "deffilep.y"
+    { def_image_name ((yyvsp[(2) - (3)].id), (yyvsp[(3) - (3)].number), 0); }
+    break;
+
+  case 5:
+
+/* Line 1455 of yacc.c  */
+#line 129 "deffilep.y"
+    { def_image_name ((yyvsp[(2) - (3)].id), (yyvsp[(3) - (3)].number), 1); }
+    break;
+
+  case 6:
+
+/* Line 1455 of yacc.c  */
+#line 130 "deffilep.y"
+    { def_description ((yyvsp[(2) - (2)].id));}
+    break;
+
+  case 7:
+
+/* Line 1455 of yacc.c  */
+#line 131 "deffilep.y"
+    { def_stacksize ((yyvsp[(2) - (3)].number), (yyvsp[(3) - (3)].number));}
+    break;
+
+  case 8:
+
+/* Line 1455 of yacc.c  */
+#line 132 "deffilep.y"
+    { def_heapsize ((yyvsp[(2) - (3)].number), (yyvsp[(3) - (3)].number));}
+    break;
+
+  case 9:
+
+/* Line 1455 of yacc.c  */
+#line 133 "deffilep.y"
+    { def_section ("CODE", (yyvsp[(2) - (2)].number));}
+    break;
+
+  case 10:
+
+/* Line 1455 of yacc.c  */
+#line 134 "deffilep.y"
+    { def_section ("DATA", (yyvsp[(2) - (2)].number));}
+    break;
+
+  case 14:
+
+/* Line 1455 of yacc.c  */
+#line 138 "deffilep.y"
+    { def_version ((yyvsp[(2) - (2)].number), 0);}
+    break;
+
+  case 15:
+
+/* Line 1455 of yacc.c  */
+#line 139 "deffilep.y"
+    { def_version ((yyvsp[(2) - (4)].number), (yyvsp[(4) - (4)].number));}
+    break;
+
+  case 16:
+
+/* Line 1455 of yacc.c  */
+#line 140 "deffilep.y"
+    { def_directive ((yyvsp[(2) - (2)].id));}
+    break;
+
+  case 17:
+
+/* Line 1455 of yacc.c  */
+#line 141 "deffilep.y"
+    { def_aligncomm ((yyvsp[(2) - (4)].id), (yyvsp[(4) - (4)].number));}
+    break;
+
+  case 21:
+
+/* Line 1455 of yacc.c  */
+#line 156 "deffilep.y"
+    { def_exports ((yyvsp[(1) - (5)].id), (yyvsp[(2) - (5)].id), (yyvsp[(3) - (5)].number), (yyvsp[(5) - (5)].number)); }
+    break;
+
+  case 22:
+
+/* Line 1455 of yacc.c  */
+#line 162 "deffilep.y"
+    { (yyval.number) = (yyvsp[(1) - (3)].number) | (yyvsp[(3) - (3)].number); }
+    break;
+
+  case 23:
+
+/* Line 1455 of yacc.c  */
+#line 163 "deffilep.y"
+    { (yyval.number) = 0; }
+    break;
+
+  case 24:
+
+/* Line 1455 of yacc.c  */
+#line 166 "deffilep.y"
+    { (yyval.number) = 1; }
+    break;
+
+  case 25:
+
+/* Line 1455 of yacc.c  */
+#line 167 "deffilep.y"
+    { (yyval.number) = 1; }
+    break;
+
+  case 26:
+
+/* Line 1455 of yacc.c  */
+#line 168 "deffilep.y"
+    { (yyval.number) = 2; }
+    break;
+
+  case 27:
+
+/* Line 1455 of yacc.c  */
+#line 169 "deffilep.y"
+    { (yyval.number) = 2; }
+    break;
+
+  case 28:
+
+/* Line 1455 of yacc.c  */
+#line 170 "deffilep.y"
+    { (yyval.number) = 4; }
+    break;
+
+  case 29:
+
+/* Line 1455 of yacc.c  */
+#line 171 "deffilep.y"
+    { (yyval.number) = 4; }
+    break;
+
+  case 30:
+
+/* Line 1455 of yacc.c  */
+#line 172 "deffilep.y"
+    { (yyval.number) = 8; }
+    break;
+
+  case 31:
+
+/* Line 1455 of yacc.c  */
+#line 173 "deffilep.y"
+    { (yyval.number) = 8; }
+    break;
+
+  case 34:
+
+/* Line 1455 of yacc.c  */
+#line 181 "deffilep.y"
+    { def_import ((yyvsp[(1) - (7)].id), (yyvsp[(3) - (7)].id), (yyvsp[(5) - (7)].id), (yyvsp[(7) - (7)].id), -1); }
+    break;
+
+  case 35:
+
+/* Line 1455 of yacc.c  */
+#line 182 "deffilep.y"
+    { def_import ((yyvsp[(1) - (7)].id), (yyvsp[(3) - (7)].id), (yyvsp[(5) - (7)].id),  0, (yyvsp[(7) - (7)].number)); }
+    break;
+
+  case 36:
+
+/* Line 1455 of yacc.c  */
+#line 183 "deffilep.y"
+    { def_import ((yyvsp[(1) - (5)].id), (yyvsp[(3) - (5)].id),  0, (yyvsp[(5) - (5)].id), -1); }
+    break;
+
+  case 37:
+
+/* Line 1455 of yacc.c  */
+#line 184 "deffilep.y"
+    { def_import ((yyvsp[(1) - (5)].id), (yyvsp[(3) - (5)].id),  0,  0, (yyvsp[(5) - (5)].number)); }
+    break;
+
+  case 38:
+
+/* Line 1455 of yacc.c  */
+#line 185 "deffilep.y"
+    { def_import ( 0, (yyvsp[(1) - (5)].id), (yyvsp[(3) - (5)].id), (yyvsp[(5) - (5)].id), -1); }
+    break;
+
+  case 39:
+
+/* Line 1455 of yacc.c  */
+#line 186 "deffilep.y"
+    { def_import ( 0, (yyvsp[(1) - (3)].id),  0, (yyvsp[(3) - (3)].id), -1); }
+    break;
+
+  case 42:
+
+/* Line 1455 of yacc.c  */
+#line 195 "deffilep.y"
+    { def_section ((yyvsp[(1) - (2)].id), (yyvsp[(2) - (2)].number));}
+    break;
+
+  case 43:
+
+/* Line 1455 of yacc.c  */
+#line 196 "deffilep.y"
+    { def_section_alt ((yyvsp[(1) - (2)].id), (yyvsp[(2) - (2)].id));}
+    break;
+
+  case 44:
+
+/* Line 1455 of yacc.c  */
+#line 200 "deffilep.y"
+    { (yyval.number) = (yyvsp[(1) - (3)].number) | (yyvsp[(3) - (3)].number); }
+    break;
+
+  case 45:
+
+/* Line 1455 of yacc.c  */
+#line 201 "deffilep.y"
+    { (yyval.number) = (yyvsp[(1) - (1)].number); }
+    break;
+
+  case 48:
+
+/* Line 1455 of yacc.c  */
+#line 208 "deffilep.y"
+    { (yyval.number)=(yyvsp[(2) - (2)].number);}
+    break;
+
+  case 49:
+
+/* Line 1455 of yacc.c  */
+#line 209 "deffilep.y"
+    { (yyval.number)=-1;}
+    break;
+
+  case 50:
+
+/* Line 1455 of yacc.c  */
+#line 213 "deffilep.y"
+    { (yyval.number) = 1;}
+    break;
+
+  case 51:
+
+/* Line 1455 of yacc.c  */
+#line 214 "deffilep.y"
+    { (yyval.number) = 2;}
+    break;
+
+  case 52:
+
+/* Line 1455 of yacc.c  */
+#line 215 "deffilep.y"
+    { (yyval.number)=4;}
+    break;
+
+  case 53:
+
+/* Line 1455 of yacc.c  */
+#line 216 "deffilep.y"
+    { (yyval.number)=8;}
+    break;
+
+  case 54:
+
+/* Line 1455 of yacc.c  */
+#line 219 "deffilep.y"
+    { (yyval.id) = (yyvsp[(1) - (1)].id); }
+    break;
+
+  case 55:
+
+/* Line 1455 of yacc.c  */
+#line 221 "deffilep.y"
+    { 
+	    char *name = xmalloc (strlen ((yyvsp[(1) - (3)].id)) + 1 + strlen ((yyvsp[(3) - (3)].id)) + 1);
+	    sprintf (name, "%s.%s", (yyvsp[(1) - (3)].id), (yyvsp[(3) - (3)].id));
+	    (yyval.id) = name;
+	  }
+    break;
+
+  case 56:
+
+/* Line 1455 of yacc.c  */
+#line 226 "deffilep.y"
+    { (yyval.id) = ""; }
+    break;
+
+  case 57:
+
+/* Line 1455 of yacc.c  */
+#line 230 "deffilep.y"
+    { (yyval.number) = (yyvsp[(2) - (2)].number);}
+    break;
+
+  case 58:
+
+/* Line 1455 of yacc.c  */
+#line 231 "deffilep.y"
+    { (yyval.number) = -1;}
+    break;
+
+  case 59:
+
+/* Line 1455 of yacc.c  */
+#line 235 "deffilep.y"
+    { (yyval.id) = (yyvsp[(2) - (2)].id); }
+    break;
+
+  case 60:
+
+/* Line 1455 of yacc.c  */
+#line 236 "deffilep.y"
+    { (yyval.id) =  0; }
+    break;
+
+  case 61:
+
+/* Line 1455 of yacc.c  */
+#line 239 "deffilep.y"
+    { (yyval.number) = (yyvsp[(3) - (3)].number);}
+    break;
+
+  case 62:
+
+/* Line 1455 of yacc.c  */
+#line 240 "deffilep.y"
+    { (yyval.number) = -1;}
+    break;
+
+  case 63:
+
+/* Line 1455 of yacc.c  */
+#line 243 "deffilep.y"
+    { (yyval.id) = (yyvsp[(1) - (1)].id); }
+    break;
+
+  case 64:
+
+/* Line 1455 of yacc.c  */
+#line 245 "deffilep.y"
+    { 
+	    char *name = xmalloc (strlen ((yyvsp[(1) - (3)].id)) + 1 + strlen ((yyvsp[(3) - (3)].id)) + 1);
+	    sprintf (name, "%s.%s", (yyvsp[(1) - (3)].id), (yyvsp[(3) - (3)].id));
+	    (yyval.id) = name;
+	  }
+    break;
+
+  case 65:
+
+/* Line 1455 of yacc.c  */
+#line 252 "deffilep.y"
+    { (yyval.id) = (yyvsp[(1) - (1)].id); }
+    break;
+
+  case 66:
+
+/* Line 1455 of yacc.c  */
+#line 254 "deffilep.y"
+    {
+	    char *id = xmalloc (strlen ((yyvsp[(1) - (4)].id)) + 1 + strlen ((yyvsp[(3) - (4)].digits)) + strlen ((yyvsp[(4) - (4)].id)) + 1);
+	    sprintf (id, "%s.%s%s", (yyvsp[(1) - (4)].id), (yyvsp[(3) - (4)].digits), (yyvsp[(4) - (4)].id));
+	    (yyval.id) = id;
+	  }
+    break;
+
+  case 67:
+
+/* Line 1455 of yacc.c  */
+#line 261 "deffilep.y"
+    { (yyval.digits) = (yyvsp[(1) - (1)].digits); }
+    break;
+
+  case 68:
+
+/* Line 1455 of yacc.c  */
+#line 262 "deffilep.y"
+    { (yyval.digits) = ""; }
+    break;
+
+  case 69:
+
+/* Line 1455 of yacc.c  */
+#line 265 "deffilep.y"
+    { (yyval.id) = (yyvsp[(1) - (1)].id); }
+    break;
+
+  case 70:
+
+/* Line 1455 of yacc.c  */
+#line 266 "deffilep.y"
+    { (yyval.id) = ""; }
+    break;
+
+  case 71:
+
+/* Line 1455 of yacc.c  */
+#line 269 "deffilep.y"
+    { (yyval.number) = strtoul ((yyvsp[(1) - (1)].digits), 0, 0); }
+    break;
+
+
+
+/* Line 1455 of yacc.c  */
+#line 1987 "deffilep.c"
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined(yyoverflow) || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+
+/* Line 1675 of yacc.c  */
+#line 271 "deffilep.y"
+
+
+/*****************************************************************************
+ API
+ *****************************************************************************/
+
+static FILE *the_file;
+static const char *def_filename;
+static int linenumber;
+static def_file *def;
+static int saw_newline;
+
+struct directive
+  {
+    struct directive *next;
+    char *name;
+    int len;
+  };
+
+static struct directive *directives = 0;
+
+def_file *
+def_file_empty (void)
+{
+  def_file *rv = xmalloc (sizeof (def_file));
+  memset (rv, 0, sizeof (def_file));
+  rv->is_dll = -1;
+  rv->base_address = (bfd_vma) -1;
+  rv->stack_reserve = rv->stack_commit = -1;
+  rv->heap_reserve = rv->heap_commit = -1;
+  rv->version_major = rv->version_minor = -1;
+  return rv;
+}
+
+def_file *
+def_file_parse (const char *filename, def_file *add_to)
+{
+  struct directive *d;
+
+  the_file = fopen (filename, "r");
+  def_filename = filename;
+  linenumber = 1;
+  if (!the_file)
+    {
+      perror (filename);
+      return 0;
+    }
+  if (add_to)
+    {
+      def = add_to;
+    }
+  else
+    {
+      def = def_file_empty ();
+    }
+
+  saw_newline = 1;
+  if (def_parse ())
+    {
+      def_file_free (def);
+      fclose (the_file);
+      return 0;
+    }
+
+  fclose (the_file);
+
+  for (d = directives; d; d = d->next)
+    {
+#if TRACE
+      printf ("Adding directive %08x `%s'\n", d->name, d->name);
+#endif
+      def_file_add_directive (def, d->name, d->len);
+    }
+
+  return def;
+}
+
+void
+def_file_free (def_file *def)
+{
+  int i;
+
+  if (!def)
+    return;
+  if (def->name)
+    free (def->name);
+  if (def->description)
+    free (def->description);
+
+  if (def->section_defs)
+    {
+      for (i = 0; i < def->num_section_defs; i++)
+	{
+	  if (def->section_defs[i].name)
+	    free (def->section_defs[i].name);
+	  if (def->section_defs[i].class)
+	    free (def->section_defs[i].class);
+	}
+      free (def->section_defs);
+    }
+
+  if (def->exports)
+    {
+      for (i = 0; i < def->num_exports; i++)
+	{
+	  if (def->exports[i].internal_name
+	      && def->exports[i].internal_name != def->exports[i].name)
+	    free (def->exports[i].internal_name);
+	  if (def->exports[i].name)
+	    free (def->exports[i].name);
+	}
+      free (def->exports);
+    }
+
+  if (def->imports)
+    {
+      for (i = 0; i < def->num_imports; i++)
+	{
+	  if (def->imports[i].internal_name
+	      && def->imports[i].internal_name != def->imports[i].name)
+	    free (def->imports[i].internal_name);
+	  if (def->imports[i].name)
+	    free (def->imports[i].name);
+	}
+      free (def->imports);
+    }
+
+  while (def->modules)
+    {
+      def_file_module *m = def->modules;
+      def->modules = def->modules->next;
+      free (m);
+    }
+
+  while (def->aligncomms)
+    {
+      def_file_aligncomm *c = def->aligncomms;
+      def->aligncomms = def->aligncomms->next;
+      free (c->symbol_name);
+      free (c);
+    }
+
+  free (def);
+}
+
+#ifdef DEF_FILE_PRINT
+void
+def_file_print (FILE *file, def_file *def)
+{
+  int i;
+
+  fprintf (file, ">>>> def_file at 0x%08x\n", def);
+  if (def->name)
+    fprintf (file, "  name: %s\n", def->name ? def->name : "(unspecified)");
+  if (def->is_dll != -1)
+    fprintf (file, "  is dll: %s\n", def->is_dll ? "yes" : "no");
+  if (def->base_address != (bfd_vma) -1)
+    fprintf (file, "  base address: 0x%08x\n", def->base_address);
+  if (def->description)
+    fprintf (file, "  description: `%s'\n", def->description);
+  if (def->stack_reserve != -1)
+    fprintf (file, "  stack reserve: 0x%08x\n", def->stack_reserve);
+  if (def->stack_commit != -1)
+    fprintf (file, "  stack commit: 0x%08x\n", def->stack_commit);
+  if (def->heap_reserve != -1)
+    fprintf (file, "  heap reserve: 0x%08x\n", def->heap_reserve);
+  if (def->heap_commit != -1)
+    fprintf (file, "  heap commit: 0x%08x\n", def->heap_commit);
+
+  if (def->num_section_defs > 0)
+    {
+      fprintf (file, "  section defs:\n");
+
+      for (i = 0; i < def->num_section_defs; i++)
+	{
+	  fprintf (file, "    name: `%s', class: `%s', flags:",
+		   def->section_defs[i].name, def->section_defs[i].class);
+	  if (def->section_defs[i].flag_read)
+	    fprintf (file, " R");
+	  if (def->section_defs[i].flag_write)
+	    fprintf (file, " W");
+	  if (def->section_defs[i].flag_execute)
+	    fprintf (file, " X");
+	  if (def->section_defs[i].flag_shared)
+	    fprintf (file, " S");
+	  fprintf (file, "\n");
+	}
+    }
+
+  if (def->num_exports > 0)
+    {
+      fprintf (file, "  exports:\n");
+
+      for (i = 0; i < def->num_exports; i++)
+	{
+	  fprintf (file, "    name: `%s', int: `%s', ordinal: %d, flags:",
+		   def->exports[i].name, def->exports[i].internal_name,
+		   def->exports[i].ordinal);
+	  if (def->exports[i].flag_private)
+	    fprintf (file, " P");
+	  if (def->exports[i].flag_constant)
+	    fprintf (file, " C");
+	  if (def->exports[i].flag_noname)
+	    fprintf (file, " N");
+	  if (def->exports[i].flag_data)
+	    fprintf (file, " D");
+	  fprintf (file, "\n");
+	}
+    }
+
+  if (def->num_imports > 0)
+    {
+      fprintf (file, "  imports:\n");
+
+      for (i = 0; i < def->num_imports; i++)
+	{
+	  fprintf (file, "    int: %s, from: `%s', name: `%s', ordinal: %d\n",
+		   def->imports[i].internal_name,
+		   def->imports[i].module,
+		   def->imports[i].name,
+		   def->imports[i].ordinal);
+	}
+    }
+
+  if (def->version_major != -1)
+    fprintf (file, "  version: %d.%d\n", def->version_major, def->version_minor);
+
+  fprintf (file, "<<<< def_file at 0x%08x\n", def);
+}
+#endif
+
+def_file_export *
+def_file_add_export (def_file *def,
+		     const char *external_name,
+		     const char *internal_name,
+		     int ordinal)
+{
+  def_file_export *e;
+  int max_exports = ROUND_UP(def->num_exports, 32);
+
+  if (def->num_exports >= max_exports)
+    {
+      max_exports = ROUND_UP(def->num_exports + 1, 32);
+      if (def->exports)
+	def->exports = xrealloc (def->exports,
+				 max_exports * sizeof (def_file_export));
+      else
+	def->exports = xmalloc (max_exports * sizeof (def_file_export));
+    }
+  e = def->exports + def->num_exports;
+  memset (e, 0, sizeof (def_file_export));
+  if (internal_name && !external_name)
+    external_name = internal_name;
+  if (external_name && !internal_name)
+    internal_name = external_name;
+  e->name = xstrdup (external_name);
+  e->internal_name = xstrdup (internal_name);
+  e->ordinal = ordinal;
+  def->num_exports++;
+  return e;
+}
+
+def_file_module *
+def_get_module (def_file *def, const char *name)
+{
+  def_file_module *s;
+
+  for (s = def->modules; s; s = s->next)
+    if (strcmp (s->name, name) == 0)
+      return s;
+
+  return NULL;
+}
+
+static def_file_module *
+def_stash_module (def_file *def, const char *name)
+{
+  def_file_module *s;
+
+  if ((s = def_get_module (def, name)) != NULL)
+      return s;
+  s = xmalloc (sizeof (def_file_module) + strlen (name));
+  s->next = def->modules;
+  def->modules = s;
+  s->user_data = 0;
+  strcpy (s->name, name);
+  return s;
+}
+
+def_file_import *
+def_file_add_import (def_file *def,
+		     const char *name,
+		     const char *module,
+		     int ordinal,
+		     const char *internal_name)
+{
+  def_file_import *i;
+  int max_imports = ROUND_UP (def->num_imports, 16);
+
+  if (def->num_imports >= max_imports)
+    {
+      max_imports = ROUND_UP (def->num_imports+1, 16);
+
+      if (def->imports)
+	def->imports = xrealloc (def->imports,
+				 max_imports * sizeof (def_file_import));
+      else
+	def->imports = xmalloc (max_imports * sizeof (def_file_import));
+    }
+  i = def->imports + def->num_imports;
+  memset (i, 0, sizeof (def_file_import));
+  if (name)
+    i->name = xstrdup (name);
+  if (module)
+    i->module = def_stash_module (def, module);
+  i->ordinal = ordinal;
+  if (internal_name)
+    i->internal_name = xstrdup (internal_name);
+  else
+    i->internal_name = i->name;
+  def->num_imports++;
+
+  return i;
+}
+
+struct
+{
+  char *param;
+  int token;
+}
+diropts[] =
+{
+  { "-heap", HEAPSIZE },
+  { "-stack", STACKSIZE_K },
+  { "-attr", SECTIONS },
+  { "-export", EXPORTS },
+  { "-aligncomm", ALIGNCOMM },
+  { 0, 0 }
+};
+
+void
+def_file_add_directive (def_file *my_def, const char *param, int len)
+{
+  def_file *save_def = def;
+  const char *pend = param + len;
+  char * tend = (char *) param;
+  int i;
+
+  def = my_def;
+
+  while (param < pend)
+    {
+      while (param < pend
+	     && (ISSPACE (*param) || *param == '\n' || *param == 0))
+	param++;
+
+      if (param == pend)
+	break;
+
+      /* Scan forward until we encounter any of:
+          - the end of the buffer
+	  - the start of a new option
+	  - a newline seperating options
+          - a NUL seperating options.  */
+      for (tend = (char *) (param + 1);
+	   (tend < pend
+	    && !(ISSPACE (tend[-1]) && *tend == '-')
+	    && *tend != '\n' && *tend != 0);
+	   tend++)
+	;
+
+      for (i = 0; diropts[i].param; i++)
+	{
+	  int len = strlen (diropts[i].param);
+
+	  if (tend - param >= len
+	      && strncmp (param, diropts[i].param, len) == 0
+	      && (param[len] == ':' || param[len] == ' '))
+	    {
+	      lex_parse_string_end = tend;
+	      lex_parse_string = param + len + 1;
+	      lex_forced_token = diropts[i].token;
+	      saw_newline = 0;
+	      if (def_parse ())
+		continue;
+	      break;
+	    }
+	}
+
+      if (!diropts[i].param)
+	{
+	  char saved;
+
+	  saved = * tend;
+	  * tend = 0;
+	  /* xgettext:c-format */
+	  einfo (_("Warning: .drectve `%s' unrecognized\n"), param);
+	  * tend = saved;
+	}
+
+      lex_parse_string = 0;
+      param = tend;
+    }
+
+  def = save_def;
+}
+
+/* Parser Callbacks.  */
+
+static void
+def_image_name (const char *name, int base, int is_dll)
+{
+  /* If a LIBRARY or NAME statement is specified without a name, there is nothing
+     to do here.  We retain the output filename specified on command line.  */
+  if (*name)
+    {
+      const char* image_name = lbasename (name);
+      if (image_name != name)
+	einfo ("%s:%d: Warning: path components stripped from %s, '%s'\n",
+	       def_filename, linenumber, is_dll ? "LIBRARY" : "NAME",
+	       name);
+      if (def->name)
+	free (def->name);
+      /* Append the default suffix, if none specified.  */ 
+      if (strchr (image_name, '.') == 0)
+	{
+	  const char * suffix = is_dll ? ".dll" : ".exe";
+
+	  def->name = xmalloc (strlen (image_name) + strlen (suffix) + 1);
+	  sprintf (def->name, "%s%s", image_name, suffix);
+        }
+      else
+	def->name = xstrdup (image_name);
+    }
+
+  /* Honor a BASE address statement, even if LIBRARY string is empty.  */
+  def->base_address = base;
+  def->is_dll = is_dll;
+}
+
+static void
+def_description (const char *text)
+{
+  int len = def->description ? strlen (def->description) : 0;
+
+  len += strlen (text) + 1;
+  if (def->description)
+    {
+      def->description = xrealloc (def->description, len);
+      strcat (def->description, text);
+    }
+  else
+    {
+      def->description = xmalloc (len);
+      strcpy (def->description, text);
+    }
+}
+
+static void
+def_stacksize (int reserve, int commit)
+{
+  def->stack_reserve = reserve;
+  def->stack_commit = commit;
+}
+
+static void
+def_heapsize (int reserve, int commit)
+{
+  def->heap_reserve = reserve;
+  def->heap_commit = commit;
+}
+
+static void
+def_section (const char *name, int attr)
+{
+  def_file_section *s;
+  int max_sections = ROUND_UP (def->num_section_defs, 4);
+
+  if (def->num_section_defs >= max_sections)
+    {
+      max_sections = ROUND_UP (def->num_section_defs+1, 4);
+
+      if (def->section_defs)
+	def->section_defs = xrealloc (def->section_defs,
+				      max_sections * sizeof (def_file_import));
+      else
+	def->section_defs = xmalloc (max_sections * sizeof (def_file_import));
+    }
+  s = def->section_defs + def->num_section_defs;
+  memset (s, 0, sizeof (def_file_section));
+  s->name = xstrdup (name);
+  if (attr & 1)
+    s->flag_read = 1;
+  if (attr & 2)
+    s->flag_write = 1;
+  if (attr & 4)
+    s->flag_execute = 1;
+  if (attr & 8)
+    s->flag_shared = 1;
+
+  def->num_section_defs++;
+}
+
+static void
+def_section_alt (const char *name, const char *attr)
+{
+  int aval = 0;
+
+  for (; *attr; attr++)
+    {
+      switch (*attr)
+	{
+	case 'R':
+	case 'r':
+	  aval |= 1;
+	  break;
+	case 'W':
+	case 'w':
+	  aval |= 2;
+	  break;
+	case 'X':
+	case 'x':
+	  aval |= 4;
+	  break;
+	case 'S':
+	case 's':
+	  aval |= 8;
+	  break;
+	}
+    }
+  def_section (name, aval);
+}
+
+static void
+def_exports (const char *external_name,
+	     const char *internal_name,
+	     int ordinal,
+	     int flags)
+{
+  def_file_export *dfe;
+
+  if (!internal_name && external_name)
+    internal_name = external_name;
+#if TRACE
+  printf ("def_exports, ext=%s int=%s\n", external_name, internal_name);
+#endif
+
+  dfe = def_file_add_export (def, external_name, internal_name, ordinal);
+  if (flags & 1)
+    dfe->flag_noname = 1;
+  if (flags & 2)
+    dfe->flag_constant = 1;
+  if (flags & 4)
+    dfe->flag_data = 1;
+  if (flags & 8)
+    dfe->flag_private = 1;
+}
+
+static void
+def_import (const char *internal_name,
+	    const char *module,
+	    const char *dllext,
+	    const char *name,
+	    int ordinal)
+{
+  char *buf = 0;
+  const char *ext = dllext ? dllext : "dll";    
+   
+  buf = xmalloc (strlen (module) + strlen (ext) + 2);
+  sprintf (buf, "%s.%s", module, ext);
+  module = buf;
+
+  def_file_add_import (def, name, module, ordinal, internal_name);
+  if (buf)
+    free (buf);
+}
+
+static void
+def_version (int major, int minor)
+{
+  def->version_major = major;
+  def->version_minor = minor;
+}
+
+static void
+def_directive (char *str)
+{
+  struct directive *d = xmalloc (sizeof (struct directive));
+
+  d->next = directives;
+  directives = d;
+  d->name = xstrdup (str);
+  d->len = strlen (str);
+}
+
+static void
+def_aligncomm (char *str, int align)
+{
+  def_file_aligncomm *c = xmalloc (sizeof (def_file_aligncomm));
+
+  c->symbol_name = xstrdup (str);
+  c->alignment = (unsigned int) align;
+
+  c->next = def->aligncomms;
+  def->aligncomms = c;
+}
+
+static int
+def_error (const char *err)
+{
+  einfo ("%P: %s:%d: %s\n",
+	 def_filename ? def_filename : "<unknown-file>", linenumber, err);
+  return 0;
+}
+
+
+/* Lexical Scanner.  */
+
+#undef TRACE
+#define TRACE 0
+
+/* Never freed, but always reused as needed, so no real leak.  */
+static char *buffer = 0;
+static int buflen = 0;
+static int bufptr = 0;
+
+static void
+put_buf (char c)
+{
+  if (bufptr == buflen)
+    {
+      buflen += 50;		/* overly reasonable, eh?  */
+      if (buffer)
+	buffer = xrealloc (buffer, buflen + 1);
+      else
+	buffer = xmalloc (buflen + 1);
+    }
+  buffer[bufptr++] = c;
+  buffer[bufptr] = 0;		/* not optimal, but very convenient.  */
+}
+
+static struct
+{
+  char *name;
+  int token;
+}
+tokens[] =
+{
+  { "BASE", BASE },
+  { "CODE", CODE },
+  { "CONSTANT", CONSTANTU },
+  { "constant", CONSTANTL },
+  { "DATA", DATAU },
+  { "data", DATAL },
+  { "DESCRIPTION", DESCRIPTION },
+  { "DIRECTIVE", DIRECTIVE },
+  { "EXECUTE", EXECUTE },
+  { "EXPORTS", EXPORTS },
+  { "HEAPSIZE", HEAPSIZE },
+  { "IMPORTS", IMPORTS },
+  { "LIBRARY", LIBRARY },
+  { "NAME", NAME },
+  { "NONAME", NONAMEU },
+  { "noname", NONAMEL },
+  { "PRIVATE", PRIVATEU },
+  { "private", PRIVATEL },
+  { "READ", READ },
+  { "SECTIONS", SECTIONS },
+  { "SEGMENTS", SECTIONS },
+  { "SHARED", SHARED },
+  { "STACKSIZE", STACKSIZE_K },
+  { "VERSION", VERSIONK },
+  { "WRITE", WRITE },
+  { 0, 0 }
+};
+
+static int
+def_getc (void)
+{
+  int rv;
+
+  if (lex_parse_string)
+    {
+      if (lex_parse_string >= lex_parse_string_end)
+	rv = EOF;
+      else
+	rv = *lex_parse_string++;
+    }
+  else
+    {
+      rv = fgetc (the_file);
+    }
+  if (rv == '\n')
+    saw_newline = 1;
+  return rv;
+}
+
+static int
+def_ungetc (int c)
+{
+  if (lex_parse_string)
+    {
+      lex_parse_string--;
+      return c;
+    }
+  else
+    return ungetc (c, the_file);
+}
+
+static int
+def_lex (void)
+{
+  int c, i, q;
+
+  if (lex_forced_token)
+    {
+      i = lex_forced_token;
+      lex_forced_token = 0;
+#if TRACE
+      printf ("lex: forcing token %d\n", i);
+#endif
+      return i;
+    }
+
+  c = def_getc ();
+
+  /* Trim leading whitespace.  */
+  while (c != EOF && (c == ' ' || c == '\t') && saw_newline)
+    c = def_getc ();
+
+  if (c == EOF)
+    {
+#if TRACE
+      printf ("lex: EOF\n");
+#endif
+      return 0;
+    }
+
+  if (saw_newline && c == ';')
+    {
+      do
+	{
+	  c = def_getc ();
+	}
+      while (c != EOF && c != '\n');
+      if (c == '\n')
+	return def_lex ();
+      return 0;
+    }
+
+  /* Must be something else.  */
+  saw_newline = 0;
+
+  if (ISDIGIT (c))
+    {
+      bufptr = 0;
+      while (c != EOF && (ISXDIGIT (c) || (c == 'x')))
+	{
+	  put_buf (c);
+	  c = def_getc ();
+	}
+      if (c != EOF)
+	def_ungetc (c);
+      yylval.digits = xstrdup (buffer);
+#if TRACE
+      printf ("lex: `%s' returns DIGITS\n", buffer);
+#endif
+      return DIGITS;
+    }
+
+  if (ISALPHA (c) || strchr ("$:-_?@", c))
+    {
+      bufptr = 0;
+      q = c;
+      put_buf (c);
+      c = def_getc ();
+
+      if (q == '@')
+	{
+          if (ISBLANK (c) ) /* '@' followed by whitespace.  */
+	    return (q);
+          else if (ISDIGIT (c)) /* '@' followed by digit.  */
+            {
+	      def_ungetc (c);
+              return (q);
+	    }
+#if TRACE
+	  printf ("lex: @ returns itself\n");
+#endif
+	}
+
+      while (c != EOF && (ISALNUM (c) || strchr ("$:-_?/@", c)))
+	{
+	  put_buf (c);
+	  c = def_getc ();
+	}
+      if (c != EOF)
+	def_ungetc (c);
+      if (ISALPHA (q)) /* Check for tokens.  */
+	{
+          for (i = 0; tokens[i].name; i++)
+	    if (strcmp (tokens[i].name, buffer) == 0)
+	      {
+#if TRACE
+	        printf ("lex: `%s' is a string token\n", buffer);
+#endif
+	        return tokens[i].token;
+	      }
+	}
+#if TRACE
+      printf ("lex: `%s' returns ID\n", buffer);
+#endif
+      yylval.id = xstrdup (buffer);
+      return ID;
+    }
+
+  if (c == '\'' || c == '"')
+    {
+      q = c;
+      c = def_getc ();
+      bufptr = 0;
+
+      while (c != EOF && c != q)
+	{
+	  put_buf (c);
+	  c = def_getc ();
+	}
+      yylval.id = xstrdup (buffer);
+#if TRACE
+      printf ("lex: `%s' returns ID\n", buffer);
+#endif
+      return ID;
+    }
+
+  if (c == '=' || c == '.' || c == ',')
+    {
+#if TRACE
+      printf ("lex: `%c' returns itself\n", c);
+#endif
+      return c;
+    }
+
+  if (c == '\n')
+    {
+      linenumber++;
+      saw_newline = 1;
+    }
+
+  /*printf ("lex: 0x%02x ignored\n", c); */
+  return def_lex ();
+}
+
==== (added) binutils-2.19.91.20091006/ld/deffilep.h ====
--- /dev/null	2009-05-01 06:17:58.000000000 +0200
+++ binutils-2.19.91.20091006/ld/deffilep.h	2009-10-07 08:19:45.000000000 +0200
@@ -0,0 +1,126 @@
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
+
+/* Skeleton interface for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     NAME = 258,
+     LIBRARY = 259,
+     DESCRIPTION = 260,
+     STACKSIZE_K = 261,
+     HEAPSIZE = 262,
+     CODE = 263,
+     DATAU = 264,
+     DATAL = 265,
+     SECTIONS = 266,
+     EXPORTS = 267,
+     IMPORTS = 268,
+     VERSIONK = 269,
+     BASE = 270,
+     CONSTANTU = 271,
+     CONSTANTL = 272,
+     PRIVATEU = 273,
+     PRIVATEL = 274,
+     ALIGNCOMM = 275,
+     READ = 276,
+     WRITE = 277,
+     EXECUTE = 278,
+     SHARED = 279,
+     NONAMEU = 280,
+     NONAMEL = 281,
+     DIRECTIVE = 282,
+     ID = 283,
+     DIGITS = 284
+   };
+#endif
+/* Tokens.  */
+#define NAME 258
+#define LIBRARY 259
+#define DESCRIPTION 260
+#define STACKSIZE_K 261
+#define HEAPSIZE 262
+#define CODE 263
+#define DATAU 264
+#define DATAL 265
+#define SECTIONS 266
+#define EXPORTS 267
+#define IMPORTS 268
+#define VERSIONK 269
+#define BASE 270
+#define CONSTANTU 271
+#define CONSTANTL 272
+#define PRIVATEU 273
+#define PRIVATEL 274
+#define ALIGNCOMM 275
+#define READ 276
+#define WRITE 277
+#define EXECUTE 278
+#define SHARED 279
+#define NONAMEU 280
+#define NONAMEL 281
+#define DIRECTIVE 282
+#define ID 283
+#define DIGITS 284
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 1676 of yacc.c  */
+#line 103 "deffilep.y"
+
+  char *id;
+  int number;
+  char *digits;
+
+
+
+/* Line 1676 of yacc.c  */
+#line 118 "deffilep.h"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+extern YYSTYPE yylval;
+
+
==== (added) binutils-2.19.91.20091006/ld/ldgram.c ====
--- /dev/null	2009-05-01 06:17:58.000000000 +0200
+++ binutils-2.19.91.20091006/ld/ldgram.c	2009-10-07 07:56:56.000000000 +0200
@@ -0,0 +1,5092 @@
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.4.1"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+
+
+/* Copy the first part of user declarations.  */
+
+/* Line 189 of yacc.c  */
+#line 24 "ldgram.y"
+
+/*
+
+ */
+
+#define DONTDECLARE_MALLOC
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "bfdlink.h"
+#include "ld.h"
+#include "ldexp.h"
+#include "ldver.h"
+#include "ldlang.h"
+#include "ldfile.h"
+#include "ldemul.h"
+#include "ldmisc.h"
+#include "ldmain.h"
+#include "mri.h"
+#include "ldctor.h"
+#include "ldlex.h"
+
+#ifndef YYDEBUG
+#define YYDEBUG 1
+#endif
+
+static enum section_type sectype;
+static lang_memory_region_type *region;
+
+bfd_boolean ldgram_had_keep = FALSE;
+char *ldgram_vers_current_lang = NULL;
+
+#define ERROR_NAME_MAX 20
+static char *error_names[ERROR_NAME_MAX];
+static int error_index;
+#define PUSH_ERROR(x) if (error_index < ERROR_NAME_MAX) error_names[error_index] = x; error_index++;
+#define POP_ERROR()   error_index--;
+
+
+/* Line 189 of yacc.c  */
+#line 113 "ldgram.c"
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     INT = 258,
+     NAME = 259,
+     LNAME = 260,
+     OREQ = 261,
+     ANDEQ = 262,
+     RSHIFTEQ = 263,
+     LSHIFTEQ = 264,
+     DIVEQ = 265,
+     MULTEQ = 266,
+     MINUSEQ = 267,
+     PLUSEQ = 268,
+     OROR = 269,
+     ANDAND = 270,
+     NE = 271,
+     EQ = 272,
+     GE = 273,
+     LE = 274,
+     RSHIFT = 275,
+     LSHIFT = 276,
+     UNARY = 277,
+     END = 278,
+     ALIGN_K = 279,
+     BLOCK = 280,
+     BIND = 281,
+     QUAD = 282,
+     SQUAD = 283,
+     LONG = 284,
+     SHORT = 285,
+     BYTE = 286,
+     SECTIONS = 287,
+     PHDRS = 288,
+     INSERT_K = 289,
+     AFTER = 290,
+     BEFORE = 291,
+     DATA_SEGMENT_ALIGN = 292,
+     DATA_SEGMENT_RELRO_END = 293,
+     DATA_SEGMENT_END = 294,
+     SORT_BY_NAME = 295,
+     SORT_BY_ALIGNMENT = 296,
+     SIZEOF_HEADERS = 297,
+     OUTPUT_FORMAT = 298,
+     FORCE_COMMON_ALLOCATION = 299,
+     OUTPUT_ARCH = 300,
+     INHIBIT_COMMON_ALLOCATION = 301,
+     SEGMENT_START = 302,
+     INCLUDE = 303,
+     MEMORY = 304,
+     REGION_ALIAS = 305,
+     NOLOAD = 306,
+     DSECT = 307,
+     COPY = 308,
+     INFO = 309,
+     OVERLAY = 310,
+     DEFINED = 311,
+     TARGET_K = 312,
+     SEARCH_DIR = 313,
+     MAP = 314,
+     ENTRY = 315,
+     NEXT = 316,
+     SIZEOF = 317,
+     ALIGNOF = 318,
+     ADDR = 319,
+     LOADADDR = 320,
+     MAX_K = 321,
+     MIN_K = 322,
+     CEILP2 = 323,
+     NACL_MASK = 324,
+     STARTUP = 325,
+     HLL = 326,
+     SYSLIB = 327,
+     FLOAT = 328,
+     NOFLOAT = 329,
+     NOCROSSREFS = 330,
+     ORIGIN = 331,
+     FILL = 332,
+     LENGTH = 333,
+     CREATE_OBJECT_SYMBOLS = 334,
+     INPUT = 335,
+     GROUP = 336,
+     OUTPUT = 337,
+     CONSTRUCTORS = 338,
+     ALIGNMOD = 339,
+     AT = 340,
+     SUBALIGN = 341,
+     PROVIDE = 342,
+     PROVIDE_HIDDEN = 343,
+     AS_NEEDED = 344,
+     CHIP = 345,
+     LIST = 346,
+     SECT = 347,
+     ABSOLUTE = 348,
+     LOAD = 349,
+     NEWLINE = 350,
+     ENDWORD = 351,
+     ORDER = 352,
+     NAMEWORD = 353,
+     ASSERT_K = 354,
+     FORMAT = 355,
+     PUBLIC = 356,
+     DEFSYMEND = 357,
+     BASE = 358,
+     ALIAS = 359,
+     TRUNCATE = 360,
+     REL = 361,
+     INPUT_SCRIPT = 362,
+     INPUT_MRI_SCRIPT = 363,
+     INPUT_DEFSYM = 364,
+     CASE = 365,
+     EXTERN = 366,
+     START = 367,
+     VERS_TAG = 368,
+     VERS_IDENTIFIER = 369,
+     GLOBAL = 370,
+     LOCAL = 371,
+     VERSIONK = 372,
+     INPUT_VERSION_SCRIPT = 373,
+     KEEP = 374,
+     ONLY_IF_RO = 375,
+     ONLY_IF_RW = 376,
+     SPECIAL = 377,
+     EXCLUDE_FILE = 378,
+     CONSTANT = 379,
+     INPUT_DYNAMIC_LIST = 380
+   };
+#endif
+/* Tokens.  */
+#define INT 258
+#define NAME 259
+#define LNAME 260
+#define OREQ 261
+#define ANDEQ 262
+#define RSHIFTEQ 263
+#define LSHIFTEQ 264
+#define DIVEQ 265
+#define MULTEQ 266
+#define MINUSEQ 267
+#define PLUSEQ 268
+#define OROR 269
+#define ANDAND 270
+#define NE 271
+#define EQ 272
+#define GE 273
+#define LE 274
+#define RSHIFT 275
+#define LSHIFT 276
+#define UNARY 277
+#define END 278
+#define ALIGN_K 279
+#define BLOCK 280
+#define BIND 281
+#define QUAD 282
+#define SQUAD 283
+#define LONG 284
+#define SHORT 285
+#define BYTE 286
+#define SECTIONS 287
+#define PHDRS 288
+#define INSERT_K 289
+#define AFTER 290
+#define BEFORE 291
+#define DATA_SEGMENT_ALIGN 292
+#define DATA_SEGMENT_RELRO_END 293
+#define DATA_SEGMENT_END 294
+#define SORT_BY_NAME 295
+#define SORT_BY_ALIGNMENT 296
+#define SIZEOF_HEADERS 297
+#define OUTPUT_FORMAT 298
+#define FORCE_COMMON_ALLOCATION 299
+#define OUTPUT_ARCH 300
+#define INHIBIT_COMMON_ALLOCATION 301
+#define SEGMENT_START 302
+#define INCLUDE 303
+#define MEMORY 304
+#define REGION_ALIAS 305
+#define NOLOAD 306
+#define DSECT 307
+#define COPY 308
+#define INFO 309
+#define OVERLAY 310
+#define DEFINED 311
+#define TARGET_K 312
+#define SEARCH_DIR 313
+#define MAP 314
+#define ENTRY 315
+#define NEXT 316
+#define SIZEOF 317
+#define ALIGNOF 318
+#define ADDR 319
+#define LOADADDR 320
+#define MAX_K 321
+#define MIN_K 322
+#define CEILP2 323
+#define NACL_MASK 324
+#define STARTUP 325
+#define HLL 326
+#define SYSLIB 327
+#define FLOAT 328
+#define NOFLOAT 329
+#define NOCROSSREFS 330
+#define ORIGIN 331
+#define FILL 332
+#define LENGTH 333
+#define CREATE_OBJECT_SYMBOLS 334
+#define INPUT 335
+#define GROUP 336
+#define OUTPUT 337
+#define CONSTRUCTORS 338
+#define ALIGNMOD 339
+#define AT 340
+#define SUBALIGN 341
+#define PROVIDE 342
+#define PROVIDE_HIDDEN 343
+#define AS_NEEDED 344
+#define CHIP 345
+#define LIST 346
+#define SECT 347
+#define ABSOLUTE 348
+#define LOAD 349
+#define NEWLINE 350
+#define ENDWORD 351
+#define ORDER 352
+#define NAMEWORD 353
+#define ASSERT_K 354
+#define FORMAT 355
+#define PUBLIC 356
+#define DEFSYMEND 357
+#define BASE 358
+#define ALIAS 359
+#define TRUNCATE 360
+#define REL 361
+#define INPUT_SCRIPT 362
+#define INPUT_MRI_SCRIPT 363
+#define INPUT_DEFSYM 364
+#define CASE 365
+#define EXTERN 366
+#define START 367
+#define VERS_TAG 368
+#define VERS_IDENTIFIER 369
+#define GLOBAL 370
+#define LOCAL 371
+#define VERSIONK 372
+#define INPUT_VERSION_SCRIPT 373
+#define KEEP 374
+#define ONLY_IF_RO 375
+#define ONLY_IF_RW 376
+#define SPECIAL 377
+#define EXCLUDE_FILE 378
+#define CONSTANT 379
+#define INPUT_DYNAMIC_LIST 380
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 214 of yacc.c  */
+#line 62 "ldgram.y"
+
+  bfd_vma integer;
+  struct big_int
+    {
+      bfd_vma integer;
+      char *str;
+    } bigint;
+  fill_type *fill;
+  char *name;
+  const char *cname;
+  struct wildcard_spec wildcard;
+  struct wildcard_list *wildcard_list;
+  struct name_list *name_list;
+  int token;
+  union etree_union *etree;
+  struct phdr_info
+    {
+      bfd_boolean filehdr;
+      bfd_boolean phdrs;
+      union etree_union *at;
+      union etree_union *flags;
+    } phdr;
+  struct lang_nocrossref *nocrossref;
+  struct lang_output_section_phdr_list *section_phdr;
+  struct bfd_elf_version_deps *deflist;
+  struct bfd_elf_version_expr *versyms;
+  struct bfd_elf_version_tree *versnode;
+
+
+
+/* Line 214 of yacc.c  */
+#line 430 "ldgram.c"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 264 of yacc.c  */
+#line 442 "ldgram.c"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
+{
+  return yyi;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  17
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   1860
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  149
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  126
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  358
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  771
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   380
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,   147,     2,     2,     2,    34,    21,     2,
+      37,   144,    32,    30,   142,    31,     2,    33,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,    16,   143,
+      24,     6,    25,    15,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,   145,     2,   146,    20,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,    56,    19,    57,   148,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     7,     8,     9,    10,    11,    12,    13,    14,    17,
+      18,    22,    23,    26,    27,    28,    29,    35,    36,    38,
+      39,    40,    41,    42,    43,    44,    45,    46,    47,    48,
+      49,    50,    51,    52,    53,    54,    55,    58,    59,    60,
+      61,    62,    63,    64,    65,    66,    67,    68,    69,    70,
+      71,    72,    73,    74,    75,    76,    77,    78,    79,    80,
+      81,    82,    83,    84,    85,    86,    87,    88,    89,    90,
+      91,    92,    93,    94,    95,    96,    97,    98,    99,   100,
+     101,   102,   103,   104,   105,   106,   107,   108,   109,   110,
+     111,   112,   113,   114,   115,   116,   117,   118,   119,   120,
+     121,   122,   123,   124,   125,   126,   127,   128,   129,   130,
+     131,   132,   133,   134,   135,   136,   137,   138,   139,   140,
+     141
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint16 yyprhs[] =
+{
+       0,     0,     3,     6,     9,    12,    15,    18,    20,    21,
+      26,    27,    30,    34,    35,    38,    43,    45,    47,    50,
+      52,    57,    62,    66,    69,    74,    78,    83,    88,    93,
+      98,   103,   106,   109,   112,   117,   122,   125,   128,   131,
+     134,   135,   141,   144,   145,   149,   152,   153,   155,   159,
+     161,   165,   166,   168,   172,   173,   176,   178,   181,   185,
+     186,   189,   192,   193,   195,   197,   199,   201,   203,   205,
+     207,   209,   211,   213,   218,   223,   228,   233,   242,   247,
+     249,   251,   256,   257,   263,   268,   269,   275,   280,   285,
+     289,   293,   300,   302,   306,   309,   311,   315,   318,   319,
+     325,   326,   334,   335,   342,   347,   350,   353,   354,   359,
+     362,   363,   371,   373,   375,   377,   379,   385,   390,   395,
+     403,   411,   419,   427,   436,   439,   441,   445,   447,   449,
+     453,   458,   460,   461,   467,   470,   472,   474,   476,   481,
+     483,   488,   493,   494,   503,   504,   510,   513,   515,   516,
+     518,   520,   522,   524,   526,   528,   530,   533,   534,   536,
+     538,   540,   542,   544,   546,   548,   550,   552,   554,   558,
+     562,   569,   576,   578,   579,   584,   586,   587,   591,   593,
+     594,   602,   603,   609,   613,   617,   618,   622,   624,   627,
+     629,   632,   637,   642,   646,   650,   652,   657,   661,   662,
+     664,   666,   667,   670,   674,   675,   678,   681,   685,   690,
+     693,   696,   699,   703,   707,   711,   715,   719,   723,   727,
+     731,   735,   739,   743,   747,   751,   755,   759,   763,   769,
+     773,   777,   782,   784,   786,   791,   796,   801,   806,   811,
+     816,   821,   828,   835,   842,   847,   854,   859,   861,   868,
+     875,   880,   885,   892,   897,   902,   906,   907,   912,   913,
+     918,   919,   924,   925,   927,   929,   931,   932,   933,   934,
+     935,   936,   937,   957,   958,   959,   960,   961,   962,   981,
+     982,   983,   991,   992,   998,  1000,  1002,  1004,  1006,  1008,
+    1012,  1013,  1016,  1020,  1023,  1030,  1041,  1044,  1046,  1047,
+    1049,  1052,  1053,  1054,  1058,  1059,  1060,  1061,  1062,  1074,
+    1079,  1080,  1083,  1084,  1085,  1092,  1094,  1095,  1099,  1105,
+    1106,  1110,  1111,  1114,  1116,  1119,  1124,  1127,  1128,  1131,
+    1132,  1138,  1140,  1143,  1148,  1154,  1161,  1163,  1166,  1167,
+    1170,  1175,  1180,  1189,  1191,  1193,  1197,  1201,  1202,  1212,
+    1213,  1221,  1223,  1227,  1229,  1233,  1235,  1239,  1240
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int16 yyrhs[] =
+{
+     150,     0,    -1,   123,   166,    -1,   124,   154,    -1,   134,
+     263,    -1,   141,   258,    -1,   125,   152,    -1,     4,    -1,
+      -1,   153,     4,     6,   219,    -1,    -1,   155,   156,    -1,
+     156,   157,   111,    -1,    -1,   106,   219,    -1,   106,   219,
+     142,   219,    -1,     4,    -1,   107,    -1,   113,   159,    -1,
+     112,    -1,   117,     4,     6,   219,    -1,   117,     4,   142,
+     219,    -1,   117,     4,   219,    -1,   116,     4,    -1,   108,
+       4,   142,   219,    -1,   108,     4,   219,    -1,   108,     4,
+       6,   219,    -1,    38,     4,     6,   219,    -1,    38,     4,
+     142,   219,    -1,   100,     4,     6,   219,    -1,   100,     4,
+     142,   219,    -1,   109,   161,    -1,   110,   160,    -1,   114,
+       4,    -1,   120,     4,   142,     4,    -1,   120,     4,   142,
+       3,    -1,   119,   219,    -1,   121,     3,    -1,   126,   162,
+      -1,   127,   163,    -1,    -1,    64,   151,   158,   156,    36,
+      -1,   128,     4,    -1,    -1,   159,   142,     4,    -1,   159,
+       4,    -1,    -1,     4,    -1,   160,   142,     4,    -1,     4,
+      -1,   161,   142,     4,    -1,    -1,     4,    -1,   162,   142,
+       4,    -1,    -1,   164,   165,    -1,     4,    -1,   165,     4,
+      -1,   165,   142,     4,    -1,    -1,   167,   168,    -1,   168,
+     169,    -1,    -1,   199,    -1,   176,    -1,   250,    -1,   210,
+      -1,   211,    -1,   213,    -1,   215,    -1,   178,    -1,   265,
+      -1,   143,    -1,    73,    37,     4,   144,    -1,    74,    37,
+     151,   144,    -1,    98,    37,   151,   144,    -1,    59,    37,
+       4,   144,    -1,    59,    37,     4,   142,     4,   142,     4,
+     144,    -1,    61,    37,     4,   144,    -1,    60,    -1,    62,
+      -1,    96,    37,   172,   144,    -1,    -1,    97,   170,    37,
+     172,   144,    -1,    75,    37,   151,   144,    -1,    -1,    64,
+     151,   171,   168,    36,    -1,    91,    37,   216,   144,    -1,
+     127,    37,   163,   144,    -1,    48,    49,     4,    -1,    48,
+      50,     4,    -1,    66,    37,     4,   142,     4,   144,    -1,
+       4,    -1,   172,   142,     4,    -1,   172,     4,    -1,     5,
+      -1,   172,   142,     5,    -1,   172,     5,    -1,    -1,   105,
+      37,   173,   172,   144,    -1,    -1,   172,   142,   105,    37,
+     174,   172,   144,    -1,    -1,   172,   105,    37,   175,   172,
+     144,    -1,    46,    56,   177,    57,    -1,   177,   225,    -1,
+     177,   178,    -1,    -1,    76,    37,     4,   144,    -1,   197,
+     196,    -1,    -1,   115,   179,    37,   219,   142,     4,   144,
+      -1,     4,    -1,    32,    -1,    15,    -1,   180,    -1,   139,
+      37,   182,   144,   180,    -1,    54,    37,   180,   144,    -1,
+      55,    37,   180,   144,    -1,    54,    37,    55,    37,   180,
+     144,   144,    -1,    54,    37,    54,    37,   180,   144,   144,
+      -1,    55,    37,    54,    37,   180,   144,   144,    -1,    55,
+      37,    55,    37,   180,   144,   144,    -1,    54,    37,   139,
+      37,   182,   144,   180,   144,    -1,   182,   180,    -1,   180,
+      -1,   183,   198,   181,    -1,   181,    -1,     4,    -1,   145,
+     183,   146,    -1,   181,    37,   183,   144,    -1,   184,    -1,
+      -1,   135,    37,   186,   184,   144,    -1,   197,   196,    -1,
+      95,    -1,   143,    -1,    99,    -1,    54,    37,    99,   144,
+      -1,   185,    -1,   192,    37,   217,   144,    -1,    93,    37,
+     193,   144,    -1,    -1,   115,   188,    37,   219,   142,     4,
+     144,   196,    -1,    -1,    64,   151,   189,   191,    36,    -1,
+     190,   187,    -1,   187,    -1,    -1,   190,    -1,    41,    -1,
+      42,    -1,    43,    -1,    44,    -1,    45,    -1,   217,    -1,
+       6,   193,    -1,    -1,    14,    -1,    13,    -1,    12,    -1,
+      11,    -1,    10,    -1,     9,    -1,     8,    -1,     7,    -1,
+     143,    -1,   142,    -1,     4,     6,   217,    -1,     4,   195,
+     217,    -1,   103,    37,     4,     6,   217,   144,    -1,   104,
+      37,     4,     6,   217,   144,    -1,   142,    -1,    -1,    65,
+      56,   200,    57,    -1,   201,    -1,    -1,   201,   198,   202,
+      -1,   202,    -1,    -1,     4,   203,   207,    16,   205,   198,
+     206,    -1,    -1,    64,   151,   204,   200,    36,    -1,    92,
+       6,   217,    -1,    94,     6,   217,    -1,    -1,    37,   208,
+     144,    -1,   209,    -1,   208,   209,    -1,     4,    -1,   147,
+       4,    -1,    86,    37,   151,   144,    -1,    87,    37,   212,
+     144,    -1,    87,    37,   144,    -1,   212,   198,   151,    -1,
+     151,    -1,    88,    37,   214,   144,    -1,   214,   198,   151,
+      -1,    -1,    89,    -1,    90,    -1,    -1,     4,   216,    -1,
+       4,   142,   216,    -1,    -1,   218,   219,    -1,    31,   219,
+      -1,    37,   219,   144,    -1,    77,    37,   219,   144,    -1,
+     147,   219,    -1,    30,   219,    -1,   148,   219,    -1,   219,
+      32,   219,    -1,   219,    33,   219,    -1,   219,    34,   219,
+      -1,   219,    30,   219,    -1,   219,    31,   219,    -1,   219,
+      29,   219,    -1,   219,    28,   219,    -1,   219,    23,   219,
+      -1,   219,    22,   219,    -1,   219,    27,   219,    -1,   219,
+      26,   219,    -1,   219,    24,   219,    -1,   219,    25,   219,
+      -1,   219,    21,   219,    -1,   219,    20,   219,    -1,   219,
+      19,   219,    -1,   219,    15,   219,    16,   219,    -1,   219,
+      18,   219,    -1,   219,    17,   219,    -1,    72,    37,     4,
+     144,    -1,     3,    -1,    58,    -1,    79,    37,     4,   144,
+      -1,    78,    37,     4,   144,    -1,    80,    37,     4,   144,
+      -1,    81,    37,     4,   144,    -1,   140,    37,     4,   144,
+      -1,   109,    37,   219,   144,    -1,    38,    37,   219,   144,
+      -1,    38,    37,   219,   142,   219,   144,    -1,    51,    37,
+     219,   142,   219,   144,    -1,    52,    37,   219,   142,   219,
+     144,    -1,    53,    37,   219,   144,    -1,    63,    37,     4,
+     142,   219,   144,    -1,    39,    37,   219,   144,    -1,     4,
+      -1,    82,    37,   219,   142,   219,   144,    -1,    83,    37,
+     219,   142,   219,   144,    -1,    84,    37,   219,   144,    -1,
+      85,    37,   219,   144,    -1,   115,    37,   219,   142,     4,
+     144,    -1,    92,    37,     4,   144,    -1,    94,    37,     4,
+     144,    -1,   101,    25,     4,    -1,    -1,   101,    37,   219,
+     144,    -1,    -1,    38,    37,   219,   144,    -1,    -1,   102,
+      37,   219,   144,    -1,    -1,   136,    -1,   137,    -1,   138,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,     4,   226,   241,
+     221,   222,   223,   227,   224,    56,   228,   191,    57,   229,
+     244,   220,   245,   194,   230,   198,    -1,    -1,    -1,    -1,
+      -1,    -1,    71,   231,   242,   243,   221,   223,   232,    56,
+     233,   246,    57,   234,   244,   220,   245,   194,   235,   198,
+      -1,    -1,    -1,    97,   236,   241,   237,    56,   177,    57,
+      -1,    -1,    64,   151,   238,   177,    36,    -1,    67,    -1,
+      68,    -1,    69,    -1,    70,    -1,    71,    -1,    37,   239,
+     144,    -1,    -1,    37,   144,    -1,   219,   240,    16,    -1,
+     240,    16,    -1,    40,    37,   219,   144,   240,    16,    -1,
+      40,    37,   219,   144,    39,    37,   219,   144,   240,    16,
+      -1,   219,    16,    -1,    16,    -1,    -1,    91,    -1,    25,
+       4,    -1,    -1,    -1,   245,    16,     4,    -1,    -1,    -1,
+      -1,    -1,   246,     4,   247,    56,   191,    57,   248,   245,
+     194,   249,   198,    -1,    47,    56,   251,    57,    -1,    -1,
+     251,   252,    -1,    -1,    -1,     4,   253,   255,   256,   254,
+     143,    -1,   219,    -1,    -1,     4,   257,   256,    -1,   101,
+      37,   219,   144,   256,    -1,    -1,    37,   219,   144,    -1,
+      -1,   259,   260,    -1,   261,    -1,   260,   261,    -1,    56,
+     262,    57,   143,    -1,   271,   143,    -1,    -1,   264,   267,
+      -1,    -1,   266,   133,    56,   267,    57,    -1,   268,    -1,
+     267,   268,    -1,    56,   270,    57,   143,    -1,   129,    56,
+     270,    57,   143,    -1,   129,    56,   270,    57,   269,   143,
+      -1,   129,    -1,   269,   129,    -1,    -1,   271,   143,    -1,
+     131,    16,   271,   143,    -1,   132,    16,   271,   143,    -1,
+     131,    16,   271,   143,   132,    16,   271,   143,    -1,   130,
+      -1,     4,    -1,   271,   143,   130,    -1,   271,   143,     4,
+      -1,    -1,   271,   143,   127,     4,    56,   272,   271,   274,
+      57,    -1,    -1,   127,     4,    56,   273,   271,   274,    57,
+      -1,   131,    -1,   271,   143,   131,    -1,   132,    -1,   271,
+     143,   132,    -1,   127,    -1,   271,   143,   127,    -1,    -1,
+     143,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   162,   162,   163,   164,   165,   166,   170,   174,   174,
+     184,   184,   197,   198,   202,   203,   204,   207,   210,   211,
+     212,   214,   216,   218,   220,   222,   224,   226,   228,   230,
+     232,   234,   235,   236,   238,   240,   242,   244,   246,   247,
+     249,   248,   252,   254,   258,   259,   260,   264,   266,   270,
+     272,   277,   278,   279,   284,   284,   289,   291,   293,   298,
+     298,   304,   305,   310,   311,   312,   313,   314,   315,   316,
+     317,   318,   319,   320,   322,   324,   326,   329,   331,   333,
+     335,   337,   339,   338,   342,   345,   344,   348,   352,   353,
+     355,   357,   362,   365,   368,   371,   374,   377,   381,   380,
+     385,   384,   389,   388,   395,   399,   400,   401,   405,   407,
+     408,   408,   416,   420,   424,   431,   437,   443,   449,   455,
+     461,   467,   473,   479,   488,   497,   508,   517,   528,   536,
+     540,   547,   549,   548,   555,   556,   560,   561,   566,   571,
+     572,   577,   581,   581,   585,   584,   591,   592,   595,   597,
+     601,   603,   605,   607,   609,   614,   621,   623,   627,   629,
+     631,   633,   635,   637,   639,   641,   646,   646,   651,   655,
+     663,   667,   675,   675,   679,   682,   682,   685,   686,   691,
+     690,   696,   695,   702,   710,   718,   719,   723,   724,   728,
+     730,   735,   740,   741,   746,   748,   754,   756,   758,   762,
+     764,   770,   773,   782,   793,   793,   799,   801,   803,   805,
+     807,   809,   812,   814,   816,   818,   820,   822,   824,   826,
+     828,   830,   832,   834,   836,   838,   840,   842,   844,   846,
+     848,   850,   852,   854,   857,   859,   861,   863,   865,   867,
+     869,   871,   873,   875,   877,   879,   888,   890,   892,   894,
+     896,   898,   900,   902,   904,   910,   911,   915,   916,   920,
+     921,   925,   926,   930,   931,   932,   933,   936,   940,   943,
+     949,   951,   936,   958,   960,   962,   967,   969,   957,   979,
+     981,   979,   987,   986,   993,   994,   995,   996,   997,  1001,
+    1002,  1003,  1007,  1008,  1013,  1014,  1019,  1020,  1025,  1026,
+    1031,  1033,  1038,  1041,  1054,  1058,  1063,  1065,  1056,  1073,
+    1076,  1078,  1082,  1083,  1082,  1092,  1137,  1140,  1152,  1161,
+    1164,  1171,  1171,  1183,  1184,  1188,  1192,  1201,  1201,  1215,
+    1215,  1225,  1226,  1230,  1234,  1238,  1245,  1249,  1257,  1260,
+    1264,  1268,  1272,  1279,  1283,  1287,  1291,  1296,  1295,  1309,
+    1308,  1318,  1322,  1326,  1330,  1334,  1338,  1344,  1346
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "INT", "NAME", "LNAME", "'='", "OREQ",
+  "ANDEQ", "RSHIFTEQ", "LSHIFTEQ", "DIVEQ", "MULTEQ", "MINUSEQ", "PLUSEQ",
+  "'?'", "':'", "OROR", "ANDAND", "'|'", "'^'", "'&'", "NE", "EQ", "'<'",
+  "'>'", "GE", "LE", "RSHIFT", "LSHIFT", "'+'", "'-'", "'*'", "'/'", "'%'",
+  "UNARY", "END", "'('", "ALIGN_K", "BLOCK", "BIND", "QUAD", "SQUAD",
+  "LONG", "SHORT", "BYTE", "SECTIONS", "PHDRS", "INSERT_K", "AFTER",
+  "BEFORE", "DATA_SEGMENT_ALIGN", "DATA_SEGMENT_RELRO_END",
+  "DATA_SEGMENT_END", "SORT_BY_NAME", "SORT_BY_ALIGNMENT", "'{'", "'}'",
+  "SIZEOF_HEADERS", "OUTPUT_FORMAT", "FORCE_COMMON_ALLOCATION",
+  "OUTPUT_ARCH", "INHIBIT_COMMON_ALLOCATION", "SEGMENT_START", "INCLUDE",
+  "MEMORY", "REGION_ALIAS", "NOLOAD", "DSECT", "COPY", "INFO", "OVERLAY",
+  "DEFINED", "TARGET_K", "SEARCH_DIR", "MAP", "ENTRY", "NEXT", "SIZEOF",
+  "ALIGNOF", "ADDR", "LOADADDR", "MAX_K", "MIN_K", "CEILP2", "NACL_MASK",
+  "STARTUP", "HLL", "SYSLIB", "FLOAT", "NOFLOAT", "NOCROSSREFS", "ORIGIN",
+  "FILL", "LENGTH", "CREATE_OBJECT_SYMBOLS", "INPUT", "GROUP", "OUTPUT",
+  "CONSTRUCTORS", "ALIGNMOD", "AT", "SUBALIGN", "PROVIDE",
+  "PROVIDE_HIDDEN", "AS_NEEDED", "CHIP", "LIST", "SECT", "ABSOLUTE",
+  "LOAD", "NEWLINE", "ENDWORD", "ORDER", "NAMEWORD", "ASSERT_K", "FORMAT",
+  "PUBLIC", "DEFSYMEND", "BASE", "ALIAS", "TRUNCATE", "REL",
+  "INPUT_SCRIPT", "INPUT_MRI_SCRIPT", "INPUT_DEFSYM", "CASE", "EXTERN",
+  "START", "VERS_TAG", "VERS_IDENTIFIER", "GLOBAL", "LOCAL", "VERSIONK",
+  "INPUT_VERSION_SCRIPT", "KEEP", "ONLY_IF_RO", "ONLY_IF_RW", "SPECIAL",
+  "EXCLUDE_FILE", "CONSTANT", "INPUT_DYNAMIC_LIST", "','", "';'", "')'",
+  "'['", "']'", "'!'", "'~'", "$accept", "file", "filename", "defsym_expr",
+  "$@1", "mri_script_file", "$@2", "mri_script_lines",
+  "mri_script_command", "$@3", "ordernamelist", "mri_load_name_list",
+  "mri_abs_name_list", "casesymlist", "extern_name_list", "$@4",
+  "extern_name_list_body", "script_file", "$@5", "ifile_list", "ifile_p1",
+  "$@6", "$@7", "input_list", "@8", "@9", "@10", "sections",
+  "sec_or_group_p1", "statement_anywhere", "$@11", "wildcard_name",
+  "wildcard_spec", "exclude_name_list", "file_NAME_list",
+  "input_section_spec_no_keep", "input_section_spec", "$@12", "statement",
+  "$@13", "$@14", "statement_list", "statement_list_opt", "length",
+  "fill_exp", "fill_opt", "assign_op", "end", "assignment", "opt_comma",
+  "memory", "memory_spec_list_opt", "memory_spec_list", "memory_spec",
+  "$@15", "$@16", "origin_spec", "length_spec", "attributes_opt",
+  "attributes_list", "attributes_string", "startup", "high_level_library",
+  "high_level_library_NAME_list", "low_level_library",
+  "low_level_library_NAME_list", "floating_point_support",
+  "nocrossref_list", "mustbe_exp", "$@17", "exp", "memspec_at_opt",
+  "opt_at", "opt_align", "opt_subalign", "sect_constraint", "section",
+  "$@18", "$@19", "$@20", "$@21", "$@22", "$@23", "$@24", "$@25", "$@26",
+  "$@27", "$@28", "$@29", "$@30", "type", "atype", "opt_exp_with_type",
+  "opt_exp_without_type", "opt_nocrossrefs", "memspec_opt", "phdr_opt",
+  "overlay_section", "$@31", "$@32", "$@33", "phdrs", "phdr_list", "phdr",
+  "$@34", "$@35", "phdr_type", "phdr_qualifiers", "phdr_val",
+  "dynamic_list_file", "$@36", "dynamic_list_nodes", "dynamic_list_node",
+  "dynamic_list_tag", "version_script_file", "$@37", "version", "$@38",
+  "vers_nodes", "vers_node", "verdep", "vers_tag", "vers_defns", "@39",
+  "@40", "opt_semicolon", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,    61,   261,   262,   263,
+     264,   265,   266,   267,   268,    63,    58,   269,   270,   124,
+      94,    38,   271,   272,    60,    62,   273,   274,   275,   276,
+      43,    45,    42,    47,    37,   277,   278,    40,   279,   280,
+     281,   282,   283,   284,   285,   286,   287,   288,   289,   290,
+     291,   292,   293,   294,   295,   296,   123,   125,   297,   298,
+     299,   300,   301,   302,   303,   304,   305,   306,   307,   308,
+     309,   310,   311,   312,   313,   314,   315,   316,   317,   318,
+     319,   320,   321,   322,   323,   324,   325,   326,   327,   328,
+     329,   330,   331,   332,   333,   334,   335,   336,   337,   338,
+     339,   340,   341,   342,   343,   344,   345,   346,   347,   348,
+     349,   350,   351,   352,   353,   354,   355,   356,   357,   358,
+     359,   360,   361,   362,   363,   364,   365,   366,   367,   368,
+     369,   370,   371,   372,   373,   374,   375,   376,   377,   378,
+     379,   380,    44,    59,    41,    91,    93,    33,   126
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint16 yyr1[] =
+{
+       0,   149,   150,   150,   150,   150,   150,   151,   153,   152,
+     155,   154,   156,   156,   157,   157,   157,   157,   157,   157,
+     157,   157,   157,   157,   157,   157,   157,   157,   157,   157,
+     157,   157,   157,   157,   157,   157,   157,   157,   157,   157,
+     158,   157,   157,   157,   159,   159,   159,   160,   160,   161,
+     161,   162,   162,   162,   164,   163,   165,   165,   165,   167,
+     166,   168,   168,   169,   169,   169,   169,   169,   169,   169,
+     169,   169,   169,   169,   169,   169,   169,   169,   169,   169,
+     169,   169,   170,   169,   169,   171,   169,   169,   169,   169,
+     169,   169,   172,   172,   172,   172,   172,   172,   173,   172,
+     174,   172,   175,   172,   176,   177,   177,   177,   178,   178,
+     179,   178,   180,   180,   180,   181,   181,   181,   181,   181,
+     181,   181,   181,   181,   182,   182,   183,   183,   184,   184,
+     184,   185,   186,   185,   187,   187,   187,   187,   187,   187,
+     187,   187,   188,   187,   189,   187,   190,   190,   191,   191,
+     192,   192,   192,   192,   192,   193,   194,   194,   195,   195,
+     195,   195,   195,   195,   195,   195,   196,   196,   197,   197,
+     197,   197,   198,   198,   199,   200,   200,   201,   201,   203,
+     202,   204,   202,   205,   206,   207,   207,   208,   208,   209,
+     209,   210,   211,   211,   212,   212,   213,   214,   214,   215,
+     215,   216,   216,   216,   218,   217,   219,   219,   219,   219,
+     219,   219,   219,   219,   219,   219,   219,   219,   219,   219,
+     219,   219,   219,   219,   219,   219,   219,   219,   219,   219,
+     219,   219,   219,   219,   219,   219,   219,   219,   219,   219,
+     219,   219,   219,   219,   219,   219,   219,   219,   219,   219,
+     219,   219,   219,   219,   219,   220,   220,   221,   221,   222,
+     222,   223,   223,   224,   224,   224,   224,   226,   227,   228,
+     229,   230,   225,   231,   232,   233,   234,   235,   225,   236,
+     237,   225,   238,   225,   239,   239,   239,   239,   239,   240,
+     240,   240,   241,   241,   241,   241,   242,   242,   243,   243,
+     244,   244,   245,   245,   246,   247,   248,   249,   246,   250,
+     251,   251,   253,   254,   252,   255,   256,   256,   256,   257,
+     257,   259,   258,   260,   260,   261,   262,   264,   263,   266,
+     265,   267,   267,   268,   268,   268,   269,   269,   270,   270,
+     270,   270,   270,   271,   271,   271,   271,   272,   271,   273,
+     271,   271,   271,   271,   271,   271,   271,   274,   274
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     1,     0,     4,
+       0,     2,     3,     0,     2,     4,     1,     1,     2,     1,
+       4,     4,     3,     2,     4,     3,     4,     4,     4,     4,
+       4,     2,     2,     2,     4,     4,     2,     2,     2,     2,
+       0,     5,     2,     0,     3,     2,     0,     1,     3,     1,
+       3,     0,     1,     3,     0,     2,     1,     2,     3,     0,
+       2,     2,     0,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     4,     4,     4,     4,     8,     4,     1,
+       1,     4,     0,     5,     4,     0,     5,     4,     4,     3,
+       3,     6,     1,     3,     2,     1,     3,     2,     0,     5,
+       0,     7,     0,     6,     4,     2,     2,     0,     4,     2,
+       0,     7,     1,     1,     1,     1,     5,     4,     4,     7,
+       7,     7,     7,     8,     2,     1,     3,     1,     1,     3,
+       4,     1,     0,     5,     2,     1,     1,     1,     4,     1,
+       4,     4,     0,     8,     0,     5,     2,     1,     0,     1,
+       1,     1,     1,     1,     1,     1,     2,     0,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     3,     3,
+       6,     6,     1,     0,     4,     1,     0,     3,     1,     0,
+       7,     0,     5,     3,     3,     0,     3,     1,     2,     1,
+       2,     4,     4,     3,     3,     1,     4,     3,     0,     1,
+       1,     0,     2,     3,     0,     2,     2,     3,     4,     2,
+       2,     2,     3,     3,     3,     3,     3,     3,     3,     3,
+       3,     3,     3,     3,     3,     3,     3,     3,     5,     3,
+       3,     4,     1,     1,     4,     4,     4,     4,     4,     4,
+       4,     6,     6,     6,     4,     6,     4,     1,     6,     6,
+       4,     4,     6,     4,     4,     3,     0,     4,     0,     4,
+       0,     4,     0,     1,     1,     1,     0,     0,     0,     0,
+       0,     0,    19,     0,     0,     0,     0,     0,    18,     0,
+       0,     7,     0,     5,     1,     1,     1,     1,     1,     3,
+       0,     2,     3,     2,     6,    10,     2,     1,     0,     1,
+       2,     0,     0,     3,     0,     0,     0,     0,    11,     4,
+       0,     2,     0,     0,     6,     1,     0,     3,     5,     0,
+       3,     0,     2,     1,     2,     4,     2,     0,     2,     0,
+       5,     1,     2,     4,     5,     6,     1,     2,     0,     2,
+       4,     4,     8,     1,     1,     3,     3,     0,     9,     0,
+       7,     1,     3,     1,     3,     1,     3,     0,     1
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint16 yydefact[] =
+{
+       0,    59,    10,     8,   327,   321,     0,     2,    62,     3,
+      13,     6,     0,     4,     0,     5,     0,     1,    60,    11,
+       0,   338,     0,   328,   331,     0,   322,   323,     0,     0,
+       0,     0,     0,    79,     0,    80,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,   199,   200,     0,     0,
+      82,     0,     0,     0,   110,     0,    72,    61,    64,    70,
+       0,    63,    66,    67,    68,    69,    65,    71,     0,    16,
+       0,     0,     0,     0,    17,     0,     0,     0,    19,    46,
+       0,     0,     0,     0,     0,     0,    51,    54,     0,     0,
+       0,   344,   355,   343,   351,   353,     0,     0,   338,   332,
+     351,   353,     0,     0,   324,   204,   165,   164,   163,   162,
+     161,   160,   159,   158,   204,   107,   310,     0,     0,     0,
+       0,     7,    85,   176,     0,     0,     0,     0,     0,     0,
+       0,   198,   201,     0,     0,     0,     0,     0,     0,    54,
+     167,   166,   109,     0,     0,    40,     0,   232,   247,     0,
+       0,     0,     0,     0,     0,     0,     0,   233,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    14,     0,    49,    31,
+      47,    32,    18,    33,    23,     0,    36,     0,    37,    52,
+      38,    39,     0,    42,    12,     9,     0,     0,     0,     0,
+     339,     0,     0,   326,   168,     0,   169,     0,     0,    89,
+      90,     0,     0,    62,   179,     0,     0,   173,   178,     0,
+       0,     0,     0,     0,     0,   193,   195,   173,   173,   201,
+       0,    92,    95,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,    13,     0,     0,   210,   206,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,   209,   211,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    25,     0,     0,    45,     0,
+       0,     0,    22,     0,     0,    56,    55,   349,     0,     0,
+     333,   346,   356,   345,   352,   354,     0,   325,   205,   267,
+     104,     0,   273,   279,   106,   105,   312,   309,   311,     0,
+      76,    78,   329,   185,   181,   174,   172,     0,     0,    73,
+      74,    84,   108,   191,   192,     0,   196,     0,   201,   202,
+      87,    98,    94,    97,     0,     0,    81,     0,    75,   204,
+     204,     0,    88,     0,    27,    28,    43,    29,    30,   207,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,   230,   229,   227,   226,   225,   220,   219,   223,
+     224,   222,   221,   218,   217,   215,   216,   212,   213,   214,
+      15,    26,    24,    50,    48,    44,    20,    21,    35,    34,
+      53,    57,     0,     0,   340,   341,     0,   336,   334,     0,
+     290,   282,     0,   290,     0,     0,    86,     0,     0,   176,
+     177,     0,   194,   197,   203,     0,   102,    93,    96,     0,
+      83,     0,     0,     0,   330,    41,     0,   240,   246,     0,
+       0,   244,     0,   231,   208,   235,   234,   236,   237,     0,
+       0,   250,   251,   253,   254,   239,     0,   238,     0,    58,
+     357,   354,   347,   337,   335,     0,     0,   290,     0,   258,
+     107,   297,     0,   298,   280,   315,   316,     0,   189,     0,
+       0,   187,     0,     0,    91,     0,     0,   100,   170,   171,
+       0,     0,     0,     0,     0,     0,     0,     0,   228,   358,
+       0,     0,     0,   284,   285,   286,   287,   288,   291,     0,
+       0,     0,     0,   293,     0,   260,     0,   296,   299,   258,
+       0,   319,     0,   313,     0,   190,   186,   188,     0,   173,
+     182,    99,     0,     0,   111,   241,   242,   243,   245,   248,
+     249,   252,   350,     0,   357,   289,     0,   292,     0,     0,
+     262,   283,   262,   107,     0,   316,     0,     0,    77,   204,
+       0,   103,     0,   342,     0,   290,     0,     0,     0,   268,
+     274,     0,     0,   317,     0,   314,   183,     0,   180,   101,
+     348,     0,     0,   257,     0,     0,   266,     0,   281,   320,
+     316,   204,     0,   294,   259,     0,   263,   264,   265,     0,
+     275,   318,   184,     0,   261,   269,   304,   290,   148,     0,
+       0,   128,   114,   113,   150,   151,   152,   153,   154,     0,
+       0,     0,     0,   135,   137,   142,     0,     0,   136,     0,
+     115,     0,   131,   139,   147,   149,     0,     0,     0,   305,
+     276,   295,     0,     0,   144,   204,     0,   132,     0,   112,
+       0,   127,   173,     0,   146,   270,   204,   134,     0,   301,
+       0,     0,     0,     0,     0,     0,     0,     0,   148,     0,
+     155,     0,     0,   125,     0,     0,   129,     0,   173,   301,
+       0,   148,     0,   256,     0,     0,   138,     0,   117,     0,
+       0,   118,     0,   141,     0,   112,     0,     0,   124,   126,
+     130,   256,   140,     0,   300,     0,   302,     0,     0,     0,
+       0,     0,   145,     0,   133,   116,   302,   306,     0,   157,
+       0,     0,     0,     0,     0,     0,   157,   302,   255,   204,
+       0,   277,   120,   119,     0,   121,   122,     0,   271,   157,
+     156,   303,   173,   123,   143,   173,   307,   278,   272,   173,
+     308
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,     6,   122,    11,    12,     9,    10,    19,    89,   244,
+     182,   181,   179,   190,   191,   192,   306,     7,     8,    18,
+      57,   134,   213,   234,   445,   553,   506,    58,   207,   324,
+     138,   650,   651,   694,   672,   652,   653,   692,   654,   666,
+     688,   655,   656,   657,   689,   751,   114,   142,    60,   697,
+      61,   216,   217,   218,   333,   439,   549,   598,   438,   500,
+     501,    62,    63,   227,    64,   228,    65,   230,   690,   205,
+     249,   726,   535,   570,   589,   619,   325,   430,   606,   628,
+     699,   765,   432,   607,   626,   679,   762,   433,   540,   490,
+     529,   488,   489,   493,   539,   703,   739,   629,   678,   747,
+     769,    66,   208,   328,   434,   577,   496,   543,   575,    15,
+      16,    26,    27,   102,    13,    14,    67,    68,    23,    24,
+     429,    96,    97,   522,   423,   520
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -658
+static const yytype_int16 yypact[] =
+{
+     278,  -658,  -658,  -658,  -658,  -658,   116,  -658,  -658,  -658,
+    -658,  -658,    39,  -658,   -21,  -658,    88,  -658,   818,  1636,
+     148,    67,    95,   -21,  -658,   106,    88,  -658,   889,   112,
+     126,    70,   156,  -658,   189,  -658,   225,   174,   203,   217,
+     218,   227,   231,   245,   253,   260,  -658,  -658,   281,   289,
+    -658,   290,   292,   294,  -658,   295,  -658,  -658,  -658,  -658,
+      43,  -658,  -658,  -658,  -658,  -658,  -658,  -658,   188,  -658,
+     324,   225,   329,   672,  -658,   330,   332,   336,  -658,  -658,
+     337,   341,   342,   672,   345,   350,   352,  -658,   354,   243,
+     672,  -658,   362,  -658,   353,   355,   315,   230,    67,  -658,
+    -658,  -658,   317,   241,  -658,  -658,  -658,  -658,  -658,  -658,
+    -658,  -658,  -658,  -658,  -658,  -658,  -658,   381,   388,   394,
+     395,  -658,  -658,    47,   396,   400,   225,   225,   403,   225,
+      20,  -658,   406,    21,   374,   225,   410,   411,   384,  -658,
+    -658,  -658,  -658,   366,    33,  -658,    41,  -658,  -658,   672,
+     672,   672,   390,   391,   392,   397,   399,  -658,   404,   405,
+     407,   409,   414,   417,   421,   423,   424,   436,   438,   440,
+     441,   451,   453,   454,   672,   672,  1433,   228,  -658,   301,
+    -658,   305,     5,  -658,  -658,   387,   827,   306,  -658,  -658,
+     347,  -658,   427,  -658,  -658,   827,   376,   106,   106,   351,
+     114,   380,   356,   114,  -658,   672,  -658,   291,    34,  -658,
+    -658,   105,   309,  -658,  -658,   225,   443,    -2,  -658,   363,
+     349,   360,   371,   372,   373,  -658,  -658,   127,   145,    19,
+     377,  -658,  -658,   460,    16,    21,   378,   492,   500,   672,
+     379,   -21,   672,   672,  -658,   672,   672,  -658,  -658,   776,
+     672,   672,   672,   672,   672,   429,   503,   672,   514,   520,
+     521,   522,   672,   672,   672,   672,   524,   526,   672,   672,
+     529,  -658,  -658,   672,   672,   672,   672,   672,   672,   672,
+     672,   672,   672,   672,   672,   672,   672,   672,   672,   672,
+     672,   672,   672,   672,   672,   827,   534,   536,  -658,   537,
+     672,   672,   827,    66,   538,  -658,    25,  -658,   413,   418,
+    -658,  -658,   543,  -658,  -658,  -658,   -55,  -658,   827,   889,
+    -658,   225,  -658,  -658,  -658,  -658,  -658,  -658,  -658,   545,
+    -658,  -658,   882,   513,  -658,  -658,  -658,    47,   548,  -658,
+    -658,  -658,  -658,  -658,  -658,   225,  -658,   225,   406,  -658,
+    -658,  -658,  -658,  -658,   516,    28,  -658,    32,  -658,  -658,
+    -658,  1453,  -658,     7,   827,   827,  1660,   827,   827,  -658,
+    1009,  1029,  1473,  1493,  1049,   412,   419,  1069,   422,   426,
+     428,   430,  1521,  1559,  1089,  1109,   431,   432,  1137,  1579,
+     433,  1774,  1811,  1539,  1826,   663,   988,   688,   688,   601,
+     601,   601,   601,   452,   452,   270,   270,  -658,  -658,  -658,
+     827,   827,   827,  -658,  -658,  -658,   827,   827,  -658,  -658,
+    -658,  -658,   556,   106,   220,   114,   509,  -658,  -658,    14,
+     506,  -658,   589,   506,   672,   420,  -658,     3,   551,    47,
+    -658,   435,  -658,  -658,  -658,    21,  -658,  -658,  -658,   531,
+    -658,   437,   450,   576,  -658,  -658,   672,  -658,  -658,   672,
+     672,  -658,   672,  -658,  -658,  -658,  -658,  -658,  -658,   672,
+     672,  -658,  -658,  -658,  -658,  -658,   578,  -658,   672,  -658,
+     456,   579,  -658,  -658,  -658,    15,   559,  1628,   581,   501,
+    -658,  -658,  1794,   510,  -658,   827,    27,   599,  -658,   612,
+       2,  -658,   512,   586,  -658,   118,    21,  -658,  -658,  -658,
+     473,  1157,  1177,  1197,  1217,  1237,  1265,   479,   827,   114,
+     567,   106,   106,  -658,  -658,  -658,  -658,  -658,  -658,   481,
+     672,   311,   620,  -658,   602,   605,   416,  -658,  -658,   501,
+     582,   607,   608,  -658,   504,  -658,  -658,  -658,   643,   508,
+    -658,  -658,   130,    21,  -658,  -658,  -658,  -658,  -658,  -658,
+    -658,  -658,  -658,   515,   456,  -658,  1285,  -658,   672,   614,
+     553,  -658,   553,  -658,   672,    27,   672,   517,  -658,  -658,
+     562,  -658,   134,   114,   606,   257,  1305,   672,   622,  -658,
+    -658,   359,  1325,  -658,  1345,  -658,  -658,   651,  -658,  -658,
+    -658,   625,   648,  -658,  1365,   672,   -88,   609,  -658,  -658,
+      27,  -658,   672,  -658,  -658,  1393,  -658,  -658,  -658,   621,
+    -658,  -658,  -658,  1413,  -658,  -658,  -658,   641,   728,    58,
+     664,   600,  -658,  -658,  -658,  -658,  -658,  -658,  -658,   642,
+     645,   225,   662,  -658,  -658,  -658,   668,   669,  -658,   238,
+    -658,   670,  -658,  -658,  -658,   728,   644,   671,    43,  -658,
+    -658,  -658,   310,   284,  -658,  -658,   689,  -658,    57,  -658,
+     690,  -658,   -29,   238,  -658,  -658,  -658,  -658,   675,   703,
+     696,   697,   594,   702,   596,   704,   705,   603,   728,   604,
+    -658,   672,    26,  -658,    12,   269,  -658,   238,   173,   703,
+     615,   728,   741,   657,    57,    57,  -658,    57,  -658,    57,
+      57,  -658,   710,  -658,  1599,   617,   618,    57,  -658,  -658,
+    -658,   657,  -658,   706,  -658,   740,  -658,   623,   624,    99,
+     630,   631,  -658,   772,  -658,  -658,  -658,  -658,   773,   136,
+     634,   635,    57,   636,   640,   646,   136,  -658,  -658,  -658,
+     781,  -658,  -658,  -658,   667,  -658,  -658,    43,  -658,   136,
+    -658,  -658,   508,  -658,  -658,   508,  -658,  -658,  -658,   508,
+    -658
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int16 yypgoto[] =
+{
+    -658,  -658,   -70,  -658,  -658,  -658,  -658,   542,  -658,  -658,
+    -658,  -658,  -658,  -658,   561,  -658,  -658,  -658,  -658,   575,
+    -658,  -658,  -658,  -223,  -658,  -658,  -658,  -658,  -448,   -13,
+    -658,   974,  -544,    82,   140,   122,  -658,  -658,   160,  -658,
+    -658,  -658,  -440,  -658,    68,  -496,  -658,  -630,  -403,  -214,
+    -658,   385,  -658,   488,  -658,  -658,  -658,  -658,  -658,  -658,
+     316,  -658,  -658,  -658,  -658,  -658,  -658,  -207,  -103,  -658,
+     -73,    97,   287,  -658,   256,  -658,  -658,  -658,  -658,  -658,
+    -658,  -658,  -658,  -658,  -658,  -658,  -658,  -658,  -658,  -658,
+    -658,  -479,   401,  -658,  -658,   131,  -657,  -658,  -658,  -658,
+    -658,  -658,  -658,  -658,  -658,  -658,  -658,  -535,  -658,  -658,
+    -658,  -658,   803,  -658,  -658,  -658,  -658,  -658,   592,   -19,
+    -658,   737,   -10,  -658,  -658,   272
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -330
+static const yytype_int16 yytable[] =
+{
+     176,   145,   204,   337,    99,    59,   498,   498,   532,   298,
+     186,   206,   357,   345,   347,   103,   669,   195,   147,   148,
+     352,   353,   349,   229,   121,   231,   232,   632,   677,   421,
+     715,   541,   447,   448,  -175,    21,   352,   353,   326,   242,
+     593,   632,   536,    20,   633,   149,   150,   245,   616,   617,
+     618,   214,   151,   152,   153,  -175,   221,   222,   633,   224,
+     226,   669,   659,    21,   454,   236,   154,   155,   156,   418,
+     419,    91,   632,   157,   427,   621,   247,   248,   158,   746,
+     670,   640,   523,   524,   525,   526,   527,   159,   428,   633,
+     759,   327,   160,   161,   162,   163,   164,   165,   166,   167,
+     168,   271,   272,   669,   295,   671,   602,   169,    22,   170,
+      91,   215,   302,   336,   632,   660,    17,   696,   311,   117,
+     118,   354,   352,   353,   171,   591,   233,   764,   542,   671,
+     172,   633,   318,   449,   352,   353,    22,   354,   352,   353,
+     336,   444,   749,   483,    25,   334,   546,   299,   630,   499,
+     499,    98,   750,   719,    90,   173,   717,   484,   355,   528,
+     356,   348,   174,   175,   225,   647,   361,   422,   115,   364,
+     365,   649,   367,   368,   355,   243,   450,   370,   371,   372,
+     373,   374,   116,   246,   377,   140,   141,   308,   309,   382,
+     383,   384,   385,   119,    92,   388,   389,    93,    94,    95,
+     391,   392,   393,   394,   395,   396,   397,   398,   399,   400,
+     401,   402,   403,   404,   405,   406,   407,   408,   409,   410,
+     411,   412,   505,   354,   311,   658,   120,   416,   417,   121,
+     123,   147,   148,    92,   293,   354,    93,   100,   101,   354,
+     124,   312,   669,   742,   313,   314,   315,   329,   712,   330,
+     758,   431,   658,   632,   125,   126,   451,   452,   149,   150,
+     355,   723,   551,   766,   127,   151,   152,   153,   128,   336,
+     633,   344,   355,   669,   581,   442,   355,   443,   599,   154,
+     155,   156,   129,   552,   632,   658,   157,   336,   669,   346,
+     130,   158,   670,   640,   531,   319,   601,   131,   658,   632,
+     159,   633,   289,   290,   291,   160,   161,   162,   163,   164,
+     165,   166,   167,   168,   669,   336,   633,   720,   132,    59,
+     169,   143,   170,   680,   681,   632,   133,   135,   144,   136,
+     582,   137,   139,   146,   177,   580,   178,   171,   685,   686,
+     180,   183,   633,   172,    99,   184,   185,   312,   320,   187,
+     313,   314,   481,   188,   194,   321,   189,   487,   193,   492,
+     487,   495,   322,   319,   680,   681,   196,    42,   173,   197,
+     294,   198,   199,   200,   202,   174,   175,   647,   523,   524,
+     525,   526,   527,   511,   203,   209,   512,   513,   323,   514,
+     147,   148,   210,   300,    52,    53,   515,   516,   211,   212,
+     219,     1,     2,     3,   220,   518,    54,   223,   683,   682,
+     229,   235,     4,   480,   237,   238,   608,   149,   150,     5,
+     319,   239,   241,   321,   151,   152,   153,   250,   251,   252,
+     322,   305,   307,   375,   253,    42,   254,   316,   154,   155,
+     156,   255,   256,   296,   257,   157,   258,   297,   303,   683,
+     158,   259,   571,   331,   260,   528,   323,   566,   261,   159,
+     262,   263,    52,    53,   160,   161,   162,   163,   164,   165,
+     166,   167,   168,   264,    54,   265,   596,   266,   267,   169,
+     321,   170,   287,   288,   289,   290,   291,   322,   268,   304,
+     269,   270,    42,   339,   310,   586,   171,   351,   359,   317,
+     335,   592,   172,   594,   340,   338,   360,   376,   622,   147,
+     148,   563,   564,   323,   604,   341,   342,   343,   378,    52,
+      53,   350,   358,   362,   379,   380,   381,   173,   386,   301,
+     387,    54,   615,   390,   174,   175,   149,   150,   413,   623,
+     414,   415,   420,   485,   152,   153,   486,   426,   767,   435,
+     437,   768,   441,   446,   462,   770,   424,   154,   155,   156,
+     479,   425,   497,   463,   157,   482,   465,   502,   507,   158,
+     466,   664,   467,   700,   468,   473,   474,   477,   159,   504,
+     510,   508,   517,   160,   161,   162,   163,   164,   165,   166,
+     167,   168,   147,   148,   509,   521,   530,   533,   169,   519,
+     170,   538,   534,   544,   548,   491,   105,   106,   107,   108,
+     109,   110,   111,   112,   113,   171,   545,   554,   714,   149,
+     150,   172,   550,   561,   562,   565,   151,   152,   153,   285,
+     286,   287,   288,   289,   290,   291,   567,  -112,   573,   568,
+     154,   155,   156,   569,   574,   576,   173,   157,   578,   579,
+     336,   587,   158,   174,   175,   588,   597,   611,   583,   605,
+     595,   159,   612,   600,   613,   620,   160,   161,   162,   163,
+     164,   165,   166,   167,   168,   147,   148,   625,   531,   662,
+     661,   169,   663,   170,   278,   279,   280,   281,   282,   283,
+     284,   285,   286,   287,   288,   289,   290,   291,   171,   665,
+     240,   675,   149,   150,   172,   667,   668,   673,   676,   151,
+     152,   153,   281,   282,   283,   284,   285,   286,   287,   288,
+     289,   290,   291,   154,   155,   156,   691,   695,   702,   173,
+     157,   701,   631,   704,   705,   158,   174,   175,   706,   707,
+     708,   709,   710,   632,   159,   724,   732,   711,   713,   160,
+     161,   162,   163,   164,   165,   166,   167,   168,   725,   722,
+     633,  -128,   734,   737,   169,   738,   170,   740,   741,   634,
+     635,   636,   637,   638,   743,   744,   745,   748,   752,   753,
+     755,   171,   639,   640,   756,   761,   366,   172,   332,   729,
+     757,   273,   641,   274,   275,   276,   277,   278,   279,   280,
+     281,   282,   283,   284,   285,   286,   287,   288,   289,   290,
+     291,   763,   173,   698,   716,   674,   547,   760,   736,   174,
+     175,   642,    28,   643,   503,   440,   572,   644,   590,   104,
+     721,    52,    53,   363,   494,   201,   584,     0,     0,     0,
+       0,     0,   273,   645,   274,   275,   276,   277,   278,   279,
+     280,   281,   282,   283,   284,   285,   286,   287,   288,   289,
+     290,   291,     0,   646,    29,    30,    31,   647,     0,     0,
+       0,   648,     0,   649,     0,     0,     0,    32,    33,    34,
+      35,     0,    36,    37,    38,     0,    28,     0,     0,     0,
+       0,    39,    40,    41,    42,   105,   106,   107,   108,   109,
+     110,   111,   112,   113,    43,    44,    45,    46,    47,    48,
+       0,     0,     0,     0,    49,    50,    51,     0,   436,     0,
+     369,    52,    53,     0,     0,     0,     0,     0,    29,    30,
+      31,     0,     0,    54,     0,     0,     0,     0,     0,     0,
+       0,    32,    33,    34,    35,    55,    36,    37,    38,     0,
+       0,  -329,     0,     0,     0,    39,    40,    41,    42,     0,
+       0,    56,     0,     0,     0,     0,     0,     0,    43,    44,
+      45,    46,    47,    48,     0,     0,     0,     0,    49,    50,
+      51,     0,     0,     0,     0,    52,    53,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,    54,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,    55,
+     279,   280,   281,   282,   283,   284,   285,   286,   287,   288,
+     289,   290,   291,     0,   273,    56,   274,   275,   276,   277,
+     278,   279,   280,   281,   282,   283,   284,   285,   286,   287,
+     288,   289,   290,   291,   273,     0,   274,   275,   276,   277,
+     278,   279,   280,   281,   282,   283,   284,   285,   286,   287,
+     288,   289,   290,   291,   273,     0,   274,   275,   276,   277,
+     278,   279,   280,   281,   282,   283,   284,   285,   286,   287,
+     288,   289,   290,   291,   273,     0,   274,   275,   276,   277,
+     278,   279,   280,   281,   282,   283,   284,   285,   286,   287,
+     288,   289,   290,   291,   273,     0,   274,   275,   276,   277,
+     278,   279,   280,   281,   282,   283,   284,   285,   286,   287,
+     288,   289,   290,   291,   273,     0,   274,   275,   276,   277,
+     278,   279,   280,   281,   282,   283,   284,   285,   286,   287,
+     288,   289,   290,   291,     0,     0,     0,     0,     0,     0,
+       0,   456,   273,   457,   274,   275,   276,   277,   278,   279,
+     280,   281,   282,   283,   284,   285,   286,   287,   288,   289,
+     290,   291,   273,   458,   274,   275,   276,   277,   278,   279,
+     280,   281,   282,   283,   284,   285,   286,   287,   288,   289,
+     290,   291,   273,   461,   274,   275,   276,   277,   278,   279,
+     280,   281,   282,   283,   284,   285,   286,   287,   288,   289,
+     290,   291,   273,   464,   274,   275,   276,   277,   278,   279,
+     280,   281,   282,   283,   284,   285,   286,   287,   288,   289,
+     290,   291,   273,   471,   274,   275,   276,   277,   278,   279,
+     280,   281,   282,   283,   284,   285,   286,   287,   288,   289,
+     290,   291,   273,   472,   274,   275,   276,   277,   278,   279,
+     280,   281,   282,   283,   284,   285,   286,   287,   288,   289,
+     290,   291,     0,     0,     0,     0,     0,     0,     0,     0,
+     273,   475,   274,   275,   276,   277,   278,   279,   280,   281,
+     282,   283,   284,   285,   286,   287,   288,   289,   290,   291,
+     273,   555,   274,   275,   276,   277,   278,   279,   280,   281,
+     282,   283,   284,   285,   286,   287,   288,   289,   290,   291,
+     273,   556,   274,   275,   276,   277,   278,   279,   280,   281,
+     282,   283,   284,   285,   286,   287,   288,   289,   290,   291,
+     273,   557,   274,   275,   276,   277,   278,   279,   280,   281,
+     282,   283,   284,   285,   286,   287,   288,   289,   290,   291,
+     273,   558,   274,   275,   276,   277,   278,   279,   280,   281,
+     282,   283,   284,   285,   286,   287,   288,   289,   290,   291,
+     273,   559,   274,   275,   276,   277,   278,   279,   280,   281,
+     282,   283,   284,   285,   286,   287,   288,   289,   290,   291,
+       0,     0,     0,     0,     0,     0,     0,     0,   273,   560,
+     274,   275,   276,   277,   278,   279,   280,   281,   282,   283,
+     284,   285,   286,   287,   288,   289,   290,   291,   273,   585,
+     274,   275,   276,   277,   278,   279,   280,   281,   282,   283,
+     284,   285,   286,   287,   288,   289,   290,   291,   273,   603,
+     274,   275,   276,   277,   278,   279,   280,   281,   282,   283,
+     284,   285,   286,   287,   288,   289,   290,   291,   273,   609,
+     274,   275,   276,   277,   278,   279,   280,   281,   282,   283,
+     284,   285,   286,   287,   288,   289,   290,   291,   273,   610,
+     274,   275,   276,   277,   278,   279,   280,   281,   282,   283,
+     284,   285,   286,   287,   288,   289,   290,   291,   273,   614,
+     274,   275,   276,   277,   278,   279,   280,   281,   282,   283,
+     284,   285,   286,   287,   288,   289,   290,   291,     0,     0,
+       0,     0,     0,     0,     0,     0,   273,   624,   274,   275,
+     276,   277,   278,   279,   280,   281,   282,   283,   284,   285,
+     286,   287,   288,   289,   290,   291,     0,   627,   276,   277,
+     278,   279,   280,   281,   282,   283,   284,   285,   286,   287,
+     288,   289,   290,   291,   273,   292,   274,   275,   276,   277,
+     278,   279,   280,   281,   282,   283,   284,   285,   286,   287,
+     288,   289,   290,   291,   273,   453,   274,   275,   276,   277,
+     278,   279,   280,   281,   282,   283,   284,   285,   286,   287,
+     288,   289,   290,   291,   273,   459,   274,   275,   276,   277,
+     278,   279,   280,   281,   282,   283,   284,   285,   286,   287,
+     288,   289,   290,   291,     0,   460,   684,   687,     0,     0,
+      69,     0,   693,   273,     0,   274,   275,   276,   277,   278,
+     279,   280,   281,   282,   283,   284,   285,   286,   287,   288,
+     289,   290,   291,   469,    69,   531,     0,     0,   718,   684,
+       0,     0,     0,     0,    70,     0,     0,     0,   727,   728,
+       0,   693,     0,   730,   731,     0,     0,     0,     0,     0,
+       0,   735,     0,     0,     0,     0,   455,     0,    70,     0,
+      71,   470,     0,   718,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,   754,     0,     0,     0,
+       0,   476,     0,     0,    71,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    72,     0,     0,     0,
+       0,   733,    73,    74,    75,    76,    77,   -43,    78,    79,
+      80,     0,    81,    82,     0,    83,    84,    85,     0,     0,
+      72,     0,    86,    87,    88,     0,    73,    74,    75,    76,
+      77,     0,    78,    79,    80,     0,    81,    82,     0,    83,
+      84,    85,     0,     0,     0,     0,    86,    87,    88,   273,
+     478,   274,   275,   276,   277,   278,   279,   280,   281,   282,
+     283,   284,   285,   286,   287,   288,   289,   290,   291,   273,
+     537,   274,   275,   276,   277,   278,   279,   280,   281,   282,
+     283,   284,   285,   286,   287,   288,   289,   290,   291,   275,
+     276,   277,   278,   279,   280,   281,   282,   283,   284,   285,
+     286,   287,   288,   289,   290,   291,   277,   278,   279,   280,
+     281,   282,   283,   284,   285,   286,   287,   288,   289,   290,
+     291
+};
+
+static const yytype_int16 yycheck[] =
+{
+      73,    71,   105,   217,    23,    18,     4,     4,   487,     4,
+      83,   114,   235,   227,   228,    25,     4,    90,     3,     4,
+       4,     5,   229,     4,     4,     4,     5,    15,   658,     4,
+       4,     4,     4,     5,    36,    56,     4,     5,     4,     6,
+     575,    15,   490,     4,    32,    30,    31,     6,   136,   137,
+     138,     4,    37,    38,    39,    57,   126,   127,    32,   129,
+     130,     4,     4,    56,    57,   135,    51,    52,    53,     3,
+       4,     4,    15,    58,   129,   610,   149,   150,    63,   736,
+      54,    55,    67,    68,    69,    70,    71,    72,   143,    32,
+     747,    57,    77,    78,    79,    80,    81,    82,    83,    84,
+      85,   174,   175,     4,   177,   649,   585,    92,   129,    94,
+       4,    64,   185,   142,    15,    57,     0,   146,     4,    49,
+      50,   105,     4,     5,   109,   573,   105,   757,   101,   673,
+     115,    32,   205,   105,     4,     5,   129,   105,     4,     5,
+     142,   348,     6,   129,    56,   215,   144,   142,   627,   147,
+     147,    56,    16,   697,     6,   140,   144,   143,   142,   144,
+     144,   142,   147,   148,   144,   139,   239,   142,    56,   242,
+     243,   145,   245,   246,   142,   142,   144,   250,   251,   252,
+     253,   254,    56,   142,   257,   142,   143,   197,   198,   262,
+     263,   264,   265,    37,   127,   268,   269,   130,   131,   132,
+     273,   274,   275,   276,   277,   278,   279,   280,   281,   282,
+     283,   284,   285,   286,   287,   288,   289,   290,   291,   292,
+     293,   294,   445,   105,     4,   628,    37,   300,   301,     4,
+      56,     3,     4,   127,     6,   105,   130,   131,   132,   105,
+      37,   127,     4,   144,   130,   131,   132,   142,   688,   144,
+     746,   321,   655,    15,    37,    37,   359,   360,    30,    31,
+     142,   701,   144,   759,    37,    37,    38,    39,    37,   142,
+      32,   144,   142,     4,   144,   345,   142,   347,   144,    51,
+      52,    53,    37,   506,    15,   688,    58,   142,     4,   144,
+      37,    63,    54,    55,    37,     4,    39,    37,   701,    15,
+      72,    32,    32,    33,    34,    77,    78,    79,    80,    81,
+      82,    83,    84,    85,     4,   142,    32,   144,    37,   332,
+      92,   133,    94,    54,    55,    15,    37,    37,     4,    37,
+     553,    37,    37,     4,     4,   549,     4,   109,    54,    55,
+       4,     4,    32,   115,   363,     4,     4,   127,    57,     4,
+     130,   131,   132,     3,   111,    64,     4,   430,     4,   432,
+     433,   434,    71,     4,    54,    55,     4,    76,   140,    16,
+     142,    16,    57,   143,    57,   147,   148,   139,    67,    68,
+      69,    70,    71,   456,   143,     4,   459,   460,    97,   462,
+       3,     4,     4,     6,   103,   104,   469,   470,     4,     4,
+       4,   123,   124,   125,     4,   478,   115,     4,   139,    99,
+       4,    37,   134,   423,     4,     4,    57,    30,    31,   141,
+       4,    37,    56,    64,    37,    38,    39,    37,    37,    37,
+      71,     4,    56,     4,    37,    76,    37,    57,    51,    52,
+      53,    37,    37,   142,    37,    58,    37,   142,   142,   139,
+      63,    37,    36,   144,    37,   144,    97,   530,    37,    72,
+      37,    37,   103,   104,    77,    78,    79,    80,    81,    82,
+      83,    84,    85,    37,   115,    37,   579,    37,    37,    92,
+      64,    94,    30,    31,    32,    33,    34,    71,    37,   142,
+      37,    37,    76,   144,   143,   568,   109,    37,     6,   143,
+      57,   574,   115,   576,   144,   142,     6,     4,   611,     3,
+       4,   521,   522,    97,   587,   144,   144,   144,     4,   103,
+     104,   144,   144,   144,     4,     4,     4,   140,     4,   142,
+       4,   115,   605,     4,   147,   148,    30,    31,     4,   612,
+       4,     4,     4,    37,    38,    39,    40,     4,   762,     4,
+      37,   765,     4,    37,   142,   769,   143,    51,    52,    53,
+       4,   143,   142,   144,    58,    56,   144,    16,    37,    63,
+     144,   641,   144,   676,   144,   144,   144,   144,    72,   144,
+       4,   144,     4,    77,    78,    79,    80,    81,    82,    83,
+      84,    85,     3,     4,   144,    16,    37,    16,    92,   143,
+      94,    91,   101,     4,    92,    16,     6,     7,     8,     9,
+      10,    11,    12,    13,    14,   109,     4,   144,   691,    30,
+      31,   115,    36,   144,    57,   144,    37,    38,    39,    28,
+      29,    30,    31,    32,    33,    34,    16,    37,    56,    37,
+      51,    52,    53,    38,    37,    37,   140,    58,   144,     6,
+     142,    37,    63,   147,   148,   102,    94,     6,   143,    37,
+     143,    72,    37,    57,    16,    56,    77,    78,    79,    80,
+      81,    82,    83,    84,    85,     3,     4,    56,    37,    37,
+      16,    92,    37,    94,    21,    22,    23,    24,    25,    26,
+      27,    28,    29,    30,    31,    32,    33,    34,   109,    37,
+     139,    57,    30,    31,   115,    37,    37,    37,    37,    37,
+      38,    39,    24,    25,    26,    27,    28,    29,    30,    31,
+      32,    33,    34,    51,    52,    53,    37,    37,    25,   140,
+      58,    56,     4,    37,    37,    63,   147,   148,   144,    37,
+     144,    37,    37,    15,    72,     4,    36,   144,   144,    77,
+      78,    79,    80,    81,    82,    83,    84,    85,   101,   144,
+      32,   144,   144,    57,    92,    25,    94,   144,   144,    41,
+      42,    43,    44,    45,   144,   144,     4,     4,   144,   144,
+     144,   109,    54,    55,   144,     4,   244,   115,   213,   707,
+     144,    15,    64,    17,    18,    19,    20,    21,    22,    23,
+      24,    25,    26,    27,    28,    29,    30,    31,    32,    33,
+      34,   144,   140,   673,   692,   655,   500,   749,   721,   147,
+     148,    93,     4,    95,   439,   337,   539,    99,   572,    26,
+     699,   103,   104,   241,   433,    98,   564,    -1,    -1,    -1,
+      -1,    -1,    15,   115,    17,    18,    19,    20,    21,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,    34,    -1,   135,    46,    47,    48,   139,    -1,    -1,
+      -1,   143,    -1,   145,    -1,    -1,    -1,    59,    60,    61,
+      62,    -1,    64,    65,    66,    -1,     4,    -1,    -1,    -1,
+      -1,    73,    74,    75,    76,     6,     7,     8,     9,    10,
+      11,    12,    13,    14,    86,    87,    88,    89,    90,    91,
+      -1,    -1,    -1,    -1,    96,    97,    98,    -1,    36,    -1,
+     144,   103,   104,    -1,    -1,    -1,    -1,    -1,    46,    47,
+      48,    -1,    -1,   115,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    59,    60,    61,    62,   127,    64,    65,    66,    -1,
+      -1,   133,    -1,    -1,    -1,    73,    74,    75,    76,    -1,
+      -1,   143,    -1,    -1,    -1,    -1,    -1,    -1,    86,    87,
+      88,    89,    90,    91,    -1,    -1,    -1,    -1,    96,    97,
+      98,    -1,    -1,    -1,    -1,   103,   104,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,   115,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   127,
+      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
+      32,    33,    34,    -1,    15,   143,    17,    18,    19,    20,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    34,    15,    -1,    17,    18,    19,    20,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    34,    15,    -1,    17,    18,    19,    20,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    34,    15,    -1,    17,    18,    19,    20,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    34,    15,    -1,    17,    18,    19,    20,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    34,    15,    -1,    17,    18,    19,    20,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    34,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,   142,    15,   144,    17,    18,    19,    20,    21,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,    34,    15,   144,    17,    18,    19,    20,    21,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,    34,    15,   144,    17,    18,    19,    20,    21,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,    34,    15,   144,    17,    18,    19,    20,    21,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,    34,    15,   144,    17,    18,    19,    20,    21,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,    34,    15,   144,    17,    18,    19,    20,    21,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,    34,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      15,   144,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      15,   144,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      15,   144,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      15,   144,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      15,   144,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      15,   144,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    15,   144,
+      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
+      27,    28,    29,    30,    31,    32,    33,    34,    15,   144,
+      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
+      27,    28,    29,    30,    31,    32,    33,    34,    15,   144,
+      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
+      27,    28,    29,    30,    31,    32,    33,    34,    15,   144,
+      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
+      27,    28,    29,    30,    31,    32,    33,    34,    15,   144,
+      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
+      27,    28,    29,    30,    31,    32,    33,    34,    15,   144,
+      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
+      27,    28,    29,    30,    31,    32,    33,    34,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    15,   144,    17,    18,
+      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
+      29,    30,    31,    32,    33,    34,    -1,   144,    19,    20,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    34,    15,   142,    17,    18,    19,    20,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    34,    15,   142,    17,    18,    19,    20,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    34,    15,   142,    17,    18,    19,    20,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    34,    -1,   142,   662,   663,    -1,    -1,
+       4,    -1,   668,    15,    -1,    17,    18,    19,    20,    21,
+      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
+      32,    33,    34,   142,     4,    37,    -1,    -1,   694,   695,
+      -1,    -1,    -1,    -1,    38,    -1,    -1,    -1,   704,   705,
+      -1,   707,    -1,   709,   710,    -1,    -1,    -1,    -1,    -1,
+      -1,   717,    -1,    -1,    -1,    -1,    36,    -1,    38,    -1,
+      64,   142,    -1,   729,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,   742,    -1,    -1,    -1,
+      -1,   142,    -1,    -1,    64,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,   100,    -1,    -1,    -1,
+      -1,   142,   106,   107,   108,   109,   110,   111,   112,   113,
+     114,    -1,   116,   117,    -1,   119,   120,   121,    -1,    -1,
+     100,    -1,   126,   127,   128,    -1,   106,   107,   108,   109,
+     110,    -1,   112,   113,   114,    -1,   116,   117,    -1,   119,
+     120,   121,    -1,    -1,    -1,    -1,   126,   127,   128,    15,
+      16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
+      26,    27,    28,    29,    30,    31,    32,    33,    34,    15,
+      16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
+      26,    27,    28,    29,    30,    31,    32,    33,    34,    18,
+      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
+      29,    30,    31,    32,    33,    34,    20,    21,    22,    23,
+      24,    25,    26,    27,    28,    29,    30,    31,    32,    33,
+      34
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint16 yystos[] =
+{
+       0,   123,   124,   125,   134,   141,   150,   166,   167,   154,
+     155,   152,   153,   263,   264,   258,   259,     0,   168,   156,
+       4,    56,   129,   267,   268,    56,   260,   261,     4,    46,
+      47,    48,    59,    60,    61,    62,    64,    65,    66,    73,
+      74,    75,    76,    86,    87,    88,    89,    90,    91,    96,
+      97,    98,   103,   104,   115,   127,   143,   169,   176,   178,
+     197,   199,   210,   211,   213,   215,   250,   265,   266,     4,
+      38,    64,   100,   106,   107,   108,   109,   110,   112,   113,
+     114,   116,   117,   119,   120,   121,   126,   127,   128,   157,
+       6,     4,   127,   130,   131,   132,   270,   271,    56,   268,
+     131,   132,   262,   271,   261,     6,     7,     8,     9,    10,
+      11,    12,    13,    14,   195,    56,    56,    49,    50,    37,
+      37,     4,   151,    56,    37,    37,    37,    37,    37,    37,
+      37,    37,    37,    37,   170,    37,    37,    37,   179,    37,
+     142,   143,   196,   133,     4,   151,     4,     3,     4,    30,
+      31,    37,    38,    39,    51,    52,    53,    58,    63,    72,
+      77,    78,    79,    80,    81,    82,    83,    84,    85,    92,
+      94,   109,   115,   140,   147,   148,   219,     4,     4,   161,
+       4,   160,   159,     4,     4,     4,   219,     4,     3,     4,
+     162,   163,   164,     4,   111,   219,     4,    16,    16,    57,
+     143,   270,    57,   143,   217,   218,   217,   177,   251,     4,
+       4,     4,     4,   171,     4,    64,   200,   201,   202,     4,
+       4,   151,   151,     4,   151,   144,   151,   212,   214,     4,
+     216,     4,     5,   105,   172,    37,   151,     4,     4,    37,
+     163,    56,     6,   142,   158,     6,   142,   219,   219,   219,
+      37,    37,    37,    37,    37,    37,    37,    37,    37,    37,
+      37,    37,    37,    37,    37,    37,    37,    37,    37,    37,
+      37,   219,   219,    15,    17,    18,    19,    20,    21,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,    34,   142,     6,   142,   219,   142,   142,     4,   142,
+       6,   142,   219,   142,   142,     4,   165,    56,   271,   271,
+     143,     4,   127,   130,   131,   132,    57,   143,   219,     4,
+      57,    64,    71,    97,   178,   225,     4,    57,   252,   142,
+     144,   144,   168,   203,   151,    57,   142,   198,   142,   144,
+     144,   144,   144,   144,   144,   198,   144,   198,   142,   216,
+     144,    37,     4,     5,   105,   142,   144,   172,   144,     6,
+       6,   219,   144,   267,   219,   219,   156,   219,   219,   144,
+     219,   219,   219,   219,   219,     4,     4,   219,     4,     4,
+       4,     4,   219,   219,   219,   219,     4,     4,   219,   219,
+       4,   219,   219,   219,   219,   219,   219,   219,   219,   219,
+     219,   219,   219,   219,   219,   219,   219,   219,   219,   219,
+     219,   219,   219,     4,     4,     4,   219,   219,     3,     4,
+       4,     4,   142,   273,   143,   143,     4,   129,   143,   269,
+     226,   151,   231,   236,   253,     4,    36,    37,   207,   204,
+     202,     4,   151,   151,   216,   173,    37,     4,     5,   105,
+     144,   217,   217,   142,    57,    36,   142,   144,   144,   142,
+     142,   144,   142,   144,   144,   144,   144,   144,   144,   142,
+     142,   144,   144,   144,   144,   144,   142,   144,    16,     4,
+     271,   132,    56,   129,   143,    37,    40,   219,   240,   241,
+     238,    16,   219,   242,   241,   219,   255,   142,     4,   147,
+     208,   209,    16,   200,   144,   172,   175,    37,   144,   144,
+       4,   219,   219,   219,   219,   219,   219,     4,   219,   143,
+     274,    16,   272,    67,    68,    69,    70,    71,   144,   239,
+      37,    37,   240,    16,   101,   221,   177,    16,    91,   243,
+     237,     4,   101,   256,     4,     4,   144,   209,    92,   205,
+      36,   144,   172,   174,   144,   144,   144,   144,   144,   144,
+     144,   144,    57,   271,   271,   144,   219,    16,    37,    38,
+     222,    36,   221,    56,    37,   257,    37,   254,   144,     6,
+     198,   144,   172,   143,   274,   144,   219,    37,   102,   223,
+     223,   177,   219,   256,   219,   143,   217,    94,   206,   144,
+      57,    39,   240,   144,   219,    37,   227,   232,    57,   144,
+     144,     6,    37,    16,   144,   219,   136,   137,   138,   224,
+      56,   256,   217,   219,   144,    56,   233,   144,   228,   246,
+     240,     4,    15,    32,    41,    42,    43,    44,    45,    54,
+      55,    64,    93,    95,    99,   115,   135,   139,   143,   145,
+     180,   181,   184,   185,   187,   190,   191,   192,   197,     4,
+      57,    16,    37,    37,   151,    37,   188,    37,    37,     4,
+      54,   181,   183,    37,   187,    57,    37,   196,   247,   234,
+      54,    55,    99,   139,   180,    54,    55,   180,   189,   193,
+     217,    37,   186,   180,   182,    37,   146,   198,   183,   229,
+     217,    56,    25,   244,    37,    37,   144,    37,   144,    37,
+      37,   144,   191,   144,   219,     4,   184,   144,   180,   181,
+     144,   244,   144,   191,     4,   101,   220,   180,   180,   182,
+     180,   180,    36,   142,   144,   180,   220,    57,    25,   245,
+     144,   144,   144,   144,   144,     4,   245,   248,     4,     6,
+      16,   194,   144,   144,   180,   144,   144,   144,   194,   245,
+     193,     4,   235,   144,   196,   230,   194,   198,   198,   249,
+     198
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+#else
+static void
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+
+      default:
+	break;
+    }
+}
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*-------------------------.
+| yyparse or yypush_parse.  |
+`-------------------------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+
+
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 8:
+
+/* Line 1455 of yacc.c  */
+#line 174 "ldgram.y"
+    { ldlex_defsym(); }
+    break;
+
+  case 9:
+
+/* Line 1455 of yacc.c  */
+#line 176 "ldgram.y"
+    {
+		  ldlex_popstate();
+		  lang_add_assignment(exp_assop((yyvsp[(3) - (4)].token),(yyvsp[(2) - (4)].name),(yyvsp[(4) - (4)].etree)));
+		}
+    break;
+
+  case 10:
+
+/* Line 1455 of yacc.c  */
+#line 184 "ldgram.y"
+    {
+		  ldlex_mri_script ();
+		  PUSH_ERROR (_("MRI style script"));
+		}
+    break;
+
+  case 11:
+
+/* Line 1455 of yacc.c  */
+#line 189 "ldgram.y"
+    {
+		  ldlex_popstate ();
+		  mri_draw_tree ();
+		  POP_ERROR ();
+		}
+    break;
+
+  case 16:
+
+/* Line 1455 of yacc.c  */
+#line 204 "ldgram.y"
+    {
+			einfo(_("%P%F: unrecognised keyword in MRI style script '%s'\n"),(yyvsp[(1) - (1)].name));
+			}
+    break;
+
+  case 17:
+
+/* Line 1455 of yacc.c  */
+#line 207 "ldgram.y"
+    {
+			config.map_filename = "-";
+			}
+    break;
+
+  case 20:
+
+/* Line 1455 of yacc.c  */
+#line 213 "ldgram.y"
+    { mri_public((yyvsp[(2) - (4)].name), (yyvsp[(4) - (4)].etree)); }
+    break;
+
+  case 21:
+
+/* Line 1455 of yacc.c  */
+#line 215 "ldgram.y"
+    { mri_public((yyvsp[(2) - (4)].name), (yyvsp[(4) - (4)].etree)); }
+    break;
+
+  case 22:
+
+/* Line 1455 of yacc.c  */
+#line 217 "ldgram.y"
+    { mri_public((yyvsp[(2) - (3)].name), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 23:
+
+/* Line 1455 of yacc.c  */
+#line 219 "ldgram.y"
+    { mri_format((yyvsp[(2) - (2)].name)); }
+    break;
+
+  case 24:
+
+/* Line 1455 of yacc.c  */
+#line 221 "ldgram.y"
+    { mri_output_section((yyvsp[(2) - (4)].name), (yyvsp[(4) - (4)].etree));}
+    break;
+
+  case 25:
+
+/* Line 1455 of yacc.c  */
+#line 223 "ldgram.y"
+    { mri_output_section((yyvsp[(2) - (3)].name), (yyvsp[(3) - (3)].etree));}
+    break;
+
+  case 26:
+
+/* Line 1455 of yacc.c  */
+#line 225 "ldgram.y"
+    { mri_output_section((yyvsp[(2) - (4)].name), (yyvsp[(4) - (4)].etree));}
+    break;
+
+  case 27:
+
+/* Line 1455 of yacc.c  */
+#line 227 "ldgram.y"
+    { mri_align((yyvsp[(2) - (4)].name),(yyvsp[(4) - (4)].etree)); }
+    break;
+
+  case 28:
+
+/* Line 1455 of yacc.c  */
+#line 229 "ldgram.y"
+    { mri_align((yyvsp[(2) - (4)].name),(yyvsp[(4) - (4)].etree)); }
+    break;
+
+  case 29:
+
+/* Line 1455 of yacc.c  */
+#line 231 "ldgram.y"
+    { mri_alignmod((yyvsp[(2) - (4)].name),(yyvsp[(4) - (4)].etree)); }
+    break;
+
+  case 30:
+
+/* Line 1455 of yacc.c  */
+#line 233 "ldgram.y"
+    { mri_alignmod((yyvsp[(2) - (4)].name),(yyvsp[(4) - (4)].etree)); }
+    break;
+
+  case 33:
+
+/* Line 1455 of yacc.c  */
+#line 237 "ldgram.y"
+    { mri_name((yyvsp[(2) - (2)].name)); }
+    break;
+
+  case 34:
+
+/* Line 1455 of yacc.c  */
+#line 239 "ldgram.y"
+    { mri_alias((yyvsp[(2) - (4)].name),(yyvsp[(4) - (4)].name),0);}
+    break;
+
+  case 35:
+
+/* Line 1455 of yacc.c  */
+#line 241 "ldgram.y"
+    { mri_alias ((yyvsp[(2) - (4)].name), 0, (int) (yyvsp[(4) - (4)].bigint).integer); }
+    break;
+
+  case 36:
+
+/* Line 1455 of yacc.c  */
+#line 243 "ldgram.y"
+    { mri_base((yyvsp[(2) - (2)].etree)); }
+    break;
+
+  case 37:
+
+/* Line 1455 of yacc.c  */
+#line 245 "ldgram.y"
+    { mri_truncate ((unsigned int) (yyvsp[(2) - (2)].bigint).integer); }
+    break;
+
+  case 40:
+
+/* Line 1455 of yacc.c  */
+#line 249 "ldgram.y"
+    { ldlex_script (); ldfile_open_command_file((yyvsp[(2) - (2)].name)); }
+    break;
+
+  case 41:
+
+/* Line 1455 of yacc.c  */
+#line 251 "ldgram.y"
+    { ldlex_popstate (); }
+    break;
+
+  case 42:
+
+/* Line 1455 of yacc.c  */
+#line 253 "ldgram.y"
+    { lang_add_entry ((yyvsp[(2) - (2)].name), FALSE); }
+    break;
+
+  case 44:
+
+/* Line 1455 of yacc.c  */
+#line 258 "ldgram.y"
+    { mri_order((yyvsp[(3) - (3)].name)); }
+    break;
+
+  case 45:
+
+/* Line 1455 of yacc.c  */
+#line 259 "ldgram.y"
+    { mri_order((yyvsp[(2) - (2)].name)); }
+    break;
+
+  case 47:
+
+/* Line 1455 of yacc.c  */
+#line 265 "ldgram.y"
+    { mri_load((yyvsp[(1) - (1)].name)); }
+    break;
+
+  case 48:
+
+/* Line 1455 of yacc.c  */
+#line 266 "ldgram.y"
+    { mri_load((yyvsp[(3) - (3)].name)); }
+    break;
+
+  case 49:
+
+/* Line 1455 of yacc.c  */
+#line 271 "ldgram.y"
+    { mri_only_load((yyvsp[(1) - (1)].name)); }
+    break;
+
+  case 50:
+
+/* Line 1455 of yacc.c  */
+#line 273 "ldgram.y"
+    { mri_only_load((yyvsp[(3) - (3)].name)); }
+    break;
+
+  case 51:
+
+/* Line 1455 of yacc.c  */
+#line 277 "ldgram.y"
+    { (yyval.name) = NULL; }
+    break;
+
+  case 54:
+
+/* Line 1455 of yacc.c  */
+#line 284 "ldgram.y"
+    { ldlex_expression (); }
+    break;
+
+  case 55:
+
+/* Line 1455 of yacc.c  */
+#line 286 "ldgram.y"
+    { ldlex_popstate (); }
+    break;
+
+  case 56:
+
+/* Line 1455 of yacc.c  */
+#line 290 "ldgram.y"
+    { ldlang_add_undef ((yyvsp[(1) - (1)].name)); }
+    break;
+
+  case 57:
+
+/* Line 1455 of yacc.c  */
+#line 292 "ldgram.y"
+    { ldlang_add_undef ((yyvsp[(2) - (2)].name)); }
+    break;
+
+  case 58:
+
+/* Line 1455 of yacc.c  */
+#line 294 "ldgram.y"
+    { ldlang_add_undef ((yyvsp[(3) - (3)].name)); }
+    break;
+
+  case 59:
+
+/* Line 1455 of yacc.c  */
+#line 298 "ldgram.y"
+    { ldlex_both(); }
+    break;
+
+  case 60:
+
+/* Line 1455 of yacc.c  */
+#line 300 "ldgram.y"
+    { ldlex_popstate(); }
+    break;
+
+  case 73:
+
+/* Line 1455 of yacc.c  */
+#line 321 "ldgram.y"
+    { lang_add_target((yyvsp[(3) - (4)].name)); }
+    break;
+
+  case 74:
+
+/* Line 1455 of yacc.c  */
+#line 323 "ldgram.y"
+    { ldfile_add_library_path ((yyvsp[(3) - (4)].name), FALSE); }
+    break;
+
+  case 75:
+
+/* Line 1455 of yacc.c  */
+#line 325 "ldgram.y"
+    { lang_add_output((yyvsp[(3) - (4)].name), 1); }
+    break;
+
+  case 76:
+
+/* Line 1455 of yacc.c  */
+#line 327 "ldgram.y"
+    { lang_add_output_format ((yyvsp[(3) - (4)].name), (char *) NULL,
+					    (char *) NULL, 1); }
+    break;
+
+  case 77:
+
+/* Line 1455 of yacc.c  */
+#line 330 "ldgram.y"
+    { lang_add_output_format ((yyvsp[(3) - (8)].name), (yyvsp[(5) - (8)].name), (yyvsp[(7) - (8)].name), 1); }
+    break;
+
+  case 78:
+
+/* Line 1455 of yacc.c  */
+#line 332 "ldgram.y"
+    { ldfile_set_output_arch ((yyvsp[(3) - (4)].name), bfd_arch_unknown); }
+    break;
+
+  case 79:
+
+/* Line 1455 of yacc.c  */
+#line 334 "ldgram.y"
+    { command_line.force_common_definition = TRUE ; }
+    break;
+
+  case 80:
+
+/* Line 1455 of yacc.c  */
+#line 336 "ldgram.y"
+    { command_line.inhibit_common_definition = TRUE ; }
+    break;
+
+  case 82:
+
+/* Line 1455 of yacc.c  */
+#line 339 "ldgram.y"
+    { lang_enter_group (); }
+    break;
+
+  case 83:
+
+/* Line 1455 of yacc.c  */
+#line 341 "ldgram.y"
+    { lang_leave_group (); }
+    break;
+
+  case 84:
+
+/* Line 1455 of yacc.c  */
+#line 343 "ldgram.y"
+    { lang_add_map((yyvsp[(3) - (4)].name)); }
+    break;
+
+  case 85:
+
+/* Line 1455 of yacc.c  */
+#line 345 "ldgram.y"
+    { ldlex_script (); ldfile_open_command_file((yyvsp[(2) - (2)].name)); }
+    break;
+
+  case 86:
+
+/* Line 1455 of yacc.c  */
+#line 347 "ldgram.y"
+    { ldlex_popstate (); }
+    break;
+
+  case 87:
+
+/* Line 1455 of yacc.c  */
+#line 349 "ldgram.y"
+    {
+		  lang_add_nocrossref ((yyvsp[(3) - (4)].nocrossref));
+		}
+    break;
+
+  case 89:
+
+/* Line 1455 of yacc.c  */
+#line 354 "ldgram.y"
+    { lang_add_insert ((yyvsp[(3) - (3)].name), 0); }
+    break;
+
+  case 90:
+
+/* Line 1455 of yacc.c  */
+#line 356 "ldgram.y"
+    { lang_add_insert ((yyvsp[(3) - (3)].name), 1); }
+    break;
+
+  case 91:
+
+/* Line 1455 of yacc.c  */
+#line 358 "ldgram.y"
+    { lang_memory_region_alias ((yyvsp[(3) - (6)].name), (yyvsp[(5) - (6)].name)); }
+    break;
+
+  case 92:
+
+/* Line 1455 of yacc.c  */
+#line 363 "ldgram.y"
+    { lang_add_input_file((yyvsp[(1) - (1)].name),lang_input_file_is_search_file_enum,
+				 (char *)NULL); }
+    break;
+
+  case 93:
+
+/* Line 1455 of yacc.c  */
+#line 366 "ldgram.y"
+    { lang_add_input_file((yyvsp[(3) - (3)].name),lang_input_file_is_search_file_enum,
+				 (char *)NULL); }
+    break;
+
+  case 94:
+
+/* Line 1455 of yacc.c  */
+#line 369 "ldgram.y"
+    { lang_add_input_file((yyvsp[(2) - (2)].name),lang_input_file_is_search_file_enum,
+				 (char *)NULL); }
+    break;
+
+  case 95:
+
+/* Line 1455 of yacc.c  */
+#line 372 "ldgram.y"
+    { lang_add_input_file((yyvsp[(1) - (1)].name),lang_input_file_is_l_enum,
+				 (char *)NULL); }
+    break;
+
+  case 96:
+
+/* Line 1455 of yacc.c  */
+#line 375 "ldgram.y"
+    { lang_add_input_file((yyvsp[(3) - (3)].name),lang_input_file_is_l_enum,
+				 (char *)NULL); }
+    break;
+
+  case 97:
+
+/* Line 1455 of yacc.c  */
+#line 378 "ldgram.y"
+    { lang_add_input_file((yyvsp[(2) - (2)].name),lang_input_file_is_l_enum,
+				 (char *)NULL); }
+    break;
+
+  case 98:
+
+/* Line 1455 of yacc.c  */
+#line 381 "ldgram.y"
+    { (yyval.integer) = as_needed; as_needed = TRUE; }
+    break;
+
+  case 99:
+
+/* Line 1455 of yacc.c  */
+#line 383 "ldgram.y"
+    { as_needed = (yyvsp[(3) - (5)].integer); }
+    break;
+
+  case 100:
+
+/* Line 1455 of yacc.c  */
+#line 385 "ldgram.y"
+    { (yyval.integer) = as_needed; as_needed = TRUE; }
+    break;
+
+  case 101:
+
+/* Line 1455 of yacc.c  */
+#line 387 "ldgram.y"
+    { as_needed = (yyvsp[(5) - (7)].integer); }
+    break;
+
+  case 102:
+
+/* Line 1455 of yacc.c  */
+#line 389 "ldgram.y"
+    { (yyval.integer) = as_needed; as_needed = TRUE; }
+    break;
+
+  case 103:
+
+/* Line 1455 of yacc.c  */
+#line 391 "ldgram.y"
+    { as_needed = (yyvsp[(4) - (6)].integer); }
+    break;
+
+  case 108:
+
+/* Line 1455 of yacc.c  */
+#line 406 "ldgram.y"
+    { lang_add_entry ((yyvsp[(3) - (4)].name), FALSE); }
+    break;
+
+  case 110:
+
+/* Line 1455 of yacc.c  */
+#line 408 "ldgram.y"
+    {ldlex_expression ();}
+    break;
+
+  case 111:
+
+/* Line 1455 of yacc.c  */
+#line 409 "ldgram.y"
+    { ldlex_popstate ();
+		  lang_add_assignment (exp_assert ((yyvsp[(4) - (7)].etree), (yyvsp[(6) - (7)].name))); }
+    break;
+
+  case 112:
+
+/* Line 1455 of yacc.c  */
+#line 417 "ldgram.y"
+    {
+			  (yyval.cname) = (yyvsp[(1) - (1)].name);
+			}
+    break;
+
+  case 113:
+
+/* Line 1455 of yacc.c  */
+#line 421 "ldgram.y"
+    {
+			  (yyval.cname) = "*";
+			}
+    break;
+
+  case 114:
+
+/* Line 1455 of yacc.c  */
+#line 425 "ldgram.y"
+    {
+			  (yyval.cname) = "?";
+			}
+    break;
+
+  case 115:
+
+/* Line 1455 of yacc.c  */
+#line 432 "ldgram.y"
+    {
+			  (yyval.wildcard).name = (yyvsp[(1) - (1)].cname);
+			  (yyval.wildcard).sorted = none;
+			  (yyval.wildcard).exclude_name_list = NULL;
+			}
+    break;
+
+  case 116:
+
+/* Line 1455 of yacc.c  */
+#line 438 "ldgram.y"
+    {
+			  (yyval.wildcard).name = (yyvsp[(5) - (5)].cname);
+			  (yyval.wildcard).sorted = none;
+			  (yyval.wildcard).exclude_name_list = (yyvsp[(3) - (5)].name_list);
+			}
+    break;
+
+  case 117:
+
+/* Line 1455 of yacc.c  */
+#line 444 "ldgram.y"
+    {
+			  (yyval.wildcard).name = (yyvsp[(3) - (4)].cname);
+			  (yyval.wildcard).sorted = by_name;
+			  (yyval.wildcard).exclude_name_list = NULL;
+			}
+    break;
+
+  case 118:
+
+/* Line 1455 of yacc.c  */
+#line 450 "ldgram.y"
+    {
+			  (yyval.wildcard).name = (yyvsp[(3) - (4)].cname);
+			  (yyval.wildcard).sorted = by_alignment;
+			  (yyval.wildcard).exclude_name_list = NULL;
+			}
+    break;
+
+  case 119:
+
+/* Line 1455 of yacc.c  */
+#line 456 "ldgram.y"
+    {
+			  (yyval.wildcard).name = (yyvsp[(5) - (7)].cname);
+			  (yyval.wildcard).sorted = by_name_alignment;
+			  (yyval.wildcard).exclude_name_list = NULL;
+			}
+    break;
+
+  case 120:
+
+/* Line 1455 of yacc.c  */
+#line 462 "ldgram.y"
+    {
+			  (yyval.wildcard).name = (yyvsp[(5) - (7)].cname);
+			  (yyval.wildcard).sorted = by_name;
+			  (yyval.wildcard).exclude_name_list = NULL;
+			}
+    break;
+
+  case 121:
+
+/* Line 1455 of yacc.c  */
+#line 468 "ldgram.y"
+    {
+			  (yyval.wildcard).name = (yyvsp[(5) - (7)].cname);
+			  (yyval.wildcard).sorted = by_alignment_name;
+			  (yyval.wildcard).exclude_name_list = NULL;
+			}
+    break;
+
+  case 122:
+
+/* Line 1455 of yacc.c  */
+#line 474 "ldgram.y"
+    {
+			  (yyval.wildcard).name = (yyvsp[(5) - (7)].cname);
+			  (yyval.wildcard).sorted = by_alignment;
+			  (yyval.wildcard).exclude_name_list = NULL;
+			}
+    break;
+
+  case 123:
+
+/* Line 1455 of yacc.c  */
+#line 480 "ldgram.y"
+    {
+			  (yyval.wildcard).name = (yyvsp[(7) - (8)].cname);
+			  (yyval.wildcard).sorted = by_name;
+			  (yyval.wildcard).exclude_name_list = (yyvsp[(5) - (8)].name_list);
+			}
+    break;
+
+  case 124:
+
+/* Line 1455 of yacc.c  */
+#line 489 "ldgram.y"
+    {
+			  struct name_list *tmp;
+			  tmp = (struct name_list *) xmalloc (sizeof *tmp);
+			  tmp->name = (yyvsp[(2) - (2)].cname);
+			  tmp->next = (yyvsp[(1) - (2)].name_list);
+			  (yyval.name_list) = tmp;
+			}
+    break;
+
+  case 125:
+
+/* Line 1455 of yacc.c  */
+#line 498 "ldgram.y"
+    {
+			  struct name_list *tmp;
+			  tmp = (struct name_list *) xmalloc (sizeof *tmp);
+			  tmp->name = (yyvsp[(1) - (1)].cname);
+			  tmp->next = NULL;
+			  (yyval.name_list) = tmp;
+			}
+    break;
+
+  case 126:
+
+/* Line 1455 of yacc.c  */
+#line 509 "ldgram.y"
+    {
+			  struct wildcard_list *tmp;
+			  tmp = (struct wildcard_list *) xmalloc (sizeof *tmp);
+			  tmp->next = (yyvsp[(1) - (3)].wildcard_list);
+			  tmp->spec = (yyvsp[(3) - (3)].wildcard);
+			  (yyval.wildcard_list) = tmp;
+			}
+    break;
+
+  case 127:
+
+/* Line 1455 of yacc.c  */
+#line 518 "ldgram.y"
+    {
+			  struct wildcard_list *tmp;
+			  tmp = (struct wildcard_list *) xmalloc (sizeof *tmp);
+			  tmp->next = NULL;
+			  tmp->spec = (yyvsp[(1) - (1)].wildcard);
+			  (yyval.wildcard_list) = tmp;
+			}
+    break;
+
+  case 128:
+
+/* Line 1455 of yacc.c  */
+#line 529 "ldgram.y"
+    {
+			  struct wildcard_spec tmp;
+			  tmp.name = (yyvsp[(1) - (1)].name);
+			  tmp.exclude_name_list = NULL;
+			  tmp.sorted = none;
+			  lang_add_wild (&tmp, NULL, ldgram_had_keep);
+			}
+    break;
+
+  case 129:
+
+/* Line 1455 of yacc.c  */
+#line 537 "ldgram.y"
+    {
+			  lang_add_wild (NULL, (yyvsp[(2) - (3)].wildcard_list), ldgram_had_keep);
+			}
+    break;
+
+  case 130:
+
+/* Line 1455 of yacc.c  */
+#line 541 "ldgram.y"
+    {
+			  lang_add_wild (&(yyvsp[(1) - (4)].wildcard), (yyvsp[(3) - (4)].wildcard_list), ldgram_had_keep);
+			}
+    break;
+
+  case 132:
+
+/* Line 1455 of yacc.c  */
+#line 549 "ldgram.y"
+    { ldgram_had_keep = TRUE; }
+    break;
+
+  case 133:
+
+/* Line 1455 of yacc.c  */
+#line 551 "ldgram.y"
+    { ldgram_had_keep = FALSE; }
+    break;
+
+  case 135:
+
+/* Line 1455 of yacc.c  */
+#line 557 "ldgram.y"
+    {
+ 		lang_add_attribute(lang_object_symbols_statement_enum);
+	      	}
+    break;
+
+  case 137:
+
+/* Line 1455 of yacc.c  */
+#line 562 "ldgram.y"
+    {
+
+		  lang_add_attribute(lang_constructors_statement_enum);
+		}
+    break;
+
+  case 138:
+
+/* Line 1455 of yacc.c  */
+#line 567 "ldgram.y"
+    {
+		  constructors_sorted = TRUE;
+		  lang_add_attribute (lang_constructors_statement_enum);
+		}
+    break;
+
+  case 140:
+
+/* Line 1455 of yacc.c  */
+#line 573 "ldgram.y"
+    {
+			  lang_add_data ((int) (yyvsp[(1) - (4)].integer), (yyvsp[(3) - (4)].etree));
+			}
+    break;
+
+  case 141:
+
+/* Line 1455 of yacc.c  */
+#line 578 "ldgram.y"
+    {
+			  lang_add_fill ((yyvsp[(3) - (4)].fill));
+			}
+    break;
+
+  case 142:
+
+/* Line 1455 of yacc.c  */
+#line 581 "ldgram.y"
+    {ldlex_expression ();}
+    break;
+
+  case 143:
+
+/* Line 1455 of yacc.c  */
+#line 582 "ldgram.y"
+    { ldlex_popstate ();
+			  lang_add_assignment (exp_assert ((yyvsp[(4) - (8)].etree), (yyvsp[(6) - (8)].name))); }
+    break;
+
+  case 144:
+
+/* Line 1455 of yacc.c  */
+#line 585 "ldgram.y"
+    { ldlex_script (); ldfile_open_command_file((yyvsp[(2) - (2)].name)); }
+    break;
+
+  case 145:
+
+/* Line 1455 of yacc.c  */
+#line 587 "ldgram.y"
+    { ldlex_popstate (); }
+    break;
+
+  case 150:
+
+/* Line 1455 of yacc.c  */
+#line 602 "ldgram.y"
+    { (yyval.integer) = (yyvsp[(1) - (1)].token); }
+    break;
+
+  case 151:
+
+/* Line 1455 of yacc.c  */
+#line 604 "ldgram.y"
+    { (yyval.integer) = (yyvsp[(1) - (1)].token); }
+    break;
+
+  case 152:
+
+/* Line 1455 of yacc.c  */
+#line 606 "ldgram.y"
+    { (yyval.integer) = (yyvsp[(1) - (1)].token); }
+    break;
+
+  case 153:
+
+/* Line 1455 of yacc.c  */
+#line 608 "ldgram.y"
+    { (yyval.integer) = (yyvsp[(1) - (1)].token); }
+    break;
+
+  case 154:
+
+/* Line 1455 of yacc.c  */
+#line 610 "ldgram.y"
+    { (yyval.integer) = (yyvsp[(1) - (1)].token); }
+    break;
+
+  case 155:
+
+/* Line 1455 of yacc.c  */
+#line 615 "ldgram.y"
+    {
+		  (yyval.fill) = exp_get_fill ((yyvsp[(1) - (1)].etree), 0, "fill value");
+		}
+    break;
+
+  case 156:
+
+/* Line 1455 of yacc.c  */
+#line 622 "ldgram.y"
+    { (yyval.fill) = (yyvsp[(2) - (2)].fill); }
+    break;
+
+  case 157:
+
+/* Line 1455 of yacc.c  */
+#line 623 "ldgram.y"
+    { (yyval.fill) = (fill_type *) 0; }
+    break;
+
+  case 158:
+
+/* Line 1455 of yacc.c  */
+#line 628 "ldgram.y"
+    { (yyval.token) = '+'; }
+    break;
+
+  case 159:
+
+/* Line 1455 of yacc.c  */
+#line 630 "ldgram.y"
+    { (yyval.token) = '-'; }
+    break;
+
+  case 160:
+
+/* Line 1455 of yacc.c  */
+#line 632 "ldgram.y"
+    { (yyval.token) = '*'; }
+    break;
+
+  case 161:
+
+/* Line 1455 of yacc.c  */
+#line 634 "ldgram.y"
+    { (yyval.token) = '/'; }
+    break;
+
+  case 162:
+
+/* Line 1455 of yacc.c  */
+#line 636 "ldgram.y"
+    { (yyval.token) = LSHIFT; }
+    break;
+
+  case 163:
+
+/* Line 1455 of yacc.c  */
+#line 638 "ldgram.y"
+    { (yyval.token) = RSHIFT; }
+    break;
+
+  case 164:
+
+/* Line 1455 of yacc.c  */
+#line 640 "ldgram.y"
+    { (yyval.token) = '&'; }
+    break;
+
+  case 165:
+
+/* Line 1455 of yacc.c  */
+#line 642 "ldgram.y"
+    { (yyval.token) = '|'; }
+    break;
+
+  case 168:
+
+/* Line 1455 of yacc.c  */
+#line 652 "ldgram.y"
+    {
+		  lang_add_assignment (exp_assop ((yyvsp[(2) - (3)].token), (yyvsp[(1) - (3)].name), (yyvsp[(3) - (3)].etree)));
+		}
+    break;
+
+  case 169:
+
+/* Line 1455 of yacc.c  */
+#line 656 "ldgram.y"
+    {
+		  lang_add_assignment (exp_assop ('=', (yyvsp[(1) - (3)].name),
+						  exp_binop ((yyvsp[(2) - (3)].token),
+							     exp_nameop (NAME,
+									 (yyvsp[(1) - (3)].name)),
+							     (yyvsp[(3) - (3)].etree))));
+		}
+    break;
+
+  case 170:
+
+/* Line 1455 of yacc.c  */
+#line 664 "ldgram.y"
+    {
+		  lang_add_assignment (exp_provide ((yyvsp[(3) - (6)].name), (yyvsp[(5) - (6)].etree), FALSE));
+		}
+    break;
+
+  case 171:
+
+/* Line 1455 of yacc.c  */
+#line 668 "ldgram.y"
+    {
+		  lang_add_assignment (exp_provide ((yyvsp[(3) - (6)].name), (yyvsp[(5) - (6)].etree), TRUE));
+		}
+    break;
+
+  case 179:
+
+/* Line 1455 of yacc.c  */
+#line 691 "ldgram.y"
+    { region = lang_memory_region_lookup ((yyvsp[(1) - (1)].name), TRUE); }
+    break;
+
+  case 180:
+
+/* Line 1455 of yacc.c  */
+#line 694 "ldgram.y"
+    {}
+    break;
+
+  case 181:
+
+/* Line 1455 of yacc.c  */
+#line 696 "ldgram.y"
+    { ldlex_script (); ldfile_open_command_file((yyvsp[(2) - (2)].name)); }
+    break;
+
+  case 182:
+
+/* Line 1455 of yacc.c  */
+#line 698 "ldgram.y"
+    { ldlex_popstate (); }
+    break;
+
+  case 183:
+
+/* Line 1455 of yacc.c  */
+#line 703 "ldgram.y"
+    {
+		  region->origin = exp_get_vma ((yyvsp[(3) - (3)].etree), 0, "origin");
+		  region->current = region->origin;
+		}
+    break;
+
+  case 184:
+
+/* Line 1455 of yacc.c  */
+#line 711 "ldgram.y"
+    {
+		  region->length = exp_get_vma ((yyvsp[(3) - (3)].etree), -1, "length");
+		}
+    break;
+
+  case 185:
+
+/* Line 1455 of yacc.c  */
+#line 718 "ldgram.y"
+    { /* dummy action to avoid bison 1.25 error message */ }
+    break;
+
+  case 189:
+
+/* Line 1455 of yacc.c  */
+#line 729 "ldgram.y"
+    { lang_set_flags (region, (yyvsp[(1) - (1)].name), 0); }
+    break;
+
+  case 190:
+
+/* Line 1455 of yacc.c  */
+#line 731 "ldgram.y"
+    { lang_set_flags (region, (yyvsp[(2) - (2)].name), 1); }
+    break;
+
+  case 191:
+
+/* Line 1455 of yacc.c  */
+#line 736 "ldgram.y"
+    { lang_startup((yyvsp[(3) - (4)].name)); }
+    break;
+
+  case 193:
+
+/* Line 1455 of yacc.c  */
+#line 742 "ldgram.y"
+    { ldemul_hll((char *)NULL); }
+    break;
+
+  case 194:
+
+/* Line 1455 of yacc.c  */
+#line 747 "ldgram.y"
+    { ldemul_hll((yyvsp[(3) - (3)].name)); }
+    break;
+
+  case 195:
+
+/* Line 1455 of yacc.c  */
+#line 749 "ldgram.y"
+    { ldemul_hll((yyvsp[(1) - (1)].name)); }
+    break;
+
+  case 197:
+
+/* Line 1455 of yacc.c  */
+#line 757 "ldgram.y"
+    { ldemul_syslib((yyvsp[(3) - (3)].name)); }
+    break;
+
+  case 199:
+
+/* Line 1455 of yacc.c  */
+#line 763 "ldgram.y"
+    { lang_float(TRUE); }
+    break;
+
+  case 200:
+
+/* Line 1455 of yacc.c  */
+#line 765 "ldgram.y"
+    { lang_float(FALSE); }
+    break;
+
+  case 201:
+
+/* Line 1455 of yacc.c  */
+#line 770 "ldgram.y"
+    {
+		  (yyval.nocrossref) = NULL;
+		}
+    break;
+
+  case 202:
+
+/* Line 1455 of yacc.c  */
+#line 774 "ldgram.y"
+    {
+		  struct lang_nocrossref *n;
+
+		  n = (struct lang_nocrossref *) xmalloc (sizeof *n);
+		  n->name = (yyvsp[(1) - (2)].name);
+		  n->next = (yyvsp[(2) - (2)].nocrossref);
+		  (yyval.nocrossref) = n;
+		}
+    break;
+
+  case 203:
+
+/* Line 1455 of yacc.c  */
+#line 783 "ldgram.y"
+    {
+		  struct lang_nocrossref *n;
+
+		  n = (struct lang_nocrossref *) xmalloc (sizeof *n);
+		  n->name = (yyvsp[(1) - (3)].name);
+		  n->next = (yyvsp[(3) - (3)].nocrossref);
+		  (yyval.nocrossref) = n;
+		}
+    break;
+
+  case 204:
+
+/* Line 1455 of yacc.c  */
+#line 793 "ldgram.y"
+    { ldlex_expression (); }
+    break;
+
+  case 205:
+
+/* Line 1455 of yacc.c  */
+#line 795 "ldgram.y"
+    { ldlex_popstate (); (yyval.etree)=(yyvsp[(2) - (2)].etree);}
+    break;
+
+  case 206:
+
+/* Line 1455 of yacc.c  */
+#line 800 "ldgram.y"
+    { (yyval.etree) = exp_unop ('-', (yyvsp[(2) - (2)].etree)); }
+    break;
+
+  case 207:
+
+/* Line 1455 of yacc.c  */
+#line 802 "ldgram.y"
+    { (yyval.etree) = (yyvsp[(2) - (3)].etree); }
+    break;
+
+  case 208:
+
+/* Line 1455 of yacc.c  */
+#line 804 "ldgram.y"
+    { (yyval.etree) = exp_unop ((int) (yyvsp[(1) - (4)].integer),(yyvsp[(3) - (4)].etree)); }
+    break;
+
+  case 209:
+
+/* Line 1455 of yacc.c  */
+#line 806 "ldgram.y"
+    { (yyval.etree) = exp_unop ('!', (yyvsp[(2) - (2)].etree)); }
+    break;
+
+  case 210:
+
+/* Line 1455 of yacc.c  */
+#line 808 "ldgram.y"
+    { (yyval.etree) = (yyvsp[(2) - (2)].etree); }
+    break;
+
+  case 211:
+
+/* Line 1455 of yacc.c  */
+#line 810 "ldgram.y"
+    { (yyval.etree) = exp_unop ('~', (yyvsp[(2) - (2)].etree));}
+    break;
+
+  case 212:
+
+/* Line 1455 of yacc.c  */
+#line 813 "ldgram.y"
+    { (yyval.etree) = exp_binop ('*', (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 213:
+
+/* Line 1455 of yacc.c  */
+#line 815 "ldgram.y"
+    { (yyval.etree) = exp_binop ('/', (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 214:
+
+/* Line 1455 of yacc.c  */
+#line 817 "ldgram.y"
+    { (yyval.etree) = exp_binop ('%', (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 215:
+
+/* Line 1455 of yacc.c  */
+#line 819 "ldgram.y"
+    { (yyval.etree) = exp_binop ('+', (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 216:
+
+/* Line 1455 of yacc.c  */
+#line 821 "ldgram.y"
+    { (yyval.etree) = exp_binop ('-' , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 217:
+
+/* Line 1455 of yacc.c  */
+#line 823 "ldgram.y"
+    { (yyval.etree) = exp_binop (LSHIFT , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 218:
+
+/* Line 1455 of yacc.c  */
+#line 825 "ldgram.y"
+    { (yyval.etree) = exp_binop (RSHIFT , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 219:
+
+/* Line 1455 of yacc.c  */
+#line 827 "ldgram.y"
+    { (yyval.etree) = exp_binop (EQ , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 220:
+
+/* Line 1455 of yacc.c  */
+#line 829 "ldgram.y"
+    { (yyval.etree) = exp_binop (NE , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 221:
+
+/* Line 1455 of yacc.c  */
+#line 831 "ldgram.y"
+    { (yyval.etree) = exp_binop (LE , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 222:
+
+/* Line 1455 of yacc.c  */
+#line 833 "ldgram.y"
+    { (yyval.etree) = exp_binop (GE , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 223:
+
+/* Line 1455 of yacc.c  */
+#line 835 "ldgram.y"
+    { (yyval.etree) = exp_binop ('<' , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 224:
+
+/* Line 1455 of yacc.c  */
+#line 837 "ldgram.y"
+    { (yyval.etree) = exp_binop ('>' , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 225:
+
+/* Line 1455 of yacc.c  */
+#line 839 "ldgram.y"
+    { (yyval.etree) = exp_binop ('&' , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 226:
+
+/* Line 1455 of yacc.c  */
+#line 841 "ldgram.y"
+    { (yyval.etree) = exp_binop ('^' , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 227:
+
+/* Line 1455 of yacc.c  */
+#line 843 "ldgram.y"
+    { (yyval.etree) = exp_binop ('|' , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 228:
+
+/* Line 1455 of yacc.c  */
+#line 845 "ldgram.y"
+    { (yyval.etree) = exp_trinop ('?' , (yyvsp[(1) - (5)].etree), (yyvsp[(3) - (5)].etree), (yyvsp[(5) - (5)].etree)); }
+    break;
+
+  case 229:
+
+/* Line 1455 of yacc.c  */
+#line 847 "ldgram.y"
+    { (yyval.etree) = exp_binop (ANDAND , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 230:
+
+/* Line 1455 of yacc.c  */
+#line 849 "ldgram.y"
+    { (yyval.etree) = exp_binop (OROR , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }
+    break;
+
+  case 231:
+
+/* Line 1455 of yacc.c  */
+#line 851 "ldgram.y"
+    { (yyval.etree) = exp_nameop (DEFINED, (yyvsp[(3) - (4)].name)); }
+    break;
+
+  case 232:
+
+/* Line 1455 of yacc.c  */
+#line 853 "ldgram.y"
+    { (yyval.etree) = exp_bigintop ((yyvsp[(1) - (1)].bigint).integer, (yyvsp[(1) - (1)].bigint).str); }
+    break;
+
+  case 233:
+
+/* Line 1455 of yacc.c  */
+#line 855 "ldgram.y"
+    { (yyval.etree) = exp_nameop (SIZEOF_HEADERS,0); }
+    break;
+
+  case 234:
+
+/* Line 1455 of yacc.c  */
+#line 858 "ldgram.y"
+    { (yyval.etree) = exp_nameop (ALIGNOF,(yyvsp[(3) - (4)].name)); }
+    break;
+
+  case 235:
+
+/* Line 1455 of yacc.c  */
+#line 860 "ldgram.y"
+    { (yyval.etree) = exp_nameop (SIZEOF,(yyvsp[(3) - (4)].name)); }
+    break;
+
+  case 236:
+
+/* Line 1455 of yacc.c  */
+#line 862 "ldgram.y"
+    { (yyval.etree) = exp_nameop (ADDR,(yyvsp[(3) - (4)].name)); }
+    break;
+
+  case 237:
+
+/* Line 1455 of yacc.c  */
+#line 864 "ldgram.y"
+    { (yyval.etree) = exp_nameop (LOADADDR,(yyvsp[(3) - (4)].name)); }
+    break;
+
+  case 238:
+
+/* Line 1455 of yacc.c  */
+#line 866 "ldgram.y"
+    { (yyval.etree) = exp_nameop (CONSTANT,(yyvsp[(3) - (4)].name)); }
+    break;
+
+  case 239:
+
+/* Line 1455 of yacc.c  */
+#line 868 "ldgram.y"
+    { (yyval.etree) = exp_unop (ABSOLUTE, (yyvsp[(3) - (4)].etree)); }
+    break;
+
+  case 240:
+
+/* Line 1455 of yacc.c  */
+#line 870 "ldgram.y"
+    { (yyval.etree) = exp_unop (ALIGN_K,(yyvsp[(3) - (4)].etree)); }
+    break;
+
+  case 241:
+
+/* Line 1455 of yacc.c  */
+#line 872 "ldgram.y"
+    { (yyval.etree) = exp_binop (ALIGN_K,(yyvsp[(3) - (6)].etree),(yyvsp[(5) - (6)].etree)); }
+    break;
+
+  case 242:
+
+/* Line 1455 of yacc.c  */
+#line 874 "ldgram.y"
+    { (yyval.etree) = exp_binop (DATA_SEGMENT_ALIGN, (yyvsp[(3) - (6)].etree), (yyvsp[(5) - (6)].etree)); }
+    break;
+
+  case 243:
+
+/* Line 1455 of yacc.c  */
+#line 876 "ldgram.y"
+    { (yyval.etree) = exp_binop (DATA_SEGMENT_RELRO_END, (yyvsp[(5) - (6)].etree), (yyvsp[(3) - (6)].etree)); }
+    break;
+
+  case 244:
+
+/* Line 1455 of yacc.c  */
+#line 878 "ldgram.y"
+    { (yyval.etree) = exp_unop (DATA_SEGMENT_END, (yyvsp[(3) - (4)].etree)); }
+    break;
+
+  case 245:
+
+/* Line 1455 of yacc.c  */
+#line 880 "ldgram.y"
+    { /* The operands to the expression node are
+			     placed in the opposite order from the way
+			     in which they appear in the script as
+			     that allows us to reuse more code in
+			     fold_binary.  */
+			  (yyval.etree) = exp_binop (SEGMENT_START,
+					  (yyvsp[(5) - (6)].etree),
+					  exp_nameop (NAME, (yyvsp[(3) - (6)].name))); }
+    break;
+
+  case 246:
+
+/* Line 1455 of yacc.c  */
+#line 889 "ldgram.y"
+    { (yyval.etree) = exp_unop (ALIGN_K,(yyvsp[(3) - (4)].etree)); }
+    break;
+
+  case 247:
+
+/* Line 1455 of yacc.c  */
+#line 891 "ldgram.y"
+    { (yyval.etree) = exp_nameop (NAME,(yyvsp[(1) - (1)].name)); }
+    break;
+
+  case 248:
+
+/* Line 1455 of yacc.c  */
+#line 893 "ldgram.y"
+    { (yyval.etree) = exp_binop (MAX_K, (yyvsp[(3) - (6)].etree), (yyvsp[(5) - (6)].etree) ); }
+    break;
+
+  case 249:
+
+/* Line 1455 of yacc.c  */
+#line 895 "ldgram.y"
+    { (yyval.etree) = exp_binop (MIN_K, (yyvsp[(3) - (6)].etree), (yyvsp[(5) - (6)].etree) ); }
+    break;
+
+  case 250:
+
+/* Line 1455 of yacc.c  */
+#line 897 "ldgram.y"
+    { (yyval.etree) = exp_unop (CEILP2, (yyvsp[(3) - (4)].etree)); }
+    break;
+
+  case 251:
+
+/* Line 1455 of yacc.c  */
+#line 899 "ldgram.y"
+    { (yyval.etree) = exp_unop (NACL_MASK, (yyvsp[(3) - (4)].etree)); }
+    break;
+
+  case 252:
+
+/* Line 1455 of yacc.c  */
+#line 901 "ldgram.y"
+    { (yyval.etree) = exp_assert ((yyvsp[(3) - (6)].etree), (yyvsp[(5) - (6)].name)); }
+    break;
+
+  case 253:
+
+/* Line 1455 of yacc.c  */
+#line 903 "ldgram.y"
+    { (yyval.etree) = exp_nameop (ORIGIN, (yyvsp[(3) - (4)].name)); }
+    break;
+
+  case 254:
+
+/* Line 1455 of yacc.c  */
+#line 905 "ldgram.y"
+    { (yyval.etree) = exp_nameop (LENGTH, (yyvsp[(3) - (4)].name)); }
+    break;
+
+  case 255:
+
+/* Line 1455 of yacc.c  */
+#line 910 "ldgram.y"
+    { (yyval.name) = (yyvsp[(3) - (3)].name); }
+    break;
+
+  case 256:
+
+/* Line 1455 of yacc.c  */
+#line 911 "ldgram.y"
+    { (yyval.name) = 0; }
+    break;
+
+  case 257:
+
+/* Line 1455 of yacc.c  */
+#line 915 "ldgram.y"
+    { (yyval.etree) = (yyvsp[(3) - (4)].etree); }
+    break;
+
+  case 258:
+
+/* Line 1455 of yacc.c  */
+#line 916 "ldgram.y"
+    { (yyval.etree) = 0; }
+    break;
+
+  case 259:
+
+/* Line 1455 of yacc.c  */
+#line 920 "ldgram.y"
+    { (yyval.etree) = (yyvsp[(3) - (4)].etree); }
+    break;
+
+  case 260:
+
+/* Line 1455 of yacc.c  */
+#line 921 "ldgram.y"
+    { (yyval.etree) = 0; }
+    break;
+
+  case 261:
+
+/* Line 1455 of yacc.c  */
+#line 925 "ldgram.y"
+    { (yyval.etree) = (yyvsp[(3) - (4)].etree); }
+    break;
+
+  case 262:
+
+/* Line 1455 of yacc.c  */
+#line 926 "ldgram.y"
+    { (yyval.etree) = 0; }
+    break;
+
+  case 263:
+
+/* Line 1455 of yacc.c  */
+#line 930 "ldgram.y"
+    { (yyval.token) = ONLY_IF_RO; }
+    break;
+
+  case 264:
+
+/* Line 1455 of yacc.c  */
+#line 931 "ldgram.y"
+    { (yyval.token) = ONLY_IF_RW; }
+    break;
+
+  case 265:
+
+/* Line 1455 of yacc.c  */
+#line 932 "ldgram.y"
+    { (yyval.token) = SPECIAL; }
+    break;
+
+  case 266:
+
+/* Line 1455 of yacc.c  */
+#line 933 "ldgram.y"
+    { (yyval.token) = 0; }
+    break;
+
+  case 267:
+
+/* Line 1455 of yacc.c  */
+#line 936 "ldgram.y"
+    { ldlex_expression(); }
+    break;
+
+  case 268:
+
+/* Line 1455 of yacc.c  */
+#line 940 "ldgram.y"
+    { ldlex_popstate (); ldlex_script (); }
+    break;
+
+  case 269:
+
+/* Line 1455 of yacc.c  */
+#line 943 "ldgram.y"
+    {
+			  lang_enter_output_section_statement((yyvsp[(1) - (9)].name), (yyvsp[(3) - (9)].etree),
+							      sectype,
+							      (yyvsp[(5) - (9)].etree), (yyvsp[(6) - (9)].etree), (yyvsp[(4) - (9)].etree), (yyvsp[(8) - (9)].token));
+			}
+    break;
+
+  case 270:
+
+/* Line 1455 of yacc.c  */
+#line 949 "ldgram.y"
+    { ldlex_popstate (); ldlex_expression (); }
+    break;
+
+  case 271:
+
+/* Line 1455 of yacc.c  */
+#line 951 "ldgram.y"
+    {
+		  ldlex_popstate ();
+		  lang_leave_output_section_statement ((yyvsp[(17) - (17)].fill), (yyvsp[(14) - (17)].name), (yyvsp[(16) - (17)].section_phdr), (yyvsp[(15) - (17)].name));
+		}
+    break;
+
+  case 272:
+
+/* Line 1455 of yacc.c  */
+#line 956 "ldgram.y"
+    {}
+    break;
+
+  case 273:
+
+/* Line 1455 of yacc.c  */
+#line 958 "ldgram.y"
+    { ldlex_expression (); }
+    break;
+
+  case 274:
+
+/* Line 1455 of yacc.c  */
+#line 960 "ldgram.y"
+    { ldlex_popstate (); ldlex_script (); }
+    break;
+
+  case 275:
+
+/* Line 1455 of yacc.c  */
+#line 962 "ldgram.y"
+    {
+			  lang_enter_overlay ((yyvsp[(3) - (8)].etree), (yyvsp[(6) - (8)].etree));
+			}
+    break;
+
+  case 276:
+
+/* Line 1455 of yacc.c  */
+#line 967 "ldgram.y"
+    { ldlex_popstate (); ldlex_expression (); }
+    break;
+
+  case 277:
+
+/* Line 1455 of yacc.c  */
+#line 969 "ldgram.y"
+    {
+			  ldlex_popstate ();
+			  lang_leave_overlay ((yyvsp[(5) - (16)].etree), (int) (yyvsp[(4) - (16)].integer),
+					      (yyvsp[(16) - (16)].fill), (yyvsp[(13) - (16)].name), (yyvsp[(15) - (16)].section_phdr), (yyvsp[(14) - (16)].name));
+			}
+    break;
+
+  case 279:
+
+/* Line 1455 of yacc.c  */
+#line 979 "ldgram.y"
+    { ldlex_expression (); }
+    break;
+
+  case 280:
+
+/* Line 1455 of yacc.c  */
+#line 981 "ldgram.y"
+    {
+		  ldlex_popstate ();
+		  lang_add_assignment (exp_assop ('=', ".", (yyvsp[(3) - (3)].etree)));
+		}
+    break;
+
+  case 282:
+
+/* Line 1455 of yacc.c  */
+#line 987 "ldgram.y"
+    { ldlex_script (); ldfile_open_command_file((yyvsp[(2) - (2)].name)); }
+    break;
+
+  case 283:
+
+/* Line 1455 of yacc.c  */
+#line 989 "ldgram.y"
+    { ldlex_popstate (); }
+    break;
+
+  case 284:
+
+/* Line 1455 of yacc.c  */
+#line 993 "ldgram.y"
+    { sectype = noload_section; }
+    break;
+
+  case 285:
+
+/* Line 1455 of yacc.c  */
+#line 994 "ldgram.y"
+    { sectype = noalloc_section; }
+    break;
+
+  case 286:
+
+/* Line 1455 of yacc.c  */
+#line 995 "ldgram.y"
+    { sectype = noalloc_section; }
+    break;
+
+  case 287:
+
+/* Line 1455 of yacc.c  */
+#line 996 "ldgram.y"
+    { sectype = noalloc_section; }
+    break;
+
+  case 288:
+
+/* Line 1455 of yacc.c  */
+#line 997 "ldgram.y"
+    { sectype = noalloc_section; }
+    break;
+
+  case 290:
+
+/* Line 1455 of yacc.c  */
+#line 1002 "ldgram.y"
+    { sectype = normal_section; }
+    break;
+
+  case 291:
+
+/* Line 1455 of yacc.c  */
+#line 1003 "ldgram.y"
+    { sectype = normal_section; }
+    break;
+
+  case 292:
+
+/* Line 1455 of yacc.c  */
+#line 1007 "ldgram.y"
+    { (yyval.etree) = (yyvsp[(1) - (3)].etree); }
+    break;
+
+  case 293:
+
+/* Line 1455 of yacc.c  */
+#line 1008 "ldgram.y"
+    { (yyval.etree) = (etree_type *)NULL;  }
+    break;
+
+  case 294:
+
+/* Line 1455 of yacc.c  */
+#line 1013 "ldgram.y"
+    { (yyval.etree) = (yyvsp[(3) - (6)].etree); }
+    break;
+
+  case 295:
+
+/* Line 1455 of yacc.c  */
+#line 1015 "ldgram.y"
+    { (yyval.etree) = (yyvsp[(3) - (10)].etree); }
+    break;
+
+  case 296:
+
+/* Line 1455 of yacc.c  */
+#line 1019 "ldgram.y"
+    { (yyval.etree) = (yyvsp[(1) - (2)].etree); }
+    break;
+
+  case 297:
+
+/* Line 1455 of yacc.c  */
+#line 1020 "ldgram.y"
+    { (yyval.etree) = (etree_type *) NULL;  }
+    break;
+
+  case 298:
+
+/* Line 1455 of yacc.c  */
+#line 1025 "ldgram.y"
+    { (yyval.integer) = 0; }
+    break;
+
+  case 299:
+
+/* Line 1455 of yacc.c  */
+#line 1027 "ldgram.y"
+    { (yyval.integer) = 1; }
+    break;
+
+  case 300:
+
+/* Line 1455 of yacc.c  */
+#line 1032 "ldgram.y"
+    { (yyval.name) = (yyvsp[(2) - (2)].name); }
+    break;
+
+  case 301:
+
+/* Line 1455 of yacc.c  */
+#line 1033 "ldgram.y"
+    { (yyval.name) = DEFAULT_MEMORY_REGION; }
+    break;
+
+  case 302:
+
+/* Line 1455 of yacc.c  */
+#line 1038 "ldgram.y"
+    {
+		  (yyval.section_phdr) = NULL;
+		}
+    break;
+
+  case 303:
+
+/* Line 1455 of yacc.c  */
+#line 1042 "ldgram.y"
+    {
+		  struct lang_output_section_phdr_list *n;
+
+		  n = ((struct lang_output_section_phdr_list *)
+		       xmalloc (sizeof *n));
+		  n->name = (yyvsp[(3) - (3)].name);
+		  n->used = FALSE;
+		  n->next = (yyvsp[(1) - (3)].section_phdr);
+		  (yyval.section_phdr) = n;
+		}
+    break;
+
+  case 305:
+
+/* Line 1455 of yacc.c  */
+#line 1058 "ldgram.y"
+    {
+			  ldlex_script ();
+			  lang_enter_overlay_section ((yyvsp[(2) - (2)].name));
+			}
+    break;
+
+  case 306:
+
+/* Line 1455 of yacc.c  */
+#line 1063 "ldgram.y"
+    { ldlex_popstate (); ldlex_expression (); }
+    break;
+
+  case 307:
+
+/* Line 1455 of yacc.c  */
+#line 1065 "ldgram.y"
+    {
+			  ldlex_popstate ();
+			  lang_leave_overlay_section ((yyvsp[(9) - (9)].fill), (yyvsp[(8) - (9)].section_phdr));
+			}
+    break;
+
+  case 312:
+
+/* Line 1455 of yacc.c  */
+#line 1082 "ldgram.y"
+    { ldlex_expression (); }
+    break;
+
+  case 313:
+
+/* Line 1455 of yacc.c  */
+#line 1083 "ldgram.y"
+    { ldlex_popstate (); }
+    break;
+
+  case 314:
+
+/* Line 1455 of yacc.c  */
+#line 1085 "ldgram.y"
+    {
+		  lang_new_phdr ((yyvsp[(1) - (6)].name), (yyvsp[(3) - (6)].etree), (yyvsp[(4) - (6)].phdr).filehdr, (yyvsp[(4) - (6)].phdr).phdrs, (yyvsp[(4) - (6)].phdr).at,
+				 (yyvsp[(4) - (6)].phdr).flags);
+		}
+    break;
+
+  case 315:
+
+/* Line 1455 of yacc.c  */
+#line 1093 "ldgram.y"
+    {
+		  (yyval.etree) = (yyvsp[(1) - (1)].etree);
+
+		  if ((yyvsp[(1) - (1)].etree)->type.node_class == etree_name
+		      && (yyvsp[(1) - (1)].etree)->type.node_code == NAME)
+		    {
+		      const char *s;
+		      unsigned int i;
+		      static const char * const phdr_types[] =
+			{
+			  "PT_NULL", "PT_LOAD", "PT_DYNAMIC",
+			  "PT_INTERP", "PT_NOTE", "PT_SHLIB",
+			  "PT_PHDR", "PT_TLS"
+			};
+
+		      s = (yyvsp[(1) - (1)].etree)->name.name;
+		      for (i = 0;
+			   i < sizeof phdr_types / sizeof phdr_types[0];
+			   i++)
+			if (strcmp (s, phdr_types[i]) == 0)
+			  {
+			    (yyval.etree) = exp_intop (i);
+			    break;
+			  }
+		      if (i == sizeof phdr_types / sizeof phdr_types[0])
+			{
+			  if (strcmp (s, "PT_GNU_EH_FRAME") == 0)
+			    (yyval.etree) = exp_intop (0x6474e550);
+			  else if (strcmp (s, "PT_GNU_STACK") == 0)
+			    (yyval.etree) = exp_intop (0x6474e551);
+			  else
+			    {
+			      einfo (_("\
+%X%P:%S: unknown phdr type `%s' (try integer literal)\n"),
+				     s);
+			      (yyval.etree) = exp_intop (0);
+			    }
+			}
+		    }
+		}
+    break;
+
+  case 316:
+
+/* Line 1455 of yacc.c  */
+#line 1137 "ldgram.y"
+    {
+		  memset (&(yyval.phdr), 0, sizeof (struct phdr_info));
+		}
+    break;
+
+  case 317:
+
+/* Line 1455 of yacc.c  */
+#line 1141 "ldgram.y"
+    {
+		  (yyval.phdr) = (yyvsp[(3) - (3)].phdr);
+		  if (strcmp ((yyvsp[(1) - (3)].name), "FILEHDR") == 0 && (yyvsp[(2) - (3)].etree) == NULL)
+		    (yyval.phdr).filehdr = TRUE;
+		  else if (strcmp ((yyvsp[(1) - (3)].name), "PHDRS") == 0 && (yyvsp[(2) - (3)].etree) == NULL)
+		    (yyval.phdr).phdrs = TRUE;
+		  else if (strcmp ((yyvsp[(1) - (3)].name), "FLAGS") == 0 && (yyvsp[(2) - (3)].etree) != NULL)
+		    (yyval.phdr).flags = (yyvsp[(2) - (3)].etree);
+		  else
+		    einfo (_("%X%P:%S: PHDRS syntax error at `%s'\n"), (yyvsp[(1) - (3)].name));
+		}
+    break;
+
+  case 318:
+
+/* Line 1455 of yacc.c  */
+#line 1153 "ldgram.y"
+    {
+		  (yyval.phdr) = (yyvsp[(5) - (5)].phdr);
+		  (yyval.phdr).at = (yyvsp[(3) - (5)].etree);
+		}
+    break;
+
+  case 319:
+
+/* Line 1455 of yacc.c  */
+#line 1161 "ldgram.y"
+    {
+		  (yyval.etree) = NULL;
+		}
+    break;
+
+  case 320:
+
+/* Line 1455 of yacc.c  */
+#line 1165 "ldgram.y"
+    {
+		  (yyval.etree) = (yyvsp[(2) - (3)].etree);
+		}
+    break;
+
+  case 321:
+
+/* Line 1455 of yacc.c  */
+#line 1171 "ldgram.y"
+    {
+		  ldlex_version_file ();
+		  PUSH_ERROR (_("dynamic list"));
+		}
+    break;
+
+  case 322:
+
+/* Line 1455 of yacc.c  */
+#line 1176 "ldgram.y"
+    {
+		  ldlex_popstate ();
+		  POP_ERROR ();
+		}
+    break;
+
+  case 326:
+
+/* Line 1455 of yacc.c  */
+#line 1193 "ldgram.y"
+    {
+		  lang_append_dynamic_list ((yyvsp[(1) - (2)].versyms));
+		}
+    break;
+
+  case 327:
+
+/* Line 1455 of yacc.c  */
+#line 1201 "ldgram.y"
+    {
+		  ldlex_version_file ();
+		  PUSH_ERROR (_("VERSION script"));
+		}
+    break;
+
+  case 328:
+
+/* Line 1455 of yacc.c  */
+#line 1206 "ldgram.y"
+    {
+		  ldlex_popstate ();
+		  POP_ERROR ();
+		}
+    break;
+
+  case 329:
+
+/* Line 1455 of yacc.c  */
+#line 1215 "ldgram.y"
+    {
+		  ldlex_version_script ();
+		}
+    break;
+
+  case 330:
+
+/* Line 1455 of yacc.c  */
+#line 1219 "ldgram.y"
+    {
+		  ldlex_popstate ();
+		}
+    break;
+
+  case 333:
+
+/* Line 1455 of yacc.c  */
+#line 1231 "ldgram.y"
+    {
+		  lang_register_vers_node (NULL, (yyvsp[(2) - (4)].versnode), NULL);
+		}
+    break;
+
+  case 334:
+
+/* Line 1455 of yacc.c  */
+#line 1235 "ldgram.y"
+    {
+		  lang_register_vers_node ((yyvsp[(1) - (5)].name), (yyvsp[(3) - (5)].versnode), NULL);
+		}
+    break;
+
+  case 335:
+
+/* Line 1455 of yacc.c  */
+#line 1239 "ldgram.y"
+    {
+		  lang_register_vers_node ((yyvsp[(1) - (6)].name), (yyvsp[(3) - (6)].versnode), (yyvsp[(5) - (6)].deflist));
+		}
+    break;
+
+  case 336:
+
+/* Line 1455 of yacc.c  */
+#line 1246 "ldgram.y"
+    {
+		  (yyval.deflist) = lang_add_vers_depend (NULL, (yyvsp[(1) - (1)].name));
+		}
+    break;
+
+  case 337:
+
+/* Line 1455 of yacc.c  */
+#line 1250 "ldgram.y"
+    {
+		  (yyval.deflist) = lang_add_vers_depend ((yyvsp[(1) - (2)].deflist), (yyvsp[(2) - (2)].name));
+		}
+    break;
+
+  case 338:
+
+/* Line 1455 of yacc.c  */
+#line 1257 "ldgram.y"
+    {
+		  (yyval.versnode) = lang_new_vers_node (NULL, NULL);
+		}
+    break;
+
+  case 339:
+
+/* Line 1455 of yacc.c  */
+#line 1261 "ldgram.y"
+    {
+		  (yyval.versnode) = lang_new_vers_node ((yyvsp[(1) - (2)].versyms), NULL);
+		}
+    break;
+
+  case 340:
+
+/* Line 1455 of yacc.c  */
+#line 1265 "ldgram.y"
+    {
+		  (yyval.versnode) = lang_new_vers_node ((yyvsp[(3) - (4)].versyms), NULL);
+		}
+    break;
+
+  case 341:
+
+/* Line 1455 of yacc.c  */
+#line 1269 "ldgram.y"
+    {
+		  (yyval.versnode) = lang_new_vers_node (NULL, (yyvsp[(3) - (4)].versyms));
+		}
+    break;
+
+  case 342:
+
+/* Line 1455 of yacc.c  */
+#line 1273 "ldgram.y"
+    {
+		  (yyval.versnode) = lang_new_vers_node ((yyvsp[(3) - (8)].versyms), (yyvsp[(7) - (8)].versyms));
+		}
+    break;
+
+  case 343:
+
+/* Line 1455 of yacc.c  */
+#line 1280 "ldgram.y"
+    {
+		  (yyval.versyms) = lang_new_vers_pattern (NULL, (yyvsp[(1) - (1)].name), ldgram_vers_current_lang, FALSE);
+		}
+    break;
+
+  case 344:
+
+/* Line 1455 of yacc.c  */
+#line 1284 "ldgram.y"
+    {
+		  (yyval.versyms) = lang_new_vers_pattern (NULL, (yyvsp[(1) - (1)].name), ldgram_vers_current_lang, TRUE);
+		}
+    break;
+
+  case 345:
+
+/* Line 1455 of yacc.c  */
+#line 1288 "ldgram.y"
+    {
+		  (yyval.versyms) = lang_new_vers_pattern ((yyvsp[(1) - (3)].versyms), (yyvsp[(3) - (3)].name), ldgram_vers_current_lang, FALSE);
+		}
+    break;
+
+  case 346:
+
+/* Line 1455 of yacc.c  */
+#line 1292 "ldgram.y"
+    {
+		  (yyval.versyms) = lang_new_vers_pattern ((yyvsp[(1) - (3)].versyms), (yyvsp[(3) - (3)].name), ldgram_vers_current_lang, TRUE);
+		}
+    break;
+
+  case 347:
+
+/* Line 1455 of yacc.c  */
+#line 1296 "ldgram.y"
+    {
+			  (yyval.name) = ldgram_vers_current_lang;
+			  ldgram_vers_current_lang = (yyvsp[(4) - (5)].name);
+			}
+    break;
+
+  case 348:
+
+/* Line 1455 of yacc.c  */
+#line 1301 "ldgram.y"
+    {
+			  struct bfd_elf_version_expr *pat;
+			  for (pat = (yyvsp[(7) - (9)].versyms); pat->next != NULL; pat = pat->next);
+			  pat->next = (yyvsp[(1) - (9)].versyms);
+			  (yyval.versyms) = (yyvsp[(7) - (9)].versyms);
+			  ldgram_vers_current_lang = (yyvsp[(6) - (9)].name);
+			}
+    break;
+
+  case 349:
+
+/* Line 1455 of yacc.c  */
+#line 1309 "ldgram.y"
+    {
+			  (yyval.name) = ldgram_vers_current_lang;
+			  ldgram_vers_current_lang = (yyvsp[(2) - (3)].name);
+			}
+    break;
+
+  case 350:
+
+/* Line 1455 of yacc.c  */
+#line 1314 "ldgram.y"
+    {
+			  (yyval.versyms) = (yyvsp[(5) - (7)].versyms);
+			  ldgram_vers_current_lang = (yyvsp[(4) - (7)].name);
+			}
+    break;
+
+  case 351:
+
+/* Line 1455 of yacc.c  */
+#line 1319 "ldgram.y"
+    {
+		  (yyval.versyms) = lang_new_vers_pattern (NULL, "global", ldgram_vers_current_lang, FALSE);
+		}
+    break;
+
+  case 352:
+
+/* Line 1455 of yacc.c  */
+#line 1323 "ldgram.y"
+    {
+		  (yyval.versyms) = lang_new_vers_pattern ((yyvsp[(1) - (3)].versyms), "global", ldgram_vers_current_lang, FALSE);
+		}
+    break;
+
+  case 353:
+
+/* Line 1455 of yacc.c  */
+#line 1327 "ldgram.y"
+    {
+		  (yyval.versyms) = lang_new_vers_pattern (NULL, "local", ldgram_vers_current_lang, FALSE);
+		}
+    break;
+
+  case 354:
+
+/* Line 1455 of yacc.c  */
+#line 1331 "ldgram.y"
+    {
+		  (yyval.versyms) = lang_new_vers_pattern ((yyvsp[(1) - (3)].versyms), "local", ldgram_vers_current_lang, FALSE);
+		}
+    break;
+
+  case 355:
+
+/* Line 1455 of yacc.c  */
+#line 1335 "ldgram.y"
+    {
+		  (yyval.versyms) = lang_new_vers_pattern (NULL, "extern", ldgram_vers_current_lang, FALSE);
+		}
+    break;
+
+  case 356:
+
+/* Line 1455 of yacc.c  */
+#line 1339 "ldgram.y"
+    {
+		  (yyval.versyms) = lang_new_vers_pattern ((yyvsp[(1) - (3)].versyms), "extern", ldgram_vers_current_lang, FALSE);
+		}
+    break;
+
+
+
+/* Line 1455 of yacc.c  */
+#line 4867 "ldgram.c"
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined(yyoverflow) || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+
+/* Line 1675 of yacc.c  */
+#line 1349 "ldgram.y"
+
+void
+yyerror(arg)
+     const char *arg;
+{
+  if (ldfile_assumed_script)
+    einfo (_("%P:%s: file format not recognized; treating as linker script\n"),
+	   ldfile_input_filename);
+  if (error_index > 0 && error_index < ERROR_NAME_MAX)
+     einfo ("%P%F:%S: %s in %s\n", arg, error_names[error_index-1]);
+  else
+     einfo ("%P%F:%S: %s\n", arg);
+}
+
==== (added) binutils-2.19.91.20091006/ld/ldgram.h ====
--- /dev/null	2009-05-01 06:17:58.000000000 +0200
+++ binutils-2.19.91.20091006/ld/ldgram.h	2009-10-07 07:56:56.000000000 +0200
@@ -0,0 +1,341 @@
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
+
+/* Skeleton interface for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     INT = 258,
+     NAME = 259,
+     LNAME = 260,
+     OREQ = 261,
+     ANDEQ = 262,
+     RSHIFTEQ = 263,
+     LSHIFTEQ = 264,
+     DIVEQ = 265,
+     MULTEQ = 266,
+     MINUSEQ = 267,
+     PLUSEQ = 268,
+     OROR = 269,
+     ANDAND = 270,
+     NE = 271,
+     EQ = 272,
+     GE = 273,
+     LE = 274,
+     RSHIFT = 275,
+     LSHIFT = 276,
+     UNARY = 277,
+     END = 278,
+     ALIGN_K = 279,
+     BLOCK = 280,
+     BIND = 281,
+     QUAD = 282,
+     SQUAD = 283,
+     LONG = 284,
+     SHORT = 285,
+     BYTE = 286,
+     SECTIONS = 287,
+     PHDRS = 288,
+     INSERT_K = 289,
+     AFTER = 290,
+     BEFORE = 291,
+     DATA_SEGMENT_ALIGN = 292,
+     DATA_SEGMENT_RELRO_END = 293,
+     DATA_SEGMENT_END = 294,
+     SORT_BY_NAME = 295,
+     SORT_BY_ALIGNMENT = 296,
+     SIZEOF_HEADERS = 297,
+     OUTPUT_FORMAT = 298,
+     FORCE_COMMON_ALLOCATION = 299,
+     OUTPUT_ARCH = 300,
+     INHIBIT_COMMON_ALLOCATION = 301,
+     SEGMENT_START = 302,
+     INCLUDE = 303,
+     MEMORY = 304,
+     REGION_ALIAS = 305,
+     NOLOAD = 306,
+     DSECT = 307,
+     COPY = 308,
+     INFO = 309,
+     OVERLAY = 310,
+     DEFINED = 311,
+     TARGET_K = 312,
+     SEARCH_DIR = 313,
+     MAP = 314,
+     ENTRY = 315,
+     NEXT = 316,
+     SIZEOF = 317,
+     ALIGNOF = 318,
+     ADDR = 319,
+     LOADADDR = 320,
+     MAX_K = 321,
+     MIN_K = 322,
+     CEILP2 = 323,
+     NACL_MASK = 324,
+     STARTUP = 325,
+     HLL = 326,
+     SYSLIB = 327,
+     FLOAT = 328,
+     NOFLOAT = 329,
+     NOCROSSREFS = 330,
+     ORIGIN = 331,
+     FILL = 332,
+     LENGTH = 333,
+     CREATE_OBJECT_SYMBOLS = 334,
+     INPUT = 335,
+     GROUP = 336,
+     OUTPUT = 337,
+     CONSTRUCTORS = 338,
+     ALIGNMOD = 339,
+     AT = 340,
+     SUBALIGN = 341,
+     PROVIDE = 342,
+     PROVIDE_HIDDEN = 343,
+     AS_NEEDED = 344,
+     CHIP = 345,
+     LIST = 346,
+     SECT = 347,
+     ABSOLUTE = 348,
+     LOAD = 349,
+     NEWLINE = 350,
+     ENDWORD = 351,
+     ORDER = 352,
+     NAMEWORD = 353,
+     ASSERT_K = 354,
+     FORMAT = 355,
+     PUBLIC = 356,
+     DEFSYMEND = 357,
+     BASE = 358,
+     ALIAS = 359,
+     TRUNCATE = 360,
+     REL = 361,
+     INPUT_SCRIPT = 362,
+     INPUT_MRI_SCRIPT = 363,
+     INPUT_DEFSYM = 364,
+     CASE = 365,
+     EXTERN = 366,
+     START = 367,
+     VERS_TAG = 368,
+     VERS_IDENTIFIER = 369,
+     GLOBAL = 370,
+     LOCAL = 371,
+     VERSIONK = 372,
+     INPUT_VERSION_SCRIPT = 373,
+     KEEP = 374,
+     ONLY_IF_RO = 375,
+     ONLY_IF_RW = 376,
+     SPECIAL = 377,
+     EXCLUDE_FILE = 378,
+     CONSTANT = 379,
+     INPUT_DYNAMIC_LIST = 380
+   };
+#endif
+/* Tokens.  */
+#define INT 258
+#define NAME 259
+#define LNAME 260
+#define OREQ 261
+#define ANDEQ 262
+#define RSHIFTEQ 263
+#define LSHIFTEQ 264
+#define DIVEQ 265
+#define MULTEQ 266
+#define MINUSEQ 267
+#define PLUSEQ 268
+#define OROR 269
+#define ANDAND 270
+#define NE 271
+#define EQ 272
+#define GE 273
+#define LE 274
+#define RSHIFT 275
+#define LSHIFT 276
+#define UNARY 277
+#define END 278
+#define ALIGN_K 279
+#define BLOCK 280
+#define BIND 281
+#define QUAD 282
+#define SQUAD 283
+#define LONG 284
+#define SHORT 285
+#define BYTE 286
+#define SECTIONS 287
+#define PHDRS 288
+#define INSERT_K 289
+#define AFTER 290
+#define BEFORE 291
+#define DATA_SEGMENT_ALIGN 292
+#define DATA_SEGMENT_RELRO_END 293
+#define DATA_SEGMENT_END 294
+#define SORT_BY_NAME 295
+#define SORT_BY_ALIGNMENT 296
+#define SIZEOF_HEADERS 297
+#define OUTPUT_FORMAT 298
+#define FORCE_COMMON_ALLOCATION 299
+#define OUTPUT_ARCH 300
+#define INHIBIT_COMMON_ALLOCATION 301
+#define SEGMENT_START 302
+#define INCLUDE 303
+#define MEMORY 304
+#define REGION_ALIAS 305
+#define NOLOAD 306
+#define DSECT 307
+#define COPY 308
+#define INFO 309
+#define OVERLAY 310
+#define DEFINED 311
+#define TARGET_K 312
+#define SEARCH_DIR 313
+#define MAP 314
+#define ENTRY 315
+#define NEXT 316
+#define SIZEOF 317
+#define ALIGNOF 318
+#define ADDR 319
+#define LOADADDR 320
+#define MAX_K 321
+#define MIN_K 322
+#define CEILP2 323
+#define NACL_MASK 324
+#define STARTUP 325
+#define HLL 326
+#define SYSLIB 327
+#define FLOAT 328
+#define NOFLOAT 329
+#define NOCROSSREFS 330
+#define ORIGIN 331
+#define FILL 332
+#define LENGTH 333
+#define CREATE_OBJECT_SYMBOLS 334
+#define INPUT 335
+#define GROUP 336
+#define OUTPUT 337
+#define CONSTRUCTORS 338
+#define ALIGNMOD 339
+#define AT 340
+#define SUBALIGN 341
+#define PROVIDE 342
+#define PROVIDE_HIDDEN 343
+#define AS_NEEDED 344
+#define CHIP 345
+#define LIST 346
+#define SECT 347
+#define ABSOLUTE 348
+#define LOAD 349
+#define NEWLINE 350
+#define ENDWORD 351
+#define ORDER 352
+#define NAMEWORD 353
+#define ASSERT_K 354
+#define FORMAT 355
+#define PUBLIC 356
+#define DEFSYMEND 357
+#define BASE 358
+#define ALIAS 359
+#define TRUNCATE 360
+#define REL 361
+#define INPUT_SCRIPT 362
+#define INPUT_MRI_SCRIPT 363
+#define INPUT_DEFSYM 364
+#define CASE 365
+#define EXTERN 366
+#define START 367
+#define VERS_TAG 368
+#define VERS_IDENTIFIER 369
+#define GLOBAL 370
+#define LOCAL 371
+#define VERSIONK 372
+#define INPUT_VERSION_SCRIPT 373
+#define KEEP 374
+#define ONLY_IF_RO 375
+#define ONLY_IF_RW 376
+#define SPECIAL 377
+#define EXCLUDE_FILE 378
+#define CONSTANT 379
+#define INPUT_DYNAMIC_LIST 380
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 1676 of yacc.c  */
+#line 62 "ldgram.y"
+
+  bfd_vma integer;
+  struct big_int
+    {
+      bfd_vma integer;
+      char *str;
+    } bigint;
+  fill_type *fill;
+  char *name;
+  const char *cname;
+  struct wildcard_spec wildcard;
+  struct wildcard_list *wildcard_list;
+  struct name_list *name_list;
+  int token;
+  union etree_union *etree;
+  struct phdr_info
+    {
+      bfd_boolean filehdr;
+      bfd_boolean phdrs;
+      union etree_union *at;
+      union etree_union *flags;
+    } phdr;
+  struct lang_nocrossref *nocrossref;
+  struct lang_output_section_phdr_list *section_phdr;
+  struct bfd_elf_version_deps *deflist;
+  struct bfd_elf_version_expr *versyms;
+  struct bfd_elf_version_tree *versnode;
+
+
+
+/* Line 1676 of yacc.c  */
+#line 333 "ldgram.h"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+extern YYSTYPE yylval;
+
+
==== (added) binutils-2.19.91.20091006/ld/ldlex.c ====
--- /dev/null	2009-05-01 06:17:58.000000000 +0200
+++ binutils-2.19.91.20091006/ld/ldlex.c	2009-10-07 07:56:57.000000000 +0200
@@ -0,0 +1,4293 @@
+
+#line 3 "ldlex.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart(yyin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#define YY_BUF_SIZE 16384
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int yyleng;
+
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart (FILE *input_file  );
+void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
+void yy_delete_buffer (YY_BUFFER_STATE b  );
+void yy_flush_buffer (YY_BUFFER_STATE b  );
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state (void );
+
+static void yyensure_buffer_stack (void );
+static void yy_load_buffer_state (void );
+static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
+
+void *yyalloc (yy_size_t  );
+void *yyrealloc (void *,yy_size_t  );
+void yyfree (void *  );
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+typedef unsigned char YY_CHAR;
+
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int yylineno;
+
+int yylineno = 1;
+
+extern char *yytext;
+#define yytext_ptr yytext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	yyleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 192
+#define YY_END_OF_BUFFER 193
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[1617] =
+    {   0,
+        0,    0,  172,  172,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,  193,  192,
+      190,  175,  174,   32,  190,  172,   38,   29,   44,   43,
+       34,   35,   28,   36,  172,   37,    8,    8,   45,   46,
+       39,   40,   27,   33,  172,  172,  172,  172,  172,  172,
+      172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
+      172,  172,  172,  172,   10,    9,  172,  117,  115,  172,
+       42,   30,   41,   31,  191,  175,   32,  191,  170,   38,
+       29,   44,   43,   34,   35,   28,   36,  170,   37,    8,
+        8,   45,   46,   39,   40,   27,   33,  170,  170,  170,
+
+      170,  170,  170,  170,  170,  170,  170,  170,  170,  170,
+      170,  170,   10,    9,  170,  170,   42,   30,   41,   31,
+      168,   36,  168,   37,    8,    8,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  117,  115,  168,
+       31,    4,    3,    2,    4,    5,  129,  128,  167,   34,
+       35,   28,   36,  167,   37,    8,    8,   45,   46,   40,
+       33,  167,  167,  167,  167,  167,  167,  167,  167,  167,
+      167,  167,  167,   10,    9,  167,  167,  167,  167,  167,
+      167,  167,  167,  167,  167,  167,   31,  189,  187,  188,
+
+      190,  182,  181,  176,  183,  184,  180,  180,  180,  180,
+      185,  186,  175,   15,    0,  173,  172,    8,   26,   24,
+       22,   20,   21,    1,   23,    8,    8,  172,   18,   17,
+       14,   16,   19,  172,  172,  172,  172,  172,  121,  172,
+      172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
+      172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
+      172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
+      172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
+      172,  172,  172,  172,  172,  172,   25,   13,  170,    6,
+       22,   20,   21,    0,    1,   23,    8,    0,    7,    7,
+
+        8,    7,   14,  170,    7,    7,    7,  170,  170,  121,
+        7,  170,  170,  170,    7,  170,  170,  170,    7,  170,
+      170,  170,  170,  170,  170,  170,  170,  170,  170,  170,
+      170,  170,  170,  170,  170,  170,  170,    7,  170,  168,
+        8,    0,   23,    8,    0,  168,  168,  168,  168,  168,
+      121,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+
+      168,    4,    4,  128,  128,  167,    6,  130,   22,  131,
+      167,    7,    7,    7,  167,  167,  167,    7,  167,    7,
+        7,  167,  167,  167,  167,  167,  167,  167,  167,    7,
+      167,  167,  167,    7,  167,    7,    7,  167,  167,  167,
+      167,  167,  167,  167,  167,  189,  188,  181,  180,    0,
+      180,  180,  180,   11,   12,  172,  172,  172,  172,  172,
+      172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
+      172,  172,  172,  172,  172,  172,  172,  172,   93,  172,
+      172,  172,  172,  172,  172,  172,  172,  172,   72,  172,
+      172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
+
+      172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
+      172,  172,  172,  172,  172,  172,  118,  116,  172,    8,
+      171,    8,  170,    7,  170,  170,  170,  170,  170,  170,
+      170,  170,  170,  170,  170,  170,  170,  170,  170,  170,
+      170,  170,   61,   62,  170,  170,  170,  170,  170,  170,
+      170,  170,  170,  170,  170,  170,  170,  170,    8,  169,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,   93,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,   72,   61,  168,   62,  168,  168,
+
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  118,  116,  168,    4,    8,
+      167,  167,  167,  167,  167,  132,  167,  167,  167,  167,
+      167,  167,  167,  167,  167,  167,  167,  167,  167,  167,
+      167,  149,  167,  167,  167,  167,  167,  167,  167,  167,
+      167,  167,  180,  180,  180,  172,   58,  172,  172,  172,
+      172,  172,   52,  172,  100,  172,  109,  172,  172,  172,
+      172,  172,  172,  172,   89,  172,  172,  172,  172,  110,
+      172,  172,  172,  125,  172,  172,   98,  172,   68,  172,
+
+      172,  172,  172,  172,  172,  172,  172,  172,   96,  172,
+      172,  172,  172,  172,  172,  106,  172,  172,  172,  172,
+      172,  172,  172,  172,  172,  170,   58,  170,  170,  170,
+       52,  170,  170,  170,  109,  170,  170,  170,  170,  170,
+      170,  110,  125,  170,  170,  170,   68,  170,  170,  170,
+      170,  170,  170,  170,  170,  170,  170,  170,  170,  168,
+       58,  168,  168,  168,  168,  168,   52,  168,  100,  168,
+      168,  109,  168,  168,  168,  168,  168,  168,  168,   89,
+      168,  168,  168,  168,  110,  168,  168,  168,  125,  168,
+      168,   98,  168,  168,   68,  168,  168,  168,  168,  168,
+
+      168,  168,  168,  168,   96,  168,  168,  168,  168,  168,
+      168,  106,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  167,  167,  167,  136,  144,  135,  167,  167,  146,
+      139,  142,  167,  167,  147,  167,  167,  167,  167,  167,
+      153,  161,  152,  167,  167,  164,  156,  159,  167,  167,
+      165,  167,  167,  180,  180,  180,  172,   87,   54,  172,
+      172,  172,   51,  172,  172,  172,  172,  108,   66,  172,
+      172,   95,  172,   78,  172,  172,   77,  172,  172,  172,
+      172,  172,  172,  172,  172,  172,  172,  172,  120,  172,
+      172,  172,  172,  172,   99,  172,  172,  172,   97,  172,
+
+      172,  172,  172,  172,  172,  172,  170,   54,  170,  170,
+       51,  170,  170,  170,  170,  108,  170,   78,  170,  170,
+      170,  170,  170,  170,  170,  170,  170,  170,  170,  170,
+      170,  170,  170,  170,  168,   87,   54,  168,  168,  168,
+       51,  168,  168,  168,  168,  168,  108,   66,  168,  168,
+       95,  168,   78,  168,  168,   77,  168,  168,  168,  168,
+      168,  168,  168,  168,  168,  168,  168,  168,  120,  168,
+      168,  168,  168,  168,   99,  168,  168,  168,   97,  168,
+      168,  168,  168,  168,  168,  168,  167,  137,  134,  167,
+      167,  146,  146,  141,  167,  145,  167,  167,  154,  151,
+
+      167,  167,  164,  164,  158,  167,  163,  167,  180,  180,
+      178,  172,  172,   65,  172,   88,  172,  172,  172,  172,
+      172,  172,   67,  172,  172,  172,   86,   53,  172,   47,
+      172,  172,  107,  172,   49,   76,  172,  172,  172,  172,
+      172,  172,   73,  172,  172,  172,  172,   94,   74,  172,
+      172,  172,  170,  170,   65,  170,   63,  170,  170,  170,
+      170,  170,   53,  170,  170,  170,  107,  170,   49,  170,
+      170,  170,   73,  170,  170,  170,  170,  168,  168,   65,
+      168,   88,   63,  168,  168,  168,  168,  168,  168,   67,
+      168,  168,  168,   86,   53,  168,   47,  168,  168,  168,
+
+      107,  168,   49,   76,  168,  168,  168,  168,  168,  168,
+       73,  168,  168,  168,  168,   94,   74,  168,  168,  168,
+      167,  167,   67,  143,  140,  167,  167,  167,  162,  160,
+      157,  167,  179,  177,  172,   60,  172,  172,  172,  172,
+      172,   80,  172,  172,  119,  172,  172,  172,  101,  172,
+      172,  103,  123,  172,  172,  172,  172,  172,  172,  114,
+       90,  172,   50,  172,  172,  170,   60,  170,  170,  170,
+       80,  170,  119,  170,  170,  170,  170,  111,  123,  170,
+      170,  114,  170,  170,  170,  168,   60,  168,  168,  168,
+      168,  168,   80,  168,  168,  119,  168,  168,  168,  168,
+
+      101,  168,  168,  103,  123,  168,  168,  168,  168,  168,
+      168,  114,   90,  168,   50,  168,  168,  167,  167,  167,
+      167,  167,  167,  148,  172,  127,  172,  172,  172,  172,
+      172,  172,   59,  172,  172,  172,  172,  172,  172,  172,
+       85,  172,  172,  172,  122,  166,  172,  148,  170,  127,
+      170,  170,   59,  170,  170,  170,  170,  170,  170,  122,
+      166,  170,  148,  168,  127,  168,  168,  168,  168,  168,
+      168,   59,  168,  168,  168,  168,  168,  168,  168,  168,
+       85,  168,  168,  168,  122,  166,  168,  148,  133,  138,
+      166,  150,  155,   79,  172,  172,  172,  172,  172,  172,
+
+      172,  172,  172,  172,  172,  172,  172,  172,  172,  172,
+      172,  172,   79,  170,  170,   64,  170,  170,  170,  170,
+      170,  170,   79,  168,  168,  168,  168,  168,  168,   64,
+      168,  168,  168,  168,  168,  168,  168,  168,  168,  168,
+      168,  168,  172,  172,  172,  172,  172,  172,  172,  112,
+      113,  172,  172,  172,  172,   75,  172,  172,  172,  172,
+      172,  170,  170,  170,  112,  113,  170,  170,  170,  170,
+      168,  168,  168,  168,  168,  168,  168,  112,  113,  168,
+      168,  168,  168,   75,  168,  168,  168,  168,  168,  172,
+      172,  172,  172,  172,  172,  102,   92,  172,  172,  172,
+
+      172,  172,  172,  172,  172,  170,  170,  102,  170,  170,
+      170,  170,  168,  168,  168,  168,  168,  168,  102,   92,
+      168,  168,  168,  168,  168,  168,  168,  168,   82,  172,
+      172,  126,  172,  172,  172,  172,   48,  172,  172,  172,
+      104,  172,  170,  126,  170,  170,  170,  170,   82,  168,
+      168,  126,  168,  168,  168,  168,   48,  168,  168,  168,
+      104,  168,  172,  172,  172,  172,   91,  172,   71,  172,
+      172,  172,  170,  170,   71,  170,  170,  168,  168,  168,
+      168,   91,  168,   71,  168,  168,  168,  172,  172,  172,
+      172,  172,  172,  124,   70,  172,   69,  170,  170,  170,
+
+      124,   70,   69,  168,  168,  168,  168,  168,  168,  124,
+       70,  168,   69,  172,  172,  172,  172,  172,  172,  172,
+      170,  170,  170,  168,  168,  168,  168,  168,  168,  168,
+      172,  172,   57,  172,  172,  172,  172,  170,   57,  170,
+      168,  168,   57,  168,  168,  168,  168,  172,  172,  172,
+      172,  172,  105,  170,  170,  168,  168,  168,  168,  168,
+      105,  172,   55,  172,  172,  172,   55,  170,  168,   55,
+      168,  168,  168,  172,  172,  172,  172,  170,  168,  168,
+      168,  168,  172,  172,  172,  172,  170,  168,  168,  168,
+      168,   81,  172,  172,  172,  170,   81,  168,  168,  168,
+
+       56,  172,  172,   56,   56,  168,  168,   83,  172,   83,
+      168,  172,  168,   84,   84,    0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    4,    5,    6,    7,    8,    9,    1,   10,
+       11,   12,   13,   14,   15,   16,   17,   18,   19,   20,
+       19,   19,   19,   19,   19,   19,   19,   21,   22,   23,
+       24,   25,   26,    1,   27,   28,   29,   30,   31,   32,
+       33,   34,   35,   36,   37,   38,   39,   40,   41,   42,
+       43,   44,   45,   46,   47,   48,   49,   50,   51,   52,
+       53,   54,   55,   56,   57,    1,   58,   59,   60,   61,
+
+       62,   63,   64,   65,   66,   16,   67,   68,   69,   70,
+       71,   72,   16,   73,   74,   75,   76,   16,   16,   77,
+       16,   78,   79,   80,   81,   82,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[83] =
+    {   0,
+        1,    1,    2,    3,    1,    1,    4,    1,    1,    1,
+        1,    5,    6,    7,    8,    9,   10,   11,   11,   11,
+        8,    1,    1,    7,    1,    5,   11,   11,   11,   11,
+       11,   11,    9,    9,    9,    9,    9,    9,    9,    9,
+        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
+        9,    9,    8,    4,    8,    3,    9,   11,   11,   11,
+       11,   11,   11,    9,    9,    9,    9,    9,    9,    9,
+        9,    9,    9,    9,    9,    9,    9,    9,    1,    1,
+        1,   10
+    } ;
+
+static yyconst flex_int16_t yy_base[1641] =
+    {   0,
+        0,    0,    0,    0,   82,    0,  164,    0,  246,  327,
+      408,    0,  275,  277,  490,  572,  654,  736, 2610, 2611,
+     2611, 2607, 2611, 2584, 2602,  801, 2611,  264, 2611, 2611,
+     2582, 2581,    0, 2580,    0,  250,  581,  499,    0, 2611,
+      252, 2579,  260,    0,  259,  255,  254,  269,  263,  274,
+     2558, 2563, 2560, 2568,  276,  289,  277,  315,  277, 2551,
+     2566,  326, 2569, 2564,    0,    0, 2535, 2531, 2519, 2525,
+     2611,  239, 2611,    0, 2611, 2588, 2565, 2583,  847, 2611,
+      334, 2611, 2611, 2563, 2562, 2611,  298,    0,  352,  893,
+      294, 2611, 2611,  300, 2561,  350, 2611,  953,  351,  357,
+
+      494,  503,  576, 2540, 2543, 2551,  353,  343,  496,  486,
+     2537,  516, 2611, 2611,  652, 2514, 2611,  482, 2611,    0,
+     1013,  496,    0,  380,  745,  757,  655,  572,  511,  534,
+      350,  519, 2535, 2540, 2537, 2545,  360,  578,  588,  590,
+      568, 2528, 2543,  661, 2546, 2541, 2512, 2508, 2496, 2502,
+        0, 1059, 2611, 2611,    0, 2611, 2611, 2564, 1105, 2542,
+     2541, 2611, 2540,    0, 2539,    0,  479, 2611,    0, 2538,
+     2611, 1151,  605,  608,  611,  677,  653,  358, 2534, 2516,
+     2512,  504, 2514, 2611, 2611,  661,  685,  734,  765,  681,
+      545, 2499, 2483, 2479,  704, 2481,    0, 2551, 2611,    0,
+
+     2540, 2611,    0, 2611, 2611, 2611, 2530,  567,  620,  546,
+     2611, 2611, 2548, 2611, 2544, 2611,    0, 1211, 2611, 2611,
+        0,    0,    0,    0,    0,  769,    0,  744, 2524, 2611,
+        0, 2611, 2523, 2501, 2515, 2498, 2508,  669,    0, 2510,
+     2501, 2499, 2493,  605, 2507, 2491, 2504, 2504, 2488,  640,
+     2495, 2491, 2487, 2489, 2491,  805, 2497, 2487,  740, 2484,
+     2486, 2474,  692, 2485, 2487, 2475, 2489, 2489, 2477, 2490,
+     2483,  741, 2474, 2462, 2469, 2481, 2464, 2483, 2481, 2463,
+     2463, 2462, 2431, 2434, 2439, 2424, 2611, 2611,    0, 1263,
+     2611, 2611, 2611,    0, 2611, 2611,  701,  864,    0, 2611,
+
+     2611,    0, 2611,  842,  929,  962,    0, 2466,  683,    0,
+      989, 2460, 2458, 1018,  729, 1009, 1064, 2467, 2468, 2455,
+      773, 2464, 2454, 2466, 2442, 2451, 2461, 2439,  632, 2450,
+     2452, 2455, 2444, 2451, 2431, 2451, 2453, 1021, 2402,    0,
+     1315,    0,    0,  878,    0, 2434, 2448, 2431, 2441,  728,
+        0, 2443, 2434, 2432, 2426, 2436,  767, 2439, 2423, 2436,
+     2436, 2420,  702, 2427, 2423, 2419, 2421, 2423,  811, 2429,
+     2419,  770,  799, 2419, 2417, 2427, 2405,  819, 2416, 2418,
+     2406, 2420, 2420, 2408, 2421, 2414,  825, 2405, 2393, 2400,
+     2412, 2395, 2414, 2412, 2394, 2394, 2393, 2362, 2365, 2370,
+
+     2355,    0, 1367, 2429, 2611,    0, 1419,    0,    0,    0,
+      763,  857,  843,    0, 2396,  890,  891, 2395, 2399, 2382,
+     2383, 2381, 2398, 2385, 2393, 2394, 2392, 2393, 2372,  866,
+     2352,  948,  951, 2351, 2355, 2340, 2341, 2339, 2354, 2342,
+     2349, 2350, 2348, 2349, 2330, 2403,    0,    0, 2383, 2382,
+      711,  802,  878, 2611, 2611, 2361, 2357, 2369, 2366, 2367,
+     2357, 2355, 2365, 2365, 2362, 2347, 2340, 2363, 2362, 2353,
+     2358, 2342, 2347, 2353, 2345, 2355, 2352, 2333,    0, 2341,
+     2337, 2342, 2329, 2344, 2332, 2340, 2342, 2338,    0, 2329,
+     2323, 2324, 2329, 2325, 2314, 2331, 2321, 2318, 2317, 2312,
+
+     2329, 2323, 2313, 2310, 2316, 2310, 2322, 2306, 2322, 2323,
+     2305, 2321, 2309, 2313, 2300, 2273,    0,    0, 2281,    0,
+        0,  926, 2301, 1055, 2308, 2309, 2299, 2308, 2308, 2298,
+     2290, 2283, 2306, 1110, 2303, 2293, 2283, 2291, 2287, 2285,
+     2293, 2295,    0,    0, 2286, 2277, 2278, 2280, 2269, 2286,
+     2274, 2269, 2277, 2284, 2285, 2286, 2241, 2249,    0,    0,
+     2269, 2265, 2277, 2274, 2275, 2265, 2263, 2273, 2273, 2270,
+     2262, 2254, 2247, 2270, 2269, 2260, 2265, 2249, 2254, 2260,
+     2252, 2262, 2259, 2240,    0, 2248, 2244, 2249, 2236, 2251,
+     2239, 2247, 2249, 2245,    0,    0, 2236,    0, 2238, 2229,
+
+     2230, 2235, 2231, 2220, 2237, 2227, 2224, 2223, 2218, 2235,
+     2229, 2219, 2216, 2222, 2216, 2228, 2212, 2228, 2229, 2211,
+     2227, 2215, 2219, 2206, 2179,    0,    0, 2187,    0,    0,
+     2207,  859, 2216, 2215, 2203,    0, 2213, 2204, 2196, 2211,
+     2209, 2208, 2200, 2191, 2192, 2195, 2163,  884, 2171, 2170,
+     2159,    0, 2168, 2160, 2153, 2166, 2164, 2163, 2156, 2148,
+     2149, 2151,  663,  834,  769, 2182,    0, 2175, 2178, 2173,
+     2185, 2171,    0, 2177,    0, 2167,    0, 2166, 2154, 2170,
+     2163, 2157, 2160, 2162,    0, 2159, 2173, 2161, 2155,    0,
+     2173, 2154, 2155,    0, 2152, 2170,    0, 2152,    0, 2154,
+
+     2153, 2166, 2135, 2156, 2143, 2151, 2143, 2152,    0, 2145,
+     2156, 2149, 2152, 2136, 2140, 2123, 2144, 2148, 2131, 2138,
+     2140, 2143, 2138, 2104, 2100, 2132,    0, 2129, 2124, 2136,
+        0, 2129, 2123, 2118,    0, 2106, 2122, 2115, 2113, 2117,
+     2111,    0,    0, 2111, 2129, 2098,    0, 2113, 2126, 2095,
+     2116, 2112, 2114, 2117, 2106, 2111, 2107, 2076, 2072, 2104,
+        0, 2097, 2100, 2095, 2107, 2093,    0, 2099,    0, 2093,
+     2088,    0, 2078, 2056, 2062, 2045, 2032, 2030, 2031,    0,
+     2026, 2038, 2026, 2016,    0, 2024, 1995, 1986,    0, 1978,
+     1995,    0, 1962, 1948,    0, 1963, 1962, 1968, 1932,  247,
+
+      263,  327,  360,  462,    0,  487,  530,  573,  593,  594,
+      625,  649,  675,  795,  798,  808,  833,  838,  854,  822,
+      820,  862,  871,  886,    0,    0,    0,  893,  912, 1488,
+        0,    0,  900,  911,    0,  903,  921,  893,  892,  898,
+        0,    0,    0,  896,  919, 1569,    0,    0,  905,  922,
+        0,  921,  937,  984,  980, 1000,  955,    0,  963,  960,
+      978,  979,    0, 1025,  989,  978,  995,    0,    0,  998,
+      989,    0,  979,    0, 1020, 1023,    0, 1014, 1027, 1032,
+     1014, 1025, 1053, 1051, 1047, 1044, 1051, 1071,    0, 1073,
+     1064, 1071, 1065, 1067,    0, 1076, 1083, 1085,    0, 1066,
+
+     1079, 1087, 1070, 1085, 1051, 1065, 1082, 1089, 1085, 1108,
+        0, 1121, 1115, 1098, 1113,    0, 1116,    0, 1117, 1115,
+     1120, 1112, 1107, 1123, 1119, 1117, 1131, 1129, 1120, 1129,
+     1135, 1137, 1097, 1111, 1128,    0, 1135, 1131, 1153, 1155,
+        0, 1167, 1161, 1159, 1146, 1162,    0,    0, 1164, 1155,
+        0, 1139,    0, 1167, 1163,    0, 1153, 1166, 1172, 1152,
+     1165, 1161, 1180, 1178, 1180, 1177, 1172, 1192,    0, 1190,
+     1181, 1189, 1183, 1185,    0, 1194, 1199, 1205,    0, 1186,
+     1199, 1207, 1190, 1196, 1168, 1182, 1199,    0, 1208, 1209,
+     1205,    0, 1650,    0, 1223,    0, 1226, 1178,    0, 1186,
+
+     1186, 1182,    0, 1731,    0, 1198,    0, 1201, 1239, 1240,
+     1241, 1217, 1232,    0, 1235,    0, 1226, 1220, 1211, 1244,
+     1246, 1246,    0, 1250, 1253, 1239,    0,    0, 1256,    0,
+     1242, 1242,    0, 1257,    0, 1239, 1246, 1267, 1242, 1244,
+     1263, 1258, 1248, 1255, 1269, 1268, 1278,    0,    0, 1272,
+     1238, 1257, 1269, 1284,    0, 1287,    0, 1278, 1288, 1290,
+     1296, 1297,    0, 1299, 1304, 1291,    0, 1305,    0, 1287,
+     1308, 1294, 1284, 1310, 1316, 1275, 1294, 1307, 1323,    0,
+     1326,    0,    0, 1317, 1311, 1302, 1329, 1331, 1331,    0,
+     1334, 1333, 1319,    0,    0, 1336,    0, 1340, 1323, 1323,
+
+        0, 1338,    0, 1314, 1321, 1348, 1323, 1324, 1343, 1342,
+     1332, 1339, 1353, 1350, 1360,    0,    0, 1360, 1326, 1345,
+     1357, 1364,    0,    0,    0, 1361, 1333, 1338,    0,    0,
+        0, 1335, 1390, 1391, 1382,    0, 1383, 1369, 1387, 1376,
+     1385,    0, 1362, 1379,    0, 1364, 1378, 1379,    0, 1367,
+     1408,    0, 1374, 1405, 1403, 1396, 1385, 1409, 1387,    0,
+        0, 1405,    0, 1390, 1388, 1423,    0, 1424, 1411, 1426,
+        0, 1403,    0, 1417, 1417, 1419, 1407,    0, 1408, 1409,
+     1433,    0, 1428, 1407, 1405, 1440,    0, 1441, 1427, 1445,
+     1434, 1443,    0, 1426, 1443,    0, 1428, 1443, 1446, 1451,
+
+        0, 1444, 1476,    0, 1447, 1478, 1476, 1462, 1452, 1481,
+     1459,    0,    0, 1477,    0, 1456, 1454, 1489, 1491, 1491,
+     1461, 1463, 1463,    0, 1496,    0, 1481, 1500, 1490, 1498,
+     1492, 1503,    0, 1502, 1490, 1491, 1495, 1503, 1500, 1504,
+        0, 1495, 1510, 1515,    0,    0, 1481,    0, 1515,    0,
+     1507, 1515,    0, 1511, 1518, 1506, 1517, 1507, 1522,    0,
+        0, 1492,    0, 1526,    0, 1511, 1530, 1520, 1528, 1522,
+     1533,    0, 1526, 1533, 1521, 1522, 1531, 1542, 1544, 1549,
+        0, 1540, 1555, 1560,    0,    0, 1526,    0,    0,    0,
+        0,    0,    0,    0, 1548, 1554, 1565, 1562, 1559, 1558,
+
+     1569, 1561, 1574, 1560, 1570, 1571, 1563, 1562, 1582, 1573,
+     1585, 1555,    0, 1583, 1580,    0, 1584, 1577, 1582, 1573,
+     1593, 1563,    0, 1581, 1587, 1593, 1592, 1589, 1588,    0,
+     1598, 1590, 1603, 1589, 1599, 1600, 1592, 1591, 1611, 1602,
+     1614, 1584, 1599, 1613, 1605, 1608, 1606, 1614, 1612,    0,
+        0, 1629, 1626, 1636, 1640,    0, 1641, 1639, 1635, 1632,
+     1616, 1638, 1641, 1635,    0,    0, 1651, 1655, 1653, 1623,
+     1641, 1655, 1647, 1650, 1648, 1651, 1646,    0,    0, 1658,
+     1654, 1664, 1668,    0, 1669, 1667, 1663, 1660, 1639, 1656,
+     1673, 1657, 1673, 1665, 1668,    0,    0, 1681, 1679, 1665,
+
+     1667, 1681, 1680, 1683, 1653, 1670, 1686,    0, 1688, 1675,
+     1689, 1659, 1677, 1694, 1678, 1694, 1686, 1688,    0,    0,
+     1701, 1704, 1693, 1700, 1715, 1714, 1717, 1687,    0, 1704,
+     1694,    0, 1695, 1717, 1713, 1729,    0, 1715, 1718, 1723,
+        0, 1691, 1708,    0, 1735, 1721, 1724, 1696,    0, 1724,
+     1714,    0, 1715, 1732, 1728, 1744,    0, 1730, 1733, 1738,
+        0, 1706, 1723, 1754, 1755, 1743,    0, 1744,    0, 1741,
+     1749, 1715, 1763, 1751,    0, 1747, 1719, 1738, 1769, 1770,
+     1759,    0, 1761,    0, 1757, 1764, 1730, 1760, 1768, 1768,
+     1778, 1776, 1758,    0,    0, 1785,    0, 1779, 1778, 1788,
+
+        0,    0,    0, 1775, 1783, 1782, 1792, 1786, 1768,    0,
+        0, 1795,    0, 1776, 1793, 1799, 1792, 1793, 1805, 1793,
+     1799, 1805, 1798, 1786, 1803, 1809, 1802, 1803, 1815, 1803,
+     1805, 1812,    0, 1802, 1806, 1810, 1803, 1817,    0, 1807,
+     1813, 1820,    0, 1810, 1814, 1818, 1811, 1830, 1819, 1819,
+     1832, 1824,    0, 1823, 1823, 1837, 1826, 1826, 1839, 1831,
+        0, 1829,    0, 1814, 1845, 1832,    0, 1817, 1834,    0,
+     1819, 1850, 1837, 1841, 1849, 1835, 1853, 1852, 1846, 1854,
+     1840, 1858, 1843, 1849, 1855, 1864, 1852, 1848, 1854, 1860,
+     1869,    0, 1867, 1857, 1853, 1870,    0, 1871, 1861, 1857,
+
+        0, 1864, 1870,    0,    0, 1866, 1872,    0, 1867,    0,
+     1868, 1870, 1871,    0,    0, 2611, 1911, 1922, 1933, 1944,
+     1955, 1966, 1974, 1982, 1990, 1998, 2009, 2017, 2028, 2039,
+     2050, 2053, 2062, 2070, 1976, 2078, 2089, 2100, 2111, 2122
+    } ;
+
+static yyconst flex_int16_t yy_def[1641] =
+    {   0,
+     1617, 1617, 1616,    3, 1616,    5, 1616,    7, 1618, 1618,
+     1616,   11, 1619, 1619, 1620, 1620, 1621, 1621, 1616, 1616,
+     1616, 1616, 1616, 1616, 1622, 1623, 1616, 1616, 1616, 1616,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1616,
+     1616, 1623, 1616, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1616, 1616, 1616, 1623, 1616, 1616, 1616, 1622, 1624, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1624, 1624, 1616,
+       90, 1616, 1616, 1616, 1616, 1616, 1616, 1624,   98,   98,
+
+       98,   98,   98, 1624, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1616, 1616,   98, 1624, 1616, 1616, 1616, 1624,
+     1625, 1616, 1625, 1625, 1616, 1616, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1626, 1616, 1616, 1626, 1616, 1616, 1627, 1628, 1629,
+     1616, 1616, 1616, 1628, 1628,   90,   90, 1616, 1630, 1616,
+     1616, 1628,  172,  172,  172,  172,  172, 1628, 1628, 1628,
+     1628, 1628, 1628, 1616, 1616,  172,  172,  172,  172,  172,
+     1628, 1628, 1628, 1628, 1628, 1628, 1628, 1616, 1616, 1631,
+
+     1616, 1616, 1632, 1616, 1616, 1616, 1633, 1633, 1633, 1633,
+     1616, 1616, 1616, 1616, 1622, 1616, 1623, 1623, 1616, 1616,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623,  218, 1616, 1616,
+     1623, 1616, 1616, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1616, 1616, 1624, 1624,
+     1616, 1616, 1616, 1634, 1616, 1616,   90,   90,  298, 1616,
+
+     1616, 1635, 1616,   98,   98,   98, 1624, 1624, 1624, 1624,
+       98, 1624, 1624,   98, 1624,   98,   98, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1624, 1624,   98, 1624, 1625,
+     1625, 1636, 1625, 1616, 1635, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+
+     1625, 1626, 1626, 1627, 1616, 1628, 1628, 1629, 1629, 1630,
+      172,  172,  172, 1628, 1628,  172,  172, 1628, 1628, 1628,
+     1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628,  172,
+     1628,  172,  172, 1628, 1628, 1628, 1628, 1628, 1628, 1628,
+     1628, 1628, 1628, 1628, 1628, 1616, 1631, 1632, 1633, 1616,
+     1633, 1633, 1633, 1616, 1616, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1624,
+     1634, 1635, 1624,   98, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624,   98, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1625, 1636,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1626, 1628,
+     1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628,
+     1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628,
+     1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628,
+     1628, 1628, 1633, 1633, 1633, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628, 1637,
+     1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628,
+     1628, 1628, 1628, 1628, 1628, 1638, 1628, 1628, 1628, 1628,
+     1628, 1628, 1628, 1633, 1633, 1633, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+
+     1623, 1623, 1623, 1623, 1623, 1623, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1628, 1628, 1628, 1628,
+     1628, 1639, 1637, 1628, 1628, 1628, 1628, 1628, 1628, 1628,
+
+     1628, 1628, 1640, 1638, 1628, 1628, 1628, 1628, 1633, 1633,
+     1633, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1624, 1624, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628, 1628,
+     1628, 1628, 1633, 1633, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1628, 1628, 1628,
+     1628, 1628, 1628, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1624, 1624, 1624,
+     1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1628, 1628, 1628,
+     1628, 1628, 1628, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624, 1624,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+
+     1623, 1623, 1623, 1623, 1623, 1624, 1624, 1624, 1624, 1624,
+     1624, 1624, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1624, 1624, 1624, 1624, 1624, 1624, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1623, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1623, 1623, 1624, 1624, 1624, 1624, 1624, 1625, 1625, 1625,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1624, 1624, 1624,
+
+     1624, 1624, 1624, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1625, 1625, 1625, 1623, 1623, 1623, 1623, 1623, 1623, 1623,
+     1624, 1624, 1624, 1625, 1625, 1625, 1625, 1625, 1625, 1625,
+     1623, 1623, 1623, 1623, 1623, 1623, 1623, 1624, 1624, 1624,
+     1625, 1625, 1625, 1625, 1625, 1625, 1625, 1623, 1623, 1623,
+     1623, 1623, 1623, 1624, 1624, 1625, 1625, 1625, 1625, 1625,
+     1625, 1623, 1623, 1623, 1623, 1623, 1624, 1624, 1625, 1625,
+     1625, 1625, 1625, 1623, 1623, 1623, 1623, 1624, 1625, 1625,
+     1625, 1625, 1623, 1623, 1623, 1623, 1624, 1625, 1625, 1625,
+     1625, 1623, 1623, 1623, 1623, 1624, 1625, 1625, 1625, 1625,
+
+     1623, 1623, 1623, 1624, 1625, 1625, 1625, 1623, 1623, 1625,
+     1625, 1623, 1625, 1623, 1625,    0, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616
+    } ;
+
+static yyconst flex_int16_t yy_nxt[2694] =
+    {   0,
+       21,   22,   23,   24,   25,   21,   26,   27,   28,   29,
+       30,   31,   32,   33,   34,   35,   36,   37,   38,   38,
+       39,   40,   41,   42,   43,   44,   45,   46,   47,   48,
+       49,   50,   51,   52,   53,   35,   54,   55,   56,   57,
+       58,   59,   60,   61,   62,   63,   35,   64,   35,   35,
+       35,   35,   65,   35,   66,   21,   35,   67,   35,   35,
+       35,   35,   35,   35,   35,   35,   35,   68,   35,   35,
+       69,   35,   35,   70,   35,   35,   35,   35,   71,   72,
+       73,   74,   75,   76,   23,   77,   78,   75,   79,   80,
+       81,   82,   83,   84,   85,   86,   87,   88,   89,   90,
+
+       91,   91,   92,   93,   94,   95,   96,   97,   98,   99,
+      100,  101,  102,  103,  104,   88,  105,   88,  106,  107,
+      108,  109,  110,  111,   88,   88,  112,   88,   88,   88,
+       88,   88,   88,   88,  113,   88,  114,   75,   88,  115,
+      103,  103,  103,  103,  103,   88,   88,   88,   88,   88,
+       88,   88,   88,   88,   88,  116,   88,   88,   88,   88,
+      117,  118,  119,  120,   75,   76,   23,   77,   78,   75,
+      121,   80,   81,   82,   83,   84,   85,   86,  122,  123,
+      124,  125,  126,  126,   92,   93,   94,   95,   96,   97,
+      127,  128,  129,  130,  131,  132,  133,  134,  135,  123,
+
+      136,  137,  138,  139,  140,  141,  142,  143,  144,  145,
+      123,  146,  123,  123,  123,  123,  113,  123,  114,   75,
+      123,  147,  123,  123,  123,  123,  123,  123,  123,  123,
+      123,  148,  123,  123,  149,  123,  123,  150,  123,  123,
+      123,  123,  117,  118,  119,  151,   75,   75,   20,   75,
+       75,   75,  152,   75,   75,   75,   75,   75,  153,   75,
+      154,  224,  287,  125,  126,  126,   75,   75,   75,  156,
+       75,   75,  219,  225,  229,  230,  198,  199,  198,  199,
+      200,  966,  200,  232,  233,  240,  234,  220,  235,  241,
+      236,  201,  242,  201,  244,  246,  237,  245,   75,  247,
+
+       75,   75,  249,  238,  239,  243,  258,  262,  251,  967,
+      268,  252,  250,  248,  253,  260,  259,  263,  288,  261,
+      269,  293,  229,  230,   75,   75,   75,   75,   75,   20,
+       75,   75,   75,  152,   75,   75,   75,   75,   75,  153,
+       75,  154,  219,  300,  125,  126,  126,   75,   75,   75,
+      156,   75,   75,  202,  264,  202,  272,  220,  265,  273,
+      274,  266,  267,  295,  968,  294,  275,  276,  277,  325,
+      300,  278,  279,  232,  233,  296,  280,  326,  311,   75,
+      311,   75,   75,  323,  311,  312,  311,  314,  313,  362,
+      371,  295,  422,  324,  289,  289,  289,  315,  423,  363,
+
+      372,  289,  289,  343,  969,   75,   75,   75,   21,   22,
+      157,   24,   21,  158,  159,   27,   28,   29,   30,  160,
+      161,  162,  163,  164,  165,  166,  167,  167,  168,  169,
+       41,  170,   43,  171,  172,  173,  174,  175,  176,  177,
+      164,  164,  164,  164,  164,  178,  164,  179,  180,  181,
+      164,  164,  182,  183,  164,  164,  164,  164,  164,  164,
+      184,  164,  185,   21,  164,  186,  187,  188,  175,  189,
+      190,  164,  164,  164,  164,  191,  164,  192,  193,  194,
+      164,  195,  196,  164,  164,  164,   71,   72,   73,  197,
+       21,  198,  199,   21,   21,  200,  970,   21,   21,   21,
+
+       21,   21,   21,  204,   21,  287,  201,   21,   21,   21,
+      204,  204,   21,   21,   21,   21,  226,  226,  226,  293,
+      316,  311,  327,  311,  317,  330,  328,  971,  300,  331,
+      311,  289,  311,  332,  427,  227,  329,  227,  318,  289,
+      289,  356,   21,   21,   21,   21,  334,  289,  289,  428,
+      335,  357,  319,  364,  358,  300,  365,  336,  972,  366,
+      359,  288,  337,  342,  360,  227,  450,  227,  205,   21,
+      206,   21,   21,  198,  199,   21,   21,  200,  361,   21,
+       21,   21,   21,   21,   21,  204,   21,  450,  201,   21,
+       21,   21,  204,  204,   21,   21,   21,   21,  226,  226,
+
+      226,  383,  352,  311,  373,  311,  353,  973,  374,  354,
+      438,  384,  375,  289,  376,  439,  453,  227,  377,  227,
+      289,  289,  355,  974,   21,   21,   21,   21,  378,  379,
+      228,  416,  413,  380,  417,  413,  381,  382,  413,  975,
+      450,  418,  406,  451,  466,  406,  467,  227,  406,  227,
+      205,   21,  206,   21,   21,  198,  199,  228,   25,  200,
+      547,   21,   21,   21,   21,  976,   21,  204,  473,  548,
+      201,   21,   21,   21,  204,  204,   21,   21,   21,  311,
+      413,  311,  346,  450,  347,  474,  348,  452,  413,  289,
+      406,  387,  349,  421,  388,  389,  289,  289,  406,  350,
+
+      351,  390,  391,  392,  413,  977,  393,  394,  413,  978,
+      338,  395,  413,  460,  406,  208,  419,  209,  406,  430,
+      492,  210,  406,  493,  854,  461,  420,  526,  431,  494,
+      579,  450,  211,   21,  212,   21,   21,  198,  199,  527,
+       25,  200,  432,   21,   21,   21,   21,  580,   21,  204,
+      300,  437,  201,   21,   21,   21,  204,  204,   21,   21,
+       21,  413,  344,  344,  344,  443,  487,  503,  531,  504,
+      532,  406,  565,  505,  344,  344,  344,  300,  444,  488,
+      217,  301,  217,  301,  566,  663,  226,  226,  226,  450,
+      413,  433,  413,  301,  345,  301,  593,  208,  434,  209,
+
+      406,  538,  406,  210,  539,  227,  572,  227,  573,  594,
+      217,  301,  217,  301,  211,   21,  212,   21,  218,  218,
+      218,  345,  450,  301,  979,  301,  856,  218,  218,  218,
+      218,  218,  218,  480,  435,  227,  481,  227,  482,  586,
+      595,  436,  587,  980,  588,  981,  483,  601,  596,  484,
+      602,  612,  589,  613,  450,  590,  603,  614,  218,  218,
+      218,  218,  218,  218,  290,  290,  290,  982,  983,  311,
+      413,  311,  664,  290,  290,  290,  290,  290,  290,  289,
+      406,  298,  298,  298,  413,  823,  289,  289,  984,  985,
+      986,  824,  855,  413,  406,  344,  344,  344,  450,  987,
+
+     1616,  631, 1616,  406,  290,  290,  290,  290,  290,  290,
+      297,  297,  297,  300,  301,  988,  301,  413,  413,  298,
+      299,  298,  299,  298,  298,  989,  300,  406,  406,  301,
+     1616,  301, 1616,  300,  633,  634,  990,  665,  991,  647,
+      300,  839,  302,  994,  301,  995,  301,  840,  996,  997,
+      298,  299,  298,  299,  298,  298,  311,  300,  311,  301,
+      998,  301,  301,  300,  301,  999,  289, 1000, 1001,  302,
+      304,  304,  304,  523,  289,  413, 1002, 1005,  413,  304,
+      305,  304,  306,  304,  304,  406,  307, 1006,  406,  311,
+      308,  524,  301,  307,  301, 1007, 1008,  309,  310,  289,
+
+      450, 1012,  307, 1013,  450, 1014,  289,  289, 1015, 1016,
+      304,  311,  304,  311,  304,  304,  311,  307,  311, 1019,
+      450,  649, 1020,  307,  650, 1021,  289, 1022, 1023,  307,
+      341,  341,  341,  289,  289, 1024,  311, 1010,  311,  341,
+      341,  341,  341,  341,  341,  311,  289,  311,  311, 1025,
+      311, 1017,  530,  289,  533,  289, 1009, 1026,  289, 1027,
+     1028, 1029,  289,  289, 1030,  289,  289, 1011, 1018, 1031,
+      341,  341,  341,  341,  341,  341,  403,  403,  403, 1032,
+     1033, 1034,  311, 1035,  311,  403,  403,  403,  403,  403,
+      403,  311,  289,  311,  557,  534, 1036, 1037,  727,  289,
+
+      289,  289, 1038, 1039, 1040, 1041, 1042, 1043,  289,  289,
+     1044, 1045, 1046, 1047, 1048, 1049,  403,  403,  403,  403,
+      403,  403,  407,  407,  407, 1050, 1051, 1052, 1053, 1054,
+     1055,  407,  407,  407,  407,  407,  407,  311, 1056,  311,
+     1057, 1058, 1059, 1060,  737, 1061, 1062,  289, 1063, 1064,
+     1065, 1066, 1067, 1068,  289,  289, 1069, 1070, 1071, 1072,
+     1073, 1074,  407,  407,  407,  407,  407,  407,  411,  411,
+      411, 1075, 1076, 1077, 1078, 1079, 1080,  411,  412,  411,
+      413,  411,  411, 1081,  414, 1082, 1083, 1084,  415, 1086,
+     1087,  414, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095,
+
+      414, 1096, 1097, 1098, 1085, 1099, 1100, 1101,  411,  413,
+      411,  413,  411,  411, 1102,  414, 1103, 1104, 1105, 1106,
+     1107,  414, 1108, 1109, 1110, 1111, 1112,  414,  218,  218,
+      218, 1113, 1114, 1115, 1116, 1117, 1118,  218,  218,  218,
+      218,  218,  218, 1119, 1120, 1121, 1122,  227, 1123,  227,
+     1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132,  450,
+      450,  450, 1135, 1136, 1137, 1138, 1139, 1140,  218,  218,
+      218,  218,  218,  218, 1141, 1142, 1143,  227, 1144,  227,
+      290,  290,  290, 1145, 1146, 1147, 1148, 1149, 1150,  290,
+      290,  290,  290,  290,  290, 1151, 1152, 1153, 1154,  520,
+
+     1155,  520, 1156, 1157, 1158, 1159, 1160, 1134, 1133, 1161,
+     1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171,
+      290,  290,  290,  290,  290,  290, 1172, 1173, 1174,  520,
+     1175,  520,  341,  341,  341, 1176, 1177, 1178, 1179, 1180,
+     1181,  341,  341,  341,  341,  341,  341, 1182, 1183, 1184,
+     1185,  559, 1186,  559, 1187, 1188, 1189, 1190, 1191, 1192,
+     1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202,
+     1203, 1204,  341,  341,  341,  341,  341,  341, 1205, 1206,
+     1207,  559, 1208,  559,  403,  403,  403, 1209, 1210, 1211,
+     1212, 1213, 1214,  403,  403,  403,  403,  403,  403, 1215,
+
+     1216, 1217, 1218,  629, 1219,  629, 1220, 1221, 1222, 1223,
+      450,  450, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231,
+     1232, 1233, 1234, 1235,  403,  403,  403,  403,  403,  403,
+     1238, 1239, 1240,  629, 1236,  629,  407,  407,  407, 1237,
+     1241, 1242, 1243, 1244, 1245,  407,  407,  407,  407,  407,
+      407, 1246, 1247, 1248, 1249,  630, 1250,  630, 1251, 1252,
+     1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262,
+     1263, 1264, 1265, 1266, 1267, 1268,  407,  407,  407,  407,
+      407,  407, 1269, 1270, 1271,  630, 1272,  630,  992,  992,
+     1273,  992,  992,  992, 1274,  992,  992,  992,  992,  992,
+
+     1275,  992, 1276, 1278, 1279, 1280, 1281, 1277, 1282,  992,
+      992,  992,  992,  992, 1283, 1284, 1285, 1286, 1287, 1288,
+     1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298,
+     1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308,
+     1309, 1310, 1312,  992, 1313, 1314, 1315, 1316, 1317, 1318,
+     1319, 1320, 1321, 1322, 1311, 1323, 1324, 1325, 1326, 1327,
+     1328, 1329, 1330, 1331, 1332, 1333,  992,  992,  992, 1003,
+     1003, 1334, 1003, 1003, 1003, 1335, 1003, 1003, 1003, 1003,
+     1003, 1336, 1003, 1337, 1338, 1339, 1340, 1342, 1343, 1344,
+     1003, 1003, 1003, 1003, 1003, 1345, 1346, 1347, 1348, 1341,
+
+     1349, 1350, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1351,
+     1359, 1360, 1361, 1362, 1363, 1364, 1367, 1365, 1368, 1369,
+     1370, 1371, 1372, 1373, 1003, 1366, 1374, 1375, 1376, 1377,
+     1378, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1379, 1387,
+     1388, 1389, 1390, 1391, 1392, 1393, 1394, 1003, 1003, 1003,
+      992,  992, 1395,  992,  992,  992, 1396,  992,  992,  992,
+      992,  992, 1397,  992, 1398, 1399, 1400, 1401, 1402, 1403,
+     1404,  992,  992,  992,  992,  992, 1405, 1406, 1407, 1408,
+     1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418,
+     1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428,
+
+     1429, 1430, 1431, 1432, 1433,  992, 1434, 1435, 1436, 1437,
+     1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447,
+     1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455,  992,  992,
+      992, 1003, 1003, 1456, 1003, 1003, 1003, 1457, 1003, 1003,
+     1003, 1003, 1003, 1458, 1003, 1459, 1460, 1461, 1462, 1463,
+     1464, 1465, 1003, 1003, 1003, 1003, 1003, 1466, 1467, 1468,
+     1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478,
+     1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488,
+     1489, 1492, 1493, 1494, 1490, 1495, 1003, 1496, 1497, 1498,
+     1501, 1502, 1503, 1499, 1504, 1505, 1508, 1491, 1509, 1506,
+
+     1510, 1511, 1512, 1513, 1514, 1515, 1500, 1516, 1517, 1003,
+     1003, 1003, 1507, 1518, 1519, 1520, 1521, 1522, 1523, 1524,
+     1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534,
+     1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544,
+     1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554,
+     1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564,
+     1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574,
+     1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584,
+     1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594,
+     1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604,
+
+     1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614,
+     1615,   20,   20,   20,   20,   20,   20,   20,   20,   20,
+       20,   20,  155,  155,  155,  155,  155,  155,  155,  155,
+      155,  155,  155,   21,   21,   21,   21,   21,   21,   21,
+       21,   21,   21,   21,  203,  203,  203,  203,  203,  203,
+      203,  203,  203,  203,  203,  207,  207,  207,  207,  207,
+      207,  207,  207,  207,  207,  207,  215,  215,  215,  215,
+      215,  215,  215,  215,  215,  215,  215,  217,  217,  217,
+      217,  217,  217,  217,  217,  289,  522,  289,  965,  289,
+      289,  289,  289,  340,  964,  340,  340,  340,  340,  340,
+
+      340,  402,  963,  962,  961,  960,  402,  402,  402,  404,
+      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
+      406,  959,  406,  958,  406,  406,  406,  406,  408,  957,
+      408,  408,  408,  408,  408,  408,  408,  408,  408,  410,
+      956,  410,  410,  410,  410,  410,  410,  410,  410,  410,
+      447,  955,  447,  447,  447,  447,  447,  447,  447,  447,
+      447,  448,  954,  448,  449,  449,  449,  953,  952,  449,
+      449,  951,  449,  521,  950,  521,  949,  521,  521,  521,
+      521,  560,  948,  560,  560,  560,  560,  560,  560,  993,
+      947,  993,  993,  993,  993,  993,  993,  993,  993,  993,
+
+     1004,  946, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004,
+     1004,  992,  945,  992,  992,  992,  992,  992,  992,  992,
+      992,  992, 1003,  944, 1003, 1003, 1003, 1003, 1003, 1003,
+     1003, 1003, 1003,  943,  942,  941,  940,  939,  938,  937,
+      936,  935,  934,  933,  932,  931,  930,  929,  928,  927,
+      926,  925,  924,  923,  922,  921,  920,  919,  918,  917,
+      916,  915,  914,  913,  912,  911,  910,  909,  908,  907,
+      906,  905,  904,  903,  902,  901,  900,  899,  898,  897,
+      896,  895,  894,  893,  892,  891,  890,  889,  888,  887,
+      886,  885,  884,  883,  882,  881,  880,  879,  878,  877,
+
+      876,  875,  874,  873,  872,  871,  870,  869,  868,  867,
+      866,  865,  864,  863,  862,  861,  860,  859,  858,  857,
+      853,  852,  851,  850,  849,  848,  847,  846,  845,  844,
+      843,  842,  841,  838,  837,  836,  835,  834,  833,  832,
+      831,  830,  829,  828,  827,  826,  825,  822,  821,  820,
+      819,  818,  817,  816,  815,  814,  813,  812,  811,  810,
+      809,  808,  807,  806,  805,  804,  803,  802,  801,  800,
+      799,  798,  797,  796,  795,  794,  793,  792,  791,  790,
+      789,  788,  787,  786,  785,  784,  783,  782,  781,  780,
+      779,  778,  777,  776,  775,  774,  773,  772,  771,  770,
+
+      769,  768,  767,  766,  765,  764,  763,  762,  761,  760,
+      759,  758,  757,  756,  755,  754,  753,  752,  751,  750,
+      749,  748,  747,  746,  745,  744,  743,  742,  741,  740,
+      739,  738,  736,  735,  734,  733,  732,  731,  730,  729,
+      728,  726,  725,  724,  723,  722,  721,  720,  719,  718,
+      717,  716,  715,  714,  713,  712,  711,  710,  709,  708,
+      707,  706,  705,  704,  703,  702,  701,  700,  699,  698,
+      697,  696,  695,  694,  693,  692,  691,  690,  689,  688,
+      687,  686,  685,  684,  683,  682,  681,  680,  679,  678,
+      677,  676,  675,  674,  673,  672,  671,  670,  669,  668,
+
+      667,  666,  449,  450,  446,  662,  661,  660,  659,  658,
+      657,  656,  655,  654,  653,  652,  651,  648,  646,  645,
+      644,  643,  642,  641,  640,  639,  638,  637,  636,  635,
+      632,  405,  628,  627,  626,  625,  624,  623,  622,  621,
+      620,  619,  618,  617,  616,  615,  611,  610,  609,  608,
+      607,  606,  605,  604,  600,  599,  598,  597,  592,  591,
+      585,  584,  583,  582,  581,  578,  577,  576,  575,  574,
+      571,  570,  569,  568,  567,  564,  563,  562,  561,  558,
+      556,  555,  554,  553,  552,  551,  550,  549,  546,  545,
+      544,  543,  542,  541,  540,  537,  536,  535,  529,  528,
+
+      525,  519,  518,  517,  516,  515,  514,  513,  512,  511,
+      510,  509,  508,  507,  506,  502,  501,  500,  499,  498,
+      497,  496,  495,  491,  490,  489,  486,  485,  479,  478,
+      477,  476,  475,  472,  471,  470,  469,  468,  465,  464,
+      463,  462,  459,  458,  457,  456,  455,  454,  216,  213,
+      450,  295,  446,  445,  442,  441,  440,  429,  426,  425,
+      424,  303,  296,  293,  292,  409,  405,  401,  400,  399,
+      398,  397,  396,  386,  385,  370,  369,  368,  367,  339,
+      333,  322,  321,  320,  303,  292,  291,  216,  214,  213,
+      286,  285,  284,  283,  282,  281,  271,  270,  257,  256,
+
+      255,  254,  231,  223,  222,  221,  216,  214,  213, 1616,
+       19, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616
+
+    } ;
+
+static yyconst flex_int16_t yy_chk[2694] =
+    {   0,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    5,    5,    5,    5,    5,    5,    5,    5,
+        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+
+        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+        5,    5,    5,    5,    7,    7,    7,    7,    7,    7,
+        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
+        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
+        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
+
+        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
+        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
+        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
+        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
+        7,    7,    7,    7,    7,    7,    9,    9,    9,    9,
+        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
+        9,   36,   72,    9,    9,    9,    9,    9,    9,    9,
+        9,    9,   28,   36,   41,   41,   13,   13,   14,   14,
+       13,  800,   14,   43,   43,   46,   45,   28,   45,   46,
+       45,   13,   46,   14,   47,   48,   45,   47,    9,   48,
+
+        9,    9,   49,   45,   45,   46,   55,   57,   50,  801,
+       59,   50,   49,   48,   50,   56,   55,   57,   72,   56,
+       59,   87,   94,   94,    9,    9,    9,   10,   10,   10,
+       10,   10,   10,   10,   10,   10,   10,   10,   10,   10,
+       10,   10,   81,   91,   10,   10,   10,   10,   10,   10,
+       10,   10,   10,   13,   58,   14,   62,   81,   58,   62,
+       62,   58,   58,   89,  802,   87,   62,   62,   62,  108,
+       91,   62,   62,   96,   96,   89,   62,  108,   99,   10,
+       99,   10,   10,  107,  100,   99,  100,  100,   99,  131,
+      137,  124,  178,  107,  100,   99,   99,  100,  178,  131,
+
+      137,  100,  100,  124,  803,   10,   10,   10,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
+       15,   15,   15,   15,   15,   15,  804,   15,   15,   15,
+
+       15,   15,   15,   15,   15,  118,   15,   15,   15,   15,
+       15,   15,   15,   15,   15,   15,   38,   38,   38,  122,
+      101,  101,  109,  101,  101,  110,  109,  806,  167,  110,
+      102,  101,  102,  110,  182,   38,  109,   38,  101,  101,
+      102,  129,   15,   15,   15,   15,  112,  102,  102,  182,
+      112,  129,  102,  132,  129,  167,  132,  112,  807,  132,
+      130,  118,  112,  122,  130,   38,  210,   38,   15,   15,
+       15,   15,   16,   16,   16,   16,   16,   16,  130,   16,
+       16,   16,   16,   16,   16,   16,   16,  208,   16,   16,
+       16,   16,   16,   16,   16,   16,   16,   16,   37,   37,
+
+       37,  141,  128,  103,  138,  103,  128,  808,  138,  128,
+      191,  141,  138,  103,  139,  191,  210,   37,  139,   37,
+      103,  103,  128,  809,   16,   16,   16,   16,  139,  140,
+       37,  173,  173,  140,  174,  174,  140,  140,  175,  810,
+      209,  174,  173,  208,  244,  174,  244,   37,  175,   37,
+       16,   16,   16,   16,   17,   17,   17,   37,   17,   17,
+      329,   17,   17,   17,   17,  811,   17,   17,  250,  329,
+       17,   17,   17,   17,   17,   17,   17,   17,   17,  115,
+      177,  115,  127,  663,  127,  250,  127,  209,  186,  115,
+      177,  144,  127,  177,  144,  144,  115,  115,  186,  127,
+
+      127,  144,  144,  144,  176,  812,  144,  144,  190,  813,
+      115,  144,  187,  238,  176,   17,  176,   17,  190,  186,
+      263,   17,  187,  263,  663,  238,  176,  309,  186,  263,
+      363,  451,   17,   17,   17,   17,   18,   18,   18,  309,
+       18,   18,  187,   18,   18,   18,   18,  363,   18,   18,
+      297,  190,   18,   18,   18,   18,   18,   18,   18,   18,
+       18,  188,  125,  125,  125,  195,  259,  272,  315,  272,
+      315,  188,  350,  272,  126,  126,  126,  297,  195,  259,
+      228,  125,  228,  125,  350,  451,  226,  226,  226,  665,
+      411,  188,  189,  126,  125,  126,  372,   18,  188,   18,
+
+      411,  321,  189,   18,  321,  226,  357,  226,  357,  372,
+      228,  125,  228,  125,   18,   18,   18,   18,   26,   26,
+       26,  125,  452,  126,  814,  126,  665,   26,   26,   26,
+       26,   26,   26,  256,  189,  226,  256,  226,  256,  369,
+      373,  189,  369,  815,  369,  816,  256,  378,  373,  256,
+      378,  387,  369,  387,  664,  369,  378,  387,   26,   26,
+       26,   26,   26,   26,   79,   79,   79,  817,  818,  304,
+      413,  304,  452,   79,   79,   79,   79,   79,   79,  304,
+      413,  298,  298,  298,  412,  632,  304,  304,  819,  820,
+      821,  632,  664,  430,  412,  344,  344,  344,  453,  822,
+
+      298,  412,  298,  430,   79,   79,   79,   79,   79,   79,
+       90,   90,   90,  298,  344,  823,  344,  416,  417,   90,
+       90,   90,   90,   90,   90,  824,   90,  416,  417,   90,
+      298,   90,  298,   90,  416,  417,  828,  453,  829,  430,
+      298,  648,   90,  833,  344,  834,  344,  648,  836,  837,
+       90,   90,   90,   90,   90,   90,  305,   90,  305,   90,
+      838,   90,  522,   90,  522,  839,  305,  840,  844,   90,
+       98,   98,   98,  305,  305,  432,  845,  849,  433,   98,
+       98,   98,   98,   98,   98,  432,   98,  850,  433,  306,
+       98,  306,  522,   98,  522,  852,  853,   98,   98,  306,
+
+      855,  857,   98,  859,  854,  860,  306,  306,  861,  862,
+       98,   98,   98,   98,   98,   98,  311,   98,  311,  865,
+      856,  432,  866,   98,  433,  867,  311,  870,  871,   98,
+      121,  121,  121,  311,  311,  873,  316,  855,  316,  121,
+      121,  121,  121,  121,  121,  314,  316,  314,  338,  875,
+      338,  864,  314,  316,  316,  314,  854,  876,  338,  878,
+      879,  880,  314,  314,  881,  338,  338,  856,  864,  882,
+      121,  121,  121,  121,  121,  121,  152,  152,  152,  883,
+      884,  885,  524,  886,  524,  152,  152,  152,  152,  152,
+      152,  317,  524,  317,  338,  317,  887,  888,  524,  524,
+
+      524,  317,  890,  891,  892,  893,  894,  896,  317,  317,
+      897,  898,  900,  901,  902,  903,  152,  152,  152,  152,
+      152,  152,  159,  159,  159,  904,  905,  906,  907,  908,
+      909,  159,  159,  159,  159,  159,  159,  534,  910,  534,
+      912,  913,  914,  915,  534,  917,  919,  534,  920,  921,
+      922,  923,  924,  925,  534,  534,  926,  927,  928,  929,
+      930,  931,  159,  159,  159,  159,  159,  159,  172,  172,
+      172,  932,  933,  934,  935,  937,  938,  172,  172,  172,
+      172,  172,  172,  939,  172,  940,  942,  943,  172,  944,
+      945,  172,  946,  949,  950,  952,  954,  955,  957,  958,
+
+      172,  959,  960,  961,  943,  962,  963,  964,  172,  172,
+      172,  172,  172,  172,  965,  172,  966,  967,  968,  970,
+      971,  172,  972,  973,  974,  976,  977,  172,  218,  218,
+      218,  978,  980,  981,  982,  983,  984,  218,  218,  218,
+      218,  218,  218,  985,  986,  987,  989,  218,  990,  218,
+      991,  995,  997,  998, 1000, 1001, 1002, 1006, 1008, 1009,
+     1010, 1011, 1012, 1013, 1015, 1017, 1018, 1019,  218,  218,
+      218,  218,  218,  218, 1020, 1021, 1022,  218, 1024,  218,
+      290,  290,  290, 1025, 1026, 1029, 1031, 1032, 1034,  290,
+      290,  290,  290,  290,  290, 1036, 1037, 1038, 1039,  290,
+
+     1040,  290, 1041, 1042, 1043, 1044, 1045, 1010, 1009, 1046,
+     1047, 1050, 1051, 1052, 1053, 1054, 1056, 1058, 1059, 1060,
+      290,  290,  290,  290,  290,  290, 1061, 1062, 1064,  290,
+     1065,  290,  341,  341,  341, 1066, 1068, 1070, 1071, 1072,
+     1073,  341,  341,  341,  341,  341,  341, 1074, 1075, 1076,
+     1077,  341, 1078,  341, 1079, 1081, 1084, 1085, 1086, 1087,
+     1088, 1089, 1091, 1092, 1093, 1096, 1098, 1099, 1100, 1102,
+     1104, 1105,  341,  341,  341,  341,  341,  341, 1106, 1107,
+     1108,  341, 1109,  341,  403,  403,  403, 1110, 1111, 1112,
+     1113, 1114, 1115,  403,  403,  403,  403,  403,  403, 1118,
+
+     1119, 1120, 1121,  403, 1122,  403, 1126, 1127, 1128, 1132,
+     1133, 1134, 1135, 1137, 1138, 1139, 1140, 1141, 1143, 1144,
+     1146, 1147, 1148, 1150,  403,  403,  403,  403,  403,  403,
+     1153, 1154, 1155,  403, 1151,  403,  407,  407,  407, 1151,
+     1156, 1157, 1158, 1159, 1162,  407,  407,  407,  407,  407,
+      407, 1164, 1165, 1166, 1168,  407, 1169,  407, 1170, 1172,
+     1174, 1175, 1176, 1177, 1179, 1180, 1181, 1183, 1184, 1185,
+     1186, 1188, 1189, 1190, 1191, 1192,  407,  407,  407,  407,
+      407,  407, 1194, 1195, 1197,  407, 1198,  407,  830,  830,
+     1199,  830,  830,  830, 1200,  830,  830,  830,  830,  830,
+
+     1202,  830, 1203, 1205, 1206, 1207, 1208, 1203, 1209,  830,
+      830,  830,  830,  830, 1210, 1211, 1214, 1216, 1217, 1218,
+     1219, 1220, 1221, 1222, 1223, 1225, 1227, 1228, 1229, 1230,
+     1231, 1232, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1242,
+     1243, 1244, 1247,  830, 1249, 1251, 1252, 1254, 1255, 1256,
+     1257, 1258, 1259, 1262, 1244, 1264, 1266, 1267, 1268, 1269,
+     1270, 1271, 1273, 1274, 1275, 1276,  830,  830,  830,  846,
+      846, 1277,  846,  846,  846, 1278,  846,  846,  846,  846,
+      846, 1279,  846, 1280, 1282, 1283, 1284, 1287, 1295, 1296,
+      846,  846,  846,  846,  846, 1297, 1298, 1299, 1300, 1284,
+
+     1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1302,
+     1310, 1311, 1312, 1314, 1315, 1317, 1319, 1318, 1320, 1321,
+     1322, 1324, 1325, 1326,  846, 1318, 1327, 1328, 1329, 1331,
+     1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1332, 1340,
+     1341, 1342, 1343, 1344, 1345, 1346, 1347,  846,  846,  846,
+      993,  993, 1348,  993,  993,  993, 1349,  993,  993,  993,
+      993,  993, 1352,  993, 1353, 1354, 1355, 1357, 1358, 1359,
+     1360,  993,  993,  993,  993,  993, 1361, 1362, 1363, 1364,
+     1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376,
+     1377, 1380, 1381, 1382, 1383, 1385, 1386, 1387, 1388, 1389,
+
+     1390, 1391, 1392, 1393, 1394,  993, 1395, 1398, 1399, 1400,
+     1401, 1402, 1403, 1404, 1405, 1406, 1407, 1409, 1410, 1411,
+     1412, 1413, 1414, 1415, 1416, 1417, 1418, 1421,  993,  993,
+      993, 1004, 1004, 1422, 1004, 1004, 1004, 1423, 1004, 1004,
+     1004, 1004, 1004, 1424, 1004, 1425, 1426, 1427, 1428, 1430,
+     1431, 1433, 1004, 1004, 1004, 1004, 1004, 1434, 1435, 1436,
+     1438, 1439, 1440, 1442, 1443, 1445, 1446, 1447, 1448, 1450,
+     1451, 1453, 1454, 1455, 1456, 1458, 1459, 1460, 1462, 1463,
+     1464, 1465, 1466, 1468, 1464, 1470, 1004, 1471, 1472, 1473,
+     1474, 1476, 1477, 1473, 1478, 1479, 1480, 1464, 1481, 1479,
+
+     1483, 1485, 1486, 1487, 1488, 1489, 1473, 1490, 1491, 1004,
+     1004, 1004, 1479, 1492, 1493, 1496, 1498, 1499, 1500, 1504,
+     1505, 1506, 1507, 1508, 1509, 1512, 1514, 1515, 1516, 1517,
+     1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527,
+     1528, 1529, 1530, 1531, 1532, 1534, 1535, 1536, 1537, 1538,
+     1540, 1541, 1542, 1544, 1545, 1546, 1547, 1548, 1549, 1550,
+     1551, 1552, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1562,
+     1564, 1565, 1566, 1568, 1569, 1571, 1572, 1573, 1574, 1575,
+     1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585,
+     1586, 1587, 1588, 1589, 1590, 1591, 1593, 1594, 1595, 1596,
+
+     1598, 1599, 1600, 1602, 1603, 1606, 1607, 1609, 1611, 1612,
+     1613, 1617, 1617, 1617, 1617, 1617, 1617, 1617, 1617, 1617,
+     1617, 1617, 1618, 1618, 1618, 1618, 1618, 1618, 1618, 1618,
+     1618, 1618, 1618, 1619, 1619, 1619, 1619, 1619, 1619, 1619,
+     1619, 1619, 1619, 1619, 1620, 1620, 1620, 1620, 1620, 1620,
+     1620, 1620, 1620, 1620, 1620, 1621, 1621, 1621, 1621, 1621,
+     1621, 1621, 1621, 1621, 1621, 1621, 1622, 1622, 1622, 1622,
+     1622, 1622, 1622, 1622, 1622, 1622, 1622, 1623, 1623, 1623,
+     1623, 1623, 1623, 1623, 1623, 1624, 1635, 1624,  799, 1624,
+     1624, 1624, 1624, 1625,  798, 1625, 1625, 1625, 1625, 1625,
+
+     1625, 1626,  797,  796,  794,  793, 1626, 1626, 1626, 1627,
+     1627, 1627, 1627, 1627, 1627, 1627, 1627, 1627, 1627, 1627,
+     1628,  791, 1628,  790, 1628, 1628, 1628, 1628, 1629,  788,
+     1629, 1629, 1629, 1629, 1629, 1629, 1629, 1629, 1629, 1630,
+      787, 1630, 1630, 1630, 1630, 1630, 1630, 1630, 1630, 1630,
+     1631,  786, 1631, 1631, 1631, 1631, 1631, 1631, 1631, 1631,
+     1631, 1632,  784, 1632, 1633, 1633, 1633,  783,  782, 1633,
+     1633,  781, 1633, 1634,  779, 1634,  778, 1634, 1634, 1634,
+     1634, 1636,  777, 1636, 1636, 1636, 1636, 1636, 1636, 1637,
+      776, 1637, 1637, 1637, 1637, 1637, 1637, 1637, 1637, 1637,
+
+     1638,  775, 1638, 1638, 1638, 1638, 1638, 1638, 1638, 1638,
+     1638, 1639,  774, 1639, 1639, 1639, 1639, 1639, 1639, 1639,
+     1639, 1639, 1640,  773, 1640, 1640, 1640, 1640, 1640, 1640,
+     1640, 1640, 1640,  771,  770,  768,  766,  765,  764,  763,
+      762,  760,  759,  758,  757,  756,  755,  754,  753,  752,
+      751,  750,  749,  748,  746,  745,  744,  741,  740,  739,
+      738,  737,  736,  734,  733,  732,  730,  729,  728,  726,
+      725,  724,  723,  722,  721,  720,  719,  718,  717,  716,
+      715,  714,  713,  712,  711,  710,  708,  707,  706,  705,
+      704,  703,  702,  701,  700,  698,  696,  695,  693,  692,
+
+      691,  689,  688,  687,  686,  684,  683,  682,  681,  680,
+      679,  678,  676,  674,  672,  671,  670,  669,  668,  666,
+      662,  661,  660,  659,  658,  657,  656,  655,  654,  653,
+      651,  650,  649,  647,  646,  645,  644,  643,  642,  641,
+      640,  639,  638,  637,  635,  634,  633,  631,  628,  625,
+      624,  623,  622,  621,  620,  619,  618,  617,  616,  615,
+      614,  613,  612,  611,  610,  609,  608,  607,  606,  605,
+      604,  603,  602,  601,  600,  599,  597,  594,  593,  592,
+      591,  590,  589,  588,  587,  586,  584,  583,  582,  581,
+      580,  579,  578,  577,  576,  575,  574,  573,  572,  571,
+
+      570,  569,  568,  567,  566,  565,  564,  563,  562,  561,
+      558,  557,  556,  555,  554,  553,  552,  551,  550,  549,
+      548,  547,  546,  545,  542,  541,  540,  539,  538,  537,
+      536,  535,  533,  532,  531,  530,  529,  528,  527,  526,
+      525,  523,  519,  516,  515,  514,  513,  512,  511,  510,
+      509,  508,  507,  506,  505,  504,  503,  502,  501,  500,
+      499,  498,  497,  496,  495,  494,  493,  492,  491,  490,
+      488,  487,  486,  485,  484,  483,  482,  481,  480,  478,
+      477,  476,  475,  474,  473,  472,  471,  470,  469,  468,
+      467,  466,  465,  464,  463,  462,  461,  460,  459,  458,
+
+      457,  456,  450,  449,  446,  445,  444,  443,  442,  441,
+      440,  439,  438,  437,  436,  435,  434,  431,  429,  428,
+      427,  426,  425,  424,  423,  422,  421,  420,  419,  418,
+      415,  404,  401,  400,  399,  398,  397,  396,  395,  394,
+      393,  392,  391,  390,  389,  388,  386,  385,  384,  383,
+      382,  381,  380,  379,  377,  376,  375,  374,  371,  370,
+      368,  367,  366,  365,  364,  362,  361,  360,  359,  358,
+      356,  355,  354,  353,  352,  349,  348,  347,  346,  339,
+      337,  336,  335,  334,  333,  332,  331,  330,  328,  327,
+      326,  325,  324,  323,  322,  320,  319,  318,  313,  312,
+
+      308,  286,  285,  284,  283,  282,  281,  280,  279,  278,
+      277,  276,  275,  274,  273,  271,  270,  269,  268,  267,
+      266,  265,  264,  262,  261,  260,  258,  257,  255,  254,
+      253,  252,  251,  249,  248,  247,  246,  245,  243,  242,
+      241,  240,  237,  236,  235,  234,  233,  229,  215,  213,
+      207,  201,  198,  196,  194,  193,  192,  183,  181,  180,
+      179,  170,  165,  163,  161,  160,  158,  150,  149,  148,
+      147,  146,  145,  143,  142,  136,  135,  134,  133,  116,
+      111,  106,  105,  104,   95,   85,   84,   78,   77,   76,
+       70,   69,   68,   67,   64,   63,   61,   60,   54,   53,
+
+       52,   51,   42,   34,   32,   31,   25,   24,   22,   19,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616, 1616,
+     1616, 1616, 1616
+
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int yy_flex_debug;
+int yy_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "ldlex.l"
+#line 2 "ldlex.l"
+
+/* Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   Free Software Foundation, Inc.
+   Written by Steve Chamberlain of Cygnus Support.
+
+   This file is part of the GNU Binutils.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "safe-ctype.h"
+#include "bfdlink.h"
+#include "ld.h"
+#include "ldmisc.h"
+#include "ldexp.h"
+#include "ldlang.h"
+#include <ldgram.h>
+#include "ldfile.h"
+#include "ldlex.h"
+#include "ldmain.h"
+#include "libiberty.h"
+
+/* The type of top-level parser input.
+   yylex and yyparse (indirectly) both check this.  */
+input_type parser_input;
+
+/* Line number in the current input file.
+   (FIXME Actually, it doesn't appear to get reset for each file?)  */
+unsigned int lineno = 1;
+
+/* The string we are currently lexing, or NULL if we are reading a
+   file.  */
+const char *lex_string = NULL;
+
+/* Support for flex reading from more than one input file (stream).
+   `include_stack' is flex's input state for each open file;
+   `file_name_stack' is the file names.  `lineno_stack' is the current
+   line numbers.
+
+   If `include_stack_ptr' is 0, we haven't started reading anything yet.
+   Otherwise, stack elements 0 through `include_stack_ptr - 1' are valid.  */
+
+#undef YY_INPUT
+#define YY_INPUT(buf,result,max_size) yy_input (buf, &result, max_size)
+
+#define YY_NO_UNPUT
+
+#define MAX_INCLUDE_DEPTH 10
+static YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];
+static const char *file_name_stack[MAX_INCLUDE_DEPTH];
+static unsigned int lineno_stack[MAX_INCLUDE_DEPTH];
+static unsigned int include_stack_ptr = 0;
+static int vers_node_nesting = 0;
+
+static void yy_input (char *, int *, int);
+static void comment (void);
+static void lex_warn_invalid (char *where, char *what);
+
+/* STATES
+	EXPRESSION	definitely in an expression
+	SCRIPT		definitely in a script
+	BOTH		either EXPRESSION or SCRIPT
+	DEFSYMEXP	in an argument to -defsym
+        MRI             in an MRI script
+	VERS_START	starting a Sun style mapfile
+	VERS_SCRIPT	a Sun style mapfile
+	VERS_NODE	a node within a Sun style mapfile
+*/
+#define RTOKEN(x)  {  yylval.token = x; return x; }
+
+/* Some versions of flex want this.  */
+#ifndef yywrap
+int yywrap (void) { return 1; }
+#endif
+
+
+
+
+
+
+
+
+#line 1682 "ldlex.c"
+
+#define INITIAL 0
+#define SCRIPT 1
+#define EXPRESSION 2
+#define BOTH 3
+#define DEFSYMEXP 4
+#define MRI 5
+#define VERS_START 6
+#define VERS_SCRIPT 7
+#define VERS_NODE 8
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy (void );
+
+int yyget_debug (void );
+
+void yyset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE yyget_extra (void );
+
+void yyset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *yyget_in (void );
+
+void yyset_in  (FILE * in_str  );
+
+FILE *yyget_out (void );
+
+void yyset_out  (FILE * out_str  );
+
+int yyget_leng (void );
+
+char *yyget_text (void );
+
+int yyget_lineno (void );
+
+void yyset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap (void );
+#else
+extern int yywrap (void );
+#endif
+#endif
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO fwrite( yytext, yyleng, 1, yyout )
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		int n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 117 "ldlex.l"
+
+
+  if (parser_input != input_selected)
+    {
+      /* The first token of the input determines the initial parser state.  */
+      input_type t = parser_input;
+      parser_input = input_selected;
+      switch (t)
+	{
+	case input_script: return INPUT_SCRIPT; break;
+	case input_mri_script: return INPUT_MRI_SCRIPT; break;
+	case input_version_script: return INPUT_VERSION_SCRIPT; break;
+	case input_dynamic_list: return INPUT_DYNAMIC_LIST; break;
+	case input_defsym: return INPUT_DEFSYM; break;
+	default: abort ();
+	}
+    }
+
+#line 1891 "ldlex.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer(yyin,YY_BUF_SIZE );
+		}
+
+		yy_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of yytext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 1617 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 2611 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 135 "ldlex.l"
+{ comment (); }
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 138 "ldlex.l"
+{ RTOKEN('-');}
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 139 "ldlex.l"
+{ RTOKEN('+');}
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 140 "ldlex.l"
+{ yylval.name = xstrdup (yytext); return NAME; }
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 141 "ldlex.l"
+{ RTOKEN('='); }
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 143 "ldlex.l"
+{
+  				yylval.integer = bfd_scan_vma (yytext + 1, 0, 16);
+				yylval.bigint.str = NULL;
+				return INT;
+			}
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 149 "ldlex.l"
+{
+				   int ibase ;
+				   switch (yytext[yyleng - 1]) {
+				    case 'X':
+				    case 'x':
+				    case 'H':
+				    case 'h':
+				     ibase = 16;
+				     break;
+				    case 'O':
+				    case 'o':
+				     ibase = 8;
+				     break;
+				    case 'B':
+				    case 'b':
+				     ibase = 2;
+				     break;
+				    default:
+				     ibase = 10;
+				   }
+				   yylval.integer = bfd_scan_vma (yytext, 0,
+								  ibase);
+				   yylval.bigint.str = NULL;
+				   return INT;
+				 }
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 174 "ldlex.l"
+{
+				  char *s = yytext;
+				  int ibase = 0;
+
+				  if (*s == '$')
+				    {
+				      ++s;
+				      ibase = 16;
+				    }
+				  yylval.integer = bfd_scan_vma (s, 0, ibase);
+				  yylval.bigint.str = NULL;
+				  if (yytext[yyleng - 1] == 'M'
+				      || yytext[yyleng - 1] == 'm')
+				    {
+				      yylval.integer *= 1024 * 1024;
+				    }
+				  else if (yytext[yyleng - 1] == 'K'
+				      || yytext[yyleng - 1]=='k')
+				    {
+				      yylval.integer *= 1024;
+				    }
+				  else if (yytext[0] == '0'
+					   && (yytext[1] == 'x'
+					       || yytext[1] == 'X'))
+				    {
+				      yylval.bigint.str = xstrdup (yytext + 2);
+				    }
+				  return INT;
+				}
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 203 "ldlex.l"
+{ RTOKEN(']');}
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 204 "ldlex.l"
+{ RTOKEN('[');}
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 205 "ldlex.l"
+{ RTOKEN(LSHIFTEQ);}
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 206 "ldlex.l"
+{ RTOKEN(RSHIFTEQ);}
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 207 "ldlex.l"
+{ RTOKEN(OROR);}
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 208 "ldlex.l"
+{ RTOKEN(EQ);}
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 209 "ldlex.l"
+{ RTOKEN(NE);}
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 210 "ldlex.l"
+{ RTOKEN(GE);}
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 211 "ldlex.l"
+{ RTOKEN(LE);}
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 212 "ldlex.l"
+{ RTOKEN(LSHIFT);}
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 213 "ldlex.l"
+{ RTOKEN(RSHIFT);}
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 214 "ldlex.l"
+{ RTOKEN(PLUSEQ);}
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+#line 215 "ldlex.l"
+{ RTOKEN(MINUSEQ);}
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+#line 216 "ldlex.l"
+{ RTOKEN(MULTEQ);}
+	YY_BREAK
+case 23:
+YY_RULE_SETUP
+#line 217 "ldlex.l"
+{ RTOKEN(DIVEQ);}
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+#line 218 "ldlex.l"
+{ RTOKEN(ANDEQ);}
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+#line 219 "ldlex.l"
+{ RTOKEN(OREQ);}
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+#line 220 "ldlex.l"
+{ RTOKEN(ANDAND);}
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+#line 221 "ldlex.l"
+{ RTOKEN('>');}
+	YY_BREAK
+case 28:
+YY_RULE_SETUP
+#line 222 "ldlex.l"
+{ RTOKEN(',');}
+	YY_BREAK
+case 29:
+YY_RULE_SETUP
+#line 223 "ldlex.l"
+{ RTOKEN('&');}
+	YY_BREAK
+case 30:
+YY_RULE_SETUP
+#line 224 "ldlex.l"
+{ RTOKEN('|');}
+	YY_BREAK
+case 31:
+YY_RULE_SETUP
+#line 225 "ldlex.l"
+{ RTOKEN('~');}
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+#line 226 "ldlex.l"
+{ RTOKEN('!');}
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+#line 227 "ldlex.l"
+{ RTOKEN('?');}
+	YY_BREAK
+case 34:
+YY_RULE_SETUP
+#line 228 "ldlex.l"
+{ RTOKEN('*');}
+	YY_BREAK
+case 35:
+YY_RULE_SETUP
+#line 229 "ldlex.l"
+{ RTOKEN('+');}
+	YY_BREAK
+case 36:
+YY_RULE_SETUP
+#line 230 "ldlex.l"
+{ RTOKEN('-');}
+	YY_BREAK
+case 37:
+YY_RULE_SETUP
+#line 231 "ldlex.l"
+{ RTOKEN('/');}
+	YY_BREAK
+case 38:
+YY_RULE_SETUP
+#line 232 "ldlex.l"
+{ RTOKEN('%');}
+	YY_BREAK
+case 39:
+YY_RULE_SETUP
+#line 233 "ldlex.l"
+{ RTOKEN('<');}
+	YY_BREAK
+case 40:
+YY_RULE_SETUP
+#line 234 "ldlex.l"
+{ RTOKEN('=');}
+	YY_BREAK
+case 41:
+YY_RULE_SETUP
+#line 235 "ldlex.l"
+{ RTOKEN('}') ; }
+	YY_BREAK
+case 42:
+YY_RULE_SETUP
+#line 236 "ldlex.l"
+{ RTOKEN('{'); }
+	YY_BREAK
+case 43:
+YY_RULE_SETUP
+#line 237 "ldlex.l"
+{ RTOKEN(')');}
+	YY_BREAK
+case 44:
+YY_RULE_SETUP
+#line 238 "ldlex.l"
+{ RTOKEN('(');}
+	YY_BREAK
+case 45:
+YY_RULE_SETUP
+#line 239 "ldlex.l"
+{ RTOKEN(':'); }
+	YY_BREAK
+case 46:
+YY_RULE_SETUP
+#line 240 "ldlex.l"
+{ RTOKEN(';');}
+	YY_BREAK
+case 47:
+YY_RULE_SETUP
+#line 241 "ldlex.l"
+{ RTOKEN(MEMORY);}
+	YY_BREAK
+case 48:
+YY_RULE_SETUP
+#line 242 "ldlex.l"
+{ RTOKEN(REGION_ALIAS);}
+	YY_BREAK
+case 49:
+YY_RULE_SETUP
+#line 243 "ldlex.l"
+{ RTOKEN(ORIGIN);}
+	YY_BREAK
+case 50:
+YY_RULE_SETUP
+#line 244 "ldlex.l"
+{ RTOKEN(VERSIONK);}
+	YY_BREAK
+case 51:
+YY_RULE_SETUP
+#line 245 "ldlex.l"
+{ RTOKEN(BLOCK);}
+	YY_BREAK
+case 52:
+YY_RULE_SETUP
+#line 246 "ldlex.l"
+{ RTOKEN(BIND);}
+	YY_BREAK
+case 53:
+YY_RULE_SETUP
+#line 247 "ldlex.l"
+{ RTOKEN(LENGTH);}
+	YY_BREAK
+case 54:
+YY_RULE_SETUP
+#line 248 "ldlex.l"
+{ RTOKEN(ALIGN_K);}
+	YY_BREAK
+case 55:
+YY_RULE_SETUP
+#line 249 "ldlex.l"
+{ RTOKEN(DATA_SEGMENT_ALIGN);}
+	YY_BREAK
+case 56:
+YY_RULE_SETUP
+#line 250 "ldlex.l"
+{ RTOKEN(DATA_SEGMENT_RELRO_END);}
+	YY_BREAK
+case 57:
+YY_RULE_SETUP
+#line 251 "ldlex.l"
+{ RTOKEN(DATA_SEGMENT_END);}
+	YY_BREAK
+case 58:
+YY_RULE_SETUP
+#line 252 "ldlex.l"
+{ RTOKEN(ADDR);}
+	YY_BREAK
+case 59:
+YY_RULE_SETUP
+#line 253 "ldlex.l"
+{ RTOKEN(LOADADDR);}
+	YY_BREAK
+case 60:
+YY_RULE_SETUP
+#line 254 "ldlex.l"
+{ RTOKEN(ALIGNOF); }
+	YY_BREAK
+case 61:
+YY_RULE_SETUP
+#line 255 "ldlex.l"
+{ RTOKEN(MAX_K); }
+	YY_BREAK
+case 62:
+YY_RULE_SETUP
+#line 256 "ldlex.l"
+{ RTOKEN(MIN_K); }
+	YY_BREAK
+case 63:
+YY_RULE_SETUP
+#line 257 "ldlex.l"
+{ RTOKEN(CEILP2); }
+	YY_BREAK
+case 64:
+YY_RULE_SETUP
+#line 258 "ldlex.l"
+{ RTOKEN(NACL_MASK);}
+	YY_BREAK
+case 65:
+YY_RULE_SETUP
+#line 259 "ldlex.l"
+{ RTOKEN(ASSERT_K); }
+	YY_BREAK
+case 66:
+YY_RULE_SETUP
+#line 260 "ldlex.l"
+{ RTOKEN(ENTRY);}
+	YY_BREAK
+case 67:
+YY_RULE_SETUP
+#line 261 "ldlex.l"
+{ RTOKEN(EXTERN);}
+	YY_BREAK
+case 68:
+YY_RULE_SETUP
+#line 262 "ldlex.l"
+{ RTOKEN(NEXT);}
+	YY_BREAK
+case 69:
+YY_RULE_SETUP
+#line 263 "ldlex.l"
+{ RTOKEN(SIZEOF_HEADERS);}
+	YY_BREAK
+case 70:
+YY_RULE_SETUP
+#line 264 "ldlex.l"
+{ RTOKEN(SIZEOF_HEADERS);}
+	YY_BREAK
+case 71:
+YY_RULE_SETUP
+#line 265 "ldlex.l"
+{ RTOKEN(SEGMENT_START);}
+	YY_BREAK
+case 72:
+YY_RULE_SETUP
+#line 266 "ldlex.l"
+{ RTOKEN(MAP);}
+	YY_BREAK
+case 73:
+YY_RULE_SETUP
+#line 267 "ldlex.l"
+{ RTOKEN(SIZEOF);}
+	YY_BREAK
+case 74:
+YY_RULE_SETUP
+#line 268 "ldlex.l"
+{ RTOKEN(TARGET_K);}
+	YY_BREAK
+case 75:
+YY_RULE_SETUP
+#line 269 "ldlex.l"
+{ RTOKEN(SEARCH_DIR);}
+	YY_BREAK
+case 76:
+YY_RULE_SETUP
+#line 270 "ldlex.l"
+{ RTOKEN(OUTPUT);}
+	YY_BREAK
+case 77:
+YY_RULE_SETUP
+#line 271 "ldlex.l"
+{ RTOKEN(INPUT);}
+	YY_BREAK
+case 78:
+YY_RULE_SETUP
+#line 272 "ldlex.l"
+{ RTOKEN(GROUP);}
+	YY_BREAK
+case 79:
+YY_RULE_SETUP
+#line 273 "ldlex.l"
+{ RTOKEN(AS_NEEDED);}
+	YY_BREAK
+case 80:
+YY_RULE_SETUP
+#line 274 "ldlex.l"
+{ RTOKEN(DEFINED);}
+	YY_BREAK
+case 81:
+YY_RULE_SETUP
+#line 275 "ldlex.l"
+{ RTOKEN(CREATE_OBJECT_SYMBOLS);}
+	YY_BREAK
+case 82:
+YY_RULE_SETUP
+#line 276 "ldlex.l"
+{ RTOKEN( CONSTRUCTORS);}
+	YY_BREAK
+case 83:
+YY_RULE_SETUP
+#line 277 "ldlex.l"
+{ RTOKEN(FORCE_COMMON_ALLOCATION);}
+	YY_BREAK
+case 84:
+YY_RULE_SETUP
+#line 278 "ldlex.l"
+{ RTOKEN(INHIBIT_COMMON_ALLOCATION);}
+	YY_BREAK
+case 85:
+YY_RULE_SETUP
+#line 279 "ldlex.l"
+{ RTOKEN(SECTIONS);}
+	YY_BREAK
+case 86:
+YY_RULE_SETUP
+#line 280 "ldlex.l"
+{ RTOKEN(INSERT_K);}
+	YY_BREAK
+case 87:
+YY_RULE_SETUP
+#line 281 "ldlex.l"
+{ RTOKEN(AFTER);}
+	YY_BREAK
+case 88:
+YY_RULE_SETUP
+#line 282 "ldlex.l"
+{ RTOKEN(BEFORE);}
+	YY_BREAK
+case 89:
+YY_RULE_SETUP
+#line 283 "ldlex.l"
+{ RTOKEN(FILL);}
+	YY_BREAK
+case 90:
+YY_RULE_SETUP
+#line 284 "ldlex.l"
+{ RTOKEN(STARTUP);}
+	YY_BREAK
+case 91:
+YY_RULE_SETUP
+#line 285 "ldlex.l"
+{ RTOKEN(OUTPUT_FORMAT);}
+	YY_BREAK
+case 92:
+YY_RULE_SETUP
+#line 286 "ldlex.l"
+{ RTOKEN( OUTPUT_ARCH);}
+	YY_BREAK
+case 93:
+YY_RULE_SETUP
+#line 287 "ldlex.l"
+{ RTOKEN(HLL);}
+	YY_BREAK
+case 94:
+YY_RULE_SETUP
+#line 288 "ldlex.l"
+{ RTOKEN(SYSLIB);}
+	YY_BREAK
+case 95:
+YY_RULE_SETUP
+#line 289 "ldlex.l"
+{ RTOKEN(FLOAT);}
+	YY_BREAK
+case 96:
+YY_RULE_SETUP
+#line 290 "ldlex.l"
+{ RTOKEN( QUAD);}
+	YY_BREAK
+case 97:
+YY_RULE_SETUP
+#line 291 "ldlex.l"
+{ RTOKEN( SQUAD);}
+	YY_BREAK
+case 98:
+YY_RULE_SETUP
+#line 292 "ldlex.l"
+{ RTOKEN( LONG);}
+	YY_BREAK
+case 99:
+YY_RULE_SETUP
+#line 293 "ldlex.l"
+{ RTOKEN( SHORT);}
+	YY_BREAK
+case 100:
+YY_RULE_SETUP
+#line 294 "ldlex.l"
+{ RTOKEN( BYTE);}
+	YY_BREAK
+case 101:
+YY_RULE_SETUP
+#line 295 "ldlex.l"
+{ RTOKEN(NOFLOAT);}
+	YY_BREAK
+case 102:
+YY_RULE_SETUP
+#line 296 "ldlex.l"
+{ RTOKEN(NOCROSSREFS);}
+	YY_BREAK
+case 103:
+YY_RULE_SETUP
+#line 297 "ldlex.l"
+{ RTOKEN(OVERLAY); }
+	YY_BREAK
+case 104:
+YY_RULE_SETUP
+#line 298 "ldlex.l"
+{ RTOKEN(SORT_BY_NAME); }
+	YY_BREAK
+case 105:
+YY_RULE_SETUP
+#line 299 "ldlex.l"
+{ RTOKEN(SORT_BY_ALIGNMENT); }
+	YY_BREAK
+case 106:
+YY_RULE_SETUP
+#line 300 "ldlex.l"
+{ RTOKEN(SORT_BY_NAME); }
+	YY_BREAK
+case 107:
+YY_RULE_SETUP
+#line 301 "ldlex.l"
+{ RTOKEN(NOLOAD);}
+	YY_BREAK
+case 108:
+YY_RULE_SETUP
+#line 302 "ldlex.l"
+{ RTOKEN(DSECT);}
+	YY_BREAK
+case 109:
+YY_RULE_SETUP
+#line 303 "ldlex.l"
+{ RTOKEN(COPY);}
+	YY_BREAK
+case 110:
+YY_RULE_SETUP
+#line 304 "ldlex.l"
+{ RTOKEN(INFO);}
+	YY_BREAK
+case 111:
+YY_RULE_SETUP
+#line 305 "ldlex.l"
+{ RTOKEN(OVERLAY);}
+	YY_BREAK
+case 112:
+YY_RULE_SETUP
+#line 306 "ldlex.l"
+{ RTOKEN(ONLY_IF_RO); }
+	YY_BREAK
+case 113:
+YY_RULE_SETUP
+#line 307 "ldlex.l"
+{ RTOKEN(ONLY_IF_RW); }
+	YY_BREAK
+case 114:
+YY_RULE_SETUP
+#line 308 "ldlex.l"
+{ RTOKEN(SPECIAL); }
+	YY_BREAK
+case 115:
+YY_RULE_SETUP
+#line 309 "ldlex.l"
+{ RTOKEN(ORIGIN);}
+	YY_BREAK
+case 116:
+YY_RULE_SETUP
+#line 310 "ldlex.l"
+{ RTOKEN(ORIGIN);}
+	YY_BREAK
+case 117:
+YY_RULE_SETUP
+#line 311 "ldlex.l"
+{ RTOKEN( LENGTH);}
+	YY_BREAK
+case 118:
+YY_RULE_SETUP
+#line 312 "ldlex.l"
+{ RTOKEN( LENGTH);}
+	YY_BREAK
+case 119:
+YY_RULE_SETUP
+#line 313 "ldlex.l"
+{ RTOKEN(INCLUDE);}
+	YY_BREAK
+case 120:
+YY_RULE_SETUP
+#line 314 "ldlex.l"
+{ RTOKEN (PHDRS); }
+	YY_BREAK
+case 121:
+YY_RULE_SETUP
+#line 315 "ldlex.l"
+{ RTOKEN(AT);}
+	YY_BREAK
+case 122:
+YY_RULE_SETUP
+#line 316 "ldlex.l"
+{ RTOKEN(SUBALIGN);}
+	YY_BREAK
+case 123:
+YY_RULE_SETUP
+#line 317 "ldlex.l"
+{ RTOKEN(PROVIDE); }
+	YY_BREAK
+case 124:
+YY_RULE_SETUP
+#line 318 "ldlex.l"
+{ RTOKEN(PROVIDE_HIDDEN); }
+	YY_BREAK
+case 125:
+YY_RULE_SETUP
+#line 319 "ldlex.l"
+{ RTOKEN(KEEP); }
+	YY_BREAK
+case 126:
+YY_RULE_SETUP
+#line 320 "ldlex.l"
+{ RTOKEN(EXCLUDE_FILE); }
+	YY_BREAK
+case 127:
+YY_RULE_SETUP
+#line 321 "ldlex.l"
+{ RTOKEN(CONSTANT);}
+	YY_BREAK
+case 128:
+/* rule 128 can match eol */
+YY_RULE_SETUP
+#line 322 "ldlex.l"
+{ ++ lineno; }
+	YY_BREAK
+case 129:
+/* rule 129 can match eol */
+YY_RULE_SETUP
+#line 323 "ldlex.l"
+{ ++ lineno;  RTOKEN(NEWLINE); }
+	YY_BREAK
+case 130:
+YY_RULE_SETUP
+#line 324 "ldlex.l"
+{ /* Mri comment line */ }
+	YY_BREAK
+case 131:
+YY_RULE_SETUP
+#line 325 "ldlex.l"
+{ /* Mri comment line */ }
+	YY_BREAK
+case 132:
+YY_RULE_SETUP
+#line 326 "ldlex.l"
+{ RTOKEN(ENDWORD); }
+	YY_BREAK
+case 133:
+YY_RULE_SETUP
+#line 327 "ldlex.l"
+{ RTOKEN(ALIGNMOD);}
+	YY_BREAK
+case 134:
+YY_RULE_SETUP
+#line 328 "ldlex.l"
+{ RTOKEN(ALIGN_K);}
+	YY_BREAK
+case 135:
+YY_RULE_SETUP
+#line 329 "ldlex.l"
+{ RTOKEN(CHIP); }
+	YY_BREAK
+case 136:
+YY_RULE_SETUP
+#line 330 "ldlex.l"
+{ RTOKEN(BASE); }
+	YY_BREAK
+case 137:
+YY_RULE_SETUP
+#line 331 "ldlex.l"
+{ RTOKEN(ALIAS); }
+	YY_BREAK
+case 138:
+YY_RULE_SETUP
+#line 332 "ldlex.l"
+{ RTOKEN(TRUNCATE); }
+	YY_BREAK
+case 139:
+YY_RULE_SETUP
+#line 333 "ldlex.l"
+{ RTOKEN(LOAD); }
+	YY_BREAK
+case 140:
+YY_RULE_SETUP
+#line 334 "ldlex.l"
+{ RTOKEN(PUBLIC); }
+	YY_BREAK
+case 141:
+YY_RULE_SETUP
+#line 335 "ldlex.l"
+{ RTOKEN(ORDER); }
+	YY_BREAK
+case 142:
+YY_RULE_SETUP
+#line 336 "ldlex.l"
+{ RTOKEN(NAMEWORD); }
+	YY_BREAK
+case 143:
+YY_RULE_SETUP
+#line 337 "ldlex.l"
+{ RTOKEN(FORMAT); }
+	YY_BREAK
+case 144:
+YY_RULE_SETUP
+#line 338 "ldlex.l"
+{ RTOKEN(CASE); }
+	YY_BREAK
+case 145:
+YY_RULE_SETUP
+#line 339 "ldlex.l"
+{ RTOKEN(START); }
+	YY_BREAK
+case 146:
+YY_RULE_SETUP
+#line 340 "ldlex.l"
+{ RTOKEN(LIST); /* LIST and ignore to end of line */ }
+	YY_BREAK
+case 147:
+YY_RULE_SETUP
+#line 341 "ldlex.l"
+{ RTOKEN(SECT); }
+	YY_BREAK
+case 148:
+YY_RULE_SETUP
+#line 342 "ldlex.l"
+{ RTOKEN(ABSOLUTE); }
+	YY_BREAK
+case 149:
+YY_RULE_SETUP
+#line 343 "ldlex.l"
+{ RTOKEN(ENDWORD); }
+	YY_BREAK
+case 150:
+YY_RULE_SETUP
+#line 344 "ldlex.l"
+{ RTOKEN(ALIGNMOD);}
+	YY_BREAK
+case 151:
+YY_RULE_SETUP
+#line 345 "ldlex.l"
+{ RTOKEN(ALIGN_K);}
+	YY_BREAK
+case 152:
+YY_RULE_SETUP
+#line 346 "ldlex.l"
+{ RTOKEN(CHIP); }
+	YY_BREAK
+case 153:
+YY_RULE_SETUP
+#line 347 "ldlex.l"
+{ RTOKEN(BASE); }
+	YY_BREAK
+case 154:
+YY_RULE_SETUP
+#line 348 "ldlex.l"
+{ RTOKEN(ALIAS); }
+	YY_BREAK
+case 155:
+YY_RULE_SETUP
+#line 349 "ldlex.l"
+{ RTOKEN(TRUNCATE); }
+	YY_BREAK
+case 156:
+YY_RULE_SETUP
+#line 350 "ldlex.l"
+{ RTOKEN(LOAD); }
+	YY_BREAK
+case 157:
+YY_RULE_SETUP
+#line 351 "ldlex.l"
+{ RTOKEN(PUBLIC); }
+	YY_BREAK
+case 158:
+YY_RULE_SETUP
+#line 352 "ldlex.l"
+{ RTOKEN(ORDER); }
+	YY_BREAK
+case 159:
+YY_RULE_SETUP
+#line 353 "ldlex.l"
+{ RTOKEN(NAMEWORD); }
+	YY_BREAK
+case 160:
+YY_RULE_SETUP
+#line 354 "ldlex.l"
+{ RTOKEN(FORMAT); }
+	YY_BREAK
+case 161:
+YY_RULE_SETUP
+#line 355 "ldlex.l"
+{ RTOKEN(CASE); }
+	YY_BREAK
+case 162:
+YY_RULE_SETUP
+#line 356 "ldlex.l"
+{ RTOKEN(EXTERN); }
+	YY_BREAK
+case 163:
+YY_RULE_SETUP
+#line 357 "ldlex.l"
+{ RTOKEN(START); }
+	YY_BREAK
+case 164:
+YY_RULE_SETUP
+#line 358 "ldlex.l"
+{ RTOKEN(LIST); /* LIST and ignore to end of line */ }
+	YY_BREAK
+case 165:
+YY_RULE_SETUP
+#line 359 "ldlex.l"
+{ RTOKEN(SECT); }
+	YY_BREAK
+case 166:
+YY_RULE_SETUP
+#line 360 "ldlex.l"
+{ RTOKEN(ABSOLUTE); }
+	YY_BREAK
+case 167:
+YY_RULE_SETUP
+#line 362 "ldlex.l"
+{
+/* Filename without commas, needed to parse mri stuff */
+				 yylval.name = xstrdup (yytext);
+				  return NAME;
+				}
+	YY_BREAK
+case 168:
+YY_RULE_SETUP
+#line 369 "ldlex.l"
+{
+				 yylval.name = xstrdup (yytext);
+				  return NAME;
+				}
+	YY_BREAK
+case 169:
+YY_RULE_SETUP
+#line 373 "ldlex.l"
+{
+				  yylval.name = xstrdup (yytext + 2);
+				  return LNAME;
+				}
+	YY_BREAK
+case 170:
+YY_RULE_SETUP
+#line 377 "ldlex.l"
+{
+				 yylval.name = xstrdup (yytext);
+				  return NAME;
+				}
+	YY_BREAK
+case 171:
+YY_RULE_SETUP
+#line 381 "ldlex.l"
+{
+				  yylval.name = xstrdup (yytext + 2);
+				  return LNAME;
+				}
+	YY_BREAK
+case 172:
+YY_RULE_SETUP
+#line 385 "ldlex.l"
+{
+		/* Annoyingly, this pattern can match comments, and we have
+		   longest match issues to consider.  So if the first two
+		   characters are a comment opening, put the input back and
+		   try again.  */
+		if (yytext[0] == '/' && yytext[1] == '*')
+		  {
+		    yyless (2);
+		    comment ();
+		  }
+		else
+		  {
+		    yylval.name = xstrdup (yytext);
+		    return NAME;
+		  }
+	}
+	YY_BREAK
+case 173:
+/* rule 173 can match eol */
+YY_RULE_SETUP
+#line 402 "ldlex.l"
+{
+					/* No matter the state, quotes
+					   give what's inside */
+					yylval.name = xstrdup (yytext + 1);
+					yylval.name[yyleng - 2] = 0;
+					return NAME;
+				}
+	YY_BREAK
+case 174:
+/* rule 174 can match eol */
+YY_RULE_SETUP
+#line 409 "ldlex.l"
+{ lineno++;}
+	YY_BREAK
+case 175:
+YY_RULE_SETUP
+#line 410 "ldlex.l"
+{ }
+	YY_BREAK
+case 176:
+YY_RULE_SETUP
+#line 412 "ldlex.l"
+{ return *yytext; }
+	YY_BREAK
+case 177:
+YY_RULE_SETUP
+#line 414 "ldlex.l"
+{ RTOKEN(GLOBAL); }
+	YY_BREAK
+case 178:
+YY_RULE_SETUP
+#line 416 "ldlex.l"
+{ RTOKEN(LOCAL); }
+	YY_BREAK
+case 179:
+YY_RULE_SETUP
+#line 418 "ldlex.l"
+{ RTOKEN(EXTERN); }
+	YY_BREAK
+case 180:
+YY_RULE_SETUP
+#line 420 "ldlex.l"
+{ yylval.name = xstrdup (yytext);
+				  return VERS_IDENTIFIER; }
+	YY_BREAK
+case 181:
+YY_RULE_SETUP
+#line 423 "ldlex.l"
+{ yylval.name = xstrdup (yytext);
+				  return VERS_TAG; }
+	YY_BREAK
+case 182:
+YY_RULE_SETUP
+#line 426 "ldlex.l"
+{ BEGIN(VERS_SCRIPT); return *yytext; }
+	YY_BREAK
+case 183:
+YY_RULE_SETUP
+#line 428 "ldlex.l"
+{ BEGIN(VERS_NODE);
+				  vers_node_nesting = 0;
+				  return *yytext;
+				}
+	YY_BREAK
+case 184:
+YY_RULE_SETUP
+#line 432 "ldlex.l"
+{ return *yytext; }
+	YY_BREAK
+case 185:
+YY_RULE_SETUP
+#line 433 "ldlex.l"
+{ vers_node_nesting++; return *yytext; }
+	YY_BREAK
+case 186:
+YY_RULE_SETUP
+#line 434 "ldlex.l"
+{ if (--vers_node_nesting < 0)
+				    BEGIN(VERS_SCRIPT);
+				  return *yytext;
+				}
+	YY_BREAK
+case 187:
+/* rule 187 can match eol */
+YY_RULE_SETUP
+#line 439 "ldlex.l"
+{ lineno++; }
+	YY_BREAK
+case 188:
+YY_RULE_SETUP
+#line 441 "ldlex.l"
+{ /* Eat up comments */ }
+	YY_BREAK
+case 189:
+YY_RULE_SETUP
+#line 443 "ldlex.l"
+{ /* Eat up whitespace */ }
+	YY_BREAK
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(SCRIPT):
+case YY_STATE_EOF(EXPRESSION):
+case YY_STATE_EOF(BOTH):
+case YY_STATE_EOF(DEFSYMEXP):
+case YY_STATE_EOF(MRI):
+case YY_STATE_EOF(VERS_START):
+case YY_STATE_EOF(VERS_SCRIPT):
+case YY_STATE_EOF(VERS_NODE):
+#line 445 "ldlex.l"
+{
+  include_stack_ptr--;
+
+  if (include_stack_ptr == 0)
+  {
+    yyterminate ();
+  }
+  else
+  {
+    yy_switch_to_buffer (include_stack[include_stack_ptr]);
+  }
+
+  ldfile_input_filename = file_name_stack[include_stack_ptr - 1];
+  lineno = lineno_stack[include_stack_ptr];
+
+  return END;
+}
+	YY_BREAK
+case 190:
+YY_RULE_SETUP
+#line 463 "ldlex.l"
+lex_warn_invalid (" in script", yytext);
+	YY_BREAK
+case 191:
+YY_RULE_SETUP
+#line 464 "ldlex.l"
+lex_warn_invalid (" in expression", yytext);
+	YY_BREAK
+case 192:
+YY_RULE_SETUP
+#line 466 "ldlex.l"
+ECHO;
+	YY_BREAK
+#line 3068 "ldlex.c"
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( yywrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of yylex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart(yyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 1617 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 1617 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 1616);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up yytext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart(yyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void yyrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer(yyin,YY_BUF_SIZE );
+	}
+
+	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
+	yy_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void yy_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * 
+ */
+    void yy_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yyfree((void *) b->yy_ch_buf  );
+
+	yyfree((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	yy_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void yypop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void yyensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
+{
+    
+	return yy_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) yyalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
+{
+        
+    return yylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int yyget_leng  (void)
+{
+        return yyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *yyget_text  (void)
+{
+        return yytext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void yyset_lineno (int  line_number )
+{
+    
+    yylineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  in_str )
+{
+        yyin = in_str ;
+}
+
+void yyset_out (FILE *  out_str )
+{
+        yyout = out_str ;
+}
+
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
+
+void yyset_debug (int  bdebug )
+{
+        yy_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = (FILE *) 0;
+    yyout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *yyalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *yyrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void yyfree (void * ptr )
+{
+	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 466 "ldlex.l"
+
+
+
+
+/* Switch flex to reading script file NAME, open on FILE,
+   saving the current input info on the include stack.  */
+
+void
+lex_push_file (FILE *file, const char *name)
+{
+  if (include_stack_ptr >= MAX_INCLUDE_DEPTH)
+    {
+      einfo ("%F:includes nested too deeply\n");
+    }
+  file_name_stack[include_stack_ptr] = name;
+  lineno_stack[include_stack_ptr] = lineno;
+  include_stack[include_stack_ptr] = YY_CURRENT_BUFFER;
+
+  include_stack_ptr++;
+  lineno = 1;
+  yyin = file;
+  yy_switch_to_buffer (yy_create_buffer (yyin, YY_BUF_SIZE));
+}
+
+/* Return a newly created flex input buffer containing STRING,
+   which is SIZE bytes long.  */
+
+static YY_BUFFER_STATE
+yy_create_string_buffer (const char *string, size_t size)
+{
+  YY_BUFFER_STATE b;
+
+  /* Calls to m-alloc get turned by sed into xm-alloc.  */
+  b = malloc (sizeof (struct yy_buffer_state));
+  b->yy_input_file = 0;
+  b->yy_buf_size = size;
+
+  /* yy_ch_buf has to be 2 characters longer than the size given because
+     we need to put in 2 end-of-buffer characters.  */
+  b->yy_ch_buf = malloc ((unsigned) (b->yy_buf_size + 3));
+
+  b->yy_ch_buf[0] = '\n';
+  strcpy (b->yy_ch_buf+1, string);
+  b->yy_ch_buf[size+1] = YY_END_OF_BUFFER_CHAR;
+  b->yy_ch_buf[size+2] = YY_END_OF_BUFFER_CHAR;
+  b->yy_n_chars = size+1;
+  b->yy_buf_pos = &b->yy_ch_buf[1];
+
+  b->yy_is_our_buffer = 1;
+  b->yy_is_interactive = 0;
+  b->yy_at_bol = 1;
+  b->yy_fill_buffer = 0;
+
+  /* flex 2.4.7 changed the interface.  FIXME: We should not be using
+     a flex internal interface in the first place!  */
+#ifdef YY_BUFFER_NEW
+  b->yy_buffer_status = YY_BUFFER_NEW;
+#else
+  b->yy_eof_status = EOF_NOT_SEEN;
+#endif
+
+  return b;
+}
+
+/* Switch flex to reading from STRING, saving the current input info
+   on the include stack.  */
+
+void
+lex_redirect (const char *string)
+{
+  YY_BUFFER_STATE tmp;
+
+  yy_init = 0;
+  if (include_stack_ptr >= MAX_INCLUDE_DEPTH)
+    {
+      einfo("%F: macros nested too deeply\n");
+    }
+  file_name_stack[include_stack_ptr] = "redirect";
+  lineno_stack[include_stack_ptr] = lineno;
+  include_stack[include_stack_ptr] = YY_CURRENT_BUFFER;
+  include_stack_ptr++;
+  lineno = 1;
+  tmp = yy_create_string_buffer (string, strlen (string));
+  yy_switch_to_buffer (tmp);
+}
+
+/* Functions to switch to a different flex start condition,
+   saving the current start condition on `state_stack'.  */
+
+static int state_stack[MAX_INCLUDE_DEPTH * 2];
+static int *state_stack_p = state_stack;
+
+void
+ldlex_script (void)
+{
+  *(state_stack_p)++ = yy_start;
+  BEGIN (SCRIPT);
+}
+
+void
+ldlex_mri_script (void)
+{
+  *(state_stack_p)++ = yy_start;
+  BEGIN (MRI);
+}
+
+void
+ldlex_version_script (void)
+{
+  *(state_stack_p)++ = yy_start;
+  BEGIN (VERS_START);
+}
+
+void
+ldlex_version_file (void)
+{
+  *(state_stack_p)++ = yy_start;
+  BEGIN (VERS_SCRIPT);
+}
+
+void
+ldlex_defsym (void)
+{
+  *(state_stack_p)++ = yy_start;
+  BEGIN (DEFSYMEXP);
+}
+
+void
+ldlex_expression (void)
+{
+  *(state_stack_p)++ = yy_start;
+  BEGIN (EXPRESSION);
+}
+
+void
+ldlex_both (void)
+{
+  *(state_stack_p)++ = yy_start;
+  BEGIN (BOTH);
+}
+
+void
+ldlex_popstate (void)
+{
+  yy_start = *(--state_stack_p);
+}
+
+
+/* Place up to MAX_SIZE characters in BUF and return in *RESULT
+   either the number of characters read, or 0 to indicate EOF.  */
+
+static void
+yy_input (char *buf, int *result, int max_size)
+{
+  *result = 0;
+  if (YY_CURRENT_BUFFER->yy_input_file)
+    {
+      if (yyin)
+	{
+	  *result = fread (buf, 1, max_size, yyin);
+	  if (*result < max_size && ferror (yyin))
+	    einfo ("%F%P: read in flex scanner failed\n");
+	}
+    }
+}
+
+/* Eat the rest of a C-style comment.  */
+
+static void
+comment (void)
+{
+  int c;
+
+  while (1)
+  {
+    c = input();
+    while (c != '*' && c != EOF)
+    {
+      if (c == '\n')
+	lineno++;
+      c = input();
+    }
+
+    if (c == '*')
+    {
+      c = input();
+      while (c == '*')
+       c = input();
+      if (c == '/')
+       break;			/* found the end */
+    }
+
+    if (c == '\n')
+      lineno++;
+
+    if (c == EOF)
+    {
+      einfo( "%F%P: EOF in comment\n");
+      break;
+    }
+  }
+}
+
+/* Warn the user about a garbage character WHAT in the input
+   in context WHERE.  */
+
+static void
+lex_warn_invalid (char *where, char *what)
+{
+  char buf[5];
+
+  /* If we have found an input file whose format we do not recognize,
+     and we are therefore treating it as a linker script, and we find
+     an invalid character, then most likely this is a real object file
+     of some different format.  Treat it as such.  */
+  if (ldfile_assumed_script)
+    {
+      bfd_set_error (bfd_error_file_not_recognized);
+      einfo ("%F%s: file not recognized: %E\n", ldfile_input_filename);
+    }
+
+  if (! ISPRINT (*what))
+    {
+      sprintf (buf, "\\%03o", (unsigned int) *what);
+      what = buf;
+    }
+
+  einfo ("%P:%S: ignoring invalid character `%s'%s\n", what, where);
+}
+
