diff -Naur ../PRISTINE/binutils-2.20/bfd/Makefile.am binutils-2.20/bfd/Makefile.am
--- ../PRISTINE/binutils-2.20/bfd/Makefile.am	2009-10-16 04:47:44.000000000 -0700
+++ binutils-2.20/bfd/Makefile.am	2010-01-05 13:21:03.270377000 -0800
@@ -303,6 +303,7 @@
 	elf32-moxie.lo \
 	elf32-msp430.lo \
 	elf32-mt.lo \
+	elf32-nacl.lo \
 	elf32-openrisc.lo \
 	elf32-or32.lo \
 	elf32-pj.lo \
@@ -486,6 +487,7 @@
 	elf32-moxie.c \
 	elf32-msp430.c \
 	elf32-mt.c \
+	elf32-nacl.c \
 	elf32-openrisc.c \
 	elf32-or32.c \
 	elf32-pj.c \
@@ -598,6 +600,7 @@
 	elf64-ia64.lo \
 	elf64-mips.lo \
 	elf64-mmix.lo \
+	elf64-nacl.lo \
 	elf64-ppc.lo \
 	elf64-s390.lo \
 	elf64-sh64.lo \
@@ -628,6 +631,7 @@
 	elf64-hppa.c \
 	elf64-mips.c \
 	elf64-mmix.c \
+	elf64-nacl.c \
 	elf64-ppc.c \
 	elf64-s390.c \
 	elf64-sh64.c \
diff -Naur ../PRISTINE/binutils-2.20/bfd/Makefile.in binutils-2.20/bfd/Makefile.in
--- ../PRISTINE/binutils-2.20/bfd/Makefile.in	2009-10-16 04:47:48.000000000 -0700
+++ binutils-2.20/bfd/Makefile.in	2010-01-05 13:21:03.292344000 -0800
@@ -599,6 +599,7 @@
 	elf32-moxie.lo \
 	elf32-msp430.lo \
 	elf32-mt.lo \
+	elf32-nacl.lo \
 	elf32-openrisc.lo \
 	elf32-or32.lo \
 	elf32-pj.lo \
@@ -782,6 +783,7 @@
 	elf32-moxie.c \
 	elf32-msp430.c \
 	elf32-mt.c \
+	elf32-nacl.c \
 	elf32-openrisc.c \
 	elf32-or32.c \
 	elf32-pj.c \
@@ -895,6 +897,7 @@
 	elf64-ia64.lo \
 	elf64-mips.lo \
 	elf64-mmix.lo \
+	elf64-nacl.lo \
 	elf64-ppc.lo \
 	elf64-s390.lo \
 	elf64-sh64.lo \
@@ -925,6 +928,7 @@
 	elf64-hppa.c \
 	elf64-mips.c \
 	elf64-mmix.c \
+	elf64-nacl.c \
 	elf64-ppc.c \
 	elf64-s390.c \
 	elf64-sh64.c \
diff -Naur ../PRISTINE/binutils-2.20/bfd/config.bfd binutils-2.20/bfd/config.bfd
--- ../PRISTINE/binutils-2.20/bfd/config.bfd	2009-08-06 10:38:00.000000000 -0700
+++ binutils-2.20/bfd/config.bfd	2010-01-05 13:21:03.302338000 -0800
@@ -603,6 +603,11 @@
     targ_selvecs="i386linux_vec i386pei_vec"
     targ64_selvecs="bfd_elf64_x86_64_vec bfd_elf64_l1om_vec"
     ;;
+  i[3-7]86-*-nacl*)
+    targ_defvec=bfd_elf32_nacl_vec
+    targ_selvecs="bfd_elf32_i386_vec i386linux_vec i386pei_vec"
+    targ64_selvecs="bfd_elf64_x86_64_vec bfd_elf64_nacl_vec"
+    ;;
 #ifdef BFD64
   x86_64-*-darwin*)
     targ_defvec=mach_o_le_vec
@@ -641,6 +646,11 @@
     want64=true
     targ_underscore=yes
     ;;
+  x86_64-*-nacl*)
+    targ_defvec=bfd_elf64_nacl_vec
+    targ_selvecs="bfd_elf32_i386_vec i386linux_vec i386pei_vec bfd_elf32_nacl_vec x86_64pei_vec"
+    want64=true
+    ;;
 #endif
   i[3-7]86-*-lynxos*)
     targ_defvec=bfd_elf32_i386_vec
diff -Naur ../PRISTINE/binutils-2.20/bfd/configure binutils-2.20/bfd/configure
--- ../PRISTINE/binutils-2.20/bfd/configure	2009-10-16 04:47:47.000000000 -0700
+++ binutils-2.20/bfd/configure	2010-01-05 13:21:03.352266000 -0800
@@ -14857,6 +14857,7 @@
     bfd_elf32_mn10300_vec)	tb="$tb elf-m10300.lo elf32.lo $elf" ;;
     bfd_elf32_mt_vec)           tb="$tb elf32-mt.lo elf32.lo $elf" ;;
     bfd_elf32_msp430_vec)	tb="$tb elf32-msp430.lo elf32.lo $elf" ;;
+    bfd_elf32_nacl_vec)		tb="$tb elf32-nacl.lo elf-vxworks.lo elf32.lo $elf" ;;
     bfd_elf32_nbigmips_vec)	tb="$tb elfn32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf32_nlittlemips_vec)	tb="$tb elfn32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf32_ntradbigmips_vec)	tb="$tb elfn32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
@@ -14914,6 +14915,7 @@
     bfd_elf64_little_generic_vec) tb="$tb elf64-gen.lo elf64.lo $elf"; target_size=64 ;;
     bfd_elf64_littlemips_vec) 	tb="$tb elf64-mips.lo elf64.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf64_mmix_vec) 	tb="$tb elf64-mmix.lo elf64.lo $elf" target_size=64 ;;
+    bfd_elf64_nacl_vec)		tb="$tb elf64-nacl.lo elf64.lo $elf" target_size=64 ;;
     bfd_elf64_powerpc_vec)	tb="$tb elf64-ppc.lo elf64-gen.lo elf64.lo $elf"; target_size=64 ;;
     bfd_elf64_powerpcle_vec)	tb="$tb elf64-ppc.lo elf64-gen.lo elf64.lo $elf" target_size=64 ;;
     bfd_elf64_s390_vec)		tb="$tb elf64-s390.lo elf64.lo $elf"; target_size=64 ;;
diff -Naur ../PRISTINE/binutils-2.20/bfd/configure.in binutils-2.20/bfd/configure.in
--- ../PRISTINE/binutils-2.20/bfd/configure.in	2009-10-16 04:47:44.000000000 -0700
+++ binutils-2.20/bfd/configure.in	2010-01-05 13:21:03.366256000 -0800
@@ -745,6 +745,7 @@
     bfd_elf32_mn10300_vec)	tb="$tb elf-m10300.lo elf32.lo $elf" ;;
     bfd_elf32_mt_vec)           tb="$tb elf32-mt.lo elf32.lo $elf" ;;
     bfd_elf32_msp430_vec)	tb="$tb elf32-msp430.lo elf32.lo $elf" ;;
+    bfd_elf32_nacl_vec)		tb="$tb elf32-nacl.lo elf-vxworks.lo elf32.lo $elf" ;;
     bfd_elf32_nbigmips_vec)	tb="$tb elfn32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf32_nlittlemips_vec)	tb="$tb elfn32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf32_ntradbigmips_vec)	tb="$tb elfn32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
@@ -802,6 +803,7 @@
     bfd_elf64_little_generic_vec) tb="$tb elf64-gen.lo elf64.lo $elf"; target_size=64 ;;
     bfd_elf64_littlemips_vec) 	tb="$tb elf64-mips.lo elf64.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf64_mmix_vec) 	tb="$tb elf64-mmix.lo elf64.lo $elf" target_size=64 ;;
+    bfd_elf64_nacl_vec)		tb="$tb elf64-nacl.lo elf64.lo $elf" ;;
     bfd_elf64_powerpc_vec)	tb="$tb elf64-ppc.lo elf64-gen.lo elf64.lo $elf"; target_size=64 ;;
     bfd_elf64_powerpcle_vec)	tb="$tb elf64-ppc.lo elf64-gen.lo elf64.lo $elf" target_size=64 ;;
     bfd_elf64_s390_vec)		tb="$tb elf64-s390.lo elf64.lo $elf"; target_size=64 ;;
diff -Naur ../PRISTINE/binutils-2.20/bfd/elf32-i386.c binutils-2.20/bfd/elf32-i386.c
--- ../PRISTINE/binutils-2.20/bfd/elf32-i386.c	2009-09-10 04:47:12.000000000 -0700
+++ binutils-2.20/bfd/elf32-i386.c	2010-01-05 13:21:03.387256000 -0800
@@ -34,6 +34,10 @@
 
 #include "elf/i386.h"
 
+#ifdef ELF32_NACL_C
+#include "elf/nacl.h"
+#endif
+
 static reloc_howto_type elf_howto_table[]=
 {
   HOWTO(R_386_NONE, 0, 0, 0, FALSE, 0, complain_overflow_bitfield,
@@ -523,44 +527,133 @@
 
 /* The size in bytes of an entry in the procedure linkage table.  */
 
+#ifdef ELF32_NACL_C
+#define PLT_ENTRY_SIZE 64
+#else
 #define PLT_ENTRY_SIZE 16
+#endif
 
 /* The first entry in an absolute procedure linkage table looks like
    this.  See the SVR4 ABI i386 supplement to see how this works.
    Will be padded to PLT_ENTRY_SIZE with htab->plt0_pad_byte.  */
 
+#ifdef ELF32_NACL_C
+static const bfd_byte elf_i386_plt0_entry[18] =
+{
+  0xff, 0x35,	    /* pushl contents of address */
+#define elf_i386_plt0_entry_offset1 2
+  0, 0, 0, 0,	    /* replaced with address of .got + 4.  */
+  0xb9,             /* movl address, %ecx */
+#define elf_i386_plt0_entry_offset2 7
+  0, 0, 0, 0,       /* replaced with address of .got + 8.  */
+  0x8b, 0x09,       /* mov (%ecx), %ecx */
+  0x83, 0xe1, 0xe0, /* andl %ecx, NACLMASK */
+  0xff, 0xe1	       /* jmp *%ecx */
+};
+#else
 static const bfd_byte elf_i386_plt0_entry[12] =
 {
   0xff, 0x35,	/* pushl contents of address */
+#define elf_i386_plt0_entry_offset1 2
   0, 0, 0, 0,	/* replaced with address of .got + 4.  */
   0xff, 0x25,	/* jmp indirect */
+#define elf_i386_plt0_entry_offset2 8
   0, 0, 0, 0	/* replaced with address of .got + 8.  */
 };
+#endif
 
 /* Subsequent entries in an absolute procedure linkage table look like
    this.  */
 
+#ifdef ELF32_NACL_C
+static const bfd_byte elf_i386_plt_entry[PLT_ENTRY_SIZE] =
+{
+  0xb9,			    /* movl address, %ecx */
+#define elf_i386_plt_entry_offset1 1
+  0, 0, 0, 0,		    /* replaced with address of this symbol in .got.  */
+  0x8b, 0x09,		    /* mov (%ecx), %ecx */
+  0x83, 0xe1, 0xe0,	    /* andl %ecx, NACLMASK */
+  0xff, 0xe1,		    /* jmp *%ecx */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+#define elf_i386_plt_entry_offset2 32
+  0x68,			    /* pushl immediate */
+#define elf_i386_plt_entry_offset3 33
+  0, 0, 0, 0,		    /* replaced with offset into relocation table.  */
+  0xe9,			    /* jmp relative */
+#define elf_i386_plt_entry_offset4 38
+  0, 0, 0, 0,		    /* replaced with offset to start of .plt.  */
+#define elf_i386_plt_entry_offset5 42
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4		    /* fill with hlt instructions. */
+};
+#else
 static const bfd_byte elf_i386_plt_entry[PLT_ENTRY_SIZE] =
 {
   0xff, 0x25,	/* jmp indirect */
+#define elf_i386_plt_entry_offset1 2
   0, 0, 0, 0,	/* replaced with address of this symbol in .got.  */
+#define elf_i386_plt_entry_offset2 6
   0x68,		/* pushl immediate */
+#define elf_i386_plt_entry_offset3 7
   0, 0, 0, 0,	/* replaced with offset into relocation table.  */
   0xe9,		/* jmp relative */
+#define elf_i386_plt_entry_offset4 12
   0, 0, 0, 0	/* replaced with offset to start of .plt.  */
+#define elf_i386_plt_entry_offset5 16
 };
+#endif
 
 /* The first entry in a PIC procedure linkage table look like this.
    Will be padded to PLT_ENTRY_SIZE with htab->plt0_pad_byte.  */
 
 static const bfd_byte elf_i386_pic_plt0_entry[12] =
 {
+#ifdef ELF32_NACL_C
+  0xff, 0x73, 0x04,		/* pushl 4(%ebx) */
+  0x8b, 0x4b, 0x08,		/* mov 0x8(%ebx), %ecx */
+  0x83, 0xe1, 0xe0,		/* and $NACLMASK, %ecx */
+  0xff, 0xe1,			/* jmp *%ecx */
+  0xf4				/* fill with hlt instructions. */
+#else
   0xff, 0xb3, 4, 0, 0, 0,	/* pushl 4(%ebx) */
   0xff, 0xa3, 8, 0, 0, 0	/* jmp *8(%ebx) */
+#endif
 };
 
 /* Subsequent entries in a PIC procedure linkage table look like this.  */
 
+#ifdef ELF32_NACL_C
+static const bfd_byte elf_i386_pic_plt_entry[PLT_ENTRY_SIZE] =
+{
+  0x8b, 0x8b,		    /* movl offset(%ebx), %ecx */
+  0, 0, 0, 0,		    /* replaced with offset of this symbol in .got.*/
+  0x83, 0xe1, 0xe0,	    /* andl %ecx, NACLMASK */
+  0xff, 0xe1,		    /* jmp *%ecx */
+  0xf4,                     /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0x68,			    /* pushl immediate */
+  0, 0, 0, 0,		    /* replaced with offset into relocation table.  */
+  0xe9,			    /* jmp relative */
+  0, 0, 0, 0,		    /* replaced with offset to start of .plt.  */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4                /* fill with hlt instructions. */
+};
+#else
 static const bfd_byte elf_i386_pic_plt_entry[PLT_ENTRY_SIZE] =
 {
   0xff, 0xa3,	/* jmp *offset(%ebx) */
@@ -570,6 +663,7 @@
   0xe9,		/* jmp relative */
   0, 0, 0, 0	/* replaced with offset to start of .plt.  */
 };
+#endif
 
 /* On VxWorks, the .rel.plt.unloaded section has absolute relocations
    for the PLTResolve stub and then for each PLT entry.  */
@@ -822,7 +916,11 @@
   ret->sym_cache.abfd = NULL;
   ret->is_vxworks = 0;
   ret->srelplt2 = NULL;
+#ifdef ELF32_NACL_C
+  ret->plt0_pad_byte = 0xf4;
+#else
   ret->plt0_pad_byte = 0;
+#endif
   ret->tls_module_base = NULL;
 
   ret->loc_hash_table = htab_try_create (1024,
@@ -875,6 +973,11 @@
       || (!info->shared && !htab->srelbss))
     abort ();
 
+#ifdef ELF32_NACL_C
+  if (!bfd_set_section_alignment(dynobj, htab->elf.splt, 5))
+    return FALSE;
+#endif
+
   if (htab->is_vxworks
       && !elf_vxworks_create_dynamic_sections (dynobj, info,
 					       &htab->srelplt2))
@@ -4115,7 +4218,8 @@
 		      (gotplt->output_section->vma
 		       + gotplt->output_offset
 		       + got_offset),
-		      plt->contents + h->plt.offset + 2);
+		      (plt->contents + h->plt.offset
+		       + elf_i386_plt_entry_offset1));
 
 	  if (htab->is_vxworks)
 	    {
@@ -4158,16 +4262,20 @@
 	  memcpy (plt->contents + h->plt.offset, elf_i386_pic_plt_entry,
 		  PLT_ENTRY_SIZE);
 	  bfd_put_32 (output_bfd, got_offset,
-		      plt->contents + h->plt.offset + 2);
+		      (plt->contents + h->plt.offset
+		       + elf_i386_plt0_entry_offset1));
 	}
 
       /* Don't fill PLT entry for static executables.  */
       if (plt == htab->elf.splt)
 	{
 	  bfd_put_32 (output_bfd, plt_index * sizeof (Elf32_External_Rel),
-		      plt->contents + h->plt.offset + 7);
-	  bfd_put_32 (output_bfd, - (h->plt.offset + PLT_ENTRY_SIZE),
-		      plt->contents + h->plt.offset + 12);
+		      (plt->contents + h->plt.offset
+		       + elf_i386_plt_entry_offset3));
+	  bfd_put_32 (output_bfd,
+		      - (h->plt.offset + elf_i386_plt_entry_offset5),
+		      (plt->contents + h->plt.offset
+		       + elf_i386_plt_entry_offset4));
 	}
 
       /* Fill in the entry in the global offset table.  */
@@ -4175,7 +4283,7 @@
 		  (plt->output_section->vma
 		   + plt->output_offset
 		   + h->plt.offset
-		   + 6),
+		   + elf_i386_plt_entry_offset2),
 		  gotplt->contents + got_offset);
 
       /* Fill in the entry in the .rel.plt section.  */
@@ -4458,12 +4566,12 @@
 			  (htab->elf.sgotplt->output_section->vma
 			   + htab->elf.sgotplt->output_offset
 			   + 4),
-			  htab->elf.splt->contents + 2);
+			  htab->elf.splt->contents + elf_i386_plt0_entry_offset1);
 	      bfd_put_32 (output_bfd,
 			  (htab->elf.sgotplt->output_section->vma
 			   + htab->elf.sgotplt->output_offset
 			   + 8),
-			  htab->elf.splt->contents + 8);
+			  htab->elf.splt->contents + elf_i386_plt0_entry_offset2);
 
 	      if (htab->is_vxworks)
 		{
@@ -4591,11 +4699,23 @@
   return TRUE;
 }
 
+#ifdef ELF32_NACL_C
+#define TARGET_LITTLE_SYM		bfd_elf32_nacl_vec
+#define TARGET_LITTLE_NAME		"elf32-nacl"
+/* NativeClient defines its own ABI.*/
+#undef ELF_OSABI
+#define ELF_OSABI ELFOSABI_NACL
+#else
 #define TARGET_LITTLE_SYM		bfd_elf32_i386_vec
 #define TARGET_LITTLE_NAME		"elf32-i386"
+#endif
 #define ELF_ARCH			bfd_arch_i386
 #define ELF_MACHINE_CODE		EM_386
+#ifdef ELF32_NACL_C
+#define ELF_MAXPAGESIZE			0x10000
+#else
 #define ELF_MAXPAGESIZE			0x1000
+#endif
 
 #define elf_backend_can_gc_sections	1
 #define elf_backend_can_refcount	1
@@ -4640,6 +4760,63 @@
 #undef	elf_backend_post_process_headers
 #define	elf_backend_post_process_headers	_bfd_elf_set_osabi
 
+#ifdef ELF32_NACL_C
+#define bfd_elf32_bfd_merge_private_bfd_data \
+  elf32_nacl_merge_private_bfd_data
+
+static unsigned long previous_ibfd_e_flags = (unsigned long) EF_NACL_ALIGN_LIB;
+static unsigned char previous_ibfd_abiversion = 0;
+
+static bfd_boolean
+elf32_nacl_merge_private_bfd_data (bfd *ibfd,
+                                   bfd *obfd)
+{
+  unsigned long ibfd_e_flags;
+  unsigned char ibfd_abiversion;
+
+  ibfd_e_flags = elf_elfheader (ibfd)->e_flags & EF_NACL_ALIGN_MASK;
+  if ((ibfd_e_flags != EF_NACL_ALIGN_LIB) &&
+      (previous_ibfd_e_flags != EF_NACL_ALIGN_LIB) &&
+      (ibfd_e_flags != previous_ibfd_e_flags)) {
+    (*_bfd_error_handler)
+    (_("%B: linking files with incompatible alignments"), ibfd);
+    bfd_set_error (bfd_error_bad_value);
+    return FALSE;
+  }
+
+  ibfd_abiversion = elf_elfheader (ibfd)->e_ident[EI_ABIVERSION];
+  if (ibfd_abiversion != 0 &&
+      previous_ibfd_abiversion != 0 &&
+      ibfd_abiversion != previous_ibfd_abiversion) {
+    (*_bfd_error_handler)
+    (_("%B: linking files with incompatible abi version"), ibfd);
+    bfd_set_error (bfd_error_bad_value);
+    return FALSE;
+  }
+
+  previous_ibfd_e_flags = ibfd_e_flags;
+  elf_elfheader (obfd)->e_flags |= previous_ibfd_e_flags;
+
+  previous_ibfd_abiversion = ibfd_abiversion;
+  elf_elfheader (obfd)->e_ident[EI_ABIVERSION] = previous_ibfd_abiversion;
+
+  return TRUE;
+}
+
+#define elf_backend_final_write_processing \
+  elf32_nacl_backend_final_write_processing
+
+static void
+elf32_nacl_backend_final_write_processing (bfd *abfd,
+                                           bfd_boolean linker ATTRIBUTE_UNUSED)
+{
+  elf_elfheader (abfd)->e_ident[EI_OSABI] = ELFOSABI_NACL;
+  elf_elfheader (abfd)->e_ident[EI_ABIVERSION] = EF_NACL_ABIVERSION;
+  elf_elfheader (abfd)->e_flags |= previous_ibfd_e_flags;
+}
+
+#include "elf32-target.h"
+#else
 #include "elf32-target.h"
 
 /* FreeBSD support.  */
@@ -4729,3 +4906,4 @@
 #define elf32_bed				elf32_i386_vxworks_bed
 
 #include "elf32-target.h"
+#endif
diff -Naur ../PRISTINE/binutils-2.20/bfd/elf32-nacl.c binutils-2.20/bfd/elf32-nacl.c
--- ../PRISTINE/binutils-2.20/bfd/elf32-nacl.c	1969-12-31 16:00:00.000000000 -0800
+++ binutils-2.20/bfd/elf32-nacl.c	2010-01-05 13:21:03.426216000 -0800
@@ -0,0 +1,2 @@
+#define ELF32_NACL_C
+#include "elf32-i386.c"
diff -Naur ../PRISTINE/binutils-2.20/bfd/elf64-nacl.c binutils-2.20/bfd/elf64-nacl.c
--- ../PRISTINE/binutils-2.20/bfd/elf64-nacl.c	1969-12-31 16:00:00.000000000 -0800
+++ binutils-2.20/bfd/elf64-nacl.c	2010-01-05 13:21:03.438223000 -0800
@@ -0,0 +1,2 @@
+#define ELF64_NACL_C
+#include "elf64-x86-64.c"
diff -Naur ../PRISTINE/binutils-2.20/bfd/elf64-x86-64.c binutils-2.20/bfd/elf64-x86-64.c
--- ../PRISTINE/binutils-2.20/bfd/elf64-x86-64.c	2009-09-10 04:47:12.000000000 -0700
+++ binutils-2.20/bfd/elf64-x86-64.c	2010-01-05 13:21:03.449227000 -0800
@@ -31,6 +31,10 @@
 
 #include "elf/x86-64.h"
 
+#ifdef ELF64_NACL_C
+#include "elf/nacl.h"
+#endif
+
 /* In case we're on a 32-bit machine, construct a 64-bit "-1" value.  */
 #define MINUS_ONE (~ (bfd_vma) 0)
 
@@ -372,29 +376,100 @@
 
 /* The size in bytes of an entry in the procedure linkage table.  */
 
+#ifdef ELF64_NACL_C
+#define PLT_ENTRY_SIZE 64
+#else
 #define PLT_ENTRY_SIZE 16
+#endif
 
 /* The first entry in a procedure linkage table looks like this.  See the
    SVR4 ABI i386 supplement and the x86-64 ABI to see how this works.  */
 
+#ifdef ELF64_NACL_C
+static const bfd_byte elf64_x86_64_plt0_entry[PLT_ENTRY_SIZE] =
+{
+  0xff, 0x35, 8, 0, 0, 0,	/* pushq GOT+8(%rip) */
+#define elf_x86_64_plt0_entry_offset1 2
+#define elf_x86_64_plt0_entry_instsize1 6
+  0x4c, 0x8b, 0x1d, 16, 0, 0, 0,/* movq GOT+16(%rip), %r11 */
+#define elf_x86_64_plt0_entry_offset2 9
+#define elf_x86_64_plt0_entry_instsize2 7
+  0x4d, 0x8b, 0x1b,		/* mov (%r11), %r11 */
+  0x49, 0x83, 0xe3, 0xe0,	/* andq NACLMASK, %r11 */
+  0x41, 0xff, 0xe3,		/* jmp *%r11 */
+  0xf4, 0xf4, 0xf4, 0xf4,	/* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,	/* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,	/* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,	/* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,	/* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,	/* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,	/* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,	/* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,	/* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,	/* fill with hlt instructions. */
+  0xf4				/* fill with hlt instructions. */
+};
+#else
 static const bfd_byte elf64_x86_64_plt0_entry[PLT_ENTRY_SIZE] =
 {
   0xff, 0x35, 8, 0, 0, 0,	/* pushq GOT+8(%rip)  */
+#define elf_x86_64_plt0_entry_offset1 2
+#define elf_x86_64_plt0_entry_instsize1 6
   0xff, 0x25, 16, 0, 0, 0,	/* jmpq *GOT+16(%rip) */
+#define elf_x86_64_plt0_entry_offset2 8
+#define elf_x86_64_plt0_entry_instsize2 6
   0x0f, 0x1f, 0x40, 0x00	/* nopl 0(%rax)       */
 };
+#endif
 
 /* Subsequent entries in a procedure linkage table look like this.  */
 
+#ifdef ELF64_NACL_C
+static const bfd_byte elf64_x86_64_plt_entry[PLT_ENTRY_SIZE] =
+{
+  0x4c, 0x8b, 0x1d,	    /* movq name@GOTPC(%rip), %r11 */
+#define elf_x86_64_plt_entry_offset1 3
+#define elf_x86_64_plt_entry_instsize1 7
+  0, 0, 0, 0,		    /* replaced with offset to this symbol in .got.  */
+  0x4d, 0x8b, 0x1b,	    /* mov (%r11), %r11 */
+  0x49, 0x83, 0xe3, 0xe0,   /* andq NACLMASK, %r11 */
+  0x41, 0xff, 0xe3,	    /* jmp *%r11 */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4,	    /* fill with hlt instructions. */
+#define elf_x86_64_plt_entry_offset2 32
+  0x68,			    /* pushq immediate */
+#define elf_x86_64_plt_entry_offset3 33
+  0, 0, 0, 0,		    /* replaced with index into relocation table.  */
+  0xe9,			    /* jmp relative */
+#define elf_x86_64_plt_entry_offset4 38
+  0, 0, 0, 0,		    /* replaced with offset to start of .plt0.  */
+#define elf_x86_64_plt_entry_offset5 42
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4		    /* fill with hlt instructions. */
+};
+#else
 static const bfd_byte elf64_x86_64_plt_entry[PLT_ENTRY_SIZE] =
 {
   0xff, 0x25,	/* jmpq *name@GOTPC(%rip) */
+#define elf_x86_64_plt_entry_offset1 2
+#define elf_x86_64_plt_entry_instsize1 6
   0, 0, 0, 0,	/* replaced with offset to this symbol in .got.	 */
+#define elf_x86_64_plt_entry_offset2 6
   0x68,		/* pushq immediate */
+#define elf_x86_64_plt_entry_offset3 7
   0, 0, 0, 0,	/* replaced with index into relocation table.  */
   0xe9,		/* jmp relative */
+#define elf_x86_64_plt_entry_offset4 12
   0, 0, 0, 0	/* replaced with offset to start of .plt0.  */
+#define elf_x86_64_plt_entry_offset5 16
 };
+#endif
 
 /* x86-64 ELF linker hash entry.  */
 
@@ -687,6 +762,11 @@
       || (!info->shared && !htab->srelbss))
     abort ();
 
+#ifdef ELF64_NACL_C
+  if (!bfd_set_section_alignment(dynobj, htab->elf.splt, 5))
+    return FALSE;
+#endif
+
   return TRUE;
 }
 
@@ -3791,25 +3871,28 @@
 		       - plt->output_section->vma
 		       - plt->output_offset
 		       - h->plt.offset
-		       - 6),
-		  plt->contents + h->plt.offset + 2);
+		       - elf_x86_64_plt_entry_instsize1),
+		  plt->contents + h->plt.offset + elf_x86_64_plt_entry_offset1);
 
       /* Don't fill PLT entry for static executables.  */
       if (plt == htab->elf.splt)
 	{
 	  /* Put relocation index.  */
 	  bfd_put_32 (output_bfd, plt_index,
-		      plt->contents + h->plt.offset + 7);
+		      (plt->contents + h->plt.offset
+		       + elf_x86_64_plt_entry_offset3));
 	  /* Put offset for jmp .PLT0.  */
-	  bfd_put_32 (output_bfd, - (h->plt.offset + PLT_ENTRY_SIZE),
-		      plt->contents + h->plt.offset + 12);
+	  bfd_put_32 (output_bfd,
+		      - (h->plt.offset + elf_x86_64_plt_entry_offset5),
+		      (plt->contents + h->plt.offset
+		       + elf_x86_64_plt_entry_offset4));
 	}
 
       /* Fill in the entry in the global offset table, initially this
 	 points to the pushq instruction in the PLT which is at offset 6.  */
       bfd_put_64 (output_bfd, (plt->output_section->vma
 			       + plt->output_offset
-			       + h->plt.offset + 6),
+			       + h->plt.offset + elf_x86_64_plt_entry_offset2),
 		  gotplt->contents + got_offset);
 
       /* Fill in the entry in the .rela.plt section.  */
@@ -4086,8 +4169,8 @@
 		       + 8
 		       - htab->elf.splt->output_section->vma
 		       - htab->elf.splt->output_offset
-		       - 6),
-		      htab->elf.splt->contents + 2);
+		       - elf_x86_64_plt0_entry_instsize1),
+		      htab->elf.splt->contents + elf_x86_64_plt0_entry_offset1);
 	  /* Add offset for jmp *GOT+16(%rip). The 12 is the offset to
 	     the end of the instruction.  */
 	  bfd_put_32 (output_bfd,
@@ -4096,8 +4179,9 @@
 		       + 16
 		       - htab->elf.splt->output_section->vma
 		       - htab->elf.splt->output_offset
-		       - 12),
-		      htab->elf.splt->contents + 8);
+		       - elf_x86_64_plt0_entry_instsize1
+		       - elf_x86_64_plt0_entry_instsize2),
+		      htab->elf.splt->contents + elf_x86_64_plt0_entry_offset2);
 
 	  elf_section_data (htab->elf.splt->output_section)->this_hdr.sh_entsize =
 	    PLT_ENTRY_SIZE;
@@ -4120,8 +4204,9 @@
 			   - htab->elf.splt->output_section->vma
 			   - htab->elf.splt->output_offset
 			   - htab->tlsdesc_plt
-			   - 6),
-			  htab->elf.splt->contents + htab->tlsdesc_plt + 2);
+			   - elf_x86_64_plt0_entry_instsize1),
+			  (htab->elf.splt->contents + htab->tlsdesc_plt
+			   + elf_x86_64_plt0_entry_offset1));
 	      /* Add offset for jmp *GOT+TDG(%rip), where TGD stands for
 		 htab->tlsdesc_got. The 12 is the offset to the end of
 		 the instruction.  */
@@ -4132,8 +4217,10 @@
 			   - htab->elf.splt->output_section->vma
 			   - htab->elf.splt->output_offset
 			   - htab->tlsdesc_plt
-			   - 12),
-			  htab->elf.splt->contents + htab->tlsdesc_plt + 8);
+			   - elf_x86_64_plt0_entry_instsize1
+			   - elf_x86_64_plt0_entry_instsize2),
+			  (htab->elf.splt->contents + htab->tlsdesc_plt
+			   + elf_x86_64_plt0_entry_offset2));
 	    }
 	}
     }
@@ -4397,13 +4484,26 @@
   { NULL,	                0,          0, 0,            0 }
 };
 
+#ifdef ELF64_NACL_C
+#define TARGET_LITTLE_SYM		    bfd_elf64_nacl_vec
+#define TARGET_LITTLE_NAME		    "elf64-nacl"
+/* NativeClient defines its own ABI.*/
+#undef ELF_OSABI
+#define ELF_OSABI ELFOSABI_NACL
+#else
 #define TARGET_LITTLE_SYM		    bfd_elf64_x86_64_vec
 #define TARGET_LITTLE_NAME		    "elf64-x86-64"
+#endif
 #define ELF_ARCH			    bfd_arch_i386
 #define ELF_MACHINE_CODE		    EM_X86_64
 #define ELF_MAXPAGESIZE			    0x200000
+#ifdef ELF64_NACL_C
+#define ELF_MINPAGESIZE			    0x10000
+#define ELF_COMMONPAGESIZE		    0x10000
+#else
 #define ELF_MINPAGESIZE			    0x1000
 #define ELF_COMMONPAGESIZE		    0x1000
+#endif
 
 #define elf_backend_can_gc_sections	    1
 #define elf_backend_can_refcount	    1
@@ -4470,6 +4570,63 @@
 #undef  elf_backend_post_process_headers
 #define elf_backend_post_process_headers  _bfd_elf_set_osabi
 
+#ifdef ELF64_NACL_C
+#define bfd_elf64_bfd_merge_private_bfd_data \
+  elf64_nacl_merge_private_bfd_data
+
+static unsigned long previous_ibfd_e_flags = (unsigned long) EF_NACL_ALIGN_LIB;
+static unsigned char previous_ibfd_abiversion = 0;
+
+static bfd_boolean
+elf64_nacl_merge_private_bfd_data (bfd *ibfd,
+                                   bfd *obfd)
+{
+  unsigned long ibfd_e_flags;
+  unsigned char ibfd_abiversion;
+
+  ibfd_e_flags = elf_elfheader (ibfd)->e_flags & EF_NACL_ALIGN_MASK;
+  if ((ibfd_e_flags != EF_NACL_ALIGN_LIB) &&
+      (previous_ibfd_e_flags != EF_NACL_ALIGN_LIB) &&
+      (ibfd_e_flags != previous_ibfd_e_flags)) {
+    (*_bfd_error_handler)
+    (_("%B: linking files with incompatible alignments"), ibfd);
+    bfd_set_error (bfd_error_bad_value);
+    return FALSE;
+  }
+
+  ibfd_abiversion = elf_elfheader (ibfd)->e_ident[EI_ABIVERSION];
+  if (ibfd_abiversion != 0 &&
+      previous_ibfd_abiversion != 0 &&
+      ibfd_abiversion != previous_ibfd_abiversion) {
+    (*_bfd_error_handler)
+    (_("%B: linking files with incompatible abi version"), ibfd);
+    bfd_set_error (bfd_error_bad_value);
+    return FALSE;
+  }
+
+  previous_ibfd_e_flags = ibfd_e_flags;
+  elf_elfheader (obfd)->e_flags |= previous_ibfd_e_flags;
+
+  previous_ibfd_abiversion = ibfd_abiversion;
+  elf_elfheader (obfd)->e_ident[EI_ABIVERSION] = previous_ibfd_abiversion;
+
+  return TRUE;
+}
+
+#define elf_backend_final_write_processing \
+  elf64_nacl_backend_final_write_processing
+
+static void
+elf64_nacl_backend_final_write_processing (bfd *abfd,
+                                           bfd_boolean linker ATTRIBUTE_UNUSED)
+{
+  elf_elfheader (abfd)->e_ident[EI_OSABI] = ELFOSABI_NACL;
+  elf_elfheader (abfd)->e_ident[EI_ABIVERSION] = EF_NACL_ABIVERSION;
+  elf_elfheader (abfd)->e_flags |= previous_ibfd_e_flags;
+}
+
+#include "elf64-target.h"
+#else
 #include "elf64-target.h"
 
 /* FreeBSD support.  */
@@ -4536,3 +4693,4 @@
 #define elf_backend_post_process_headers  _bfd_elf_set_osabi
 
 #include "elf64-target.h"
+#endif
diff -Naur ../PRISTINE/binutils-2.20/bfd/targets.c binutils-2.20/bfd/targets.c
--- ../PRISTINE/binutils-2.20/bfd/targets.c	2009-09-10 04:47:13.000000000 -0700
+++ binutils-2.20/bfd/targets.c	2010-01-05 13:21:03.456214000 -0800
@@ -630,6 +630,7 @@
 extern const bfd_target bfd_elf32_mn10300_vec;
 extern const bfd_target bfd_elf32_mt_vec;
 extern const bfd_target bfd_elf32_msp430_vec;
+extern const bfd_target bfd_elf32_nacl_vec;
 extern const bfd_target bfd_elf32_nbigmips_vec;
 extern const bfd_target bfd_elf32_nlittlemips_vec;
 extern const bfd_target bfd_elf32_ntradbigmips_vec;
@@ -684,6 +685,7 @@
 extern const bfd_target bfd_elf64_little_generic_vec;
 extern const bfd_target bfd_elf64_littlemips_vec;
 extern const bfd_target bfd_elf64_mmix_vec;
+extern const bfd_target bfd_elf64_nacl_vec;
 extern const bfd_target bfd_elf64_powerpc_vec;
 extern const bfd_target bfd_elf64_powerpcle_vec;
 extern const bfd_target bfd_elf64_s390_vec;
diff -Naur ../PRISTINE/binutils-2.20/binutils/readelf.c binutils-2.20/binutils/readelf.c
--- ../PRISTINE/binutils-2.20/binutils/readelf.c	2009-09-22 08:40:59.000000000 -0700
+++ binutils-2.20/binutils/readelf.c	2010-01-05 13:21:03.490215000 -0800
@@ -2462,6 +2462,7 @@
     case ELFOSABI_AROS:		return "AROS";
     case ELFOSABI_STANDALONE:	return _("Standalone App");
     case ELFOSABI_ARM:		return "ARM";
+    case ELFOSABI_NACL:		return "NativeClient";
     default:
       snprintf (buff, sizeof (buff), _("<unknown: %x>"), osabi);
       return buff;
diff -Naur ../PRISTINE/binutils-2.20/config.sub binutils-2.20/config.sub
--- ../PRISTINE/binutils-2.20/config.sub	2009-08-16 21:10:29.000000000 -0700
+++ binutils-2.20/config.sub	2010-01-05 13:21:03.496225000 -0800
@@ -314,6 +314,14 @@
 	i*86 | x86_64)
 	  basic_machine=$basic_machine-pc
 	  ;;
+	nacl64*)
+	  basic_machine=x86_64-pc
+	  os=-nacl
+	  ;;
+	nacl*)
+	  basic_machine=i686-pc
+	  os=-nacl
+	  ;;
 	# Object if more than one company name word.
 	*-*-*)
 		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
@@ -1305,6 +1313,9 @@
 			;;
 		esac
 		;;
+	-nacl*)
+		os=-nacl
+		;;
 	-nto-qnx*)
 		;;
 	-nto*)
diff -Naur ../PRISTINE/binutils-2.20/gas/Makefile.in binutils-2.20/gas/Makefile.in
--- ../PRISTINE/binutils-2.20/gas/Makefile.in	2009-09-07 05:09:27.000000000 -0700
+++ binutils-2.20/gas/Makefile.in	2010-01-05 13:21:03.507225000 -0800
@@ -341,6 +341,7 @@
 	mn10300 \
 	msp430 \
 	mt \
+	nacl \
 	ns32k \
 	openrisc \
 	or32 \
@@ -542,6 +543,7 @@
 	config/tc-moxie.c \
 	config/tc-msp430.c \
 	config/tc-mt.c \
+	config/tc-nacl.c \
 	config/tc-ns32k.c \
 	config/tc-openrisc.c \
 	config/tc-or32.c \
@@ -604,6 +606,7 @@
 	config/tc-mn10300.h \
 	config/tc-msp430.h \
 	config/tc-mt.h \
+	config/tc-nacl.h \
 	config/tc-ns32k.h \
 	config/tc-openrisc.h \
 	config/tc-or32.h \
@@ -983,6 +986,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-moxie.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-msp430.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-mt.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-nacl.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-ns32k.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-openrisc.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-or32.Po@am__quote@
@@ -1562,6 +1566,20 @@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-mt.obj `if test -f 'config/tc-mt.c'; then $(CYGPATH_W) 'config/tc-mt.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-mt.c'; fi`
 
+tc-nacl.o: config/tc-nacl.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT tc-nacl.o -MD -MP -MF $(DEPDIR)/tc-nacl.Tpo -c -o tc-nacl.o `test -f 'config/tc-nacl.c' || echo '$(srcdir)/'`config/tc-nacl.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/tc-nacl.Tpo $(DEPDIR)/tc-nacl.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='config/tc-nacl.c' object='tc-nacl.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-nacl.o `test -f 'config/tc-nacl.c' || echo '$(srcdir)/'`config/tc-nacl.c
+
+tc-nacl.obj: config/tc-nacl.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT tc-nacl.obj -MD -MP -MF $(DEPDIR)/tc-nacl.Tpo -c -o tc-nacl.obj `if test -f 'config/tc-nacl.c'; then $(CYGPATH_W) 'config/tc-nacl.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-nacl.c'; fi`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/tc-nacl.Tpo $(DEPDIR)/tc-nacl.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='config/tc-nacl.c' object='tc-nacl.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-nacl.obj `if test -f 'config/tc-nacl.c'; then $(CYGPATH_W) 'config/tc-nacl.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-nacl.c'; fi`
+
 tc-ns32k.o: config/tc-ns32k.c
 @am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT tc-ns32k.o -MD -MP -MF $(DEPDIR)/tc-ns32k.Tpo -c -o tc-ns32k.o `test -f 'config/tc-ns32k.c' || echo '$(srcdir)/'`config/tc-ns32k.c
 @am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/tc-ns32k.Tpo $(DEPDIR)/tc-ns32k.Po
diff -Naur ../PRISTINE/binutils-2.20/gas/config/tc-i386-intel.c binutils-2.20/gas/config/tc-i386-intel.c
--- ../PRISTINE/binutils-2.20/gas/config/tc-i386-intel.c	2009-09-14 04:43:27.000000000 -0700
+++ binutils-2.20/gas/config/tc-i386-intel.c	2010-01-05 13:21:03.548213000 -0800
@@ -559,7 +559,7 @@
 	  else if (!got_a_float)
 	    {
 	      if (flag_code == CODE_16BIT)
-		add_prefix (DATA_PREFIX_OPCODE);
+		add_prefix (DATA_PREFIX_OPCODE, 1);
 	      suffix = LONG_DOUBLE_MNEM_SUFFIX;
 	    }
 	  else
diff -Naur ../PRISTINE/binutils-2.20/gas/config/tc-i386.c binutils-2.20/gas/config/tc-i386.c
--- ../PRISTINE/binutils-2.20/gas/config/tc-i386.c	2009-09-14 04:43:27.000000000 -0700
+++ binutils-2.20/gas/config/tc-i386.c	2010-01-05 13:21:03.560238000 -0800
@@ -33,6 +33,9 @@
 #include "dwarf2dbg.h"
 #include "dw2gencfi.h"
 #include "elf/x86-64.h"
+#ifdef TC_NACL_C
+#include "elf/nacl.h"
+#endif
 #include "opcodes/i386-init.h"
 
 #ifndef REGISTER_WARNINGS
@@ -178,6 +181,7 @@
 #if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
 static void handle_large_common (int small ATTRIBUTE_UNUSED);
 #endif
+static void nativeclient_symbol_init (void);
 
 static const char *default_arch = DEFAULT_ARCH;
 
@@ -243,6 +247,13 @@
        explicit segment overrides are given.  */
     const seg_entry *seg[2];
 
+#ifdef TC_NACL_C
+    /* NaCl-style truncation for data accesses: if the %nacl prefix is used for
+       an address it means the index register should be truncated to 32bit.
+       Base register is untouched. */
+    char nacl_truncate[2];
+#endif
+
     /* PREFIX holds all the given prefix opcodes (usually null).
        PREFIXES is the number of prefix opcodes.  */
     unsigned int prefixes;
@@ -454,6 +465,14 @@
 /* The dwarf2 data alignment, adjusted for 32 or 64 bit.  */
 int x86_cie_data_alignment;
 
+/* NativeClient support */
+
+/* Default alignment.  0=OFF */
+int nacl_alignment = NACL_ALIGN_POW2;
+
+/* Use library mode.  0=OFF */
+int nacl_library_mode = 0;
+
 /* Interface to relax_segment.
    There are 3 major relax states for 386 jump insns because the
    different types of jumps add different sizes to frags when we're
@@ -1056,7 +1075,7 @@
 	    }
 	}
 
-      if (patt == f32_patt)
+      if (patt == f32_patt || !optimize_align_code)
 	{
 	  /* If the padding is less than 15 bytes, we use the normal
 	     ones.  Otherwise, we use a jump instruction and adjust
@@ -1782,7 +1801,7 @@
    class already exists, 1 if non rep/repne added, 2 if rep/repne
    added.  */
 static int
-add_prefix (unsigned int prefix)
+add_prefix (unsigned int prefix, int duplicate_are_errors)
 {
   int ret = 1;
   unsigned int q;
@@ -1842,7 +1861,7 @@
 	++i.prefixes;
       i.prefix[q] |= prefix;
     }
-  else
+  else if (duplicate_are_errors)
     as_bad (_("same type of prefix used twice"));
 
   return ret;
@@ -2117,6 +2136,34 @@
   else
     as_fatal (_("Unknown architecture"));
 }
+
+void
+nativeclient_symbol_init ()
+{
+  symbolS *symbolP;
+  int entry_align;
+
+  /*
+   * A symbol conveying the setting of nacl_alignment to assembler writers.
+   */
+  symbolP = symbol_new ("NACLALIGN", absolute_section,
+			(valueT) nacl_alignment, &zero_address_frag);
+  symbol_table_insert (symbolP);
+
+  /*
+   * A symbol conveying the function entry alignment.  This differs from
+   * NACLALIGN in library mode.
+   */
+  if (nacl_library_mode) {
+    entry_align = 5;
+  }
+  else {
+    entry_align = nacl_alignment;
+  }
+  symbolP = symbol_new ("NACLENTRYALIGN", absolute_section,
+			(valueT) entry_align, &zero_address_frag);
+  symbol_table_insert (symbolP);
+}
 
 void
 md_begin ()
@@ -2234,7 +2281,11 @@
 #if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
   if (IS_ELF)
     {
+#ifdef TC_NACL_C
+      record_alignment (text_section, nacl_alignment);
+#else
       record_alignment (text_section, 2);
+#endif
       record_alignment (data_section, 2);
       record_alignment (bss_section, 2);
     }
@@ -2250,6 +2301,8 @@
       x86_dwarf2_return_column = 8;
       x86_cie_data_alignment = -4;
     }
+
+  nativeclient_symbol_init ();
 }
 
 void
@@ -2799,6 +2852,11 @@
    machine dependent instruction.  This function is supposed to emit
    the frags/bytes it assembles to.  */
 
+/* Sometimes we defer processing of "prefix" command to correctly combine them.
+   If this varible is not zero then we already have initialized information in
+   "i" and should not clean it */
+int single_standalone_prefix = 0;
+
 void
 md_assemble (char *line)
 {
@@ -2807,7 +2865,8 @@
   const insn_template *t;
 
   /* Initialize globals.  */
-  memset (&i, '\0', sizeof (i));
+  if (!single_standalone_prefix)
+    memset (&i, '\0', sizeof (i));
   for (j = 0; j < MAX_OPERANDS; j++)
     i.reloc[j] = NO_RELOC;
   memset (disp_expressions, '\0', sizeof (disp_expressions));
@@ -2819,7 +2878,7 @@
      start of a (possibly prefixed) mnemonic.  */
 
   line = parse_insn (line, mnemonic);
-  if (line == NULL)
+  if (line == NULL || single_standalone_prefix)
     return;
 
   line = parse_operands (line, mnemonic);
@@ -2897,7 +2956,7 @@
     }
 
   if (i.tm.opcode_modifier.fwait)
-    if (!add_prefix (FWAIT_OPCODE))
+    if (!add_prefix (FWAIT_OPCODE, 1))
       return;
 
   /* Check string instruction segment overrides.  */
@@ -3012,7 +3071,7 @@
     }
 
   if (i.rex != 0)
-    add_prefix (REX_OPCODE | i.rex);
+    add_prefix (REX_OPCODE | i.rex, 1);
 
   /* We are ready to output the insn.  */
   output_insn ();
@@ -3027,6 +3086,8 @@
   int supported;
   const insn_template *t;
   char *dot_p = NULL;
+  single_standalone_prefix = 0;
+  int standalone_prefix;
 
   /* Non-zero if we found a prefix only acceptable with string insns.  */
   const char *expecting_string_instruction = NULL;
@@ -3068,11 +3129,11 @@
       /* Look up instruction (or prefix) via hash table.  */
       current_templates = (const templates *) hash_find (op_hash, mnemonic);
 
-      if (*l != END_OF_INSN
-	  && (!is_space_char (*l) || l[1] != END_OF_INSN)
-	  && current_templates
+      if (current_templates
 	  && current_templates->start->opcode_modifier.isprefix)
 	{
+	  standalone_prefix = (*l == END_OF_INSN)
+			      || (is_space_char (*l) && l[1] == END_OF_INSN);
 	  if (!cpu_flags_check_cpu64 (current_templates->start->cpu_flags))
 	    {
 	      as_bad ((flag_code != CODE_64BIT
@@ -3083,7 +3144,8 @@
 	    }
 	  /* If we are in 16-bit mode, do not allow addr16 or data16.
 	     Similarly, in 32-bit mode, do not allow addr32 or data32.  */
-	  if ((current_templates->start->opcode_modifier.size16
+	  if (!standalone_prefix
+	      && (current_templates->start->opcode_modifier.size16
 	       || current_templates->start->opcode_modifier.size32)
 	      && flag_code != CODE_64BIT
 	      && (current_templates->start->opcode_modifier.size32
@@ -3093,17 +3155,35 @@
 		      current_templates->start->name);
 	      return NULL;
 	    }
-	  /* Add prefix, checking for repeated prefixes.  */
-	  switch (add_prefix (current_templates->start->base_opcode))
+	  if (standalone_prefix)
 	    {
-	    case 0:
-	      return NULL;
-	    case 2:
-	      expecting_string_instruction = current_templates->start->name;
+	      /* Add prefix, checking for repeated prefixes.  */
+	      switch (add_prefix (current_templates->start->base_opcode, 0))
+		{
+		  /* Duplicated prefix - process as standalone instruction */
+		  case 0:
+		    return l;
+		  case 1:
+		  case 2:
+		    single_standalone_prefix = 1;
+		    break;
+		}
 	      break;
 	    }
-	  /* Skip past PREFIX_SEPARATOR and reset token_start.  */
-	  token_start = ++l;
+	  else
+	    {
+	      /* Add prefix, checking for repeated prefixes.  */
+	      switch (add_prefix (current_templates->start->base_opcode, 1))
+		{
+		  case 0:
+		    return NULL;
+		  case 2:
+		    expecting_string_instruction = current_templates->start->name;
+		    break;
+		}
+	      /* Skip past PREFIX_SEPARATOR and reset token_start.  */
+	      token_start = ++l;
+	    }
 	}
       else
 	break;
@@ -3183,13 +3263,13 @@
 	{
 	  if (l[2] == 't')
 	    {
-	      if (!add_prefix (DS_PREFIX_OPCODE))
+	      if (!add_prefix (DS_PREFIX_OPCODE, 1))
 		return NULL;
 	      l += 3;
 	    }
 	  else if (l[2] == 'n')
 	    {
-	      if (!add_prefix (CS_PREFIX_OPCODE))
+	      if (!add_prefix (CS_PREFIX_OPCODE, 1))
 		return NULL;
 	      l += 3;
 	    }
@@ -3416,6 +3496,12 @@
   if (i.mem_operands == 2)
     {
       const seg_entry *temp_seg;
+#ifdef TC_NACL_C
+      char nacl_truncate;
+      nacl_truncate = i.nacl_truncate[0];
+      i.nacl_truncate[0] = i.nacl_truncate[1];
+      i.nacl_truncate[1] = nacl_truncate;
+#endif
       temp_seg = i.seg[0];
       i.seg[0] = i.seg[1];
       i.seg[1] = temp_seg;
@@ -4250,7 +4336,7 @@
 	       && i.op->regs[0].reg_type.bitfield.reg16)
 	      || (flag_code != CODE_32BIT
 		  && i.op->regs[0].reg_type.bitfield.reg32))
-	    if (!add_prefix (ADDR_PREFIX_OPCODE))
+	    if (!add_prefix (ADDR_PREFIX_OPCODE, 1))
 	      return 0;
 	}
       else if (i.suffix != QWORD_MNEM_SUFFIX
@@ -4266,7 +4352,7 @@
 	  if (i.tm.opcode_modifier.jumpbyte) /* jcxz, loop */
 	    prefix = ADDR_PREFIX_OPCODE;
 
-	  if (!add_prefix (prefix))
+	  if (!add_prefix (prefix, 1))
 	    return 0;
 	}
 
@@ -4320,6 +4406,12 @@
       if (i.tm.base_opcode == 0xf20f38f0)
 	continue;
 
+      if (op == 2 && i.tm.opcode_modifier.isstring)
+        /* Native client string instruction: sandbox register is always 64bit */
+        {
+	  continue;
+        }
+
       if ((i.types[op].bitfield.reg16
 	   || i.types[op].bitfield.reg32
 	   || i.types[op].bitfield.reg64)
@@ -4850,7 +4942,7 @@
      always be used.  */
   if ((i.seg[0]) && (i.seg[0] != default_seg))
     {
-      if (!add_prefix (i.seg[0]->seg_prefix))
+      if (!add_prefix (i.seg[0]->seg_prefix, 1))
 	return 0;
     }
   return 1;
@@ -5048,7 +5140,7 @@
 	      && !i.types[1].bitfield.control)
 	    abort ();
 	  i.rex &= ~(REX_R | REX_B);
-	  add_prefix (LOCK_PREFIX_OPCODE);
+	  add_prefix (LOCK_PREFIX_OPCODE, 1);
 	}
     }
   else
@@ -5560,19 +5652,264 @@
 }
 
 static void
+insert_sandbox_jmp (void)
+{
+  char* p;
+  int align_mask = (1 << nacl_alignment) - 1;
+
+  if (getenv("NACL_DEBUG_ALIGN")) {
+    if (i.rex & REX_B) {
+      p = frag_more (12);
+      p[0] = 0x40 | (i.rex & REX_B);
+      p[1] = 0xF7; p[2] = 0xC0 + i.rm.regmem; // TEST reg, align_mask
+      p[3] = align_mask; p[4] = p[5] = p[6] = 0x00;
+      p[7] = 0x74; p[8] = 0x03; // JZ +3
+      p[9] = 0xCC;
+      p[10] = 0x66; p[11] = 0x90; // NOP
+    } else {
+      p = frag_more (12);
+      p[0] = 0xF7; p[1] = 0xC0 + i.rm.regmem;
+      p[2] = align_mask; p[3] = p[4] = p[5] = 0x00; // TEST reg, align_mask
+      p[6] = 0x74; p[7] = 0x04; // JZ +4
+      p[8] = 0xCC; // INT3
+      p[9] = 0x66; p[10] = 0x66; p[11] = 0x90; // NOP
+    }
+  }
+  else {
+    if (i.rex & REX_B) {
+      p = frag_more (4);
+      p[0] = 0x40 | (i.rex & REX_B);
+      p[1] = 0x83; // AND instruction
+      p[2] = (0xe0 + i.rm.regmem); // mod = 11, reg = 100,  rm = i.rm.regmem
+#ifdef TC_NACL_C
+      p[3] = 0xff & ~align_mask;
+#else
+      p[3] = 0xff;
+#endif
+    } else {
+      p = frag_more (3);
+      p[0] = 0x83; // AND instruction.
+      p[1] = (0xe0 + i.rm.regmem); // mod = 11, reg = 100,  rm = i.rm.regmem
+#ifdef TC_NACL_C
+      p[2] = 0xff & ~align_mask;
+#else
+      p[2] = 0xff;
+#endif
+    }
+    if (i.operands == 2) {
+      p = frag_more (3);
+      p[0] = 0x48 | ((i.rex & REX_B) ? REX_B : 0)
+		  | ((i.rex & REX_R) ? REX_R : 0);
+      p[1] = 0x01;
+      p[2] = 0xc0 | i.rm.regmem | (i.rm.reg << 3);
+      // Clear %rbase from call
+      i.rex &= ~(REX_W | REX_R);
+      if (!i.rex && i.prefix[REX_PREFIX]) {
+        i.prefix[REX_PREFIX] = 0;
+        i.prefixes--;
+      } else {
+        i.prefix[REX_PREFIX] &= ~(REX_W | REX_R);
+      }
+      i.rm.reg = i.tm.extension_opcode;
+      i.operands = 1;
+      i.reg_operands = 1;
+    }
+  }
+}
+
+
+static void
+insert_sandbox_memory_access (void)
+{
+  char *p;
+  if (i.tm.opcode_modifier.isstring)
+    {
+      /* String operations can include two sandbox prefixes */
+      int mem_op = operand_type_check (i.types[0], anymem) ? 0 : 1;
+      if ((i.nacl_truncate[0] && !i.tm.operand_types[mem_op].bitfield.esseg)
+          || (i.nacl_truncate[1] && !i.tm.operand_types[mem_op+1].bitfield.esseg))
+	{
+	  p = frag_more (6);
+	  p[0] = 0x89; // MOV %ESI, %ESI instruction
+	  p[1] = 0xf6;
+	  p[2] = 0x48 | (i.op[2].regs->reg_flags & RegRex); // REX prefix
+	  p[3] = 0x8d; // LEA (%RXX,%RSI),%RSI instruction
+	  p[4] = 0x34;
+	  p[5] = 0x30 | i.op[2].regs->reg_num;
+	}
+      if ((i.nacl_truncate[0] && i.tm.operand_types[mem_op].bitfield.esseg)
+          || (i.nacl_truncate[1] && i.tm.operand_types[mem_op+1].bitfield.esseg))
+	{
+	  p = frag_more (6);
+	  p[0] = 0x89; // MOV %EDI, %EDI instruction
+	  p[1] = 0xff;
+	  p[2] = 0x48 | (i.op[2].regs->reg_flags & RegRex); // REX prefix
+	  p[3] = 0x8d; // LEA (%RXX,%RDI),%RDI instruction
+	  p[4] = 0x3c;
+	  p[5] = 0x38 | i.op[2].regs->reg_num;
+	}
+    }
+  else
+    {
+      /* Normal instruction can only include one sandbox prefix */
+      if (i.nacl_truncate[0])
+	{
+	  if (i.rex & REX_X)
+	    {
+	      p = frag_more (3);
+	      p[0] = 0x45;
+	      p[1] = 0x89; // MOV instruction
+	      p[2] = (0xc0 + i.sib.index + (i.sib.index << 3));
+	    }
+	  else
+	    {
+	      p = frag_more (2);
+	      p[0] = 0x89; // MOV instruction.
+	      p[1] = (0xc0 + i.sib.index + (i.sib.index << 3));
+	    }
+	}
+    }
+}
+
+
+static int imm_size (unsigned int n);
+
+static void
+insert_sp_adjust_sandbox_code (offsetT insn_start_off)
+{
+  char *p = frag_more (2);
+  p[0] = 0x8d; // LEA off(%rbp), %esp
+  if (imm_size(0) == 1)
+    p[1] = 0x65; // Off8
+  else
+    p[1] = 0xa5; // Off32
+  output_imm (frag_now, insn_start_off);
+  // Immediate was already used.
+  i.imm_operands = 0;
+  // Second operand is SP
+  i.rm.regmem = 4;
+}
+
+static void
+insert_xp_sandbox_code(unsigned int regN, unsigned int cmd_2reg,
+		       unsigned int cmd_imm, offsetT insn_start_off)
+{
+  char *p;
+  unsigned int need_rex = !!(i.rex & (REX_B | REX_X));
+  if (i.reg_operands == 2)
+    {
+      p = frag_more (2 + need_rex);
+      if (need_rex)
+	p[0] = 0x44;
+      p[0 + need_rex] = cmd_2reg; // CMD %eXX, %esp
+      p[1 + need_rex] = regN/*ExP*/ << 0 | (i.rm.regmem << 3) | 0xc0;
+      i.prefix[REX_PREFIX] &= ~REX_B;
+      // Second operand is regN(ExP)
+      i.rm.regmem = regN/*ExP*/;
+      // Mode is always reg-to-reg
+      i.rm.mode = 3;
+    }
+  else if (i.imm_operands == 0)
+    {
+      unsigned int need_sib =
+        i.rm.regmem == ESCAPE_TO_TWO_BYTE_ADDRESSING
+        && i.rm.mode != 3
+        && !(i.base_reg && i.base_reg->reg_type.bitfield.reg16);
+      unsigned int need_addr32 = !!i.prefix[ADDR_PREFIX];
+      p = frag_more (2 + need_sib + need_rex + need_addr32);
+      if (need_addr32)
+	{
+	  --i.prefixes;
+	  i.prefix[ADDR_PREFIX] = 0;
+	  p[0] = 0x67;
+	}
+      if (need_rex)
+        p[0 + need_addr32] = i.prefix[REX_PREFIX] & ~(REX_R | REX_W);
+      p[0 + need_addr32 + need_rex] = cmd_2reg | 2; // CMD XXX(XXX,XXX,X),%eYY
+      p[1 + need_addr32 + need_rex] =
+	(i.rm.regmem << 0 | regN/*ExP*/ << 3 | i.rm.mode << 6);
+      if (need_sib)
+        p[2 + need_addr32 + need_rex] =
+	  (i.sib.base << 0 | i.sib.index << 3 | i.sib.scale << 6);
+      if (i.disp_operands)
+        output_disp (frag_now, insn_start_off);
+      // Some bits from REX prefix are already used
+      i.rex &= ~(REX_B | REX_X);
+      i.prefix[REX_PREFIX] &= ~(REX_B | REX_X);
+      // i.prefix[ADDR_PREFIX] was already used
+      i.prefix[ADDR_PREFIX] = 0;
+      // Second operand is regN(ExP)
+      i.rm.regmem = regN/*ExP*/;
+      // Mode is always reg-to-reg
+      i.rm.mode = 3;
+      // We've already used disp
+      i.disp_operands = 0;
+    }
+  else
+    {
+      p = frag_more (2);
+      if (imm_size (0) == 1)
+	p[0] = 0x83; // CMD imm8, %regN(ExP)
+      else
+	p[0] = 0x81; // CMD imm32, %regX(ExP)
+      p[1] = cmd_imm;
+      output_imm (frag_now, insn_start_off);
+      // Second operand is regN(ExP)
+      i.rm.regmem = regN/*ExP*/;
+      // Mode is always reg-to-reg
+      i.rm.mode = 3;
+      // Immediate was already used
+      i.imm_operands = 0;
+    }
+}
+
+static int
+frag_is_a_call (void)
+{
+  if (i.tm.base_opcode == 0xe8) {
+    // direct calls
+    return 1;
+  }
+  else if (i.tm.base_opcode == 0xff) {
+    // possibly indirect calls
+    return (i.rm.mode == 3) && (i.rm.reg == 2);
+  }
+  else {
+    return 0;
+  }
+}
+
+static void
 output_insn (void)
 {
   fragS *insn_start_frag;
   offsetT insn_start_off;
 
+  // Frag_align_code sets the alignment on the current fragment and may
+  // create a new one.  Because of this we remember the current fragment
+  // before calling frag_align_code.
+  insn_start_frag = frag_now;
+
+  if (nacl_alignment > 0) {
+    frag_align_code (0, 0);
+  }
+
   /* Tie dwarf2 debug info to the address at the start of the insn.
      We can't do this after the insn has been output as the current
      frag may have been closed off.  eg. by frag_var.  */
   dwarf2_emit_insn (0);
 
-  insn_start_frag = frag_now;
   insn_start_off = frag_now_fix ();
 
+  if (nacl_alignment > 0) {
+    if (!strcmp(i.tm.name, "naclcall")) {
+      insert_sandbox_jmp ();
+    }
+    else if (!strcmp(i.tm.name, "nacljmp")) {
+      insert_sandbox_jmp ();
+    }
+  }
+
   /* Output jumps.  */
   if (i.tm.opcode_modifier.jump)
     output_branch ();
@@ -5612,10 +5949,10 @@
 		      if (prefix != REPE_PREFIX_OPCODE
 			  || (i.prefix[LOCKREP_PREFIX]
 			      != REPE_PREFIX_OPCODE))
-			add_prefix (prefix);
+			add_prefix (prefix, 1);
 		    }
 		  else
-		    add_prefix (prefix);
+		    add_prefix (prefix, 1);
 		}
 	      break;
 	    case 1:
@@ -5624,6 +5961,31 @@
 	      abort ();
 	    }
 
+#ifdef TC_NACL_C
+	  /* First output NaCl "prefix" */
+          insert_sandbox_memory_access ();
+#endif
+
+          /* Special instructions */
+	  if (!strcmp(i.tm.name, "naclasp"))
+	    /*                    esp   add   add
+				        reg   imm  */
+	    insert_xp_sandbox_code (4, 0x01, 0xc4, insn_start_off);
+	  else if (!strcmp(i.tm.name, "naclssp"))
+	    /*                    esp   sub   sub
+				        reg   imm  */
+	    insert_xp_sandbox_code (4, 0x29, 0xec, insn_start_off);
+	  else if (!strcmp(i.tm.name, "naclspadj"))
+	    insert_sp_adjust_sandbox_code (insn_start_off);
+	  else if (!strcmp(i.tm.name, "naclrestbp"))
+	    /*                    ebp   mov   mov
+				        reg   imm  */
+	    insert_xp_sandbox_code (5, 0x89, 0xbc, insn_start_off);
+	  else if (!strcmp(i.tm.name, "naclrestsp"))
+	    /*                    esp   mov   mov
+				        reg   imm  */
+	    insert_xp_sandbox_code (4, 0x89, 0xbc, insn_start_off);
+
 	  /* The prefix bytes.  */
 	  for (j = ARRAY_SIZE (i.prefix), q = i.prefix; j > 0; j--, q++)
 	    if (*q)
@@ -5700,10 +6062,18 @@
 	}
 
       if (i.disp_operands)
+#ifdef TC_NACL_C
+	output_disp (frag_now, insn_start_off);
+#else
 	output_disp (insn_start_frag, insn_start_off);
+#endif
 
       if (i.imm_operands)
+#ifdef TC_NACL_C
+	output_imm (frag_now, insn_start_off);
+#else
 	output_imm (insn_start_frag, insn_start_off);
+#endif
     }
 
 #ifdef DEBUG386
@@ -5712,6 +6082,74 @@
       pi ("" /*line*/, &i);
     }
 #endif /* DEBUG386  */
+  /*
+   * We want to make sure no instruction straddles a (1 << nacl_alignment)
+   * boundary.  We do this by setting the fragment alignment to
+   * (1 << nacl_alignment), but allowing no more than the size of the
+   * instruction as fill.
+   */
+  if (nacl_alignment > 0) {
+    int align_base;
+    int call_align;
+    int instrsize = (int) frag_now_fix ();
+
+    /*
+     * "library mode" enables compatible library builds for either 16 or
+     * 32 byte alignment.  Using the strictest alignment requirement for
+     * instructions makes them 0mod16 aligned.  Calls need to end a 32 byte
+     * region.
+     */
+    if (nacl_library_mode) {
+      align_base = 4;
+      call_align = 5;
+    }
+    else {
+      align_base = nacl_alignment;
+      call_align = nacl_alignment;
+    }
+
+    switch (instrsize) {
+      case 0:
+        // We get zero size for jump instructions.  Go to their biggest.
+        insn_start_frag->fr_offset = align_base;
+        insn_start_frag->fr_subtype = 5;
+        break;
+
+      case 1:
+        if ((i.tm.base_opcode == 0xf3) || (i.tm.base_opcode == 0xf2) ||
+            (i.tm.base_opcode == 0xf0)) {
+          // rep and lock refixes are treated as separate instructions.
+          // I don't know any other patch but to force an alignment to 0,
+          // i.e., waste as many bytes as it takes.
+          insn_start_frag->fr_offset = align_base;
+          insn_start_frag->fr_subtype = 0;
+        }
+        else {
+          // Don't align other one-byte instructions.
+          insn_start_frag->fr_offset = 0;
+          insn_start_frag->fr_subtype = 0;
+        }
+        break;
+
+      default:
+        // Don't use more than size-1 bytes to pad.
+        insn_start_frag->fr_offset = align_base;
+        insn_start_frag->fr_subtype = instrsize-1;
+        break;
+    }
+
+
+    /*
+     * Calls need to fall at the end of a (1 << call_align) region.  We
+     * make sure there are no instructions after the call until the next
+     * alignment.  During writing of the object we swap the nops before the
+     * instruction.
+     */
+    if (frag_is_a_call ()) {
+      frag_now->is_call = 1;
+      frag_align_code (call_align,0);
+    }
+  }
 }
 
 /* Return the size of the displacement operand N.  */
@@ -6858,8 +7296,44 @@
     }
   else if (*op_string == REGISTER_PREFIX)
     {
-      as_bad (_("bad register name `%s'"), op_string);
-      return 0;
+#ifdef TC_NACL_C
+      if (flag_code == CODE_64BIT && strncmp(op_string, "%nacl", 5) == 0)
+        {
+          /* Check for a nacl override by searching for ':' after a %nacl */
+          op_string += 5;
+          if (is_space_char (*op_string))
+	    ++op_string;
+	  if (*op_string == ':')
+	    {
+	      /* Skip the ':' and whitespace.  */
+	      ++op_string;
+	      if (is_space_char (*op_string))
+		++op_string;
+
+	      i.nacl_truncate[i.mem_operands] = 1;
+
+	      if (!is_digit_char (*op_string)
+		  && !is_identifier_char (*op_string)
+		  && *op_string != '('
+		  && *op_string != ABSOLUTE_PREFIX)
+		{
+		  as_bad (_("bad memory operand `%s'"), op_string);
+		   return 0;
+		}
+	      goto do_memory_reference;
+	    }
+	  if (*op_string)
+	    {
+	      as_bad (_("junk `%s' after register"), op_string);
+	      return 0;
+	    }
+        }
+      else
+#endif
+        {      
+          as_bad (_("bad register name `%s'"), op_string);
+          return 0;
+        }
     }
   else if (*op_string == IMMEDIATE_PREFIX)
     {
@@ -7725,6 +8199,8 @@
 #define OPTION_MOLD_GCC (OPTION_MD_BASE + 9)
 #define OPTION_MSSE2AVX (OPTION_MD_BASE + 10)
 #define OPTION_MSSE_CHECK (OPTION_MD_BASE + 11)
+#define OPTION_NACL_ALIGN (OPTION_MD_BASE + 12)
+#define OPTION_NACL_LIBRARY_MODE (OPTION_MD_BASE + 13)
 
 struct option md_longopts[] =
 {
@@ -7743,6 +8219,8 @@
   {"mold-gcc", no_argument, NULL, OPTION_MOLD_GCC},
   {"msse2avx", no_argument, NULL, OPTION_MSSE2AVX},
   {"msse-check", required_argument, NULL, OPTION_MSSE_CHECK},
+  {"nacl-align", required_argument, NULL, OPTION_NACL_ALIGN},
+  {"nacl-library-mode", no_argument, NULL, OPTION_NACL_LIBRARY_MODE},
   {NULL, no_argument, NULL, 0}
 };
 size_t md_longopts_size = sizeof (md_longopts);
@@ -7953,6 +8431,20 @@
 	as_fatal (_("Invalid -msse-check= option: `%s'"), arg);
       break;
 
+    case OPTION_NACL_ALIGN:
+      {
+        nacl_alignment = atoi (optarg);
+        if (nacl_alignment < 0)
+          as_fatal (_("--nacl-align needs a non-negative argument"));
+        break;
+      }
+
+    case OPTION_NACL_LIBRARY_MODE:
+      {
+        nacl_library_mode = 1;
+        break;
+      }
+
     default:
       return 0;
     }
@@ -8597,4 +9089,25 @@
       bss_section = saved_bss_section;
     }
 }
+#ifdef TC_NACL_C
+void nacl_elf_final_processing(void)
+{
+  elf_elfheader (stdoutput)->e_ident[EI_OSABI] = ELFOSABI_NACL;
+  if (flag_code == CODE_64BIT)
+    {
+      /* Until we reach a stable version on x86-64, leave it as zero. */
+      elf_elfheader (stdoutput)->e_ident[EI_ABIVERSION] = 0;
+    }
+  else
+    elf_elfheader (stdoutput)->e_ident[EI_ABIVERSION] = EF_NACL_ABIVERSION;
+
+  elf_elfheader (stdoutput)->e_flags &= ~EF_NACL_ALIGN_MASK;
+  if (nacl_library_mode)
+    elf_elfheader (stdoutput)->e_flags |= EF_NACL_ALIGN_LIB;
+  else if (nacl_alignment == 4)
+    elf_elfheader (stdoutput)->e_flags |= EF_NACL_ALIGN_16;
+  else if (nacl_alignment == 5)
+    elf_elfheader (stdoutput)->e_flags |= EF_NACL_ALIGN_32;
+}
+#endif
 #endif /* OBJ_ELF || OBJ_MAYBE_ELF */
diff -Naur ../PRISTINE/binutils-2.20/gas/config/tc-i386.h binutils-2.20/gas/config/tc-i386.h
--- ../PRISTINE/binutils-2.20/gas/config/tc-i386.h	2009-09-02 00:24:20.000000000 -0700
+++ binutils-2.20/gas/config/tc-i386.h	2010-01-05 13:21:03.566222000 -0800
@@ -297,4 +297,12 @@
 /* X_add_symbol:X_op_symbol (Intel mode only) */
 #define O_full_ptr O_md2
 
+/* NativeClient specific additions. */
+
+/* log2 of the instruction alignment */
+extern int nacl_alignment;
+
+/* library mode: 16-byte alignment, calls end 32-byte chunks. */
+extern int nacl_library_mode;
+
 #endif /* TC_I386 */
diff -Naur ../PRISTINE/binutils-2.20/gas/config/tc-nacl.c binutils-2.20/gas/config/tc-nacl.c
--- ../PRISTINE/binutils-2.20/gas/config/tc-nacl.c	1969-12-31 16:00:00.000000000 -0800
+++ binutils-2.20/gas/config/tc-nacl.c	2010-01-05 13:21:03.622222000 -0800
@@ -0,0 +1,2 @@
+#define TC_NACL_C
+#include "tc-i386.c"
diff -Naur ../PRISTINE/binutils-2.20/gas/config/tc-nacl.h binutils-2.20/gas/config/tc-nacl.h
--- ../PRISTINE/binutils-2.20/gas/config/tc-nacl.h	1969-12-31 16:00:00.000000000 -0800
+++ binutils-2.20/gas/config/tc-nacl.h	2010-01-05 13:21:03.635214000 -0800
@@ -0,0 +1,37 @@
+/* tc-nacl.h -- Header file for tc-nacl.c
+   Copyright 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
+   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#ifndef TC_NACL
+#define TC_NACL 1
+
+#include "tc-i386.h"
+
+#undef ELF_TARGET_FORMAT
+#define ELF_TARGET_FORMAT "elf32-nacl"
+
+#undef ELF_TARGET_FORMAT64
+#define ELF_TARGET_FORMAT64 "elf64-nacl"
+
+#define elf_tc_final_processing nacl_elf_final_processing
+extern void nacl_elf_final_processing PARAMS ((void));
+
+#endif /* TC_NACL */
diff -Naur ../PRISTINE/binutils-2.20/gas/configure binutils-2.20/gas/configure
--- ../PRISTINE/binutils-2.20/gas/configure	2009-09-07 05:09:27.000000000 -0700
+++ binutils-2.20/gas/configure	2010-01-05 13:21:03.659215000 -0800
@@ -12019,7 +12019,7 @@
         using_cgen=yes
 	;;
 
-      i386 | s390 | sparc)
+      i386 | nacl | s390 | sparc)
 	if test $this_target = $target ; then
 
 cat >>confdefs.h <<_ACEOF
diff -Naur ../PRISTINE/binutils-2.20/gas/configure.in binutils-2.20/gas/configure.in
--- ../PRISTINE/binutils-2.20/gas/configure.in	2009-09-07 02:16:07.000000000 -0700
+++ binutils-2.20/gas/configure.in	2010-01-05 13:21:03.665226000 -0800
@@ -347,7 +347,7 @@
         using_cgen=yes
 	;;
 
-      i386 | s390 | sparc)
+      i386 | nacl | s390 | sparc)
 	if test $this_target = $target ; then
 	  AC_DEFINE_UNQUOTED(DEFAULT_ARCH, "${arch}", [Default architecture.])
 	fi
diff -Naur ../PRISTINE/binutils-2.20/gas/configure.tgt binutils-2.20/gas/configure.tgt
--- ../PRISTINE/binutils-2.20/gas/configure.tgt	2009-09-09 01:13:28.000000000 -0700
+++ binutils-2.20/gas/configure.tgt	2010-01-05 13:21:03.670223000 -0800
@@ -59,6 +59,8 @@
   mips*el)		cpu_type=mips endian=little ;;
   mips*)		cpu_type=mips endian=big ;;
   mt)                   cpu_type=mt endian=big ;;
+  nacl*)		cpu_type=nacl arch=i386 ;;
+  nacl64*)		cpu_type=nacl arch=x86_64 ;;
   or32*)		cpu_type=or32 endian=big ;;
   pjl*)			cpu_type=pj endian=little ;;
   pj*)			cpu_type=pj endian=big ;;
@@ -203,6 +205,7 @@
   i386-*-linux*coff*)			fmt=coff em=linux ;;
   i386-*-linux-*)			fmt=elf em=linux ;;
   i386-*-lynxos*)			fmt=elf em=lynx ;;
+  i386-*-nacl*)				fmt=elf em=linux cpu_type=nacl;;
   i386-*-sysv[45]*)			fmt=elf ;;
   i386-*-solaris*)			fmt=elf em=solaris ;;
   i386-*-freebsdaout*)			fmt=aout em=386bsd ;;
diff -Naur ../PRISTINE/binutils-2.20/gas/frags.c binutils-2.20/gas/frags.c
--- ../PRISTINE/binutils-2.20/gas/frags.c	2009-09-14 04:43:26.000000000 -0700
+++ binutils-2.20/gas/frags.c	2010-01-05 13:21:03.676214000 -0800
@@ -69,6 +69,16 @@
   (void) obstack_alloc (ob, 0);
   oalign = obstack_alignment_mask (ob);
   obstack_alignment_mask (ob) = 0;
+  {
+    /* If there isn't adequate space for a frag plus its contents plus the
+     * alignment contents in the current chunk, force the allocation of a new
+     * chunk. */
+
+    int space = obstack_room (ob);
+    if (space < SIZEOF_STRUCT_FRAG + (1 << (nacl_alignment + 2))) {
+      (void) obstack_alloc (ob, space-1);
+    }
+  }
   ptr = (fragS *) obstack_alloc (ob, SIZEOF_STRUCT_FRAG);
   obstack_alignment_mask (ob) = oalign;
   memset (ptr, 0, SIZEOF_STRUCT_FRAG);
diff -Naur ../PRISTINE/binutils-2.20/gas/frags.h binutils-2.20/gas/frags.h
--- ../PRISTINE/binutils-2.20/gas/frags.h	2007-07-03 04:01:03.000000000 -0700
+++ binutils-2.20/gas/frags.h	2010-01-05 13:21:03.680220000 -0800
@@ -77,10 +77,22 @@
   unsigned int has_code:1;
   unsigned int insn_addr:6;
 
+  /* NativeClient support:
+   * Set if this fragment contains a call in a native client assembly.  These
+   * need to end an alignment unit.
+   */
+  unsigned int is_call:1;
+
   /* What state is my tail in? */
   relax_stateT fr_type;
   relax_substateT fr_subtype;
 
+  /* NativeClient support:
+   * If this fragment contains a call, we will need to tweak the fixup to
+   * reflect the padding to put the call at the end of the fragment.
+   */
+  fixS *nacl_fixup;
+
 #ifdef USING_CGEN
   /* Don't include this unless using CGEN to keep frag size down.  */
   struct {
diff -Naur ../PRISTINE/binutils-2.20/gas/write.c binutils-2.20/gas/write.c
--- ../PRISTINE/binutils-2.20/gas/write.c	2009-09-14 04:43:27.000000000 -0700
+++ binutils-2.20/gas/write.c	2010-01-05 13:21:03.695232000 -0800
@@ -158,6 +158,8 @@
 
   fixP = (fixS *) obstack_alloc (&notes, sizeof (fixS));
 
+  frag->nacl_fixup = fixP;
+
   fixP->fx_frag = frag;
   fixP->fx_where = where;
   fixP->fx_size = size;
@@ -422,6 +424,38 @@
 }
 
 static void
+move_call_insn_to_end(fragS *fragP, fragS *next ATTRIBUTE_UNUSED)
+{
+  if (fragP->fr_offset != 0) {
+    // fragP->fr_fix is the start of the fixup code (i.e. nops).
+    int i;
+    unsigned char *tmp = alloca (fragP->fr_fix);
+    memcpy (tmp, fragP->fr_literal, fragP->fr_fix);
+    for (i = 0; i < fragP->fr_var; i++) {
+      fragP->fr_literal[i] = fragP->fr_literal[fragP->fr_fix+i];
+    }
+    for (i = 0; i< fragP->fr_fix; i++) {
+      fragP->fr_literal[fragP->fr_var+i] = tmp[i];
+    }
+    // TODO(sehr): this code should be obsolete.  Remove it.
+    // If it was a direct call, there's a fixup for the target address.
+    // This needs to corrected to point to the new location of the
+    // constant after we moved the nops.
+    // If there is no fixup, but this is a call, then it is an indirect
+    // call, and we need to put in the fixups for the sandbox code.
+    if (fragP->nacl_fixup) {
+      fragP->nacl_fixup->fx_where += fragP->fr_var;
+    }
+    else if (getenv("NACL_CONTROL_ENFORCE_RANGE")) {
+      symbolS* and_mask = symbol_find_or_make ("__nacl_and_mask");
+      symbolS* exec_start = symbol_find_or_make ("__executable_start");
+      fix_new (fragP, 2+fragP->fr_var, 4, and_mask, 0, 0, BFD_RELOC_32);
+      fix_new (fragP, 8+fragP->fr_var, 4, exec_start, 0, 0, BFD_RELOC_32);
+    }
+  }
+}
+
+static void
 cvt_frag_to_fill (segT sec ATTRIBUTE_UNUSED, fragS *fragP)
 {
   switch (fragP->fr_type)
@@ -445,6 +479,10 @@
 			(long) fragP->fr_offset);
 	  fragP->fr_offset = 0;
 	}
+
+      if (fragP->is_call && (nacl_alignment > 0)) {
+        move_call_insn_to_end (fragP, NULL);
+      }
       fragP->fr_type = rs_fill;
       break;
 
@@ -1177,6 +1215,8 @@
     {
       int j;
       int fx_size, slack;
+      /* NativeClient change here to handle moving calls. */
+      int limitsize;
       offsetT loc;
 
       if (fixp->fx_done)
@@ -1187,7 +1227,10 @@
       if (slack > 0)
 	fx_size = fx_size > slack ? fx_size - slack : 0;
       loc = fixp->fx_where + fx_size;
-      if (slack >= 0 && loc > fixp->fx_frag->fr_fix)
+      limitsize = (fixp->fx_frag->is_call ?
+                   (fixp->fx_frag->fr_fix + fixp->fx_frag->fr_var) :
+                   fixp->fx_frag->fr_fix);
+      if (slack >= 0 && loc > limitsize)
 	as_bad_where (fixp->fx_file, fixp->fx_line,
 		      _("internal error: fixup not contained within frag"));
 
diff -Naur ../PRISTINE/binutils-2.20/include/elf/common.h binutils-2.20/include/elf/common.h
--- ../PRISTINE/binutils-2.20/include/elf/common.h	2009-08-09 06:42:26.000000000 -0700
+++ binutils-2.20/include/elf/common.h	2010-01-05 13:21:03.720222000 -0800
@@ -75,6 +75,7 @@
 #define ELFOSABI_NSK	     14	/* Hewlett-Packard Non-Stop Kernel */
 #define ELFOSABI_AROS	     15	/* AROS */
 #define ELFOSABI_ARM	     97	/* ARM */
+#define ELFOSABI_NACL	    123	/* x86 NativeClient */
 #define ELFOSABI_STANDALONE 255	/* Standalone (embedded) application */
 
 #define EI_ABIVERSION	8	/* ABI version */
diff -Naur ../PRISTINE/binutils-2.20/include/elf/nacl.h binutils-2.20/include/elf/nacl.h
--- ../PRISTINE/binutils-2.20/include/elf/nacl.h	1969-12-31 16:00:00.000000000 -0800
+++ binutils-2.20/include/elf/nacl.h	2010-01-05 13:21:03.732217000 -0800
@@ -0,0 +1,34 @@
+/* ix86 ELF support for BFD.
+   Copyright 1998, 1999, 2000, 2002, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _ELF_NACL_H
+#define _ELF_NACL_H
+
+/* e_flags settings for NativeClient. */
+#define EF_NACL_ALIGN_MASK  0x300000	/* bits indicating alignment */
+#define EF_NACL_ALIGN_16    0x100000	/* aligned zero mod 16 */
+#define EF_NACL_ALIGN_32    0x200000	/* aligned zero mod 32 */ 
+#define EF_NACL_ALIGN_LIB   0x000000	/* aligned to pass either way */
+
+/* ABI version number -- increment when ABI changes are incompatible. */
+#define EF_NACL_ABIVERSION  7
+/* For x86-64 the version number is still zero, until a stable point. */
+
+#endif
diff -Naur ../PRISTINE/binutils-2.20/ld/Makefile.am binutils-2.20/ld/Makefile.am
--- ../PRISTINE/binutils-2.20/ld/Makefile.am	2009-09-01 13:56:51.000000000 -0700
+++ binutils-2.20/ld/Makefile.am	2010-01-05 13:21:03.742217000 -0800
@@ -221,6 +221,7 @@
 	eelf_i386_fbsd.o \
 	eelf_i386_ldso.o \
 	eelf_i386_vxworks.o \
+	eelf_nacl.o \
 	eelf_s390.o \
 	egld960.o \
 	egld960coff.o \
@@ -1072,6 +1073,10 @@
   $(srcdir)/emultempl/needrelax.em \
   $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf64_ia64_fbsd "$(tdir_elf64_ia64_fbsd)"
+eelf64_nacl.c: $(srcdir)/emulparams/elf64_nacl.sh \
+  $(srcdir)/emulparams/elf_x86_64.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64_nacl "$(tdir_elf64_nacl)"
 eelf64_s390.c: $(srcdir)/emulparams/elf64_s390.sh \
   $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf64_s390 "$(tdir_elf64_s390)"
@@ -1110,6 +1115,10 @@
 eelf_i386.c: $(srcdir)/emulparams/elf_i386.sh \
   $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf_i386 "$(tdir_elf_i386)"
+eelf_nacl.c: $(srcdir)/emulparams/elf_nacl.sh \
+  $(srcdir)/emulparams/elf_i386.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_nacl "$(tdir_elf_nacl)"
 eelf_x86_64.c: $(srcdir)/emulparams/elf_x86_64.sh \
   $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf_x86_64 "$(tdir_elf_x86_64)"
diff -Naur ../PRISTINE/binutils-2.20/ld/Makefile.in binutils-2.20/ld/Makefile.in
--- ../PRISTINE/binutils-2.20/ld/Makefile.in	2009-09-07 05:10:24.000000000 -0700
+++ binutils-2.20/ld/Makefile.in	2010-01-05 13:21:03.751216000 -0800
@@ -507,6 +507,7 @@
 	eelf_i386_fbsd.o \
 	eelf_i386_ldso.o \
 	eelf_i386_vxworks.o \
+	eelf_nacl.o \
 	eelf_s390.o \
 	egld960.o \
 	egld960coff.o \
@@ -709,6 +710,7 @@
 	eelf_x86_64_fbsd.o \
 	eelf_l1om.o \
 	eelf_l1om_fbsd.o \
+	eelf64_nacl.o \
 	eelf64_s390.o \
 	eelf64_sparc.o \
 	eelf64_sparc_fbsd.o \
@@ -2413,6 +2415,10 @@
   $(srcdir)/emultempl/needrelax.em \
   $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf64_ia64_fbsd "$(tdir_elf64_ia64_fbsd)"
+eelf64_nacl.c: $(srcdir)/emulparams/elf64_nacl.sh \
+  $(srcdir)/emulparams/elf_x86_64.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64_nacl "$(tdir_elf64_nacl)"
 eelf64_s390.c: $(srcdir)/emulparams/elf64_s390.sh \
   $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf64_s390 "$(tdir_elf64_s390)"
@@ -2451,6 +2457,10 @@
 eelf_i386.c: $(srcdir)/emulparams/elf_i386.sh \
   $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf_i386 "$(tdir_elf_i386)"
+eelf_nacl.c: $(srcdir)/emulparams/elf_nacl.sh \
+  $(srcdir)/emulparams/elf_i386.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_nacl "$(tdir_elf_nacl)"
 eelf_x86_64.c: $(srcdir)/emulparams/elf_x86_64.sh \
   $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf_x86_64 "$(tdir_elf_x86_64)"
diff -Naur ../PRISTINE/binutils-2.20/ld/configure.tgt binutils-2.20/ld/configure.tgt
--- ../PRISTINE/binutils-2.20/ld/configure.tgt	2009-08-06 10:38:03.000000000 -0700
+++ binutils-2.20/ld/configure.tgt	2010-01-05 13:21:03.757202000 -0800
@@ -230,6 +230,9 @@
 			targ_extra_ofiles="deffilep.o pe-dll.o" ;;
 i[3-7]86-*-netbsd*)	targ_emul=i386nbsd
 			targ_extra_emuls=elf_i386 ;;
+i[3-7]86-*-nacl*)	targ_emul=elf_nacl ;;
+x86_64-*-nacl*)		targ_emul=elf64_nacl
+			targ_extra_emuls=elf_nacl ;;
 x86_64-*-netbsd*)	targ_emul=elf_x86_64
 			targ_extra_emuls="elf_i386 i386nbsd elf_l1om"
 			tdir_elf_i386=`echo ${targ_alias} | \
diff -Naur ../PRISTINE/binutils-2.20/ld/emulparams/elf64_nacl.sh binutils-2.20/ld/emulparams/elf64_nacl.sh
--- ../PRISTINE/binutils-2.20/ld/emulparams/elf64_nacl.sh	1969-12-31 16:00:00.000000000 -0800
+++ binutils-2.20/ld/emulparams/elf64_nacl.sh	2010-01-05 13:21:03.785168000 -0800
@@ -0,0 +1,4 @@
+. ${srcdir}/emulparams/elf_x86_64.sh
+SCRIPT_NAME=naclelf
+OUTPUT_FORMAT="elf64-nacl"
+TEXT_START_ADDR=0x00020000
diff -Naur ../PRISTINE/binutils-2.20/ld/emulparams/elf_nacl.sh binutils-2.20/ld/emulparams/elf_nacl.sh
--- ../PRISTINE/binutils-2.20/ld/emulparams/elf_nacl.sh	1969-12-31 16:00:00.000000000 -0800
+++ binutils-2.20/ld/emulparams/elf_nacl.sh	2010-01-05 13:21:03.798157000 -0800
@@ -0,0 +1,4 @@
+. ${srcdir}/emulparams/elf_i386.sh
+SCRIPT_NAME=naclelf
+OUTPUT_FORMAT="elf32-nacl"
+TEXT_START_ADDR=0x00020000
diff -Naur ../PRISTINE/binutils-2.20/ld/genscripts.sh binutils-2.20/ld/genscripts.sh
--- ../PRISTINE/binutils-2.20/ld/genscripts.sh	2009-09-02 00:25:35.000000000 -0700
+++ binutils-2.20/ld/genscripts.sh	2010-01-05 13:21:03.805147000 -0800
@@ -418,9 +418,10 @@
   ) | sed -e '/^ *$/d;s/[ 	]*$//' > ldscripts/${EMULATION_NAME}.xa
 fi
 
-case " $EMULATION_LIBPATH " in
-    *" ${EMULATION_NAME} "*) COMPILE_IN=true;;
-esac
+# Disable compiling-in of linker scripts.
+# case " $EMULATION_LIBPATH " in
+#     *" ${EMULATION_NAME} "*) COMPILE_IN=true;;
+# esac
 
 # PR ld/5652:
 # Determine if the shell has support for the variable BASH_LINENO.
diff -Naur ../PRISTINE/binutils-2.20/ld/ldexp.c binutils-2.20/ld/ldexp.c
--- ../PRISTINE/binutils-2.20/ld/ldexp.c	2009-09-14 04:43:29.000000000 -0700
+++ binutils-2.20/ld/ldexp.c	2010-01-05 13:21:03.816161000 -0800
@@ -46,6 +46,8 @@
 static void exp_fold_tree_1 (etree_type *);
 static void exp_fold_tree_no_dot (etree_type *);
 static bfd_vma align_n (bfd_vma, bfd_vma);
+static bfd_vma ceilp2 (bfd_vma);
+static bfd_vma nacl_mask (bfd_vma);
 
 segment_type *segments;
 
@@ -272,6 +274,20 @@
 	    expld.result.valid_p = FALSE;
 	  break;
 
+	case CEILP2:
+	  if (expld.phase != lang_first_phase_enum)
+	    expld.result.value = ceilp2 (expld.result.value);
+	  else
+	    expld.result.valid_p = FALSE;
+	  break;
+
+	case NACL_MASK:
+	  if (expld.phase != lang_first_phase_enum)
+	    expld.result.value = nacl_mask (expld.result.value);
+	  else
+	    expld.result.valid_p = FALSE;
+	  break;
+
 	default:
 	  FAIL ();
 	  break;
@@ -1161,3 +1177,27 @@
   value = (value + align - 1) / align;
   return value * align;
 }
+
+static bfd_vma
+ceilp2 (bfd_vma value)
+{
+  value |= (value >> 1);
+  value |= (value >> 2);
+  value |= (value >> 4);
+  value |= (value >> 8);
+  value |= (value >> 16);
+  return value + 1;
+}
+
+static bfd_vma
+nacl_mask (bfd_vma value)
+{
+  char* str = getenv ("NACL_CONTROL_ENFORCE_ALIGN");
+  if (str) {
+    int nacl_alignment = atoi (str);
+    return (value - 1) & ~((1 << nacl_alignment) - 1);
+  }
+  else {
+    return value - 1;
+  }
+}
diff -Naur ../PRISTINE/binutils-2.20/ld/ldfile.c binutils-2.20/ld/ldfile.c
--- ../PRISTINE/binutils-2.20/ld/ldfile.c	2009-08-29 15:11:01.000000000 -0700
+++ binutils-2.20/ld/ldfile.c	2010-01-05 13:21:03.822130000 -0800
@@ -608,7 +608,7 @@
 void
 ldfile_open_default_command_file (const char *name)
 {
-  ldfile_open_command_file_1 (name, TRUE);
+  ldfile_open_command_file_1 (name, FALSE);
 }
 
 void
diff -Naur ../PRISTINE/binutils-2.20/ld/ldgram.y binutils-2.20/ld/ldgram.y
--- ../PRISTINE/binutils-2.20/ld/ldgram.y	2009-09-02 00:25:35.000000000 -0700
+++ binutils-2.20/ld/ldgram.y	2010-01-05 13:21:03.829129000 -0800
@@ -136,7 +136,7 @@
 %token NOLOAD DSECT COPY INFO OVERLAY
 %token DEFINED TARGET_K SEARCH_DIR MAP ENTRY
 %token <integer> NEXT
-%token SIZEOF ALIGNOF ADDR LOADADDR MAX_K MIN_K
+%token SIZEOF ALIGNOF ADDR LOADADDR MAX_K MIN_K CEILP2 NACL_MASK
 %token STARTUP HLL SYSLIB FLOAT NOFLOAT NOCROSSREFS
 %token ORIGIN FILL
 %token LENGTH CREATE_OBJECT_SYMBOLS INPUT GROUP OUTPUT CONSTRUCTORS
@@ -893,6 +893,10 @@
 			{ $$ = exp_binop (MAX_K, $3, $5 ); }
 	|	MIN_K '(' exp ',' exp ')'
 			{ $$ = exp_binop (MIN_K, $3, $5 ); }
+	|	CEILP2 '(' exp ')'
+			{ $$ = exp_unop (CEILP2, $3); }
+        |	NACL_MASK '(' exp ')'
+			{ $$ = exp_unop (NACL_MASK, $3); }
 	|	ASSERT_K '(' exp ',' NAME ')'
 			{ $$ = exp_assert ($3, $5); }
 	|	ORIGIN '(' NAME ')'
diff -Naur ../PRISTINE/binutils-2.20/ld/ldlex.l binutils-2.20/ld/ldlex.l
--- ../PRISTINE/binutils-2.20/ld/ldlex.l	2009-10-14 07:51:32.000000000 -0700
+++ binutils-2.20/ld/ldlex.l	2010-01-05 13:21:03.834120000 -0800
@@ -254,6 +254,8 @@
 <EXPRESSION,BOTH,SCRIPT>"ALIGNOF"	{ RTOKEN(ALIGNOF); }
 <EXPRESSION,BOTH>"MAX"			{ RTOKEN(MAX_K); }
 <EXPRESSION,BOTH>"MIN"			{ RTOKEN(MIN_K); }
+<EXPRESSION,BOTH>"CEILP2"		{ RTOKEN(CEILP2); }
+<EXPRESSION,BOTH>"NACL_MASK"		{ RTOKEN(NACL_MASK);}
 <EXPRESSION,BOTH,SCRIPT>"ASSERT"	{ RTOKEN(ASSERT_K); }
 <BOTH,SCRIPT>"ENTRY"			{ RTOKEN(ENTRY);}
 <BOTH,SCRIPT,MRI>"EXTERN"		{ RTOKEN(EXTERN);}
diff -Naur ../PRISTINE/binutils-2.20/ld/scripttempl/naclelf.sc binutils-2.20/ld/scripttempl/naclelf.sc
--- ../PRISTINE/binutils-2.20/ld/scripttempl/naclelf.sc	1969-12-31 16:00:00.000000000 -0800
+++ binutils-2.20/ld/scripttempl/naclelf.sc	2010-01-05 13:21:03.846110000 -0800
@@ -0,0 +1,611 @@
+#
+# Unusual variables checked by this code:
+#	NOP - four byte opcode for no-op (defaults to 0)
+#	NO_SMALL_DATA - no .sbss/.sbss2/.sdata/.sdata2 sections if not
+#		empty.
+#	SMALL_DATA_CTOR - .ctors contains small data.
+#	SMALL_DATA_DTOR - .dtors contains small data.
+#	DATA_ADDR - if end-of-text-plus-one-page isn't right for data start
+#	INITIAL_READONLY_SECTIONS - at start of text segment
+#	OTHER_READONLY_SECTIONS - other than .text .init .rodata ...
+#		(e.g., .PARISC.milli)
+#	OTHER_TEXT_SECTIONS - these get put in .text when relocating
+#	OTHER_READWRITE_SECTIONS - other than .data .bss .ctors .sdata ...
+#		(e.g., .PARISC.global)
+#	OTHER_RELRO_SECTIONS - other than .data.rel.ro ...
+#		(e.g. PPC32 .fixup, .got[12])
+#	OTHER_BSS_SECTIONS - other than .bss .sbss ...
+#	ATTRS_SECTIONS - at the end
+#	OTHER_SECTIONS - at the end
+#	EXECUTABLE_SYMBOLS - symbols that must be defined for an
+#		executable (e.g., _DYNAMIC_LINK)
+#       TEXT_START_ADDR - the first byte of the text segment, after any
+#               headers.
+#       TEXT_BASE_ADDRESS - the first byte of the text segment.
+#	TEXT_START_SYMBOLS - symbols that appear at the start of the
+#		.text section.
+#	DATA_START_SYMBOLS - symbols that appear at the start of the
+#		.data section.
+#	DATA_END_SYMBOLS - symbols that appear at the end of the
+#		writeable data sections.
+#	OTHER_GOT_SYMBOLS - symbols defined just before .got.
+#	OTHER_GOT_SECTIONS - sections just after .got.
+#	OTHER_SDATA_SECTIONS - sections just after .sdata.
+#	OTHER_BSS_SYMBOLS - symbols that appear at the start of the
+#		.bss section besides __bss_start.
+#	DATA_PLT - .plt should be in data segment, not text segment.
+#	PLT_BEFORE_GOT - .plt just before .got when .plt is in data segement.
+#	BSS_PLT - .plt should be in bss segment
+#	NO_REL_RELOCS - Don't include .rel.* sections in script
+#	NO_RELA_RELOCS - Don't include .rela.* sections in script
+#	NON_ALLOC_DYN - Place dynamic sections after data segment.
+#	TEXT_DYNAMIC - .dynamic in text segment, not data segment.
+#	EMBEDDED - whether this is for an embedded system. 
+#	SHLIB_TEXT_START_ADDR - if set, add to SIZEOF_HEADERS to set
+#		start address of shared library.
+#	INPUT_FILES - INPUT command of files to always include
+#	WRITABLE_RODATA - if set, the .rodata section should be writable
+#	INIT_START, INIT_END -  statements just before and just after
+# 	combination of .init sections.
+#	FINI_START, FINI_END - statements just before and just after
+# 	combination of .fini sections.
+#	STACK_ADDR - start of a .stack section.
+#	OTHER_SYMBOLS - symbols to place right at the end of the script.
+#	ETEXT_NAME - name of a symbol for the end of the text section,
+#		normally etext.
+#	SEPARATE_GOTPLT - if set, .got.plt should be separate output section,
+#		so that .got can be in the RELRO area.  It should be set to
+#		the number of bytes in the beginning of .got.plt which can be
+#		in the RELRO area as well.
+#	USER_LABEL_PREFIX - prefix to add to user-visible symbols.
+#
+# When adding sections, do note that the names of some sections are used
+# when specifying the start address of the next.
+#
+
+#  Many sections come in three flavours.  There is the 'real' section,
+#  like ".data".  Then there are the per-procedure or per-variable
+#  sections, generated by -ffunction-sections and -fdata-sections in GCC,
+#  and useful for --gc-sections, which for a variable "foo" might be
+#  ".data.foo".  Then there are the linkonce sections, for which the linker
+#  eliminates duplicates, which are named like ".gnu.linkonce.d.foo".
+#  The exact correspondences are:
+#
+#  Section	Linkonce section
+#  .text	.gnu.linkonce.t.foo
+#  .rodata	.gnu.linkonce.r.foo
+#  .data	.gnu.linkonce.d.foo
+#  .bss		.gnu.linkonce.b.foo
+#  .sdata	.gnu.linkonce.s.foo
+#  .sbss	.gnu.linkonce.sb.foo
+#  .sdata2	.gnu.linkonce.s2.foo
+#  .sbss2	.gnu.linkonce.sb2.foo
+#  .debug_info	.gnu.linkonce.wi.foo
+#  .tdata	.gnu.linkonce.td.foo
+#  .tbss	.gnu.linkonce.tb.foo
+#  .lrodata	.gnu.linkonce.lr.foo
+#  .ldata	.gnu.linkonce.l.foo
+#  .lbss	.gnu.linkonce.lb.foo
+#
+#  Each of these can also have corresponding .rel.* and .rela.* sections.
+
+test -z "$ENTRY" && ENTRY=_start
+test -z "${BIG_OUTPUT_FORMAT}" && BIG_OUTPUT_FORMAT=${OUTPUT_FORMAT}
+test -z "${LITTLE_OUTPUT_FORMAT}" && LITTLE_OUTPUT_FORMAT=${OUTPUT_FORMAT}
+if [ -z "$MACHINE" ]; then OUTPUT_ARCH=${ARCH}; else OUTPUT_ARCH=${ARCH}:${MACHINE}; fi
+test -z "${ELFSIZE}" && ELFSIZE=32
+test -z "${ALIGNMENT}" && ALIGNMENT="${ELFSIZE} / 8"
+test "$LD_FLAG" = "N" && DATA_ADDR=.
+test -z "${ETEXT_NAME}" && ETEXT_NAME=etext
+test -n "$CREATE_SHLIB$CREATE_PIE" && test -n "$SHLIB_DATA_ADDR" && COMMONPAGESIZE=""
+test -z "$CREATE_SHLIB$CREATE_PIE" && test -n "$DATA_ADDR" && COMMONPAGESIZE=""
+test -n "$RELRO_NOW" && unset SEPARATE_GOTPLT
+test -z "$ATTRS_SECTIONS" && ATTRS_SECTIONS=".gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }"
+DATA_SEGMENT_ALIGN="ALIGN(${SEGMENT_SIZE}) + (. & (${MAXPAGESIZE} - 1))"
+DATA_SEGMENT_RELRO_END=""
+DATA_SEGMENT_END=""
+if test -n "${COMMONPAGESIZE}"; then
+  DATA_SEGMENT_ALIGN="ALIGN (${SEGMENT_SIZE}) - ((${MAXPAGESIZE} - .) & (${MAXPAGESIZE} - 1)); . = DATA_SEGMENT_ALIGN (${MAXPAGESIZE}, ${COMMONPAGESIZE})"
+  DATA_SEGMENT_END=". = DATA_SEGMENT_END (.);"
+  DATA_SEGMENT_RELRO_END=". = DATA_SEGMENT_RELRO_END (${SEPARATE_GOTPLT-0}, .);"
+fi
+if test -z "${INITIAL_READONLY_SECTIONS}${CREATE_SHLIB}"; then
+  INITIAL_READONLY_SECTIONS=".interp       ${RELOCATING-0} : { *(.interp) }"
+fi
+if test -z "$PLT"; then
+  PLT=".plt          ${RELOCATING-0} : { *(.plt) *(.iplt)}"
+fi
+test -n "${DATA_PLT-${BSS_PLT-text}}" && TEXT_PLT=yes
+if test -z "$GOT"; then
+  if test -z "$SEPARATE_GOTPLT"; then
+    GOT=".got          ${RELOCATING-0} : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }"
+  else
+    GOT=".got          ${RELOCATING-0} : { *(.got) *(.igot) }"
+    GOTPLT=".got.plt      ${RELOCATING-0} : { *(.got.plt)  *(.igot.plt) }"
+  fi
+fi
+DYNAMIC=".dynamic      ${RELOCATING-0} : { *(.dynamic) }"
+RODATA=".rodata       ${RELOCATING-0} : { *(.rodata${RELOCATING+ .rodata.* .gnu.linkonce.r.*}) }"
+DATARELRO=".data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro* .gnu.linkonce.d.rel.ro.*) }"
+DISCARDED="/DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) }"
+if test -z "${NO_SMALL_DATA}"; then
+  SBSS=".sbss         ${RELOCATING-0} :
+  {
+    ${RELOCATING+${SBSS_START_SYMBOLS}}
+    ${CREATE_SHLIB+*(.sbss2 .sbss2.* .gnu.linkonce.sb2.*)}
+    *(.dynsbss)
+    *(.sbss${RELOCATING+ .sbss.* .gnu.linkonce.sb.*})
+    *(.scommon)
+    ${RELOCATING+${SBSS_END_SYMBOLS}}
+  }"
+  SBSS2=".sbss2        ${RELOCATING-0} : { *(.sbss2${RELOCATING+ .sbss2.* .gnu.linkonce.sb2.*}) }"
+  SDATA="/* We want the small data sections together, so single-instruction offsets
+     can access them all, and initialized data all before uninitialized, so
+     we can shorten the on-disk segment size.  */
+  .sdata        ${RELOCATING-0} : 
+  {
+    ${RELOCATING+${SDATA_START_SYMBOLS}}
+    ${CREATE_SHLIB+*(.sdata2 .sdata2.* .gnu.linkonce.s2.*)}
+    *(.sdata${RELOCATING+ .sdata.* .gnu.linkonce.s.*})
+  }"
+  SDATA2=".sdata2       ${RELOCATING-0} :
+  {
+    ${RELOCATING+${SDATA2_START_SYMBOLS}}
+    *(.sdata2${RELOCATING+ .sdata2.* .gnu.linkonce.s2.*})
+  }"
+  REL_SDATA=".rel.sdata    ${RELOCATING-0} : { *(.rel.sdata${RELOCATING+ .rel.sdata.* .rel.gnu.linkonce.s.*}) }
+  .rela.sdata   ${RELOCATING-0} : { *(.rela.sdata${RELOCATING+ .rela.sdata.* .rela.gnu.linkonce.s.*}) }"
+  REL_SBSS=".rel.sbss     ${RELOCATING-0} : { *(.rel.sbss${RELOCATING+ .rel.sbss.* .rel.gnu.linkonce.sb.*}) }
+  .rela.sbss    ${RELOCATING-0} : { *(.rela.sbss${RELOCATING+ .rela.sbss.* .rela.gnu.linkonce.sb.*}) }"
+  REL_SDATA2=".rel.sdata2   ${RELOCATING-0} : { *(.rel.sdata2${RELOCATING+ .rel.sdata2.* .rel.gnu.linkonce.s2.*}) }
+  .rela.sdata2  ${RELOCATING-0} : { *(.rela.sdata2${RELOCATING+ .rela.sdata2.* .rela.gnu.linkonce.s2.*}) }"
+  REL_SBSS2=".rel.sbss2    ${RELOCATING-0} : { *(.rel.sbss2${RELOCATING+ .rel.sbss2.* .rel.gnu.linkonce.sb2.*}) }
+  .rela.sbss2   ${RELOCATING-0} : { *(.rela.sbss2${RELOCATING+ .rela.sbss2.* .rela.gnu.linkonce.sb2.*}) }"
+else
+  NO_SMALL_DATA=" "
+fi
+if test -z "${DATA_GOT}"; then
+  if test -n "${NO_SMALL_DATA}"; then
+    DATA_GOT=" "
+  fi
+fi
+if test -z "${SDATA_GOT}"; then
+  if test -z "${NO_SMALL_DATA}"; then
+    SDATA_GOT=" "
+  fi
+fi
+test -n "$SEPARATE_GOTPLT" && SEPARATE_GOTPLT=" "
+test "${LARGE_SECTIONS}" = "yes" && REL_LARGE="
+  .rel.ldata    ${RELOCATING-0} : { *(.rel.ldata${RELOCATING+ .rel.ldata.* .rel.gnu.linkonce.l.*}) }
+  .rela.ldata   ${RELOCATING-0} : { *(.rela.ldata${RELOCATING+ .rela.ldata.* .rela.gnu.linkonce.l.*}) }
+  .rel.lbss     ${RELOCATING-0} : { *(.rel.lbss${RELOCATING+ .rel.lbss.* .rel.gnu.linkonce.lb.*}) }
+  .rela.lbss    ${RELOCATING-0} : { *(.rela.lbss${RELOCATING+ .rela.lbss.* .rela.gnu.linkonce.lb.*}) }
+  .rel.lrodata  ${RELOCATING-0} : { *(.rel.lrodata${RELOCATING+ .rel.lrodata.* .rel.gnu.linkonce.lr.*}) }
+  .rela.lrodata ${RELOCATING-0} : { *(.rela.lrodata${RELOCATING+ .rela.lrodata.* .rela.gnu.linkonce.lr.*}) }"
+test "${LARGE_SECTIONS}" = "yes" && OTHER_BSS_SECTIONS="
+  ${OTHER_BSS_SECTIONS}
+  .lbss ${RELOCATING-0} :
+  {
+    *(.dynlbss)
+    *(.lbss${RELOCATING+ .lbss.* .gnu.linkonce.lb.*})
+    *(LARGE_COMMON)
+  }"
+test "${LARGE_SECTIONS}" = "yes" && LARGE_SECTIONS="
+  .lrodata ${RELOCATING-0} ${RELOCATING+ALIGN(${MAXPAGESIZE}) + (. & (${MAXPAGESIZE} - 1))} :
+  {
+    *(.lrodata${RELOCATING+ .lrodata.* .gnu.linkonce.lr.*})
+  }
+  .ldata ${RELOCATING-0} ${RELOCATING+ALIGN(${MAXPAGESIZE}) + (. & (${MAXPAGESIZE} - 1))} :
+  {
+    *(.ldata${RELOCATING+ .ldata.* .gnu.linkonce.l.*})
+    ${RELOCATING+. = ALIGN(. != 0 ? ${ALIGNMENT} : 1);}
+  }"
+CTOR=".ctors        ${CONSTRUCTING-0} : 
+  {
+    ${CONSTRUCTING+${CTOR_START}}
+    /* gcc uses crtbegin.o to find the start of
+       the constructors, so we make sure it is
+       first.  Because this is a wildcard, it
+       doesn't matter if the user does not
+       actually link against crtbegin.o; the
+       linker won't look for a file to match a
+       wildcard.  The wildcard also means that it
+       doesn't matter which directory crtbegin.o
+       is in.  */
+
+    KEEP (*crtbegin.o(.ctors))
+    KEEP (*crtbegin?.o(.ctors))
+
+    /* We don't want to include the .ctor section from
+       the crtend.o file until after the sorted ctors.
+       The .ctor section from the crtend file contains the
+       end of ctors marker and it must be last */
+
+    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o $OTHER_EXCLUDE_FILES) .ctors))
+    KEEP (*(SORT(.ctors.*)))
+    KEEP (*(.ctors))
+    ${CONSTRUCTING+${CTOR_END}}
+  }"
+DTOR=".dtors        ${CONSTRUCTING-0} :
+  {
+    ${CONSTRUCTING+${DTOR_START}}
+    KEEP (*crtbegin.o(.dtors))
+    KEEP (*crtbegin?.o(.dtors))
+    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o $OTHER_EXCLUDE_FILES) .dtors))
+    KEEP (*(SORT(.dtors.*)))
+    KEEP (*(.dtors))
+    ${CONSTRUCTING+${DTOR_END}}
+  }"
+STACK="  .stack        ${RELOCATING-0}${RELOCATING+${STACK_ADDR}} :
+  {
+    ${RELOCATING+_stack = .;}
+    *(.stack)
+  }"
+
+TEXT_START_ADDR="SEGMENT_START(\"text-segment\", ${TEXT_START_ADDR})"
+SHLIB_TEXT_START_ADDR="SEGMENT_START(\"text-segment\", ${SHLIB_TEXT_START_ADDR:-0})"
+
+# if this is for an embedded system (or nacl), don't add SIZEOF_HEADERS.
+if [ -z "$EMBEDDED" ]; then
+   test -z "${TEXT_BASE_ADDRESS}" && TEXT_BASE_ADDRESS="${TEXT_START_ADDR}"
+else
+   test -z "${TEXT_BASE_ADDRESS}" && TEXT_BASE_ADDRESS="${TEXT_START_ADDR}"
+fi
+
+cat <<EOF
+OUTPUT_FORMAT("${OUTPUT_FORMAT}", "${BIG_OUTPUT_FORMAT}",
+	      "${LITTLE_OUTPUT_FORMAT}")
+OUTPUT_ARCH(${OUTPUT_ARCH})
+${RELOCATING+ENTRY(${ENTRY})}
+
+${RELOCATING+${LIB_SEARCH_DIRS}}
+${RELOCATING+${EXECUTABLE_SYMBOLS}}
+${RELOCATING+${INPUT_FILES}}
+${RELOCATING- /* For some reason, the Solaris linker makes bad executables
+  if gld -r is used and the intermediate file has sections starting
+  at non-zero addresses.  Could be a Solaris ld bug, could be a GNU ld
+  bug.  But for now assigning the zero vmas works.  */}
+
+PHDRS
+{
+  headers PT_PHDR FILEHDR PHDRS ;  /* put the headers in a non-loadable seg */
+  text    PT_LOAD FLAGS(5) ;       /* read + execute */
+  rodata  PT_LOAD FLAGS(4) ;       /* read */
+  data    PT_LOAD FLAGS(6) ;       /* read + write */
+  /* TODO(sehr): do we need a stack? */
+}
+
+SECTIONS
+{
+  /* Read-only sections, merged into text segment: */
+  ${CREATE_SHLIB-${CREATE_PIE-${RELOCATING+PROVIDE (__executable_start = ${TEXT_START_ADDR}); . = ${TEXT_BASE_ADDRESS};}}}
+  ${CREATE_SHLIB+${RELOCATING+. = ${SHLIB_TEXT_START_ADDR} + SIZEOF_HEADERS;}}
+  ${CREATE_PIE+${RELOCATING+. = ${SHLIB_TEXT_START_ADDR} + SIZEOF_HEADERS;}}
+  ${INITIAL_READONLY_SECTIONS}
+  .note.gnu.build-id : { *(.note.gnu.build-id) }
+EOF
+
+test -n "${RELOCATING+0}" || unset NON_ALLOC_DYN
+test -z "${NON_ALLOC_DYN}" || TEXT_DYNAMIC=
+cat > ldscripts/dyntmp.$$ <<EOF
+  ${TEXT_DYNAMIC+${DYNAMIC}}
+  .hash         ${RELOCATING-0} : { *(.hash) }
+  .gnu.hash     ${RELOCATING-0} : { *(.gnu.hash) }
+  .dynsym       ${RELOCATING-0} : { *(.dynsym) }
+  .dynstr       ${RELOCATING-0} : { *(.dynstr) }
+  .gnu.version  ${RELOCATING-0} : { *(.gnu.version) }
+  .gnu.version_d ${RELOCATING-0}: { *(.gnu.version_d) }
+  .gnu.version_r ${RELOCATING-0}: { *(.gnu.version_r) }
+EOF
+
+if [ "x$COMBRELOC" = x ]; then
+  COMBRELOCCAT="cat >> ldscripts/dyntmp.$$"
+else
+  COMBRELOCCAT="cat > $COMBRELOC"
+fi
+eval $COMBRELOCCAT <<EOF
+  .rel.init     ${RELOCATING-0} : { *(.rel.init) }
+  .rela.init    ${RELOCATING-0} : { *(.rela.init) }
+  .rel.text     ${RELOCATING-0} : { *(.rel.text${RELOCATING+ .rel.text.* .rel.gnu.linkonce.t.*}) }
+  .rela.text    ${RELOCATING-0} : { *(.rela.text${RELOCATING+ .rela.text.* .rela.gnu.linkonce.t.*}) }
+  .rel.fini     ${RELOCATING-0} : { *(.rel.fini) }
+  .rela.fini    ${RELOCATING-0} : { *(.rela.fini) }
+  .rel.rodata   ${RELOCATING-0} : { *(.rel.rodata${RELOCATING+ .rel.rodata.* .rel.gnu.linkonce.r.*}) }
+  .rela.rodata  ${RELOCATING-0} : { *(.rela.rodata${RELOCATING+ .rela.rodata.* .rela.gnu.linkonce.r.*}) }
+  ${OTHER_READONLY_RELOC_SECTIONS}
+  .rel.data.rel.ro ${RELOCATING-0} : { *(.rel.data.rel.ro${RELOCATING+* .rel.gnu.linkonce.d.rel.ro.*}) }
+  .rela.data.rel.ro ${RELOCATING-0} : { *(.rela.data.rel.ro${RELOCATING+* .rela.gnu.linkonce.d.rel.ro.*}) }
+  .rel.data     ${RELOCATING-0} : { *(.rel.data${RELOCATING+ .rel.data.* .rel.gnu.linkonce.d.*}) }
+  .rela.data    ${RELOCATING-0} : { *(.rela.data${RELOCATING+ .rela.data.* .rela.gnu.linkonce.d.*}) }
+  .rel.tdata	${RELOCATING-0} : { *(.rel.tdata${RELOCATING+ .rel.tdata.* .rel.gnu.linkonce.td.*}) }
+  .rela.tdata	${RELOCATING-0} : { *(.rela.tdata${RELOCATING+ .rela.tdata.* .rela.gnu.linkonce.td.*}) }
+  .rel.tbss	${RELOCATING-0} : { *(.rel.tbss${RELOCATING+ .rel.tbss.* .rel.gnu.linkonce.tb.*}) }
+  .rela.tbss	${RELOCATING-0} : { *(.rela.tbss${RELOCATING+ .rela.tbss.* .rela.gnu.linkonce.tb.*}) }
+  .rel.ctors    ${RELOCATING-0} : { *(.rel.ctors) }
+  .rela.ctors   ${RELOCATING-0} : { *(.rela.ctors) }
+  .rel.dtors    ${RELOCATING-0} : { *(.rel.dtors) }
+  .rela.dtors   ${RELOCATING-0} : { *(.rela.dtors) }
+  .rel.got      ${RELOCATING-0} : { *(.rel.got) }
+  .rela.got     ${RELOCATING-0} : { *(.rela.got) }
+  ${OTHER_GOT_RELOC_SECTIONS}
+  ${REL_SDATA}
+  ${REL_SBSS}
+  ${REL_SDATA2}
+  ${REL_SBSS2}
+  .rel.bss      ${RELOCATING-0} : { *(.rel.bss${RELOCATING+ .rel.bss.* .rel.gnu.linkonce.b.*}) }
+  .rela.bss     ${RELOCATING-0} : { *(.rela.bss${RELOCATING+ .rela.bss.* .rela.gnu.linkonce.b.*}) }
+  ${REL_LARGE}
+  .rel.ifunc      ${RELOCATING-0} : { *(.rel.ifunc) }
+  .rela.ifunc     ${RELOCATING-0} : { *(.rela.ifunc) }
+EOF
+
+if [ -n "$COMBRELOC" ]; then
+cat >> ldscripts/dyntmp.$$ <<EOF
+  .rel.dyn      ${RELOCATING-0} :
+    {
+EOF
+sed -e '/^[ 	]*[{}][ 	]*$/d;/:[ 	]*$/d;/\.rela\./d;s/^.*: { *\(.*\)}$/      \1/' $COMBRELOC >> ldscripts/dyntmp.$$
+cat >> ldscripts/dyntmp.$$ <<EOF
+    }
+  .rela.dyn     ${RELOCATING-0} :
+    {
+EOF
+sed -e '/^[ 	]*[{}][ 	]*$/d;/:[ 	]*$/d;/\.rel\./d;s/^.*: { *\(.*\)}/      \1/' $COMBRELOC >> ldscripts/dyntmp.$$
+cat >> ldscripts/dyntmp.$$ <<EOF
+    }
+EOF
+fi
+
+cat >> ldscripts/dyntmp.$$ <<EOF
+  .rel.plt      ${RELOCATING-0} :
+    {
+      *(.rel.plt)
+      ${RELOCATING+${CREATE_SHLIB-PROVIDE_HIDDEN (${USER_LABEL_PREFIX}__rel_iplt_start = .);}}
+      *(.rel.iplt)
+      ${RELOCATING+${CREATE_SHLIB-PROVIDE_HIDDEN (${USER_LABEL_PREFIX}__rel_iplt_end = .);}}
+    }
+  .rela.plt     ${RELOCATING-0} :
+    {
+      *(.rela.plt)
+      ${RELOCATING+${CREATE_SHLIB-PROVIDE_HIDDEN (${USER_LABEL_PREFIX}__rela_iplt_start = .);}}
+      *(.rela.iplt)
+      ${RELOCATING+${CREATE_SHLIB-PROVIDE_HIDDEN (${USER_LABEL_PREFIX}__rela_iplt_end = .);}}
+    }
+  ${OTHER_PLT_RELOC_SECTIONS}
+EOF
+
+if test -z "${NON_ALLOC_DYN}"; then
+  if test -z "${NO_REL_RELOCS}${NO_RELA_RELOCS}"; then
+    cat ldscripts/dyntmp.$$
+  else
+    if test -z "${NO_REL_RELOCS}"; then
+      sed -e '/^[ 	]*\.rela\.[^}]*$/,/}/d' -e '/^[ 	]*\.rela\./d' ldscripts/dyntmp.$$
+    fi
+    if test -z "${NO_RELA_RELOCS}"; then
+      sed -e '/^[ 	]*\.rel\.[^}]*$/,/}/d' -e '/^[ 	]*\.rel\./d' ldscripts/dyntmp.$$
+    fi
+  fi
+  rm -f ldscripts/dyntmp.$$
+fi
+
+cat <<EOF
+  .init         ${RELOCATING-0} : 
+  { 
+    ${RELOCATING+${INIT_START}}
+    KEEP (*(.init))
+    ${RELOCATING+${INIT_END}}
+  } :text =${NOP-0}
+
+  ${TEXT_PLT+${PLT}}
+  ${TINY_READONLY_SECTION}
+  .text         ${RELOCATING-0} :
+  {
+    ${RELOCATING+${TEXT_START_SYMBOLS}}
+    *(.text .stub${RELOCATING+ .text.* .gnu.linkonce.t.*})
+    /* .gnu.warning sections are handled specially by elf32.em.  */
+    *(.gnu.warning)
+    ${RELOCATING+${OTHER_TEXT_SECTIONS}}
+  } =${NOP-0}
+  .fini         ${RELOCATING-0} :
+  {
+    ${RELOCATING+${FINI_START}}
+    KEEP (*(.fini))
+    ${RELOCATING+${FINI_END}}
+  } =${NOP-0}
+  ${RELOCATING+PROVIDE (__${ETEXT_NAME} = .);}
+  ${RELOCATING+PROVIDE (_${ETEXT_NAME} = .);}
+  ${RELOCATING+PROVIDE (${ETEXT_NAME} = .);}
+  ${RELOCATING+. = DEFINED (__executable_start) ? 
+                     ALIGN(CEILP2(. - __executable_start)) : .;}
+  ${RELOCATING+PROVIDE (__nacl_and_mask =
+                          DEFINED (__executable_start) ?
+                            NACL_MASK (. - __executable_start) : 0xffffffff);}
+  . = . + 32; /* reserve space for HLTs */
+  . = ALIGN(CONSTANT (MAXPAGESIZE)); /* nacl wants page alignment */
+  ${WRITABLE_RODATA-${RODATA}} :rodata
+  .rodata1      ${RELOCATING-0} : { *(.rodata1) }
+  .nacl_rpc_methods : { *(.nacl_rpc_methods) }
+  ${CREATE_SHLIB-${SDATA2}}
+  ${CREATE_SHLIB-${SBSS2}}
+  ${OTHER_READONLY_SECTIONS}
+  .eh_frame_hdr : { *(.eh_frame_hdr) }
+  .eh_frame     ${RELOCATING-0} : ONLY_IF_RO { KEEP (*(.eh_frame)) }
+  .gcc_except_table ${RELOCATING-0} : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }
+
+  /* Adjust the address for the data segment.  We want to adjust up to
+     the same address within the page on the next page up.  */
+  ${CREATE_SHLIB-${CREATE_PIE-${RELOCATING+. = ${DATA_ADDR-${DATA_SEGMENT_ALIGN}};}}}
+  ${CREATE_SHLIB+${RELOCATING+. = ${SHLIB_DATA_ADDR-${DATA_SEGMENT_ALIGN}};}}
+  ${CREATE_PIE+${RELOCATING+. = ${SHLIB_DATA_ADDR-${DATA_SEGMENT_ALIGN}};}}
+
+  /* Exception handling  */
+  .eh_frame     ${RELOCATING-0} : ONLY_IF_RW { KEEP (*(.eh_frame)) }
+  .gcc_except_table ${RELOCATING-0} : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }
+
+  /* Thread Local Storage sections  */
+  /* The total size of the TLS template area must be a multiple of 0x20,
+   * but it's size calculation is hardcoded in bfd_elf_final_link function
+   * so the only thing we can do is align segments here properly */
+  .tdata	${RELOCATING+ALIGN(0x20)}${RELOCATING-0} : {
+    ${RELOCATING+PROVIDE (__tls_template_start = .);}
+    *(.tdata${RELOCATING+ .tdata.* .gnu.linkonce.td.*})
+    ${RELOCATING+. = ALIGN(0x20);}
+    ${RELOCATING+PROVIDE (__tls_template_tdata_end = .);}
+  }
+  .tbss		${RELOCATING+ALIGN(0x20)}${RELOCATING-0} : {
+    *(.tbss${RELOCATING+ .tbss.* .gnu.linkonce.tb.*})${RELOCATING+ *(.tcommon)}
+    ${RELOCATING+. = ALIGN(0x20);}
+  }
+  /* . does not advance for tbss because it is not loaded. */
+  ${RELOCATING+PROVIDE (__tls_template_end = . + SIZEOF(.tbss));}
+  .preinit_array   ${RELOCATING-0} :
+  {
+    ${RELOCATING+${CREATE_SHLIB-PROVIDE_HIDDEN (${USER_LABEL_PREFIX}__preinit_array_start = .);}}
+    KEEP (*(.preinit_array))
+    ${RELOCATING+${CREATE_SHLIB-PROVIDE_HIDDEN (${USER_LABEL_PREFIX}__preinit_array_end = .);}}
+  }
+  .init_array   ${RELOCATING-0} :
+  {
+     ${RELOCATING+${CREATE_SHLIB-PROVIDE_HIDDEN (${USER_LABEL_PREFIX}__init_array_start = .);}}
+     KEEP (*(SORT(.init_array.*)))
+     KEEP (*(.init_array))
+     ${RELOCATING+${CREATE_SHLIB-PROVIDE_HIDDEN (${USER_LABEL_PREFIX}__init_array_end = .);}}
+  }
+  .fini_array   ${RELOCATING-0} :
+  {
+    ${RELOCATING+${CREATE_SHLIB-PROVIDE_HIDDEN (${USER_LABEL_PREFIX}__fini_array_start = .);}}
+    KEEP (*(.fini_array))
+    KEEP (*(SORT(.fini_array.*)))
+    ${RELOCATING+${CREATE_SHLIB-PROVIDE_HIDDEN (${USER_LABEL_PREFIX}__fini_array_end = .);}}
+  }
+  ${SMALL_DATA_CTOR-${RELOCATING+${CTOR}}}
+  ${SMALL_DATA_DTOR-${RELOCATING+${DTOR}}}
+  .jcr          ${RELOCATING-0} : { KEEP (*(.jcr)) }
+
+  ${RELOCATING+${DATARELRO}}
+  ${OTHER_RELRO_SECTIONS}
+  ${TEXT_DYNAMIC-${DYNAMIC}}
+  ${DATA_GOT+${RELRO_NOW+${GOT}}}
+  ${DATA_GOT+${RELRO_NOW+${GOTPLT}}}
+  ${DATA_GOT+${RELRO_NOW-${SEPARATE_GOTPLT+${GOT}}}}
+  ${RELOCATING+${DATA_SEGMENT_RELRO_END}}
+  ${DATA_GOT+${RELRO_NOW-${SEPARATE_GOTPLT-${GOT}}}}
+  ${DATA_GOT+${RELRO_NOW-${GOTPLT}}}
+
+  ${DATA_PLT+${PLT_BEFORE_GOT-${PLT}}}
+
+  ${RELOCATING+. = ALIGN(${MAXPAGESIZE});} /* nacl wants page alignment */
+  .data         ${RELOCATING-0} :
+  {
+    ${RELOCATING+${DATA_START_SYMBOLS}}
+    *(.data${RELOCATING+ .data.* .gnu.linkonce.d.*})
+    ${CONSTRUCTING+SORT(CONSTRUCTORS)}
+  } :data
+  .data1        ${RELOCATING-0} : { *(.data1) }
+  ${WRITABLE_RODATA+${RODATA}}
+  ${OTHER_READWRITE_SECTIONS}
+  ${SMALL_DATA_CTOR+${RELOCATING+${CTOR}}}
+  ${SMALL_DATA_DTOR+${RELOCATING+${DTOR}}}
+  ${DATA_PLT+${PLT_BEFORE_GOT+${PLT}}}
+  ${SDATA_GOT+${RELOCATING+${OTHER_GOT_SYMBOLS}}}
+  ${SDATA_GOT+${GOT}}
+  ${SDATA_GOT+${OTHER_GOT_SECTIONS}}
+  ${SDATA}
+  ${OTHER_SDATA_SECTIONS}
+  ${RELOCATING+${DATA_END_SYMBOLS-${USER_LABEL_PREFIX}_edata = .; PROVIDE (${USER_LABEL_PREFIX}edata = .);}}
+  ${RELOCATING+__bss_start = .;}
+  ${RELOCATING+${OTHER_BSS_SYMBOLS}}
+  ${SBSS}
+  ${BSS_PLT+${PLT}}
+  .bss          ${RELOCATING-0} :
+  {
+   *(.dynbss)
+   *(.bss${RELOCATING+ .bss.* .gnu.linkonce.b.*})
+   *(COMMON)
+   /* Align here to ensure that the .bss section occupies space up to
+      _end.  Align after .bss to ensure correct alignment even if the
+      .bss section disappears because there are no input sections.
+      FIXME: Why do we need it? When there is no .bss section, we don't
+      pad the .data section.  */
+   ${RELOCATING+. = ALIGN(. != 0 ? ${ALIGNMENT} : 1);}
+  }
+  ${OTHER_BSS_SECTIONS}
+  ${RELOCATING+${OTHER_BSS_END_SYMBOLS}}
+  ${RELOCATING+. = ALIGN(${ALIGNMENT});}
+  ${LARGE_SECTIONS}
+  ${RELOCATING+. = ALIGN(${ALIGNMENT});}
+  ${RELOCATING+${OTHER_END_SYMBOLS}}
+  ${RELOCATING+${END_SYMBOLS-${USER_LABEL_PREFIX}_end = .; PROVIDE (${USER_LABEL_PREFIX}end = .);}}
+  ${RELOCATING+${DATA_SEGMENT_END}}
+EOF
+
+if test -n "${NON_ALLOC_DYN}"; then
+  if test -z "${NO_REL_RELOCS}${NO_RELA_RELOCS}"; then
+    cat ldscripts/dyntmp.$$
+  else
+    if test -z "${NO_REL_RELOCS}"; then
+      sed -e '/^[ 	]*\.rela\.[^}]*$/,/}/d' -e '/^[ 	]*\.rela\./d' ldscripts/dyntmp.$$
+    fi
+    if test -z "${NO_RELA_RELOCS}"; then
+      sed -e '/^[ 	]*\.rel\.[^}]*$/,/}/d' -e '/^[ 	]*\.rel\./d' ldscripts/dyntmp.$$
+    fi
+  fi
+  rm -f ldscripts/dyntmp.$$
+fi
+
+cat <<EOF
+  /* Stabs debugging sections.  */
+  .stab          0 : { *(.stab) }
+  .stabstr       0 : { *(.stabstr) }
+  .stab.excl     0 : { *(.stab.excl) }
+  .stab.exclstr  0 : { *(.stab.exclstr) }
+  .stab.index    0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+
+  .comment       0 : { *(.comment) }
+
+  /* DWARF debug sections.
+     Symbols in the DWARF debugging sections are relative to the beginning
+     of the section so we begin them at 0.  */
+
+  /* DWARF 1 */
+  .debug          0 : { *(.debug) }
+  .line           0 : { *(.line) }
+
+  /* GNU DWARF 1 extensions */
+  .debug_srcinfo  0 : { *(.debug_srcinfo) }
+  .debug_sfnames  0 : { *(.debug_sfnames) }
+
+  /* DWARF 1.1 and DWARF 2 */
+  .debug_aranges  0 : { *(.debug_aranges) }
+  .debug_pubnames 0 : { *(.debug_pubnames) }
+
+  /* DWARF 2 */
+  .debug_info     0 : { *(.debug_info${RELOCATING+ .gnu.linkonce.wi.*}) }
+  .debug_abbrev   0 : { *(.debug_abbrev) }
+  .debug_line     0 : { *(.debug_line) }
+  .debug_frame    0 : { *(.debug_frame) }
+  .debug_str      0 : { *(.debug_str) }
+  .debug_loc      0 : { *(.debug_loc) }
+  .debug_macinfo  0 : { *(.debug_macinfo) }
+
+  /* SGI/MIPS DWARF 2 extensions */
+  .debug_weaknames 0 : { *(.debug_weaknames) }
+  .debug_funcnames 0 : { *(.debug_funcnames) }
+  .debug_typenames 0 : { *(.debug_typenames) }
+  .debug_varnames  0 : { *(.debug_varnames) }
+
+  /* DWARF 3 */
+  .debug_pubtypes 0 : { *(.debug_pubtypes) }
+  .debug_ranges   0 : { *(.debug_ranges) }
+
+  ${TINY_DATA_SECTION}
+  ${TINY_BSS_SECTION}
+
+  ${STACK_ADDR+${STACK}}
+  ${ATTRS_SECTIONS}
+  ${OTHER_SECTIONS}
+  ${RELOCATING+${OTHER_SYMBOLS}}
+  ${RELOCATING+${DISCARDED}}
+}
+EOF
diff -uNr binutils-2.20.orig/opcodes/Makefile.am binutils-2.20/opcodes/Makefile.am
--- binutils-2.20.orig/opcodes/Makefile.am	2009-09-07 14:07:53.000000000 +0200
+++ binutils-2.20/opcodes/Makefile.am	2010-01-06 20:21:21.000000000 +0100
@@ -465,7 +465,7 @@
 $(srcdir)/i386-tbl.h: $(srcdir)/i386-init.h 
 	@echo $@
 
-$(srcdir)/i386-init.h: @MAINT@ i386-gen$(EXEEXT_FOR_BUILD) i386-opc.tbl i386-reg.tbl
+$(srcdir)/i386-init.h: i386-gen$(EXEEXT_FOR_BUILD) i386-opc.tbl i386-reg.tbl
 	./i386-gen$(EXEEXT_FOR_BUILD) --srcdir $(srcdir)
 
 i386-opc.lo: $(srcdir)/i386-tbl.h
diff -uNr binutils-2.20.orig/opcodes/Makefile.in binutils-2.20/opcodes/Makefile.in
--- binutils-2.20.orig/opcodes/Makefile.in	2009-09-07 14:08:03.000000000 +0200
+++ binutils-2.20/opcodes/Makefile.in	2010-01-06 20:21:30.000000000 +0100
@@ -1304,7 +1304,7 @@
 $(srcdir)/i386-tbl.h: $(srcdir)/i386-init.h 
 	@echo $@
 
-$(srcdir)/i386-init.h: @MAINT@ i386-gen$(EXEEXT_FOR_BUILD) i386-opc.tbl i386-reg.tbl
+$(srcdir)/i386-init.h: i386-gen$(EXEEXT_FOR_BUILD) i386-opc.tbl i386-reg.tbl
 	./i386-gen$(EXEEXT_FOR_BUILD) --srcdir $(srcdir)
 
 i386-opc.lo: $(srcdir)/i386-tbl.h
diff -Naur ../PRISTINE/binutils-2.20/opcodes/i386-opc.tbl binutils-2.20/opcodes/i386-opc.tbl
--- ../PRISTINE/binutils-2.20/opcodes/i386-opc.tbl	2009-07-24 08:41:20.000000000 -0700
+++ binutils-2.20/opcodes/i386-opc.tbl	2010-01-05 13:21:03.861105000 -0800
@@ -209,6 +209,36 @@
 or, 2, 0xc, None, 1, 0, W|No_sSuf|No_ldSuf, { Imm8|Imm16|Imm32|Imm32S, Acc|Byte|Word|Dword|Qword }
 or, 2, 0x80, 0x1, 1, 0, W|Modrm|No_sSuf|No_ldSuf, { Imm8|Imm16|Imm32|Imm32S, Reg8|Reg16|Reg32|Reg64|Byte|Word|Dword|Qword|Unspecified|BaseIndex|Disp8|Disp16|Disp32|Disp32S }
 
+// Native client support instructions.
+naclcall, 1, 0xff, 0x2, 1, CpuNo64, Modrm|DefaultSize|No_bSuf|No_wSuf|No_lSuf|No_sSuf|No_qSuf|No_ldSuf, { Reg32 }
+nacljmp, 1, 0xff, 0x4, 1, CpuNo64, Modrm|DefaultSize|No_bSuf|No_wSuf|No_lSuf|No_sSuf|No_qSuf|No_ldSuf, { Reg32 }
+naclcall, 2, 0xff, 0x2, 1, Cpu64, Modrm|DefaultSize|No_bSuf|No_wSuf|No_lSuf|No_sSuf|No_qSuf|No_ldSuf, { Reg32, Reg64 }
+nacljmp, 2, 0xff, 0x4, 1, Cpu64, Modrm|DefaultSize|No_bSuf|No_wSuf|No_lSuf|No_sSuf|No_qSuf|No_ldSuf, { Reg32, Reg64 }
+naclasp, 2, 0x01, None, 1, Cpu64, W|Modrm|No_sSuf|No_ldSuf, { Imm8S, Reg64 }
+naclasp, 2, 0x01, None, 1, Cpu64, W|Modrm|No_sSuf|No_ldSuf, { Imm32S, Reg64 }
+naclasp, 2, 0x01, None, 1, Cpu64, W|Modrm|No_sSuf|No_ldSuf, { Unspecified|BaseIndex|Disp8|Disp32S|Reg32, Reg64 }
+naclssp, 2, 0x01, None, 1, Cpu64, W|Modrm|No_sSuf|No_ldSuf, { Imm8S, Reg64 }
+naclssp, 2, 0x01, None, 1, Cpu64, W|Modrm|No_sSuf|No_ldSuf, { Imm32S, Reg64 }
+naclssp, 2, 0x01, None, 1, Cpu64, W|Modrm|No_sSuf|No_ldSuf, { Unspecified|BaseIndex|Disp8|Disp32S|Reg32, Reg64 }
+naclspadj, 2, 0x01, None, 1, Cpu64, W|Modrm|No_sSuf|No_ldSuf, { Imm8S, Reg64 }
+naclspadj, 2, 0x01, None, 1, Cpu64, W|Modrm|No_sSuf|No_ldSuf, { Imm32S, Reg64 }
+naclrestbp, 2, 0x01, None, 1, Cpu64, W|Modrm|No_sSuf|No_ldSuf, { Unspecified|BaseIndex|Disp8|Disp32S|Reg32, Reg64 }
+naclrestsp, 2, 0x01, None, 1, Cpu64, W|Modrm|No_sSuf|No_ldSuf, { Unspecified|BaseIndex|Disp8|Disp32S|Reg32, Reg64 }
+
+// Native client string operations
+cmps, 3, 0xa6, None, 1, Cpu64, W|No_sSuf|No_ldSuf|IsString, { Byte|Word|Dword|Qword|Unspecified|BaseIndex|Disp8|Disp16|Disp32|Disp32S|EsSeg, Byte|Word|Dword|Qword|Unspecified|BaseIndex|Disp8|Disp16|Disp32|Disp32S, Reg64 }
+scmp, 3, 0xa6, None, 1, Cpu64, W|No_sSuf|No_ldSuf|IsString, { Byte|Word|Dword|Qword|Unspecified|BaseIndex|Disp8|Disp16|Disp32|Disp32S|EsSeg, Byte|Word|Dword|Qword|Unspecified|BaseIndex|Disp8|Disp16|Disp32|Disp32S, Reg64 }
+ins, 3, 0x6c, None, 1, Cpu64, W|No_sSuf|No_qSuf|No_ldSuf|IsString, { InOutPortReg, Byte|Word|Dword|Unspecified|BaseIndex|Disp8|Disp16|Disp32|Disp32S|EsSeg, Reg64 }
+outs, 3, 0x6e, None, 1, Cpu64, W|No_sSuf|No_qSuf|No_ldSuf|IsString, { Byte|Word|Dword|Unspecified|BaseIndex|Disp8|Disp16|Disp32|Disp32S, InOutPortReg, Reg64 }
+lods, 3, 0xac, None, 1, Cpu64, W|No_sSuf|No_ldSuf|IsString, { Byte|Word|Dword|Qword|Unspecified|BaseIndex|Disp8|Disp16|Disp32|Disp32S, Acc|Byte|Word|Dword|Qword, Reg64 }
+slod, 3, 0xac, None, 1, Cpu64, W|No_sSuf|No_ldSuf|IsString, { Byte|Word|Dword|Qword|Unspecified|BaseIndex|Disp8|Disp16|Disp32|Disp32S, Acc|Byte|Word|Dword|Qword, Reg64 }
+movs, 3, 0xa4, None, 1, Cpu64, W|No_sSuf|No_ldSuf|IsString, { Byte|Word|Dword|Qword|Unspecified|BaseIndex|Disp8|Disp16|Disp32|Disp32S, Byte|Word|Dword|Qword|Unspecified|BaseIndex|Disp8|Disp16|Disp32|Disp32S|EsSeg, Reg64 }
+smov, 3, 0xa4, None, 1, Cpu64, W|No_sSuf|No_ldSuf|IsString, { Byte|Word|Dword|Qword|Unspecified|BaseIndex|Disp8|Disp16|Disp32|Disp32S, Byte|Word|Dword|Qword|Unspecified|BaseIndex|Disp8|Disp16|Disp32|Disp32S|EsSeg, Reg64 }
+scas, 3, 0xae, None, 1, Cpu64, W|No_sSuf|No_ldSuf|IsString, { Byte|Word|Dword|Qword|Unspecified|BaseIndex|Disp8|Disp16|Disp32|Disp32S|EsSeg, Acc|Byte|Word|Dword|Qword, Reg64 }
+ssca, 3, 0xae, None, 1, Cpu64, W|No_sSuf|No_ldSuf|IsString, { Byte|Word|Dword|Qword|Unspecified|BaseIndex|Disp8|Disp16|Disp32|Disp32S|EsSeg, Acc|Byte|Word|Dword|Qword, Reg64 }
+stos, 3, 0xaa, None, 1, Cpu64, W|No_sSuf|No_ldSuf|IsString, { Acc|Byte|Word|Dword|Qword, Byte|Word|Dword|Qword|Unspecified|BaseIndex|Disp8|Disp16|Disp32|Disp32S|EsSeg, Reg64 }
+ssto, 3, 0xaa, None, 1, Cpu64, W|No_sSuf|No_ldSuf|IsString, { Acc|Byte|Word|Dword|Qword, Byte|Word|Dword|Qword|Unspecified|BaseIndex|Disp8|Disp16|Disp32|Disp32S|EsSeg, Reg64 }
+
 xor, 2, 0x30, None, 1, 0, D|W|Modrm|No_sSuf|No_ldSuf, { Reg8|Reg16|Reg32|Reg64, Reg8|Reg16|Reg32|Reg64|Byte|Word|Dword|Qword|Unspecified|BaseIndex|Disp8|Disp16|Disp32|Disp32S }
 xor, 2, 0x83, 0x6, 1, 0, Modrm|No_bSuf|No_sSuf|No_ldSuf, { Imm8S, Reg16|Reg32|Reg64|Word|Dword|Qword|Unspecified|BaseIndex|Disp8|Disp16|Disp32|Disp32S }
 xor, 2, 0x34, None, 1, 0, W|No_sSuf|No_ldSuf, { Imm8|Imm16|Imm32|Imm32S, Acc|Byte|Word|Dword|Qword }
