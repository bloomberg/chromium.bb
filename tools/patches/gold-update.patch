diff --git a/elfcpp/arm.h b/elfcpp/arm.h
index 7ad827a..397d0d0 100644
--- a/elfcpp/arm.h
+++ b/elfcpp/arm.h
@@ -199,6 +199,135 @@ enum
   // 160 - 255			Unallocated
 };
 
+// e_flags values used for ARM.  We only support flags defined in AAELF.
+
+enum
+{
+  EF_ARM_BE8 = 0x00800000,
+
+  // Mask to extract EABI version, not really a flag value.
+  EF_ARM_EABIMASK = 0xFF000000,
+
+  EF_ARM_EABI_UNKNOWN = 0x00000000,
+  EF_ARM_EABI_VER1 = 0x01000000,
+  EF_ARM_EABI_VER2 = 0x02000000,
+  EF_ARM_EABI_VER3 = 0x03000000,
+  EF_ARM_EABI_VER4 = 0x04000000,
+  EF_ARM_EABI_VER5 = 0x05000000,
+};
+
+// Extract EABI version from flags.
+
+inline Elf_Word
+arm_eabi_version(Elf_Word flags)
+{ return flags & EF_ARM_EABIMASK; }
+
+// Values for the Tag_CPU_arch EABI attribute.
+enum
+{
+  TAG_CPU_ARCH_PRE_V4,
+  TAG_CPU_ARCH_V4,
+  TAG_CPU_ARCH_V4T,
+  TAG_CPU_ARCH_V5T,
+  TAG_CPU_ARCH_V5TE,
+  TAG_CPU_ARCH_V5TEJ,
+  TAG_CPU_ARCH_V6,
+  TAG_CPU_ARCH_V6KZ,
+  TAG_CPU_ARCH_V6T2,
+  TAG_CPU_ARCH_V6K,
+  TAG_CPU_ARCH_V7,
+  TAG_CPU_ARCH_V6_M,
+  TAG_CPU_ARCH_V6S_M,
+  TAG_CPU_ARCH_V7E_M,
+  MAX_TAG_CPU_ARCH = TAG_CPU_ARCH_V7E_M,
+  // Pseudo-architecture to allow objects to be compatible with the subset of
+  // armv4t and armv6-m.  This value should never be stored in object files.
+  TAG_CPU_ARCH_V4T_PLUS_V6_M = (MAX_TAG_CPU_ARCH + 1)
+};
+
+// EABI object attributes.
+enum
+{
+  // 0-3 are generic.
+  Tag_CPU_raw_name = 4,
+  Tag_CPU_name = 5,
+  Tag_CPU_arch = 6,
+  Tag_CPU_arch_profile = 7,
+  Tag_ARM_ISA_use = 8,
+  Tag_THUMB_ISA_use = 9,
+  Tag_VFP_arch = 10,
+  Tag_WMMX_arch = 11,
+  Tag_Advanced_SIMD_arch = 12,
+  Tag_PCS_config = 13,
+  Tag_ABI_PCS_R9_use = 14,
+  Tag_ABI_PCS_RW_data = 15,
+  Tag_ABI_PCS_RO_data = 16,
+  Tag_ABI_PCS_GOT_use = 17,
+  Tag_ABI_PCS_wchar_t = 18,
+  Tag_ABI_FP_rounding = 19,
+  Tag_ABI_FP_denormal = 20,
+  Tag_ABI_FP_exceptions = 21,
+  Tag_ABI_FP_user_exceptions = 22,
+  Tag_ABI_FP_number_model = 23,
+  Tag_ABI_align8_needed = 24,
+  Tag_ABI_align8_preserved = 25,
+  Tag_ABI_enum_size = 26,
+  Tag_ABI_HardFP_use = 27,
+  Tag_ABI_VFP_args = 28,
+  Tag_ABI_WMMX_args = 29,
+  Tag_ABI_optimization_goals = 30,
+  Tag_ABI_FP_optimization_goals = 31,
+  // 32 is generic (Tag_compatibility).
+  Tag_undefined33 = 33,
+  Tag_CPU_unaligned_access = 34,
+  Tag_undefined35 = 35,
+  Tag_VFP_HP_extension = 36,
+  Tag_undefined37 = 37,
+  Tag_ABI_FP_16bit_format = 38,
+  Tag_undefined39 = 39,
+  Tag_nodefaults = 64,
+  Tag_also_compatible_with = 65,
+  Tag_T2EE_use = 66,
+  Tag_conformance = 67,
+  Tag_Virtualization_use = 68,
+  Tag_undefined69 = 69,
+  Tag_MPextension_use = 70
+};
+
+// Values for Tag_ABI_PCS_R9_use.
+enum
+{
+  AEABI_R9_V6 = 0,
+  AEABI_R9_SB = 1,
+  AEABI_R9_TLS = 2,
+  AEABI_R9_unused = 3
+};
+
+// Values for Tag_ABI_PCS_RW_data.
+enum
+{
+  AEABI_PCS_RW_data_absolute = 0,
+  AEABI_PCS_RW_data_PCrel = 1,
+  AEABI_PCS_RW_data_SBrel = 2,
+  AEABI_PCS_RW_data_unused = 3
+};
+
+// Values for Tag_ABI_enum_size.
+enum
+{
+  AEABI_enum_unused = 0,
+  AEABI_enum_short = 1,
+  AEABI_enum_wide = 2,
+  AEABI_enum_forced_wide = 3
+};
+
+// For Exception Index Table. (Exception handling ABI for the ARM
+// architectue, Section 5)
+enum
+{
+  EXIDX_CANTUNWIND = 1,
+};
+
 } // End namespace elfcpp.
 
 #endif // !defined(ELFCPP_ARM_H)
diff --git a/elfcpp/elfcpp.h b/elfcpp/elfcpp.h
index 11b0726..b3d604b 100644
--- a/elfcpp/elfcpp.h
+++ b/elfcpp/elfcpp.h
@@ -656,7 +656,11 @@ enum DT
   DT_FINI_ARRAYSZ = 28,
   DT_RUNPATH = 29,
   DT_FLAGS = 30,
+
+  // This is used to mark a range of dynamic tags.  It is not really
+  // a tag value.
   DT_ENCODING = 32,
+
   DT_PREINIT_ARRAY = 32,
   DT_PREINIT_ARRAYSZ = 33,
   DT_LOOS = 0x6000000d,
diff --git a/gold/ChangeLog b/gold/ChangeLog
index cb32549..6358191 100644
--- a/gold/ChangeLog
+++ b/gold/ChangeLog
@@ -1,3 +1,42 @@
+2009-10-16  Doug Kwan  <dougkwan@google.com>
+
+	* expression.cc (class Segment_start_expression): New class definition.
+	(Segment_start_expression::value): New method definition.
+	(script_exp_function_segment_start): Return a new
+	Segment_start_expression.
+	* gold/script-c.h (script_saw_segment_start_expression): New function
+	prototype.
+	* script-sections.cc (Script_sections::Script_sections): Initialize
+	SAW_SEGMENT_START_EXPRESSION_ to false.
+	(Script_sections::set_section_addresses): Use -Ttext, -Tdata
+	and -Tbbs options to specify section addresses if given in
+	command line and no SEGMENT_START expression is seen in a script.
+	* script-sections.h (Script_sections::saw_segment_start_expression,
+	Script_sections::set_saw_segment_start_expression): New method
+	definition.
+	(Script_sections::saw_segment_start_expression_): New data member
+	declaration.
+	* script.cc (script_saw_segment_start_expression): New function.
+	* yyscript.y (SEGMENT_START): Call script_saw_segment_start_expression.
+	* testsuite/Makefile.am (check_SCRIPTS): Add script_test_6.sh,
+	script_test_7.sh and script_test_8.sh.
+	(check_DATA): Add script_test_6.stdout, script_test_7.stdout and
+	script_test_8.stdout.
+	(MOSTLYCLEANFILES): Add script_test_6, script_test_7 and script_test_8.
+	(script_test_6, script_test_6.stdout, script_test_7,
+	script_test_7.stdout, script_test_8, script_test_8.stdout): New rules.
+	* Makefile.in: Regenerate.
+	* testsuite/script_test_6.sh: New file.
+	* testsuite/script_test_6.t: Same.
+	* testsuite/script_test_7.sh: Same.
+	* testsuite/script_test_7.t: Same.
+	* testsuite/script_test_8.sh: Same.
+
+2009-10-16  Doug Kwan  <dougkwan@google.com>
+
+	* output.cc (Output_segment::set_section_list_address): Cast
+	expressions to unsigned long long type to avoid format warnings.
+
 2009-10-15  Ian Lance Taylor  <iant@google.com>
 
 	* script.cc (Script_options::add_symbol_assignment): Always add a
diff --git a/gold/Makefile.am b/gold/Makefile.am
index 8d8b617..f172128 100644
--- a/gold/Makefile.am
+++ b/gold/Makefile.am
@@ -39,6 +39,7 @@ noinst_LIBRARIES = libgold.a
 
 CCFILES = \
 	archive.cc \
+	attributes.cc \
 	binary.cc \
 	common.cc \
 	compressed_output.cc \
@@ -58,6 +59,7 @@ CCFILES = \
 	gold-threads.cc \
 	icf.cc \
 	incremental.cc \
+	int_encoding.cc \
 	layout.cc \
 	mapfile.cc \
 	merge.cc \
@@ -81,7 +83,9 @@ CCFILES = \
 	workqueue-threads.cc
 
 HFILES = \
+	arm-reloc-property.h \
 	archive.h \
+	attributes.h \
 	binary.h \
 	common.h \
 	compressed_output.h \
@@ -100,6 +104,7 @@ HFILES = \
 	gold.h \
 	gold-threads.h \
 	icf.h \
+	int_encoding.h \
 	layout.h \
 	mapfile.h \
 	merge.h \
@@ -128,16 +133,18 @@ HFILES = \
 YFILES = \
 	yyscript.y
 
+DEFFILES = arm-reloc.def
+
 EXTRA_DIST = yyscript.c yyscript.h
 
 TARGETSOURCES = \
-	i386.cc x86_64.cc sparc.cc powerpc.cc arm.cc
+	i386.cc x86_64.cc sparc.cc powerpc.cc arm.cc arm-reloc-property.cc
 
 ALL_TARGETOBJS = \
 	i386.$(OBJEXT) x86_64.$(OBJEXT) sparc.$(OBJEXT) powerpc.$(OBJEXT) \
-	arm.$(OBJEXT)
+	arm.$(OBJEXT) arm-reloc-property.$(OBJEXT)
 
-libgold_a_SOURCES = $(CCFILES) $(HFILES) $(YFILES)
+libgold_a_SOURCES = $(CCFILES) $(HFILES) $(YFILES) $(DEFFILES)
 libgold_a_LIBADD = $(LIBOBJS)
 
 sources_var = main.cc
diff --git a/gold/Makefile.in b/gold/Makefile.in
index d4c689b..05ebe74 100644
--- a/gold/Makefile.in
+++ b/gold/Makefile.in
@@ -73,16 +73,17 @@ AR = ar
 ARFLAGS = cru
 libgold_a_AR = $(AR) $(ARFLAGS)
 libgold_a_DEPENDENCIES = $(LIBOBJS)
-am__objects_1 = archive.$(OBJEXT) binary.$(OBJEXT) common.$(OBJEXT) \
-	compressed_output.$(OBJEXT) copy-relocs.$(OBJEXT) \
-	cref.$(OBJEXT) defstd.$(OBJEXT) descriptors.$(OBJEXT) \
-	dirsearch.$(OBJEXT) dynobj.$(OBJEXT) dwarf_reader.$(OBJEXT) \
-	ehframe.$(OBJEXT) errors.$(OBJEXT) expression.$(OBJEXT) \
-	fileread.$(OBJEXT) gc.$(OBJEXT) gold.$(OBJEXT) \
-	gold-threads.$(OBJEXT) icf.$(OBJEXT) incremental.$(OBJEXT) \
-	layout.$(OBJEXT) mapfile.$(OBJEXT) merge.$(OBJEXT) \
-	object.$(OBJEXT) options.$(OBJEXT) output.$(OBJEXT) \
-	parameters.$(OBJEXT) plugin.$(OBJEXT) readsyms.$(OBJEXT) \
+am__objects_1 = archive.$(OBJEXT) attributes.$(OBJEXT) \
+	binary.$(OBJEXT) common.$(OBJEXT) compressed_output.$(OBJEXT) \
+	copy-relocs.$(OBJEXT) cref.$(OBJEXT) defstd.$(OBJEXT) \
+	descriptors.$(OBJEXT) dirsearch.$(OBJEXT) dynobj.$(OBJEXT) \
+	dwarf_reader.$(OBJEXT) ehframe.$(OBJEXT) errors.$(OBJEXT) \
+	expression.$(OBJEXT) fileread.$(OBJEXT) gc.$(OBJEXT) \
+	gold.$(OBJEXT) gold-threads.$(OBJEXT) icf.$(OBJEXT) \
+	incremental.$(OBJEXT) int_encoding.$(OBJEXT) layout.$(OBJEXT) \
+	mapfile.$(OBJEXT) merge.$(OBJEXT) object.$(OBJEXT) \
+	options.$(OBJEXT) output.$(OBJEXT) parameters.$(OBJEXT) \
+	plugin.$(OBJEXT) readsyms.$(OBJEXT) \
 	reduced_debug_output.$(OBJEXT) reloc.$(OBJEXT) \
 	resolve.$(OBJEXT) script-sections.$(OBJEXT) script.$(OBJEXT) \
 	stringpool.$(OBJEXT) symtab.$(OBJEXT) target.$(OBJEXT) \
@@ -91,7 +92,7 @@ am__objects_1 = archive.$(OBJEXT) binary.$(OBJEXT) common.$(OBJEXT) \
 am__objects_2 =
 am__objects_3 = yyscript.$(OBJEXT)
 am_libgold_a_OBJECTS = $(am__objects_1) $(am__objects_2) \
-	$(am__objects_3)
+	$(am__objects_3) $(am__objects_2)
 libgold_a_OBJECTS = $(am_libgold_a_OBJECTS)
 PROGRAMS = $(noinst_PROGRAMS)
 am__objects_4 = main.$(OBJEXT)
@@ -350,6 +351,7 @@ am__skipyacc =
 noinst_LIBRARIES = libgold.a
 CCFILES = \
 	archive.cc \
+	attributes.cc \
 	binary.cc \
 	common.cc \
 	compressed_output.cc \
@@ -369,6 +371,7 @@ CCFILES = \
 	gold-threads.cc \
 	icf.cc \
 	incremental.cc \
+	int_encoding.cc \
 	layout.cc \
 	mapfile.cc \
 	merge.cc \
@@ -392,7 +395,9 @@ CCFILES = \
 	workqueue-threads.cc
 
 HFILES = \
+	arm-reloc-property.h \
 	archive.h \
+	attributes.h \
 	binary.h \
 	common.h \
 	compressed_output.h \
@@ -411,6 +416,7 @@ HFILES = \
 	gold.h \
 	gold-threads.h \
 	icf.h \
+	int_encoding.h \
 	layout.h \
 	mapfile.h \
 	merge.h \
@@ -439,15 +445,16 @@ HFILES = \
 YFILES = \
 	yyscript.y
 
+DEFFILES = arm-reloc.def
 EXTRA_DIST = yyscript.c yyscript.h
 TARGETSOURCES = \
-	i386.cc x86_64.cc sparc.cc powerpc.cc arm.cc
+	i386.cc x86_64.cc sparc.cc powerpc.cc arm.cc arm-reloc-property.cc
 
 ALL_TARGETOBJS = \
 	i386.$(OBJEXT) x86_64.$(OBJEXT) sparc.$(OBJEXT) powerpc.$(OBJEXT) \
-	arm.$(OBJEXT)
+	arm.$(OBJEXT) arm-reloc-property.$(OBJEXT)
 
-libgold_a_SOURCES = $(CCFILES) $(HFILES) $(YFILES)
+libgold_a_SOURCES = $(CCFILES) $(HFILES) $(YFILES) $(DEFFILES)
 libgold_a_LIBADD = $(LIBOBJS)
 sources_var = main.cc
 deps_var = $(TARGETOBJS) libgold.a $(LIBIBERTY) $(LIBINTL_DEP)
@@ -579,7 +586,9 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/mremap.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/pread.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/archive.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/arm-reloc-property.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/arm.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/attributes.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/binary.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/common.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/compressed_output.Po@am__quote@
@@ -600,6 +609,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/i386.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/icf.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/incremental.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/int_encoding.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/layout.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/main.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mapfile.Po@am__quote@
diff --git a/gold/arm-reloc-property.cc b/gold/arm-reloc-property.cc
new file mode 100644
index 0000000..4f8fa9e
--- /dev/null
+++ b/gold/arm-reloc-property.cc
@@ -0,0 +1,331 @@
+// arm-reloc-property.cc -- ARM relocation property.
+
+// Copyright 2010 Free Software Foundation, Inc.
+// Written by Doug Kwan <dougkwan@google.com>.
+
+// This file is part of gold.
+
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+// MA 02110-1301, USA.
+
+#include "gold.h"
+
+#include <cstdio>
+#include <cstring>
+#include <stack>
+#include <string>
+#include <vector>
+
+#include "elfcpp.h"
+#include "arm.h"
+#include "arm-reloc-property.h"
+
+namespace gold
+{
+
+// Arm_reloc_property::Tree_node methods.
+
+// Parse an S-expression S and build a tree and return the root node.
+// Caller is responsible for releasing tree after use.
+
+Arm_reloc_property::Tree_node*
+Arm_reloc_property::Tree_node::make_tree(const std::string& s)
+{
+  std::stack<size_t> size_stack;
+  Tree_node_vector node_stack;
+
+  // strtok needs a non-const string pointer.
+  char* buffer = new char[s.size() + 1];
+  memcpy(buffer, s.data(), s.size());
+  buffer[s.size()] = '\0';
+  char* token = strtok(buffer, " ");
+
+  while (token != NULL)
+    {
+      if (strcmp(token, "(") == 0)
+	// Remember the node stack position for start of a new internal node.
+	size_stack.push(node_stack.size());
+      else if (strcmp(token, ")") == 0)
+	{
+	  // Pop all tree nodes after the previous '(' and use them as
+	  // children to build a new internal node.  Push internal node back.
+	  size_t current_size = node_stack.size();
+	  size_t prev_size = size_stack.top();
+	  size_stack.pop();
+	  Tree_node* node =
+	    new Tree_node(node_stack.begin() + prev_size,
+			  node_stack.begin() + current_size); 
+	  node_stack.resize(prev_size);
+	  node_stack.push_back(node);
+	}
+      else
+	// Just push a leaf node to node_stack.
+	node_stack.push_back(new Tree_node(token));
+
+      token = strtok(NULL, " ");
+    }
+
+  delete[] buffer;
+
+  // At this point, size_stack should be empty and node_stack should only
+  // contain the root node.
+  gold_assert(size_stack.empty() && node_stack.size() == 1);
+  return node_stack[0];
+}
+
+// Arm_reloc_property methods.
+
+// Constructor.
+
+Arm_reloc_property::Arm_reloc_property(
+    unsigned int code,
+    const char* name,
+    Reloc_type rtype,
+    bool is_deprecated,
+    Reloc_class rclass,
+    const std::string& operation,
+    bool is_implemented,
+    int group_index,
+    bool checks_overflow)
+  : code_(code), name_(name), reloc_type_(rtype), reloc_class_(rclass),
+    group_index_(group_index), size_(0), align_(1),
+    relative_address_base_(RAB_NONE), is_deprecated_(is_deprecated),
+    is_implemented_(is_implemented), checks_overflow_(checks_overflow),
+    uses_got_entry_(false), uses_got_origin_(false), uses_plt_entry_(false),
+    uses_thumb_bit_(false), uses_symbol_base_(false), uses_addend_(false)
+{
+  // Set size and alignment of static and dynamic relocations.
+  if (rtype == RT_STATIC)
+    {
+      switch (rclass)
+	{
+	case RC_DATA:
+	  // Except for R_ARM_ABS16 and R_ARM_ABS8, all static data relocations
+	  // have size 4.  All static data relocations have alignment of 1.
+	  if (code == elfcpp::R_ARM_ABS8)
+	    this->size_ = 1;
+	  else if (code == elfcpp::R_ARM_ABS16)
+	    this->size_ = 2;
+	  else
+	    this->size_ = 4;
+	  this->align_ = 1;
+	  break;
+	case RC_MISC:
+	  // R_ARM_V4BX should be treated as an ARM relocation.  For all
+	  // others, just use defaults.
+	  if (code != elfcpp::R_ARM_V4BX)
+	    break;
+	  // Fall through.
+	case RC_ARM:
+	  this->size_ = 4;
+	  this->align_ = 4;
+	  break;
+	case RC_THM16:
+	  this->size_ = 2;
+	  this->align_ = 2;
+	  break;
+	case RC_THM32:
+	  this->size_ = 4;
+	  this->align_ = 2;
+	  break;
+	default:
+	  gold_unreachable();
+	}
+    }
+  else if (rtype == RT_DYNAMIC)
+    {
+      // With the exception of R_ARM_COPY, all dynamic relocations requires
+      // that the place being relocated is a word-aligned 32-bit object.
+      if (code != elfcpp::R_ARM_COPY)
+	{
+	  this->size_ = 4;
+	  this->align_ = 4;
+	}
+    }
+
+  // If no relocation operation is specified, we are done.
+  if (operation == "NONE")
+    return;
+
+  // Extract information from relocation operation.
+  Tree_node* root_node = Tree_node::make_tree(operation);
+  Tree_node* node = root_node;
+
+  // Check for an expression of the form XXX - YYY.
+  if (!node->is_leaf()
+      && node->child(0)->is_leaf()
+      && node->child(0)->name() == "-")
+    {
+      struct RAB_table_entry
+      {
+	Relative_address_base rab;
+	const char* name;
+      };
+
+      static const RAB_table_entry rab_table[] =
+      {
+	{ RAB_B_S, "( B S )" },
+	{ RAB_DELTA_B_S, "( DELTA_B ( S ) )" },
+      	{ RAB_GOT_ORG, "GOT_ORG" },
+      	{ RAB_P, "P" },
+      	{ RAB_Pa, "Pa" },
+      	{ RAB_TLS, "TLS" },
+      	{ RAB_tp, "tp" }
+      };
+
+      static size_t rab_table_size = sizeof(rab_table) / sizeof(rab_table[0]);
+      const std::string rhs(node->child(2)->s_expression());
+      for (size_t i = 0; i < rab_table_size; ++i)
+	if (rhs == rab_table[i].name)
+	  {
+	    this->relative_address_base_ = rab_table[i].rab;
+	    break;
+	  }
+
+      gold_assert(this->relative_address_base_ != RAB_NONE);
+      if (this->relative_address_base_ == RAB_B_S)
+	this->uses_symbol_base_ = true;
+      node = node->child(1);
+    }
+
+  // Check for an expression of the form XXX | T.
+  if (!node->is_leaf()
+      && node->child(0)->is_leaf()
+      && node->child(0)->name() == "|")
+    {
+      gold_assert(node->number_of_children() == 3
+		  && node->child(2)->is_leaf()
+		  && node->child(2)->name() == "T");
+      this->uses_thumb_bit_ = true;
+      node = node->child(1);
+    }
+
+  // Check for an expression of the form XXX + A.
+  if (!node->is_leaf()
+      && node->child(0)->is_leaf()
+      && node->child(0)->name() == "+")
+    {
+      gold_assert(node->number_of_children() == 3
+		  && node->child(2)->is_leaf()
+		  && node->child(2)->name() == "A");
+      this->uses_addend_ = true;
+      node = node->child(1);
+    }
+
+  // Check for an expression of the form XXX(S).
+  if (!node->is_leaf() && node->child(0)->is_leaf())
+    {
+      gold_assert(node->number_of_children() == 2
+		  && node->child(1)->is_leaf()
+		  && node->child(1)->name() == "S");
+      const std::string func(node->child(0)->name());
+      if (func == "B")
+	this->uses_symbol_base_ = true;
+      else if (func == "GOT")
+	this->uses_got_entry_ = true;
+      else if (func == "PLT")
+	this->uses_plt_entry_ = true;
+      else if (func == "Module" || func == "DELTA_B")
+	// These are used in dynamic relocations.
+	;
+      else
+	gold_unreachable();
+      node = node->child(1);
+    }
+
+  gold_assert(node->is_leaf() && node->name() == "S");
+
+  delete root_node;
+}
+
+// Arm_reloc_property_table methods.
+
+// Constructor.  This processing informations in arm-reloc.def to
+// initialize the table.
+
+Arm_reloc_property_table::Arm_reloc_property_table()
+{
+  // These appers in arm-reloc.def.  Do not rename them.
+  Parse_expression A("A"), GOT_ORG("GOT_ORG"), NONE("NONE"), P("P"),
+		   Pa("Pa"), S("S"), T("T"), TLS("TLS"), tp("tp");
+  const bool Y(true), N(false);
+
+  for (unsigned int i = 0; i < Property_table_size; ++i)
+    this->table_[i] = NULL;
+
+#undef RD
+#define RD(name, type, deprecated, class, operation, is_implemented, \
+	   group_index, checks_oveflow) \
+  do \
+    { \
+      unsigned int code = elfcpp::R_ARM_##name; \
+      gold_assert(code < Property_table_size); \
+      this->table_[code] = \
+	new Arm_reloc_property(elfcpp::R_ARM_##name, "R_ARM_" #name, \
+			       Arm_reloc_property::RT_##type, deprecated, \
+			       Arm_reloc_property::RC_##class, \
+			       (operation).s_expression(), is_implemented, \
+			       group_index, checks_oveflow); \
+    } \
+  while(0);
+
+#include "arm-reloc.def"
+#undef RD
+}
+
+// Return a string describing a relocation code that fails to get a
+// relocation property in get_implemented_static_reloc_property().
+
+std::string
+Arm_reloc_property_table::reloc_name_in_error_message(unsigned int code)
+{
+  gold_assert(code < Property_table_size);
+
+  const Arm_reloc_property* arp = this->table_[code];
+
+  if (arp == NULL)
+    {
+      char buffer[100];
+      sprintf(buffer, _("invalid reloc %u"), code);
+      return std::string(buffer);
+    }
+  
+  // gold only implements static relocation codes.
+  Arm_reloc_property::Reloc_type reloc_type = arp->reloc_type();
+  gold_assert(reloc_type == Arm_reloc_property::RT_STATIC
+	      || !arp->is_implemented());
+
+  const char* prefix = NULL;
+  switch (reloc_type)
+    {
+    case Arm_reloc_property::RT_STATIC:
+      prefix = arp->is_implemented() ? _("reloc ") : _("unimplemented reloc ");
+      break;
+    case Arm_reloc_property::RT_DYNAMIC:
+      prefix = _("dynamic reloc ");
+      break;
+    case Arm_reloc_property::RT_PRIVATE:
+      prefix = _("private reloc ");
+      break;
+    case Arm_reloc_property::RT_OBSOLETE:
+      prefix = _("obsolete reloc ");
+      break;
+    default:
+      gold_unreachable();
+    }
+  return std::string(prefix) + arp->name();
+}
+
+} // End namespace gold.
diff --git a/gold/arm-reloc-property.h b/gold/arm-reloc-property.h
new file mode 100644
index 0000000..349d862
--- /dev/null
+++ b/gold/arm-reloc-property.h
@@ -0,0 +1,379 @@
+// arm-reloc-property.h -- ARM relocation properties   -*- C++ -*-
+
+// Copyright 2010 Free Software Foundation, Inc.
+// Written by Doug Kwan <dougkwan@google.com>.
+
+// This file is part of gold.
+
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+// MA 02110-1301, USA.
+
+#ifndef GOLD_ARM_RELOC_PROPERTY_H
+#define GOLD_ARM_RELOC_PROPERTY_H
+
+namespace gold
+{
+// The Arm_reloc_property class is to store information about a paticular
+// relocation code.
+
+class Arm_reloc_property
+{
+ public:
+  // Types of relocation codes.
+  enum Reloc_type {
+    RT_NONE,		// No relocation type.
+    RT_STATIC,	// Relocations processed by static linkers.
+    RT_DYNAMIC,	// Relocations processed by dynamic linkers.
+    RT_PRIVATE,	// Private relocations, not supported by gold.
+    RT_OBSOLETE	// Obsolete relocations that should not be used.
+  };
+
+  // Classes of relocation codes.
+  enum Reloc_class {
+    RC_NONE,	// No relocation class.
+    RC_DATA,	// Data relocation.
+    RC_ARM,	// ARM instruction relocation.
+    RC_THM16,	// 16-bit THUMB instruction relocation.
+    RC_THM32,	// 32-bit THUMB instruction relocation.
+    RC_MISC	// Miscellaneous class.
+  };
+
+  // Types of bases of relative addressing relocation codes.
+  enum Relative_address_base {
+    RAB_NONE,		// Relocation is not relative addressing
+    RAB_B_S,		// Address origin of output segment of defining symbol.
+    RAB_DELTA_B_S,	// Change of address origin.
+    RAB_GOT_ORG,	// Origin of GOT.
+    RAB_P,		// Address of the place being relocated.
+    RAB_Pa,		// Adjusted address (P & 0xfffffffc).
+    RAB_TLS,		// Thread local storage.
+    RAB_tp		// Thread pointer.
+  };
+
+  // Relocation code represented by this.
+  unsigned int
+  code() const
+  { return this->code_; }
+
+  // Name of the relocation code.
+  const std::string&
+  name() const
+  { return this->name_; }
+  
+  // Type of relocation code.
+  Reloc_type
+  reloc_type() const
+  { return this->reloc_type_; }
+
+  // Whether this code is deprecated.
+  bool
+  is_deprecated() const
+  { return this->is_deprecated_; }
+
+  // Class of relocation code.
+  Reloc_class
+  reloc_class() const
+  { return this->reloc_class_; }
+
+  // Whether this code is implemented in gold.
+  bool
+  is_implemented() const
+  { return this->is_implemented_; }
+
+  // If code is a group relocation code, return the group number, otherwise -1.
+  int
+  group_index() const
+  { return this->group_index_; }
+
+  // Whether relocation checks for overflow.
+  bool
+  checks_overflow() const
+  { return this->checks_overflow_; }
+
+  // Return size of relocation.
+  size_t
+  size() const
+  { return this->size_; }
+
+  // Return alignment of relocation.
+  size_t
+  align() const
+  { return this->align_; }
+
+  // Whether relocation use a GOT entry.
+  bool
+  uses_got_entry() const
+  { return this->uses_got_entry_; }
+
+  // Whether relocation use a GOT origin.
+  bool
+  uses_got_origin() const
+  { return this->uses_got_origin_; }
+  
+  // Whether relocation uses the Thumb-bit in a symbol address.
+  bool
+  uses_thumb_bit() const
+  { return this->uses_thumb_bit_; }
+
+  // Whether relocation uses the symbol base.
+  bool
+  uses_symbol_base() const
+  { return this->uses_symbol_base_; }
+
+  // Return the type of relative address base or RAB_NONE if this
+  // is not a relative addressing relocation.
+  Relative_address_base
+  relative_address_base() const
+  { return this->relative_address_base_; } 
+
+ protected:
+  // These are protected.  We only allow Arm_reloc_property_table to
+  // manage Arm_reloc_property. 
+  Arm_reloc_property(unsigned int code, const char* name, Reloc_type rtype,
+		     bool is_deprecated, Reloc_class rclass,
+		     const std::string& operation, bool is_implemented,
+		     int group_index, bool checks_overflow);
+
+  friend class Arm_reloc_property_table;
+  
+ private:
+  // Copying is not allowed.
+  Arm_reloc_property(const Arm_reloc_property&);
+  Arm_reloc_property& operator=(const Arm_reloc_property&);
+
+  // The Tree_node class is used to represent parsed relocation operations. 
+  // We look at Trees to extract information about relocation operations.
+  class Tree_node
+  {
+   public:
+    typedef std::vector<Tree_node*> Tree_node_vector;
+
+    // Construct a leaf node.
+    Tree_node(const char* name)
+      : is_leaf_(true), name_(name), children_()
+    { }
+
+    // Construct an internal node.  A node owns all its children and is
+    // responsible for releasing them at its own destruction.
+    Tree_node(Tree_node_vector::const_iterator begin,
+	      Tree_node_vector::const_iterator end)
+      : is_leaf_(false), name_(), children_()
+    {
+      for (Tree_node_vector::const_iterator p = begin; p != end; ++p)
+	this->children_.push_back(*p);
+    }
+
+    ~Tree_node()
+    {
+      for(size_t i = 0; i <this->children_.size(); ++i)
+	delete this->children_[i];
+    }
+
+    // Whether this is a leaf node.
+    bool
+    is_leaf() const
+    { return this->is_leaf_; }
+
+    // Return name of this.  This is only valid for a leaf node.
+    const std::string&
+    name() const
+    {
+      gold_assert(this->is_leaf_);
+      return this->name_;
+    }
+
+    // Return the number of children.  This is only valid for a non-leaf node.
+    size_t
+    number_of_children() const
+    {
+      gold_assert(!this->is_leaf_);
+      return this->children_.size();
+    }
+
+    // Return the i-th child of this.  This is only valid for a non-leaf node.
+    Tree_node*
+    child(size_t i) const
+    {
+      gold_assert(!this->is_leaf_ && i < this->children_.size());
+      return this->children_[i];
+    }
+
+    // Parse an S-expression string and build a tree and return the root node.
+    // Caller is responsible for releasing tree after use.
+    static Tree_node*
+    make_tree(const std::string&);
+
+    // Convert a tree back to an S-expression string.
+    std::string
+    s_expression() const
+    {
+      if (this->is_leaf_)
+	return this->name_;
+
+      // Concatenate S-expressions of children. Enclose them with
+      // a pair of parentheses and use space as token delimiters.
+      std::string s("(");
+      for(size_t i = 0; i <this->children_.size(); ++i)
+	s = s + " " + this->children_[i]->s_expression();
+      return s + " )";
+    }
+
+   private:
+    // Whether this is a leaf node.
+    bool is_leaf_;
+    // Name of this if this is a leaf node.
+    std::string name_;
+    // Children of this if this a non-leaf node.
+    Tree_node_vector children_;
+  };
+
+  // Relocation code.
+  unsigned int code_;
+  // Relocation name.
+  std::string name_;
+  // Type of relocation.
+  Reloc_type reloc_type_;
+  // Class of relocation.
+  Reloc_class reloc_class_;
+  // Group index (0, 1, or 2) if this is a group relocation or -1 otherwise.
+  int group_index_; 
+  // Size of relocation.
+  size_t size_;
+  // Alignment of relocation.
+  size_t align_;
+  // Relative address base.
+  Relative_address_base relative_address_base_;
+  // Whether this is deprecated.
+  bool is_deprecated_ : 1;
+  // Whether this is implemented in gold.
+  bool is_implemented_ : 1;
+  // Whether this checks overflow.
+  bool checks_overflow_ : 1;
+  // Whether this uses a GOT entry.
+  bool uses_got_entry_ : 1;
+  // Whether this uses a GOT origin.
+  bool uses_got_origin_ : 1;
+  // Whether this uses a PLT entry.
+  bool uses_plt_entry_ : 1;
+  // Whether this uses the THUMB bit in symbol address.
+  bool uses_thumb_bit_ : 1;
+  // Whether this uses the symbol base.
+  bool uses_symbol_base_ : 1;
+  // Whether this uses an addend.
+  bool uses_addend_ : 1;
+};
+
+// Arm_reloc_property_table.  This table is used for looking up propeties
+// of relocationt types.  The table entries are initialized using information
+// from arm-reloc.def.
+
+class Arm_reloc_property_table
+{
+ public:
+  Arm_reloc_property_table();
+
+  // Return an Arm_reloc_property object for CODE if it is a valid relocation
+  // code or NULL otherwise.
+  const Arm_reloc_property*
+  get_reloc_property(unsigned int code) const
+  {
+    gold_assert(code < Property_table_size);
+    return this->table_[code];
+  }
+
+  // Like get_reloc_property but only return non-NULL if relocation code is
+  // static and implemented.
+  const Arm_reloc_property*
+  get_implemented_static_reloc_property(unsigned int code) const
+  {
+    gold_assert(code < Property_table_size);
+    const Arm_reloc_property* arp = this->table_[code];
+    return ((arp != NULL
+	     && (arp->reloc_type() == Arm_reloc_property::RT_STATIC)
+	     && arp->is_implemented())
+	    ? arp
+	    : NULL);
+  }
+  
+  // Return a string describing the a relocation code that is not
+  // an implemented static reloc code.
+  std::string
+  reloc_name_in_error_message(unsigned int code);
+
+ private:
+  // Copying is not allowed.
+  Arm_reloc_property_table(const Arm_reloc_property_table&);
+  Arm_reloc_property_table& operator=(const Arm_reloc_property_table&);
+
+  // The Parse_expression class is used to convert relocation operations in
+  // arm-reloc.def into S-expression strings, which are parsed again to
+  // build actual expression trees.  We do not build the expression trees
+  // directly because the parser for operations in arm-reloc.def is simpler
+  // this way.  Coversion from S-expressions to trees is simple.
+  class Parse_expression
+  {
+   public:
+    // Construction a Parse_expression with an S-expression string.
+    Parse_expression(const std::string& s_expression)
+      : s_expression_(s_expression)
+    { }
+
+    // Value of this expression as an S-expression string.
+    const std::string&
+    s_expression() const
+    { return this->s_expression_; }
+
+    // We want to overload operators used in relocation operations so
+    // that we can execute operations in arm-reloc.def to generate
+    // S-expressions directly.
+#define DEF_OPERATOR_OVERLOAD(op) \
+    Parse_expression \
+    operator op (const Parse_expression& e) \
+    { \
+      return Parse_expression("( " #op " " + this->s_expression_ + " " + \
+			      e.s_expression_ + " )"); \
+    }
+
+    // Operator appearing in relocation operations in arm-reloc.def.
+    DEF_OPERATOR_OVERLOAD(+)
+    DEF_OPERATOR_OVERLOAD(-)
+    DEF_OPERATOR_OVERLOAD(|)
+    
+   private:
+    // This represented as an S-expression string.
+    std::string s_expression_;
+  };
+
+#define DEF_RELOC_FUNC(name) \
+  static Parse_expression \
+  (name)(const Parse_expression& arg) \
+  { return Parse_expression("( " #name " " + arg.s_expression() + " )"); }
+
+  // Functions appearing in relocation operations in arm-reloc.def.
+  DEF_RELOC_FUNC(B)
+  DEF_RELOC_FUNC(DELTA_B)
+  DEF_RELOC_FUNC(GOT)
+  DEF_RELOC_FUNC(Module)
+  DEF_RELOC_FUNC(PLT)
+
+  static const unsigned int Property_table_size = 256;
+
+  // The property table.
+  Arm_reloc_property* table_[Property_table_size];
+};
+
+} // End namespace gold.
+
+#endif // !defined(GOLD_ARM_RELOC_PROPERTY_H)
diff --git a/gold/arm-reloc.def b/gold/arm-reloc.def
new file mode 100644
index 0000000..2caf371
--- /dev/null
+++ b/gold/arm-reloc.def
@@ -0,0 +1,194 @@
+// arm-reloc.def -- ARM relocation definitions.
+
+// Copyright 2010 Free Software Foundation, Inc.
+// Written by Doug Kwan <dougkwan@google.com>.
+
+// This file is part of gold.
+
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+// MA 02110-1301, USA.
+
+// The information here is based on the official ARM document "ELF for ARM
+// Architecture" (Document number ARM IHI 0044C).  The first five columns of
+// the table below are derived from Table 4-8 in the ARM ELF document.  Each
+// relocation from Table 4-8 corresponds to one relocation definition in the
+// table below.  A relocation defintion has the following information:
+//
+// Name: This is the name of the relocation without the "R_ARM_" prefix.
+//
+// Type: Relocation type.  There are four.
+//   - STATIC for static relocations processed by a static linker.
+//   - DYNAMIC for dynamic relocations processed by a dynamic linker.
+//   - PRIVATE for R_ARM_PRIVATE_<n> private relocation type.
+//   - OBSOLETE for old relocation types no longer used.
+//   We do not use DEPRECATED as a distinct type since we still have to
+//   handle deprecated relocations so we one of the types above.
+//
+// Deprecated:  Whether this is a deprecated relocation type.  The linker
+//   is expected to handle these though they should not be generated by fully
+//   conforming tool-chains.
+//
+// Operation: An expression specifying how the linker should performace a
+//   relocation.  If there is no operation or the operation cannot be
+//   specified, it is "NONE".
+//
+// Implemented: Whether this is implemented by the gold.
+//
+// Group_index: For a group relocation type, it is one of 0, 1 or 2.  For
+//   a non-group relocation type, it is -1.
+//
+// Overflow: Whether gold should check for overflow.  This is "No" by default
+//   for relocation types DYNAMIC, PRIVATE and OBSOLETE.
+//
+// Overflow-----------------------------------------------------------------+
+// Group index----------------------------------------------------------+   |
+// Implemented-------------------------------------------------------+  |   |
+// Operation-------------------------------+                         |  |   |
+// Class----------------------------+      |                         |  |   |
+// Deprecated--------------------+  |      |                         |  |   |
+// Type----------------+         |  |      |                         |  |   |
+// Name                |         |  |      |                         |  |   |
+// |                   |         |  |      |                         |  |   |
+RD(NONE              , STATIC  , N, MISC , NONE                   ,  Y, -1, N)
+RD(PC24              , STATIC  , Y, ARM  , ((S + A) | T) - P      ,  Y, -1, Y)
+RD(ABS32             , STATIC  , N, DATA , (S + A) | T            ,  Y, -1, N)
+RD(REL32             , STATIC  , N, DATA , ((S + A) | T) - P      ,  Y, -1, N)
+RD(LDR_PC_G0         , STATIC  , N, ARM  , S + A - P              ,  Y,  0, Y)
+RD(ABS16             , STATIC  , N, DATA , S + A                  ,  Y, -1, Y)
+RD(ABS12             , STATIC  , N, ARM  , S + A                  ,  Y, -1, Y)
+RD(THM_ABS5          , STATIC  , N, THM16, S + A                  ,  Y, -1, Y)
+RD(ABS8              , STATIC  , N, DATA , S + A                  ,  Y, -1, Y)
+RD(SBREL32           , STATIC  , N, DATA , ((S + A) | T) - B(S)   ,  N, -1, N)
+RD(THM_CALL          , STATIC  , N, THM32, ((S + A) | T) - P      ,  Y, -1, Y)
+RD(THM_PC8           , STATIC  , N, THM16, S + A - Pa             ,  Y, -1, Y)
+RD(BREL_ADJ          , DYNAMIC , N, DATA , DELTA_B(S) + A         ,  Y, -1, N)
+RD(TLS_DESC          , DYNAMIC , N, DATA , NONE                   ,  Y, -1, N)
+RD(THM_SWI8          , OBSOLETE, N, NONE , NONE                   ,  N, -1, N)
+RD(XPC25             , OBSOLETE, N, NONE , NONE                   ,  N, -1, N)
+RD(THM_XPC22         , OBSOLETE, N, NONE , NONE                   ,  N, -1, N)
+RD(TLS_DTPMOD32      , DYNAMIC , N, DATA , Module(S)              ,  Y, -1, N)
+RD(TLS_DTPOFF32      , DYNAMIC , N, DATA , S + A - TLS            ,  Y, -1, N)
+RD(TLS_TPOFF32       , DYNAMIC , N, DATA , S + A - tp             ,  Y, -1, N)
+RD(COPY              , DYNAMIC , N, MISC , NONE                   ,  Y, -1, N)
+RD(GLOB_DAT          , DYNAMIC , N, DATA , (S + A) | T            ,  Y, -1, N)
+RD(JUMP_SLOT         , DYNAMIC , N, DATA , (S + A) | T            ,  Y, -1, N)
+RD(RELATIVE          , DYNAMIC , N, DATA , B(S) + A               ,  Y, -1, N)
+RD(GOTOFF32          , STATIC  , N, DATA , ((S + A) | T) - GOT_ORG,  Y, -1, N)
+RD(BASE_PREL         , STATIC  , N, DATA , B(S) + A - P           ,  Y, -1, N)
+RD(GOT_BREL          , STATIC  , N, DATA , GOT(S) + A - GOT_ORG   ,  Y, -1, N)
+RD(PLT32             , STATIC  , Y, ARM  , ((S + A) | T) - P      ,  Y, -1, Y)
+RD(CALL              , STATIC  , N, ARM  , ((S + A) | T) - P      ,  Y, -1, Y)
+RD(JUMP24            , STATIC  , N, ARM  , ((S + A) | T) - P      ,  Y, -1, Y)
+RD(THM_JUMP24        , STATIC  , N, THM32, ((S + A) | T) - P      ,  Y, -1, Y)
+RD(BASE_ABS          , STATIC  , N, DATA , B(S) + A               ,  Y, -1, N)
+RD(ALU_PCREL_7_0     , OBSOLETE, N, NONE , NONE                   ,  N, -1, N)
+RD(ALU_PCREL_15_8    , OBSOLETE, N, NONE , NONE                   ,  N, -1, N)
+RD(ALU_PCREL_23_15   , OBSOLETE, N, NONE , NONE                   ,  N, -1, N)
+RD(LDR_SBREL_11_0_NC , STATIC  , Y, ARM  , S + A - B(S)           ,  N, -1, N)
+RD(ALU_SBREL_19_12_NC, STATIC  , Y, ARM  , S + A - B(S)           ,  N, -1, N)
+RD(ALU_SBREL_27_20_CK, STATIC  , Y, ARM  , S + A - B(S)           ,  N, -1, Y)
+RD(TARGET1           , STATIC  , N, MISC , NONE                   ,  Y, -1, N)
+RD(SBREL31           , STATIC  , Y, DATA , ((S + A) | T) - B(S)   ,  N, -1, N)
+RD(V4BX              , STATIC  , N, MISC , NONE                   ,  Y, -1, N)
+RD(TARGET2           , STATIC  , N, MISC , NONE                   ,  Y, -1, N)
+RD(PREL31            , STATIC  , N, DATA , ((S + A) | T) - P      ,  Y, -1, Y)
+RD(MOVW_ABS_NC       , STATIC  , N, ARM  , (S + A) | T            ,  Y, -1, N)
+RD(MOVT_ABS          , STATIC  , N, ARM  , S + A                  ,  Y, -1, Y)
+RD(MOVW_PREL_NC      , STATIC  , N, ARM  , ((S + A) | T) - P      ,  Y, -1, N)
+RD(MOVT_PREL         , STATIC  , N, ARM  , (S + A)  - P           ,  Y, -1, Y)
+RD(THM_MOVW_ABS_NC   , STATIC  , N, THM32, (S + A) | T            ,  Y, -1, N)
+RD(THM_MOVT_ABS      , STATIC  , N, THM32, S + A                  ,  Y, -1, N)
+RD(THM_MOVW_PREL_NC  , STATIC  , N, THM32, ((S + A) | T) - P      ,  Y, -1, N)
+RD(THM_MOVT_PREL     , STATIC  , N, THM32, S + A - P              ,  Y, -1, N)
+RD(THM_JUMP19        , STATIC  , N, THM32, ((S + A) | T) - P      ,  Y, -1, Y)
+RD(THM_JUMP6         , STATIC  , N, THM16, S + A - P              ,  Y, -1, Y)
+RD(THM_ALU_PREL_11_0 , STATIC  , N, THM32, ((S + A) | T) - Pa     ,  Y, -1, Y)
+RD(THM_PC12          , STATIC  , N, THM32, S + A - Pa             ,  Y, -1, Y)
+RD(ABS32_NOI         , STATIC  , N, DATA , S + A                  ,  Y, -1, N)
+RD(REL32_NOI         , STATIC  , N, DATA , S + A - P              ,  N, -1, N)
+RD(ALU_PC_G0_NC      , STATIC  , N, ARM  , ((S + A) | T) - P      ,  Y,  0, N)
+RD(ALU_PC_G0         , STATIC  , N, ARM  , ((S + A) | T) - P      ,  Y,  0, Y)
+RD(ALU_PC_G1_NC      , STATIC  , N, ARM  , ((S + A) | T) - P      ,  Y,  1, N)
+RD(ALU_PC_G1         , STATIC  , N, ARM  , ((S + A) | T) - P      ,  Y,  1, Y)
+RD(ALU_PC_G2         , STATIC  , N, ARM  , ((S + A) | T) - P      ,  Y,  2, Y)
+RD(LDR_PC_G1         , STATIC  , N, ARM  , S + A - P              ,  Y,  1, Y)
+RD(LDR_PC_G2         , STATIC  , N, ARM  , S + A - P              ,  Y,  2, Y)
+RD(LDRS_PC_G0        , STATIC  , N, ARM  , S + A - P              ,  Y,  0, Y)
+RD(LDRS_PC_G1        , STATIC  , N, ARM  , S + A - P              ,  Y,  1, Y)
+RD(LDRS_PC_G2        , STATIC  , N, ARM  , S + A - P              ,  Y,  2, Y)
+RD(LDC_PC_G0         , STATIC  , N, ARM  , S + A - P              ,  Y,  0, Y)
+RD(LDC_PC_G1         , STATIC  , N, ARM  , S + A - P              ,  Y,  1, Y)
+RD(LDC_PC_G2         , STATIC  , N, ARM  , S + A - P              ,  Y,  2, Y)
+RD(ALU_SB_G0_NC      , STATIC  , N, ARM  , ((S + A) | T) - B(S)   ,  Y,  0, N)
+RD(ALU_SB_G0         , STATIC  , N, ARM  , ((S + A) | T) - B(S)   ,  Y,  0, Y)
+RD(ALU_SB_G1_NC      , STATIC  , N, ARM  , ((S + A) | T) - B(S)   ,  Y,  1, N)
+RD(ALU_SB_G1         , STATIC  , N, ARM  , ((S + A) | T) - B(S)   ,  Y,  1, Y)
+RD(ALU_SB_G2         , STATIC  , N, ARM  , ((S + A) | T) - B(S)   ,  Y,  2, Y)
+RD(LDR_SB_G0         , STATIC  , N, ARM  , S + A - B(S)           ,  Y,  0, Y)
+RD(LDR_SB_G1         , STATIC  , N, ARM  , S + A - B(S)           ,  Y,  1, Y)
+RD(LDR_SB_G2         , STATIC  , N, ARM  , S + A - B(S)           ,  Y,  2, Y)
+RD(LDRS_SB_G0        , STATIC  , N, ARM  , S + A - B(S)           ,  Y,  0, Y)
+RD(LDRS_SB_G1        , STATIC  , N, ARM  , S + A - B(S)           ,  Y,  1, Y)
+RD(LDRS_SB_G2        , STATIC  , N, ARM  , S + A - B(S)           ,  Y,  2, Y)
+RD(LDC_SB_G0         , STATIC  , N, ARM  , S + A - B(S)           ,  Y,  0, Y)
+RD(LDC_SB_G1         , STATIC  , N, ARM  , S + A - B(S)           ,  Y,  1, Y)
+RD(LDC_SB_G2         , STATIC  , N, ARM  , S + A - B(S)           ,  Y,  2, Y)
+RD(MOVW_BREL_NC      , STATIC  , N, ARM  , ((S + A) | T) - B(S)   ,  Y, -1, N)
+RD(MOVT_BREL         , STATIC  , N, ARM  , S + A - B(S)           ,  Y, -1, Y)
+RD(MOVW_BREL         , STATIC  , N, ARM  , ((S + A) | T) - B(S)   ,  Y, -1, Y)
+RD(THM_MOVW_BREL_NC  , STATIC  , N, THM32, ((S + A) | T) - B(S)   ,  Y, -1, N)
+RD(THM_MOVT_BREL     , STATIC  , N, THM32, S + A - B(S)           ,  Y, -1, N)
+RD(THM_MOVW_BREL     , STATIC  , N, THM32, ((S + A) | T) - B(S)   ,  Y, -1, Y)
+RD(TLS_GOTDESC       , STATIC  , N, DATA , NONE                   ,  Y, -1, N)
+RD(TLS_CALL          , STATIC  , N, ARM  , NONE                   ,  N, -1, Y)
+RD(TLS_DESCSEQ       , STATIC  , N, ARM  , NONE                   ,  N, -1, Y)
+RD(THM_TLS_CALL      , STATIC  , N, THM32, NONE                   ,  N, -1, Y)
+RD(PLT32_ABS         , STATIC  , N, DATA , PLT(S) + A             ,  N, -1, N)
+RD(GOT_ABS           , STATIC  , N, DATA , GOT(S) + A             ,  N, -1, N)
+RD(GOT_PREL          , STATIC  , N, DATA , GOT(S) + A - P         ,  Y, -1, N)
+RD(GOT_BREL12        , STATIC  , N, ARM  , GOT(S) + A - GOT_ORG   ,  N, -1, Y)
+RD(GOTOFF12          , STATIC  , N, ARM  , S + A - GOT_ORG        ,  N, -1, Y)
+RD(GOTRELAX          , STATIC  , N, MISC , NONE                   ,  N, -1, N)
+RD(GNU_VTENTRY       , STATIC  , Y, DATA , NONE                   ,  Y, -1, N)
+RD(GNU_VTINHERIT     , STATIC  , Y, DATA , NONE                   ,  Y, -1, N)
+RD(THM_JUMP11        , STATIC  , N, THM16, S + A - P              ,  Y, -1, Y)
+RD(THM_JUMP8         , STATIC  , N, THM16, S + A - P              ,  Y, -1, Y)
+RD(TLS_GD32          , STATIC  , N, DATA , GOT(S) + A - P         ,  Y, -1, N)
+RD(TLS_LDM32         , STATIC  , N, DATA , GOT(S) + A - P         ,  Y, -1, N)
+RD(TLS_LDO32         , STATIC  , N, DATA , S + A - TLS            ,  Y, -1, N)
+RD(TLS_IE32          , STATIC  , N, DATA , GOT(S) + A - P         ,  Y, -1, N)
+RD(TLS_LE32          , STATIC  , N, DATA , S + A - tp             ,  Y, -1, N)
+RD(TLS_LDO12         , STATIC  , N, ARM  , S + A - TLS            ,  N, -1, Y)
+RD(TLS_LE12          , STATIC  , N, ARM  , S + A - tp             ,  N, -1, Y)
+RD(TLS_IE12GP        , STATIC  , N, ARM  , GOT(S) + A - GOT_ORG   ,  N, -1, Y)
+RD(PRIVATE_0         , PRIVATE , N, NONE , NONE                   ,  N, -1, N)
+RD(PRIVATE_1         , PRIVATE , N, NONE , NONE                   ,  N, -1, N)
+RD(PRIVATE_2         , PRIVATE , N, NONE , NONE                   ,  N, -1, N)
+RD(PRIVATE_3         , PRIVATE , N, NONE , NONE                   ,  N, -1, N)
+RD(PRIVATE_4         , PRIVATE , N, NONE , NONE                   ,  N, -1, N)
+RD(PRIVATE_5         , PRIVATE , N, NONE , NONE                   ,  N, -1, N)
+RD(PRIVATE_6         , PRIVATE , N, NONE , NONE                   ,  N, -1, N)
+RD(PRIVATE_7         , PRIVATE , N, NONE , NONE                   ,  N, -1, N)
+RD(PRIVATE_8         , PRIVATE , N, NONE , NONE                   ,  N, -1, N)
+RD(PRIVATE_9         , PRIVATE , N, NONE , NONE                   ,  N, -1, N)
+RD(PRIVATE_10        , PRIVATE , N, NONE , NONE                   ,  N, -1, N)
+RD(PRIVATE_11        , PRIVATE , N, NONE , NONE                   ,  N, -1, N)
+RD(PRIVATE_12        , PRIVATE , N, NONE , NONE                   ,  N, -1, N)
+RD(PRIVATE_13        , PRIVATE , N, NONE , NONE                   ,  N, -1, N)
+RD(PRIVATE_14        , PRIVATE , N, NONE , NONE                   ,  N, -1, N)
+RD(PRIVATE_15        , PRIVATE , N, NONE , NONE                   ,  N, -1, N)
+RD(ME_TOO            , OBSOLETE, N, NONE , NONE                   ,  N, -1, N)
+RD(THM_TLS_DESCSEQ16 , STATIC  , N, THM16, NONE                   ,  N, -1, Y)
+RD(THM_TLS_DESCSEQ32 , STATIC  , N, THM32, NONE                   ,  N, -1, Y)
diff --git a/gold/arm.cc b/gold/arm.cc
index dd5f67d..fdc4287 100644
--- a/gold/arm.cc
+++ b/gold/arm.cc
@@ -1,8 +1,10 @@
 // arm.cc -- arm target support for gold.
 
-// Copyright 2009 Free Software Foundation, Inc.
+// Copyright 2009, 2010 Free Software Foundation, Inc.
 // Written by Doug Kwan <dougkwan@google.com> based on the i386 code
 // by Ian Lance Taylor <iant@google.com>.
+// This file also contains borrowed and adapted code from
+// bfd/elf32-arm.c.
 
 // This file is part of gold.
 
@@ -27,6 +29,10 @@
 #include <limits>
 #include <cstdio>
 #include <string>
+#include <algorithm>
+#include <map>
+#include <utility>
+#include <set>
 
 #include "elfcpp.h"
 #include "parameters.h"
@@ -43,6 +49,8 @@
 #include "tls.h"
 #include "defstd.h"
 #include "gc.h"
+#include "attributes.h"
+#include "arm-reloc-property.h"
 
 namespace
 {
@@ -52,54 +60,1838 @@ using namespace gold;
 template<bool big_endian>
 class Output_data_plt_arm;
 
+template<bool big_endian>
+class Stub_table;
+
+template<bool big_endian>
+class Arm_input_section;
+
+class Arm_exidx_cantunwind;
+
+class Arm_exidx_merged_section;
+
+class Arm_exidx_fixup;
+
+template<bool big_endian>
+class Arm_output_section;
+
+class Arm_exidx_input_section;
+
+template<bool big_endian>
+class Arm_relobj;
+
+template<bool big_endian>
+class Arm_relocate_functions;
+
+template<bool big_endian>
+class Arm_output_data_got;
+
+template<bool big_endian>
+class Target_arm;
+
+// For convenience.
+typedef elfcpp::Elf_types<32>::Elf_Addr Arm_address;
+
+// Maximum branch offsets for ARM, THUMB and THUMB2.
+const int32_t ARM_MAX_FWD_BRANCH_OFFSET = ((((1 << 23) - 1) << 2) + 8);
+const int32_t ARM_MAX_BWD_BRANCH_OFFSET = ((-((1 << 23) << 2)) + 8);
+const int32_t THM_MAX_FWD_BRANCH_OFFSET = ((1 << 22) -2 + 4);
+const int32_t THM_MAX_BWD_BRANCH_OFFSET = (-(1 << 22) + 4);
+const int32_t THM2_MAX_FWD_BRANCH_OFFSET = (((1 << 24) - 2) + 4);
+const int32_t THM2_MAX_BWD_BRANCH_OFFSET = (-(1 << 24) + 4);
+
+// Thread Control Block size.
+const size_t ARM_TCB_SIZE = 8;
+
 // The arm target class.
 //
 // This is a very simple port of gold for ARM-EABI.  It is intended for
-// supporting Android only for the time being.  Only these relocation types
-// are supported.
-//
-// R_ARM_NONE
-// R_ARM_ABS32
-// R_ARM_ABS32_NOI
-// R_ARM_ABS16
-// R_ARM_ABS12
-// R_ARM_ABS8
-// R_ARM_THM_ABS5
-// R_ARM_BASE_ABS
-// R_ARM_REL32
-// R_ARM_THM_CALL
-// R_ARM_COPY
-// R_ARM_GLOB_DAT
-// R_ARM_BASE_PREL
-// R_ARM_JUMP_SLOT
-// R_ARM_RELATIVE
-// R_ARM_GOTOFF32
-// R_ARM_GOT_BREL
-// R_ARM_GOT_PREL
-// R_ARM_PLT32
-// R_ARM_CALL
-// R_ARM_JUMP24
-// R_ARM_TARGET1
-// R_ARM_PREL31
-// R_ARM_ABS8
-// R_ARM_MOVW_ABS_NC
-// R_ARM_MOVT_ABS
-// R_ARM_THM_MOVW_ABS_NC
-// R_ARM_THM_MOVT_ABS
-// R_ARM_MOVW_PREL_NC
-// R_ARM_MOVT_PREL
-// R_ARM_THM_MOVW_PREL_NC
-// R_ARM_THM_MOVT_PREL
+// supporting Android only for the time being.
 // 
 // TODOs:
-// - Generate various branch stubs.
-// - Support interworking.
-// - Define section symbols __exidx_start and __exidx_stop.
-// - Support more relocation types as needed. 
+// - Implement all static relocation types documented in arm-reloc.def.
 // - Make PLTs more flexible for different architecture features like
 //   Thumb-2 and BE8.
 // There are probably a lot more.
 
+// Ideally we would like to avoid using global variables but this is used
+// very in many places and sometimes in loops.  If we use a function
+// returning a static instance of Arm_reloc_property_table, it will very
+// slow in an threaded environment since the static instance needs to be
+// locked.  The pointer is below initialized in the
+// Target::do_select_as_default_target() hook so that we do not spend time
+// building the table if we are not linking ARM objects.
+//
+// An alternative is to to process the information in arm-reloc.def in
+// compilation time and generate a representation of it in PODs only.  That
+// way we can avoid initialization when the linker starts.
+
+Arm_reloc_property_table *arm_reloc_property_table = NULL;
+
+// Instruction template class.  This class is similar to the insn_sequence
+// struct in bfd/elf32-arm.c.
+
+class Insn_template
+{
+ public:
+  // Types of instruction templates.
+  enum Type
+    {
+      THUMB16_TYPE = 1,
+      // THUMB16_SPECIAL_TYPE is used by sub-classes of Stub for instruction 
+      // templates with class-specific semantics.  Currently this is used
+      // only by the Cortex_a8_stub class for handling condition codes in
+      // conditional branches.
+      THUMB16_SPECIAL_TYPE,
+      THUMB32_TYPE,
+      ARM_TYPE,
+      DATA_TYPE
+    };
+
+  // Factory methods to create instruction templates in different formats.
+
+  static const Insn_template
+  thumb16_insn(uint32_t data)
+  { return Insn_template(data, THUMB16_TYPE, elfcpp::R_ARM_NONE, 0); } 
+
+  // A Thumb conditional branch, in which the proper condition is inserted
+  // when we build the stub.
+  static const Insn_template
+  thumb16_bcond_insn(uint32_t data)
+  { return Insn_template(data, THUMB16_SPECIAL_TYPE, elfcpp::R_ARM_NONE, 1); } 
+
+  static const Insn_template
+  thumb32_insn(uint32_t data)
+  { return Insn_template(data, THUMB32_TYPE, elfcpp::R_ARM_NONE, 0); } 
+
+  static const Insn_template
+  thumb32_b_insn(uint32_t data, int reloc_addend)
+  {
+    return Insn_template(data, THUMB32_TYPE, elfcpp::R_ARM_THM_JUMP24,
+			 reloc_addend);
+  } 
+
+  static const Insn_template
+  arm_insn(uint32_t data)
+  { return Insn_template(data, ARM_TYPE, elfcpp::R_ARM_NONE, 0); }
+
+  static const Insn_template
+  arm_rel_insn(unsigned data, int reloc_addend)
+  { return Insn_template(data, ARM_TYPE, elfcpp::R_ARM_JUMP24, reloc_addend); }
+
+  static const Insn_template
+  data_word(unsigned data, unsigned int r_type, int reloc_addend)
+  { return Insn_template(data, DATA_TYPE, r_type, reloc_addend); } 
+
+  // Accessors.  This class is used for read-only objects so no modifiers
+  // are provided.
+
+  uint32_t
+  data() const
+  { return this->data_; }
+
+  // Return the instruction sequence type of this.
+  Type
+  type() const
+  { return this->type_; }
+
+  // Return the ARM relocation type of this.
+  unsigned int
+  r_type() const
+  { return this->r_type_; }
+
+  int32_t
+  reloc_addend() const
+  { return this->reloc_addend_; }
+
+  // Return size of instruction template in bytes.
+  size_t
+  size() const;
+
+  // Return byte-alignment of instruction template.
+  unsigned
+  alignment() const;
+
+ private:
+  // We make the constructor private to ensure that only the factory
+  // methods are used.
+  inline
+  Insn_template(unsigned data, Type type, unsigned int r_type, int reloc_addend)
+    : data_(data), type_(type), r_type_(r_type), reloc_addend_(reloc_addend)
+  { }
+
+  // Instruction specific data.  This is used to store information like
+  // some of the instruction bits.
+  uint32_t data_;
+  // Instruction template type.
+  Type type_;
+  // Relocation type if there is a relocation or R_ARM_NONE otherwise.
+  unsigned int r_type_;
+  // Relocation addend.
+  int32_t reloc_addend_;
+};
+
+// Macro for generating code to stub types. One entry per long/short
+// branch stub
+
+#define DEF_STUBS \
+  DEF_STUB(long_branch_any_any) \
+  DEF_STUB(long_branch_v4t_arm_thumb) \
+  DEF_STUB(long_branch_thumb_only) \
+  DEF_STUB(long_branch_v4t_thumb_thumb) \
+  DEF_STUB(long_branch_v4t_thumb_arm) \
+  DEF_STUB(short_branch_v4t_thumb_arm) \
+  DEF_STUB(long_branch_any_arm_pic) \
+  DEF_STUB(long_branch_any_thumb_pic) \
+  DEF_STUB(long_branch_v4t_thumb_thumb_pic) \
+  DEF_STUB(long_branch_v4t_arm_thumb_pic) \
+  DEF_STUB(long_branch_v4t_thumb_arm_pic) \
+  DEF_STUB(long_branch_thumb_only_pic) \
+  DEF_STUB(a8_veneer_b_cond) \
+  DEF_STUB(a8_veneer_b) \
+  DEF_STUB(a8_veneer_bl) \
+  DEF_STUB(a8_veneer_blx) \
+  DEF_STUB(v4_veneer_bx)
+
+// Stub types.
+
+#define DEF_STUB(x) arm_stub_##x,
+typedef enum
+  {
+    arm_stub_none,
+    DEF_STUBS
+
+    // First reloc stub type.
+    arm_stub_reloc_first = arm_stub_long_branch_any_any,
+    // Last  reloc stub type.
+    arm_stub_reloc_last = arm_stub_long_branch_thumb_only_pic,
+
+    // First Cortex-A8 stub type.
+    arm_stub_cortex_a8_first = arm_stub_a8_veneer_b_cond,
+    // Last Cortex-A8 stub type.
+    arm_stub_cortex_a8_last = arm_stub_a8_veneer_blx,
+    
+    // Last stub type.
+    arm_stub_type_last = arm_stub_v4_veneer_bx
+  } Stub_type;
+#undef DEF_STUB
+
+// Stub template class.  Templates are meant to be read-only objects.
+// A stub template for a stub type contains all read-only attributes
+// common to all stubs of the same type.
+
+class Stub_template
+{
+ public:
+  Stub_template(Stub_type, const Insn_template*, size_t);
+
+  ~Stub_template()
+  { }
+
+  // Return stub type.
+  Stub_type
+  type() const
+  { return this->type_; }
+
+  // Return an array of instruction templates.
+  const Insn_template*
+  insns() const
+  { return this->insns_; }
+
+  // Return size of template in number of instructions.
+  size_t
+  insn_count() const
+  { return this->insn_count_; }
+
+  // Return size of template in bytes.
+  size_t
+  size() const
+  { return this->size_; }
+
+  // Return alignment of the stub template.
+  unsigned
+  alignment() const
+  { return this->alignment_; }
+  
+  // Return whether entry point is in thumb mode.
+  bool
+  entry_in_thumb_mode() const
+  { return this->entry_in_thumb_mode_; }
+
+  // Return number of relocations in this template.
+  size_t
+  reloc_count() const
+  { return this->relocs_.size(); }
+
+  // Return index of the I-th instruction with relocation.
+  size_t
+  reloc_insn_index(size_t i) const
+  {
+    gold_assert(i < this->relocs_.size());
+    return this->relocs_[i].first;
+  }
+
+  // Return the offset of the I-th instruction with relocation from the
+  // beginning of the stub.
+  section_size_type
+  reloc_offset(size_t i) const
+  {
+    gold_assert(i < this->relocs_.size());
+    return this->relocs_[i].second;
+  }
+
+ private:
+  // This contains information about an instruction template with a relocation
+  // and its offset from start of stub.
+  typedef std::pair<size_t, section_size_type> Reloc;
+
+  // A Stub_template may not be copied.  We want to share templates as much
+  // as possible.
+  Stub_template(const Stub_template&);
+  Stub_template& operator=(const Stub_template&);
+  
+  // Stub type.
+  Stub_type type_;
+  // Points to an array of Insn_templates.
+  const Insn_template* insns_;
+  // Number of Insn_templates in insns_[].
+  size_t insn_count_;
+  // Size of templated instructions in bytes.
+  size_t size_;
+  // Alignment of templated instructions.
+  unsigned alignment_;
+  // Flag to indicate if entry is in thumb mode.
+  bool entry_in_thumb_mode_;
+  // A table of reloc instruction indices and offsets.  We can find these by
+  // looking at the instruction templates but we pre-compute and then stash
+  // them here for speed. 
+  std::vector<Reloc> relocs_;
+};
+
+//
+// A class for code stubs.  This is a base class for different type of
+// stubs used in the ARM target.
+//
+
+class Stub
+{
+ private:
+  static const section_offset_type invalid_offset =
+    static_cast<section_offset_type>(-1);
+
+ public:
+  Stub(const Stub_template* stub_template)
+    : stub_template_(stub_template), offset_(invalid_offset)
+  { }
+
+  virtual
+   ~Stub()
+  { }
+
+  // Return the stub template.
+  const Stub_template*
+  stub_template() const
+  { return this->stub_template_; }
+
+  // Return offset of code stub from beginning of its containing stub table.
+  section_offset_type
+  offset() const
+  {
+    gold_assert(this->offset_ != invalid_offset);
+    return this->offset_;
+  }
+
+  // Set offset of code stub from beginning of its containing stub table.
+  void
+  set_offset(section_offset_type offset)
+  { this->offset_ = offset; }
+  
+  // Return the relocation target address of the i-th relocation in the
+  // stub.  This must be defined in a child class.
+  Arm_address
+  reloc_target(size_t i)
+  { return this->do_reloc_target(i); }
+
+  // Write a stub at output VIEW.  BIG_ENDIAN select how a stub is written.
+  void
+  write(unsigned char* view, section_size_type view_size, bool big_endian)
+  { this->do_write(view, view_size, big_endian); }
+
+  // Return the instruction for THUMB16_SPECIAL_TYPE instruction template
+  // for the i-th instruction.
+  uint16_t
+  thumb16_special(size_t i)
+  { return this->do_thumb16_special(i); }
+
+ protected:
+  // This must be defined in the child class.
+  virtual Arm_address
+  do_reloc_target(size_t) = 0;
+
+  // This may be overridden in the child class.
+  virtual void
+  do_write(unsigned char* view, section_size_type view_size, bool big_endian)
+  {
+    if (big_endian)
+      this->do_fixed_endian_write<true>(view, view_size);
+    else
+      this->do_fixed_endian_write<false>(view, view_size);
+  }
+  
+  // This must be overridden if a child class uses the THUMB16_SPECIAL_TYPE
+  // instruction template.
+  virtual uint16_t
+  do_thumb16_special(size_t)
+  { gold_unreachable(); }
+
+ private:
+  // A template to implement do_write.
+  template<bool big_endian>
+  void inline
+  do_fixed_endian_write(unsigned char*, section_size_type);
+
+  // Its template.
+  const Stub_template* stub_template_;
+  // Offset within the section of containing this stub.
+  section_offset_type offset_;
+};
+
+// Reloc stub class.  These are stubs we use to fix up relocation because
+// of limited branch ranges.
+
+class Reloc_stub : public Stub
+{
+ public:
+  static const unsigned int invalid_index = static_cast<unsigned int>(-1);
+  // We assume we never jump to this address.
+  static const Arm_address invalid_address = static_cast<Arm_address>(-1);
+
+  // Return destination address.
+  Arm_address
+  destination_address() const
+  {
+    gold_assert(this->destination_address_ != this->invalid_address);
+    return this->destination_address_;
+  }
+
+  // Set destination address.
+  void
+  set_destination_address(Arm_address address)
+  {
+    gold_assert(address != this->invalid_address);
+    this->destination_address_ = address;
+  }
+
+  // Reset destination address.
+  void
+  reset_destination_address()
+  { this->destination_address_ = this->invalid_address; }
+
+  // Determine stub type for a branch of a relocation of R_TYPE going
+  // from BRANCH_ADDRESS to BRANCH_TARGET.  If TARGET_IS_THUMB is set,
+  // the branch target is a thumb instruction.  TARGET is used for look
+  // up ARM-specific linker settings.
+  static Stub_type
+  stub_type_for_reloc(unsigned int r_type, Arm_address branch_address,
+		      Arm_address branch_target, bool target_is_thumb);
+
+  // Reloc_stub key.  A key is logically a triplet of a stub type, a symbol
+  // and an addend.  Since we treat global and local symbol differently, we
+  // use a Symbol object for a global symbol and a object-index pair for
+  // a local symbol.
+  class Key
+  {
+   public:
+    // If SYMBOL is not null, this is a global symbol, we ignore RELOBJ and
+    // R_SYM.  Otherwise, this is a local symbol and RELOBJ must non-NULL
+    // and R_SYM must not be invalid_index.
+    Key(Stub_type stub_type, const Symbol* symbol, const Relobj* relobj,
+	unsigned int r_sym, int32_t addend)
+      : stub_type_(stub_type), addend_(addend)
+    {
+      if (symbol != NULL)
+	{
+	  this->r_sym_ = Reloc_stub::invalid_index;
+	  this->u_.symbol = symbol;
+	}
+      else
+	{
+	  gold_assert(relobj != NULL && r_sym != invalid_index);
+	  this->r_sym_ = r_sym;
+	  this->u_.relobj = relobj;
+	}
+    }
+
+    ~Key()
+    { }
+
+    // Accessors: Keys are meant to be read-only object so no modifiers are
+    // provided.
+
+    // Return stub type.
+    Stub_type
+    stub_type() const
+    { return this->stub_type_; }
+
+    // Return the local symbol index or invalid_index.
+    unsigned int
+    r_sym() const
+    { return this->r_sym_; }
+
+    // Return the symbol if there is one.
+    const Symbol*
+    symbol() const
+    { return this->r_sym_ == invalid_index ? this->u_.symbol : NULL; }
+
+    // Return the relobj if there is one.
+    const Relobj*
+    relobj() const
+    { return this->r_sym_ != invalid_index ? this->u_.relobj : NULL; }
+
+    // Whether this equals to another key k.
+    bool
+    eq(const Key& k) const 
+    {
+      return ((this->stub_type_ == k.stub_type_)
+	      && (this->r_sym_ == k.r_sym_)
+	      && ((this->r_sym_ != Reloc_stub::invalid_index)
+		  ? (this->u_.relobj == k.u_.relobj)
+		  : (this->u_.symbol == k.u_.symbol))
+	      && (this->addend_ == k.addend_));
+    }
+
+    // Return a hash value.
+    size_t
+    hash_value() const
+    {
+      return (this->stub_type_
+	      ^ this->r_sym_
+	      ^ gold::string_hash<char>(
+		    (this->r_sym_ != Reloc_stub::invalid_index)
+		    ? this->u_.relobj->name().c_str()
+		    : this->u_.symbol->name())
+	      ^ this->addend_);
+    }
+
+    // Functors for STL associative containers.
+    struct hash
+    {
+      size_t
+      operator()(const Key& k) const
+      { return k.hash_value(); }
+    };
+
+    struct equal_to
+    {
+      bool
+      operator()(const Key& k1, const Key& k2) const
+      { return k1.eq(k2); }
+    };
+
+    // Name of key.  This is mainly for debugging.
+    std::string
+    name() const;
+
+   private:
+    // Stub type.
+    Stub_type stub_type_;
+    // If this is a local symbol, this is the index in the defining object.
+    // Otherwise, it is invalid_index for a global symbol.
+    unsigned int r_sym_;
+    // If r_sym_ is invalid index.  This points to a global symbol.
+    // Otherwise, this points a relobj.  We used the unsized and target
+    // independent Symbol and Relobj classes instead of Sized_symbol<32> and  
+    // Arm_relobj.  This is done to avoid making the stub class a template
+    // as most of the stub machinery is endianity-neutral.  However, it
+    // may require a bit of casting done by users of this class.
+    union
+    {
+      const Symbol* symbol;
+      const Relobj* relobj;
+    } u_;
+    // Addend associated with a reloc.
+    int32_t addend_;
+  };
+
+ protected:
+  // Reloc_stubs are created via a stub factory.  So these are protected.
+  Reloc_stub(const Stub_template* stub_template)
+    : Stub(stub_template), destination_address_(invalid_address)
+  { }
+
+  ~Reloc_stub()
+  { }
+
+  friend class Stub_factory;
+
+  // Return the relocation target address of the i-th relocation in the
+  // stub.
+  Arm_address
+  do_reloc_target(size_t i)
+  {
+    // All reloc stub have only one relocation.
+    gold_assert(i == 0);
+    return this->destination_address_;
+  }
+
+ private:
+  // Address of destination.
+  Arm_address destination_address_;
+};
+
+// Cortex-A8 stub class.  We need a Cortex-A8 stub to redirect any 32-bit
+// THUMB branch that meets the following conditions:
+// 
+// 1. The branch straddles across a page boundary. i.e. lower 12-bit of
+//    branch address is 0xffe.
+// 2. The branch target address is in the same page as the first word of the
+//    branch.
+// 3. The branch follows a 32-bit instruction which is not a branch.
+//
+// To do the fix up, we need to store the address of the branch instruction
+// and its target at least.  We also need to store the original branch
+// instruction bits for the condition code in a conditional branch.  The
+// condition code is used in a special instruction template.  We also want
+// to identify input sections needing Cortex-A8 workaround quickly.  We store
+// extra information about object and section index of the code section
+// containing a branch being fixed up.  The information is used to mark
+// the code section when we finalize the Cortex-A8 stubs.
+//
+
+class Cortex_a8_stub : public Stub
+{
+ public:
+  ~Cortex_a8_stub()
+  { }
+
+  // Return the object of the code section containing the branch being fixed
+  // up.
+  Relobj*
+  relobj() const
+  { return this->relobj_; }
+
+  // Return the section index of the code section containing the branch being
+  // fixed up.
+  unsigned int
+  shndx() const
+  { return this->shndx_; }
+
+  // Return the source address of stub.  This is the address of the original
+  // branch instruction.  LSB is 1 always set to indicate that it is a THUMB
+  // instruction.
+  Arm_address
+  source_address() const
+  { return this->source_address_; }
+
+  // Return the destination address of the stub.  This is the branch taken
+  // address of the original branch instruction.  LSB is 1 if it is a THUMB
+  // instruction address.
+  Arm_address
+  destination_address() const
+  { return this->destination_address_; }
+
+  // Return the instruction being fixed up.
+  uint32_t
+  original_insn() const
+  { return this->original_insn_; }
+
+ protected:
+  // Cortex_a8_stubs are created via a stub factory.  So these are protected.
+  Cortex_a8_stub(const Stub_template* stub_template, Relobj* relobj,
+		 unsigned int shndx, Arm_address source_address,
+		 Arm_address destination_address, uint32_t original_insn)
+    : Stub(stub_template), relobj_(relobj), shndx_(shndx),
+      source_address_(source_address | 1U),
+      destination_address_(destination_address),
+      original_insn_(original_insn)
+  { }
+
+  friend class Stub_factory;
+
+  // Return the relocation target address of the i-th relocation in the
+  // stub.
+  Arm_address
+  do_reloc_target(size_t i)
+  {
+    if (this->stub_template()->type() == arm_stub_a8_veneer_b_cond)
+      {
+        // The conditional branch veneer has two relocations.
+        gold_assert(i < 2);
+	return i == 0 ? this->source_address_ + 4 : this->destination_address_;
+      }
+    else
+      {
+        // All other Cortex-A8 stubs have only one relocation.
+        gold_assert(i == 0);
+        return this->destination_address_;
+      }
+  }
+
+  // Return an instruction for the THUMB16_SPECIAL_TYPE instruction template.
+  uint16_t
+  do_thumb16_special(size_t);
+
+ private:
+  // Object of the code section containing the branch being fixed up.
+  Relobj* relobj_;
+  // Section index of the code section containing the branch begin fixed up.
+  unsigned int shndx_;
+  // Source address of original branch.
+  Arm_address source_address_;
+  // Destination address of the original branch.
+  Arm_address destination_address_;
+  // Original branch instruction.  This is needed for copying the condition
+  // code from a condition branch to its stub.
+  uint32_t original_insn_;
+};
+
+// ARMv4 BX Rx branch relocation stub class.
+class Arm_v4bx_stub : public Stub
+{
+ public:
+  ~Arm_v4bx_stub()
+  { }
+
+  // Return the associated register.
+  uint32_t
+  reg() const
+  { return this->reg_; }
+
+ protected:
+  // Arm V4BX stubs are created via a stub factory.  So these are protected.
+  Arm_v4bx_stub(const Stub_template* stub_template, const uint32_t reg)
+    : Stub(stub_template), reg_(reg)
+  { }
+
+  friend class Stub_factory;
+
+  // Return the relocation target address of the i-th relocation in the
+  // stub.
+  Arm_address
+  do_reloc_target(size_t)
+  { gold_unreachable(); }
+
+  // This may be overridden in the child class.
+  virtual void
+  do_write(unsigned char* view, section_size_type view_size, bool big_endian)
+  {
+    if (big_endian)
+      this->do_fixed_endian_v4bx_write<true>(view, view_size);
+    else
+      this->do_fixed_endian_v4bx_write<false>(view, view_size);
+  }
+
+ private:
+  // A template to implement do_write.
+  template<bool big_endian>
+  void inline
+  do_fixed_endian_v4bx_write(unsigned char* view, section_size_type)
+  {
+    const Insn_template* insns = this->stub_template()->insns();
+    elfcpp::Swap<32, big_endian>::writeval(view,
+					   (insns[0].data()
+					   + (this->reg_ << 16)));
+    view += insns[0].size();
+    elfcpp::Swap<32, big_endian>::writeval(view,
+					   (insns[1].data() + this->reg_));
+    view += insns[1].size();
+    elfcpp::Swap<32, big_endian>::writeval(view,
+					   (insns[2].data() + this->reg_));
+  }
+
+  // A register index (r0-r14), which is associated with the stub.
+  uint32_t reg_;
+};
+
+// Stub factory class.
+
+class Stub_factory
+{
+ public:
+  // Return the unique instance of this class.
+  static const Stub_factory&
+  get_instance()
+  {
+    static Stub_factory singleton;
+    return singleton;
+  }
+
+  // Make a relocation stub.
+  Reloc_stub*
+  make_reloc_stub(Stub_type stub_type) const
+  {
+    gold_assert(stub_type >= arm_stub_reloc_first
+		&& stub_type <= arm_stub_reloc_last);
+    return new Reloc_stub(this->stub_templates_[stub_type]);
+  }
+
+  // Make a Cortex-A8 stub.
+  Cortex_a8_stub*
+  make_cortex_a8_stub(Stub_type stub_type, Relobj* relobj, unsigned int shndx,
+		      Arm_address source, Arm_address destination,
+		      uint32_t original_insn) const
+  {
+    gold_assert(stub_type >= arm_stub_cortex_a8_first
+		&& stub_type <= arm_stub_cortex_a8_last);
+    return new Cortex_a8_stub(this->stub_templates_[stub_type], relobj, shndx,
+			      source, destination, original_insn);
+  }
+
+  // Make an ARM V4BX relocation stub.
+  // This method creates a stub from the arm_stub_v4_veneer_bx template only.
+  Arm_v4bx_stub*
+  make_arm_v4bx_stub(uint32_t reg) const
+  {
+    gold_assert(reg < 0xf);
+    return new Arm_v4bx_stub(this->stub_templates_[arm_stub_v4_veneer_bx],
+			     reg);
+  }
+
+ private:
+  // Constructor and destructor are protected since we only return a single
+  // instance created in Stub_factory::get_instance().
+  
+  Stub_factory();
+
+  // A Stub_factory may not be copied since it is a singleton.
+  Stub_factory(const Stub_factory&);
+  Stub_factory& operator=(Stub_factory&);
+  
+  // Stub templates.  These are initialized in the constructor.
+  const Stub_template* stub_templates_[arm_stub_type_last+1];
+};
+
+// A class to hold stubs for the ARM target.
+
+template<bool big_endian>
+class Stub_table : public Output_data
+{
+ public:
+  Stub_table(Arm_input_section<big_endian>* owner)
+    : Output_data(), owner_(owner), reloc_stubs_(), cortex_a8_stubs_(),
+      arm_v4bx_stubs_(0xf), prev_data_size_(0), prev_addralign_(1)
+  { }
+
+  ~Stub_table()
+  { }
+
+  // Owner of this stub table.
+  Arm_input_section<big_endian>*
+  owner() const
+  { return this->owner_; }
+
+  // Whether this stub table is empty.
+  bool
+  empty() const
+  {
+    return (this->reloc_stubs_.empty()
+	    && this->cortex_a8_stubs_.empty()
+	    && this->arm_v4bx_stubs_.empty());
+  }
+
+  // Return the current data size.
+  off_t
+  current_data_size() const
+  { return this->current_data_size_for_child(); }
+
+  // Add a STUB with using KEY.  Caller is reponsible for avoid adding
+  // if already a STUB with the same key has been added. 
+  void
+  add_reloc_stub(Reloc_stub* stub, const Reloc_stub::Key& key)
+  {
+    const Stub_template* stub_template = stub->stub_template();
+    gold_assert(stub_template->type() == key.stub_type());
+    this->reloc_stubs_[key] = stub;
+  }
+
+  // Add a Cortex-A8 STUB that fixes up a THUMB branch at ADDRESS.
+  // Caller is reponsible for avoid adding if already a STUB with the same
+  // address has been added. 
+  void
+  add_cortex_a8_stub(Arm_address address, Cortex_a8_stub* stub)
+  {
+    std::pair<Arm_address, Cortex_a8_stub*> value(address, stub);
+    this->cortex_a8_stubs_.insert(value);
+  }
+
+  // Add an ARM V4BX relocation stub. A register index will be retrieved
+  // from the stub.
+  void
+  add_arm_v4bx_stub(Arm_v4bx_stub* stub)
+  {
+    gold_assert(stub != NULL && this->arm_v4bx_stubs_[stub->reg()] == NULL);
+    this->arm_v4bx_stubs_[stub->reg()] = stub;
+  }
+
+  // Remove all Cortex-A8 stubs.
+  void
+  remove_all_cortex_a8_stubs();
+
+  // Look up a relocation stub using KEY.  Return NULL if there is none.
+  Reloc_stub*
+  find_reloc_stub(const Reloc_stub::Key& key) const
+  {
+    typename Reloc_stub_map::const_iterator p = this->reloc_stubs_.find(key);
+    return (p != this->reloc_stubs_.end()) ? p->second : NULL;
+  }
+
+  // Look up an arm v4bx relocation stub using the register index.
+  // Return NULL if there is none.
+  Arm_v4bx_stub*
+  find_arm_v4bx_stub(const uint32_t reg) const
+  {
+    gold_assert(reg < 0xf);
+    return this->arm_v4bx_stubs_[reg];
+  }
+
+  // Relocate stubs in this stub table.
+  void
+  relocate_stubs(const Relocate_info<32, big_endian>*,
+		 Target_arm<big_endian>*, Output_section*,
+		 unsigned char*, Arm_address, section_size_type);
+
+  // Update data size and alignment at the end of a relaxation pass.  Return
+  // true if either data size or alignment is different from that of the
+  // previous relaxation pass.
+  bool
+  update_data_size_and_addralign();
+
+  // Finalize stubs.  Set the offsets of all stubs and mark input sections
+  // needing the Cortex-A8 workaround.
+  void
+  finalize_stubs();
+  
+  // Apply Cortex-A8 workaround to an address range.
+  void
+  apply_cortex_a8_workaround_to_address_range(Target_arm<big_endian>*,
+					      unsigned char*, Arm_address,
+					      section_size_type);
+
+ protected:
+  // Write out section contents.
+  void
+  do_write(Output_file*);
+ 
+  // Return the required alignment.
+  uint64_t
+  do_addralign() const
+  { return this->prev_addralign_; }
+
+  // Reset address and file offset.
+  void
+  do_reset_address_and_file_offset()
+  { this->set_current_data_size_for_child(this->prev_data_size_); }
+
+  // Set final data size.
+  void
+  set_final_data_size()
+  { this->set_data_size(this->current_data_size()); }
+  
+ private:
+  // Relocate one stub.
+  void
+  relocate_stub(Stub*, const Relocate_info<32, big_endian>*,
+		Target_arm<big_endian>*, Output_section*,
+		unsigned char*, Arm_address, section_size_type);
+
+  // Unordered map of relocation stubs.
+  typedef
+    Unordered_map<Reloc_stub::Key, Reloc_stub*, Reloc_stub::Key::hash,
+		  Reloc_stub::Key::equal_to>
+    Reloc_stub_map;
+
+  // List of Cortex-A8 stubs ordered by addresses of branches being
+  // fixed up in output.
+  typedef std::map<Arm_address, Cortex_a8_stub*> Cortex_a8_stub_list;
+  // List of Arm V4BX relocation stubs ordered by associated registers.
+  typedef std::vector<Arm_v4bx_stub*> Arm_v4bx_stub_list;
+
+  // Owner of this stub table.
+  Arm_input_section<big_endian>* owner_;
+  // The relocation stubs.
+  Reloc_stub_map reloc_stubs_;
+  // The cortex_a8_stubs.
+  Cortex_a8_stub_list cortex_a8_stubs_;
+  // The Arm V4BX relocation stubs.
+  Arm_v4bx_stub_list arm_v4bx_stubs_;
+  // data size of this in the previous pass.
+  off_t prev_data_size_;
+  // address alignment of this in the previous pass.
+  uint64_t prev_addralign_;
+};
+
+// Arm_exidx_cantunwind class.  This represents an EXIDX_CANTUNWIND entry
+// we add to the end of an EXIDX input section that goes into the output.
+
+class Arm_exidx_cantunwind : public Output_section_data
+{
+ public:
+  Arm_exidx_cantunwind(Relobj* relobj, unsigned int shndx)
+    : Output_section_data(8, 4, true), relobj_(relobj), shndx_(shndx)
+  { }
+
+  // Return the object containing the section pointed by this.
+  Relobj*
+  relobj() const
+  { return this->relobj_; }
+
+  // Return the section index of the section pointed by this.
+  unsigned int
+  shndx() const
+  { return this->shndx_; }
+
+ protected:
+  void
+  do_write(Output_file* of)
+  {
+    if (parameters->target().is_big_endian())
+      this->do_fixed_endian_write<true>(of);
+    else
+      this->do_fixed_endian_write<false>(of);
+  }
+
+ private:
+  // Implement do_write for a given endianity.
+  template<bool big_endian>
+  void inline
+  do_fixed_endian_write(Output_file*);
+  
+  // The object containing the section pointed by this.
+  Relobj* relobj_;
+  // The section index of the section pointed by this.
+  unsigned int shndx_;
+};
+
+// During EXIDX coverage fix-up, we compact an EXIDX section.  The
+// Offset map is used to map input section offset within the EXIDX section
+// to the output offset from the start of this EXIDX section. 
+
+typedef std::map<section_offset_type, section_offset_type>
+	Arm_exidx_section_offset_map;
+
+// Arm_exidx_merged_section class.  This represents an EXIDX input section
+// with some of its entries merged.
+
+class Arm_exidx_merged_section : public Output_relaxed_input_section
+{
+ public:
+  // Constructor for Arm_exidx_merged_section.
+  // EXIDX_INPUT_SECTION points to the unmodified EXIDX input section.
+  // SECTION_OFFSET_MAP points to a section offset map describing how
+  // parts of the input section are mapped to output.  DELETED_BYTES is
+  // the number of bytes deleted from the EXIDX input section.
+  Arm_exidx_merged_section(
+      const Arm_exidx_input_section& exidx_input_section,
+      const Arm_exidx_section_offset_map& section_offset_map,
+      uint32_t deleted_bytes);
+
+  // Return the original EXIDX input section.
+  const Arm_exidx_input_section&
+  exidx_input_section() const
+  { return this->exidx_input_section_; }
+
+  // Return the section offset map.
+  const Arm_exidx_section_offset_map&
+  section_offset_map() const
+  { return this->section_offset_map_; }
+
+ protected:
+  // Write merged section into file OF.
+  void
+  do_write(Output_file* of);
+
+  bool
+  do_output_offset(const Relobj*, unsigned int, section_offset_type,
+		  section_offset_type*) const;
+
+ private:
+  // Original EXIDX input section.
+  const Arm_exidx_input_section& exidx_input_section_;
+  // Section offset map.
+  const Arm_exidx_section_offset_map& section_offset_map_;
+};
+
+// A class to wrap an ordinary input section containing executable code.
+
+template<bool big_endian>
+class Arm_input_section : public Output_relaxed_input_section
+{
+ public:
+  Arm_input_section(Relobj* relobj, unsigned int shndx)
+    : Output_relaxed_input_section(relobj, shndx, 1),
+      original_addralign_(1), original_size_(0), stub_table_(NULL)
+  { }
+
+  ~Arm_input_section()
+  { }
+
+  // Initialize.
+  void
+  init();
+  
+  // Whether this is a stub table owner.
+  bool
+  is_stub_table_owner() const
+  { return this->stub_table_ != NULL && this->stub_table_->owner() == this; }
+
+  // Return the stub table.
+  Stub_table<big_endian>*
+  stub_table() const
+  { return this->stub_table_; }
+
+  // Set the stub_table.
+  void
+  set_stub_table(Stub_table<big_endian>* stub_table)
+  { this->stub_table_ = stub_table; }
+
+  // Downcast a base pointer to an Arm_input_section pointer.  This is
+  // not type-safe but we only use Arm_input_section not the base class.
+  static Arm_input_section<big_endian>*
+  as_arm_input_section(Output_relaxed_input_section* poris)
+  { return static_cast<Arm_input_section<big_endian>*>(poris); }
+
+ protected:
+  // Write data to output file.
+  void
+  do_write(Output_file*);
+
+  // Return required alignment of this.
+  uint64_t
+  do_addralign() const
+  {
+    if (this->is_stub_table_owner())
+      return std::max(this->stub_table_->addralign(),
+		      this->original_addralign_);
+    else
+      return this->original_addralign_;
+  }
+
+  // Finalize data size.
+  void
+  set_final_data_size();
+
+  // Reset address and file offset.
+  void
+  do_reset_address_and_file_offset();
+
+  // Output offset.
+  bool
+  do_output_offset(const Relobj* object, unsigned int shndx,
+		   section_offset_type offset,
+                   section_offset_type* poutput) const
+  {
+    if ((object == this->relobj())
+	&& (shndx == this->shndx())
+	&& (offset >= 0)
+	&& (convert_types<uint64_t, section_offset_type>(offset)
+	    <= this->original_size_))
+      {
+	*poutput = offset;
+	return true;
+      }
+    else
+      return false;
+  }
+
+ private:
+  // Copying is not allowed.
+  Arm_input_section(const Arm_input_section&);
+  Arm_input_section& operator=(const Arm_input_section&);
+
+  // Address alignment of the original input section.
+  uint64_t original_addralign_;
+  // Section size of the original input section.
+  uint64_t original_size_;
+  // Stub table.
+  Stub_table<big_endian>* stub_table_;
+};
+
+// Arm_exidx_fixup class.  This is used to define a number of methods
+// and keep states for fixing up EXIDX coverage.
+
+class Arm_exidx_fixup
+{
+ public:
+  Arm_exidx_fixup(Output_section* exidx_output_section)
+    : exidx_output_section_(exidx_output_section), last_unwind_type_(UT_NONE),
+      last_inlined_entry_(0), last_input_section_(NULL),
+      section_offset_map_(NULL)
+  { }
+
+  ~Arm_exidx_fixup()
+  { delete this->section_offset_map_; }
+
+  // Process an EXIDX section for entry merging.  Return  number of bytes to
+  // be deleted in output.  If parts of the input EXIDX section are merged
+  // a heap allocated Arm_exidx_section_offset_map is store in the located
+  // PSECTION_OFFSET_MAP.  The caller owns the map and is reponsible for
+  // releasing it.
+  template<bool big_endian>
+  uint32_t
+  process_exidx_section(const Arm_exidx_input_section* exidx_input_section,
+			Arm_exidx_section_offset_map** psection_offset_map);
+  
+  // Append an EXIDX_CANTUNWIND entry pointing at the end of the last
+  // input section, if there is not one already.
+  void
+  add_exidx_cantunwind_as_needed();
+
+ private:
+  // Copying is not allowed.
+  Arm_exidx_fixup(const Arm_exidx_fixup&);
+  Arm_exidx_fixup& operator=(const Arm_exidx_fixup&);
+
+  // Type of EXIDX unwind entry.
+  enum Unwind_type
+  {
+    // No type.
+    UT_NONE,
+    // EXIDX_CANTUNWIND.
+    UT_EXIDX_CANTUNWIND,
+    // Inlined entry.
+    UT_INLINED_ENTRY,
+    // Normal entry.
+    UT_NORMAL_ENTRY,
+  };
+
+  // Process an EXIDX entry.  We only care about the second word of the
+  // entry.  Return true if the entry can be deleted.
+  bool
+  process_exidx_entry(uint32_t second_word);
+
+  // Update the current section offset map during EXIDX section fix-up.
+  // If there is no map, create one.  INPUT_OFFSET is the offset of a
+  // reference point, DELETED_BYTES is the number of deleted by in the
+  // section so far.  If DELETE_ENTRY is true, the reference point and
+  // all offsets after the previous reference point are discarded.
+  void
+  update_offset_map(section_offset_type input_offset,
+		    section_size_type deleted_bytes, bool delete_entry);
+
+  // EXIDX output section.
+  Output_section* exidx_output_section_;
+  // Unwind type of the last EXIDX entry processed.
+  Unwind_type last_unwind_type_;
+  // Last seen inlined EXIDX entry.
+  uint32_t last_inlined_entry_;
+  // Last processed EXIDX input section.
+  const Arm_exidx_input_section* last_input_section_;
+  // Section offset map created in process_exidx_section.
+  Arm_exidx_section_offset_map* section_offset_map_;
+};
+
+// Arm output section class.  This is defined mainly to add a number of
+// stub generation methods.
+
+template<bool big_endian>
+class Arm_output_section : public Output_section
+{
+ public:
+  typedef std::vector<std::pair<Relobj*, unsigned int> > Text_section_list;
+
+  Arm_output_section(const char* name, elfcpp::Elf_Word type,
+		     elfcpp::Elf_Xword flags)
+    : Output_section(name, type, flags)
+  { }
+
+  ~Arm_output_section()
+  { }
+  
+  // Group input sections for stub generation.
+  void
+  group_sections(section_size_type, bool, Target_arm<big_endian>*);
+
+  // Downcast a base pointer to an Arm_output_section pointer.  This is
+  // not type-safe but we only use Arm_output_section not the base class.
+  static Arm_output_section<big_endian>*
+  as_arm_output_section(Output_section* os)
+  { return static_cast<Arm_output_section<big_endian>*>(os); }
+
+  // Append all input text sections in this into LIST.
+  void
+  append_text_sections_to_list(Text_section_list* list);
+
+  // Fix EXIDX coverage of this EXIDX output section.  SORTED_TEXT_SECTION
+  // is a list of text input sections sorted in ascending order of their
+  // output addresses.
+  void
+  fix_exidx_coverage(Layout* layout,
+		     const Text_section_list& sorted_text_section,
+		     Symbol_table* symtab);
+
+ private:
+  // For convenience.
+  typedef Output_section::Input_section Input_section;
+  typedef Output_section::Input_section_list Input_section_list;
+
+  // Create a stub group.
+  void create_stub_group(Input_section_list::const_iterator,
+			 Input_section_list::const_iterator,
+			 Input_section_list::const_iterator,
+			 Target_arm<big_endian>*,
+			 std::vector<Output_relaxed_input_section*>*);
+};
+
+// Arm_exidx_input_section class.  This represents an EXIDX input section.
+
+class Arm_exidx_input_section
+{
+ public:
+  static const section_offset_type invalid_offset =
+    static_cast<section_offset_type>(-1);
+
+  Arm_exidx_input_section(Relobj* relobj, unsigned int shndx,
+			  unsigned int link, uint32_t size, uint32_t addralign)
+    : relobj_(relobj), shndx_(shndx), link_(link), size_(size),
+      addralign_(addralign)
+  { }
+
+  ~Arm_exidx_input_section()
+  { }
+  	
+  // Accessors:  This is a read-only class.
+
+  // Return the object containing this EXIDX input section.
+  Relobj*
+  relobj() const
+  { return this->relobj_; }
+
+  // Return the section index of this EXIDX input section.
+  unsigned int
+  shndx() const
+  { return this->shndx_; }
+
+  // Return the section index of linked text section in the same object.
+  unsigned int
+  link() const
+  { return this->link_; }
+
+  // Return size of the EXIDX input section.
+  uint32_t
+  size() const
+  { return this->size_; }
+
+  // Reutnr address alignment of EXIDX input section.
+  uint32_t
+  addralign() const
+  { return this->addralign_; }
+
+ private:
+  // Object containing this.
+  Relobj* relobj_;
+  // Section index of this.
+  unsigned int shndx_;
+  // text section linked to this in the same object.
+  unsigned int link_;
+  // Size of this.  For ARM 32-bit is sufficient.
+  uint32_t size_;
+  // Address alignment of this.  For ARM 32-bit is sufficient.
+  uint32_t addralign_;
+};
+
+// Arm_relobj class.
+
+template<bool big_endian>
+class Arm_relobj : public Sized_relobj<32, big_endian>
+{
+ public:
+  static const Arm_address invalid_address = static_cast<Arm_address>(-1);
+
+  Arm_relobj(const std::string& name, Input_file* input_file, off_t offset,
+             const typename elfcpp::Ehdr<32, big_endian>& ehdr)
+    : Sized_relobj<32, big_endian>(name, input_file, offset, ehdr),
+      stub_tables_(), local_symbol_is_thumb_function_(),
+      attributes_section_data_(NULL), mapping_symbols_info_(),
+      section_has_cortex_a8_workaround_(NULL), exidx_section_map_(),
+      output_local_symbol_count_needs_update_(false)
+  { }
+
+  ~Arm_relobj()
+  { delete this->attributes_section_data_; }
+ 
+  // Return the stub table of the SHNDX-th section if there is one.
+  Stub_table<big_endian>*
+  stub_table(unsigned int shndx) const
+  {
+    gold_assert(shndx < this->stub_tables_.size());
+    return this->stub_tables_[shndx];
+  }
+
+  // Set STUB_TABLE to be the stub_table of the SHNDX-th section.
+  void
+  set_stub_table(unsigned int shndx, Stub_table<big_endian>* stub_table)
+  {
+    gold_assert(shndx < this->stub_tables_.size());
+    this->stub_tables_[shndx] = stub_table;
+  }
+
+  // Whether a local symbol is a THUMB function.  R_SYM is the symbol table
+  // index.  This is only valid after do_count_local_symbol is called.
+  bool
+  local_symbol_is_thumb_function(unsigned int r_sym) const
+  {
+    gold_assert(r_sym < this->local_symbol_is_thumb_function_.size());
+    return this->local_symbol_is_thumb_function_[r_sym];
+  }
+  
+  // Scan all relocation sections for stub generation.
+  void
+  scan_sections_for_stubs(Target_arm<big_endian>*, const Symbol_table*,
+			  const Layout*);
+
+  // Convert regular input section with index SHNDX to a relaxed section.
+  void
+  convert_input_section_to_relaxed_section(unsigned shndx)
+  {
+    // The stubs have relocations and we need to process them after writing
+    // out the stubs.  So relocation now must follow section write.
+    this->set_section_offset(shndx, -1ULL);
+    this->set_relocs_must_follow_section_writes();
+  }
+
+  // Downcast a base pointer to an Arm_relobj pointer.  This is
+  // not type-safe but we only use Arm_relobj not the base class.
+  static Arm_relobj<big_endian>*
+  as_arm_relobj(Relobj* relobj)
+  { return static_cast<Arm_relobj<big_endian>*>(relobj); }
+
+  // Processor-specific flags in ELF file header.  This is valid only after
+  // reading symbols.
+  elfcpp::Elf_Word
+  processor_specific_flags() const
+  { return this->processor_specific_flags_; }
+
+  // Attribute section data  This is the contents of the .ARM.attribute section
+  // if there is one.
+  const Attributes_section_data*
+  attributes_section_data() const
+  { return this->attributes_section_data_; }
+
+  // Mapping symbol location.
+  typedef std::pair<unsigned int, Arm_address> Mapping_symbol_position;
+
+  // Functor for STL container.
+  struct Mapping_symbol_position_less
+  {
+    bool
+    operator()(const Mapping_symbol_position& p1,
+	       const Mapping_symbol_position& p2) const
+    {
+      return (p1.first < p2.first
+	      || (p1.first == p2.first && p1.second < p2.second));
+    }
+  };
+  
+  // We only care about the first character of a mapping symbol, so
+  // we only store that instead of the whole symbol name.
+  typedef std::map<Mapping_symbol_position, char,
+		   Mapping_symbol_position_less> Mapping_symbols_info;
+
+  // Whether a section contains any Cortex-A8 workaround.
+  bool
+  section_has_cortex_a8_workaround(unsigned int shndx) const
+  { 
+    return (this->section_has_cortex_a8_workaround_ != NULL
+	    && (*this->section_has_cortex_a8_workaround_)[shndx]);
+  }
+  
+  // Mark a section that has Cortex-A8 workaround.
+  void
+  mark_section_for_cortex_a8_workaround(unsigned int shndx)
+  {
+    if (this->section_has_cortex_a8_workaround_ == NULL)
+      this->section_has_cortex_a8_workaround_ =
+	new std::vector<bool>(this->shnum(), false);
+    (*this->section_has_cortex_a8_workaround_)[shndx] = true;
+  }
+
+  // Return the EXIDX section of an text section with index SHNDX or NULL
+  // if the text section has no associated EXIDX section.
+  const Arm_exidx_input_section*
+  exidx_input_section_by_link(unsigned int shndx) const
+  {
+    Exidx_section_map::const_iterator p = this->exidx_section_map_.find(shndx);
+    return ((p != this->exidx_section_map_.end()
+	     && p->second->link() == shndx)
+	    ? p->second
+	    : NULL);
+  }
+
+  // Return the EXIDX section with index SHNDX or NULL if there is none.
+  const Arm_exidx_input_section*
+  exidx_input_section_by_shndx(unsigned shndx) const
+  {
+    Exidx_section_map::const_iterator p = this->exidx_section_map_.find(shndx);
+    return ((p != this->exidx_section_map_.end()
+	     && p->second->shndx() == shndx)
+	    ? p->second
+	    : NULL);
+  }
+
+  // Whether output local symbol count needs updating.
+  bool
+  output_local_symbol_count_needs_update() const
+  { return this->output_local_symbol_count_needs_update_; }
+
+  // Set output_local_symbol_count_needs_update flag to be true.
+  void
+  set_output_local_symbol_count_needs_update()
+  { this->output_local_symbol_count_needs_update_ = true; }
+  
+  // Update output local symbol count at the end of relaxation.
+  void
+  update_output_local_symbol_count();
+
+ protected:
+  // Post constructor setup.
+  void
+  do_setup()
+  {
+    // Call parent's setup method.
+    Sized_relobj<32, big_endian>::do_setup();
+
+    // Initialize look-up tables.
+    Stub_table_list empty_stub_table_list(this->shnum(), NULL);
+    this->stub_tables_.swap(empty_stub_table_list);
+  }
+
+  // Count the local symbols.
+  void
+  do_count_local_symbols(Stringpool_template<char>*,
+                         Stringpool_template<char>*);
+
+  void
+  do_relocate_sections(const Symbol_table* symtab, const Layout* layout,
+		       const unsigned char* pshdrs,
+		       typename Sized_relobj<32, big_endian>::Views* pivews);
+
+  // Read the symbol information.
+  void
+  do_read_symbols(Read_symbols_data* sd);
+
+  // Process relocs for garbage collection.
+  void
+  do_gc_process_relocs(Symbol_table*, Layout*, Read_relocs_data*);
+
+ private:
+
+  // Whether a section needs to be scanned for relocation stubs.
+  bool
+  section_needs_reloc_stub_scanning(const elfcpp::Shdr<32, big_endian>&,
+				    const Relobj::Output_sections&,
+				    const Symbol_table *, const unsigned char*);
+
+  // Whether a section needs to be scanned for the Cortex-A8 erratum.
+  bool
+  section_needs_cortex_a8_stub_scanning(const elfcpp::Shdr<32, big_endian>&,
+					unsigned int, Output_section*,
+					const Symbol_table *);
+
+  // Scan a section for the Cortex-A8 erratum.
+  void
+  scan_section_for_cortex_a8_erratum(const elfcpp::Shdr<32, big_endian>&,
+				     unsigned int, Output_section*,
+				     Target_arm<big_endian>*);
+
+  // Make a new Arm_exidx_input_section object for EXIDX section with
+  // index SHNDX and section header SHDR.
+  void
+  make_exidx_input_section(unsigned int shndx,
+			   const elfcpp::Shdr<32, big_endian>& shdr);
+
+  typedef std::vector<Stub_table<big_endian>*> Stub_table_list;
+  typedef Unordered_map<unsigned int, const Arm_exidx_input_section*>
+    Exidx_section_map;
+
+  // List of stub tables.
+  Stub_table_list stub_tables_;
+  // Bit vector to tell if a local symbol is a thumb function or not.
+  // This is only valid after do_count_local_symbol is called.
+  std::vector<bool> local_symbol_is_thumb_function_;
+  // processor-specific flags in ELF file header.
+  elfcpp::Elf_Word processor_specific_flags_;
+  // Object attributes if there is an .ARM.attributes section or NULL.
+  Attributes_section_data* attributes_section_data_;
+  // Mapping symbols information.
+  Mapping_symbols_info mapping_symbols_info_;
+  // Bitmap to indicate sections with Cortex-A8 workaround or NULL.
+  std::vector<bool>* section_has_cortex_a8_workaround_;
+  // Map a text section to its associated .ARM.exidx section, if there is one.
+  Exidx_section_map exidx_section_map_;
+  // Whether output local symbol count needs updating.
+  bool output_local_symbol_count_needs_update_;
+};
+
+// Arm_dynobj class.
+
+template<bool big_endian>
+class Arm_dynobj : public Sized_dynobj<32, big_endian>
+{
+ public:
+  Arm_dynobj(const std::string& name, Input_file* input_file, off_t offset,
+	     const elfcpp::Ehdr<32, big_endian>& ehdr)
+    : Sized_dynobj<32, big_endian>(name, input_file, offset, ehdr),
+      processor_specific_flags_(0), attributes_section_data_(NULL)
+  { }
+ 
+  ~Arm_dynobj()
+  { delete this->attributes_section_data_; }
+
+  // Downcast a base pointer to an Arm_relobj pointer.  This is
+  // not type-safe but we only use Arm_relobj not the base class.
+  static Arm_dynobj<big_endian>*
+  as_arm_dynobj(Dynobj* dynobj)
+  { return static_cast<Arm_dynobj<big_endian>*>(dynobj); }
+
+  // Processor-specific flags in ELF file header.  This is valid only after
+  // reading symbols.
+  elfcpp::Elf_Word
+  processor_specific_flags() const
+  { return this->processor_specific_flags_; }
+
+  // Attributes section data.
+  const Attributes_section_data*
+  attributes_section_data() const
+  { return this->attributes_section_data_; }
+
+ protected:
+  // Read the symbol information.
+  void
+  do_read_symbols(Read_symbols_data* sd);
+
+ private:
+  // processor-specific flags in ELF file header.
+  elfcpp::Elf_Word processor_specific_flags_;
+  // Object attributes if there is an .ARM.attributes section or NULL.
+  Attributes_section_data* attributes_section_data_;
+};
+
+// Functor to read reloc addends during stub generation.
+
+template<int sh_type, bool big_endian>
+struct Stub_addend_reader
+{
+  // Return the addend for a relocation of a particular type.  Depending
+  // on whether this is a REL or RELA relocation, read the addend from a
+  // view or from a Reloc object.
+  elfcpp::Elf_types<32>::Elf_Swxword
+  operator()(
+    unsigned int /* r_type */,
+    const unsigned char* /* view */,
+    const typename Reloc_types<sh_type,
+			       32, big_endian>::Reloc& /* reloc */) const;
+};
+
+// Specialized Stub_addend_reader for SHT_REL type relocation sections.
+
+template<bool big_endian>
+struct Stub_addend_reader<elfcpp::SHT_REL, big_endian>
+{
+  elfcpp::Elf_types<32>::Elf_Swxword
+  operator()(
+    unsigned int,
+    const unsigned char*,
+    const typename Reloc_types<elfcpp::SHT_REL, 32, big_endian>::Reloc&) const;
+};
+
+// Specialized Stub_addend_reader for RELA type relocation sections.
+// We currently do not handle RELA type relocation sections but it is trivial
+// to implement the addend reader.  This is provided for completeness and to
+// make it easier to add support for RELA relocation sections in the future.
+
+template<bool big_endian>
+struct Stub_addend_reader<elfcpp::SHT_RELA, big_endian>
+{
+  elfcpp::Elf_types<32>::Elf_Swxword
+  operator()(
+    unsigned int,
+    const unsigned char*,
+    const typename Reloc_types<elfcpp::SHT_RELA, 32,
+			       big_endian>::Reloc& reloc) const
+  { return reloc.get_r_addend(); }
+};
+
+// Cortex_a8_reloc class.  We keep record of relocation that may need
+// the Cortex-A8 erratum workaround.
+
+class Cortex_a8_reloc
+{
+ public:
+  Cortex_a8_reloc(Reloc_stub* reloc_stub, unsigned r_type,
+		  Arm_address destination)
+    : reloc_stub_(reloc_stub), r_type_(r_type), destination_(destination)
+  { }
+
+  ~Cortex_a8_reloc()
+  { }
+
+  // Accessors:  This is a read-only class.
+  
+  // Return the relocation stub associated with this relocation if there is
+  // one.
+  const Reloc_stub*
+  reloc_stub() const
+  { return this->reloc_stub_; } 
+  
+  // Return the relocation type.
+  unsigned int
+  r_type() const
+  { return this->r_type_; }
+
+  // Return the destination address of the relocation.  LSB stores the THUMB
+  // bit.
+  Arm_address
+  destination() const
+  { return this->destination_; }
+
+ private:
+  // Associated relocation stub if there is one, or NULL.
+  const Reloc_stub* reloc_stub_;
+  // Relocation type.
+  unsigned int r_type_;
+  // Destination address of this relocation.  LSB is used to distinguish
+  // ARM/THUMB mode.
+  Arm_address destination_;
+};
+
+// Arm_output_data_got class.  We derive this from Output_data_got to add
+// extra methods to handle TLS relocations in a static link.
+
+template<bool big_endian>
+class Arm_output_data_got : public Output_data_got<32, big_endian>
+{
+ public:
+  Arm_output_data_got(Symbol_table* symtab, Layout* layout)
+    : Output_data_got<32, big_endian>(), symbol_table_(symtab), layout_(layout)
+  { }
+
+  // Add a static entry for the GOT entry at OFFSET.  GSYM is a global
+  // symbol and R_TYPE is the code of a dynamic relocation that needs to be
+  // applied in a static link.
+  void
+  add_static_reloc(unsigned int got_offset, unsigned int r_type, Symbol* gsym)
+  { this->static_relocs_.push_back(Static_reloc(got_offset, r_type, gsym)); }
+
+  // Add a static reloc for the GOT entry at OFFSET.  RELOBJ is an object
+  // defining a local symbol with INDEX.  R_TYPE is the code of a dynamic
+  // relocation that needs to be applied in a static link.
+  void
+  add_static_reloc(unsigned int got_offset, unsigned int r_type,
+		   Sized_relobj<32, big_endian>* relobj, unsigned int index)
+  {
+    this->static_relocs_.push_back(Static_reloc(got_offset, r_type, relobj,
+						index));
+  }
+
+  // Add a GOT pair for R_ARM_TLS_GD32.  The creates a pair of GOT entries.
+  // The first one is initialized to be 1, which is the module index for
+  // the main executable and the second one 0.  A reloc of the type
+  // R_ARM_TLS_DTPOFF32 will be created for the second GOT entry and will
+  // be applied by gold.  GSYM is a global symbol.
+  void
+  add_tls_gd32_with_static_reloc(unsigned int got_type, Symbol* gsym);
+
+  // Same as the above but for a local symbol in OBJECT with INDEX.
+  void
+  add_tls_gd32_with_static_reloc(unsigned int got_type,
+				 Sized_relobj<32, big_endian>* object,
+				 unsigned int index);
+
+ protected:
+  // Write out the GOT table.
+  void
+  do_write(Output_file*);
+
+ private:
+  // This class represent dynamic relocations that need to be applied by
+  // gold because we are using TLS relocations in a static link.
+  class Static_reloc
+  {
+   public:
+    Static_reloc(unsigned int got_offset, unsigned int r_type, Symbol* gsym)
+      : got_offset_(got_offset), r_type_(r_type), symbol_is_global_(true)
+    { this->u_.global.symbol = gsym; }
+
+    Static_reloc(unsigned int got_offset, unsigned int r_type,
+	  Sized_relobj<32, big_endian>* relobj, unsigned int index)
+      : got_offset_(got_offset), r_type_(r_type), symbol_is_global_(false)
+    {
+      this->u_.local.relobj = relobj;
+      this->u_.local.index = index;
+    }
+
+    // Return the GOT offset.
+    unsigned int
+    got_offset() const
+    { return this->got_offset_; }
+
+    // Relocation type.
+    unsigned int
+    r_type() const
+    { return this->r_type_; }
+
+    // Whether the symbol is global or not.
+    bool
+    symbol_is_global() const
+    { return this->symbol_is_global_; }
+
+    // For a relocation against a global symbol, the global symbol.
+    Symbol*
+    symbol() const
+    {
+      gold_assert(this->symbol_is_global_);
+      return this->u_.global.symbol;
+    }
+
+    // For a relocation against a local symbol, the defining object.
+    Sized_relobj<32, big_endian>*
+    relobj() const
+    {
+      gold_assert(!this->symbol_is_global_);
+      return this->u_.local.relobj;
+    }
+
+    // For a relocation against a local symbol, the local symbol index.
+    unsigned int
+    index() const
+    {
+      gold_assert(!this->symbol_is_global_);
+      return this->u_.local.index;
+    }
+
+   private:
+    // GOT offset of the entry to which this relocation is applied.
+    unsigned int got_offset_;
+    // Type of relocation.
+    unsigned int r_type_;
+    // Whether this relocation is against a global symbol.
+    bool symbol_is_global_;
+    // A global or local symbol.
+    union
+    {
+      struct
+      {
+	// For a global symbol, the symbol itself.
+	Symbol* symbol;
+      } global;
+      struct
+      {
+	// For a local symbol, the object defining object.
+	Sized_relobj<32, big_endian>* relobj;
+	// For a local symbol, the symbol index.
+	unsigned int index;
+      } local;
+    } u_;
+  };
+
+  // Symbol table of the output object.
+  Symbol_table* symbol_table_;
+  // Layout of the output object.
+  Layout* layout_;
+  // Static relocs to be applied to the GOT.
+  std::vector<Static_reloc> static_relocs_;
+};
+
 // Utilities for manipulating integers of up to 32-bits
 
 namespace utils
@@ -166,17 +1958,92 @@ class Target_arm : public Sized_target<32, big_endian>
   typedef Output_data_reloc<elfcpp::SHT_REL, true, 32, big_endian>
     Reloc_section;
 
+  // When were are relocating a stub, we pass this as the relocation number.
+  static const size_t fake_relnum_for_stubs = static_cast<size_t>(-1);
+
   Target_arm()
     : Sized_target<32, big_endian>(&arm_info),
       got_(NULL), plt_(NULL), got_plt_(NULL), rel_dyn_(NULL),
-      copy_relocs_(elfcpp::R_ARM_COPY), dynbss_(NULL)
+      copy_relocs_(elfcpp::R_ARM_COPY), dynbss_(NULL), 
+      got_mod_index_offset_(-1U), tls_base_symbol_defined_(false),
+      stub_tables_(), stub_factory_(Stub_factory::get_instance()),
+      may_use_blx_(false), should_force_pic_veneer_(false),
+      arm_input_section_map_(), attributes_section_data_(NULL),
+      fix_cortex_a8_(false), cortex_a8_relocs_info_()
   { }
 
+  // Whether we can use BLX.
+  bool
+  may_use_blx() const
+  { return this->may_use_blx_; }
+
+  // Set use-BLX flag.
+  void
+  set_may_use_blx(bool value)
+  { this->may_use_blx_ = value; }
+  
+  // Whether we force PCI branch veneers.
+  bool
+  should_force_pic_veneer() const
+  { return this->should_force_pic_veneer_; }
+
+  // Set PIC veneer flag.
+  void
+  set_should_force_pic_veneer(bool value)
+  { this->should_force_pic_veneer_ = value; }
+  
+  // Whether we use THUMB-2 instructions.
+  bool
+  using_thumb2() const
+  {
+    Object_attribute* attr =
+      this->get_aeabi_object_attribute(elfcpp::Tag_CPU_arch);
+    int arch = attr->int_value();
+    return arch == elfcpp::TAG_CPU_ARCH_V6T2 || arch >= elfcpp::TAG_CPU_ARCH_V7;
+  }
+
+  // Whether we use THUMB/THUMB-2 instructions only.
+  bool
+  using_thumb_only() const
+  {
+    Object_attribute* attr =
+      this->get_aeabi_object_attribute(elfcpp::Tag_CPU_arch);
+    if (attr->int_value() != elfcpp::TAG_CPU_ARCH_V7
+	&& attr->int_value() != elfcpp::TAG_CPU_ARCH_V7E_M)
+      return false;
+    attr = this->get_aeabi_object_attribute(elfcpp::Tag_CPU_arch_profile);
+    return attr->int_value() == 'M';
+  }
+
+  // Whether we have an NOP instruction.  If not, use mov r0, r0 instead.
+  bool
+  may_use_arm_nop() const
+  {
+    Object_attribute* attr =
+      this->get_aeabi_object_attribute(elfcpp::Tag_CPU_arch);
+    int arch = attr->int_value();
+    return (arch == elfcpp::TAG_CPU_ARCH_V6T2
+	    || arch == elfcpp::TAG_CPU_ARCH_V6K
+	    || arch == elfcpp::TAG_CPU_ARCH_V7
+	    || arch == elfcpp::TAG_CPU_ARCH_V7E_M);
+  }
+
+  // Whether we have THUMB-2 NOP.W instruction.
+  bool
+  may_use_thumb2_nop() const
+  {
+    Object_attribute* attr =
+      this->get_aeabi_object_attribute(elfcpp::Tag_CPU_arch);
+    int arch = attr->int_value();
+    return (arch == elfcpp::TAG_CPU_ARCH_V6T2
+	    || arch == elfcpp::TAG_CPU_ARCH_V7
+	    || arch == elfcpp::TAG_CPU_ARCH_V7E_M);
+  }
+  
   // Process the relocations to determine unreferenced sections for 
   // garbage collection.
   void
-  gc_process_relocs(const General_options& options,
-		    Symbol_table* symtab,
+  gc_process_relocs(Symbol_table* symtab,
 		    Layout* layout,
 		    Sized_relobj<32, big_endian>* object,
 		    unsigned int data_shndx,
@@ -190,8 +2057,7 @@ class Target_arm : public Sized_target<32, big_endian>
 
   // Scan the relocations to look for symbol adjustments.
   void
-  scan_relocs(const General_options& options,
-	      Symbol_table* symtab,
+  scan_relocs(Symbol_table* symtab,
 	      Layout* layout,
 	      Sized_relobj<32, big_endian>* object,
 	      unsigned int data_shndx,
@@ -205,7 +2071,7 @@ class Target_arm : public Sized_target<32, big_endian>
 
   // Finalize the sections.
   void
-  do_finalize_sections(Layout*);
+  do_finalize_sections(Layout*, const Input_objects*, Symbol_table*);
 
   // Return the value to use for a dynamic symbol which requires special
   // treatment.
@@ -221,14 +2087,13 @@ class Target_arm : public Sized_target<32, big_endian>
 		   Output_section* output_section,
 		   bool needs_special_offset_handling,
 		   unsigned char* view,
-		   elfcpp::Elf_types<32>::Elf_Addr view_address,
+		   Arm_address view_address,
 		   section_size_type view_size,
 		   const Reloc_symbol_changes*);
 
   // Scan the relocs during a relocatable link.
   void
-  scan_relocatable_relocs(const General_options& options,
-			  Symbol_table* symtab,
+  scan_relocatable_relocs(Symbol_table* symtab,
 			  Layout* layout,
 			  Sized_relobj<32, big_endian>* object,
 			  unsigned int data_shndx,
@@ -251,7 +2116,7 @@ class Target_arm : public Sized_target<32, big_endian>
 			   off_t offset_in_output_section,
 			   const Relocatable_relocs*,
 			   unsigned char* view,
-			   elfcpp::Elf_types<32>::Elf_Addr view_address,
+			   Arm_address view_address,
 			   section_size_type view_size,
 			   unsigned char* reloc_view,
 			   section_size_type reloc_view_size);
@@ -273,6 +2138,144 @@ class Target_arm : public Sized_target<32, big_endian>
   static unsigned int
   get_real_reloc_type (unsigned int r_type);
 
+  //
+  // Methods to support stub-generations.
+  //
+  
+  // Return the stub factory
+  const Stub_factory&
+  stub_factory() const
+  { return this->stub_factory_; }
+
+  // Make a new Arm_input_section object.
+  Arm_input_section<big_endian>*
+  new_arm_input_section(Relobj*, unsigned int);
+
+  // Find the Arm_input_section object corresponding to the SHNDX-th input
+  // section of RELOBJ.
+  Arm_input_section<big_endian>*
+  find_arm_input_section(Relobj* relobj, unsigned int shndx) const;
+
+  // Make a new Stub_table
+  Stub_table<big_endian>*
+  new_stub_table(Arm_input_section<big_endian>*);
+
+  // Scan a section for stub generation.
+  void
+  scan_section_for_stubs(const Relocate_info<32, big_endian>*, unsigned int,
+			 const unsigned char*, size_t, Output_section*,
+			 bool, const unsigned char*, Arm_address,
+			 section_size_type);
+
+  // Relocate a stub. 
+  void
+  relocate_stub(Stub*, const Relocate_info<32, big_endian>*,
+		Output_section*, unsigned char*, Arm_address,
+		section_size_type);
+ 
+  // Get the default ARM target.
+  static Target_arm<big_endian>*
+  default_target()
+  {
+    gold_assert(parameters->target().machine_code() == elfcpp::EM_ARM
+		&& parameters->target().is_big_endian() == big_endian);
+    return static_cast<Target_arm<big_endian>*>(
+	     parameters->sized_target<32, big_endian>());
+  }
+
+  // Whether NAME belongs to a mapping symbol.
+  static bool
+  is_mapping_symbol_name(const char* name)
+  {
+    return (name
+	    && name[0] == '$'
+	    && (name[1] == 'a' || name[1] == 't' || name[1] == 'd')
+	    && (name[2] == '\0' || name[2] == '.'));
+  }
+
+  // Whether we work around the Cortex-A8 erratum.
+  bool
+  fix_cortex_a8() const
+  { return this->fix_cortex_a8_; }
+
+  // Whether we fix R_ARM_V4BX relocation.
+  // 0 - do not fix
+  // 1 - replace with MOV instruction (armv4 target)
+  // 2 - make interworking veneer (>= armv4t targets only)
+  General_options::Fix_v4bx
+  fix_v4bx() const
+  { return parameters->options().fix_v4bx(); }
+
+  // Scan a span of THUMB code section for Cortex-A8 erratum.
+  void
+  scan_span_for_cortex_a8_erratum(Arm_relobj<big_endian>*, unsigned int,
+				  section_size_type, section_size_type,
+				  const unsigned char*, Arm_address);
+
+  // Apply Cortex-A8 workaround to a branch.
+  void
+  apply_cortex_a8_workaround(const Cortex_a8_stub*, Arm_address,
+			     unsigned char*, Arm_address);
+
+ protected:
+  // Make an ELF object.
+  Object*
+  do_make_elf_object(const std::string&, Input_file*, off_t,
+		     const elfcpp::Ehdr<32, big_endian>& ehdr);
+
+  Object*
+  do_make_elf_object(const std::string&, Input_file*, off_t,
+		     const elfcpp::Ehdr<32, !big_endian>&)
+  { gold_unreachable(); }
+
+  Object*
+  do_make_elf_object(const std::string&, Input_file*, off_t,
+		      const elfcpp::Ehdr<64, false>&)
+  { gold_unreachable(); }
+
+  Object*
+  do_make_elf_object(const std::string&, Input_file*, off_t,
+		     const elfcpp::Ehdr<64, true>&)
+  { gold_unreachable(); }
+
+  // Make an output section.
+  Output_section*
+  do_make_output_section(const char* name, elfcpp::Elf_Word type,
+			 elfcpp::Elf_Xword flags)
+  { return new Arm_output_section<big_endian>(name, type, flags); }
+
+  void
+  do_adjust_elf_header(unsigned char* view, int len) const;
+
+  // We only need to generate stubs, and hence perform relaxation if we are
+  // not doing relocatable linking.
+  bool
+  do_may_relax() const
+  { return !parameters->options().relocatable(); }
+
+  bool
+  do_relax(int, const Input_objects*, Symbol_table*, Layout*);
+
+  // Determine whether an object attribute tag takes an integer, a
+  // string or both.
+  int
+  do_attribute_arg_type(int tag) const;
+
+  // Reorder tags during output.
+  int
+  do_attributes_order(int num) const;
+
+  // This is called when the target is selected as the default.
+  void
+  do_select_as_default_target()
+  {
+    // No locking is required since there should only be one default target.
+    // We cannot have both the big-endian and little-endian ARM targets
+    // as the default.
+    gold_assert(arm_reloc_property_table == NULL);
+    arm_reloc_property_table = new Arm_reloc_property_table();
+  }
+
  private:
   // The class which scans relocations.
   class Scan
@@ -283,8 +2286,7 @@ class Target_arm : public Sized_target<32, big_endian>
     { }
 
     inline void
-    local(const General_options& options, Symbol_table* symtab,
-	  Layout* layout, Target_arm* target,
+    local(Symbol_table* symtab, Layout* layout, Target_arm* target,
 	  Sized_relobj<32, big_endian>* object,
 	  unsigned int data_shndx,
 	  Output_section* output_section,
@@ -292,8 +2294,7 @@ class Target_arm : public Sized_target<32, big_endian>
 	  const elfcpp::Sym<32, big_endian>& lsym);
 
     inline void
-    global(const General_options& options, Symbol_table* symtab,
-	   Layout* layout, Target_arm* target,
+    global(Symbol_table* symtab, Layout* layout, Target_arm* target,
 	   Sized_relobj<32, big_endian>* object,
 	   unsigned int data_shndx,
 	   Output_section* output_section,
@@ -358,31 +2359,52 @@ class Target_arm : public Sized_target<32, big_endian>
 	     const elfcpp::Rel<32, big_endian>&,
 	     unsigned int r_type, const Sized_symbol<32>*,
 	     const Symbol_value<32>*,
-	     unsigned char*, elfcpp::Elf_types<32>::Elf_Addr,
+	     unsigned char*, Arm_address,
 	     section_size_type);
 
     // Return whether we want to pass flag NON_PIC_REF for this
-    // reloc.
+    // reloc.  This means the relocation type accesses a symbol not via
+    // GOT or PLT.
     static inline bool
     reloc_is_non_pic (unsigned int r_type)
     {
       switch (r_type)
 	{
-	case elfcpp::R_ARM_REL32:
-	case elfcpp::R_ARM_THM_CALL:
+	// These relocation types reference GOT or PLT entries explicitly.
+	case elfcpp::R_ARM_GOT_BREL:
+	case elfcpp::R_ARM_GOT_ABS:
+	case elfcpp::R_ARM_GOT_PREL:
+	case elfcpp::R_ARM_GOT_BREL12:
+	case elfcpp::R_ARM_PLT32_ABS:
+	case elfcpp::R_ARM_TLS_GD32:
+	case elfcpp::R_ARM_TLS_LDM32:
+	case elfcpp::R_ARM_TLS_IE32:
+	case elfcpp::R_ARM_TLS_IE12GP:
+
+	// These relocate types may use PLT entries.
 	case elfcpp::R_ARM_CALL:
+	case elfcpp::R_ARM_THM_CALL:
 	case elfcpp::R_ARM_JUMP24:
-	case elfcpp::R_ARM_PREL31:
-	case elfcpp::R_ARM_THM_ABS5:
-	case elfcpp::R_ARM_ABS8:
-	case elfcpp::R_ARM_ABS12:
-	case elfcpp::R_ARM_ABS16:
-	case elfcpp::R_ARM_BASE_ABS:
-	  return true;
-	default:
+	case elfcpp::R_ARM_THM_JUMP24:
+	case elfcpp::R_ARM_THM_JUMP19:
+	case elfcpp::R_ARM_PLT32:
+	case elfcpp::R_ARM_THM_XPC22:
 	  return false;
+
+	default:
+	  return true;
 	}
     }
+
+   private:
+    // Do a TLS relocation.
+    inline typename Arm_relocate_functions<big_endian>::Status
+    relocate_tls(const Relocate_info<32, big_endian>*, Target_arm<big_endian>*,
+                 size_t, const elfcpp::Rel<32, big_endian>&, unsigned int,
+		 const Sized_symbol<32>*, const Symbol_value<32>*,
+		 unsigned char*, elfcpp::Elf_types<32>::Elf_Addr,
+		 section_size_type);
+
   };
 
   // A class which returns the size required for a relocation type,
@@ -394,8 +2416,13 @@ class Target_arm : public Sized_target<32, big_endian>
     get_size_for_reloc(unsigned int, Relobj*);
   };
 
+  // Adjust TLS relocation type based on the options and whether this
+  // is a local symbol.
+  static tls::Tls_optimization
+  optimize_tls_reloc(bool is_final, int r_type);
+
   // Get the GOT section, creating it if necessary.
-  Output_data_got<32, big_endian>*
+  Arm_output_data_got<big_endian>*
   got_section(Symbol_table*, Layout*);
 
   // Get the GOT PLT section.
@@ -410,6 +2437,15 @@ class Target_arm : public Sized_target<32, big_endian>
   void
   make_plt_entry(Symbol_table*, Layout*, Symbol*);
 
+  // Define the _TLS_MODULE_BASE_ symbol in the TLS segment.
+  void
+  define_tls_base_symbol(Symbol_table*, Layout*);
+
+  // Create a GOT entry for the TLS module index.
+  unsigned int
+  got_mod_index_entry(Symbol_table* symtab, Layout* layout,
+		      Sized_relobj<32, big_endian>* object);
+
   // Get the PLT section.
   const Output_data_plt_arm<big_endian>*
   plt_section() const
@@ -422,6 +2458,10 @@ class Target_arm : public Sized_target<32, big_endian>
   Reloc_section*
   rel_dyn_section(Layout*);
 
+  // Get the section to use for TLS_DESC relocations.
+  Reloc_section*
+  rel_tls_desc_section(Layout*) const;
+
   // Return true if the symbol may need a COPY relocation.
   // References from an executable object to non-function symbols
   // defined in a dynamic object may need a COPY relocation.
@@ -445,6 +2485,90 @@ class Target_arm : public Sized_target<32, big_endian>
 				  this->rel_dyn_section(layout));
   }
 
+  // Whether two EABI versions are compatible.
+  static bool
+  are_eabi_versions_compatible(elfcpp::Elf_Word v1, elfcpp::Elf_Word v2);
+
+  // Merge processor-specific flags from input object and those in the ELF
+  // header of the output.
+  void
+  merge_processor_specific_flags(const std::string&, elfcpp::Elf_Word);
+
+  // Get the secondary compatible architecture.
+  static int
+  get_secondary_compatible_arch(const Attributes_section_data*);
+
+  // Set the secondary compatible architecture.
+  static void
+  set_secondary_compatible_arch(Attributes_section_data*, int);
+
+  static int
+  tag_cpu_arch_combine(const char*, int, int*, int, int);
+
+  // Helper to print AEABI enum tag value.
+  static std::string
+  aeabi_enum_name(unsigned int);
+
+  // Return string value for TAG_CPU_name.
+  static std::string
+  tag_cpu_name_value(unsigned int);
+
+  // Merge object attributes from input object and those in the output.
+  void
+  merge_object_attributes(const char*, const Attributes_section_data*);
+
+  // Helper to get an AEABI object attribute
+  Object_attribute*
+  get_aeabi_object_attribute(int tag) const
+  {
+    Attributes_section_data* pasd = this->attributes_section_data_;
+    gold_assert(pasd != NULL);
+    Object_attribute* attr =
+      pasd->get_attribute(Object_attribute::OBJ_ATTR_PROC, tag);
+    gold_assert(attr != NULL);
+    return attr;
+  }
+
+  //
+  // Methods to support stub-generations.
+  //
+
+  // Group input sections for stub generation.
+  void
+  group_sections(Layout*, section_size_type, bool);
+
+  // Scan a relocation for stub generation.
+  void
+  scan_reloc_for_stub(const Relocate_info<32, big_endian>*, unsigned int,
+		      const Sized_symbol<32>*, unsigned int,
+		      const Symbol_value<32>*,
+		      elfcpp::Elf_types<32>::Elf_Swxword, Arm_address);
+
+  // Scan a relocation section for stub.
+  template<int sh_type>
+  void
+  scan_reloc_section_for_stubs(
+      const Relocate_info<32, big_endian>* relinfo,
+      const unsigned char* prelocs,
+      size_t reloc_count,
+      Output_section* output_section,
+      bool needs_special_offset_handling,
+      const unsigned char* view,
+      elfcpp::Elf_types<32>::Elf_Addr view_address,
+      section_size_type);
+
+  // Fix .ARM.exidx section coverage.
+  void
+  fix_exidx_coverage(Layout*, Arm_output_section<big_endian>*, Symbol_table*);
+
+  // Functors for STL set.
+  struct output_section_address_less_than
+  {
+    bool
+    operator()(const Output_section* s1, const Output_section* s2) const
+    { return s1->address() < s2->address(); }
+  };
+
   // Information about this specific target which we pass to the
   // general Target structure.
   static const Target::Target_info arm_info;
@@ -452,11 +2576,27 @@ class Target_arm : public Sized_target<32, big_endian>
   // The types of GOT entries needed for this platform.
   enum Got_type
   {
-    GOT_TYPE_STANDARD = 0	// GOT entry for a regular symbol
+    GOT_TYPE_STANDARD = 0,      // GOT entry for a regular symbol
+    GOT_TYPE_TLS_NOFFSET = 1,   // GOT entry for negative TLS offset
+    GOT_TYPE_TLS_OFFSET = 2,    // GOT entry for positive TLS offset
+    GOT_TYPE_TLS_PAIR = 3,      // GOT entry for TLS module/offset pair
+    GOT_TYPE_TLS_DESC = 4       // GOT entry for TLS_DESC pair
   };
 
+  typedef typename std::vector<Stub_table<big_endian>*> Stub_table_list;
+
+  // Map input section to Arm_input_section.
+  typedef Unordered_map<Section_id,
+			Arm_input_section<big_endian>*,
+			Section_id_hash>
+	  Arm_input_section_map;
+    
+  // Map output addresses to relocs for Cortex-A8 erratum.
+  typedef Unordered_map<Arm_address, const Cortex_a8_reloc*>
+	  Cortex_a8_relocs_info;
+
   // The GOT section.
-  Output_data_got<32, big_endian>* got_;
+  Arm_output_data_got<big_endian>* got_;
   // The PLT section.
   Output_data_plt_arm<big_endian>* plt_;
   // The GOT PLT section.
@@ -467,6 +2607,26 @@ class Target_arm : public Sized_target<32, big_endian>
   Copy_relocs<elfcpp::SHT_REL, 32, big_endian> copy_relocs_;
   // Space for variables copied with a COPY reloc.
   Output_data_space* dynbss_;
+  // Offset of the GOT entry for the TLS module index.
+  unsigned int got_mod_index_offset_;
+  // True if the _TLS_MODULE_BASE_ symbol has been defined.
+  bool tls_base_symbol_defined_;
+  // Vector of Stub_tables created.
+  Stub_table_list stub_tables_;
+  // Stub factory.
+  const Stub_factory &stub_factory_;
+  // Whether we can use BLX.
+  bool may_use_blx_;
+  // Whether we force PIC branch veneers.
+  bool should_force_pic_veneer_;
+  // Map for locating Arm_input_sections.
+  Arm_input_section_map arm_input_section_map_;
+  // Attributes section data in output.
+  Attributes_section_data* attributes_section_data_;
+  // Whether we want to fix code for Cortex-A8 erratum.
+  bool fix_cortex_a8_;
+  // Map addresses to relocs for Cortex-A8 erratum.
+  Cortex_a8_relocs_info cortex_a8_relocs_info_;
 };
 
 template<bool big_endian>
@@ -487,7 +2647,9 @@ const Target::Target_info Target_arm<big_endian>::arm_info =
   elfcpp::SHN_UNDEF,	// small_common_shndx
   elfcpp::SHN_UNDEF,	// large_common_shndx
   0,			// small_common_section_flags
-  0			// large_common_section_flags
+  0,			// large_common_section_flags
+  ".ARM.attributes",	// attributes_section
+  "aeabi"		// attributes_vendor
 };
 
 // Arm relocate functions class
@@ -508,27 +2670,6 @@ class Arm_relocate_functions : public Relocate_functions<32, big_endian>
   typedef Relocate_functions<32, big_endian> Base;
   typedef Arm_relocate_functions<big_endian> This;
 
-  // Get an symbol value of *PSYMVAL with an ADDEND.  This is a wrapper
-  // to Symbol_value::value().  If HAS_THUMB_BIT is true, that LSB is used
-  // to distinguish ARM and THUMB functions and it is treated specially.
-  static inline Symbol_value<32>::Value
-  arm_symbol_value (const Sized_relobj<32, big_endian> *object,
-		    const Symbol_value<32>* psymval,
-		    Symbol_value<32>::Value addend,
-		    bool has_thumb_bit)
-  {
-    typedef Symbol_value<32>::Value Valtype;
-
-    if (has_thumb_bit)
-      {
-	Valtype raw = psymval->value(object, 0);
-	Valtype thumb_bit = raw & 1;
-	return ((raw & ~((Valtype) 1)) + addend) | thumb_bit;
-      }
-    else
-      return psymval->value(object, addend);
-  }
-
   // Encoding of imm16 argument for movt and movw ARM instructions
   // from ARM ARM:
   //     
@@ -602,71 +2743,163 @@ class Arm_relocate_functions : public Relocate_functions<32, big_endian>
     return val;
   }
 
-  // FIXME: This probably only works for Android on ARM v5te. We should
-  // following GNU ld for the general case.
-  template<unsigned r_type>
-  static inline typename This::Status
-  arm_branch_common(unsigned char *view,
-		    const Sized_relobj<32, big_endian>* object,
-		    const Symbol_value<32>* psymval,
-		    elfcpp::Elf_types<32>::Elf_Addr address,
-		    bool has_thumb_bit)
+  // Calculate the smallest constant Kn for the specified residual.
+  // (see (AAELF 4.6.1.4 Static ARM relocations, Group Relocations, p.32)
+  static uint32_t
+  calc_grp_kn(typename elfcpp::Swap<32, big_endian>::Valtype residual)
   {
-    typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
-    Valtype* wv = reinterpret_cast<Valtype*>(view);
-    Valtype val = elfcpp::Swap<32, big_endian>::readval(wv);
-     
-    bool insn_is_b = (((val >> 28) & 0xf) <= 0xe)
-		      && ((val & 0x0f000000UL) == 0x0a000000UL);
-    bool insn_is_uncond_bl = (val & 0xff000000UL) == 0xeb000000UL;
-    bool insn_is_cond_bl = (((val >> 28) & 0xf) < 0xe)
-			    && ((val & 0x0f000000UL) == 0x0b000000UL);
-    bool insn_is_blx = (val & 0xfe000000UL) == 0xfa000000UL;
-    bool insn_is_any_branch = (val & 0x0e000000UL) == 0x0a000000UL;
-
-    if (r_type == elfcpp::R_ARM_CALL)
-      {
-	if (!insn_is_uncond_bl && !insn_is_blx)
-	  return This::STATUS_BAD_RELOC;
-      }
-    else if (r_type == elfcpp::R_ARM_JUMP24)
-      {
-	if (!insn_is_b && !insn_is_cond_bl)
-	  return This::STATUS_BAD_RELOC;
-      }
-    else if (r_type == elfcpp::R_ARM_PLT32)
+    int32_t msb;
+
+    if (residual == 0)
+      return 0;
+    // Determine the most significant bit in the residual and
+    // align the resulting value to a 2-bit boundary.
+    for (msb = 30; (msb >= 0) && !(residual & (3 << msb)); msb -= 2)
+      ;
+    // The desired shift is now (msb - 6), or zero, whichever
+    // is the greater.
+    return (((msb - 6) < 0) ? 0 : (msb - 6));
+  }
+
+  // Calculate the final residual for the specified group index.
+  // If the passed group index is less than zero, the method will return
+  // the value of the specified residual without any change.
+  // (see (AAELF 4.6.1.4 Static ARM relocations, Group Relocations, p.32)
+  static typename elfcpp::Swap<32, big_endian>::Valtype
+  calc_grp_residual(typename elfcpp::Swap<32, big_endian>::Valtype residual,
+		    const int group)
+  {
+    for (int n = 0; n <= group; n++)
       {
-	if (!insn_is_any_branch)
-	  return This::STATUS_BAD_RELOC;
+	// Calculate which part of the value to mask.
+	uint32_t shift = calc_grp_kn(residual);
+	// Calculate the residual for the next time around.
+	residual &= ~(residual & (0xff << shift));
       }
-    else
-      gold_unreachable();
 
-    Valtype addend = utils::sign_extend<26>(val << 2);
-    Valtype x = (This::arm_symbol_value(object, psymval, addend, has_thumb_bit)
-		 - address);
+    return residual;
+  }
 
-    // If target has thumb bit set, we need to either turn the BL
-    // into a BLX (for ARMv5 or above) or generate a stub.
-    if (x & 1)
+  // Calculate the value of Gn for the specified group index.
+  // We return it in the form of an encoded constant-and-rotation.
+  // (see (AAELF 4.6.1.4 Static ARM relocations, Group Relocations, p.32)
+  static typename elfcpp::Swap<32, big_endian>::Valtype
+  calc_grp_gn(typename elfcpp::Swap<32, big_endian>::Valtype residual,
+	      const int group)
+  {
+    typename elfcpp::Swap<32, big_endian>::Valtype gn = 0;
+    uint32_t shift = 0;
+
+    for (int n = 0; n <= group; n++)
       {
-	// Turn BL to BLX.
-	if (insn_is_uncond_bl)
-	  val = (val & 0xffffff) | 0xfa000000 | ((x & 2) << 23);
-	else
-	  return This::STATUS_BAD_RELOC;
+	// Calculate which part of the value to mask.
+	shift = calc_grp_kn(residual);
+	// Calculate Gn in 32-bit as well as encoded constant-and-rotation form.
+	gn = residual & (0xff << shift);
+	// Calculate the residual for the next time around.
+	residual &= ~gn;
       }
-    else
-      gold_assert(!insn_is_blx);
-
-    val = utils::bit_select(val, (x >> 2), 0xffffffUL);
-    elfcpp::Swap<32, big_endian>::writeval(wv, val);
-    return (utils::has_overflow<26>(x)
-	    ? This::STATUS_OVERFLOW : This::STATUS_OKAY);
+    // Return Gn in the form of an encoded constant-and-rotation.
+    return ((gn >> shift) | ((gn <= 0xff ? 0 : (32 - shift) / 2) << 8));
   }
 
+  // Handle ARM long branches.
+  static typename This::Status
+  arm_branch_common(unsigned int, const Relocate_info<32, big_endian>*,
+		    unsigned char *, const Sized_symbol<32>*,
+		    const Arm_relobj<big_endian>*, unsigned int,
+		    const Symbol_value<32>*, Arm_address, Arm_address, bool);
+
+  // Handle THUMB long branches.
+  static typename This::Status
+  thumb_branch_common(unsigned int, const Relocate_info<32, big_endian>*,
+		      unsigned char *, const Sized_symbol<32>*,
+		      const Arm_relobj<big_endian>*, unsigned int,
+		      const Symbol_value<32>*, Arm_address, Arm_address, bool);
+
  public:
 
+  // Return the branch offset of a 32-bit THUMB branch.
+  static inline int32_t
+  thumb32_branch_offset(uint16_t upper_insn, uint16_t lower_insn)
+  {
+    // We use the Thumb-2 encoding (backwards compatible with Thumb-1)
+    // involving the J1 and J2 bits.
+    uint32_t s = (upper_insn & (1U << 10)) >> 10;
+    uint32_t upper = upper_insn & 0x3ffU;
+    uint32_t lower = lower_insn & 0x7ffU;
+    uint32_t j1 = (lower_insn & (1U << 13)) >> 13;
+    uint32_t j2 = (lower_insn & (1U << 11)) >> 11;
+    uint32_t i1 = j1 ^ s ? 0 : 1;
+    uint32_t i2 = j2 ^ s ? 0 : 1;
+
+    return utils::sign_extend<25>((s << 24) | (i1 << 23) | (i2 << 22)
+				  | (upper << 12) | (lower << 1));
+  }
+
+  // Insert OFFSET to a 32-bit THUMB branch and return the upper instruction.
+  // UPPER_INSN is the original upper instruction of the branch.  Caller is
+  // responsible for overflow checking and BLX offset adjustment.
+  static inline uint16_t
+  thumb32_branch_upper(uint16_t upper_insn, int32_t offset)
+  {
+    uint32_t s = offset < 0 ? 1 : 0;
+    uint32_t bits = static_cast<uint32_t>(offset);
+    return (upper_insn & ~0x7ffU) | ((bits >> 12) & 0x3ffU) | (s << 10);
+  }
+
+  // Insert OFFSET to a 32-bit THUMB branch and return the lower instruction.
+  // LOWER_INSN is the original lower instruction of the branch.  Caller is
+  // responsible for overflow checking and BLX offset adjustment.
+  static inline uint16_t
+  thumb32_branch_lower(uint16_t lower_insn, int32_t offset)
+  {
+    uint32_t s = offset < 0 ? 1 : 0;
+    uint32_t bits = static_cast<uint32_t>(offset);
+    return ((lower_insn & ~0x2fffU)
+            | ((((bits >> 23) & 1) ^ !s) << 13)
+            | ((((bits >> 22) & 1) ^ !s) << 11)
+            | ((bits >> 1) & 0x7ffU));
+  }
+
+  // Return the branch offset of a 32-bit THUMB conditional branch.
+  static inline int32_t
+  thumb32_cond_branch_offset(uint16_t upper_insn, uint16_t lower_insn)
+  {
+    uint32_t s = (upper_insn & 0x0400U) >> 10;
+    uint32_t j1 = (lower_insn & 0x2000U) >> 13;
+    uint32_t j2 = (lower_insn & 0x0800U) >> 11;
+    uint32_t lower = (lower_insn & 0x07ffU);
+    uint32_t upper = (s << 8) | (j2 << 7) | (j1 << 6) | (upper_insn & 0x003fU);
+
+    return utils::sign_extend<21>((upper << 12) | (lower << 1));
+  }
+
+  // Insert OFFSET to a 32-bit THUMB conditional branch and return the upper
+  // instruction.  UPPER_INSN is the original upper instruction of the branch.
+  // Caller is responsible for overflow checking.
+  static inline uint16_t
+  thumb32_cond_branch_upper(uint16_t upper_insn, int32_t offset)
+  {
+    uint32_t s = offset < 0 ? 1 : 0;
+    uint32_t bits = static_cast<uint32_t>(offset);
+    return (upper_insn & 0xfbc0U) | (s << 10) | ((bits & 0x0003f000U) >> 12);
+  }
+
+  // Insert OFFSET to a 32-bit THUMB conditional branch and return the lower
+  // instruction.  LOWER_INSN is the original lower instruction of the branch.
+  // Caller is reponsible for overflow checking.
+  static inline uint16_t
+  thumb32_cond_branch_lower(uint16_t lower_insn, int32_t offset)
+  {
+    uint32_t bits = static_cast<uint32_t>(offset);
+    uint32_t j2 = (bits & 0x00080000U) >> 19;
+    uint32_t j1 = (bits & 0x00040000U) >> 18;
+    uint32_t lo = (bits & 0x00000ffeU) >> 1;
+
+    return (lower_insn & 0xd000U) | (j1 << 13) | (j2 << 11) | lo;
+  }
+
   // R_ARM_ABS8: S + A
   static inline typename This::Status
   abs8(unsigned char *view,
@@ -678,7 +2911,7 @@ class Arm_relocate_functions : public Relocate_functions<32, big_endian>
     Valtype* wv = reinterpret_cast<Valtype*>(view);
     Valtype val = elfcpp::Swap<8, big_endian>::readval(wv);
     Reltype addend = utils::sign_extend<8>(val);
-    Reltype x = This::arm_symbol_value(object, psymval, addend, false);
+    Reltype x = psymval->value(object, addend);
     val = utils::bit_select(val, x, 0xffU);
     elfcpp::Swap<8, big_endian>::writeval(wv, val);
     return (utils::has_signed_unsigned_overflow<8>(x)
@@ -697,7 +2930,7 @@ class Arm_relocate_functions : public Relocate_functions<32, big_endian>
     Valtype* wv = reinterpret_cast<Valtype*>(view);
     Valtype val = elfcpp::Swap<16, big_endian>::readval(wv);
     Reltype addend = (val & 0x7e0U) >> 6;
-    Reltype x = This::arm_symbol_value(object, psymval, addend, false);
+    Reltype x = psymval->value(object, addend);
     val = utils::bit_select(val, x << 6, 0x7e0U);
     elfcpp::Swap<16, big_endian>::writeval(wv, val);
     return (utils::has_overflow<5>(x)
@@ -708,15 +2941,15 @@ class Arm_relocate_functions : public Relocate_functions<32, big_endian>
   // R_ARM_ABS12: S + A
   static inline typename This::Status
   abs12(unsigned char *view,
-       const Sized_relobj<32, big_endian>* object,
-       const Symbol_value<32>* psymval)
+	const Sized_relobj<32, big_endian>* object,
+	const Symbol_value<32>* psymval)
   {
     typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
     typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
     Valtype* wv = reinterpret_cast<Valtype*>(view);
     Valtype val = elfcpp::Swap<32, big_endian>::readval(wv);
     Reltype addend = val & 0x0fffU;
-    Reltype x = This::arm_symbol_value(object, psymval, addend, false);
+    Reltype x = psymval->value(object, addend);
     val = utils::bit_select(val, x, 0x0fffU);
     elfcpp::Swap<32, big_endian>::writeval(wv, val);
     return (utils::has_overflow<12>(x)
@@ -727,15 +2960,15 @@ class Arm_relocate_functions : public Relocate_functions<32, big_endian>
   // R_ARM_ABS16: S + A
   static inline typename This::Status
   abs16(unsigned char *view,
-       const Sized_relobj<32, big_endian>* object,
-       const Symbol_value<32>* psymval)
+	const Sized_relobj<32, big_endian>* object,
+	const Symbol_value<32>* psymval)
   {
     typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
     typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
     Valtype* wv = reinterpret_cast<Valtype*>(view);
     Valtype val = elfcpp::Swap<16, big_endian>::readval(wv);
     Reltype addend = utils::sign_extend<16>(val);
-    Reltype x = This::arm_symbol_value(object, psymval, addend, false);
+    Reltype x = psymval->value(object, addend);
     val = utils::bit_select(val, x, 0xffffU);
     elfcpp::Swap<16, big_endian>::writeval(wv, val);
     return (utils::has_signed_unsigned_overflow<16>(x)
@@ -748,12 +2981,12 @@ class Arm_relocate_functions : public Relocate_functions<32, big_endian>
   abs32(unsigned char *view,
 	const Sized_relobj<32, big_endian>* object,
 	const Symbol_value<32>* psymval,
-	bool has_thumb_bit)
+	Arm_address thumb_bit)
   {
     typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
     Valtype* wv = reinterpret_cast<Valtype*>(view);
     Valtype addend = elfcpp::Swap<32, big_endian>::readval(wv);
-    Valtype x = This::arm_symbol_value(object, psymval, addend, has_thumb_bit);
+    Valtype x = psymval->value(object, addend) | thumb_bit;
     elfcpp::Swap<32, big_endian>::writeval(wv, x);
     return This::STATUS_OKAY;
   }
@@ -763,51 +2996,118 @@ class Arm_relocate_functions : public Relocate_functions<32, big_endian>
   rel32(unsigned char *view,
 	const Sized_relobj<32, big_endian>* object,
 	const Symbol_value<32>* psymval,
-	elfcpp::Elf_types<32>::Elf_Addr address,
-	bool has_thumb_bit)
+	Arm_address address,
+	Arm_address thumb_bit)
   {
     typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
     Valtype* wv = reinterpret_cast<Valtype*>(view);
     Valtype addend = elfcpp::Swap<32, big_endian>::readval(wv);
-    Valtype x = (This::arm_symbol_value(object, psymval, addend, has_thumb_bit) 
-		 - address);
+    Valtype x = (psymval->value(object, addend) | thumb_bit) - address;
     elfcpp::Swap<32, big_endian>::writeval(wv, x);
     return This::STATUS_OKAY;
   }
 
   // R_ARM_THM_CALL: (S + A) | T - P
   static inline typename This::Status
-  thm_call(unsigned char *view,
-	   const Sized_relobj<32, big_endian>* object,
-	   const Symbol_value<32>* psymval,
-	   elfcpp::Elf_types<32>::Elf_Addr address,
-	   bool has_thumb_bit)
+  thm_call(const Relocate_info<32, big_endian>* relinfo, unsigned char *view,
+	   const Sized_symbol<32>* gsym, const Arm_relobj<big_endian>* object,
+	   unsigned int r_sym, const Symbol_value<32>* psymval,
+	   Arm_address address, Arm_address thumb_bit,
+	   bool is_weakly_undefined_without_plt)
+  {
+    return thumb_branch_common(elfcpp::R_ARM_THM_CALL, relinfo, view, gsym,
+			       object, r_sym, psymval, address, thumb_bit,
+			       is_weakly_undefined_without_plt);
+  }
+
+  // R_ARM_THM_JUMP24: (S + A) | T - P
+  static inline typename This::Status
+  thm_jump24(const Relocate_info<32, big_endian>* relinfo, unsigned char *view,
+	     const Sized_symbol<32>* gsym, const Arm_relobj<big_endian>* object,
+	     unsigned int r_sym, const Symbol_value<32>* psymval,
+	     Arm_address address, Arm_address thumb_bit,
+	     bool is_weakly_undefined_without_plt)
+  {
+    return thumb_branch_common(elfcpp::R_ARM_THM_JUMP24, relinfo, view, gsym,
+			       object, r_sym, psymval, address, thumb_bit,
+			       is_weakly_undefined_without_plt);
+  }
+
+  // R_ARM_THM_JUMP24: (S + A) | T - P
+  static typename This::Status
+  thm_jump19(unsigned char *view, const Arm_relobj<big_endian>* object,
+	     const Symbol_value<32>* psymval, Arm_address address,
+	     Arm_address thumb_bit);
+
+  // R_ARM_THM_XPC22: (S + A) | T - P
+  static inline typename This::Status
+  thm_xpc22(const Relocate_info<32, big_endian>* relinfo, unsigned char *view,
+	    const Sized_symbol<32>* gsym, const Arm_relobj<big_endian>* object,
+	    unsigned int r_sym, const Symbol_value<32>* psymval,
+	    Arm_address address, Arm_address thumb_bit,
+	    bool is_weakly_undefined_without_plt)
+  {
+    return thumb_branch_common(elfcpp::R_ARM_THM_XPC22, relinfo, view, gsym,
+			       object, r_sym, psymval, address, thumb_bit,
+			       is_weakly_undefined_without_plt);
+  }
+
+  // R_ARM_THM_JUMP6: S + A  P
+  static inline typename This::Status
+  thm_jump6(unsigned char *view,
+	    const Sized_relobj<32, big_endian>* object,
+	    const Symbol_value<32>* psymval,
+	    Arm_address address)
   {
-    // A thumb call consists of two instructions.
     typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
-    typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
+    typedef typename elfcpp::Swap<16, big_endian>::Valtype Reltype;
     Valtype* wv = reinterpret_cast<Valtype*>(view);
-    Valtype hi = elfcpp::Swap<16, big_endian>::readval(wv);
-    Valtype lo = elfcpp::Swap<16, big_endian>::readval(wv + 1);
-    // Must be a BL instruction. lo == 11111xxxxxxxxxxx.
-    gold_assert((lo & 0xf800) == 0xf800);
-    Reltype addend = utils::sign_extend<23>(((hi & 0x7ff) << 12)
-					   | ((lo & 0x7ff) << 1));
-    Reltype x = (This::arm_symbol_value(object, psymval, addend, has_thumb_bit)
-		 - address);
-
-    // If target has no thumb bit set, we need to either turn the BL
-    // into a BLX (for ARMv5 or above) or generate a stub.
-    if ((x & 1) == 0)
-      {
-	// This only works for ARMv5 and above with interworking enabled.
-	lo &= 0xefff;
-      }
-    hi = utils::bit_select(hi, (x >> 12), 0x7ffU);
-    lo = utils::bit_select(lo, (x >> 1), 0x7ffU);
-    elfcpp::Swap<16, big_endian>::writeval(wv, hi);
-    elfcpp::Swap<16, big_endian>::writeval(wv + 1, lo);
-    return (utils::has_overflow<23>(x)
+    Valtype val = elfcpp::Swap<16, big_endian>::readval(wv);
+    // bit[9]:bit[7:3]:0 (mask: 0x02f8)
+    Reltype addend = (((val & 0x0200) >> 3) | ((val & 0x00f8) >> 2));
+    Reltype x = (psymval->value(object, addend) - address);
+    val = (val & 0xfd07) | ((x  & 0x0040) << 3) | ((val & 0x003e) << 2);
+    elfcpp::Swap<16, big_endian>::writeval(wv, val);
+    // CZB does only forward jumps.
+    return ((x > 0x007e)
+	    ? This::STATUS_OVERFLOW
+	    : This::STATUS_OKAY);
+  }
+
+  // R_ARM_THM_JUMP8: S + A  P
+  static inline typename This::Status
+  thm_jump8(unsigned char *view,
+	    const Sized_relobj<32, big_endian>* object,
+	    const Symbol_value<32>* psymval,
+	    Arm_address address)
+  {
+    typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
+    typedef typename elfcpp::Swap<16, big_endian>::Valtype Reltype;
+    Valtype* wv = reinterpret_cast<Valtype*>(view);
+    Valtype val = elfcpp::Swap<16, big_endian>::readval(wv);
+    Reltype addend = utils::sign_extend<8>((val & 0x00ff) << 1);
+    Reltype x = (psymval->value(object, addend) - address);
+    elfcpp::Swap<16, big_endian>::writeval(wv, (val & 0xff00) | ((x & 0x01fe) >> 1));
+    return (utils::has_overflow<8>(x)
+	    ? This::STATUS_OVERFLOW
+	    : This::STATUS_OKAY);
+  }
+
+  // R_ARM_THM_JUMP11: S + A  P
+  static inline typename This::Status
+  thm_jump11(unsigned char *view,
+	    const Sized_relobj<32, big_endian>* object,
+	    const Symbol_value<32>* psymval,
+	    Arm_address address)
+  {
+    typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
+    typedef typename elfcpp::Swap<16, big_endian>::Valtype Reltype;
+    Valtype* wv = reinterpret_cast<Valtype*>(view);
+    Valtype val = elfcpp::Swap<16, big_endian>::readval(wv);
+    Reltype addend = utils::sign_extend<11>((val & 0x07ff) << 1);
+    Reltype x = (psymval->value(object, addend) - address);
+    elfcpp::Swap<16, big_endian>::writeval(wv, (val & 0xf800) | ((x & 0x0ffe) >> 1));
+    return (utils::has_overflow<11>(x)
 	    ? This::STATUS_OVERFLOW
 	    : This::STATUS_OKAY);
   }
@@ -815,8 +3115,8 @@ class Arm_relocate_functions : public Relocate_functions<32, big_endian>
   // R_ARM_BASE_PREL: B(S) + A - P
   static inline typename This::Status
   base_prel(unsigned char* view,
-	    elfcpp::Elf_types<32>::Elf_Addr origin,
-	    elfcpp::Elf_types<32>::Elf_Addr address)
+	    Arm_address origin,
+	    Arm_address address)
   {
     Base::rel32(view, origin - address);
     return STATUS_OKAY;
@@ -825,7 +3125,7 @@ class Arm_relocate_functions : public Relocate_functions<32, big_endian>
   // R_ARM_BASE_ABS: B(S) + A
   static inline typename This::Status
   base_abs(unsigned char* view,
-	    elfcpp::Elf_types<32>::Elf_Addr origin)
+	   Arm_address origin)
   {
     Base::rel32(view, origin);
     return STATUS_OKAY;
@@ -840,50 +3140,82 @@ class Arm_relocate_functions : public Relocate_functions<32, big_endian>
     return This::STATUS_OKAY;
   }
 
-  // R_ARM_GOT_PREL: GOT(S) + A  P
+  // R_ARM_GOT_PREL: GOT(S) + A - P
   static inline typename This::Status
-  got_prel(unsigned char* view,
-	   typename elfcpp::Swap<32, big_endian>::Valtype got_offset,
-	   elfcpp::Elf_types<32>::Elf_Addr address)
+  got_prel(unsigned char *view,
+	   Arm_address got_entry,
+	   Arm_address address)
   {
-    Base::rel32(view, got_offset - address);
+    Base::rel32(view, got_entry - address);
     return This::STATUS_OKAY;
   }
 
   // R_ARM_PLT32: (S + A) | T - P
   static inline typename This::Status
-  plt32(unsigned char *view,
-	const Sized_relobj<32, big_endian>* object,
+  plt32(const Relocate_info<32, big_endian>* relinfo,
+	unsigned char *view,
+	const Sized_symbol<32>* gsym,
+	const Arm_relobj<big_endian>* object,
+	unsigned int r_sym,
+	const Symbol_value<32>* psymval,
+	Arm_address address,
+	Arm_address thumb_bit,
+	bool is_weakly_undefined_without_plt)
+  {
+    return arm_branch_common(elfcpp::R_ARM_PLT32, relinfo, view, gsym,
+			     object, r_sym, psymval, address, thumb_bit,
+			     is_weakly_undefined_without_plt);
+  }
+
+  // R_ARM_XPC25: (S + A) | T - P
+  static inline typename This::Status
+  xpc25(const Relocate_info<32, big_endian>* relinfo,
+	unsigned char *view,
+	const Sized_symbol<32>* gsym,
+	const Arm_relobj<big_endian>* object,
+	unsigned int r_sym,
 	const Symbol_value<32>* psymval,
-	elfcpp::Elf_types<32>::Elf_Addr address,
-	bool has_thumb_bit)
+	Arm_address address,
+	Arm_address thumb_bit,
+	bool is_weakly_undefined_without_plt)
   {
-    return arm_branch_common<elfcpp::R_ARM_PLT32>(view, object, psymval,
-						  address, has_thumb_bit);
+    return arm_branch_common(elfcpp::R_ARM_XPC25, relinfo, view, gsym,
+			     object, r_sym, psymval, address, thumb_bit,
+			     is_weakly_undefined_without_plt);
   }
 
   // R_ARM_CALL: (S + A) | T - P
   static inline typename This::Status
-  call(unsigned char *view,
-       const Sized_relobj<32, big_endian>* object,
+  call(const Relocate_info<32, big_endian>* relinfo,
+       unsigned char *view,
+       const Sized_symbol<32>* gsym,
+       const Arm_relobj<big_endian>* object,
+       unsigned int r_sym,
        const Symbol_value<32>* psymval,
-       elfcpp::Elf_types<32>::Elf_Addr address,
-       bool has_thumb_bit)
+       Arm_address address,
+       Arm_address thumb_bit,
+       bool is_weakly_undefined_without_plt)
   {
-    return arm_branch_common<elfcpp::R_ARM_CALL>(view, object, psymval,
-						 address, has_thumb_bit);
+    return arm_branch_common(elfcpp::R_ARM_CALL, relinfo, view, gsym,
+			     object, r_sym, psymval, address, thumb_bit,
+			     is_weakly_undefined_without_plt);
   }
 
   // R_ARM_JUMP24: (S + A) | T - P
   static inline typename This::Status
-  jump24(unsigned char *view,
-	 const Sized_relobj<32, big_endian>* object,
+  jump24(const Relocate_info<32, big_endian>* relinfo,
+	 unsigned char *view,
+	 const Sized_symbol<32>* gsym,
+	 const Arm_relobj<big_endian>* object,
+	 unsigned int r_sym,
 	 const Symbol_value<32>* psymval,
-	 elfcpp::Elf_types<32>::Elf_Addr address,
-	 bool has_thumb_bit)
+	 Arm_address address,
+	 Arm_address thumb_bit,
+	 bool is_weakly_undefined_without_plt)
   {
-    return arm_branch_common<elfcpp::R_ARM_JUMP24>(view, object, psymval,
-						   address, has_thumb_bit);
+    return arm_branch_common(elfcpp::R_ARM_JUMP24, relinfo, view, gsym,
+			     object, r_sym, psymval, address, thumb_bit,
+			     is_weakly_undefined_without_plt);
   }
 
   // R_ARM_PREL: (S + A) | T - P
@@ -891,192 +3223,785 @@ class Arm_relocate_functions : public Relocate_functions<32, big_endian>
   prel31(unsigned char *view,
 	 const Sized_relobj<32, big_endian>* object,
 	 const Symbol_value<32>* psymval,
-	 elfcpp::Elf_types<32>::Elf_Addr address,
-	 bool has_thumb_bit)
+	 Arm_address address,
+	 Arm_address thumb_bit)
   {
     typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
     Valtype* wv = reinterpret_cast<Valtype*>(view);
     Valtype val = elfcpp::Swap<32, big_endian>::readval(wv);
     Valtype addend = utils::sign_extend<31>(val);
-    Valtype x = (This::arm_symbol_value(object, psymval, addend, has_thumb_bit)
-		 - address);
+    Valtype x = (psymval->value(object, addend) | thumb_bit) - address;
     val = utils::bit_select(val, x, 0x7fffffffU);
     elfcpp::Swap<32, big_endian>::writeval(wv, val);
     return (utils::has_overflow<31>(x) ?
 	    This::STATUS_OVERFLOW : This::STATUS_OKAY);
   }
 
-  // R_ARM_MOVW_ABS_NC: (S + A) | T
-  static inline typename This::Status 
-  movw_abs_nc(unsigned char *view,
-	      const Sized_relobj<32, big_endian>* object,
-	      const Symbol_value<32>* psymval,
-	      bool has_thumb_bit)
+  // R_ARM_MOVW_ABS_NC: (S + A) | T	(relative address base is )
+  // R_ARM_MOVW_PREL_NC: (S + A) | T - P
+  // R_ARM_MOVW_BREL_NC: ((S + A) | T) - B(S)
+  // R_ARM_MOVW_BREL: ((S + A) | T) - B(S)
+  static inline typename This::Status
+  movw(unsigned char* view,
+       const Sized_relobj<32, big_endian>* object,
+       const Symbol_value<32>* psymval,
+       Arm_address relative_address_base,
+       Arm_address thumb_bit,
+       bool check_overflow)
   {
     typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
     Valtype* wv = reinterpret_cast<Valtype*>(view);
     Valtype val = elfcpp::Swap<32, big_endian>::readval(wv);
-    Valtype addend =  This::extract_arm_movw_movt_addend(val);
-    Valtype x = This::arm_symbol_value(object, psymval, addend, has_thumb_bit);
+    Valtype addend = This::extract_arm_movw_movt_addend(val);
+    Valtype x = ((psymval->value(object, addend) | thumb_bit)
+		 - relative_address_base);
     val = This::insert_val_arm_movw_movt(val, x);
     elfcpp::Swap<32, big_endian>::writeval(wv, val);
-    return This::STATUS_OKAY;
+    return ((check_overflow && utils::has_overflow<16>(x))
+	    ? This::STATUS_OVERFLOW
+	    : This::STATUS_OKAY);
   }
 
-  // R_ARM_MOVT_ABS: S + A
+  // R_ARM_MOVT_ABS: S + A	(relative address base is 0)
+  // R_ARM_MOVT_PREL: S + A - P
+  // R_ARM_MOVT_BREL: S + A - B(S)
   static inline typename This::Status
-  movt_abs(unsigned char *view,
-	   const Sized_relobj<32, big_endian>* object,
-           const Symbol_value<32>* psymval)
+  movt(unsigned char* view,
+       const Sized_relobj<32, big_endian>* object,
+       const Symbol_value<32>* psymval,
+       Arm_address relative_address_base)
   {
     typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
     Valtype* wv = reinterpret_cast<Valtype*>(view);
     Valtype val = elfcpp::Swap<32, big_endian>::readval(wv);
     Valtype addend = This::extract_arm_movw_movt_addend(val);
-    Valtype x = This::arm_symbol_value(object, psymval, addend, 0) >> 16;
+    Valtype x = (psymval->value(object, addend) - relative_address_base) >> 16;
     val = This::insert_val_arm_movw_movt(val, x);
     elfcpp::Swap<32, big_endian>::writeval(wv, val);
+    // FIXME: IHI0044D says that we should check for overflow.
     return This::STATUS_OKAY;
   }
 
-  //  R_ARM_THM_MOVW_ABS_NC: S + A | T
-  static inline typename This::Status 
-  thm_movw_abs_nc(unsigned char *view,
-	          const Sized_relobj<32, big_endian>* object,
-	          const Symbol_value<32>* psymval,
-	          bool has_thumb_bit)
+  // R_ARM_THM_MOVW_ABS_NC: S + A | T		(relative_address_base is 0)
+  // R_ARM_THM_MOVW_PREL_NC: (S + A) | T - P
+  // R_ARM_THM_MOVW_BREL_NC: ((S + A) | T) - B(S)
+  // R_ARM_THM_MOVW_BREL: ((S + A) | T) - B(S)
+  static inline typename This::Status
+  thm_movw(unsigned char *view,
+	   const Sized_relobj<32, big_endian>* object,
+	   const Symbol_value<32>* psymval,
+	   Arm_address relative_address_base,
+	   Arm_address thumb_bit,
+	   bool check_overflow)
   {
     typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
     typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
     Valtype* wv = reinterpret_cast<Valtype*>(view);
-    Reltype val = ((elfcpp::Swap<16, big_endian>::readval(wv) << 16)
-		   | elfcpp::Swap<16, big_endian>::readval(wv + 1));
-    Reltype addend = extract_thumb_movw_movt_addend(val);
-    Reltype x = This::arm_symbol_value(object, psymval, addend, has_thumb_bit);
+    Reltype val = (elfcpp::Swap<16, big_endian>::readval(wv) << 16)
+		  | elfcpp::Swap<16, big_endian>::readval(wv + 1);
+    Reltype addend = This::extract_thumb_movw_movt_addend(val);
+    Reltype x =
+      (psymval->value(object, addend) | thumb_bit) - relative_address_base;
     val = This::insert_val_thumb_movw_movt(val, x);
     elfcpp::Swap<16, big_endian>::writeval(wv, val >> 16);
     elfcpp::Swap<16, big_endian>::writeval(wv + 1, val & 0xffff);
-    return This::STATUS_OKAY;
+    return ((check_overflow && utils::has_overflow<16>(x))
+    	    ? This::STATUS_OVERFLOW
+	    : This::STATUS_OKAY);
   }
 
-  //  R_ARM_THM_MOVT_ABS: S + A
-  static inline typename This::Status 
-  thm_movt_abs(unsigned char *view,
-	       const Sized_relobj<32, big_endian>* object,
-	       const Symbol_value<32>* psymval)
+  // R_ARM_THM_MOVT_ABS: S + A		(relative address base is 0)
+  // R_ARM_THM_MOVT_PREL: S + A - P
+  // R_ARM_THM_MOVT_BREL: S + A - B(S)
+  static inline typename This::Status
+  thm_movt(unsigned char* view,
+	   const Sized_relobj<32, big_endian>* object,
+	   const Symbol_value<32>* psymval,
+	   Arm_address relative_address_base)
   {
     typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
     typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
     Valtype* wv = reinterpret_cast<Valtype*>(view);
-    Reltype val = ((elfcpp::Swap<16, big_endian>::readval(wv) << 16)
-		   | elfcpp::Swap<16, big_endian>::readval(wv + 1));
+    Reltype val = (elfcpp::Swap<16, big_endian>::readval(wv) << 16)
+		  | elfcpp::Swap<16, big_endian>::readval(wv + 1);
     Reltype addend = This::extract_thumb_movw_movt_addend(val);
-    Reltype x = This::arm_symbol_value(object, psymval, addend, 0) >> 16;
+    Reltype x = (psymval->value(object, addend) - relative_address_base) >> 16;
     val = This::insert_val_thumb_movw_movt(val, x);
     elfcpp::Swap<16, big_endian>::writeval(wv, val >> 16);
     elfcpp::Swap<16, big_endian>::writeval(wv + 1, val & 0xffff);
     return This::STATUS_OKAY;
   }
 
-  // R_ARM_MOVW_PREL_NC: (S + A) | T - P
+  // R_ARM_THM_ALU_PREL_11_0: ((S + A) | T) - Pa (Thumb32)
   static inline typename This::Status
-  movw_prel_nc(unsigned char *view,
-	       const Sized_relobj<32, big_endian>* object,
-	       const Symbol_value<32>* psymval,
-	       elfcpp::Elf_types<32>::Elf_Addr address,
-	       bool has_thumb_bit)
+  thm_alu11(unsigned char* view,
+	    const Sized_relobj<32, big_endian>* object,
+	    const Symbol_value<32>* psymval,
+	    Arm_address address,
+	    Arm_address thumb_bit)
   {
+    typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
+    typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
+    Valtype* wv = reinterpret_cast<Valtype*>(view);
+    Reltype insn = (elfcpp::Swap<16, big_endian>::readval(wv) << 16)
+		   | elfcpp::Swap<16, big_endian>::readval(wv + 1);
+
+    //	      f e d c b|a|9|8 7 6 5|4|3 2 1 0||f|e d c|b a 9 8|7 6 5 4 3 2 1 0
+    // -----------------------------------------------------------------------
+    // ADD{S} 1 1 1 1 0|i|0|1 0 0 0|S|1 1 0 1||0|imm3 |Rd     |imm8
+    // ADDW   1 1 1 1 0|i|1|0 0 0 0|0|1 1 0 1||0|imm3 |Rd     |imm8
+    // ADR[+] 1 1 1 1 0|i|1|0 0 0 0|0|1 1 1 1||0|imm3 |Rd     |imm8
+    // SUB{S} 1 1 1 1 0|i|0|1 1 0 1|S|1 1 0 1||0|imm3 |Rd     |imm8
+    // SUBW   1 1 1 1 0|i|1|0 1 0 1|0|1 1 0 1||0|imm3 |Rd     |imm8
+    // ADR[-] 1 1 1 1 0|i|1|0 1 0 1|0|1 1 1 1||0|imm3 |Rd     |imm8
+
+    // Determine a sign for the addend.
+    const int sign = ((insn & 0xf8ef0000) == 0xf0ad0000
+		      || (insn & 0xf8ef0000) == 0xf0af0000) ? -1 : 1;
+    // Thumb2 addend encoding:
+    // imm12 := i | imm3 | imm8
+    int32_t addend = (insn & 0xff)
+		     | ((insn & 0x00007000) >> 4)
+		     | ((insn & 0x04000000) >> 15);
+    // Apply a sign to the added.
+    addend *= sign;
+
+    int32_t x = (psymval->value(object, addend) | thumb_bit)
+		- (address & 0xfffffffc);
+    Reltype val = abs(x);
+    // Mask out the value and a distinct part of the ADD/SUB opcode
+    // (bits 7:5 of opword).
+    insn = (insn & 0xfb0f8f00)
+	   | (val & 0xff)
+	   | ((val & 0x700) << 4)
+	   | ((val & 0x800) << 15);
+    // Set the opcode according to whether the value to go in the
+    // place is negative.
+    if (x < 0)
+      insn |= 0x00a00000;
+
+    elfcpp::Swap<16, big_endian>::writeval(wv, insn >> 16);
+    elfcpp::Swap<16, big_endian>::writeval(wv + 1, insn & 0xffff);
+    return ((val > 0xfff) ?
+    	    This::STATUS_OVERFLOW : This::STATUS_OKAY);
+  }
+
+  // R_ARM_THM_PC8: S + A - Pa (Thumb)
+  static inline typename This::Status
+  thm_pc8(unsigned char* view,
+	  const Sized_relobj<32, big_endian>* object,
+	  const Symbol_value<32>* psymval,
+	  Arm_address address)
+  {
+    typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
+    typedef typename elfcpp::Swap<16, big_endian>::Valtype Reltype;
+    Valtype* wv = reinterpret_cast<Valtype*>(view);
+    Valtype insn = elfcpp::Swap<16, big_endian>::readval(wv);
+    Reltype addend = ((insn & 0x00ff) << 2);
+    int32_t x = (psymval->value(object, addend) - (address & 0xfffffffc));
+    Reltype val = abs(x);
+    insn = (insn & 0xff00) | ((val & 0x03fc) >> 2);
+
+    elfcpp::Swap<16, big_endian>::writeval(wv, insn);
+    return ((val > 0x03fc)
+	    ? This::STATUS_OVERFLOW
+	    : This::STATUS_OKAY);
+  }
+
+  // R_ARM_THM_PC12: S + A - Pa (Thumb32)
+  static inline typename This::Status
+  thm_pc12(unsigned char* view,
+	   const Sized_relobj<32, big_endian>* object,
+	   const Symbol_value<32>* psymval,
+	   Arm_address address)
+  {
+    typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
+    typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
+    Valtype* wv = reinterpret_cast<Valtype*>(view);
+    Reltype insn = (elfcpp::Swap<16, big_endian>::readval(wv) << 16)
+		   | elfcpp::Swap<16, big_endian>::readval(wv + 1);
+    // Determine a sign for the addend (positive if the U bit is 1).
+    const int sign = (insn & 0x00800000) ? 1 : -1;
+    int32_t addend = (insn & 0xfff);
+    // Apply a sign to the added.
+    addend *= sign;
+
+    int32_t x = (psymval->value(object, addend) - (address & 0xfffffffc));
+    Reltype val = abs(x);
+    // Mask out and apply the value and the U bit.
+    insn = (insn & 0xff7ff000) | (val & 0xfff);
+    // Set the U bit according to whether the value to go in the
+    // place is positive.
+    if (x >= 0)
+      insn |= 0x00800000;
+
+    elfcpp::Swap<16, big_endian>::writeval(wv, insn >> 16);
+    elfcpp::Swap<16, big_endian>::writeval(wv + 1, insn & 0xffff);
+    return ((val > 0xfff) ?
+    	    This::STATUS_OVERFLOW : This::STATUS_OKAY);
+  }
+
+  // R_ARM_V4BX
+  static inline typename This::Status
+  v4bx(const Relocate_info<32, big_endian>* relinfo,
+       unsigned char *view,
+       const Arm_relobj<big_endian>* object,
+       const Arm_address address,
+       const bool is_interworking)
+  {
+
     typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
     Valtype* wv = reinterpret_cast<Valtype*>(view);
     Valtype val = elfcpp::Swap<32, big_endian>::readval(wv);
-    Valtype addend = This::extract_arm_movw_movt_addend(val);
-    Valtype x = (This::arm_symbol_value(object, psymval, addend, has_thumb_bit)
-                 - address);
-    val = This::insert_val_arm_movw_movt(val, x);
+
+    // Ensure that we have a BX instruction.
+    gold_assert((val & 0x0ffffff0) == 0x012fff10);
+    const uint32_t reg = (val & 0xf);
+    if (is_interworking && reg != 0xf)
+      {
+	Stub_table<big_endian>* stub_table =
+	    object->stub_table(relinfo->data_shndx);
+	gold_assert(stub_table != NULL);
+
+	Arm_v4bx_stub* stub = stub_table->find_arm_v4bx_stub(reg);
+	gold_assert(stub != NULL);
+
+	int32_t veneer_address =
+	    stub_table->address() + stub->offset() - 8 - address;
+	gold_assert((veneer_address <= ARM_MAX_FWD_BRANCH_OFFSET)
+		    && (veneer_address >= ARM_MAX_BWD_BRANCH_OFFSET));
+	// Replace with a branch to veneer (B <addr>)
+	val = (val & 0xf0000000) | 0x0a000000
+	      | ((veneer_address >> 2) & 0x00ffffff);
+      }
+    else
+      {
+	// Preserve Rm (lowest four bits) and the condition code
+	// (highest four bits). Other bits encode MOV PC,Rm.
+	val = (val & 0xf000000f) | 0x01a0f000;
+      }
     elfcpp::Swap<32, big_endian>::writeval(wv, val);
     return This::STATUS_OKAY;
   }
 
-  // R_ARM_MOVT_PREL: S + A - P
+  // R_ARM_ALU_PC_G0_NC: ((S + A) | T) - P
+  // R_ARM_ALU_PC_G0:    ((S + A) | T) - P
+  // R_ARM_ALU_PC_G1_NC: ((S + A) | T) - P
+  // R_ARM_ALU_PC_G1:    ((S + A) | T) - P
+  // R_ARM_ALU_PC_G2:    ((S + A) | T) - P
+  // R_ARM_ALU_SB_G0_NC: ((S + A) | T) - B(S)
+  // R_ARM_ALU_SB_G0:    ((S + A) | T) - B(S)
+  // R_ARM_ALU_SB_G1_NC: ((S + A) | T) - B(S)
+  // R_ARM_ALU_SB_G1:    ((S + A) | T) - B(S)
+  // R_ARM_ALU_SB_G2:    ((S + A) | T) - B(S)
   static inline typename This::Status
-  movt_prel(unsigned char *view,
-	    const Sized_relobj<32, big_endian>* object,
-	    const Symbol_value<32>* psymval,
-            elfcpp::Elf_types<32>::Elf_Addr address)
+  arm_grp_alu(unsigned char* view,
+	const Sized_relobj<32, big_endian>* object,
+	const Symbol_value<32>* psymval,
+	const int group,
+	Arm_address address,
+	Arm_address thumb_bit,
+	bool check_overflow)
   {
+    gold_assert(group >= 0 && group < 3);
     typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
     Valtype* wv = reinterpret_cast<Valtype*>(view);
-    Valtype val = elfcpp::Swap<32, big_endian>::readval(wv);
-    Valtype addend = This::extract_arm_movw_movt_addend(val);
-    Valtype x = (This::arm_symbol_value(object, psymval, addend, 0)
-                 - address) >> 16;
-    val = This::insert_val_arm_movw_movt(val, x);
-    elfcpp::Swap<32, big_endian>::writeval(wv, val);
+    Valtype insn = elfcpp::Swap<32, big_endian>::readval(wv);
+
+    // ALU group relocations are allowed only for the ADD/SUB instructions.
+    // (0x00800000 - ADD, 0x00400000 - SUB)
+    const Valtype opcode = insn & 0x01e00000;
+    if (opcode != 0x00800000 && opcode != 0x00400000)
+      return This::STATUS_BAD_RELOC;
+
+    // Determine a sign for the addend.
+    const int sign = (opcode == 0x00800000) ? 1 : -1;
+    // shifter = rotate_imm * 2
+    const uint32_t shifter = (insn & 0xf00) >> 7;
+    // Initial addend value.
+    int32_t addend = insn & 0xff;
+    // Rotate addend right by shifter.
+    addend = (addend >> shifter) | (addend << (32 - shifter));
+    // Apply a sign to the added.
+    addend *= sign;
+
+    int32_t x = ((psymval->value(object, addend) | thumb_bit) - address);
+    Valtype gn = Arm_relocate_functions::calc_grp_gn(abs(x), group);
+    // Check for overflow if required
+    if (check_overflow
+	&& (Arm_relocate_functions::calc_grp_residual(abs(x), group) != 0))
+      return This::STATUS_OVERFLOW;
+
+    // Mask out the value and the ADD/SUB part of the opcode; take care
+    // not to destroy the S bit.
+    insn &= 0xff1ff000;
+    // Set the opcode according to whether the value to go in the
+    // place is negative.
+    insn |= ((x < 0) ? 0x00400000 : 0x00800000);
+    // Encode the offset (encoded Gn).
+    insn |= gn;
+
+    elfcpp::Swap<32, big_endian>::writeval(wv, insn);
     return This::STATUS_OKAY;
   }
 
-  // R_ARM_THM_MOVW_PREL_NC: (S + A) | T - P
+  // R_ARM_LDR_PC_G0: S + A - P
+  // R_ARM_LDR_PC_G1: S + A - P
+  // R_ARM_LDR_PC_G2: S + A - P
+  // R_ARM_LDR_SB_G0: S + A - B(S)
+  // R_ARM_LDR_SB_G1: S + A - B(S)
+  // R_ARM_LDR_SB_G2: S + A - B(S)
   static inline typename This::Status
-  thm_movw_prel_nc(unsigned char *view,
-	           const Sized_relobj<32, big_endian>* object,
-	           const Symbol_value<32>* psymval,
-	           elfcpp::Elf_types<32>::Elf_Addr address,
-	           bool has_thumb_bit)
+  arm_grp_ldr(unsigned char* view,
+	const Sized_relobj<32, big_endian>* object,
+	const Symbol_value<32>* psymval,
+	const int group,
+	Arm_address address)
   {
-    typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
-    typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
+    gold_assert(group >= 0 && group < 3);
+    typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
     Valtype* wv = reinterpret_cast<Valtype*>(view);
-    Reltype val = (elfcpp::Swap<16, big_endian>::readval(wv) << 16)
-		  | elfcpp::Swap<16, big_endian>::readval(wv + 1);
-    Reltype addend = This::extract_thumb_movw_movt_addend(val);
-    Reltype x = (This::arm_symbol_value(object, psymval, addend, has_thumb_bit)
-                 - address);
-    val = This::insert_val_thumb_movw_movt(val, x);
-    elfcpp::Swap<16, big_endian>::writeval(wv, val >> 16);
-    elfcpp::Swap<16, big_endian>::writeval(wv + 1, val & 0xffff);
+    Valtype insn = elfcpp::Swap<32, big_endian>::readval(wv);
+
+    const int sign = (insn & 0x00800000) ? 1 : -1;
+    int32_t addend = (insn & 0xfff) * sign;
+    int32_t x = (psymval->value(object, addend) - address);
+    // Calculate the relevant G(n-1) value to obtain this stage residual.
+    Valtype residual =
+	Arm_relocate_functions::calc_grp_residual(abs(x), group - 1);
+    if (residual >= 0x1000)
+      return This::STATUS_OVERFLOW;
+
+    // Mask out the value and U bit.
+    insn &= 0xff7ff000;
+    // Set the U bit for non-negative values.
+    if (x >= 0)
+      insn |= 0x00800000;
+    insn |= residual;
+
+    elfcpp::Swap<32, big_endian>::writeval(wv, insn);
     return This::STATUS_OKAY;
   }
 
-  // R_ARM_THM_MOVT_PREL: S + A - P
+  // R_ARM_LDRS_PC_G0: S + A - P
+  // R_ARM_LDRS_PC_G1: S + A - P
+  // R_ARM_LDRS_PC_G2: S + A - P
+  // R_ARM_LDRS_SB_G0: S + A - B(S)
+  // R_ARM_LDRS_SB_G1: S + A - B(S)
+  // R_ARM_LDRS_SB_G2: S + A - B(S)
   static inline typename This::Status
-  thm_movt_prel(unsigned char *view,
-	        const Sized_relobj<32, big_endian>* object,
-	        const Symbol_value<32>* psymval,
-	        elfcpp::Elf_types<32>::Elf_Addr address)
+  arm_grp_ldrs(unsigned char* view,
+	const Sized_relobj<32, big_endian>* object,
+	const Symbol_value<32>* psymval,
+	const int group,
+	Arm_address address)
   {
-    typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
-    typedef typename elfcpp::Swap<32, big_endian>::Valtype Reltype;
+    gold_assert(group >= 0 && group < 3);
+    typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
     Valtype* wv = reinterpret_cast<Valtype*>(view);
-    Reltype val = (elfcpp::Swap<16, big_endian>::readval(wv) << 16)
-		  | elfcpp::Swap<16, big_endian>::readval(wv + 1);
-    Reltype addend = This::extract_thumb_movw_movt_addend(val);
-    Reltype x = (This::arm_symbol_value(object, psymval, addend, 0)
-                 - address) >> 16;
-    val = This::insert_val_thumb_movw_movt(val, x);
-    elfcpp::Swap<16, big_endian>::writeval(wv, val >> 16);
-    elfcpp::Swap<16, big_endian>::writeval(wv + 1, val & 0xffff);
+    Valtype insn = elfcpp::Swap<32, big_endian>::readval(wv);
+
+    const int sign = (insn & 0x00800000) ? 1 : -1;
+    int32_t addend = (((insn & 0xf00) >> 4) + (insn & 0xf)) * sign;
+    int32_t x = (psymval->value(object, addend) - address);
+    // Calculate the relevant G(n-1) value to obtain this stage residual.
+    Valtype residual =
+	Arm_relocate_functions::calc_grp_residual(abs(x), group - 1);
+   if (residual >= 0x100)
+      return This::STATUS_OVERFLOW;
+
+    // Mask out the value and U bit.
+    insn &= 0xff7ff0f0;
+    // Set the U bit for non-negative values.
+    if (x >= 0)
+      insn |= 0x00800000;
+    insn |= ((residual & 0xf0) << 4) | (residual & 0xf);
+
+    elfcpp::Swap<32, big_endian>::writeval(wv, insn);
+    return This::STATUS_OKAY;
+  }
+
+  // R_ARM_LDC_PC_G0: S + A - P
+  // R_ARM_LDC_PC_G1: S + A - P
+  // R_ARM_LDC_PC_G2: S + A - P
+  // R_ARM_LDC_SB_G0: S + A - B(S)
+  // R_ARM_LDC_SB_G1: S + A - B(S)
+  // R_ARM_LDC_SB_G2: S + A - B(S)
+  static inline typename This::Status
+  arm_grp_ldc(unsigned char* view,
+      const Sized_relobj<32, big_endian>* object,
+      const Symbol_value<32>* psymval,
+      const int group,
+      Arm_address address)
+  {
+    gold_assert(group >= 0 && group < 3);
+    typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
+    Valtype* wv = reinterpret_cast<Valtype*>(view);
+    Valtype insn = elfcpp::Swap<32, big_endian>::readval(wv);
+
+    const int sign = (insn & 0x00800000) ? 1 : -1;
+    int32_t addend = ((insn & 0xff) << 2) * sign;
+    int32_t x = (psymval->value(object, addend) - address);
+    // Calculate the relevant G(n-1) value to obtain this stage residual.
+    Valtype residual =
+      Arm_relocate_functions::calc_grp_residual(abs(x), group - 1);
+    if ((residual & 0x3) != 0 || residual >= 0x400)
+      return This::STATUS_OVERFLOW;
+
+    // Mask out the value and U bit.
+    insn &= 0xff7fff00;
+    // Set the U bit for non-negative values.
+    if (x >= 0)
+      insn |= 0x00800000;
+    insn |= (residual >> 2);
+
+    elfcpp::Swap<32, big_endian>::writeval(wv, insn);
     return This::STATUS_OKAY;
   }
 };
 
+// Relocate ARM long branches.  This handles relocation types
+// R_ARM_CALL, R_ARM_JUMP24, R_ARM_PLT32 and R_ARM_XPC25.
+// If IS_WEAK_UNDEFINED_WITH_PLT is true.  The target symbol is weakly
+// undefined and we do not use PLT in this relocation.  In such a case,
+// the branch is converted into an NOP.
+
+template<bool big_endian>
+typename Arm_relocate_functions<big_endian>::Status
+Arm_relocate_functions<big_endian>::arm_branch_common(
+    unsigned int r_type,
+    const Relocate_info<32, big_endian>* relinfo,
+    unsigned char *view,
+    const Sized_symbol<32>* gsym,
+    const Arm_relobj<big_endian>* object,
+    unsigned int r_sym,
+    const Symbol_value<32>* psymval,
+    Arm_address address,
+    Arm_address thumb_bit,
+    bool is_weakly_undefined_without_plt)
+{
+  typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
+  Valtype* wv = reinterpret_cast<Valtype*>(view);
+  Valtype val = elfcpp::Swap<32, big_endian>::readval(wv);
+     
+  bool insn_is_b = (((val >> 28) & 0xf) <= 0xe)
+	            && ((val & 0x0f000000UL) == 0x0a000000UL);
+  bool insn_is_uncond_bl = (val & 0xff000000UL) == 0xeb000000UL;
+  bool insn_is_cond_bl = (((val >> 28) & 0xf) < 0xe)
+			  && ((val & 0x0f000000UL) == 0x0b000000UL);
+  bool insn_is_blx = (val & 0xfe000000UL) == 0xfa000000UL;
+  bool insn_is_any_branch = (val & 0x0e000000UL) == 0x0a000000UL;
+
+  // Check that the instruction is valid.
+  if (r_type == elfcpp::R_ARM_CALL)
+    {
+      if (!insn_is_uncond_bl && !insn_is_blx)
+	return This::STATUS_BAD_RELOC;
+    }
+  else if (r_type == elfcpp::R_ARM_JUMP24)
+    {
+      if (!insn_is_b && !insn_is_cond_bl)
+	return This::STATUS_BAD_RELOC;
+    }
+  else if (r_type == elfcpp::R_ARM_PLT32)
+    {
+      if (!insn_is_any_branch)
+	return This::STATUS_BAD_RELOC;
+    }
+  else if (r_type == elfcpp::R_ARM_XPC25)
+    {
+      // FIXME: AAELF document IH0044C does not say much about it other
+      // than it being obsolete.
+      if (!insn_is_any_branch)
+	return This::STATUS_BAD_RELOC;
+    }
+  else
+    gold_unreachable();
+
+  // A branch to an undefined weak symbol is turned into a jump to
+  // the next instruction unless a PLT entry will be created.
+  // Do the same for local undefined symbols.
+  // The jump to the next instruction is optimized as a NOP depending
+  // on the architecture.
+  const Target_arm<big_endian>* arm_target =
+    Target_arm<big_endian>::default_target();
+  if (is_weakly_undefined_without_plt)
+    {
+      Valtype cond = val & 0xf0000000U;
+      if (arm_target->may_use_arm_nop())
+	val = cond | 0x0320f000;
+      else
+	val = cond | 0x01a00000;	// Using pre-UAL nop: mov r0, r0.
+      elfcpp::Swap<32, big_endian>::writeval(wv, val);
+      return This::STATUS_OKAY;
+    }
+ 
+  Valtype addend = utils::sign_extend<26>(val << 2);
+  Valtype branch_target = psymval->value(object, addend);
+  int32_t branch_offset = branch_target - address;
+
+  // We need a stub if the branch offset is too large or if we need
+  // to switch mode.
+  bool may_use_blx = arm_target->may_use_blx();
+  Reloc_stub* stub = NULL;
+  if ((branch_offset > ARM_MAX_FWD_BRANCH_OFFSET)
+      || (branch_offset < ARM_MAX_BWD_BRANCH_OFFSET)
+      || ((thumb_bit != 0) && !(may_use_blx && r_type == elfcpp::R_ARM_CALL)))
+    {
+      Stub_type stub_type =
+	Reloc_stub::stub_type_for_reloc(r_type, address, branch_target,
+					(thumb_bit != 0));
+      if (stub_type != arm_stub_none)
+	{
+	  Stub_table<big_endian>* stub_table =
+	    object->stub_table(relinfo->data_shndx);
+	  gold_assert(stub_table != NULL);
+
+	  Reloc_stub::Key stub_key(stub_type, gsym, object, r_sym, addend);
+	  stub = stub_table->find_reloc_stub(stub_key);
+	  gold_assert(stub != NULL);
+	  thumb_bit = stub->stub_template()->entry_in_thumb_mode() ? 1 : 0;
+	  branch_target = stub_table->address() + stub->offset() + addend;
+	  branch_offset = branch_target - address;
+	  gold_assert((branch_offset <= ARM_MAX_FWD_BRANCH_OFFSET)
+		      && (branch_offset >= ARM_MAX_BWD_BRANCH_OFFSET));
+	}
+    }
+
+  // At this point, if we still need to switch mode, the instruction
+  // must either be a BLX or a BL that can be converted to a BLX.
+  if (thumb_bit != 0)
+    {
+      // Turn BL to BLX.
+      gold_assert(may_use_blx && r_type == elfcpp::R_ARM_CALL);
+      val = (val & 0xffffff) | 0xfa000000 | ((branch_offset & 2) << 23);
+    }
+
+  val = utils::bit_select(val, (branch_offset >> 2), 0xffffffUL);
+  elfcpp::Swap<32, big_endian>::writeval(wv, val);
+  return (utils::has_overflow<26>(branch_offset)
+	  ? This::STATUS_OVERFLOW : This::STATUS_OKAY);
+}
+
+// Relocate THUMB long branches.  This handles relocation types
+// R_ARM_THM_CALL, R_ARM_THM_JUMP24 and R_ARM_THM_XPC22.
+// If IS_WEAK_UNDEFINED_WITH_PLT is true.  The target symbol is weakly
+// undefined and we do not use PLT in this relocation.  In such a case,
+// the branch is converted into an NOP.
+
+template<bool big_endian>
+typename Arm_relocate_functions<big_endian>::Status
+Arm_relocate_functions<big_endian>::thumb_branch_common(
+    unsigned int r_type,
+    const Relocate_info<32, big_endian>* relinfo,
+    unsigned char *view,
+    const Sized_symbol<32>* gsym,
+    const Arm_relobj<big_endian>* object,
+    unsigned int r_sym,
+    const Symbol_value<32>* psymval,
+    Arm_address address,
+    Arm_address thumb_bit,
+    bool is_weakly_undefined_without_plt)
+{
+  typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
+  Valtype* wv = reinterpret_cast<Valtype*>(view);
+  uint32_t upper_insn = elfcpp::Swap<16, big_endian>::readval(wv);
+  uint32_t lower_insn = elfcpp::Swap<16, big_endian>::readval(wv + 1);
+
+  // FIXME: These tests are too loose and do not take THUMB/THUMB-2 difference
+  // into account.
+  bool is_bl_insn = (lower_insn & 0x1000U) == 0x1000U;
+  bool is_blx_insn = (lower_insn & 0x1000U) == 0x0000U;
+     
+  // Check that the instruction is valid.
+  if (r_type == elfcpp::R_ARM_THM_CALL)
+    {
+      if (!is_bl_insn && !is_blx_insn)
+	return This::STATUS_BAD_RELOC;
+    }
+  else if (r_type == elfcpp::R_ARM_THM_JUMP24)
+    {
+      // This cannot be a BLX.
+      if (!is_bl_insn)
+	return This::STATUS_BAD_RELOC;
+    }
+  else if (r_type == elfcpp::R_ARM_THM_XPC22)
+    {
+      // Check for Thumb to Thumb call.
+      if (!is_blx_insn)
+	return This::STATUS_BAD_RELOC;
+      if (thumb_bit != 0)
+	{
+	  gold_warning(_("%s: Thumb BLX instruction targets "
+			 "thumb function '%s'."),
+			 object->name().c_str(),
+			 (gsym ? gsym->name() : "(local)")); 
+	  // Convert BLX to BL.
+	  lower_insn |= 0x1000U;
+	}
+    }
+  else
+    gold_unreachable();
+
+  // A branch to an undefined weak symbol is turned into a jump to
+  // the next instruction unless a PLT entry will be created.
+  // The jump to the next instruction is optimized as a NOP.W for
+  // Thumb-2 enabled architectures.
+  const Target_arm<big_endian>* arm_target =
+    Target_arm<big_endian>::default_target();
+  if (is_weakly_undefined_without_plt)
+    {
+      if (arm_target->may_use_thumb2_nop())
+	{
+	  elfcpp::Swap<16, big_endian>::writeval(wv, 0xf3af);
+	  elfcpp::Swap<16, big_endian>::writeval(wv + 1, 0x8000);
+	}
+      else
+	{
+	  elfcpp::Swap<16, big_endian>::writeval(wv, 0xe000);
+	  elfcpp::Swap<16, big_endian>::writeval(wv + 1, 0xbf00);
+	}
+      return This::STATUS_OKAY;
+    }
+ 
+  int32_t addend = This::thumb32_branch_offset(upper_insn, lower_insn);
+  Arm_address branch_target = psymval->value(object, addend);
+  int32_t branch_offset = branch_target - address;
+
+  // We need a stub if the branch offset is too large or if we need
+  // to switch mode.
+  bool may_use_blx = arm_target->may_use_blx();
+  bool thumb2 = arm_target->using_thumb2();
+  if ((!thumb2
+       && (branch_offset > THM_MAX_FWD_BRANCH_OFFSET
+	   || (branch_offset < THM_MAX_BWD_BRANCH_OFFSET)))
+      || (thumb2
+	  && (branch_offset > THM2_MAX_FWD_BRANCH_OFFSET
+	      || (branch_offset < THM2_MAX_BWD_BRANCH_OFFSET)))
+      || ((thumb_bit == 0)
+          && (((r_type == elfcpp::R_ARM_THM_CALL) && !may_use_blx)
+	      || r_type == elfcpp::R_ARM_THM_JUMP24)))
+    {
+      Stub_type stub_type =
+	Reloc_stub::stub_type_for_reloc(r_type, address, branch_target,
+					(thumb_bit != 0));
+      if (stub_type != arm_stub_none)
+	{
+	  Stub_table<big_endian>* stub_table =
+	    object->stub_table(relinfo->data_shndx);
+	  gold_assert(stub_table != NULL);
+
+	  Reloc_stub::Key stub_key(stub_type, gsym, object, r_sym, addend);
+	  Reloc_stub* stub = stub_table->find_reloc_stub(stub_key);
+	  gold_assert(stub != NULL);
+	  thumb_bit = stub->stub_template()->entry_in_thumb_mode() ? 1 : 0;
+	  branch_target = stub_table->address() + stub->offset() + addend;
+	  branch_offset = branch_target - address;
+	}
+    }
+
+  // At this point, if we still need to switch mode, the instruction
+  // must either be a BLX or a BL that can be converted to a BLX.
+  if (thumb_bit == 0)
+    {
+      gold_assert(may_use_blx
+		  && (r_type == elfcpp::R_ARM_THM_CALL
+		      || r_type == elfcpp::R_ARM_THM_XPC22));
+      // Make sure this is a BLX.
+      lower_insn &= ~0x1000U;
+    }
+  else
+    {
+      // Make sure this is a BL.
+      lower_insn |= 0x1000U;
+    }
+
+  if ((lower_insn & 0x5000U) == 0x4000U)
+    // For a BLX instruction, make sure that the relocation is rounded up
+    // to a word boundary.  This follows the semantics of the instruction
+    // which specifies that bit 1 of the target address will come from bit
+    // 1 of the base address.
+    branch_offset = (branch_offset + 2) & ~3;
+
+  // Put BRANCH_OFFSET back into the insn.  Assumes two's complement.
+  // We use the Thumb-2 encoding, which is safe even if dealing with
+  // a Thumb-1 instruction by virtue of our overflow check above.  */
+  upper_insn = This::thumb32_branch_upper(upper_insn, branch_offset);
+  lower_insn = This::thumb32_branch_lower(lower_insn, branch_offset);
+
+  elfcpp::Swap<16, big_endian>::writeval(wv, upper_insn);
+  elfcpp::Swap<16, big_endian>::writeval(wv + 1, lower_insn);
+
+  return ((thumb2
+	   ? utils::has_overflow<25>(branch_offset)
+	   : utils::has_overflow<23>(branch_offset))
+	  ? This::STATUS_OVERFLOW
+	  : This::STATUS_OKAY);
+}
+
+// Relocate THUMB-2 long conditional branches.
+// If IS_WEAK_UNDEFINED_WITH_PLT is true.  The target symbol is weakly
+// undefined and we do not use PLT in this relocation.  In such a case,
+// the branch is converted into an NOP.
+
+template<bool big_endian>
+typename Arm_relocate_functions<big_endian>::Status
+Arm_relocate_functions<big_endian>::thm_jump19(
+    unsigned char *view,
+    const Arm_relobj<big_endian>* object,
+    const Symbol_value<32>* psymval,
+    Arm_address address,
+    Arm_address thumb_bit)
+{
+  typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
+  Valtype* wv = reinterpret_cast<Valtype*>(view);
+  uint32_t upper_insn = elfcpp::Swap<16, big_endian>::readval(wv);
+  uint32_t lower_insn = elfcpp::Swap<16, big_endian>::readval(wv + 1);
+  int32_t addend = This::thumb32_cond_branch_offset(upper_insn, lower_insn);
+
+  Arm_address branch_target = psymval->value(object, addend);
+  int32_t branch_offset = branch_target - address;
+
+  // ??? Should handle interworking?  GCC might someday try to
+  // use this for tail calls.
+  // FIXME: We do support thumb entry to PLT yet.
+  if (thumb_bit == 0)
+    {
+      gold_error(_("conditional branch to PLT in THUMB-2 not supported yet."));
+      return This::STATUS_BAD_RELOC;
+    }
+
+  // Put RELOCATION back into the insn.
+  upper_insn = This::thumb32_cond_branch_upper(upper_insn, branch_offset);
+  lower_insn = This::thumb32_cond_branch_lower(lower_insn, branch_offset);
+
+  // Put the relocated value back in the object file:
+  elfcpp::Swap<16, big_endian>::writeval(wv, upper_insn);
+  elfcpp::Swap<16, big_endian>::writeval(wv + 1, lower_insn);
+
+  return (utils::has_overflow<21>(branch_offset)
+	  ? This::STATUS_OVERFLOW
+	  : This::STATUS_OKAY);
+}
+
 // Get the GOT section, creating it if necessary.
 
 template<bool big_endian>
-Output_data_got<32, big_endian>*
+Arm_output_data_got<big_endian>*
 Target_arm<big_endian>::got_section(Symbol_table* symtab, Layout* layout)
 {
   if (this->got_ == NULL)
     {
       gold_assert(symtab != NULL && layout != NULL);
 
-      this->got_ = new Output_data_got<32, big_endian>();
+      this->got_ = new Arm_output_data_got<big_endian>(symtab, layout);
 
       Output_section* os;
       os = layout->add_output_section_data(".got", elfcpp::SHT_PROGBITS,
 					   (elfcpp::SHF_ALLOC
 					    | elfcpp::SHF_WRITE),
-					   this->got_);
-      os->set_is_relro();
+					   this->got_, false, true, true,
+					   false);
 
       // The old GNU linker creates a .got.plt section.  We just
       // create another set of data in the .got section.  Note that we
@@ -1086,14 +4011,15 @@ Target_arm<big_endian>::got_section(Symbol_table* symtab, Layout* layout)
       os = layout->add_output_section_data(".got", elfcpp::SHT_PROGBITS,
 					   (elfcpp::SHF_ALLOC
 					    | elfcpp::SHF_WRITE),
-					   this->got_plt_);
-      os->set_is_relro();
+					   this->got_plt_, false, false,
+					   false, true);
 
       // The first three entries are reserved.
       this->got_plt_->set_current_data_size(3 * 4);
 
       // Define _GLOBAL_OFFSET_TABLE_ at the start of the PLT.
       symtab->define_in_output_data("_GLOBAL_OFFSET_TABLE_", NULL,
+				    Symbol_table::PREDEFINED,
 				    this->got_plt_,
 				    0, 0, elfcpp::STT_OBJECT,
 				    elfcpp::STB_LOCAL,
@@ -1114,11 +4040,2611 @@ Target_arm<big_endian>::rel_dyn_section(Layout* layout)
       gold_assert(layout != NULL);
       this->rel_dyn_ = new Reloc_section(parameters->options().combreloc());
       layout->add_output_section_data(".rel.dyn", elfcpp::SHT_REL,
-				      elfcpp::SHF_ALLOC, this->rel_dyn_);
+				      elfcpp::SHF_ALLOC, this->rel_dyn_, true,
+				      false, false, false);
     }
   return this->rel_dyn_;
 }
 
+// Insn_template methods.
+
+// Return byte size of an instruction template.
+
+size_t
+Insn_template::size() const
+{
+  switch (this->type())
+    {
+    case THUMB16_TYPE:
+    case THUMB16_SPECIAL_TYPE:
+      return 2;
+    case ARM_TYPE:
+    case THUMB32_TYPE:
+    case DATA_TYPE:
+      return 4;
+    default:
+      gold_unreachable();
+    }
+}
+
+// Return alignment of an instruction template.
+
+unsigned
+Insn_template::alignment() const
+{
+  switch (this->type())
+    {
+    case THUMB16_TYPE:
+    case THUMB16_SPECIAL_TYPE:
+    case THUMB32_TYPE:
+      return 2;
+    case ARM_TYPE:
+    case DATA_TYPE:
+      return 4;
+    default:
+      gold_unreachable();
+    }
+}
+
+// Stub_template methods.
+
+Stub_template::Stub_template(
+    Stub_type type, const Insn_template* insns,
+     size_t insn_count)
+  : type_(type), insns_(insns), insn_count_(insn_count), alignment_(1),
+    entry_in_thumb_mode_(false), relocs_()
+{
+  off_t offset = 0;
+
+  // Compute byte size and alignment of stub template.
+  for (size_t i = 0; i < insn_count; i++)
+    {
+      unsigned insn_alignment = insns[i].alignment();
+      size_t insn_size = insns[i].size();
+      gold_assert((offset & (insn_alignment - 1)) == 0);
+      this->alignment_ = std::max(this->alignment_, insn_alignment);
+      switch (insns[i].type())
+	{
+	case Insn_template::THUMB16_TYPE:
+	case Insn_template::THUMB16_SPECIAL_TYPE:
+	  if (i == 0)
+	    this->entry_in_thumb_mode_ = true;
+	  break;
+
+	case Insn_template::THUMB32_TYPE:
+          if (insns[i].r_type() != elfcpp::R_ARM_NONE)
+	    this->relocs_.push_back(Reloc(i, offset));
+	  if (i == 0)
+	    this->entry_in_thumb_mode_ = true;
+          break;
+
+	case Insn_template::ARM_TYPE:
+	  // Handle cases where the target is encoded within the
+	  // instruction.
+	  if (insns[i].r_type() == elfcpp::R_ARM_JUMP24)
+	    this->relocs_.push_back(Reloc(i, offset));
+	  break;
+
+	case Insn_template::DATA_TYPE:
+	  // Entry point cannot be data.
+	  gold_assert(i != 0);
+	  this->relocs_.push_back(Reloc(i, offset));
+	  break;
+
+	default:
+	  gold_unreachable();
+	}
+      offset += insn_size; 
+    }
+  this->size_ = offset;
+}
+
+// Stub methods.
+
+// Template to implement do_write for a specific target endianity.
+
+template<bool big_endian>
+void inline
+Stub::do_fixed_endian_write(unsigned char* view, section_size_type view_size)
+{
+  const Stub_template* stub_template = this->stub_template();
+  const Insn_template* insns = stub_template->insns();
+
+  // FIXME:  We do not handle BE8 encoding yet.
+  unsigned char* pov = view;
+  for (size_t i = 0; i < stub_template->insn_count(); i++)
+    {
+      switch (insns[i].type())
+	{
+	case Insn_template::THUMB16_TYPE:
+	  elfcpp::Swap<16, big_endian>::writeval(pov, insns[i].data() & 0xffff);
+	  break;
+	case Insn_template::THUMB16_SPECIAL_TYPE:
+	  elfcpp::Swap<16, big_endian>::writeval(
+	      pov,
+	      this->thumb16_special(i));
+	  break;
+	case Insn_template::THUMB32_TYPE:
+	  {
+	    uint32_t hi = (insns[i].data() >> 16) & 0xffff;
+	    uint32_t lo = insns[i].data() & 0xffff;
+	    elfcpp::Swap<16, big_endian>::writeval(pov, hi);
+	    elfcpp::Swap<16, big_endian>::writeval(pov + 2, lo);
+	  }
+          break;
+	case Insn_template::ARM_TYPE:
+	case Insn_template::DATA_TYPE:
+	  elfcpp::Swap<32, big_endian>::writeval(pov, insns[i].data());
+	  break;
+	default:
+	  gold_unreachable();
+	}
+      pov += insns[i].size();
+    }
+  gold_assert(static_cast<section_size_type>(pov - view) == view_size);
+} 
+
+// Reloc_stub::Key methods.
+
+// Dump a Key as a string for debugging.
+
+std::string
+Reloc_stub::Key::name() const
+{
+  if (this->r_sym_ == invalid_index)
+    {
+      // Global symbol key name
+      // <stub-type>:<symbol name>:<addend>.
+      const std::string sym_name = this->u_.symbol->name();
+      // We need to print two hex number and two colons.  So just add 100 bytes
+      // to the symbol name size.
+      size_t len = sym_name.size() + 100;
+      char* buffer = new char[len];
+      int c = snprintf(buffer, len, "%d:%s:%x", this->stub_type_,
+		       sym_name.c_str(), this->addend_);
+      gold_assert(c > 0 && c < static_cast<int>(len));
+      delete[] buffer;
+      return std::string(buffer);
+    }
+  else
+    {
+      // local symbol key name
+      // <stub-type>:<object>:<r_sym>:<addend>.
+      const size_t len = 200;
+      char buffer[len];
+      int c = snprintf(buffer, len, "%d:%p:%u:%x", this->stub_type_,
+		       this->u_.relobj, this->r_sym_, this->addend_);
+      gold_assert(c > 0 && c < static_cast<int>(len));
+      return std::string(buffer);
+    }
+}
+
+// Reloc_stub methods.
+
+// Determine the type of stub needed, if any, for a relocation of R_TYPE at
+// LOCATION to DESTINATION.
+// This code is based on the arm_type_of_stub function in
+// bfd/elf32-arm.c.  We have changed the interface a liitle to keep the Stub
+// class simple.
+
+Stub_type
+Reloc_stub::stub_type_for_reloc(
+   unsigned int r_type,
+   Arm_address location,
+   Arm_address destination,
+   bool target_is_thumb)
+{
+  Stub_type stub_type = arm_stub_none;
+
+  // This is a bit ugly but we want to avoid using a templated class for
+  // big and little endianities.
+  bool may_use_blx;
+  bool should_force_pic_veneer;
+  bool thumb2;
+  bool thumb_only;
+  if (parameters->target().is_big_endian())
+    {
+      const Target_arm<true>* big_endian_target =
+	Target_arm<true>::default_target();
+      may_use_blx = big_endian_target->may_use_blx();
+      should_force_pic_veneer = big_endian_target->should_force_pic_veneer();
+      thumb2 = big_endian_target->using_thumb2();
+      thumb_only = big_endian_target->using_thumb_only();
+    }
+  else
+    {
+      const Target_arm<false>* little_endian_target =
+	Target_arm<false>::default_target();
+      may_use_blx = little_endian_target->may_use_blx();
+      should_force_pic_veneer = little_endian_target->should_force_pic_veneer();
+      thumb2 = little_endian_target->using_thumb2();
+      thumb_only = little_endian_target->using_thumb_only();
+    }
+
+  int64_t branch_offset = (int64_t)destination - location;
+
+  if (r_type == elfcpp::R_ARM_THM_CALL || r_type == elfcpp::R_ARM_THM_JUMP24)
+    {
+      // Handle cases where:
+      // - this call goes too far (different Thumb/Thumb2 max
+      //   distance)
+      // - it's a Thumb->Arm call and blx is not available, or it's a
+      //   Thumb->Arm branch (not bl). A stub is needed in this case.
+      if ((!thumb2
+	    && (branch_offset > THM_MAX_FWD_BRANCH_OFFSET
+		|| (branch_offset < THM_MAX_BWD_BRANCH_OFFSET)))
+	  || (thumb2
+	      && (branch_offset > THM2_MAX_FWD_BRANCH_OFFSET
+		  || (branch_offset < THM2_MAX_BWD_BRANCH_OFFSET)))
+	  || ((!target_is_thumb)
+	      && (((r_type == elfcpp::R_ARM_THM_CALL) && !may_use_blx)
+		  || (r_type == elfcpp::R_ARM_THM_JUMP24))))
+	{
+	  if (target_is_thumb)
+	    {
+	      // Thumb to thumb.
+	      if (!thumb_only)
+		{
+		  stub_type = (parameters->options().shared()
+			       || should_force_pic_veneer)
+		    // PIC stubs.
+		    ? ((may_use_blx
+			&& (r_type == elfcpp::R_ARM_THM_CALL))
+		       // V5T and above. Stub starts with ARM code, so
+		       // we must be able to switch mode before
+		       // reaching it, which is only possible for 'bl'
+		       // (ie R_ARM_THM_CALL relocation).
+		       ? arm_stub_long_branch_any_thumb_pic
+		       // On V4T, use Thumb code only.
+		       : arm_stub_long_branch_v4t_thumb_thumb_pic)
+
+		    // non-PIC stubs.
+		    : ((may_use_blx
+			&& (r_type == elfcpp::R_ARM_THM_CALL))
+		       ? arm_stub_long_branch_any_any // V5T and above.
+		       : arm_stub_long_branch_v4t_thumb_thumb);	// V4T.
+		}
+	      else
+		{
+		  stub_type = (parameters->options().shared()
+			       || should_force_pic_veneer)
+		    ? arm_stub_long_branch_thumb_only_pic	// PIC stub.
+		    : arm_stub_long_branch_thumb_only;	// non-PIC stub.
+		}
+	    }
+	  else
+	    {
+	      // Thumb to arm.
+	     
+	      // FIXME: We should check that the input section is from an
+	      // object that has interwork enabled.
+
+	      stub_type = (parameters->options().shared()
+			   || should_force_pic_veneer)
+		// PIC stubs.
+		? ((may_use_blx
+		    && (r_type == elfcpp::R_ARM_THM_CALL))
+		   ? arm_stub_long_branch_any_arm_pic	// V5T and above.
+		   : arm_stub_long_branch_v4t_thumb_arm_pic)	// V4T.
+
+		// non-PIC stubs.
+		: ((may_use_blx
+		    && (r_type == elfcpp::R_ARM_THM_CALL))
+		   ? arm_stub_long_branch_any_any	// V5T and above.
+		   : arm_stub_long_branch_v4t_thumb_arm);	// V4T.
+
+	      // Handle v4t short branches.
+	      if ((stub_type == arm_stub_long_branch_v4t_thumb_arm)
+		  && (branch_offset <= THM_MAX_FWD_BRANCH_OFFSET)
+		  && (branch_offset >= THM_MAX_BWD_BRANCH_OFFSET))
+		stub_type = arm_stub_short_branch_v4t_thumb_arm;
+	    }
+	}
+    }
+  else if (r_type == elfcpp::R_ARM_CALL
+	   || r_type == elfcpp::R_ARM_JUMP24
+	   || r_type == elfcpp::R_ARM_PLT32)
+    {
+      if (target_is_thumb)
+	{
+	  // Arm to thumb.
+
+	  // FIXME: We should check that the input section is from an
+	  // object that has interwork enabled.
+
+	  // We have an extra 2-bytes reach because of
+	  // the mode change (bit 24 (H) of BLX encoding).
+	  if (branch_offset > (ARM_MAX_FWD_BRANCH_OFFSET + 2)
+	      || (branch_offset < ARM_MAX_BWD_BRANCH_OFFSET)
+	      || ((r_type == elfcpp::R_ARM_CALL) && !may_use_blx)
+	      || (r_type == elfcpp::R_ARM_JUMP24)
+	      || (r_type == elfcpp::R_ARM_PLT32))
+	    {
+	      stub_type = (parameters->options().shared()
+			   || should_force_pic_veneer)
+		// PIC stubs.
+		? (may_use_blx
+		   ? arm_stub_long_branch_any_thumb_pic// V5T and above.
+		   : arm_stub_long_branch_v4t_arm_thumb_pic)	// V4T stub.
+
+		// non-PIC stubs.
+		: (may_use_blx
+		   ? arm_stub_long_branch_any_any	// V5T and above.
+		   : arm_stub_long_branch_v4t_arm_thumb);	// V4T.
+	    }
+	}
+      else
+	{
+	  // Arm to arm.
+	  if (branch_offset > ARM_MAX_FWD_BRANCH_OFFSET
+	      || (branch_offset < ARM_MAX_BWD_BRANCH_OFFSET))
+	    {
+	      stub_type = (parameters->options().shared()
+			   || should_force_pic_veneer)
+		? arm_stub_long_branch_any_arm_pic	// PIC stubs.
+		: arm_stub_long_branch_any_any;		/// non-PIC.
+	    }
+	}
+    }
+
+  return stub_type;
+}
+
+// Cortex_a8_stub methods.
+
+// Return the instruction for a THUMB16_SPECIAL_TYPE instruction template.
+// I is the position of the instruction template in the stub template.
+
+uint16_t
+Cortex_a8_stub::do_thumb16_special(size_t i)
+{
+  // The only use of this is to copy condition code from a conditional
+  // branch being worked around to the corresponding conditional branch in
+  // to the stub.
+  gold_assert(this->stub_template()->type() == arm_stub_a8_veneer_b_cond
+	      && i == 0);
+  uint16_t data = this->stub_template()->insns()[i].data();
+  gold_assert((data & 0xff00U) == 0xd000U);
+  data |= ((this->original_insn_ >> 22) & 0xf) << 8;
+  return data;
+}
+
+// Stub_factory methods.
+
+Stub_factory::Stub_factory()
+{
+  // The instruction template sequences are declared as static
+  // objects and initialized first time the constructor runs.
+ 
+  // Arm/Thumb -> Arm/Thumb long branch stub. On V5T and above, use blx
+  // to reach the stub if necessary.
+  static const Insn_template elf32_arm_stub_long_branch_any_any[] =
+    {
+      Insn_template::arm_insn(0xe51ff004),	// ldr   pc, [pc, #-4]
+      Insn_template::data_word(0, elfcpp::R_ARM_ABS32, 0),
+  						// dcd   R_ARM_ABS32(X)
+    };
+  
+  // V4T Arm -> Thumb long branch stub. Used on V4T where blx is not
+  // available.
+  static const Insn_template elf32_arm_stub_long_branch_v4t_arm_thumb[] =
+    {
+      Insn_template::arm_insn(0xe59fc000),	// ldr   ip, [pc, #0]
+      Insn_template::arm_insn(0xe12fff1c),	// bx    ip
+      Insn_template::data_word(0, elfcpp::R_ARM_ABS32, 0),
+  						// dcd   R_ARM_ABS32(X)
+    };
+  
+  // Thumb -> Thumb long branch stub. Used on M-profile architectures.
+  static const Insn_template elf32_arm_stub_long_branch_thumb_only[] =
+    {
+      Insn_template::thumb16_insn(0xb401),	// push {r0}
+      Insn_template::thumb16_insn(0x4802),	// ldr  r0, [pc, #8]
+      Insn_template::thumb16_insn(0x4684),	// mov  ip, r0
+      Insn_template::thumb16_insn(0xbc01),	// pop  {r0}
+      Insn_template::thumb16_insn(0x4760),	// bx   ip
+      Insn_template::thumb16_insn(0xbf00),	// nop
+      Insn_template::data_word(0, elfcpp::R_ARM_ABS32, 0),
+  						// dcd  R_ARM_ABS32(X)
+    };
+  
+  // V4T Thumb -> Thumb long branch stub. Using the stack is not
+  // allowed.
+  static const Insn_template elf32_arm_stub_long_branch_v4t_thumb_thumb[] =
+    {
+      Insn_template::thumb16_insn(0x4778),	// bx   pc
+      Insn_template::thumb16_insn(0x46c0),	// nop
+      Insn_template::arm_insn(0xe59fc000),	// ldr  ip, [pc, #0]
+      Insn_template::arm_insn(0xe12fff1c),	// bx   ip
+      Insn_template::data_word(0, elfcpp::R_ARM_ABS32, 0),
+  						// dcd  R_ARM_ABS32(X)
+    };
+  
+  // V4T Thumb -> ARM long branch stub. Used on V4T where blx is not
+  // available.
+  static const Insn_template elf32_arm_stub_long_branch_v4t_thumb_arm[] =
+    {
+      Insn_template::thumb16_insn(0x4778),	// bx   pc
+      Insn_template::thumb16_insn(0x46c0),	// nop
+      Insn_template::arm_insn(0xe51ff004),	// ldr   pc, [pc, #-4]
+      Insn_template::data_word(0, elfcpp::R_ARM_ABS32, 0),
+  						// dcd   R_ARM_ABS32(X)
+    };
+  
+  // V4T Thumb -> ARM short branch stub. Shorter variant of the above
+  // one, when the destination is close enough.
+  static const Insn_template elf32_arm_stub_short_branch_v4t_thumb_arm[] =
+    {
+      Insn_template::thumb16_insn(0x4778),		// bx   pc
+      Insn_template::thumb16_insn(0x46c0),		// nop
+      Insn_template::arm_rel_insn(0xea000000, -8),	// b    (X-8)
+    };
+  
+  // ARM/Thumb -> ARM long branch stub, PIC.  On V5T and above, use
+  // blx to reach the stub if necessary.
+  static const Insn_template elf32_arm_stub_long_branch_any_arm_pic[] =
+    {
+      Insn_template::arm_insn(0xe59fc000),	// ldr   r12, [pc]
+      Insn_template::arm_insn(0xe08ff00c),	// add   pc, pc, ip
+      Insn_template::data_word(0, elfcpp::R_ARM_REL32, -4),
+  						// dcd   R_ARM_REL32(X-4)
+    };
+  
+  // ARM/Thumb -> Thumb long branch stub, PIC.  On V5T and above, use
+  // blx to reach the stub if necessary.  We can not add into pc;
+  // it is not guaranteed to mode switch (different in ARMv6 and
+  // ARMv7).
+  static const Insn_template elf32_arm_stub_long_branch_any_thumb_pic[] =
+    {
+      Insn_template::arm_insn(0xe59fc004),	// ldr   r12, [pc, #4]
+      Insn_template::arm_insn(0xe08fc00c),	// add   ip, pc, ip
+      Insn_template::arm_insn(0xe12fff1c),	// bx    ip
+      Insn_template::data_word(0, elfcpp::R_ARM_REL32, 0),
+  						// dcd   R_ARM_REL32(X)
+    };
+  
+  // V4T ARM -> ARM long branch stub, PIC.
+  static const Insn_template elf32_arm_stub_long_branch_v4t_arm_thumb_pic[] =
+    {
+      Insn_template::arm_insn(0xe59fc004),	// ldr   ip, [pc, #4]
+      Insn_template::arm_insn(0xe08fc00c),	// add   ip, pc, ip
+      Insn_template::arm_insn(0xe12fff1c),	// bx    ip
+      Insn_template::data_word(0, elfcpp::R_ARM_REL32, 0),
+  						// dcd   R_ARM_REL32(X)
+    };
+  
+  // V4T Thumb -> ARM long branch stub, PIC.
+  static const Insn_template elf32_arm_stub_long_branch_v4t_thumb_arm_pic[] =
+    {
+      Insn_template::thumb16_insn(0x4778),	// bx   pc
+      Insn_template::thumb16_insn(0x46c0),	// nop
+      Insn_template::arm_insn(0xe59fc000),	// ldr  ip, [pc, #0]
+      Insn_template::arm_insn(0xe08cf00f),	// add  pc, ip, pc
+      Insn_template::data_word(0, elfcpp::R_ARM_REL32, -4),
+  						// dcd  R_ARM_REL32(X)
+    };
+  
+  // Thumb -> Thumb long branch stub, PIC. Used on M-profile
+  // architectures.
+  static const Insn_template elf32_arm_stub_long_branch_thumb_only_pic[] =
+    {
+      Insn_template::thumb16_insn(0xb401),	// push {r0}
+      Insn_template::thumb16_insn(0x4802),	// ldr  r0, [pc, #8]
+      Insn_template::thumb16_insn(0x46fc),	// mov  ip, pc
+      Insn_template::thumb16_insn(0x4484),	// add  ip, r0
+      Insn_template::thumb16_insn(0xbc01),	// pop  {r0}
+      Insn_template::thumb16_insn(0x4760),	// bx   ip
+      Insn_template::data_word(0, elfcpp::R_ARM_REL32, 4),
+  						// dcd  R_ARM_REL32(X)
+    };
+  
+  // V4T Thumb -> Thumb long branch stub, PIC. Using the stack is not
+  // allowed.
+  static const Insn_template elf32_arm_stub_long_branch_v4t_thumb_thumb_pic[] =
+    {
+      Insn_template::thumb16_insn(0x4778),	// bx   pc
+      Insn_template::thumb16_insn(0x46c0),	// nop
+      Insn_template::arm_insn(0xe59fc004),	// ldr  ip, [pc, #4]
+      Insn_template::arm_insn(0xe08fc00c),	// add   ip, pc, ip
+      Insn_template::arm_insn(0xe12fff1c),	// bx   ip
+      Insn_template::data_word(0, elfcpp::R_ARM_REL32, 0),
+  						// dcd  R_ARM_REL32(X)
+    };
+  
+  // Cortex-A8 erratum-workaround stubs.
+  
+  // Stub used for conditional branches (which may be beyond +/-1MB away,
+  // so we can't use a conditional branch to reach this stub).
+  
+  // original code:
+  //
+  // 	b<cond> X
+  // after:
+  //
+  static const Insn_template elf32_arm_stub_a8_veneer_b_cond[] =
+    {
+      Insn_template::thumb16_bcond_insn(0xd001),	//	b<cond>.n true
+      Insn_template::thumb32_b_insn(0xf000b800, -4),	//	b.w after
+      Insn_template::thumb32_b_insn(0xf000b800, -4)	// true:
+  							//	b.w X
+    };
+  
+  // Stub used for b.w and bl.w instructions.
+  
+  static const Insn_template elf32_arm_stub_a8_veneer_b[] =
+    {
+      Insn_template::thumb32_b_insn(0xf000b800, -4)	// b.w dest
+    };
+  
+  static const Insn_template elf32_arm_stub_a8_veneer_bl[] =
+    {
+      Insn_template::thumb32_b_insn(0xf000b800, -4)	// b.w dest
+    };
+  
+  // Stub used for Thumb-2 blx.w instructions.  We modified the original blx.w
+  // instruction (which switches to ARM mode) to point to this stub.  Jump to
+  // the real destination using an ARM-mode branch.
+  static const Insn_template elf32_arm_stub_a8_veneer_blx[] =
+    {
+      Insn_template::arm_rel_insn(0xea000000, -8)	// b dest
+    };
+
+  // Stub used to provide an interworking for R_ARM_V4BX relocation
+  // (bx r[n] instruction).
+  static const Insn_template elf32_arm_stub_v4_veneer_bx[] =
+    {
+      Insn_template::arm_insn(0xe3100001),		// tst   r<n>, #1
+      Insn_template::arm_insn(0x01a0f000),		// moveq pc, r<n>
+      Insn_template::arm_insn(0xe12fff10)		// bx    r<n>
+    };
+
+  // Fill in the stub template look-up table.  Stub templates are constructed
+  // per instance of Stub_factory for fast look-up without locking
+  // in a thread-enabled environment.
+
+  this->stub_templates_[arm_stub_none] =
+    new Stub_template(arm_stub_none, NULL, 0);
+
+#define DEF_STUB(x)	\
+  do \
+    { \
+      size_t array_size \
+	= sizeof(elf32_arm_stub_##x) / sizeof(elf32_arm_stub_##x[0]); \
+      Stub_type type = arm_stub_##x; \
+      this->stub_templates_[type] = \
+	new Stub_template(type, elf32_arm_stub_##x, array_size); \
+    } \
+  while (0);
+
+  DEF_STUBS
+#undef DEF_STUB
+}
+
+// Stub_table methods.
+
+// Removel all Cortex-A8 stub.
+
+template<bool big_endian>
+void
+Stub_table<big_endian>::remove_all_cortex_a8_stubs()
+{
+  for (Cortex_a8_stub_list::iterator p = this->cortex_a8_stubs_.begin();
+       p != this->cortex_a8_stubs_.end();
+       ++p)
+    delete p->second;
+  this->cortex_a8_stubs_.clear();
+}
+
+// Relocate one stub.  This is a helper for Stub_table::relocate_stubs().
+
+template<bool big_endian>
+void
+Stub_table<big_endian>::relocate_stub(
+    Stub* stub,
+    const Relocate_info<32, big_endian>* relinfo,
+    Target_arm<big_endian>* arm_target,
+    Output_section* output_section,
+    unsigned char* view,
+    Arm_address address,
+    section_size_type view_size)
+{
+  const Stub_template* stub_template = stub->stub_template();
+  if (stub_template->reloc_count() != 0)
+    {
+      // Adjust view to cover the stub only.
+      section_size_type offset = stub->offset();
+      section_size_type stub_size = stub_template->size();
+      gold_assert(offset + stub_size <= view_size);
+
+      arm_target->relocate_stub(stub, relinfo, output_section, view + offset,
+				address + offset, stub_size);
+    }
+}
+
+// Relocate all stubs in this stub table.
+
+template<bool big_endian>
+void
+Stub_table<big_endian>::relocate_stubs(
+    const Relocate_info<32, big_endian>* relinfo,
+    Target_arm<big_endian>* arm_target,
+    Output_section* output_section,
+    unsigned char* view,
+    Arm_address address,
+    section_size_type view_size)
+{
+  // If we are passed a view bigger than the stub table's.  we need to
+  // adjust the view.
+  gold_assert(address == this->address()
+	      && (view_size
+		  == static_cast<section_size_type>(this->data_size())));
+
+  // Relocate all relocation stubs.
+  for (typename Reloc_stub_map::const_iterator p = this->reloc_stubs_.begin();
+      p != this->reloc_stubs_.end();
+      ++p)
+    this->relocate_stub(p->second, relinfo, arm_target, output_section, view,
+			address, view_size);
+
+  // Relocate all Cortex-A8 stubs.
+  for (Cortex_a8_stub_list::iterator p = this->cortex_a8_stubs_.begin();
+       p != this->cortex_a8_stubs_.end();
+       ++p)
+    this->relocate_stub(p->second, relinfo, arm_target, output_section, view,
+			address, view_size);
+
+  // Relocate all ARM V4BX stubs.
+  for (Arm_v4bx_stub_list::iterator p = this->arm_v4bx_stubs_.begin();
+       p != this->arm_v4bx_stubs_.end();
+       ++p)
+    {
+      if (*p != NULL)
+	this->relocate_stub(*p, relinfo, arm_target, output_section, view,
+			    address, view_size);
+    }
+}
+
+// Write out the stubs to file.
+
+template<bool big_endian>
+void
+Stub_table<big_endian>::do_write(Output_file* of)
+{
+  off_t offset = this->offset();
+  const section_size_type oview_size =
+    convert_to_section_size_type(this->data_size());
+  unsigned char* const oview = of->get_output_view(offset, oview_size);
+
+  // Write relocation stubs.
+  for (typename Reloc_stub_map::const_iterator p = this->reloc_stubs_.begin();
+      p != this->reloc_stubs_.end();
+      ++p)
+    {
+      Reloc_stub* stub = p->second;
+      Arm_address address = this->address() + stub->offset();
+      gold_assert(address
+		  == align_address(address,
+				   stub->stub_template()->alignment()));
+      stub->write(oview + stub->offset(), stub->stub_template()->size(),
+		  big_endian);
+    }
+
+  // Write Cortex-A8 stubs.
+  for (Cortex_a8_stub_list::const_iterator p = this->cortex_a8_stubs_.begin();
+       p != this->cortex_a8_stubs_.end();
+       ++p)
+    {
+      Cortex_a8_stub* stub = p->second;
+      Arm_address address = this->address() + stub->offset();
+      gold_assert(address
+		  == align_address(address,
+				   stub->stub_template()->alignment()));
+      stub->write(oview + stub->offset(), stub->stub_template()->size(),
+		  big_endian);
+    }
+
+  // Write ARM V4BX relocation stubs.
+  for (Arm_v4bx_stub_list::const_iterator p = this->arm_v4bx_stubs_.begin();
+       p != this->arm_v4bx_stubs_.end();
+       ++p)
+    {
+      if (*p == NULL)
+	continue;
+
+      Arm_address address = this->address() + (*p)->offset();
+      gold_assert(address
+		  == align_address(address,
+				   (*p)->stub_template()->alignment()));
+      (*p)->write(oview + (*p)->offset(), (*p)->stub_template()->size(),
+		  big_endian);
+    }
+
+  of->write_output_view(this->offset(), oview_size, oview);
+}
+
+// Update the data size and address alignment of the stub table at the end
+// of a relaxation pass.   Return true if either the data size or the
+// alignment changed in this relaxation pass.
+
+template<bool big_endian>
+bool
+Stub_table<big_endian>::update_data_size_and_addralign()
+{
+  off_t size = 0;
+  unsigned addralign = 1;
+
+  // Go over all stubs in table to compute data size and address alignment.
+  
+  for (typename Reloc_stub_map::const_iterator p = this->reloc_stubs_.begin();
+      p != this->reloc_stubs_.end();
+      ++p)
+    {
+      const Stub_template* stub_template = p->second->stub_template();
+      addralign = std::max(addralign, stub_template->alignment());
+      size = (align_address(size, stub_template->alignment())
+	      + stub_template->size());
+    }
+
+  for (Cortex_a8_stub_list::const_iterator p = this->cortex_a8_stubs_.begin();
+       p != this->cortex_a8_stubs_.end();
+       ++p)
+    {
+      const Stub_template* stub_template = p->second->stub_template();
+      addralign = std::max(addralign, stub_template->alignment());
+      size = (align_address(size, stub_template->alignment())
+	      + stub_template->size());
+    }
+
+  for (Arm_v4bx_stub_list::const_iterator p = this->arm_v4bx_stubs_.begin();
+       p != this->arm_v4bx_stubs_.end();
+       ++p)
+    {
+      if (*p == NULL)
+	continue;
+
+      const Stub_template* stub_template = (*p)->stub_template();
+      addralign = std::max(addralign, stub_template->alignment());
+      size = (align_address(size, stub_template->alignment())
+	      + stub_template->size());
+    }
+
+  // Check if either data size or alignment changed in this pass.
+  // Update prev_data_size_ and prev_addralign_.  These will be used
+  // as the current data size and address alignment for the next pass.
+  bool changed = size != this->prev_data_size_;
+  this->prev_data_size_ = size; 
+
+  if (addralign != this->prev_addralign_)
+    changed = true;
+  this->prev_addralign_ = addralign;
+
+  return changed;
+}
+
+// Finalize the stubs.  This sets the offsets of the stubs within the stub
+// table.  It also marks all input sections needing Cortex-A8 workaround.
+
+template<bool big_endian>
+void
+Stub_table<big_endian>::finalize_stubs()
+{
+  off_t off = 0;
+  for (typename Reloc_stub_map::const_iterator p = this->reloc_stubs_.begin();
+      p != this->reloc_stubs_.end();
+      ++p)
+    {
+      Reloc_stub* stub = p->second;
+      const Stub_template* stub_template = stub->stub_template();
+      uint64_t stub_addralign = stub_template->alignment();
+      off = align_address(off, stub_addralign);
+      stub->set_offset(off);
+      off += stub_template->size();
+    }
+
+  for (Cortex_a8_stub_list::const_iterator p = this->cortex_a8_stubs_.begin();
+       p != this->cortex_a8_stubs_.end();
+       ++p)
+    {
+      Cortex_a8_stub* stub = p->second;
+      const Stub_template* stub_template = stub->stub_template();
+      uint64_t stub_addralign = stub_template->alignment();
+      off = align_address(off, stub_addralign);
+      stub->set_offset(off);
+      off += stub_template->size();
+
+      // Mark input section so that we can determine later if a code section
+      // needs the Cortex-A8 workaround quickly.
+      Arm_relobj<big_endian>* arm_relobj =
+	Arm_relobj<big_endian>::as_arm_relobj(stub->relobj());
+      arm_relobj->mark_section_for_cortex_a8_workaround(stub->shndx());
+    }
+
+  for (Arm_v4bx_stub_list::const_iterator p = this->arm_v4bx_stubs_.begin();
+      p != this->arm_v4bx_stubs_.end();
+      ++p)
+    {
+      if (*p == NULL)
+	continue;
+
+      const Stub_template* stub_template = (*p)->stub_template();
+      uint64_t stub_addralign = stub_template->alignment();
+      off = align_address(off, stub_addralign);
+      (*p)->set_offset(off);
+      off += stub_template->size();
+    }
+
+  gold_assert(off <= this->prev_data_size_);
+}
+
+// Apply Cortex-A8 workaround to an address range between VIEW_ADDRESS
+// and VIEW_ADDRESS + VIEW_SIZE - 1.  VIEW points to the mapped address
+// of the address range seen by the linker.
+
+template<bool big_endian>
+void
+Stub_table<big_endian>::apply_cortex_a8_workaround_to_address_range(
+    Target_arm<big_endian>* arm_target,
+    unsigned char* view,
+    Arm_address view_address,
+    section_size_type view_size)
+{
+  // Cortex-A8 stubs are sorted by addresses of branches being fixed up.
+  for (Cortex_a8_stub_list::const_iterator p =
+	 this->cortex_a8_stubs_.lower_bound(view_address);
+       ((p != this->cortex_a8_stubs_.end())
+	&& (p->first < (view_address + view_size)));
+       ++p)
+    {
+      // We do not store the THUMB bit in the LSB of either the branch address
+      // or the stub offset.  There is no need to strip the LSB.
+      Arm_address branch_address = p->first;
+      const Cortex_a8_stub* stub = p->second;
+      Arm_address stub_address = this->address() + stub->offset();
+
+      // Offset of the branch instruction relative to this view.
+      section_size_type offset =
+	convert_to_section_size_type(branch_address - view_address);
+      gold_assert((offset + 4) <= view_size);
+
+      arm_target->apply_cortex_a8_workaround(stub, stub_address,
+					     view + offset, branch_address);
+    }
+}
+
+// Arm_input_section methods.
+
+// Initialize an Arm_input_section.
+
+template<bool big_endian>
+void
+Arm_input_section<big_endian>::init()
+{
+  Relobj* relobj = this->relobj();
+  unsigned int shndx = this->shndx();
+
+  // Cache these to speed up size and alignment queries.  It is too slow
+  // to call section_addraglin and section_size every time.
+  this->original_addralign_ = relobj->section_addralign(shndx);
+  this->original_size_ = relobj->section_size(shndx);
+
+  // We want to make this look like the original input section after
+  // output sections are finalized.
+  Output_section* os = relobj->output_section(shndx);
+  off_t offset = relobj->output_section_offset(shndx);
+  gold_assert(os != NULL && !relobj->is_output_section_offset_invalid(shndx));
+  this->set_address(os->address() + offset);
+  this->set_file_offset(os->offset() + offset);
+
+  this->set_current_data_size(this->original_size_);
+  this->finalize_data_size();
+}
+
+template<bool big_endian>
+void
+Arm_input_section<big_endian>::do_write(Output_file* of)
+{
+  // We have to write out the original section content.
+  section_size_type section_size;
+  const unsigned char* section_contents =
+    this->relobj()->section_contents(this->shndx(), &section_size, false); 
+  of->write(this->offset(), section_contents, section_size); 
+
+  // If this owns a stub table and it is not empty, write it.
+  if (this->is_stub_table_owner() && !this->stub_table_->empty())
+    this->stub_table_->write(of);
+}
+
+// Finalize data size.
+
+template<bool big_endian>
+void
+Arm_input_section<big_endian>::set_final_data_size()
+{
+  // If this owns a stub table, finalize its data size as well.
+  if (this->is_stub_table_owner())
+    {
+      uint64_t address = this->address();
+
+      // The stub table comes after the original section contents.
+      address += this->original_size_;
+      address = align_address(address, this->stub_table_->addralign());
+      off_t offset = this->offset() + (address - this->address());
+      this->stub_table_->set_address_and_file_offset(address, offset);
+      address += this->stub_table_->data_size();
+      gold_assert(address == this->address() + this->current_data_size());
+    }
+
+  this->set_data_size(this->current_data_size());
+}
+
+// Reset address and file offset.
+
+template<bool big_endian>
+void
+Arm_input_section<big_endian>::do_reset_address_and_file_offset()
+{
+  // Size of the original input section contents.
+  off_t off = convert_types<off_t, uint64_t>(this->original_size_);
+
+  // If this is a stub table owner, account for the stub table size.
+  if (this->is_stub_table_owner())
+    {
+      Stub_table<big_endian>* stub_table = this->stub_table_;
+
+      // Reset the stub table's address and file offset.  The
+      // current data size for child will be updated after that.
+      stub_table_->reset_address_and_file_offset();
+      off = align_address(off, stub_table_->addralign());
+      off += stub_table->current_data_size();
+    }
+
+  this->set_current_data_size(off);
+}
+
+// Arm_exidx_cantunwind methods.
+
+// Write this to Output file OF for a fixed endianity.
+
+template<bool big_endian>
+void
+Arm_exidx_cantunwind::do_fixed_endian_write(Output_file* of)
+{
+  off_t offset = this->offset();
+  const section_size_type oview_size = 8;
+  unsigned char* const oview = of->get_output_view(offset, oview_size);
+  
+  typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
+  Valtype* wv = reinterpret_cast<Valtype*>(oview);
+
+  Output_section* os = this->relobj_->output_section(this->shndx_);
+  gold_assert(os != NULL);
+
+  Arm_relobj<big_endian>* arm_relobj =
+    Arm_relobj<big_endian>::as_arm_relobj(this->relobj_);
+  Arm_address output_offset =
+    arm_relobj->get_output_section_offset(this->shndx_);
+  Arm_address section_start;
+  if(output_offset != Arm_relobj<big_endian>::invalid_address)
+    section_start = os->address() + output_offset;
+  else
+    {
+      // Currently this only happens for a relaxed section.
+      const Output_relaxed_input_section* poris =
+	os->find_relaxed_input_section(this->relobj_, this->shndx_);
+      gold_assert(poris != NULL);
+      section_start = poris->address();
+    }
+
+  // We always append this to the end of an EXIDX section.
+  Arm_address output_address =
+    section_start + this->relobj_->section_size(this->shndx_);
+
+  // Write out the entry.  The first word either points to the beginning
+  // or after the end of a text section.  The second word is the special
+  // EXIDX_CANTUNWIND value.
+  uint32_t prel31_offset = output_address - this->address();
+  if (utils::has_overflow<31>(offset))
+    gold_error(_("PREL31 overflow in EXIDX_CANTUNWIND entry"));
+  elfcpp::Swap<32, big_endian>::writeval(wv, prel31_offset & 0x7fffffffU);
+  elfcpp::Swap<32, big_endian>::writeval(wv + 1, elfcpp::EXIDX_CANTUNWIND);
+
+  of->write_output_view(this->offset(), oview_size, oview);
+}
+
+// Arm_exidx_merged_section methods.
+
+// Constructor for Arm_exidx_merged_section.
+// EXIDX_INPUT_SECTION points to the unmodified EXIDX input section.
+// SECTION_OFFSET_MAP points to a section offset map describing how
+// parts of the input section are mapped to output.  DELETED_BYTES is
+// the number of bytes deleted from the EXIDX input section.
+
+Arm_exidx_merged_section::Arm_exidx_merged_section(
+    const Arm_exidx_input_section& exidx_input_section,
+    const Arm_exidx_section_offset_map& section_offset_map,
+    uint32_t deleted_bytes)
+  : Output_relaxed_input_section(exidx_input_section.relobj(),
+				 exidx_input_section.shndx(),
+				 exidx_input_section.addralign()),
+    exidx_input_section_(exidx_input_section),
+    section_offset_map_(section_offset_map)
+{
+  // Fix size here so that we do not need to implement set_final_data_size.
+  this->set_data_size(exidx_input_section.size() - deleted_bytes);
+  this->fix_data_size();
+}
+
+// Given an input OBJECT, an input section index SHNDX within that
+// object, and an OFFSET relative to the start of that input
+// section, return whether or not the corresponding offset within
+// the output section is known.  If this function returns true, it
+// sets *POUTPUT to the output offset.  The value -1 indicates that
+// this input offset is being discarded.
+
+bool
+Arm_exidx_merged_section::do_output_offset(
+    const Relobj* relobj,
+    unsigned int shndx,
+    section_offset_type offset,
+    section_offset_type* poutput) const
+{
+  // We only handle offsets for the original EXIDX input section.
+  if (relobj != this->exidx_input_section_.relobj()
+      || shndx != this->exidx_input_section_.shndx())
+    return false;
+
+  section_offset_type section_size =
+    convert_types<section_offset_type>(this->exidx_input_section_.size());
+  if (offset < 0 || offset >= section_size)
+    // Input offset is out of valid range.
+    *poutput = -1;
+  else
+    {
+      // We need to look up the section offset map to determine the output
+      // offset.  Find the reference point in map that is first offset
+      // bigger than or equal to this offset.
+      Arm_exidx_section_offset_map::const_iterator p =
+	this->section_offset_map_.lower_bound(offset);
+
+      // The section offset maps are build such that this should not happen if
+      // input offset is in the valid range.
+      gold_assert(p != this->section_offset_map_.end());
+
+      // We need to check if this is dropped.
+     section_offset_type ref = p->first;
+     section_offset_type mapped_ref = p->second;
+
+      if (mapped_ref != Arm_exidx_input_section::invalid_offset)
+	// Offset is present in output.
+	*poutput = mapped_ref + (offset - ref);
+      else
+	// Offset is discarded owing to EXIDX entry merging.
+	*poutput = -1;
+    }
+  
+  return true;
+}
+
+// Write this to output file OF.
+
+void
+Arm_exidx_merged_section::do_write(Output_file* of)
+{
+  // If we retain or discard the whole EXIDX input section,  we would
+  // not be here.
+  gold_assert(this->data_size() != this->exidx_input_section_.size()
+	      && this->data_size() != 0);
+
+  off_t offset = this->offset();
+  const section_size_type oview_size = this->data_size();
+  unsigned char* const oview = of->get_output_view(offset, oview_size);
+  
+  Output_section* os = this->relobj()->output_section(this->shndx());
+  gold_assert(os != NULL);
+
+  // Get contents of EXIDX input section.
+  section_size_type section_size;
+  const unsigned char* section_contents =
+    this->relobj()->section_contents(this->shndx(), &section_size, false); 
+  gold_assert(section_size == this->exidx_input_section_.size());
+
+  // Go over spans of input offsets and write only those that are not
+  // discarded.
+  section_offset_type in_start = 0;
+  section_offset_type out_start = 0;
+  for(Arm_exidx_section_offset_map::const_iterator p =
+        this->section_offset_map_.begin();
+      p != this->section_offset_map_.end();
+      ++p)
+    {
+      section_offset_type in_end = p->first;
+      gold_assert(in_end >= in_start);
+      section_offset_type out_end = p->second;
+      size_t in_chunk_size = convert_types<size_t>(in_end - in_start + 1);
+      if (out_end != -1)
+	{
+	  size_t out_chunk_size =
+	    convert_types<size_t>(out_end - out_start + 1);
+	  gold_assert(out_chunk_size == in_chunk_size);
+	  memcpy(oview + out_start, section_contents + in_start,
+		 out_chunk_size);
+	  out_start += out_chunk_size;
+	}
+      in_start += in_chunk_size;
+    }
+
+  gold_assert(convert_to_section_size_type(out_start) == oview_size);
+  of->write_output_view(this->offset(), oview_size, oview);
+}
+
+// Arm_exidx_fixup methods.
+
+// Append an EXIDX_CANTUNWIND in the current output section if the last entry
+// is not an EXIDX_CANTUNWIND entry already.  The new EXIDX_CANTUNWIND entry
+// points to the end of the last seen EXIDX section.
+
+void
+Arm_exidx_fixup::add_exidx_cantunwind_as_needed()
+{
+  if (this->last_unwind_type_ != UT_EXIDX_CANTUNWIND
+      && this->last_input_section_ != NULL)
+    {
+      Relobj* relobj = this->last_input_section_->relobj();
+      unsigned int text_shndx = this->last_input_section_->link();
+      Arm_exidx_cantunwind* cantunwind =
+	new Arm_exidx_cantunwind(relobj, text_shndx);
+      this->exidx_output_section_->add_output_section_data(cantunwind);
+      this->last_unwind_type_ = UT_EXIDX_CANTUNWIND;
+    }
+}
+
+// Process an EXIDX section entry in input.  Return whether this entry
+// can be deleted in the output.  SECOND_WORD in the second word of the
+// EXIDX entry.
+
+bool
+Arm_exidx_fixup::process_exidx_entry(uint32_t second_word)
+{
+  bool delete_entry;
+  if (second_word == elfcpp::EXIDX_CANTUNWIND)
+    {
+      // Merge if previous entry is also an EXIDX_CANTUNWIND.
+      delete_entry = this->last_unwind_type_ == UT_EXIDX_CANTUNWIND;
+      this->last_unwind_type_ = UT_EXIDX_CANTUNWIND;
+    }
+  else if ((second_word & 0x80000000) != 0)
+    {
+      // Inlined unwinding data.  Merge if equal to previous.
+      delete_entry = (this->last_unwind_type_ == UT_INLINED_ENTRY
+		      && this->last_inlined_entry_ == second_word);
+      this->last_unwind_type_ = UT_INLINED_ENTRY;
+      this->last_inlined_entry_ = second_word;
+    }
+  else
+    {
+      // Normal table entry.  In theory we could merge these too,
+      // but duplicate entries are likely to be much less common.
+      delete_entry = false;
+      this->last_unwind_type_ = UT_NORMAL_ENTRY;
+    }
+  return delete_entry;
+}
+
+// Update the current section offset map during EXIDX section fix-up.
+// If there is no map, create one.  INPUT_OFFSET is the offset of a
+// reference point, DELETED_BYTES is the number of deleted by in the
+// section so far.  If DELETE_ENTRY is true, the reference point and
+// all offsets after the previous reference point are discarded.
+
+void
+Arm_exidx_fixup::update_offset_map(
+    section_offset_type input_offset,
+    section_size_type deleted_bytes,
+    bool delete_entry)
+{
+  if (this->section_offset_map_ == NULL)
+    this->section_offset_map_ = new Arm_exidx_section_offset_map();
+  section_offset_type output_offset = (delete_entry
+				       ? -1
+				       : input_offset - deleted_bytes);
+  (*this->section_offset_map_)[input_offset] = output_offset;
+}
+
+// Process EXIDX_INPUT_SECTION for EXIDX entry merging.  Return the number of
+// bytes deleted.  If some entries are merged, also store a pointer to a newly
+// created Arm_exidx_section_offset_map object in *PSECTION_OFFSET_MAP.  The
+// caller owns the map and is responsible for releasing it after use.
+
+template<bool big_endian>
+uint32_t
+Arm_exidx_fixup::process_exidx_section(
+    const Arm_exidx_input_section* exidx_input_section,
+    Arm_exidx_section_offset_map** psection_offset_map)
+{
+  Relobj* relobj = exidx_input_section->relobj();
+  unsigned shndx = exidx_input_section->shndx();
+  section_size_type section_size;
+  const unsigned char* section_contents =
+    relobj->section_contents(shndx, &section_size, false);
+
+  if ((section_size % 8) != 0)
+    {
+      // Something is wrong with this section.  Better not touch it.
+      gold_error(_("uneven .ARM.exidx section size in %s section %u"),
+		 relobj->name().c_str(), shndx);
+      this->last_input_section_ = exidx_input_section;
+      this->last_unwind_type_ = UT_NONE;
+      return 0;
+    }
+  
+  uint32_t deleted_bytes = 0;
+  bool prev_delete_entry = false;
+  gold_assert(this->section_offset_map_ == NULL);
+
+  for (section_size_type i = 0; i < section_size; i += 8)
+    {
+      typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
+      const Valtype* wv =
+	  reinterpret_cast<const Valtype*>(section_contents + i + 4);
+      uint32_t second_word = elfcpp::Swap<32, big_endian>::readval(wv);
+
+      bool delete_entry = this->process_exidx_entry(second_word);
+
+      // Entry deletion causes changes in output offsets.  We use a std::map
+      // to record these.  And entry (x, y) means input offset x
+      // is mapped to output offset y.  If y is invalid_offset, then x is
+      // dropped in the output.  Because of the way std::map::lower_bound
+      // works, we record the last offset in a region w.r.t to keeping or
+      // dropping.  If there is no entry (x0, y0) for an input offset x0,
+      // the output offset y0 of it is determined by the output offset y1 of
+      // the smallest input offset x1 > x0 that there is an (x1, y1) entry
+      // in the map.  If y1 is not -1, then y0 = y1 + x0 - x1.  Othewise, y1
+      // y0 is also -1.
+      if (delete_entry != prev_delete_entry && i != 0)
+	this->update_offset_map(i - 1, deleted_bytes, prev_delete_entry);
+
+      // Update total deleted bytes for this entry.
+      if (delete_entry)
+	deleted_bytes += 8;
+
+      prev_delete_entry = delete_entry;
+    }
+  
+  // If section offset map is not NULL, make an entry for the end of
+  // section.
+  if (this->section_offset_map_ != NULL)
+    update_offset_map(section_size - 1, deleted_bytes, prev_delete_entry);
+
+  *psection_offset_map = this->section_offset_map_;
+  this->section_offset_map_ = NULL;
+  this->last_input_section_ = exidx_input_section;
+  
+  return deleted_bytes;
+}
+
+// Arm_output_section methods.
+
+// Create a stub group for input sections from BEGIN to END.  OWNER
+// points to the input section to be the owner a new stub table.
+
+template<bool big_endian>
+void
+Arm_output_section<big_endian>::create_stub_group(
+  Input_section_list::const_iterator begin,
+  Input_section_list::const_iterator end,
+  Input_section_list::const_iterator owner,
+  Target_arm<big_endian>* target,
+  std::vector<Output_relaxed_input_section*>* new_relaxed_sections)
+{
+  // We use a different kind of relaxed section in an EXIDX section.
+  // The static casting from Output_relaxed_input_section to
+  // Arm_input_section is invalid in an EXIDX section.  We are okay
+  // because we should not be calling this for an EXIDX section. 
+  gold_assert(this->type() != elfcpp::SHT_ARM_EXIDX);
+
+  // Currently we convert ordinary input sections into relaxed sections only
+  // at this point but we may want to support creating relaxed input section
+  // very early.  So we check here to see if owner is already a relaxed
+  // section.
+  
+  Arm_input_section<big_endian>* arm_input_section;
+  if (owner->is_relaxed_input_section())
+    {
+      arm_input_section =
+	Arm_input_section<big_endian>::as_arm_input_section(
+	  owner->relaxed_input_section());
+    }
+  else
+    {
+      gold_assert(owner->is_input_section());
+      // Create a new relaxed input section.
+      arm_input_section =
+	target->new_arm_input_section(owner->relobj(), owner->shndx());
+      new_relaxed_sections->push_back(arm_input_section);
+    }
+
+  // Create a stub table.
+  Stub_table<big_endian>* stub_table =
+    target->new_stub_table(arm_input_section);
+
+  arm_input_section->set_stub_table(stub_table);
+  
+  Input_section_list::const_iterator p = begin;
+  Input_section_list::const_iterator prev_p;
+
+  // Look for input sections or relaxed input sections in [begin ... end].
+  do
+    {
+      if (p->is_input_section() || p->is_relaxed_input_section())
+	{
+	  // The stub table information for input sections live
+	  // in their objects.
+	  Arm_relobj<big_endian>* arm_relobj =
+	    Arm_relobj<big_endian>::as_arm_relobj(p->relobj());
+	  arm_relobj->set_stub_table(p->shndx(), stub_table);
+	}
+      prev_p = p++;
+    }
+  while (prev_p != end);
+}
+
+// Group input sections for stub generation.  GROUP_SIZE is roughly the limit
+// of stub groups.  We grow a stub group by adding input section until the
+// size is just below GROUP_SIZE.  The last input section will be converted
+// into a stub table.  If STUB_ALWAYS_AFTER_BRANCH is false, we also add
+// input section after the stub table, effectively double the group size.
+// 
+// This is similar to the group_sections() function in elf32-arm.c but is
+// implemented differently.
+
+template<bool big_endian>
+void
+Arm_output_section<big_endian>::group_sections(
+    section_size_type group_size,
+    bool stubs_always_after_branch,
+    Target_arm<big_endian>* target)
+{
+  // We only care about sections containing code.
+  if ((this->flags() & elfcpp::SHF_EXECINSTR) == 0)
+    return;
+
+  // States for grouping.
+  typedef enum
+  {
+    // No group is being built.
+    NO_GROUP,
+    // A group is being built but the stub table is not found yet.
+    // We keep group a stub group until the size is just under GROUP_SIZE.
+    // The last input section in the group will be used as the stub table.
+    FINDING_STUB_SECTION,
+    // A group is being built and we have already found a stub table.
+    // We enter this state to grow a stub group by adding input section
+    // after the stub table.  This effectively doubles the group size.
+    HAS_STUB_SECTION
+  } State;
+
+  // Any newly created relaxed sections are stored here.
+  std::vector<Output_relaxed_input_section*> new_relaxed_sections;
+
+  State state = NO_GROUP;
+  section_size_type off = 0;
+  section_size_type group_begin_offset = 0;
+  section_size_type group_end_offset = 0;
+  section_size_type stub_table_end_offset = 0;
+  Input_section_list::const_iterator group_begin =
+    this->input_sections().end();
+  Input_section_list::const_iterator stub_table =
+    this->input_sections().end();
+  Input_section_list::const_iterator group_end = this->input_sections().end();
+  for (Input_section_list::const_iterator p = this->input_sections().begin();
+       p != this->input_sections().end();
+       ++p)
+    {
+      section_size_type section_begin_offset =
+	align_address(off, p->addralign());
+      section_size_type section_end_offset =
+	section_begin_offset + p->data_size(); 
+      
+      // Check to see if we should group the previously seens sections.
+      switch (state)
+	{
+	case NO_GROUP:
+	  break;
+
+	case FINDING_STUB_SECTION:
+	  // Adding this section makes the group larger than GROUP_SIZE.
+	  if (section_end_offset - group_begin_offset >= group_size)
+	    {
+	      if (stubs_always_after_branch)
+		{	
+		  gold_assert(group_end != this->input_sections().end());
+		  this->create_stub_group(group_begin, group_end, group_end,
+					  target, &new_relaxed_sections);
+		  state = NO_GROUP;
+		}
+	      else
+		{
+		  // But wait, there's more!  Input sections up to
+		  // stub_group_size bytes after the stub table can be
+		  // handled by it too.
+		  state = HAS_STUB_SECTION;
+		  stub_table = group_end;
+		  stub_table_end_offset = group_end_offset;
+		}
+	    }
+	    break;
+
+	case HAS_STUB_SECTION:
+	  // Adding this section makes the post stub-section group larger
+	  // than GROUP_SIZE.
+	  if (section_end_offset - stub_table_end_offset >= group_size)
+	   {
+	     gold_assert(group_end != this->input_sections().end());
+	     this->create_stub_group(group_begin, group_end, stub_table,
+				     target, &new_relaxed_sections);
+	     state = NO_GROUP;
+	   }
+	   break;
+
+	  default:
+	    gold_unreachable();
+	}	
+
+      // If we see an input section and currently there is no group, start
+      // a new one.  Skip any empty sections.
+      if ((p->is_input_section() || p->is_relaxed_input_section())
+	  && (p->relobj()->section_size(p->shndx()) != 0))
+	{
+	  if (state == NO_GROUP)
+	    {
+	      state = FINDING_STUB_SECTION;
+	      group_begin = p;
+	      group_begin_offset = section_begin_offset;
+	    }
+
+	  // Keep track of the last input section seen.
+	  group_end = p;
+	  group_end_offset = section_end_offset;
+	}
+
+      off = section_end_offset;
+    }
+
+  // Create a stub group for any ungrouped sections.
+  if (state == FINDING_STUB_SECTION || state == HAS_STUB_SECTION)
+    {
+      gold_assert(group_end != this->input_sections().end());
+      this->create_stub_group(group_begin, group_end,
+			      (state == FINDING_STUB_SECTION
+			       ? group_end
+			       : stub_table),
+			       target, &new_relaxed_sections);
+    }
+
+  // Convert input section into relaxed input section in a batch.
+  if (!new_relaxed_sections.empty())
+    this->convert_input_sections_to_relaxed_sections(new_relaxed_sections);
+
+  // Update the section offsets
+  for (size_t i = 0; i < new_relaxed_sections.size(); ++i)
+    {
+      Arm_relobj<big_endian>* arm_relobj =
+	Arm_relobj<big_endian>::as_arm_relobj(
+	  new_relaxed_sections[i]->relobj());
+      unsigned int shndx = new_relaxed_sections[i]->shndx();
+      // Tell Arm_relobj that this input section is converted.
+      arm_relobj->convert_input_section_to_relaxed_section(shndx);
+    }
+}
+
+// Append non empty text sections in this to LIST in ascending
+// order of their position in this.
+
+template<bool big_endian>
+void
+Arm_output_section<big_endian>::append_text_sections_to_list(
+    Text_section_list* list)
+{
+  // We only care about text sections.
+  if ((this->flags() & elfcpp::SHF_EXECINSTR) == 0)
+    return;
+
+  gold_assert((this->flags() & elfcpp::SHF_ALLOC) != 0);
+
+  for (Input_section_list::const_iterator p = this->input_sections().begin();
+       p != this->input_sections().end();
+       ++p)
+    {
+      // We only care about plain or relaxed input sections.  We also
+      // ignore any merged sections.
+      if ((p->is_input_section() || p->is_relaxed_input_section())
+	  && p->data_size() != 0)
+	list->push_back(Text_section_list::value_type(p->relobj(),
+						      p->shndx()));
+    }
+}
+
+template<bool big_endian>
+void
+Arm_output_section<big_endian>::fix_exidx_coverage(
+    Layout* layout,
+    const Text_section_list& sorted_text_sections,
+    Symbol_table* symtab)
+{
+  // We should only do this for the EXIDX output section.
+  gold_assert(this->type() == elfcpp::SHT_ARM_EXIDX);
+
+  // We don't want the relaxation loop to undo these changes, so we discard
+  // the current saved states and take another one after the fix-up.
+  this->discard_states();
+
+  // Remove all input sections.
+  uint64_t address = this->address();
+  typedef std::list<Simple_input_section> Simple_input_section_list;
+  Simple_input_section_list input_sections;
+  this->reset_address_and_file_offset();
+  this->get_input_sections(address, std::string(""), &input_sections);
+
+  if (!this->input_sections().empty())
+    gold_error(_("Found non-EXIDX input sections in EXIDX output section"));
+  
+  // Go through all the known input sections and record them.
+  typedef Unordered_set<Section_id, Section_id_hash> Section_id_set;
+  Section_id_set known_input_sections;
+  for (Simple_input_section_list::const_iterator p = input_sections.begin();
+       p != input_sections.end();
+       ++p)
+    {
+      // This should never happen.  At this point, we should only see
+      // plain EXIDX input sections.
+      gold_assert(!p->is_relaxed_input_section());
+      known_input_sections.insert(Section_id(p->relobj(), p->shndx()));
+    }
+
+  Arm_exidx_fixup exidx_fixup(this);
+
+  // Go over the sorted text sections.
+  Section_id_set processed_input_sections;
+  for (Text_section_list::const_iterator p = sorted_text_sections.begin();
+       p != sorted_text_sections.end();
+       ++p)
+    {
+      Relobj* relobj = p->first;
+      unsigned int shndx = p->second;
+
+      Arm_relobj<big_endian>* arm_relobj =
+	 Arm_relobj<big_endian>::as_arm_relobj(relobj);
+      const Arm_exidx_input_section* exidx_input_section =
+	 arm_relobj->exidx_input_section_by_link(shndx);
+
+      // If this text section has no EXIDX section, force an EXIDX_CANTUNWIND
+      // entry pointing to the end of the last seen EXIDX section.
+      if (exidx_input_section == NULL)
+	{
+	  exidx_fixup.add_exidx_cantunwind_as_needed();
+	  continue;
+	}
+
+      Relobj* exidx_relobj = exidx_input_section->relobj();
+      unsigned int exidx_shndx = exidx_input_section->shndx();
+      Section_id sid(exidx_relobj, exidx_shndx);
+      if (known_input_sections.find(sid) == known_input_sections.end())
+	{
+	  // This is odd.  We have not seen this EXIDX input section before.
+	  // We cannot do fix-up.  If we saw a SECTIONS clause in a script,
+	  // issue a warning instead.  We assume the user knows what he
+	  // or she is doing.  Otherwise, this is an error.
+	  if (layout->script_options()->saw_sections_clause())
+	    gold_warning(_("unwinding may not work because EXIDX input section"
+			   " %u of %s is not in EXIDX output section"),
+			 exidx_shndx, exidx_relobj->name().c_str());
+	  else
+	    gold_error(_("unwinding may not work because EXIDX input section"
+			 " %u of %s is not in EXIDX output section"),
+		       exidx_shndx, exidx_relobj->name().c_str());
+
+	  exidx_fixup.add_exidx_cantunwind_as_needed();
+	  continue;
+	}
+
+      // Fix up coverage and append input section to output data list.
+      Arm_exidx_section_offset_map* section_offset_map = NULL;
+      uint32_t deleted_bytes =
+        exidx_fixup.process_exidx_section<big_endian>(exidx_input_section,
+						      &section_offset_map);
+
+      if (deleted_bytes == exidx_input_section->size())
+	{
+	  // The whole EXIDX section got merged.  Remove it from output.
+	  gold_assert(section_offset_map == NULL);
+	  exidx_relobj->set_output_section(exidx_shndx, NULL);
+
+	  // All local symbols defined in this input section will be dropped.
+	  // We need to adjust output local symbol count.
+	  arm_relobj->set_output_local_symbol_count_needs_update();
+	}
+      else if (deleted_bytes > 0)
+	{
+	  // Some entries are merged.  We need to convert this EXIDX input
+	  // section into a relaxed section.
+	  gold_assert(section_offset_map != NULL);
+	  Arm_exidx_merged_section* merged_section =
+	    new Arm_exidx_merged_section(*exidx_input_section,
+					 *section_offset_map, deleted_bytes);
+	  this->add_relaxed_input_section(merged_section);
+	  arm_relobj->convert_input_section_to_relaxed_section(exidx_shndx);
+
+	  // All local symbols defined in discarded portions of this input
+	  // section will be dropped.  We need to adjust output local symbol
+	  // count.
+	  arm_relobj->set_output_local_symbol_count_needs_update();
+	}
+      else
+	{
+	  // Just add back the EXIDX input section.
+	  gold_assert(section_offset_map == NULL);
+	  Output_section::Simple_input_section sis(exidx_relobj, exidx_shndx);
+	  this->add_simple_input_section(sis, exidx_input_section->size(),
+					 exidx_input_section->addralign());
+	}
+
+      processed_input_sections.insert(Section_id(exidx_relobj, exidx_shndx)); 
+    }
+
+  // Insert an EXIDX_CANTUNWIND entry at the end of output if necessary.
+  exidx_fixup.add_exidx_cantunwind_as_needed();
+
+  // Remove any known EXIDX input sections that are not processed.
+  for (Simple_input_section_list::const_iterator p = input_sections.begin();
+       p != input_sections.end();
+       ++p)
+    {
+      if (processed_input_sections.find(Section_id(p->relobj(), p->shndx()))
+	  == processed_input_sections.end())
+	{
+	  // We only discard a known EXIDX section because its linked
+	  // text section has been folded by ICF.
+	  Arm_relobj<big_endian>* arm_relobj =
+	    Arm_relobj<big_endian>::as_arm_relobj(p->relobj());
+	  const Arm_exidx_input_section* exidx_input_section =
+	    arm_relobj->exidx_input_section_by_shndx(p->shndx());
+	  gold_assert(exidx_input_section != NULL);
+	  unsigned int text_shndx = exidx_input_section->link();
+	  gold_assert(symtab->is_section_folded(p->relobj(), text_shndx));
+
+	  // Remove this from link.
+	  p->relobj()->set_output_section(p->shndx(), NULL);
+	}
+    }
+    
+  // Make changes permanent.
+  this->save_states();
+  this->set_section_offsets_need_adjustment();
+}
+
+// Arm_relobj methods.
+
+// Determine if we want to scan the SHNDX-th section for relocation stubs.
+// This is a helper for Arm_relobj::scan_sections_for_stubs() below.
+
+template<bool big_endian>
+bool
+Arm_relobj<big_endian>::section_needs_reloc_stub_scanning(
+    const elfcpp::Shdr<32, big_endian>& shdr,
+    const Relobj::Output_sections& out_sections,
+    const Symbol_table *symtab,
+    const unsigned char* pshdrs)
+{
+  unsigned int sh_type = shdr.get_sh_type();
+  if (sh_type != elfcpp::SHT_REL && sh_type != elfcpp::SHT_RELA)
+    return false;
+
+  // Ignore empty section.
+  off_t sh_size = shdr.get_sh_size();
+  if (sh_size == 0)
+    return false;
+
+  // Ignore reloc section with bad info.  This error will be
+  // reported in the final link.
+  unsigned int index = this->adjust_shndx(shdr.get_sh_info());
+  if (index >= this->shnum())
+    return false;
+
+  // This relocation section is against a section which we
+  // discarded or if the section is folded into another
+  // section due to ICF.
+  if (out_sections[index] == NULL || symtab->is_section_folded(this, index))
+    return false;
+
+  // Check the section to which relocations are applied.  Ignore relocations
+  // to unallocated sections or EXIDX sections.
+  const unsigned int shdr_size = elfcpp::Elf_sizes<32>::shdr_size;
+  const elfcpp::Shdr<32, big_endian> data_shdr(pshdrs + index * shdr_size);
+  if ((data_shdr.get_sh_flags() & elfcpp::SHF_ALLOC) == 0
+      || data_shdr.get_sh_type() == elfcpp::SHT_ARM_EXIDX)
+    return false;
+
+  // Ignore reloc section with unexpected symbol table.  The
+  // error will be reported in the final link.
+  if (this->adjust_shndx(shdr.get_sh_link()) != this->symtab_shndx())
+    return false;
+
+  const unsigned int reloc_size = (sh_type == elfcpp::SHT_REL
+				   ? elfcpp::Elf_sizes<32>::rel_size
+				   : elfcpp::Elf_sizes<32>::rela_size);
+
+  // Ignore reloc section with unexpected entsize or uneven size.
+  // The error will be reported in the final link.
+  if (reloc_size != shdr.get_sh_entsize() || sh_size % reloc_size != 0)
+    return false;
+
+  return true;
+}
+
+// Determine if we want to scan the SHNDX-th section for non-relocation stubs.
+// This is a helper for Arm_relobj::scan_sections_for_stubs() below.
+
+template<bool big_endian>
+bool
+Arm_relobj<big_endian>::section_needs_cortex_a8_stub_scanning(
+    const elfcpp::Shdr<32, big_endian>& shdr,
+    unsigned int shndx,
+    Output_section* os,
+    const Symbol_table* symtab)
+{
+  // We only scan non-empty code sections.
+  if ((shdr.get_sh_flags() & elfcpp::SHF_EXECINSTR) == 0
+      || shdr.get_sh_size() == 0)
+    return false;
+
+  // Ignore discarded or ICF'ed sections.
+  if (os == NULL || symtab->is_section_folded(this, shndx))
+    return false;
+  
+  // Find output address of section.
+  Arm_address address = os->output_address(this, shndx, 0);
+
+  // If the section does not cross any 4K-boundaries, it does not need to
+  // be scanned.
+  if ((address & ~0xfffU) == ((address + shdr.get_sh_size() - 1) & ~0xfffU))
+    return false;
+
+  return true;
+}
+
+// Scan a section for Cortex-A8 workaround.
+
+template<bool big_endian>
+void
+Arm_relobj<big_endian>::scan_section_for_cortex_a8_erratum(
+    const elfcpp::Shdr<32, big_endian>& shdr,
+    unsigned int shndx,
+    Output_section* os,
+    Target_arm<big_endian>* arm_target)
+{
+  Arm_address output_address = os->output_address(this, shndx, 0);
+
+  // Get the section contents.
+  section_size_type input_view_size = 0;
+  const unsigned char* input_view =
+    this->section_contents(shndx, &input_view_size, false);
+
+  // We need to go through the mapping symbols to determine what to
+  // scan.  There are two reasons.  First, we should look at THUMB code and
+  // THUMB code only.  Second, we only want to look at the 4K-page boundary
+  // to speed up the scanning.
+  
+  // Look for the first mapping symbol in this section.  It should be
+  // at (shndx, 0).
+  Mapping_symbol_position section_start(shndx, 0);
+  typename Mapping_symbols_info::const_iterator p =
+    this->mapping_symbols_info_.lower_bound(section_start);
+
+  if (p == this->mapping_symbols_info_.end()
+      || p->first != section_start)
+    {
+      gold_warning(_("Cortex-A8 erratum scanning failed because there "
+		     "is no mapping symbols for section %u of %s"),
+		   shndx, this->name().c_str());
+      return;
+    }
+ 
+  while (p != this->mapping_symbols_info_.end()
+	&& p->first.first == shndx)
+    {
+      typename Mapping_symbols_info::const_iterator next =
+	this->mapping_symbols_info_.upper_bound(p->first);
+
+      // Only scan part of a section with THUMB code.
+      if (p->second == 't')
+	{
+	  // Determine the end of this range.
+	  section_size_type span_start =
+	    convert_to_section_size_type(p->first.second);
+	  section_size_type span_end;
+	  if (next != this->mapping_symbols_info_.end()
+	      && next->first.first == shndx)
+	    span_end = convert_to_section_size_type(next->first.second);
+	  else
+	    span_end = convert_to_section_size_type(shdr.get_sh_size());
+	  
+	  if (((span_start + output_address) & ~0xfffUL)
+	      != ((span_end + output_address - 1) & ~0xfffUL))
+	    {
+	      arm_target->scan_span_for_cortex_a8_erratum(this, shndx,
+							  span_start, span_end,
+							  input_view,
+							  output_address);
+	    }
+	}
+
+      p = next; 
+    }
+}
+
+// Scan relocations for stub generation.
+
+template<bool big_endian>
+void
+Arm_relobj<big_endian>::scan_sections_for_stubs(
+    Target_arm<big_endian>* arm_target,
+    const Symbol_table* symtab,
+    const Layout* layout)
+{
+  unsigned int shnum = this->shnum();
+  const unsigned int shdr_size = elfcpp::Elf_sizes<32>::shdr_size;
+
+  // Read the section headers.
+  const unsigned char* pshdrs = this->get_view(this->elf_file()->shoff(),
+					       shnum * shdr_size,
+					       true, true);
+
+  // To speed up processing, we set up hash tables for fast lookup of
+  // input offsets to output addresses.
+  this->initialize_input_to_output_maps();
+
+  const Relobj::Output_sections& out_sections(this->output_sections());
+
+  Relocate_info<32, big_endian> relinfo;
+  relinfo.symtab = symtab;
+  relinfo.layout = layout;
+  relinfo.object = this;
+
+  // Do relocation stubs scanning.
+  const unsigned char* p = pshdrs + shdr_size;
+  for (unsigned int i = 1; i < shnum; ++i, p += shdr_size)
+    {
+      const elfcpp::Shdr<32, big_endian> shdr(p);
+      if (this->section_needs_reloc_stub_scanning(shdr, out_sections, symtab,
+						  pshdrs))
+	{
+	  unsigned int index = this->adjust_shndx(shdr.get_sh_info());
+	  Arm_address output_offset = this->get_output_section_offset(index);
+	  Arm_address output_address;
+	  if(output_offset != invalid_address)
+	    output_address = out_sections[index]->address() + output_offset;
+	  else
+	    {
+	      // Currently this only happens for a relaxed section.
+	      const Output_relaxed_input_section* poris =
+	      out_sections[index]->find_relaxed_input_section(this, index);
+	      gold_assert(poris != NULL);
+	      output_address = poris->address();
+	    }
+
+	  // Get the relocations.
+	  const unsigned char* prelocs = this->get_view(shdr.get_sh_offset(),
+							shdr.get_sh_size(),
+							true, false);
+
+	  // Get the section contents.  This does work for the case in which
+	  // we modify the contents of an input section.  We need to pass the
+	  // output view under such circumstances.
+	  section_size_type input_view_size = 0;
+	  const unsigned char* input_view =
+	    this->section_contents(index, &input_view_size, false);
+
+	  relinfo.reloc_shndx = i;
+	  relinfo.data_shndx = index;
+	  unsigned int sh_type = shdr.get_sh_type();
+	  const unsigned int reloc_size = (sh_type == elfcpp::SHT_REL
+					   ? elfcpp::Elf_sizes<32>::rel_size
+					   : elfcpp::Elf_sizes<32>::rela_size);
+
+	  Output_section* os = out_sections[index];
+	  arm_target->scan_section_for_stubs(&relinfo, sh_type, prelocs,
+					     shdr.get_sh_size() / reloc_size,
+					     os,
+					     output_offset == invalid_address,
+					     input_view, output_address,
+					     input_view_size);
+	}
+    }
+
+  // Do Cortex-A8 erratum stubs scanning.  This has to be done for a section
+  // after its relocation section, if there is one, is processed for
+  // relocation stubs.  Merging this loop with the one above would have been
+  // complicated since we would have had to make sure that relocation stub
+  // scanning is done first.
+  if (arm_target->fix_cortex_a8())
+    {
+      const unsigned char* p = pshdrs + shdr_size;
+      for (unsigned int i = 1; i < shnum; ++i, p += shdr_size)
+	{
+	  const elfcpp::Shdr<32, big_endian> shdr(p);
+	  if (this->section_needs_cortex_a8_stub_scanning(shdr, i,
+							  out_sections[i],
+							  symtab))
+	    this->scan_section_for_cortex_a8_erratum(shdr, i, out_sections[i],
+						     arm_target);
+	}
+    }
+
+  // After we've done the relocations, we release the hash tables,
+  // since we no longer need them.
+  this->free_input_to_output_maps();
+}
+
+// Count the local symbols.  The ARM backend needs to know if a symbol
+// is a THUMB function or not.  For global symbols, it is easy because
+// the Symbol object keeps the ELF symbol type.  For local symbol it is
+// harder because we cannot access this information.   So we override the
+// do_count_local_symbol in parent and scan local symbols to mark
+// THUMB functions.  This is not the most efficient way but I do not want to
+// slow down other ports by calling a per symbol targer hook inside
+// Sized_relobj<size, big_endian>::do_count_local_symbols. 
+
+template<bool big_endian>
+void
+Arm_relobj<big_endian>::do_count_local_symbols(
+    Stringpool_template<char>* pool,
+    Stringpool_template<char>* dynpool)
+{
+  // We need to fix-up the values of any local symbols whose type are
+  // STT_ARM_TFUNC.
+  
+  // Ask parent to count the local symbols.
+  Sized_relobj<32, big_endian>::do_count_local_symbols(pool, dynpool);
+  const unsigned int loccount = this->local_symbol_count();
+  if (loccount == 0)
+    return;
+
+  // Intialize the thumb function bit-vector.
+  std::vector<bool> empty_vector(loccount, false);
+  this->local_symbol_is_thumb_function_.swap(empty_vector);
+
+  // Read the symbol table section header.
+  const unsigned int symtab_shndx = this->symtab_shndx();
+  elfcpp::Shdr<32, big_endian>
+      symtabshdr(this, this->elf_file()->section_header(symtab_shndx));
+  gold_assert(symtabshdr.get_sh_type() == elfcpp::SHT_SYMTAB);
+
+  // Read the local symbols.
+  const int sym_size =elfcpp::Elf_sizes<32>::sym_size;
+  gold_assert(loccount == symtabshdr.get_sh_info());
+  off_t locsize = loccount * sym_size;
+  const unsigned char* psyms = this->get_view(symtabshdr.get_sh_offset(),
+					      locsize, true, true);
+
+  // For mapping symbol processing, we need to read the symbol names.
+  unsigned int strtab_shndx = this->adjust_shndx(symtabshdr.get_sh_link());
+  if (strtab_shndx >= this->shnum())
+    {
+      this->error(_("invalid symbol table name index: %u"), strtab_shndx);
+      return;
+    }
+
+  elfcpp::Shdr<32, big_endian>
+    strtabshdr(this, this->elf_file()->section_header(strtab_shndx));
+  if (strtabshdr.get_sh_type() != elfcpp::SHT_STRTAB)
+    {
+      this->error(_("symbol table name section has wrong type: %u"),
+	          static_cast<unsigned int>(strtabshdr.get_sh_type()));
+      return;
+    }
+  const char* pnames =
+    reinterpret_cast<const char*>(this->get_view(strtabshdr.get_sh_offset(),
+						 strtabshdr.get_sh_size(),
+						 false, false));
+
+  // Loop over the local symbols and mark any local symbols pointing
+  // to THUMB functions.
+
+  // Skip the first dummy symbol.
+  psyms += sym_size;
+  typename Sized_relobj<32, big_endian>::Local_values* plocal_values =
+    this->local_values();
+  for (unsigned int i = 1; i < loccount; ++i, psyms += sym_size)
+    {
+      elfcpp::Sym<32, big_endian> sym(psyms);
+      elfcpp::STT st_type = sym.get_st_type();
+      Symbol_value<32>& lv((*plocal_values)[i]);
+      Arm_address input_value = lv.input_value();
+
+      // Check to see if this is a mapping symbol.
+      const char* sym_name = pnames + sym.get_st_name();
+      if (Target_arm<big_endian>::is_mapping_symbol_name(sym_name))
+	{
+	  unsigned int input_shndx = sym.get_st_shndx();  
+
+	  // Strip of LSB in case this is a THUMB symbol.
+	  Mapping_symbol_position msp(input_shndx, input_value & ~1U);
+	  this->mapping_symbols_info_[msp] = sym_name[1];
+	}
+
+      if (st_type == elfcpp::STT_ARM_TFUNC
+	  || (st_type == elfcpp::STT_FUNC && ((input_value & 1) != 0)))
+	{
+	  // This is a THUMB function.  Mark this and canonicalize the
+	  // symbol value by setting LSB.
+	  this->local_symbol_is_thumb_function_[i] = true;
+	  if ((input_value & 1) == 0)
+	    lv.set_input_value(input_value | 1);
+	}
+    }
+}
+
+// Relocate sections.
+template<bool big_endian>
+void
+Arm_relobj<big_endian>::do_relocate_sections(
+    const Symbol_table* symtab,
+    const Layout* layout,
+    const unsigned char* pshdrs,
+    typename Sized_relobj<32, big_endian>::Views* pviews)
+{
+  // Call parent to relocate sections.
+  Sized_relobj<32, big_endian>::do_relocate_sections(symtab, layout, pshdrs,
+						     pviews); 
+
+  // We do not generate stubs if doing a relocatable link.
+  if (parameters->options().relocatable())
+    return;
+
+  // Relocate stub tables.
+  unsigned int shnum = this->shnum();
+
+  Target_arm<big_endian>* arm_target =
+    Target_arm<big_endian>::default_target();
+
+  Relocate_info<32, big_endian> relinfo;
+  relinfo.symtab = symtab;
+  relinfo.layout = layout;
+  relinfo.object = this;
+
+  for (unsigned int i = 1; i < shnum; ++i)
+    {
+      Arm_input_section<big_endian>* arm_input_section =
+	arm_target->find_arm_input_section(this, i);
+
+      if (arm_input_section != NULL
+	  && arm_input_section->is_stub_table_owner()
+	  && !arm_input_section->stub_table()->empty())
+	{
+	  // We cannot discard a section if it owns a stub table.
+	  Output_section* os = this->output_section(i);
+	  gold_assert(os != NULL);
+
+	  relinfo.reloc_shndx = elfcpp::SHN_UNDEF;
+	  relinfo.reloc_shdr = NULL;
+	  relinfo.data_shndx = i;
+	  relinfo.data_shdr = pshdrs + i * elfcpp::Elf_sizes<32>::shdr_size;
+
+	  gold_assert((*pviews)[i].view != NULL);
+
+	  // We are passed the output section view.  Adjust it to cover the
+	  // stub table only.
+	  Stub_table<big_endian>* stub_table = arm_input_section->stub_table();
+	  gold_assert((stub_table->address() >= (*pviews)[i].address)
+		      && ((stub_table->address() + stub_table->data_size())
+			  <= (*pviews)[i].address + (*pviews)[i].view_size));
+
+	  off_t offset = stub_table->address() - (*pviews)[i].address;
+	  unsigned char* view = (*pviews)[i].view + offset;
+	  Arm_address address = stub_table->address();
+	  section_size_type view_size = stub_table->data_size();
+ 
+	  stub_table->relocate_stubs(&relinfo, arm_target, os, view, address,
+				     view_size);
+	}
+
+      // Apply Cortex A8 workaround if applicable.
+      if (this->section_has_cortex_a8_workaround(i))
+	{
+	  unsigned char* view = (*pviews)[i].view;
+	  Arm_address view_address = (*pviews)[i].address;
+	  section_size_type view_size = (*pviews)[i].view_size;
+	  Stub_table<big_endian>* stub_table = this->stub_tables_[i];
+
+	  // Adjust view to cover section.
+	  Output_section* os = this->output_section(i);
+	  gold_assert(os != NULL);
+	  Arm_address section_address = os->output_address(this, i, 0);
+	  uint64_t section_size = this->section_size(i);
+
+	  gold_assert(section_address >= view_address
+		      && ((section_address + section_size)
+			  <= (view_address + view_size)));
+
+	  unsigned char* section_view = view + (section_address - view_address);
+
+	  // Apply the Cortex-A8 workaround to the output address range
+	  // corresponding to this input section.
+	  stub_table->apply_cortex_a8_workaround_to_address_range(
+	      arm_target,
+	      section_view,
+	      section_address,
+	      section_size);
+	}
+    }
+}
+
+// Create a new EXIDX input section object for EXIDX section SHNDX with
+// header SHDR.
+
+template<bool big_endian>
+void
+Arm_relobj<big_endian>::make_exidx_input_section(
+    unsigned int shndx,
+    const elfcpp::Shdr<32, big_endian>& shdr)
+{
+  // Link .text section to its .ARM.exidx section in the same object.
+  unsigned int text_shndx = this->adjust_shndx(shdr.get_sh_link());
+
+  // Issue an error and ignore this EXIDX section if it does not point
+  // to any text section.
+  if (text_shndx == elfcpp::SHN_UNDEF)
+    {
+      gold_error(_("EXIDX section %u in %s has no linked text section"),
+		 shndx, this->name().c_str());
+      return;
+    }
+  
+  // Issue an error and ignore this EXIDX section if it points to a text
+  // section already has an EXIDX section.
+  if (this->exidx_section_map_[text_shndx] != NULL)
+    {
+      gold_error(_("EXIDX sections %u and %u both link to text section %u "
+		   "in %s"),
+		 shndx, this->exidx_section_map_[text_shndx]->shndx(),
+		 text_shndx, this->name().c_str());
+      return;
+    }
+
+  // Create an Arm_exidx_input_section object for this EXIDX section.
+  Arm_exidx_input_section* exidx_input_section =
+    new Arm_exidx_input_section(this, shndx, text_shndx, shdr.get_sh_size(),
+				shdr.get_sh_addralign());
+  this->exidx_section_map_[text_shndx] = exidx_input_section;
+
+  // Also map the EXIDX section index to this.
+  gold_assert(this->exidx_section_map_[shndx] == NULL);
+  this->exidx_section_map_[shndx] = exidx_input_section;
+}
+
+// Read the symbol information.
+
+template<bool big_endian>
+void
+Arm_relobj<big_endian>::do_read_symbols(Read_symbols_data* sd)
+{
+  // Call parent class to read symbol information.
+  Sized_relobj<32, big_endian>::do_read_symbols(sd);
+
+  // Read processor-specific flags in ELF file header.
+  const unsigned char* pehdr = this->get_view(elfcpp::file_header_offset,
+					      elfcpp::Elf_sizes<32>::ehdr_size,
+					      true, false);
+  elfcpp::Ehdr<32, big_endian> ehdr(pehdr);
+  this->processor_specific_flags_ = ehdr.get_e_flags();
+
+  // Go over the section headers and look for .ARM.attributes and .ARM.exidx
+  // sections.
+  const size_t shdr_size = elfcpp::Elf_sizes<32>::shdr_size;
+  const unsigned char *ps =
+    sd->section_headers->data() + shdr_size;
+  for (unsigned int i = 1; i < this->shnum(); ++i, ps += shdr_size)
+    {
+      elfcpp::Shdr<32, big_endian> shdr(ps);
+      if (shdr.get_sh_type() == elfcpp::SHT_ARM_ATTRIBUTES)
+	{
+     	  gold_assert(this->attributes_section_data_ == NULL);
+	  section_offset_type section_offset = shdr.get_sh_offset();
+	  section_size_type section_size =
+	    convert_to_section_size_type(shdr.get_sh_size());
+	  File_view* view = this->get_lasting_view(section_offset,
+						   section_size, true, false);
+	  this->attributes_section_data_ =
+	    new Attributes_section_data(view->data(), section_size);
+	}
+      else if (shdr.get_sh_type() == elfcpp::SHT_ARM_EXIDX)
+	this->make_exidx_input_section(i, shdr);
+    }
+}
+
+// Process relocations for garbage collection.  The ARM target uses .ARM.exidx
+// sections for unwinding.  These sections are referenced implicitly by 
+// text sections linked in the section headers.  If we ignore these implict
+// references, the .ARM.exidx sections and any .ARM.extab sections they use
+// will be garbage-collected incorrectly.  Hence we override the same function
+// in the base class to handle these implicit references.
+
+template<bool big_endian>
+void
+Arm_relobj<big_endian>::do_gc_process_relocs(Symbol_table* symtab,
+					     Layout* layout,
+					     Read_relocs_data* rd)
+{
+  // First, call base class method to process relocations in this object.
+  Sized_relobj<32, big_endian>::do_gc_process_relocs(symtab, layout, rd);
+
+  // If --gc-sections is not specified, there is nothing more to do.
+  // This happens when --icf is used but --gc-sections is not.
+  if (!parameters->options().gc_sections())
+    return;
+  
+  unsigned int shnum = this->shnum();
+  const unsigned int shdr_size = elfcpp::Elf_sizes<32>::shdr_size;
+  const unsigned char* pshdrs = this->get_view(this->elf_file()->shoff(),
+					       shnum * shdr_size,
+					       true, true);
+
+  // Scan section headers for sections of type SHT_ARM_EXIDX.  Add references
+  // to these from the linked text sections.
+  const unsigned char* ps = pshdrs + shdr_size;
+  for (unsigned int i = 1; i < shnum; ++i, ps += shdr_size)
+    {
+      elfcpp::Shdr<32, big_endian> shdr(ps);
+      if (shdr.get_sh_type() == elfcpp::SHT_ARM_EXIDX)
+	{
+	  // Found an .ARM.exidx section, add it to the set of reachable
+	  // sections from its linked text section.
+	  unsigned int text_shndx = this->adjust_shndx(shdr.get_sh_link());
+	  symtab->gc()->add_reference(this, text_shndx, this, i);
+	}
+    }
+}
+
+// Update output local symbol count.  Owing to EXIDX entry merging, some local
+// symbols  will be removed in output.  Adjust output local symbol count
+// accordingly.  We can only changed the static output local symbol count.  It
+// is too late to change the dynamic symbols.
+
+template<bool big_endian>
+void
+Arm_relobj<big_endian>::update_output_local_symbol_count()
+{
+  // Caller should check that this needs updating.  We want caller checking
+  // because output_local_symbol_count_needs_update() is most likely inlined.
+  gold_assert(this->output_local_symbol_count_needs_update_);
+
+  gold_assert(this->symtab_shndx() != -1U);
+  if (this->symtab_shndx() == 0)
+    {
+      // This object has no symbols.  Weird but legal.
+      return;
+    }
+
+  // Read the symbol table section header.
+  const unsigned int symtab_shndx = this->symtab_shndx();
+  elfcpp::Shdr<32, big_endian>
+    symtabshdr(this, this->elf_file()->section_header(symtab_shndx));
+  gold_assert(symtabshdr.get_sh_type() == elfcpp::SHT_SYMTAB);
+
+  // Read the local symbols.
+  const int sym_size = elfcpp::Elf_sizes<32>::sym_size;
+  const unsigned int loccount = this->local_symbol_count();
+  gold_assert(loccount == symtabshdr.get_sh_info());
+  off_t locsize = loccount * sym_size;
+  const unsigned char* psyms = this->get_view(symtabshdr.get_sh_offset(),
+					      locsize, true, true);
+
+  // Loop over the local symbols.
+
+  typedef typename Sized_relobj<32, big_endian>::Output_sections
+     Output_sections;
+  const Output_sections& out_sections(this->output_sections());
+  unsigned int shnum = this->shnum();
+  unsigned int count = 0;
+  // Skip the first, dummy, symbol.
+  psyms += sym_size;
+  for (unsigned int i = 1; i < loccount; ++i, psyms += sym_size)
+    {
+      elfcpp::Sym<32, big_endian> sym(psyms);
+
+      Symbol_value<32>& lv((*this->local_values())[i]);
+
+      // This local symbol was already discarded by do_count_local_symbols.
+      if (!lv.needs_output_symtab_entry())
+	continue;
+
+      bool is_ordinary;
+      unsigned int shndx = this->adjust_sym_shndx(i, sym.get_st_shndx(),
+						  &is_ordinary);
+
+      if (shndx < shnum)
+	{
+	  Output_section* os = out_sections[shndx];
+
+	  // This local symbol no longer has an output section.  Discard it.
+	  if (os == NULL)
+	    {
+	      lv.set_no_output_symtab_entry();
+	      continue;
+	    }
+
+	  // Currently we only discard parts of EXIDX input sections.
+	  // We explicitly check for a merged EXIDX input section to avoid
+	  // calling Output_section_data::output_offset unless necessary.
+	  if ((this->get_output_section_offset(shndx) == invalid_address)
+	      && (this->exidx_input_section_by_shndx(shndx) != NULL))
+	    {
+	      section_offset_type output_offset =
+		os->output_offset(this, shndx, lv.input_value());
+	      if (output_offset == -1)
+		{
+		  // This symbol is defined in a part of an EXIDX input section
+		  // that is discarded due to entry merging.
+		  lv.set_no_output_symtab_entry();
+		  continue;
+		}	
+	    }
+	}
+
+      ++count;
+    }
+
+  this->set_output_local_symbol_count(count);
+  this->output_local_symbol_count_needs_update_ = false;
+}
+
+// Arm_dynobj methods.
+
+// Read the symbol information.
+
+template<bool big_endian>
+void
+Arm_dynobj<big_endian>::do_read_symbols(Read_symbols_data* sd)
+{
+  // Call parent class to read symbol information.
+  Sized_dynobj<32, big_endian>::do_read_symbols(sd);
+
+  // Read processor-specific flags in ELF file header.
+  const unsigned char* pehdr = this->get_view(elfcpp::file_header_offset,
+					      elfcpp::Elf_sizes<32>::ehdr_size,
+					      true, false);
+  elfcpp::Ehdr<32, big_endian> ehdr(pehdr);
+  this->processor_specific_flags_ = ehdr.get_e_flags();
+
+  // Read the attributes section if there is one.
+  // We read from the end because gas seems to put it near the end of
+  // the section headers.
+  const size_t shdr_size = elfcpp::Elf_sizes<32>::shdr_size;
+  const unsigned char *ps =
+    sd->section_headers->data() + shdr_size * (this->shnum() - 1);
+  for (unsigned int i = this->shnum(); i > 0; --i, ps -= shdr_size)
+    {
+      elfcpp::Shdr<32, big_endian> shdr(ps);
+      if (shdr.get_sh_type() == elfcpp::SHT_ARM_ATTRIBUTES)
+	{
+	  section_offset_type section_offset = shdr.get_sh_offset();
+	  section_size_type section_size =
+	    convert_to_section_size_type(shdr.get_sh_size());
+	  File_view* view = this->get_lasting_view(section_offset,
+						   section_size, true, false);
+	  this->attributes_section_data_ =
+	    new Attributes_section_data(view->data(), section_size);
+	  break;
+	}
+    }
+}
+
+// Stub_addend_reader methods.
+
+// Read the addend of a REL relocation of type R_TYPE at VIEW.
+
+template<bool big_endian>
+elfcpp::Elf_types<32>::Elf_Swxword
+Stub_addend_reader<elfcpp::SHT_REL, big_endian>::operator()(
+    unsigned int r_type,
+    const unsigned char* view,
+    const typename Reloc_types<elfcpp::SHT_REL, 32, big_endian>::Reloc&) const
+{
+  typedef struct Arm_relocate_functions<big_endian> RelocFuncs;
+  
+  switch (r_type)
+    {
+    case elfcpp::R_ARM_CALL:
+    case elfcpp::R_ARM_JUMP24:
+    case elfcpp::R_ARM_PLT32:
+      {
+	typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
+	const Valtype* wv = reinterpret_cast<const Valtype*>(view);
+	Valtype val = elfcpp::Swap<32, big_endian>::readval(wv);
+	return utils::sign_extend<26>(val << 2);
+      }
+
+    case elfcpp::R_ARM_THM_CALL:
+    case elfcpp::R_ARM_THM_JUMP24:
+    case elfcpp::R_ARM_THM_XPC22:
+      {
+	typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
+	const Valtype* wv = reinterpret_cast<const Valtype*>(view);
+	Valtype upper_insn = elfcpp::Swap<16, big_endian>::readval(wv);
+	Valtype lower_insn = elfcpp::Swap<16, big_endian>::readval(wv + 1);
+	return RelocFuncs::thumb32_branch_offset(upper_insn, lower_insn);
+      }
+
+    case elfcpp::R_ARM_THM_JUMP19:
+      {
+	typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
+	const Valtype* wv = reinterpret_cast<const Valtype*>(view);
+	Valtype upper_insn = elfcpp::Swap<16, big_endian>::readval(wv);
+	Valtype lower_insn = elfcpp::Swap<16, big_endian>::readval(wv + 1);
+	return RelocFuncs::thumb32_cond_branch_offset(upper_insn, lower_insn);
+      }
+
+    default:
+      gold_unreachable();
+    }
+}
+
+// Arm_output_data_got methods.
+
+// Add a GOT pair for R_ARM_TLS_GD32.  The creates a pair of GOT entries.
+// The first one is initialized to be 1, which is the module index for
+// the main executable and the second one 0.  A reloc of the type
+// R_ARM_TLS_DTPOFF32 will be created for the second GOT entry and will
+// be applied by gold.  GSYM is a global symbol.
+//
+template<bool big_endian>
+void
+Arm_output_data_got<big_endian>::add_tls_gd32_with_static_reloc(
+    unsigned int got_type,
+    Symbol* gsym)
+{
+  if (gsym->has_got_offset(got_type))
+    return;
+
+  // We are doing a static link.  Just mark it as belong to module 1,
+  // the executable.
+  unsigned int got_offset = this->add_constant(1);
+  gsym->set_got_offset(got_type, got_offset); 
+  got_offset = this->add_constant(0);
+  this->static_relocs_.push_back(Static_reloc(got_offset,
+					      elfcpp::R_ARM_TLS_DTPOFF32,
+					      gsym));
+}
+
+// Same as the above but for a local symbol.
+
+template<bool big_endian>
+void
+Arm_output_data_got<big_endian>::add_tls_gd32_with_static_reloc(
+  unsigned int got_type,
+  Sized_relobj<32, big_endian>* object,
+  unsigned int index)
+{
+  if (object->local_has_got_offset(index, got_type))
+    return;
+
+  // We are doing a static link.  Just mark it as belong to module 1,
+  // the executable.
+  unsigned int got_offset = this->add_constant(1);
+  object->set_local_got_offset(index, got_type, got_offset);
+  got_offset = this->add_constant(0);
+  this->static_relocs_.push_back(Static_reloc(got_offset, 
+					      elfcpp::R_ARM_TLS_DTPOFF32, 
+					      object, index));
+}
+
+template<bool big_endian>
+void
+Arm_output_data_got<big_endian>::do_write(Output_file* of)
+{
+  // Call parent to write out GOT.
+  Output_data_got<32, big_endian>::do_write(of);
+
+  // We are done if there is no fix up.
+  if (this->static_relocs_.empty())
+    return;
+
+  gold_assert(parameters->doing_static_link());
+
+  const off_t offset = this->offset();
+  const section_size_type oview_size =
+    convert_to_section_size_type(this->data_size());
+  unsigned char* const oview = of->get_output_view(offset, oview_size);
+
+  Output_segment* tls_segment = this->layout_->tls_segment();
+  gold_assert(tls_segment != NULL);
+  
+  // The thread pointer $tp points to the TCB, which is followed by the
+  // TLS.  So we need to adjust $tp relative addressing by this amount.
+  Arm_address aligned_tcb_size =
+    align_address(ARM_TCB_SIZE, tls_segment->maximum_alignment());
+
+  for (size_t i = 0; i < this->static_relocs_.size(); ++i)
+    {
+      Static_reloc& reloc(this->static_relocs_[i]);
+      
+      Arm_address value;
+      if (!reloc.symbol_is_global())
+	{
+	  Sized_relobj<32, big_endian>* object = reloc.relobj();
+	  const Symbol_value<32>* psymval =
+	    reloc.relobj()->local_symbol(reloc.index());
+
+	  // We are doing static linking.  Issue an error and skip this
+	  // relocation if the symbol is undefined or in a discarded_section.
+	  bool is_ordinary;
+	  unsigned int shndx = psymval->input_shndx(&is_ordinary);
+	  if ((shndx == elfcpp::SHN_UNDEF)
+	      || (is_ordinary
+		  && shndx != elfcpp::SHN_UNDEF
+		  && !object->is_section_included(shndx)
+		  && !this->symbol_table_->is_section_folded(object, shndx)))
+	    {
+	      gold_error(_("undefined or discarded local symbol %u from "
+			   " object %s in GOT"),
+			 reloc.index(), reloc.relobj()->name().c_str());
+	      continue;
+	    }
+	  
+	  value = psymval->value(object, 0);
+	}
+      else
+	{
+	  const Symbol* gsym = reloc.symbol();
+	  gold_assert(gsym != NULL);
+	  if (gsym->is_forwarder())
+	    gsym = this->symbol_table_->resolve_forwards(gsym);
+
+	  // We are doing static linking.  Issue an error and skip this
+	  // relocation if the symbol is undefined or in a discarded_section
+	  // unless it is a weakly_undefined symbol.
+	  if ((gsym->is_defined_in_discarded_section()
+	       || gsym->is_undefined())
+	      && !gsym->is_weak_undefined())
+	    {
+	      gold_error(_("undefined or discarded symbol %s in GOT"),
+			 gsym->name());
+	      continue;
+	    }
+
+	  if (!gsym->is_weak_undefined())
+	    {
+	      const Sized_symbol<32>* sym =
+		static_cast<const Sized_symbol<32>*>(gsym);
+	      value = sym->value();
+	    }
+	  else
+	      value = 0;
+	}
+
+      unsigned got_offset = reloc.got_offset();
+      gold_assert(got_offset < oview_size);
+
+      typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
+      Valtype* wv = reinterpret_cast<Valtype*>(oview + got_offset);
+      Valtype x;
+      switch (reloc.r_type())
+	{
+	case elfcpp::R_ARM_TLS_DTPOFF32:
+	  x = value;
+	  break;
+	case elfcpp::R_ARM_TLS_TPOFF32:
+	  x = value + aligned_tcb_size;
+	  break;
+	default:
+	  gold_unreachable();
+	}
+      elfcpp::Swap<32, big_endian>::writeval(wv, x);
+    }
+
+  of->write_output_view(offset, oview_size, oview);
+}
+
 // A class to handle the PLT data.
 
 template<bool big_endian>
@@ -1186,7 +6712,8 @@ Output_data_plt_arm<big_endian>::Output_data_plt_arm(Layout* layout,
 {
   this->rel_ = new Reloc_section(false);
   layout->add_output_section_data(".rel.plt", elfcpp::SHT_REL,
-				  elfcpp::SHF_ALLOC, this->rel_);
+				  elfcpp::SHF_ALLOC, this->rel_, true, false,
+				  false, false);
 }
 
 template<bool big_endian>
@@ -1274,8 +6801,8 @@ Output_data_plt_arm<big_endian>::do_write(Output_file* of)
 						      got_size);
   unsigned char* pov = oview;
 
-  elfcpp::Elf_types<32>::Elf_Addr plt_address = this->address();
-  elfcpp::Elf_types<32>::Elf_Addr got_address = this->got_plt_->address();
+  Arm_address plt_address = this->address();
+  Arm_address got_address = this->got_plt_->address();
 
   // Write first PLT entry.  All but the last word are constants.
   const size_t num_first_plt_words = (sizeof(first_plt_entry)
@@ -1348,11 +6875,95 @@ Target_arm<big_endian>::make_plt_entry(Symbol_table* symtab, Layout* layout,
       layout->add_output_section_data(".plt", elfcpp::SHT_PROGBITS,
 				      (elfcpp::SHF_ALLOC
 				       | elfcpp::SHF_EXECINSTR),
-				      this->plt_);
+				      this->plt_, false, false, false, false);
     }
   this->plt_->add_entry(gsym);
 }
 
+// Get the section to use for TLS_DESC relocations.
+
+template<bool big_endian>
+typename Target_arm<big_endian>::Reloc_section*
+Target_arm<big_endian>::rel_tls_desc_section(Layout* layout) const
+{
+  return this->plt_section()->rel_tls_desc(layout);
+}
+
+// Define the _TLS_MODULE_BASE_ symbol in the TLS segment.
+
+template<bool big_endian>
+void
+Target_arm<big_endian>::define_tls_base_symbol(
+    Symbol_table* symtab,
+    Layout* layout)
+{
+  if (this->tls_base_symbol_defined_)
+    return;
+
+  Output_segment* tls_segment = layout->tls_segment();
+  if (tls_segment != NULL)
+    {
+      bool is_exec = parameters->options().output_is_executable();
+      symtab->define_in_output_segment("_TLS_MODULE_BASE_", NULL,
+				       Symbol_table::PREDEFINED,
+				       tls_segment, 0, 0,
+				       elfcpp::STT_TLS,
+				       elfcpp::STB_LOCAL,
+				       elfcpp::STV_HIDDEN, 0,
+				       (is_exec
+					? Symbol::SEGMENT_END
+					: Symbol::SEGMENT_START),
+				       true);
+    }
+  this->tls_base_symbol_defined_ = true;
+}
+
+// Create a GOT entry for the TLS module index.
+
+template<bool big_endian>
+unsigned int
+Target_arm<big_endian>::got_mod_index_entry(
+    Symbol_table* symtab,
+    Layout* layout,
+    Sized_relobj<32, big_endian>* object)
+{
+  if (this->got_mod_index_offset_ == -1U)
+    {
+      gold_assert(symtab != NULL && layout != NULL && object != NULL);
+      Arm_output_data_got<big_endian>* got = this->got_section(symtab, layout);
+      unsigned int got_offset;
+      if (!parameters->doing_static_link())
+	{
+	  got_offset = got->add_constant(0);
+	  Reloc_section* rel_dyn = this->rel_dyn_section(layout);
+	  rel_dyn->add_local(object, 0, elfcpp::R_ARM_TLS_DTPMOD32, got,
+			     got_offset);
+	}
+      else
+	{
+	  // We are doing a static link.  Just mark it as belong to module 1,
+	  // the executable.
+	  got_offset = got->add_constant(1);
+	}
+
+      got->add_constant(0);
+      this->got_mod_index_offset_ = got_offset;
+    }
+  return this->got_mod_index_offset_;
+}
+
+// Optimize the TLS relocation type based on what we know about the
+// symbol.  IS_FINAL is true if the final address of this symbol is
+// known at link time.
+
+template<bool big_endian>
+tls::Tls_optimization
+Target_arm<big_endian>::optimize_tls_reloc(bool, int)
+{
+  // FIXME: Currently we do not do any TLS optimization.
+  return tls::TLSOPT_NONE;
+}
+
 // Report an unsupported relocation against a local symbol.
 
 template<bool big_endian>
@@ -1417,8 +7028,7 @@ Target_arm<big_endian>::Scan::check_non_pic(Relobj* object,
 
 template<bool big_endian>
 inline void
-Target_arm<big_endian>::Scan::local(const General_options&,
-				    Symbol_table* symtab,
+Target_arm<big_endian>::Scan::local(Symbol_table* symtab,
 				    Layout* layout,
 				    Target_arm* target,
 				    Sized_relobj<32, big_endian>* object,
@@ -1426,12 +7036,15 @@ Target_arm<big_endian>::Scan::local(const General_options&,
 				    Output_section* output_section,
 				    const elfcpp::Rel<32, big_endian>& reloc,
 				    unsigned int r_type,
-				    const elfcpp::Sym<32, big_endian>&)
+				    const elfcpp::Sym<32, big_endian>& lsym)
 {
   r_type = get_real_reloc_type(r_type);
   switch (r_type)
     {
     case elfcpp::R_ARM_NONE:
+    case elfcpp::R_ARM_V4BX:
+    case elfcpp::R_ARM_GNU_VTENTRY:
+    case elfcpp::R_ARM_GNU_VTINHERIT:
       break;
 
     case elfcpp::R_ARM_ABS32:
@@ -1454,41 +7067,121 @@ Target_arm<big_endian>::Scan::local(const General_options&,
 	}
       break;
 
-    case elfcpp::R_ARM_REL32:
-    case elfcpp::R_ARM_THM_CALL:
-    case elfcpp::R_ARM_CALL:
-    case elfcpp::R_ARM_PREL31:
-    case elfcpp::R_ARM_JUMP24:
-    case elfcpp::R_ARM_PLT32:
+    case elfcpp::R_ARM_ABS16:
+    case elfcpp::R_ARM_ABS12:
     case elfcpp::R_ARM_THM_ABS5:
     case elfcpp::R_ARM_ABS8:
-    case elfcpp::R_ARM_ABS12:
-    case elfcpp::R_ARM_ABS16:
     case elfcpp::R_ARM_BASE_ABS:
     case elfcpp::R_ARM_MOVW_ABS_NC:
     case elfcpp::R_ARM_MOVT_ABS:
     case elfcpp::R_ARM_THM_MOVW_ABS_NC:
     case elfcpp::R_ARM_THM_MOVT_ABS:
+      // If building a shared library (or a position-independent
+      // executable), we need to create a dynamic relocation for
+      // this location. Because the addend needs to remain in the
+      // data section, we need to be careful not to apply this
+      // relocation statically.
+      if (parameters->options().output_is_position_independent())
+        {
+	  check_non_pic(object, r_type);
+          Reloc_section* rel_dyn = target->rel_dyn_section(layout);
+	  unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
+          if (lsym.get_st_type() != elfcpp::STT_SECTION)
+	    rel_dyn->add_local(object, r_sym, r_type, output_section,
+			       data_shndx, reloc.get_r_offset());
+          else
+            {
+              gold_assert(lsym.get_st_value() == 0);
+	      unsigned int shndx = lsym.get_st_shndx();
+	      bool is_ordinary;
+	      shndx = object->adjust_sym_shndx(r_sym, shndx,
+					       &is_ordinary);
+	      if (!is_ordinary)
+		object->error(_("section symbol %u has bad shndx %u"),
+			      r_sym, shndx);
+	      else
+		rel_dyn->add_local_section(object, shndx,
+					   r_type, output_section,
+					   data_shndx, reloc.get_r_offset());
+            }
+        }
+      break;
+
+    case elfcpp::R_ARM_PC24:
+    case elfcpp::R_ARM_REL32:
+    case elfcpp::R_ARM_LDR_PC_G0:
+    case elfcpp::R_ARM_SBREL32:
+    case elfcpp::R_ARM_THM_CALL:
+    case elfcpp::R_ARM_THM_PC8:
+    case elfcpp::R_ARM_BASE_PREL:
+    case elfcpp::R_ARM_PLT32:
+    case elfcpp::R_ARM_CALL:
+    case elfcpp::R_ARM_JUMP24:
+    case elfcpp::R_ARM_THM_JUMP24:
+    case elfcpp::R_ARM_LDR_SBREL_11_0_NC:
+    case elfcpp::R_ARM_ALU_SBREL_19_12_NC:
+    case elfcpp::R_ARM_ALU_SBREL_27_20_CK:
+    case elfcpp::R_ARM_SBREL31:
+    case elfcpp::R_ARM_PREL31:
     case elfcpp::R_ARM_MOVW_PREL_NC:
     case elfcpp::R_ARM_MOVT_PREL:
     case elfcpp::R_ARM_THM_MOVW_PREL_NC:
     case elfcpp::R_ARM_THM_MOVT_PREL:
+    case elfcpp::R_ARM_THM_JUMP19:
+    case elfcpp::R_ARM_THM_JUMP6:
+    case elfcpp::R_ARM_THM_ALU_PREL_11_0:
+    case elfcpp::R_ARM_THM_PC12:
+    case elfcpp::R_ARM_REL32_NOI:
+    case elfcpp::R_ARM_ALU_PC_G0_NC:
+    case elfcpp::R_ARM_ALU_PC_G0:
+    case elfcpp::R_ARM_ALU_PC_G1_NC:
+    case elfcpp::R_ARM_ALU_PC_G1:
+    case elfcpp::R_ARM_ALU_PC_G2:
+    case elfcpp::R_ARM_LDR_PC_G1:
+    case elfcpp::R_ARM_LDR_PC_G2:
+    case elfcpp::R_ARM_LDRS_PC_G0:
+    case elfcpp::R_ARM_LDRS_PC_G1:
+    case elfcpp::R_ARM_LDRS_PC_G2:
+    case elfcpp::R_ARM_LDC_PC_G0:
+    case elfcpp::R_ARM_LDC_PC_G1:
+    case elfcpp::R_ARM_LDC_PC_G2:
+    case elfcpp::R_ARM_ALU_SB_G0_NC:
+    case elfcpp::R_ARM_ALU_SB_G0:
+    case elfcpp::R_ARM_ALU_SB_G1_NC:
+    case elfcpp::R_ARM_ALU_SB_G1:
+    case elfcpp::R_ARM_ALU_SB_G2:
+    case elfcpp::R_ARM_LDR_SB_G0:
+    case elfcpp::R_ARM_LDR_SB_G1:
+    case elfcpp::R_ARM_LDR_SB_G2:
+    case elfcpp::R_ARM_LDRS_SB_G0:
+    case elfcpp::R_ARM_LDRS_SB_G1:
+    case elfcpp::R_ARM_LDRS_SB_G2:
+    case elfcpp::R_ARM_LDC_SB_G0:
+    case elfcpp::R_ARM_LDC_SB_G1:
+    case elfcpp::R_ARM_LDC_SB_G2:
+    case elfcpp::R_ARM_MOVW_BREL_NC:
+    case elfcpp::R_ARM_MOVT_BREL:
+    case elfcpp::R_ARM_MOVW_BREL:
+    case elfcpp::R_ARM_THM_MOVW_BREL_NC:
+    case elfcpp::R_ARM_THM_MOVT_BREL:
+    case elfcpp::R_ARM_THM_MOVW_BREL:
+    case elfcpp::R_ARM_THM_JUMP11:
+    case elfcpp::R_ARM_THM_JUMP8:
+      // We don't need to do anything for a relative addressing relocation
+      // against a local symbol if it does not reference the GOT.
       break;
 
     case elfcpp::R_ARM_GOTOFF32:
+    case elfcpp::R_ARM_GOTOFF12:
       // We need a GOT section:
       target->got_section(symtab, layout);
       break;
 
-    case elfcpp::R_ARM_BASE_PREL:
-      // FIXME: What about this?
-      break;
-
     case elfcpp::R_ARM_GOT_BREL:
     case elfcpp::R_ARM_GOT_PREL:
       {
 	// The symbol requires a GOT entry.
-	Output_data_got<32, big_endian>* got =
+	Arm_output_data_got<big_endian>* got =
 	  target->got_section(symtab, layout);
 	unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
 	if (got->add_local(object, r_sym, GOT_TYPE_STANDARD))
@@ -1508,6 +7201,7 @@ Target_arm<big_endian>::Scan::local(const General_options&,
       break;
 
     case elfcpp::R_ARM_TARGET1:
+    case elfcpp::R_ARM_TARGET2:
       // This should have been mapped to another type already.
       // Fall through.
     case elfcpp::R_ARM_COPY:
@@ -1520,6 +7214,116 @@ Target_arm<big_endian>::Scan::local(const General_options&,
 		 object->name().c_str(), r_type);
       break;
 
+
+      // These are initial TLS relocs, which are expected when
+      // linking.
+    case elfcpp::R_ARM_TLS_GD32:	// Global-dynamic
+    case elfcpp::R_ARM_TLS_LDM32:	// Local-dynamic
+    case elfcpp::R_ARM_TLS_LDO32:	// Alternate local-dynamic
+    case elfcpp::R_ARM_TLS_IE32:	// Initial-exec
+    case elfcpp::R_ARM_TLS_LE32:	// Local-exec
+      {
+	bool output_is_shared = parameters->options().shared();
+	const tls::Tls_optimization optimized_type
+            = Target_arm<big_endian>::optimize_tls_reloc(!output_is_shared,
+							 r_type);
+	switch (r_type)
+	  {
+	  case elfcpp::R_ARM_TLS_GD32:		// Global-dynamic
+	    if (optimized_type == tls::TLSOPT_NONE)
+	      {
+	        // Create a pair of GOT entries for the module index and
+	        // dtv-relative offset.
+                Arm_output_data_got<big_endian>* got
+                    = target->got_section(symtab, layout);
+                unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
+		unsigned int shndx = lsym.get_st_shndx();
+		bool is_ordinary;
+		shndx = object->adjust_sym_shndx(r_sym, shndx, &is_ordinary);
+		if (!is_ordinary)
+		  {
+		    object->error(_("local symbol %u has bad shndx %u"),
+				  r_sym, shndx);
+		    break;
+		  }
+
+		if (!parameters->doing_static_link())
+		  got->add_local_pair_with_rel(object, r_sym, shndx,
+					       GOT_TYPE_TLS_PAIR,
+					       target->rel_dyn_section(layout),
+					       elfcpp::R_ARM_TLS_DTPMOD32, 0);
+		else
+		  got->add_tls_gd32_with_static_reloc(GOT_TYPE_TLS_PAIR,
+						      object, r_sym);
+	      }
+	    else
+	      // FIXME: TLS optimization not supported yet.
+	      gold_unreachable();
+	    break;
+
+	  case elfcpp::R_ARM_TLS_LDM32:		// Local-dynamic
+	    if (optimized_type == tls::TLSOPT_NONE)
+	      {
+	        // Create a GOT entry for the module index.
+	        target->got_mod_index_entry(symtab, layout, object);
+	      }
+	    else
+	      // FIXME: TLS optimization not supported yet.
+	      gold_unreachable();
+	    break;
+
+	  case elfcpp::R_ARM_TLS_LDO32:		// Alternate local-dynamic
+	    break;
+
+	  case elfcpp::R_ARM_TLS_IE32:		// Initial-exec
+	    layout->set_has_static_tls();
+	    if (optimized_type == tls::TLSOPT_NONE)
+	      {
+		// Create a GOT entry for the tp-relative offset.
+		Arm_output_data_got<big_endian>* got
+		  = target->got_section(symtab, layout);
+		unsigned int r_sym =
+		   elfcpp::elf_r_sym<32>(reloc.get_r_info());
+		if (!parameters->doing_static_link())
+		    got->add_local_with_rel(object, r_sym, GOT_TYPE_TLS_OFFSET,
+					    target->rel_dyn_section(layout),
+					    elfcpp::R_ARM_TLS_TPOFF32);
+		else if (!object->local_has_got_offset(r_sym,
+						       GOT_TYPE_TLS_OFFSET))
+		  {
+		    got->add_local(object, r_sym, GOT_TYPE_TLS_OFFSET);
+		    unsigned int got_offset =
+		      object->local_got_offset(r_sym, GOT_TYPE_TLS_OFFSET);
+		    got->add_static_reloc(got_offset,
+					  elfcpp::R_ARM_TLS_TPOFF32, object,
+					  r_sym);
+		  }
+	      }
+	    else
+	      // FIXME: TLS optimization not supported yet.
+	      gold_unreachable();
+	    break;
+
+	  case elfcpp::R_ARM_TLS_LE32:		// Local-exec
+	    layout->set_has_static_tls();
+	    if (output_is_shared)
+	      {
+	        // We need to create a dynamic relocation.
+                gold_assert(lsym.get_st_type() != elfcpp::STT_SECTION);
+                unsigned int r_sym = elfcpp::elf_r_sym<32>(reloc.get_r_info());
+		Reloc_section* rel_dyn = target->rel_dyn_section(layout);
+		rel_dyn->add_local(object, r_sym, elfcpp::R_ARM_TLS_TPOFF32,
+				   output_section, data_shndx,
+				   reloc.get_r_offset());
+	      }
+	    break;
+
+	  default:
+	    gold_unreachable();
+	  }
+      }
+      break;
+
     default:
       unsupported_reloc_local(object, r_type);
       break;
@@ -1540,13 +7344,10 @@ Target_arm<big_endian>::Scan::unsupported_reloc_global(
 }
 
 // Scan a relocation for a global symbol.
-// FIXME: This only handles a subset of relocation types used by Android
-// on ARM v5te devices.
 
 template<bool big_endian>
 inline void
-Target_arm<big_endian>::Scan::global(const General_options&,
-				     Symbol_table* symtab,
+Target_arm<big_endian>::Scan::global(Symbol_table* symtab,
 				     Layout* layout,
 				     Target_arm* target,
 				     Sized_relobj<32, big_endian>* object,
@@ -1560,69 +7361,118 @@ Target_arm<big_endian>::Scan::global(const General_options&,
   switch (r_type)
     {
     case elfcpp::R_ARM_NONE:
+    case elfcpp::R_ARM_V4BX:
+    case elfcpp::R_ARM_GNU_VTENTRY:
+    case elfcpp::R_ARM_GNU_VTINHERIT:
       break;
 
     case elfcpp::R_ARM_ABS32:
-    case elfcpp::R_ARM_ABS32_NOI:
-      {
-	// Make a dynamic relocation if necessary.
-	if (gsym->needs_dynamic_reloc(Symbol::ABSOLUTE_REF))
-	  {
-	    if (target->may_need_copy_reloc(gsym))
-	      {
-		target->copy_reloc(symtab, layout, object,
-				   data_shndx, output_section, gsym, reloc);
-	      }
-	    else if (gsym->can_use_relative_reloc(false))
-	      {
-   		// If we are to add more other reloc types than R_ARM_ABS32,
-   		// we need to add check_non_pic(object, r_type) here.
-		Reloc_section* rel_dyn = target->rel_dyn_section(layout);
-		rel_dyn->add_global_relative(gsym, elfcpp::R_ARM_RELATIVE,
-					     output_section, object,
-					     data_shndx, reloc.get_r_offset());
-	      }
-	    else
-	      {
-   		// If we are to add more other reloc types than R_ARM_ABS32,
-   		// we need to add check_non_pic(object, r_type) here.
-		Reloc_section* rel_dyn = target->rel_dyn_section(layout);
-		rel_dyn->add_global(gsym, r_type, output_section, object,
-				    data_shndx, reloc.get_r_offset());
-	      }
-	  }
-      }
-      break;
-
+    case elfcpp::R_ARM_ABS16:
+    case elfcpp::R_ARM_ABS12:
+    case elfcpp::R_ARM_THM_ABS5:
+    case elfcpp::R_ARM_ABS8:
+    case elfcpp::R_ARM_BASE_ABS:
     case elfcpp::R_ARM_MOVW_ABS_NC:
     case elfcpp::R_ARM_MOVT_ABS:
     case elfcpp::R_ARM_THM_MOVW_ABS_NC:
     case elfcpp::R_ARM_THM_MOVT_ABS:
-    case elfcpp::R_ARM_MOVW_PREL_NC:
-    case elfcpp::R_ARM_MOVT_PREL:
-    case elfcpp::R_ARM_THM_MOVW_PREL_NC:
-    case elfcpp::R_ARM_THM_MOVT_PREL:
-      break;
-
-    case elfcpp::R_ARM_THM_ABS5:
-    case elfcpp::R_ARM_ABS8:
-    case elfcpp::R_ARM_ABS12:
-    case elfcpp::R_ARM_ABS16:
-    case elfcpp::R_ARM_BASE_ABS:
+    case elfcpp::R_ARM_ABS32_NOI:
+      // Absolute addressing relocations.
       {
-	// No dynamic relocs of this kinds.
-	// Report the error in case of PIC.
-	int flags = Symbol::NON_PIC_REF;
-	if (gsym->type() == elfcpp::STT_FUNC
-	    || gsym->type() == elfcpp::STT_ARM_TFUNC)
-	  flags |= Symbol::FUNCTION_CALL;
-	if (gsym->needs_dynamic_reloc(flags))
-	  check_non_pic(object, r_type);
+        // Make a PLT entry if necessary.
+        if (this->symbol_needs_plt_entry(gsym))
+          {
+            target->make_plt_entry(symtab, layout, gsym);
+            // Since this is not a PC-relative relocation, we may be
+            // taking the address of a function. In that case we need to
+            // set the entry in the dynamic symbol table to the address of
+            // the PLT entry.
+            if (gsym->is_from_dynobj() && !parameters->options().shared())
+              gsym->set_needs_dynsym_value();
+          }
+        // Make a dynamic relocation if necessary.
+        if (gsym->needs_dynamic_reloc(Symbol::ABSOLUTE_REF))
+          {
+            if (gsym->may_need_copy_reloc())
+              {
+	        target->copy_reloc(symtab, layout, object,
+	                           data_shndx, output_section, gsym, reloc);
+              }
+            else if ((r_type == elfcpp::R_ARM_ABS32
+		      || r_type == elfcpp::R_ARM_ABS32_NOI)
+                     && gsym->can_use_relative_reloc(false))
+              {
+                Reloc_section* rel_dyn = target->rel_dyn_section(layout);
+                rel_dyn->add_global_relative(gsym, elfcpp::R_ARM_RELATIVE,
+                                             output_section, object,
+                                             data_shndx, reloc.get_r_offset());
+              }
+            else
+              {
+		check_non_pic(object, r_type);
+                Reloc_section* rel_dyn = target->rel_dyn_section(layout);
+                rel_dyn->add_global(gsym, r_type, output_section, object,
+                                    data_shndx, reloc.get_r_offset());
+              }
+          }
       }
       break;
 
+    case elfcpp::R_ARM_GOTOFF32:
+    case elfcpp::R_ARM_GOTOFF12:
+      // We need a GOT section.
+      target->got_section(symtab, layout);
+      break;
+      
     case elfcpp::R_ARM_REL32:
-    case elfcpp::R_ARM_PREL31:
+    case elfcpp::R_ARM_LDR_PC_G0:
+    case elfcpp::R_ARM_SBREL32:
+    case elfcpp::R_ARM_THM_PC8:
+    case elfcpp::R_ARM_BASE_PREL:
+    case elfcpp::R_ARM_LDR_SBREL_11_0_NC:
+    case elfcpp::R_ARM_ALU_SBREL_19_12_NC:
+    case elfcpp::R_ARM_ALU_SBREL_27_20_CK:
+    case elfcpp::R_ARM_MOVW_PREL_NC:
+    case elfcpp::R_ARM_MOVT_PREL:
+    case elfcpp::R_ARM_THM_MOVW_PREL_NC:
+    case elfcpp::R_ARM_THM_MOVT_PREL:
+    case elfcpp::R_ARM_THM_ALU_PREL_11_0:
+    case elfcpp::R_ARM_THM_PC12:
+    case elfcpp::R_ARM_REL32_NOI:
+    case elfcpp::R_ARM_ALU_PC_G0_NC:
+    case elfcpp::R_ARM_ALU_PC_G0:
+    case elfcpp::R_ARM_ALU_PC_G1_NC:
+    case elfcpp::R_ARM_ALU_PC_G1:
+    case elfcpp::R_ARM_ALU_PC_G2:
+    case elfcpp::R_ARM_LDR_PC_G1:
+    case elfcpp::R_ARM_LDR_PC_G2:
+    case elfcpp::R_ARM_LDRS_PC_G0:
+    case elfcpp::R_ARM_LDRS_PC_G1:
+    case elfcpp::R_ARM_LDRS_PC_G2:
+    case elfcpp::R_ARM_LDC_PC_G0:
+    case elfcpp::R_ARM_LDC_PC_G1:
+    case elfcpp::R_ARM_LDC_PC_G2:
+    case elfcpp::R_ARM_ALU_SB_G0_NC:
+    case elfcpp::R_ARM_ALU_SB_G0:
+    case elfcpp::R_ARM_ALU_SB_G1_NC:
+    case elfcpp::R_ARM_ALU_SB_G1:
+    case elfcpp::R_ARM_ALU_SB_G2:
+    case elfcpp::R_ARM_LDR_SB_G0:
+    case elfcpp::R_ARM_LDR_SB_G1:
+    case elfcpp::R_ARM_LDR_SB_G2:
+    case elfcpp::R_ARM_LDRS_SB_G0:
+    case elfcpp::R_ARM_LDRS_SB_G1:
+    case elfcpp::R_ARM_LDRS_SB_G2:
+    case elfcpp::R_ARM_LDC_SB_G0:
+    case elfcpp::R_ARM_LDC_SB_G1:
+    case elfcpp::R_ARM_LDC_SB_G2:
+    case elfcpp::R_ARM_MOVW_BREL_NC:
+    case elfcpp::R_ARM_MOVT_BREL:
+    case elfcpp::R_ARM_MOVW_BREL:
+    case elfcpp::R_ARM_THM_MOVW_BREL_NC:
+    case elfcpp::R_ARM_THM_MOVT_BREL:
+    case elfcpp::R_ARM_THM_MOVW_BREL:
+      // Relative addressing relocations.
       {
 	// Make a dynamic relocation if necessary.
 	int flags = Symbol::NON_PIC_REF;
@@ -1644,37 +7494,27 @@ Target_arm<big_endian>::Scan::global(const General_options&,
       }
       break;
 
-    case elfcpp::R_ARM_JUMP24:
+    case elfcpp::R_ARM_PC24:
     case elfcpp::R_ARM_THM_CALL:
+    case elfcpp::R_ARM_PLT32:
     case elfcpp::R_ARM_CALL:
-      {
-	if (Target_arm<big_endian>::Scan::symbol_needs_plt_entry(gsym))
-	  target->make_plt_entry(symtab, layout, gsym);
-	// Make a dynamic relocation if necessary.
-	int flags = Symbol::NON_PIC_REF;
-	if (gsym->type() == elfcpp::STT_FUNC
-	    || gsym->type() == elfcpp::STT_ARM_TFUNC)
-	  flags |= Symbol::FUNCTION_CALL;
-	if (gsym->needs_dynamic_reloc(flags))
-	  {
-	    if (target->may_need_copy_reloc(gsym))
-	      {
-		target->copy_reloc(symtab, layout, object,
-				   data_shndx, output_section, gsym,
-				   reloc);
-	      }
-	    else
-	      {
-		check_non_pic(object, r_type);
-		Reloc_section* rel_dyn = target->rel_dyn_section(layout);
-		rel_dyn->add_global(gsym, r_type, output_section, object,
-				    data_shndx, reloc.get_r_offset());
-	      }
-	  }
-      }
-      break;
+    case elfcpp::R_ARM_JUMP24:
+    case elfcpp::R_ARM_THM_JUMP24:
+    case elfcpp::R_ARM_SBREL31:
+    case elfcpp::R_ARM_PREL31:
+    case elfcpp::R_ARM_THM_JUMP19:
+    case elfcpp::R_ARM_THM_JUMP6:
+    case elfcpp::R_ARM_THM_JUMP11:
+    case elfcpp::R_ARM_THM_JUMP8:
+      // All the relocation above are branches except for the PREL31 ones.
+      // A PREL31 relocation can point to a personality function in a shared
+      // library.  In that case we want to use a PLT because we want to
+      // call the personality routine and the dyanmic linkers we care about
+      // do not support dynamic PREL31 relocations. An REL31 relocation may
+      // point to a function whose unwinding behaviour is being described but
+      // we will not mistakenly generate a PLT for that because we should use
+      // a local section symbol.
 
-    case elfcpp::R_ARM_PLT32:
       // If the symbol is fully resolved, this is just a relative
       // local reloc.  Otherwise we need a PLT entry.
       if (gsym->final_value_is_known())
@@ -1689,20 +7529,12 @@ Target_arm<big_endian>::Scan::global(const General_options&,
       target->make_plt_entry(symtab, layout, gsym);
       break;
 
-    case elfcpp::R_ARM_GOTOFF32:
-      // We need a GOT section.
-      target->got_section(symtab, layout);
-      break;
-
-    case elfcpp::R_ARM_BASE_PREL:
-      // FIXME: What about this?
-      break;
-      
     case elfcpp::R_ARM_GOT_BREL:
+    case elfcpp::R_ARM_GOT_ABS:
     case elfcpp::R_ARM_GOT_PREL:
       {
 	// The symbol requires a GOT entry.
-	Output_data_got<32, big_endian>* got =
+	Arm_output_data_got<big_endian>* got =
 	  target->got_section(symtab, layout);
 	if (gsym->final_value_is_known())
 	  got->add_global(gsym, GOT_TYPE_STANDARD);
@@ -1728,7 +7560,8 @@ Target_arm<big_endian>::Scan::global(const General_options&,
       break;
 
     case elfcpp::R_ARM_TARGET1:
-      // This should have been mapped to another type already.
+    case elfcpp::R_ARM_TARGET2:
+      // These should have been mapped to other types already.
       // Fall through.
     case elfcpp::R_ARM_COPY:
     case elfcpp::R_ARM_GLOB_DAT:
@@ -1740,6 +7573,96 @@ Target_arm<big_endian>::Scan::global(const General_options&,
 		 object->name().c_str(), r_type);
       break;
 
+      // These are initial tls relocs, which are expected when
+      // linking.
+    case elfcpp::R_ARM_TLS_GD32:	// Global-dynamic
+    case elfcpp::R_ARM_TLS_LDM32:	// Local-dynamic
+    case elfcpp::R_ARM_TLS_LDO32:	// Alternate local-dynamic
+    case elfcpp::R_ARM_TLS_IE32:	// Initial-exec
+    case elfcpp::R_ARM_TLS_LE32:	// Local-exec
+      {
+	const bool is_final = gsym->final_value_is_known();
+	const tls::Tls_optimization optimized_type
+            = Target_arm<big_endian>::optimize_tls_reloc(is_final, r_type);
+	switch (r_type)
+	  {
+	  case elfcpp::R_ARM_TLS_GD32:		// Global-dynamic
+	    if (optimized_type == tls::TLSOPT_NONE)
+	      {
+	        // Create a pair of GOT entries for the module index and
+	        // dtv-relative offset.
+                Arm_output_data_got<big_endian>* got
+                    = target->got_section(symtab, layout);
+		if (!parameters->doing_static_link())
+		  got->add_global_pair_with_rel(gsym, GOT_TYPE_TLS_PAIR,
+						target->rel_dyn_section(layout),
+						elfcpp::R_ARM_TLS_DTPMOD32,
+						elfcpp::R_ARM_TLS_DTPOFF32);
+		else
+		  got->add_tls_gd32_with_static_reloc(GOT_TYPE_TLS_PAIR, gsym);
+	      }
+	    else
+	      // FIXME: TLS optimization not supported yet.
+	      gold_unreachable();
+	    break;
+
+	  case elfcpp::R_ARM_TLS_LDM32:		// Local-dynamic
+	    if (optimized_type == tls::TLSOPT_NONE)
+	      {
+	        // Create a GOT entry for the module index.
+	        target->got_mod_index_entry(symtab, layout, object);
+	      }
+	    else
+	      // FIXME: TLS optimization not supported yet.
+	      gold_unreachable();
+	    break;
+
+	  case elfcpp::R_ARM_TLS_LDO32:		// Alternate local-dynamic
+	    break;
+
+	  case elfcpp::R_ARM_TLS_IE32:		// Initial-exec
+	    layout->set_has_static_tls();
+	    if (optimized_type == tls::TLSOPT_NONE)
+	      {
+		// Create a GOT entry for the tp-relative offset.
+		Arm_output_data_got<big_endian>* got
+		  = target->got_section(symtab, layout);
+		if (!parameters->doing_static_link())
+		  got->add_global_with_rel(gsym, GOT_TYPE_TLS_OFFSET,
+					   target->rel_dyn_section(layout),
+					   elfcpp::R_ARM_TLS_TPOFF32);
+		else if (!gsym->has_got_offset(GOT_TYPE_TLS_OFFSET))
+		  {
+		    got->add_global(gsym, GOT_TYPE_TLS_OFFSET);
+		    unsigned int got_offset =
+		       gsym->got_offset(GOT_TYPE_TLS_OFFSET);
+		    got->add_static_reloc(got_offset,
+					  elfcpp::R_ARM_TLS_TPOFF32, gsym);
+		  }
+	      }
+	    else
+	      // FIXME: TLS optimization not supported yet.
+	      gold_unreachable();
+	    break;
+
+	  case elfcpp::R_ARM_TLS_LE32:	// Local-exec
+	    layout->set_has_static_tls();
+	    if (parameters->options().shared())
+	      {
+	        // We need to create a dynamic relocation.
+                Reloc_section* rel_dyn = target->rel_dyn_section(layout);
+                rel_dyn->add_global(gsym, elfcpp::R_ARM_TLS_TPOFF32,
+				    output_section, object,
+                                    data_shndx, reloc.get_r_offset());
+	      }
+	    break;
+
+	  default:
+	    gold_unreachable();
+	  }
+      }
+      break;
+
     default:
       unsupported_reloc_global(object, r_type, gsym);
       break;
@@ -1750,8 +7673,7 @@ Target_arm<big_endian>::Scan::global(const General_options&,
 
 template<bool big_endian>
 void
-Target_arm<big_endian>::gc_process_relocs(const General_options& options,
-					  Symbol_table* symtab,
+Target_arm<big_endian>::gc_process_relocs(Symbol_table* symtab,
 					  Layout* layout,
 					  Sized_relobj<32, big_endian>* object,
 					  unsigned int data_shndx,
@@ -1767,7 +7689,6 @@ Target_arm<big_endian>::gc_process_relocs(const General_options& options,
   typedef typename Target_arm<big_endian>::Scan Scan;
 
   gold::gc_process_relocs<32, big_endian, Arm, elfcpp::SHT_REL, Scan>(
-    options,
     symtab,
     layout,
     this,
@@ -1785,8 +7706,7 @@ Target_arm<big_endian>::gc_process_relocs(const General_options& options,
 
 template<bool big_endian>
 void
-Target_arm<big_endian>::scan_relocs(const General_options& options,
-				    Symbol_table* symtab,
+Target_arm<big_endian>::scan_relocs(Symbol_table* symtab,
 				    Layout* layout,
 				    Sized_relobj<32, big_endian>* object,
 				    unsigned int data_shndx,
@@ -1807,7 +7727,6 @@ Target_arm<big_endian>::scan_relocs(const General_options& options,
     }
 
   gold::scan_relocs<32, big_endian, Target_arm, elfcpp::SHT_REL, Scan>(
-    options,
     symtab,
     layout,
     this,
@@ -1825,8 +7744,74 @@ Target_arm<big_endian>::scan_relocs(const General_options& options,
 
 template<bool big_endian>
 void
-Target_arm<big_endian>::do_finalize_sections(Layout* layout)
+Target_arm<big_endian>::do_finalize_sections(
+    Layout* layout,
+    const Input_objects* input_objects,
+    Symbol_table* symtab)
 {
+  // Create an empty uninitialized attribute section if we still don't have it
+  // at this moment.
+  if (this->attributes_section_data_ == NULL)
+    this->attributes_section_data_ = new Attributes_section_data(NULL, 0);
+
+  // Merge processor-specific flags.
+  for (Input_objects::Relobj_iterator p = input_objects->relobj_begin();
+       p != input_objects->relobj_end();
+       ++p)
+    {
+      Arm_relobj<big_endian>* arm_relobj =
+	Arm_relobj<big_endian>::as_arm_relobj(*p);
+      this->merge_processor_specific_flags(
+	  arm_relobj->name(),
+	  arm_relobj->processor_specific_flags());
+      this->merge_object_attributes(arm_relobj->name().c_str(),
+				    arm_relobj->attributes_section_data());
+
+    } 
+
+  for (Input_objects::Dynobj_iterator p = input_objects->dynobj_begin();
+       p != input_objects->dynobj_end();
+       ++p)
+    {
+      Arm_dynobj<big_endian>* arm_dynobj =
+	Arm_dynobj<big_endian>::as_arm_dynobj(*p);
+      this->merge_processor_specific_flags(
+	  arm_dynobj->name(),
+	  arm_dynobj->processor_specific_flags());
+      this->merge_object_attributes(arm_dynobj->name().c_str(),
+				    arm_dynobj->attributes_section_data());
+    }
+
+  // Check BLX use.
+  const Object_attribute* cpu_arch_attr =
+    this->get_aeabi_object_attribute(elfcpp::Tag_CPU_arch);
+  if (cpu_arch_attr->int_value() > elfcpp::TAG_CPU_ARCH_V4)
+    this->set_may_use_blx(true);
+ 
+  // Check if we need to use Cortex-A8 workaround.
+  if (parameters->options().user_set_fix_cortex_a8())
+    this->fix_cortex_a8_ = parameters->options().fix_cortex_a8();
+  else
+    {
+      // If neither --fix-cortex-a8 nor --no-fix-cortex-a8 is used, turn on
+      // Cortex-A8 erratum workaround for ARMv7-A or ARMv7 with unknown
+      // profile.  
+      const Object_attribute* cpu_arch_profile_attr =
+	this->get_aeabi_object_attribute(elfcpp::Tag_CPU_arch_profile);
+      this->fix_cortex_a8_ =
+	(cpu_arch_attr->int_value() == elfcpp::TAG_CPU_ARCH_V7
+         && (cpu_arch_profile_attr->int_value() == 'A'
+             || cpu_arch_profile_attr->int_value() == 0));
+    }
+  
+  // Check if we can use V4BX interworking.
+  // The V4BX interworking stub contains BX instruction,
+  // which is not specified for some profiles.
+  if (this->fix_v4bx() == General_options::FIX_V4BX_INTERWORKING
+      && !this->may_use_blx())
+    gold_error(_("unable to provide V4BX reloc interworking fix up; "
+	         "the target profile does not support BX instruction"));
+
   // Fill in some more dynamic tags.
   Output_data_dynamic* const odyn = layout->dynamic_data();
   if (odyn != NULL)
@@ -1864,24 +7849,44 @@ Target_arm<big_endian>::do_finalize_sections(Layout* layout)
   if (this->copy_relocs_.any_saved_relocs())
     this->copy_relocs_.emit(this->rel_dyn_section(layout));
 
-  // For the ARM target, we need to add a PT_ARM_EXIDX segment for
-  // the .ARM.exidx section.
-  if (!layout->script_options()->saw_phdrs_clause()
+  // Handle the .ARM.exidx section.
+  Output_section* exidx_section = layout->find_output_section(".ARM.exidx");
+  if (exidx_section != NULL
+      && exidx_section->type() == elfcpp::SHT_ARM_EXIDX
       && !parameters->options().relocatable())
     {
-      Output_section* exidx_section =
-	layout->find_output_section(".ARM.exidx");
-
-      if (exidx_section != NULL
-	  && exidx_section->type() == elfcpp::SHT_ARM_EXIDX)
+      // Create __exidx_start and __exdix_end symbols.
+      symtab->define_in_output_data("__exidx_start", NULL,
+				    Symbol_table::PREDEFINED,
+				    exidx_section, 0, 0, elfcpp::STT_OBJECT,
+				    elfcpp::STB_GLOBAL, elfcpp::STV_HIDDEN, 0,
+				    false, true);
+      symtab->define_in_output_data("__exidx_end", NULL,
+				    Symbol_table::PREDEFINED,
+				    exidx_section, 0, 0, elfcpp::STT_OBJECT,
+				    elfcpp::STB_GLOBAL, elfcpp::STV_HIDDEN, 0,
+				    true, true);
+
+      // For the ARM target, we need to add a PT_ARM_EXIDX segment for
+      // the .ARM.exidx section.
+      if (!layout->script_options()->saw_phdrs_clause())
 	{
 	  gold_assert(layout->find_output_segment(elfcpp::PT_ARM_EXIDX, 0, 0)
 		      == NULL);
 	  Output_segment*  exidx_segment =
 	    layout->make_output_segment(elfcpp::PT_ARM_EXIDX, elfcpp::PF_R);
-	  exidx_segment->add_output_section(exidx_section, elfcpp::PF_R);
+	  exidx_segment->add_output_section(exidx_section, elfcpp::PF_R,
+					    false);
 	}
     }
+
+  // Create an .ARM.attributes section if there is not one already.
+  Output_attributes_section_data* attributes_section =
+    new Output_attributes_section_data(*this->attributes_section_data_);
+  layout->add_output_section_data(".ARM.attributes",
+				  elfcpp::SHT_ARM_ATTRIBUTES, 0,
+				  attributes_section, false, false, false,
+				  false);
 }
 
 // Return whether a direct absolute static relocation needs to be applied.
@@ -1938,31 +7943,94 @@ Target_arm<big_endian>::Relocate::relocate(
     const Sized_symbol<32>* gsym,
     const Symbol_value<32>* psymval,
     unsigned char* view,
-    elfcpp::Elf_types<32>::Elf_Addr address,
-    section_size_type /* view_size */ )
+    Arm_address address,
+    section_size_type view_size)
 {
   typedef Arm_relocate_functions<big_endian> Arm_relocate_functions;
 
   r_type = get_real_reloc_type(r_type);
+  const Arm_reloc_property* reloc_property =
+    arm_reloc_property_table->get_implemented_static_reloc_property(r_type);
+  if (reloc_property == NULL)
+    {
+      std::string reloc_name =
+	arm_reloc_property_table->reloc_name_in_error_message(r_type);
+      gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
+			     _("cannot relocate %s in object file"),
+			     reloc_name.c_str());
+      return true;
+    }
 
-  // If this the symbol may be a Thumb function, set thumb bit to 1.
-  bool has_thumb_bit = ((gsym != NULL)
-			&& (gsym->type() == elfcpp::STT_FUNC
-			    || gsym->type() == elfcpp::STT_ARM_TFUNC));
+  const Arm_relobj<big_endian>* object =
+    Arm_relobj<big_endian>::as_arm_relobj(relinfo->object);
 
-  // Pick the value to use for symbols defined in shared objects.
+  // If the final branch target of a relocation is THUMB instruction, this
+  // is 1.  Otherwise it is 0.
+  Arm_address thumb_bit = 0;
   Symbol_value<32> symval;
-  if (gsym != NULL
-      && gsym->use_plt_offset(reloc_is_non_pic(r_type)))
+  bool is_weakly_undefined_without_plt = false;
+  if (relnum != Target_arm<big_endian>::fake_relnum_for_stubs)
     {
-      symval.set_output_value(target->plt_section()->address()
-			      + gsym->plt_offset());
-      psymval = &symval;
-      has_thumb_bit = 0;
+      if (gsym != NULL)
+	{
+	  // This is a global symbol.  Determine if we use PLT and if the
+	  // final target is THUMB.
+	  if (gsym->use_plt_offset(reloc_is_non_pic(r_type)))
+	    {
+	      // This uses a PLT, change the symbol value.
+	      symval.set_output_value(target->plt_section()->address()
+				      + gsym->plt_offset());
+	      psymval = &symval;
+	    }
+	  else if (gsym->is_weak_undefined())
+	    {
+	      // This is a weakly undefined symbol and we do not use PLT
+	      // for this relocation.  A branch targeting this symbol will
+	      // be converted into an NOP.
+	      is_weakly_undefined_without_plt = true;
+	    }
+	  else
+	    {
+	      // Set thumb bit if symbol:
+	      // -Has type STT_ARM_TFUNC or
+	      // -Has type STT_FUNC, is defined and with LSB in value set.
+	      thumb_bit =
+		(((gsym->type() == elfcpp::STT_ARM_TFUNC)
+		 || (gsym->type() == elfcpp::STT_FUNC
+		     && !gsym->is_undefined()
+		     && ((psymval->value(object, 0) & 1) != 0)))
+		? 1
+		: 0);
+	    }
+	}
+      else
+	{
+          // This is a local symbol.  Determine if the final target is THUMB.
+          // We saved this information when all the local symbols were read.
+	  elfcpp::Elf_types<32>::Elf_WXword r_info = rel.get_r_info();
+	  unsigned int r_sym = elfcpp::elf_r_sym<32>(r_info);
+	  thumb_bit = object->local_symbol_is_thumb_function(r_sym) ? 1 : 0;
+	}
+    }
+  else
+    {
+      // This is a fake relocation synthesized for a stub.  It does not have
+      // a real symbol.  We just look at the LSB of the symbol value to
+      // determine if the target is THUMB or not.
+      thumb_bit = ((psymval->value(object, 0) & 1) != 0);
     }
 
-  const Sized_relobj<32, big_endian>* object = relinfo->object;
-  
+  // Strip LSB if this points to a THUMB target.
+  if (thumb_bit != 0
+      && reloc_property->uses_thumb_bit() 
+      && ((psymval->value(object, 0) & 1) != 0))
+    {
+      Arm_address stripped_value =
+	psymval->value(object, 0) & ~static_cast<Arm_address>(1);
+      symval.set_output_value(stripped_value);
+      psymval = &symval;
+    } 
+
   // Get the GOT offset if needed.
   // The GOT pointer points to the end of the GOT section.
   // We need to subtract the size of the GOT section to get
@@ -1993,8 +8061,61 @@ Target_arm<big_endian>::Relocate::relocate(
       break;
     }
 
+  // To look up relocation stubs, we need to pass the symbol table index of
+  // a local symbol.
+  unsigned int r_sym = elfcpp::elf_r_sym<32>(rel.get_r_info());
+
+  // Get the addressing origin of the output segment defining the
+  // symbol gsym if needed (AAELF 4.6.1.2 Relocation types).
+  Arm_address sym_origin = 0;
+  if (reloc_property->uses_symbol_base())
+    {
+      if (r_type == elfcpp::R_ARM_BASE_ABS && gsym == NULL)
+	// R_ARM_BASE_ABS with the NULL symbol will give the
+	// absolute address of the GOT origin (GOT_ORG) (see ARM IHI
+	// 0044C (AAELF): 4.6.1.8 Proxy generating relocations).
+	sym_origin = target->got_plt_section()->address();
+      else if (gsym == NULL)
+	sym_origin = 0;
+      else if (gsym->source() == Symbol::IN_OUTPUT_SEGMENT)
+	sym_origin = gsym->output_segment()->vaddr();
+      else if (gsym->source() == Symbol::IN_OUTPUT_DATA)
+	sym_origin = gsym->output_data()->address();
+
+      // TODO: Assumes the segment base to be zero for the global symbols
+      // till the proper support for the segment-base-relative addressing
+      // will be implemented.  This is consistent with GNU ld.
+    }
+
+  // For relative addressing relocation, find out the relative address base.
+  Arm_address relative_address_base = 0;
+  switch(reloc_property->relative_address_base())
+    {
+    case Arm_reloc_property::RAB_NONE:
+    // Relocations with relative address bases RAB_TLS and RAB_tp are
+    // handled by relocate_tls.  So we do not need to do anything here.
+    case Arm_reloc_property::RAB_TLS:
+    case Arm_reloc_property::RAB_tp:
+      break;
+    case Arm_reloc_property::RAB_B_S:
+      relative_address_base = sym_origin;
+      break;
+    case Arm_reloc_property::RAB_GOT_ORG:
+      relative_address_base = target->got_plt_section()->address();
+      break;
+    case Arm_reloc_property::RAB_P:
+      relative_address_base = address;
+      break;
+    case Arm_reloc_property::RAB_Pa:
+      relative_address_base = address & 0xfffffffcU;
+      break;
+    default:
+      gold_unreachable(); 
+    }
+    
   typename Arm_relocate_functions::Status reloc_status =
 	Arm_relocate_functions::STATUS_OKAY;
+  bool check_overflow = reloc_property->checks_overflow();
   switch (r_type)
     {
     case elfcpp::R_ARM_NONE:
@@ -2022,7 +8143,7 @@ Target_arm<big_endian>::Relocate::relocate(
       if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, true,
 				    output_section))
 	reloc_status = Arm_relocate_functions::abs32(view, object, psymval,
-						     has_thumb_bit);
+						     thumb_bit);
       break;
 
     case elfcpp::R_ARM_ABS32_NOI:
@@ -2030,75 +8151,72 @@ Target_arm<big_endian>::Relocate::relocate(
 				    output_section))
 	// No thumb bit for this relocation: (S + A)
 	reloc_status = Arm_relocate_functions::abs32(view, object, psymval,
-						     false);
+						     0);
       break;
 
     case elfcpp::R_ARM_MOVW_ABS_NC:
-      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, true,
+      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, false,
 				    output_section))
-	reloc_status = Arm_relocate_functions::movw_abs_nc(view, object,
-							   psymval,
-       						           has_thumb_bit);
-      else
-	gold_error(_("relocation R_ARM_MOVW_ABS_NC cannot be used when making"
-		     "a shared object; recompile with -fPIC"));
+	reloc_status = Arm_relocate_functions::movw(view, object, psymval,
+						    0, thumb_bit,
+						    check_overflow);
       break;
 
     case elfcpp::R_ARM_MOVT_ABS:
-      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, true,
+      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, false,
 				    output_section))
-	reloc_status = Arm_relocate_functions::movt_abs(view, object, psymval);
-      else
-	gold_error(_("relocation R_ARM_MOVT_ABS cannot be used when making"
-		     "a shared object; recompile with -fPIC"));
+	reloc_status = Arm_relocate_functions::movt(view, object, psymval, 0);
       break;
 
     case elfcpp::R_ARM_THM_MOVW_ABS_NC:
-      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, true,
+      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, false,
 				    output_section))
-	reloc_status = Arm_relocate_functions::thm_movw_abs_nc(view, object,
-							       psymval,
-       						               has_thumb_bit);
-      else
-	gold_error(_("relocation R_ARM_THM_MOVW_ABS_NC cannot be used when"
-		     "making a shared object; recompile with -fPIC"));
+	reloc_status = Arm_relocate_functions::thm_movw(view, object, psymval,
+       						        0, thumb_bit, false);
       break;
 
     case elfcpp::R_ARM_THM_MOVT_ABS:
-      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, true,
+      if (should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, false,
 				    output_section))
-	reloc_status = Arm_relocate_functions::thm_movt_abs(view, object,
-							    psymval);
-      else
-	gold_error(_("relocation R_ARM_THM_MOVT_ABS cannot be used when"
-		     "making a shared object; recompile with -fPIC"));
+	reloc_status = Arm_relocate_functions::thm_movt(view, object,
+							psymval, 0);
       break;
 
     case elfcpp::R_ARM_MOVW_PREL_NC:
-      reloc_status = Arm_relocate_functions::movw_prel_nc(view, object,
-							  psymval, address,
-							  has_thumb_bit);
+    case elfcpp::R_ARM_MOVW_BREL_NC:
+    case elfcpp::R_ARM_MOVW_BREL:
+      reloc_status =
+	Arm_relocate_functions::movw(view, object, psymval,
+				     relative_address_base, thumb_bit,
+				     check_overflow);
       break;
 
     case elfcpp::R_ARM_MOVT_PREL:
-      reloc_status = Arm_relocate_functions::movt_prel(view, object,
-                                                       psymval, address);
+    case elfcpp::R_ARM_MOVT_BREL:
+      reloc_status =
+	Arm_relocate_functions::movt(view, object, psymval,
+				     relative_address_base);
       break;
 
     case elfcpp::R_ARM_THM_MOVW_PREL_NC:
-      reloc_status = Arm_relocate_functions::thm_movw_prel_nc(view, object,
-							      psymval, address,
-							      has_thumb_bit);
+    case elfcpp::R_ARM_THM_MOVW_BREL_NC:
+    case elfcpp::R_ARM_THM_MOVW_BREL:
+      reloc_status =
+	Arm_relocate_functions::thm_movw(view, object, psymval,
+					 relative_address_base,
+					 thumb_bit, check_overflow);
       break;
 
     case elfcpp::R_ARM_THM_MOVT_PREL:
-      reloc_status = Arm_relocate_functions::thm_movt_prel(view, object,
-							   psymval, address);
+    case elfcpp::R_ARM_THM_MOVT_BREL:
+      reloc_status =
+	Arm_relocate_functions::thm_movt(view, object, psymval,
+					 relative_address_base);
       break;
 	
     case elfcpp::R_ARM_REL32:
       reloc_status = Arm_relocate_functions::rel32(view, object, psymval,
-						   address, has_thumb_bit);
+						   address, thumb_bit);
       break;
 
     case elfcpp::R_ARM_THM_ABS5:
@@ -2108,65 +8226,48 @@ Target_arm<big_endian>::Relocate::relocate(
       break;
 
     case elfcpp::R_ARM_THM_CALL:
-      reloc_status = Arm_relocate_functions::thm_call(view, object, psymval,
-						      address, has_thumb_bit);
+      reloc_status =
+	Arm_relocate_functions::thm_call(relinfo, view, gsym, object, r_sym,
+					 psymval, address, thumb_bit,
+					 is_weakly_undefined_without_plt);
+      break;
+
+    case elfcpp::R_ARM_XPC25:
+      reloc_status =
+	Arm_relocate_functions::xpc25(relinfo, view, gsym, object, r_sym,
+				      psymval, address, thumb_bit,
+				      is_weakly_undefined_without_plt);
+      break;
+
+    case elfcpp::R_ARM_THM_XPC22:
+      reloc_status =
+	Arm_relocate_functions::thm_xpc22(relinfo, view, gsym, object, r_sym,
+					  psymval, address, thumb_bit,
+					  is_weakly_undefined_without_plt);
       break;
 
     case elfcpp::R_ARM_GOTOFF32:
       {
-	elfcpp::Elf_types<32>::Elf_Addr got_origin;
+	Arm_address got_origin;
 	got_origin = target->got_plt_section()->address();
 	reloc_status = Arm_relocate_functions::rel32(view, object, psymval,
-						     got_origin, has_thumb_bit);
+						     got_origin, thumb_bit);
       }
       break;
 
     case elfcpp::R_ARM_BASE_PREL:
-      {
-	uint32_t origin;
-	// Get the addressing origin of the output segment defining the 
-	// symbol gsym (AAELF 4.6.1.2 Relocation types)
-	gold_assert(gsym != NULL); 
-	if (gsym->source() == Symbol::IN_OUTPUT_SEGMENT)
-	  origin = gsym->output_segment()->vaddr();
-	else if (gsym->source () == Symbol::IN_OUTPUT_DATA)
-	  origin = gsym->output_data()->address();
-	else
-	  {
-            gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
-				   _("cannot find origin of R_ARM_BASE_PREL"));
-	    return true;
-	  }
-	reloc_status = Arm_relocate_functions::base_prel(view, origin, address);
-      }
+      gold_assert(gsym != NULL);
+      reloc_status =
+	  Arm_relocate_functions::base_prel(view, sym_origin, address);
       break;
 
     case elfcpp::R_ARM_BASE_ABS:
       {
-	if (!should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, true,
+	if (!should_apply_static_reloc(gsym, Symbol::ABSOLUTE_REF, false,
 				      output_section))
 	  break;
 
-	uint32_t origin;
-	// Get the addressing origin of the output segment defining
-	// the symbol gsym (AAELF 4.6.1.2 Relocation types).
-	if (gsym == NULL)
-	  // R_ARM_BASE_ABS with the NULL symbol will give the
-	  // absolute address of the GOT origin (GOT_ORG) (see ARM IHI
-	  // 0044C (AAELF): 4.6.1.8 Proxy generating relocations).
-	  origin = target->got_plt_section()->address();
-	else if (gsym->source() == Symbol::IN_OUTPUT_SEGMENT)
-	  origin = gsym->output_segment()->vaddr();
-	else if (gsym->source () == Symbol::IN_OUTPUT_DATA)
-	  origin = gsym->output_data()->address();
-	else
-	  {
-            gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
-				   _("cannot find origin of R_ARM_BASE_ABS"));
-	    return true;
-	  }
-
-	reloc_status = Arm_relocate_functions::base_abs(view, origin);
+	reloc_status = Arm_relocate_functions::base_abs(view, sym_origin);
       }
       break;
 
@@ -2180,7 +8281,7 @@ Target_arm<big_endian>::Relocate::relocate(
       // Get the address origin for GOT PLT, which is allocated right
       // after the GOT section, to calculate an absolute address of
       // the symbol GOT entry (got_origin + got_offset).
-      elfcpp::Elf_types<32>::Elf_Addr got_origin;
+      Arm_address got_origin;
       got_origin = target->got_plt_section()->address();
       reloc_status = Arm_relocate_functions::got_prel(view,
 						      got_origin + got_offset,
@@ -2194,44 +8295,153 @@ Target_arm<big_endian>::Relocate::relocate(
 		  || (gsym->is_defined()
 		      && !gsym->is_from_dynobj()
 		      && !gsym->is_preemptible()));
-      reloc_status = Arm_relocate_functions::plt32(view, object, psymval,
-						   address, has_thumb_bit);
+      reloc_status =
+	Arm_relocate_functions::plt32(relinfo, view, gsym, object, r_sym,
+				      psymval, address, thumb_bit,
+				      is_weakly_undefined_without_plt);
       break;
 
     case elfcpp::R_ARM_CALL:
-      reloc_status = Arm_relocate_functions::call(view, object, psymval,
-						  address, has_thumb_bit);
+      reloc_status =
+	Arm_relocate_functions::call(relinfo, view, gsym, object, r_sym,
+				     psymval, address, thumb_bit,
+				     is_weakly_undefined_without_plt);
       break;
 
     case elfcpp::R_ARM_JUMP24:
-      reloc_status = Arm_relocate_functions::jump24(view, object, psymval,
-						    address, has_thumb_bit);
+      reloc_status =
+	Arm_relocate_functions::jump24(relinfo, view, gsym, object, r_sym,
+				       psymval, address, thumb_bit,
+				       is_weakly_undefined_without_plt);
+      break;
+
+    case elfcpp::R_ARM_THM_JUMP24:
+      reloc_status =
+	Arm_relocate_functions::thm_jump24(relinfo, view, gsym, object, r_sym,
+					   psymval, address, thumb_bit,
+					   is_weakly_undefined_without_plt);
+      break;
+
+    case elfcpp::R_ARM_THM_JUMP19:
+      reloc_status =
+	Arm_relocate_functions::thm_jump19(view, object, psymval, address,
+					   thumb_bit);
+      break;
+
+    case elfcpp::R_ARM_THM_JUMP6:
+      reloc_status =
+	Arm_relocate_functions::thm_jump6(view, object, psymval, address);
+      break;
+
+    case elfcpp::R_ARM_THM_JUMP8:
+      reloc_status =
+	Arm_relocate_functions::thm_jump8(view, object, psymval, address);
+      break;
+
+    case elfcpp::R_ARM_THM_JUMP11:
+      reloc_status =
+	Arm_relocate_functions::thm_jump11(view, object, psymval, address);
       break;
 
     case elfcpp::R_ARM_PREL31:
       reloc_status = Arm_relocate_functions::prel31(view, object, psymval,
-						    address, has_thumb_bit);
+						    address, thumb_bit);
       break;
 
-    case elfcpp::R_ARM_TARGET1:
-      // This should have been mapped to another type already.
-      // Fall through.
-    case elfcpp::R_ARM_COPY:
-    case elfcpp::R_ARM_GLOB_DAT:
-    case elfcpp::R_ARM_JUMP_SLOT:
-    case elfcpp::R_ARM_RELATIVE:
-      // These are relocations which should only be seen by the
-      // dynamic linker, and should never be seen here.
-      gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
-			     _("unexpected reloc %u in object file"),
-			     r_type);
+    case elfcpp::R_ARM_V4BX:
+      if (target->fix_v4bx() > General_options::FIX_V4BX_NONE)
+	{
+	  const bool is_v4bx_interworking =
+	      (target->fix_v4bx() == General_options::FIX_V4BX_INTERWORKING);
+	  reloc_status =
+	    Arm_relocate_functions::v4bx(relinfo, view, object, address,
+					 is_v4bx_interworking);
+	}
       break;
 
-    default:
-      gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
-			     _("unsupported reloc %u"),
-			     r_type);
+    case elfcpp::R_ARM_THM_PC8:
+      reloc_status =
+	Arm_relocate_functions::thm_pc8(view, object, psymval, address);
+      break;
+
+    case elfcpp::R_ARM_THM_PC12:
+      reloc_status =
+	Arm_relocate_functions::thm_pc12(view, object, psymval, address);
+      break;
+
+    case elfcpp::R_ARM_THM_ALU_PREL_11_0:
+      reloc_status =
+	Arm_relocate_functions::thm_alu11(view, object, psymval, address,
+					  thumb_bit);
+      break;
+
+    case elfcpp::R_ARM_ALU_PC_G0_NC:
+    case elfcpp::R_ARM_ALU_PC_G0:
+    case elfcpp::R_ARM_ALU_PC_G1_NC:
+    case elfcpp::R_ARM_ALU_PC_G1:
+    case elfcpp::R_ARM_ALU_PC_G2:
+    case elfcpp::R_ARM_ALU_SB_G0_NC:
+    case elfcpp::R_ARM_ALU_SB_G0:
+    case elfcpp::R_ARM_ALU_SB_G1_NC:
+    case elfcpp::R_ARM_ALU_SB_G1:
+    case elfcpp::R_ARM_ALU_SB_G2:
+      reloc_status =
+	Arm_relocate_functions::arm_grp_alu(view, object, psymval,
+					    reloc_property->group_index(),
+					    relative_address_base,
+					    thumb_bit, check_overflow);
+      break;
+
+    case elfcpp::R_ARM_LDR_PC_G0:
+    case elfcpp::R_ARM_LDR_PC_G1:
+    case elfcpp::R_ARM_LDR_PC_G2:
+    case elfcpp::R_ARM_LDR_SB_G0:
+    case elfcpp::R_ARM_LDR_SB_G1:
+    case elfcpp::R_ARM_LDR_SB_G2:
+      reloc_status =
+	  Arm_relocate_functions::arm_grp_ldr(view, object, psymval,
+					      reloc_property->group_index(),
+					      relative_address_base);
+      break;
+
+    case elfcpp::R_ARM_LDRS_PC_G0:
+    case elfcpp::R_ARM_LDRS_PC_G1:
+    case elfcpp::R_ARM_LDRS_PC_G2:
+    case elfcpp::R_ARM_LDRS_SB_G0:
+    case elfcpp::R_ARM_LDRS_SB_G1:
+    case elfcpp::R_ARM_LDRS_SB_G2:
+      reloc_status =
+	  Arm_relocate_functions::arm_grp_ldrs(view, object, psymval,
+					       reloc_property->group_index(),
+					       relative_address_base);
+      break;
+
+    case elfcpp::R_ARM_LDC_PC_G0:
+    case elfcpp::R_ARM_LDC_PC_G1:
+    case elfcpp::R_ARM_LDC_PC_G2:
+    case elfcpp::R_ARM_LDC_SB_G0:
+    case elfcpp::R_ARM_LDC_SB_G1:
+    case elfcpp::R_ARM_LDC_SB_G2:
+      reloc_status =
+	  Arm_relocate_functions::arm_grp_ldc(view, object, psymval,
+					      reloc_property->group_index(),
+					      relative_address_base);
+      break;
+
+      // These are initial tls relocs, which are expected when
+      // linking.
+    case elfcpp::R_ARM_TLS_GD32:	// Global-dynamic
+    case elfcpp::R_ARM_TLS_LDM32:	// Local-dynamic
+    case elfcpp::R_ARM_TLS_LDO32:	// Alternate local-dynamic
+    case elfcpp::R_ARM_TLS_IE32:	// Initial-exec
+    case elfcpp::R_ARM_TLS_LE32:	// Local-exec
+      reloc_status =
+	this->relocate_tls(relinfo, target, relnum, rel, r_type, gsym, psymval,
+			   view, address, view_size);
       break;
+
+    default:
+      gold_unreachable();
     }
 
   // Report any errors.
@@ -2259,6 +8469,145 @@ Target_arm<big_endian>::Relocate::relocate(
   return true;
 }
 
+// Perform a TLS relocation.
+
+template<bool big_endian>
+inline typename Arm_relocate_functions<big_endian>::Status
+Target_arm<big_endian>::Relocate::relocate_tls(
+    const Relocate_info<32, big_endian>* relinfo,
+    Target_arm<big_endian>* target,
+    size_t relnum,
+    const elfcpp::Rel<32, big_endian>& rel,
+    unsigned int r_type,
+    const Sized_symbol<32>* gsym,
+    const Symbol_value<32>* psymval,
+    unsigned char* view,
+    elfcpp::Elf_types<32>::Elf_Addr address,
+    section_size_type /*view_size*/ )
+{
+  typedef Arm_relocate_functions<big_endian> ArmRelocFuncs;
+  typedef Relocate_functions<32, big_endian> RelocFuncs;
+  Output_segment* tls_segment = relinfo->layout->tls_segment();
+
+  const Sized_relobj<32, big_endian>* object = relinfo->object;
+
+  elfcpp::Elf_types<32>::Elf_Addr value = psymval->value(object, 0);
+
+  const bool is_final = (gsym == NULL
+			 ? !parameters->options().shared()
+			 : gsym->final_value_is_known());
+  const tls::Tls_optimization optimized_type
+      = Target_arm<big_endian>::optimize_tls_reloc(is_final, r_type);
+  switch (r_type)
+    {
+    case elfcpp::R_ARM_TLS_GD32:	// Global-dynamic
+        {
+          unsigned int got_type = GOT_TYPE_TLS_PAIR;
+          unsigned int got_offset;
+          if (gsym != NULL)
+            {
+              gold_assert(gsym->has_got_offset(got_type));
+              got_offset = gsym->got_offset(got_type) - target->got_size();
+            }
+          else
+            {
+              unsigned int r_sym = elfcpp::elf_r_sym<32>(rel.get_r_info());
+              gold_assert(object->local_has_got_offset(r_sym, got_type));
+              got_offset = (object->local_got_offset(r_sym, got_type)
+			    - target->got_size());
+            }
+          if (optimized_type == tls::TLSOPT_NONE)
+            {
+	      Arm_address got_entry =
+		target->got_plt_section()->address() + got_offset;
+	      
+              // Relocate the field with the PC relative offset of the pair of
+              // GOT entries.
+	      RelocFuncs::pcrel32(view, got_entry, address);
+              return ArmRelocFuncs::STATUS_OKAY;
+            }
+        }
+      break;
+
+    case elfcpp::R_ARM_TLS_LDM32:	// Local-dynamic
+      if (optimized_type == tls::TLSOPT_NONE)
+        {
+          // Relocate the field with the offset of the GOT entry for
+          // the module index.
+          unsigned int got_offset;
+          got_offset = (target->got_mod_index_entry(NULL, NULL, NULL)
+			- target->got_size());
+	  Arm_address got_entry =
+	    target->got_plt_section()->address() + got_offset;
+
+          // Relocate the field with the PC relative offset of the pair of
+          // GOT entries.
+          RelocFuncs::pcrel32(view, got_entry, address);
+	  return ArmRelocFuncs::STATUS_OKAY;
+        }
+      break;
+
+    case elfcpp::R_ARM_TLS_LDO32:	// Alternate local-dynamic
+      RelocFuncs::rel32(view, value);
+      return ArmRelocFuncs::STATUS_OKAY;
+
+    case elfcpp::R_ARM_TLS_IE32:	// Initial-exec
+      if (optimized_type == tls::TLSOPT_NONE)
+        {
+          // Relocate the field with the offset of the GOT entry for
+          // the tp-relative offset of the symbol.
+	  unsigned int got_type = GOT_TYPE_TLS_OFFSET;
+          unsigned int got_offset;
+          if (gsym != NULL)
+            {
+              gold_assert(gsym->has_got_offset(got_type));
+              got_offset = gsym->got_offset(got_type);
+            }
+          else
+            {
+              unsigned int r_sym = elfcpp::elf_r_sym<32>(rel.get_r_info());
+              gold_assert(object->local_has_got_offset(r_sym, got_type));
+              got_offset = object->local_got_offset(r_sym, got_type);
+            }
+
+          // All GOT offsets are relative to the end of the GOT.
+          got_offset -= target->got_size();
+
+	  Arm_address got_entry =
+	    target->got_plt_section()->address() + got_offset;
+
+          // Relocate the field with the PC relative offset of the GOT entry.
+	  RelocFuncs::pcrel32(view, got_entry, address);
+	  return ArmRelocFuncs::STATUS_OKAY;
+        }
+      break;
+
+    case elfcpp::R_ARM_TLS_LE32:	// Local-exec
+      // If we're creating a shared library, a dynamic relocation will
+      // have been created for this location, so do not apply it now.
+      if (!parameters->options().shared())
+        {
+          gold_assert(tls_segment != NULL);
+
+	  // $tp points to the TCB, which is followed by the TLS, so we
+	  // need to add TCB size to the offset.
+	  Arm_address aligned_tcb_size =
+	    align_address(ARM_TCB_SIZE, tls_segment->maximum_alignment());
+          RelocFuncs::rel32(view, value + aligned_tcb_size);
+
+        }
+      return ArmRelocFuncs::STATUS_OKAY;
+    
+    default:
+      gold_unreachable();
+    }
+
+  gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
+			 _("unsupported reloc %u"),
+			 r_type);
+  return ArmRelocFuncs::STATUS_BAD_RELOC;
+}
+
 // Relocate section data.
 
 template<bool big_endian>
@@ -2271,13 +8620,35 @@ Target_arm<big_endian>::relocate_section(
     Output_section* output_section,
     bool needs_special_offset_handling,
     unsigned char* view,
-    elfcpp::Elf_types<32>::Elf_Addr address,
+    Arm_address address,
     section_size_type view_size,
     const Reloc_symbol_changes* reloc_symbol_changes)
 {
   typedef typename Target_arm<big_endian>::Relocate Arm_relocate;
   gold_assert(sh_type == elfcpp::SHT_REL);
 
+  Arm_input_section<big_endian>* arm_input_section =
+    this->find_arm_input_section(relinfo->object, relinfo->data_shndx);
+
+  // This is an ARM input section and the view covers the whole output
+  // section.
+  if (arm_input_section != NULL)
+    {
+      gold_assert(needs_special_offset_handling);
+      Arm_address section_address = arm_input_section->address();
+      section_size_type section_size = arm_input_section->data_size();
+
+      gold_assert((arm_input_section->address() >= address)
+		  && ((arm_input_section->address()
+		       + arm_input_section->data_size())
+		      <= (address + view_size)));
+
+      off_t offset = section_address - address;
+      view += offset;
+      address += offset;
+      view_size = section_size;
+    }
+
   gold::relocate_section<32, big_endian, Target_arm, elfcpp::SHT_REL,
 			 Arm_relocate>(
     relinfo,
@@ -2302,57 +8673,16 @@ Target_arm<big_endian>::Relocatable_size_for_reloc::get_size_for_reloc(
     Relobj* object)
 {
   r_type = get_real_reloc_type(r_type);
-  switch (r_type)
+  const Arm_reloc_property* arp =
+      arm_reloc_property_table->get_implemented_static_reloc_property(r_type);
+  if (arp != NULL)
+    return arp->size();
+  else
     {
-    case elfcpp::R_ARM_NONE:
-      return 0;
-
-    case elfcpp::R_ARM_ABS8:
-      return 1;
-
-    case elfcpp::R_ARM_ABS16:
-    case elfcpp::R_ARM_THM_ABS5:
-      return 2;
-
-    case elfcpp::R_ARM_ABS32:
-    case elfcpp::R_ARM_ABS32_NOI:
-    case elfcpp::R_ARM_ABS12:
-    case elfcpp::R_ARM_BASE_ABS:
-    case elfcpp::R_ARM_REL32:
-    case elfcpp::R_ARM_THM_CALL:
-    case elfcpp::R_ARM_GOTOFF32:
-    case elfcpp::R_ARM_BASE_PREL:
-    case elfcpp::R_ARM_GOT_BREL:
-    case elfcpp::R_ARM_GOT_PREL:
-    case elfcpp::R_ARM_PLT32:
-    case elfcpp::R_ARM_CALL:
-    case elfcpp::R_ARM_JUMP24:
-    case elfcpp::R_ARM_PREL31:
-    case elfcpp::R_ARM_MOVW_ABS_NC:
-    case elfcpp::R_ARM_MOVT_ABS:
-    case elfcpp::R_ARM_THM_MOVW_ABS_NC:
-    case elfcpp::R_ARM_THM_MOVT_ABS:
-    case elfcpp::R_ARM_MOVW_PREL_NC:
-    case elfcpp::R_ARM_MOVT_PREL:
-    case elfcpp::R_ARM_THM_MOVW_PREL_NC:
-    case elfcpp::R_ARM_THM_MOVT_PREL:
-      return 4;
-
-    case elfcpp::R_ARM_TARGET1:
-      // This should have been mapped to another type already.
-      // Fall through.
-    case elfcpp::R_ARM_COPY:
-    case elfcpp::R_ARM_GLOB_DAT:
-    case elfcpp::R_ARM_JUMP_SLOT:
-    case elfcpp::R_ARM_RELATIVE:
-      // These are relocations which should only be seen by the
-      // dynamic linker, and should never be seen here.
-      gold_error(_("%s: unexpected reloc %u in object file"),
-		 object->name().c_str(), r_type);
-      return 0;
-
-    default:
-      object->error(_("unsupported reloc %u in object file"), r_type);
+      std::string reloc_name =
+	arm_reloc_property_table->reloc_name_in_error_message(r_type);
+      gold_error(_("%s: unexpected %s in object file"),
+		 object->name().c_str(), reloc_name.c_str());
       return 0;
     }
 }
@@ -2362,7 +8692,6 @@ Target_arm<big_endian>::Relocatable_size_for_reloc::get_size_for_reloc(
 template<bool big_endian>
 void
 Target_arm<big_endian>::scan_relocatable_relocs(
-    const General_options& options,
     Symbol_table* symtab,
     Layout* layout,
     Sized_relobj<32, big_endian>* object,
@@ -2383,7 +8712,6 @@ Target_arm<big_endian>::scan_relocatable_relocs(
 
   gold::scan_relocatable_relocs<32, big_endian, elfcpp::SHT_REL,
       Scan_relocatable_relocs>(
-    options,
     symtab,
     layout,
     object,
@@ -2410,7 +8738,7 @@ Target_arm<big_endian>::relocate_for_relocatable(
     off_t offset_in_output_section,
     const Relocatable_relocs* rr,
     unsigned char* view,
-    elfcpp::Elf_types<32>::Elf_Addr view_address,
+    Arm_address view_address,
     section_size_type view_size,
     unsigned char* reloc_view,
     section_size_type reloc_view_size)
@@ -2465,7 +8793,1836 @@ Target_arm<big_endian>::get_real_reloc_type (unsigned int r_type)
     }
 }
 
-// The selector for arm object files.
+// Whether if two EABI versions V1 and V2 are compatible.
+
+template<bool big_endian>
+bool
+Target_arm<big_endian>::are_eabi_versions_compatible(
+    elfcpp::Elf_Word v1,
+    elfcpp::Elf_Word v2)
+{
+  // v4 and v5 are the same spec before and after it was released,
+  // so allow mixing them.
+  if ((v1 == elfcpp::EF_ARM_EABI_VER4 && v2 == elfcpp::EF_ARM_EABI_VER5)
+      || (v1 == elfcpp::EF_ARM_EABI_VER5 && v2 == elfcpp::EF_ARM_EABI_VER4))
+    return true;
+
+  return v1 == v2;
+}
+
+// Combine FLAGS from an input object called NAME and the processor-specific
+// flags in the ELF header of the output.  Much of this is adapted from the
+// processor-specific flags merging code in elf32_arm_merge_private_bfd_data
+// in bfd/elf32-arm.c.
+
+template<bool big_endian>
+void
+Target_arm<big_endian>::merge_processor_specific_flags(
+    const std::string& name,
+    elfcpp::Elf_Word flags)
+{
+  if (this->are_processor_specific_flags_set())
+    {
+      elfcpp::Elf_Word out_flags = this->processor_specific_flags();
+
+      // Nothing to merge if flags equal to those in output.
+      if (flags == out_flags)
+	return;
+
+      // Complain about various flag mismatches.
+      elfcpp::Elf_Word version1 = elfcpp::arm_eabi_version(flags);
+      elfcpp::Elf_Word version2 = elfcpp::arm_eabi_version(out_flags);
+      if (!this->are_eabi_versions_compatible(version1, version2))
+	gold_error(_("Source object %s has EABI version %d but output has "
+		     "EABI version %d."),
+		   name.c_str(),
+		   (flags & elfcpp::EF_ARM_EABIMASK) >> 24,
+		   (out_flags & elfcpp::EF_ARM_EABIMASK) >> 24);
+    }
+  else
+    {
+      // If the input is the default architecture and had the default
+      // flags then do not bother setting the flags for the output
+      // architecture, instead allow future merges to do this.  If no
+      // future merges ever set these flags then they will retain their
+      // uninitialised values, which surprise surprise, correspond
+      // to the default values.
+      if (flags == 0)
+	return;
+
+      // This is the first time, just copy the flags.
+      // We only copy the EABI version for now.
+      this->set_processor_specific_flags(flags & elfcpp::EF_ARM_EABIMASK);
+    }
+}
+
+// Adjust ELF file header.
+template<bool big_endian>
+void
+Target_arm<big_endian>::do_adjust_elf_header(
+    unsigned char* view,
+    int len) const
+{
+  gold_assert(len == elfcpp::Elf_sizes<32>::ehdr_size);
+
+  elfcpp::Ehdr<32, big_endian> ehdr(view);
+  unsigned char e_ident[elfcpp::EI_NIDENT];
+  memcpy(e_ident, ehdr.get_e_ident(), elfcpp::EI_NIDENT);
+
+  if (elfcpp::arm_eabi_version(this->processor_specific_flags())
+      == elfcpp::EF_ARM_EABI_UNKNOWN)
+    e_ident[elfcpp::EI_OSABI] = elfcpp::ELFOSABI_ARM;
+  else
+    e_ident[elfcpp::EI_OSABI] = 0;
+  e_ident[elfcpp::EI_ABIVERSION] = 0;
+
+  // FIXME: Do EF_ARM_BE8 adjustment.
+
+  elfcpp::Ehdr_write<32, big_endian> oehdr(view);
+  oehdr.put_e_ident(e_ident);
+}
+
+// do_make_elf_object to override the same function in the base class.
+// We need to use a target-specific sub-class of Sized_relobj<32, big_endian>
+// to store ARM specific information.  Hence we need to have our own
+// ELF object creation.
+
+template<bool big_endian>
+Object*
+Target_arm<big_endian>::do_make_elf_object(
+    const std::string& name,
+    Input_file* input_file,
+    off_t offset, const elfcpp::Ehdr<32, big_endian>& ehdr)
+{
+  int et = ehdr.get_e_type();
+  if (et == elfcpp::ET_REL)
+    {
+      Arm_relobj<big_endian>* obj =
+        new Arm_relobj<big_endian>(name, input_file, offset, ehdr);
+      obj->setup();
+      return obj;
+    }
+  else if (et == elfcpp::ET_DYN)
+    {
+      Sized_dynobj<32, big_endian>* obj =
+        new Arm_dynobj<big_endian>(name, input_file, offset, ehdr);
+      obj->setup();
+      return obj;
+    }
+  else
+    {
+      gold_error(_("%s: unsupported ELF file type %d"),
+                 name.c_str(), et);
+      return NULL;
+    }
+}
+
+// Read the architecture from the Tag_also_compatible_with attribute, if any.
+// Returns -1 if no architecture could be read.
+// This is adapted from get_secondary_compatible_arch() in bfd/elf32-arm.c.
+
+template<bool big_endian>
+int
+Target_arm<big_endian>::get_secondary_compatible_arch(
+    const Attributes_section_data* pasd)
+{
+  const Object_attribute *known_attributes =
+    pasd->known_attributes(Object_attribute::OBJ_ATTR_PROC);
+
+  // Note: the tag and its argument below are uleb128 values, though
+  // currently-defined values fit in one byte for each.
+  const std::string& sv =
+    known_attributes[elfcpp::Tag_also_compatible_with].string_value();
+  if (sv.size() == 2
+      && sv.data()[0] == elfcpp::Tag_CPU_arch
+      && (sv.data()[1] & 128) != 128)
+   return sv.data()[1];
+
+  // This tag is "safely ignorable", so don't complain if it looks funny.
+  return -1;
+}
+
+// Set, or unset, the architecture of the Tag_also_compatible_with attribute.
+// The tag is removed if ARCH is -1.
+// This is adapted from set_secondary_compatible_arch() in bfd/elf32-arm.c.
+
+template<bool big_endian>
+void
+Target_arm<big_endian>::set_secondary_compatible_arch(
+    Attributes_section_data* pasd,
+    int arch)
+{
+  Object_attribute *known_attributes =
+    pasd->known_attributes(Object_attribute::OBJ_ATTR_PROC);
+
+  if (arch == -1)
+    {
+      known_attributes[elfcpp::Tag_also_compatible_with].set_string_value("");
+      return;
+    }
+
+  // Note: the tag and its argument below are uleb128 values, though
+  // currently-defined values fit in one byte for each.
+  char sv[3];
+  sv[0] = elfcpp::Tag_CPU_arch;
+  gold_assert(arch != 0);
+  sv[1] = arch;
+  sv[2] = '\0';
+
+  known_attributes[elfcpp::Tag_also_compatible_with].set_string_value(sv);
+}
+
+// Combine two values for Tag_CPU_arch, taking secondary compatibility tags
+// into account.
+// This is adapted from tag_cpu_arch_combine() in bfd/elf32-arm.c.
+
+template<bool big_endian>
+int
+Target_arm<big_endian>::tag_cpu_arch_combine(
+    const char* name,
+    int oldtag,
+    int* secondary_compat_out,
+    int newtag,
+    int secondary_compat)
+{
+#define T(X) elfcpp::TAG_CPU_ARCH_##X
+  static const int v6t2[] =
+    {
+      T(V6T2),   // PRE_V4.
+      T(V6T2),   // V4.
+      T(V6T2),   // V4T.
+      T(V6T2),   // V5T.
+      T(V6T2),   // V5TE.
+      T(V6T2),   // V5TEJ.
+      T(V6T2),   // V6.
+      T(V7),     // V6KZ.
+      T(V6T2)    // V6T2.
+    };
+  static const int v6k[] =
+    {
+      T(V6K),    // PRE_V4.
+      T(V6K),    // V4.
+      T(V6K),    // V4T.
+      T(V6K),    // V5T.
+      T(V6K),    // V5TE.
+      T(V6K),    // V5TEJ.
+      T(V6K),    // V6.
+      T(V6KZ),   // V6KZ.
+      T(V7),     // V6T2.
+      T(V6K)     // V6K.
+    };
+  static const int v7[] =
+    {
+      T(V7),     // PRE_V4.
+      T(V7),     // V4.
+      T(V7),     // V4T.
+      T(V7),     // V5T.
+      T(V7),     // V5TE.
+      T(V7),     // V5TEJ.
+      T(V7),     // V6.
+      T(V7),     // V6KZ.
+      T(V7),     // V6T2.
+      T(V7),     // V6K.
+      T(V7)      // V7.
+    };
+  static const int v6_m[] =
+    {
+      -1,        // PRE_V4.
+      -1,        // V4.
+      T(V6K),    // V4T.
+      T(V6K),    // V5T.
+      T(V6K),    // V5TE.
+      T(V6K),    // V5TEJ.
+      T(V6K),    // V6.
+      T(V6KZ),   // V6KZ.
+      T(V7),     // V6T2.
+      T(V6K),    // V6K.
+      T(V7),     // V7.
+      T(V6_M)    // V6_M.
+    };
+  static const int v6s_m[] =
+    {
+      -1,        // PRE_V4.
+      -1,        // V4.
+      T(V6K),    // V4T.
+      T(V6K),    // V5T.
+      T(V6K),    // V5TE.
+      T(V6K),    // V5TEJ.
+      T(V6K),    // V6.
+      T(V6KZ),   // V6KZ.
+      T(V7),     // V6T2.
+      T(V6K),    // V6K.
+      T(V7),     // V7.
+      T(V6S_M),  // V6_M.
+      T(V6S_M)   // V6S_M.
+    };
+  static const int v7e_m[] =
+    {
+      -1,	// PRE_V4.
+      -1,	// V4.
+      T(V7E_M),	// V4T.
+      T(V7E_M),	// V5T.
+      T(V7E_M),	// V5TE.
+      T(V7E_M),	// V5TEJ.
+      T(V7E_M),	// V6.
+      T(V7E_M),	// V6KZ.
+      T(V7E_M),	// V6T2.
+      T(V7E_M),	// V6K.
+      T(V7E_M),	// V7.
+      T(V7E_M),	// V6_M.
+      T(V7E_M),	// V6S_M.
+      T(V7E_M)	// V7E_M.
+    };
+  static const int v4t_plus_v6_m[] =
+    {
+      -1,		// PRE_V4.
+      -1,		// V4.
+      T(V4T),		// V4T.
+      T(V5T),		// V5T.
+      T(V5TE),		// V5TE.
+      T(V5TEJ),		// V5TEJ.
+      T(V6),		// V6.
+      T(V6KZ),		// V6KZ.
+      T(V6T2),		// V6T2.
+      T(V6K),		// V6K.
+      T(V7),		// V7.
+      T(V6_M),		// V6_M.
+      T(V6S_M),		// V6S_M.
+      T(V7E_M),		// V7E_M.
+      T(V4T_PLUS_V6_M)	// V4T plus V6_M.
+    };
+  static const int *comb[] =
+    {
+      v6t2,
+      v6k,
+      v7,
+      v6_m,
+      v6s_m,
+      v7e_m,
+      // Pseudo-architecture.
+      v4t_plus_v6_m
+    };
+
+  // Check we've not got a higher architecture than we know about.
+
+  if (oldtag >= elfcpp::MAX_TAG_CPU_ARCH || newtag >= elfcpp::MAX_TAG_CPU_ARCH)
+    {
+      gold_error(_("%s: unknown CPU architecture"), name);
+      return -1;
+    }
+
+  // Override old tag if we have a Tag_also_compatible_with on the output.
+
+  if ((oldtag == T(V6_M) && *secondary_compat_out == T(V4T))
+      || (oldtag == T(V4T) && *secondary_compat_out == T(V6_M)))
+    oldtag = T(V4T_PLUS_V6_M);
+
+  // And override the new tag if we have a Tag_also_compatible_with on the
+  // input.
+
+  if ((newtag == T(V6_M) && secondary_compat == T(V4T))
+      || (newtag == T(V4T) && secondary_compat == T(V6_M)))
+    newtag = T(V4T_PLUS_V6_M);
+
+  // Architectures before V6KZ add features monotonically.
+  int tagh = std::max(oldtag, newtag);
+  if (tagh <= elfcpp::TAG_CPU_ARCH_V6KZ)
+    return tagh;
+
+  int tagl = std::min(oldtag, newtag);
+  int result = comb[tagh - T(V6T2)][tagl];
+
+  // Use Tag_CPU_arch == V4T and Tag_also_compatible_with (Tag_CPU_arch V6_M)
+  // as the canonical version.
+  if (result == T(V4T_PLUS_V6_M))
+    {
+      result = T(V4T);
+      *secondary_compat_out = T(V6_M);
+    }
+  else
+    *secondary_compat_out = -1;
+
+  if (result == -1)
+    {
+      gold_error(_("%s: conflicting CPU architectures %d/%d"),
+		 name, oldtag, newtag);
+      return -1;
+    }
+
+  return result;
+#undef T
+}
+
+// Helper to print AEABI enum tag value.
+
+template<bool big_endian>
+std::string
+Target_arm<big_endian>::aeabi_enum_name(unsigned int value)
+{
+  static const char *aeabi_enum_names[] =
+    { "", "variable-size", "32-bit", "" };
+  const size_t aeabi_enum_names_size =
+    sizeof(aeabi_enum_names) / sizeof(aeabi_enum_names[0]);
+
+  if (value < aeabi_enum_names_size)
+    return std::string(aeabi_enum_names[value]);
+  else
+    {
+      char buffer[100];
+      sprintf(buffer, "<unknown value %u>", value);
+      return std::string(buffer);
+    }
+}
+
+// Return the string value to store in TAG_CPU_name.
+
+template<bool big_endian>
+std::string
+Target_arm<big_endian>::tag_cpu_name_value(unsigned int value)
+{
+  static const char *name_table[] = {
+    // These aren't real CPU names, but we can't guess
+    // that from the architecture version alone.
+   "Pre v4",
+   "ARM v4",
+   "ARM v4T",
+   "ARM v5T",
+   "ARM v5TE",
+   "ARM v5TEJ",
+   "ARM v6",
+   "ARM v6KZ",
+   "ARM v6T2",
+   "ARM v6K",
+   "ARM v7",
+   "ARM v6-M",
+   "ARM v6S-M",
+   "ARM v7E-M"
+ };
+ const size_t name_table_size = sizeof(name_table) / sizeof(name_table[0]);
+
+  if (value < name_table_size)
+    return std::string(name_table[value]);
+  else
+    {
+      char buffer[100];
+      sprintf(buffer, "<unknown CPU value %u>", value);
+      return std::string(buffer);
+    } 
+}
+
+// Merge object attributes from input file called NAME with those of the
+// output.  The input object attributes are in the object pointed by PASD.
+
+template<bool big_endian>
+void
+Target_arm<big_endian>::merge_object_attributes(
+    const char* name,
+    const Attributes_section_data* pasd)
+{
+  // Return if there is no attributes section data.
+  if (pasd == NULL)
+    return;
+
+  // If output has no object attributes, just copy.
+  if (this->attributes_section_data_ == NULL)
+    {
+      this->attributes_section_data_ = new Attributes_section_data(*pasd);
+      return;
+    }
+
+  const int vendor = Object_attribute::OBJ_ATTR_PROC;
+  const Object_attribute* in_attr = pasd->known_attributes(vendor);
+  Object_attribute* out_attr =
+    this->attributes_section_data_->known_attributes(vendor);
+
+  // This needs to happen before Tag_ABI_FP_number_model is merged.  */
+  if (in_attr[elfcpp::Tag_ABI_VFP_args].int_value()
+      != out_attr[elfcpp::Tag_ABI_VFP_args].int_value())
+    {
+      // Ignore mismatches if the object doesn't use floating point.  */
+      if (out_attr[elfcpp::Tag_ABI_FP_number_model].int_value() == 0)
+	out_attr[elfcpp::Tag_ABI_VFP_args].set_int_value(
+	    in_attr[elfcpp::Tag_ABI_VFP_args].int_value());
+      else if (in_attr[elfcpp::Tag_ABI_FP_number_model].int_value() != 0)
+        gold_error(_("%s uses VFP register arguments, output does not"),
+		   name);
+    }
+
+  for (int i = 4; i < Vendor_object_attributes::NUM_KNOWN_ATTRIBUTES; ++i)
+    {
+      // Merge this attribute with existing attributes.
+      switch (i)
+	{
+	case elfcpp::Tag_CPU_raw_name:
+	case elfcpp::Tag_CPU_name:
+	  // These are merged after Tag_CPU_arch.
+	  break;
+
+	case elfcpp::Tag_ABI_optimization_goals:
+	case elfcpp::Tag_ABI_FP_optimization_goals:
+	  // Use the first value seen.
+	  break;
+
+	case elfcpp::Tag_CPU_arch:
+	  {
+	    unsigned int saved_out_attr = out_attr->int_value();
+	    // Merge Tag_CPU_arch and Tag_also_compatible_with.
+	    int secondary_compat =
+	      this->get_secondary_compatible_arch(pasd);
+	    int secondary_compat_out =
+	      this->get_secondary_compatible_arch(
+		  this->attributes_section_data_);
+	    out_attr[i].set_int_value(
+		tag_cpu_arch_combine(name, out_attr[i].int_value(),
+				     &secondary_compat_out,
+				     in_attr[i].int_value(),
+				     secondary_compat));
+	    this->set_secondary_compatible_arch(this->attributes_section_data_,
+						secondary_compat_out);
+
+	    // Merge Tag_CPU_name and Tag_CPU_raw_name.
+	    if (out_attr[i].int_value() == saved_out_attr)
+	      ; // Leave the names alone.
+	    else if (out_attr[i].int_value() == in_attr[i].int_value())
+	      {
+		// The output architecture has been changed to match the
+		// input architecture.  Use the input names.
+		out_attr[elfcpp::Tag_CPU_name].set_string_value(
+		    in_attr[elfcpp::Tag_CPU_name].string_value());
+		out_attr[elfcpp::Tag_CPU_raw_name].set_string_value(
+		    in_attr[elfcpp::Tag_CPU_raw_name].string_value());
+	      }
+	    else
+	      {
+		out_attr[elfcpp::Tag_CPU_name].set_string_value("");
+		out_attr[elfcpp::Tag_CPU_raw_name].set_string_value("");
+	      }
+
+	    // If we still don't have a value for Tag_CPU_name,
+	    // make one up now.  Tag_CPU_raw_name remains blank.
+	    if (out_attr[elfcpp::Tag_CPU_name].string_value() == "")
+	      {
+		const std::string cpu_name =
+		  this->tag_cpu_name_value(out_attr[i].int_value());
+		// FIXME:  If we see an unknown CPU, this will be set
+		// to "<unknown CPU n>", where n is the attribute value.
+		// This is different from BFD, which leaves the name alone.
+		out_attr[elfcpp::Tag_CPU_name].set_string_value(cpu_name);
+	      }
+	  }
+	  break;
+
+	case elfcpp::Tag_ARM_ISA_use:
+	case elfcpp::Tag_THUMB_ISA_use:
+	case elfcpp::Tag_WMMX_arch:
+	case elfcpp::Tag_Advanced_SIMD_arch:
+	  // ??? Do Advanced_SIMD (NEON) and WMMX conflict?
+	case elfcpp::Tag_ABI_FP_rounding:
+	case elfcpp::Tag_ABI_FP_exceptions:
+	case elfcpp::Tag_ABI_FP_user_exceptions:
+	case elfcpp::Tag_ABI_FP_number_model:
+	case elfcpp::Tag_VFP_HP_extension:
+	case elfcpp::Tag_CPU_unaligned_access:
+	case elfcpp::Tag_T2EE_use:
+	case elfcpp::Tag_Virtualization_use:
+	case elfcpp::Tag_MPextension_use:
+	  // Use the largest value specified.
+	  if (in_attr[i].int_value() > out_attr[i].int_value())
+	    out_attr[i].set_int_value(in_attr[i].int_value());
+	  break;
+
+	case elfcpp::Tag_ABI_align8_preserved:
+	case elfcpp::Tag_ABI_PCS_RO_data:
+	  // Use the smallest value specified.
+	  if (in_attr[i].int_value() < out_attr[i].int_value())
+	    out_attr[i].set_int_value(in_attr[i].int_value());
+	  break;
+
+	case elfcpp::Tag_ABI_align8_needed:
+	  if ((in_attr[i].int_value() > 0 || out_attr[i].int_value() > 0)
+	      && (in_attr[elfcpp::Tag_ABI_align8_preserved].int_value() == 0
+		  || (out_attr[elfcpp::Tag_ABI_align8_preserved].int_value()
+		      == 0)))
+	    {
+	      // This error message should be enabled once all non-conformant
+	      // binaries in the toolchain have had the attributes set
+	      // properly.
+	      // gold_error(_("output 8-byte data alignment conflicts with %s"),
+	      // 	    name);
+	    }
+	  // Fall through.
+	case elfcpp::Tag_ABI_FP_denormal:
+	case elfcpp::Tag_ABI_PCS_GOT_use:
+	  {
+	    // These tags have 0 = don't care, 1 = strong requirement,
+	    // 2 = weak requirement.
+	    static const int order_021[3] = {0, 2, 1};
+
+	    // Use the "greatest" from the sequence 0, 2, 1, or the largest
+	    // value if greater than 2 (for future-proofing).
+	    if ((in_attr[i].int_value() > 2
+		 && in_attr[i].int_value() > out_attr[i].int_value())
+		|| (in_attr[i].int_value() <= 2
+		    && out_attr[i].int_value() <= 2
+		    && (order_021[in_attr[i].int_value()]
+			> order_021[out_attr[i].int_value()])))
+	      out_attr[i].set_int_value(in_attr[i].int_value());
+	  }
+	  break;
+
+	case elfcpp::Tag_CPU_arch_profile:
+	  if (out_attr[i].int_value() != in_attr[i].int_value())
+	    {
+	      // 0 will merge with anything.
+	      // 'A' and 'S' merge to 'A'.
+	      // 'R' and 'S' merge to 'R'.
+	      // 'M' and 'A|R|S' is an error.
+	      if (out_attr[i].int_value() == 0
+		  || (out_attr[i].int_value() == 'S'
+		      && (in_attr[i].int_value() == 'A'
+			  || in_attr[i].int_value() == 'R')))
+		out_attr[i].set_int_value(in_attr[i].int_value());
+	      else if (in_attr[i].int_value() == 0
+		       || (in_attr[i].int_value() == 'S'
+			   && (out_attr[i].int_value() == 'A'
+			       || out_attr[i].int_value() == 'R')))
+		; // Do nothing.
+	      else
+		{
+		  gold_error
+		    (_("conflicting architecture profiles %c/%c"),
+		     in_attr[i].int_value() ? in_attr[i].int_value() : '0',
+		     out_attr[i].int_value() ? out_attr[i].int_value() : '0');
+		}
+	    }
+	  break;
+	case elfcpp::Tag_VFP_arch:
+	    {
+	      static const struct
+	      {
+		  int ver;
+		  int regs;
+	      } vfp_versions[7] =
+		{
+		  {0, 0},
+		  {1, 16},
+		  {2, 16},
+		  {3, 32},
+		  {3, 16},
+		  {4, 32},
+		  {4, 16}
+		};
+
+	      // Values greater than 6 aren't defined, so just pick the
+	      // biggest.
+	      if (in_attr[i].int_value() > 6
+		  && in_attr[i].int_value() > out_attr[i].int_value())
+		{
+		  *out_attr = *in_attr;
+		  break;
+		}
+	      // The output uses the superset of input features
+	      // (ISA version) and registers.
+	      int ver = std::max(vfp_versions[in_attr[i].int_value()].ver,
+				 vfp_versions[out_attr[i].int_value()].ver);
+	      int regs = std::max(vfp_versions[in_attr[i].int_value()].regs,
+				  vfp_versions[out_attr[i].int_value()].regs);
+	      // This assumes all possible supersets are also a valid
+	      // options.
+	      int newval;
+	      for (newval = 6; newval > 0; newval--)
+		{
+		  if (regs == vfp_versions[newval].regs
+		      && ver == vfp_versions[newval].ver)
+		    break;
+		}
+	      out_attr[i].set_int_value(newval);
+	    }
+	  break;
+	case elfcpp::Tag_PCS_config:
+	  if (out_attr[i].int_value() == 0)
+	    out_attr[i].set_int_value(in_attr[i].int_value());
+	  else if (in_attr[i].int_value() != 0 && out_attr[i].int_value() != 0)
+	    {
+	      // It's sometimes ok to mix different configs, so this is only
+	      // a warning.
+	      gold_warning(_("%s: conflicting platform configuration"), name);
+	    }
+	  break;
+	case elfcpp::Tag_ABI_PCS_R9_use:
+	  if (in_attr[i].int_value() != out_attr[i].int_value()
+	      && out_attr[i].int_value() != elfcpp::AEABI_R9_unused
+	      && in_attr[i].int_value() != elfcpp::AEABI_R9_unused)
+	    {
+	      gold_error(_("%s: conflicting use of R9"), name);
+	    }
+	  if (out_attr[i].int_value() == elfcpp::AEABI_R9_unused)
+	    out_attr[i].set_int_value(in_attr[i].int_value());
+	  break;
+	case elfcpp::Tag_ABI_PCS_RW_data:
+	  if (in_attr[i].int_value() == elfcpp::AEABI_PCS_RW_data_SBrel
+	      && (in_attr[elfcpp::Tag_ABI_PCS_R9_use].int_value()
+		  != elfcpp::AEABI_R9_SB)
+	      && (out_attr[elfcpp::Tag_ABI_PCS_R9_use].int_value()
+		  != elfcpp::AEABI_R9_unused))
+	    {
+	      gold_error(_("%s: SB relative addressing conflicts with use "
+			   "of R9"),
+			 name);
+	    }
+	  // Use the smallest value specified.
+	  if (in_attr[i].int_value() < out_attr[i].int_value())
+	    out_attr[i].set_int_value(in_attr[i].int_value());
+	  break;
+	case elfcpp::Tag_ABI_PCS_wchar_t:
+	  // FIXME: Make it possible to turn off this warning.
+	  if (out_attr[i].int_value()
+	      && in_attr[i].int_value()
+	      && out_attr[i].int_value() != in_attr[i].int_value())
+	    {
+	      gold_warning(_("%s uses %u-byte wchar_t yet the output is to "
+			     "use %u-byte wchar_t; use of wchar_t values "
+			     "across objects may fail"),
+			   name, in_attr[i].int_value(),
+			   out_attr[i].int_value());
+	    }
+	  else if (in_attr[i].int_value() && !out_attr[i].int_value())
+	    out_attr[i].set_int_value(in_attr[i].int_value());
+	  break;
+	case elfcpp::Tag_ABI_enum_size:
+	  if (in_attr[i].int_value() != elfcpp::AEABI_enum_unused)
+	    {
+	      if (out_attr[i].int_value() == elfcpp::AEABI_enum_unused
+		  || out_attr[i].int_value() == elfcpp::AEABI_enum_forced_wide)
+		{
+		  // The existing object is compatible with anything.
+		  // Use whatever requirements the new object has.
+		  out_attr[i].set_int_value(in_attr[i].int_value());
+		}
+	      // FIXME: Make it possible to turn off this warning.
+	      else if (in_attr[i].int_value() != elfcpp::AEABI_enum_forced_wide
+		       && out_attr[i].int_value() != in_attr[i].int_value())
+		{
+		  unsigned int in_value = in_attr[i].int_value();
+		  unsigned int out_value = out_attr[i].int_value();
+		  gold_warning(_("%s uses %s enums yet the output is to use "
+				 "%s enums; use of enum values across objects "
+				 "may fail"),
+			       name,
+			       this->aeabi_enum_name(in_value).c_str(),
+			       this->aeabi_enum_name(out_value).c_str());
+		}
+	    }
+	  break;
+	case elfcpp::Tag_ABI_VFP_args:
+	  // Aready done.
+	  break;
+	case elfcpp::Tag_ABI_WMMX_args:
+	  if (in_attr[i].int_value() != out_attr[i].int_value())
+	    {
+	      gold_error(_("%s uses iWMMXt register arguments, output does "
+			   "not"),
+			 name);
+	    }
+	  break;
+	case Object_attribute::Tag_compatibility:
+	  // Merged in target-independent code.
+	  break;
+	case elfcpp::Tag_ABI_HardFP_use:
+	  // 1 (SP) and 2 (DP) conflict, so combine to 3 (SP & DP).
+	  if ((in_attr[i].int_value() == 1 && out_attr[i].int_value() == 2)
+	      || (in_attr[i].int_value() == 2 && out_attr[i].int_value() == 1))
+	    out_attr[i].set_int_value(3);
+	  else if (in_attr[i].int_value() > out_attr[i].int_value())
+	    out_attr[i].set_int_value(in_attr[i].int_value());
+	  break;
+	case elfcpp::Tag_ABI_FP_16bit_format:
+	  if (in_attr[i].int_value() != 0 && out_attr[i].int_value() != 0)
+	    {
+	      if (in_attr[i].int_value() != out_attr[i].int_value())
+		gold_error(_("fp16 format mismatch between %s and output"),
+			   name);
+	    }
+	  if (in_attr[i].int_value() != 0)
+	    out_attr[i].set_int_value(in_attr[i].int_value());
+	  break;
+
+	case elfcpp::Tag_nodefaults:
+	  // This tag is set if it exists, but the value is unused (and is
+	  // typically zero).  We don't actually need to do anything here -
+	  // the merge happens automatically when the type flags are merged
+	  // below.
+	  break;
+	case elfcpp::Tag_also_compatible_with:
+	  // Already done in Tag_CPU_arch.
+	  break;
+	case elfcpp::Tag_conformance:
+	  // Keep the attribute if it matches.  Throw it away otherwise.
+	  // No attribute means no claim to conform.
+	  if (in_attr[i].string_value() != out_attr[i].string_value())
+	    out_attr[i].set_string_value("");
+	  break;
+
+	default:
+	  {
+	    const char* err_object = NULL;
+
+	    // The "known_obj_attributes" table does contain some undefined
+	    // attributes.  Ensure that there are unused.
+	    if (out_attr[i].int_value() != 0
+		|| out_attr[i].string_value() != "")
+	      err_object = "output";
+	    else if (in_attr[i].int_value() != 0
+		     || in_attr[i].string_value() != "")
+	      err_object = name;
+
+	    if (err_object != NULL)
+	      {
+		// Attribute numbers >=64 (mod 128) can be safely ignored.
+		if ((i & 127) < 64)
+		  gold_error(_("%s: unknown mandatory EABI object attribute "
+			       "%d"),
+			     err_object, i);
+		else
+		  gold_warning(_("%s: unknown EABI object attribute %d"),
+			       err_object, i);
+	      }
+
+	    // Only pass on attributes that match in both inputs.
+	    if (!in_attr[i].matches(out_attr[i]))
+	      {
+		out_attr[i].set_int_value(0);
+		out_attr[i].set_string_value("");
+	      }
+	  }
+	}
+
+      // If out_attr was copied from in_attr then it won't have a type yet.
+      if (in_attr[i].type() && !out_attr[i].type())
+	out_attr[i].set_type(in_attr[i].type());
+    }
+
+  // Merge Tag_compatibility attributes and any common GNU ones.
+  this->attributes_section_data_->merge(name, pasd);
+
+  // Check for any attributes not known on ARM.
+  typedef Vendor_object_attributes::Other_attributes Other_attributes;
+  const Other_attributes* in_other_attributes = pasd->other_attributes(vendor);
+  Other_attributes::const_iterator in_iter = in_other_attributes->begin();
+  Other_attributes* out_other_attributes =
+    this->attributes_section_data_->other_attributes(vendor);
+  Other_attributes::iterator out_iter = out_other_attributes->begin();
+
+  while (in_iter != in_other_attributes->end()
+	 || out_iter != out_other_attributes->end())
+    {
+      const char* err_object = NULL;
+      int err_tag = 0;
+
+      // The tags for each list are in numerical order.
+      // If the tags are equal, then merge.
+      if (out_iter != out_other_attributes->end()
+	  && (in_iter == in_other_attributes->end()
+	      || in_iter->first > out_iter->first))
+	{
+	  // This attribute only exists in output.  We can't merge, and we
+	  // don't know what the tag means, so delete it.
+	  err_object = "output";
+	  err_tag = out_iter->first;
+	  int saved_tag = out_iter->first;
+	  delete out_iter->second;
+	  out_other_attributes->erase(out_iter); 
+	  out_iter = out_other_attributes->upper_bound(saved_tag);
+	}
+      else if (in_iter != in_other_attributes->end()
+	       && (out_iter != out_other_attributes->end()
+		   || in_iter->first < out_iter->first))
+	{
+	  // This attribute only exists in input. We can't merge, and we
+	  // don't know what the tag means, so ignore it.
+	  err_object = name;
+	  err_tag = in_iter->first;
+	  ++in_iter;
+	}
+      else // The tags are equal.
+	{
+	  // As present, all attributes in the list are unknown, and
+	  // therefore can't be merged meaningfully.
+	  err_object = "output";
+	  err_tag = out_iter->first;
+
+	  //  Only pass on attributes that match in both inputs.
+	  if (!in_iter->second->matches(*(out_iter->second)))
+	    {
+	      // No match.  Delete the attribute.
+	      int saved_tag = out_iter->first;
+	      delete out_iter->second;
+	      out_other_attributes->erase(out_iter);
+	      out_iter = out_other_attributes->upper_bound(saved_tag);
+	    }
+	  else
+	    {
+	      // Matched.  Keep the attribute and move to the next.
+	      ++out_iter;
+	      ++in_iter;
+	    }
+	}
+
+      if (err_object)
+	{
+	  // Attribute numbers >=64 (mod 128) can be safely ignored.  */
+	  if ((err_tag & 127) < 64)
+	    {
+	      gold_error(_("%s: unknown mandatory EABI object attribute %d"),
+			 err_object, err_tag);
+	    }
+	  else
+	    {
+	      gold_warning(_("%s: unknown EABI object attribute %d"),
+			   err_object, err_tag);
+	    }
+	}
+    }
+}
+
+// Stub-generation methods for Target_arm.
+
+// Make a new Arm_input_section object.
+
+template<bool big_endian>
+Arm_input_section<big_endian>*
+Target_arm<big_endian>::new_arm_input_section(
+    Relobj* relobj,
+    unsigned int shndx)
+{
+  Section_id sid(relobj, shndx);
+
+  Arm_input_section<big_endian>* arm_input_section =
+    new Arm_input_section<big_endian>(relobj, shndx);
+  arm_input_section->init();
+
+  // Register new Arm_input_section in map for look-up.
+  std::pair<typename Arm_input_section_map::iterator, bool> ins =
+    this->arm_input_section_map_.insert(std::make_pair(sid, arm_input_section));
+
+  // Make sure that it we have not created another Arm_input_section
+  // for this input section already.
+  gold_assert(ins.second);
+
+  return arm_input_section; 
+}
+
+// Find the Arm_input_section object corresponding to the SHNDX-th input
+// section of RELOBJ.
+
+template<bool big_endian>
+Arm_input_section<big_endian>*
+Target_arm<big_endian>::find_arm_input_section(
+    Relobj* relobj,
+    unsigned int shndx) const
+{
+  Section_id sid(relobj, shndx);
+  typename Arm_input_section_map::const_iterator p =
+    this->arm_input_section_map_.find(sid);
+  return (p != this->arm_input_section_map_.end()) ? p->second : NULL;
+}
+
+// Make a new stub table.
+
+template<bool big_endian>
+Stub_table<big_endian>*
+Target_arm<big_endian>::new_stub_table(Arm_input_section<big_endian>* owner)
+{
+  Stub_table<big_endian>* stub_table =
+    new Stub_table<big_endian>(owner);
+  this->stub_tables_.push_back(stub_table);
+
+  stub_table->set_address(owner->address() + owner->data_size());
+  stub_table->set_file_offset(owner->offset() + owner->data_size());
+  stub_table->finalize_data_size();
+
+  return stub_table;
+}
+
+// Scan a relocation for stub generation.
+
+template<bool big_endian>
+void
+Target_arm<big_endian>::scan_reloc_for_stub(
+    const Relocate_info<32, big_endian>* relinfo,
+    unsigned int r_type,
+    const Sized_symbol<32>* gsym,
+    unsigned int r_sym,
+    const Symbol_value<32>* psymval,
+    elfcpp::Elf_types<32>::Elf_Swxword addend,
+    Arm_address address)
+{
+  typedef typename Target_arm<big_endian>::Relocate Relocate;
+
+  const Arm_relobj<big_endian>* arm_relobj =
+    Arm_relobj<big_endian>::as_arm_relobj(relinfo->object);
+
+  if (r_type == elfcpp::R_ARM_V4BX)
+    {
+      const uint32_t reg = (addend & 0xf);
+      if (this->fix_v4bx() == General_options::FIX_V4BX_INTERWORKING
+	  && reg < 0xf)
+	{
+	  // Try looking up an existing stub from a stub table.
+	  Stub_table<big_endian>* stub_table =
+	    arm_relobj->stub_table(relinfo->data_shndx);
+	  gold_assert(stub_table != NULL);
+
+	  if (stub_table->find_arm_v4bx_stub(reg) == NULL)
+	    {
+	      // create a new stub and add it to stub table.
+	      Arm_v4bx_stub* stub =
+		this->stub_factory().make_arm_v4bx_stub(reg);
+	      gold_assert(stub != NULL);
+	      stub_table->add_arm_v4bx_stub(stub);
+	    }
+	}
+
+      return;
+    }
+
+  bool target_is_thumb;
+  Symbol_value<32> symval;
+  if (gsym != NULL)
+    {
+      // This is a global symbol.  Determine if we use PLT and if the
+      // final target is THUMB.
+      if (gsym->use_plt_offset(Relocate::reloc_is_non_pic(r_type)))
+	{
+	  // This uses a PLT, change the symbol value.
+	  symval.set_output_value(this->plt_section()->address()
+				  + gsym->plt_offset());
+	  psymval = &symval;
+	  target_is_thumb = false;
+	}
+      else if (gsym->is_undefined())
+	// There is no need to generate a stub symbol is undefined.
+	return;
+      else
+	{
+	  target_is_thumb =
+	    ((gsym->type() == elfcpp::STT_ARM_TFUNC)
+	     || (gsym->type() == elfcpp::STT_FUNC
+		 && !gsym->is_undefined()
+		 && ((psymval->value(arm_relobj, 0) & 1) != 0)));
+	}
+    }
+  else
+    {
+      // This is a local symbol.  Determine if the final target is THUMB.
+      target_is_thumb = arm_relobj->local_symbol_is_thumb_function(r_sym);
+    }
+
+  // Strip LSB if this points to a THUMB target.
+  const Arm_reloc_property* reloc_property =
+    arm_reloc_property_table->get_implemented_static_reloc_property(r_type);
+  gold_assert(reloc_property != NULL);
+  if (target_is_thumb
+      && reloc_property->uses_thumb_bit()
+      && ((psymval->value(arm_relobj, 0) & 1) != 0))
+    {
+      Arm_address stripped_value =
+	psymval->value(arm_relobj, 0) & ~static_cast<Arm_address>(1);
+      symval.set_output_value(stripped_value);
+      psymval = &symval;
+    } 
+
+  // Get the symbol value.
+  Symbol_value<32>::Value value = psymval->value(arm_relobj, 0);
+
+  // Owing to pipelining, the PC relative branches below actually skip
+  // two instructions when the branch offset is 0.
+  Arm_address destination;
+  switch (r_type)
+    {
+    case elfcpp::R_ARM_CALL:
+    case elfcpp::R_ARM_JUMP24:
+    case elfcpp::R_ARM_PLT32:
+      // ARM branches.
+      destination = value + addend + 8;
+      break;
+    case elfcpp::R_ARM_THM_CALL:
+    case elfcpp::R_ARM_THM_XPC22:
+    case elfcpp::R_ARM_THM_JUMP24:
+    case elfcpp::R_ARM_THM_JUMP19:
+      // THUMB branches.
+      destination = value + addend + 4;
+      break;
+    default:
+      gold_unreachable();
+    }
+
+  Reloc_stub* stub = NULL;
+  Stub_type stub_type =
+    Reloc_stub::stub_type_for_reloc(r_type, address, destination,
+				    target_is_thumb);
+  if (stub_type != arm_stub_none)
+    {
+      // Try looking up an existing stub from a stub table.
+      Stub_table<big_endian>* stub_table = 
+	arm_relobj->stub_table(relinfo->data_shndx);
+      gold_assert(stub_table != NULL);
+   
+      // Locate stub by destination.
+      Reloc_stub::Key stub_key(stub_type, gsym, arm_relobj, r_sym, addend);
+
+      // Create a stub if there is not one already
+      stub = stub_table->find_reloc_stub(stub_key);
+      if (stub == NULL)
+	{
+	  // create a new stub and add it to stub table.
+	  stub = this->stub_factory().make_reloc_stub(stub_type);
+	  stub_table->add_reloc_stub(stub, stub_key);
+	}
+
+      // Record the destination address.
+      stub->set_destination_address(destination
+				    | (target_is_thumb ? 1 : 0));
+    }
+
+  // For Cortex-A8, we need to record a relocation at 4K page boundary.
+  if (this->fix_cortex_a8_
+      && (r_type == elfcpp::R_ARM_THM_JUMP24
+	  || r_type == elfcpp::R_ARM_THM_JUMP19
+	  || r_type == elfcpp::R_ARM_THM_CALL
+	  || r_type == elfcpp::R_ARM_THM_XPC22)
+      && (address & 0xfffU) == 0xffeU)
+    {
+      // Found a candidate.  Note we haven't checked the destination is
+      // within 4K here: if we do so (and don't create a record) we can't
+      // tell that a branch should have been relocated when scanning later.
+      this->cortex_a8_relocs_info_[address] =
+	new Cortex_a8_reloc(stub, r_type,
+			    destination | (target_is_thumb ? 1 : 0));
+    }
+}
+
+// This function scans a relocation sections for stub generation.
+// The template parameter Relocate must be a class type which provides
+// a single function, relocate(), which implements the machine
+// specific part of a relocation.
+
+// BIG_ENDIAN is the endianness of the data.  SH_TYPE is the section type:
+// SHT_REL or SHT_RELA.
+
+// PRELOCS points to the relocation data.  RELOC_COUNT is the number
+// of relocs.  OUTPUT_SECTION is the output section.
+// NEEDS_SPECIAL_OFFSET_HANDLING is true if input offsets need to be
+// mapped to output offsets.
+
+// VIEW is the section data, VIEW_ADDRESS is its memory address, and
+// VIEW_SIZE is the size.  These refer to the input section, unless
+// NEEDS_SPECIAL_OFFSET_HANDLING is true, in which case they refer to
+// the output section.
+
+template<bool big_endian>
+template<int sh_type>
+void inline
+Target_arm<big_endian>::scan_reloc_section_for_stubs(
+    const Relocate_info<32, big_endian>* relinfo,
+    const unsigned char* prelocs,
+    size_t reloc_count,
+    Output_section* output_section,
+    bool needs_special_offset_handling,
+    const unsigned char* view,
+    elfcpp::Elf_types<32>::Elf_Addr view_address,
+    section_size_type)
+{
+  typedef typename Reloc_types<sh_type, 32, big_endian>::Reloc Reltype;
+  const int reloc_size =
+    Reloc_types<sh_type, 32, big_endian>::reloc_size;
+
+  Arm_relobj<big_endian>* arm_object =
+    Arm_relobj<big_endian>::as_arm_relobj(relinfo->object);
+  unsigned int local_count = arm_object->local_symbol_count();
+
+  Comdat_behavior comdat_behavior = CB_UNDETERMINED;
+
+  for (size_t i = 0; i < reloc_count; ++i, prelocs += reloc_size)
+    {
+      Reltype reloc(prelocs);
+
+      typename elfcpp::Elf_types<32>::Elf_WXword r_info = reloc.get_r_info();
+      unsigned int r_sym = elfcpp::elf_r_sym<32>(r_info);
+      unsigned int r_type = elfcpp::elf_r_type<32>(r_info);
+
+      r_type = this->get_real_reloc_type(r_type);
+
+      // Only a few relocation types need stubs.
+      if ((r_type != elfcpp::R_ARM_CALL)
+         && (r_type != elfcpp::R_ARM_JUMP24)
+         && (r_type != elfcpp::R_ARM_PLT32)
+         && (r_type != elfcpp::R_ARM_THM_CALL)
+         && (r_type != elfcpp::R_ARM_THM_XPC22)
+         && (r_type != elfcpp::R_ARM_THM_JUMP24)
+         && (r_type != elfcpp::R_ARM_THM_JUMP19)
+         && (r_type != elfcpp::R_ARM_V4BX))
+	continue;
+
+      section_offset_type offset =
+	convert_to_section_size_type(reloc.get_r_offset());
+
+      if (needs_special_offset_handling)
+	{
+	  offset = output_section->output_offset(relinfo->object,
+						 relinfo->data_shndx,
+						 offset);
+	  if (offset == -1)
+	    continue;
+	}
+
+      if (r_type == elfcpp::R_ARM_V4BX)
+	{
+	  // Get the BX instruction.
+	  typedef typename elfcpp::Swap<32, big_endian>::Valtype Valtype;
+	  const Valtype* wv = reinterpret_cast<const Valtype*>(view + offset);
+	  elfcpp::Elf_types<32>::Elf_Swxword insn =
+	      elfcpp::Swap<32, big_endian>::readval(wv);
+	  this->scan_reloc_for_stub(relinfo, r_type, NULL, 0, NULL,
+				    insn, NULL);
+	  continue;
+	}
+
+      // Get the addend.
+      Stub_addend_reader<sh_type, big_endian> stub_addend_reader;
+      elfcpp::Elf_types<32>::Elf_Swxword addend =
+	stub_addend_reader(r_type, view + offset, reloc);
+
+      const Sized_symbol<32>* sym;
+
+      Symbol_value<32> symval;
+      const Symbol_value<32> *psymval;
+      if (r_sym < local_count)
+	{
+	  sym = NULL;
+	  psymval = arm_object->local_symbol(r_sym);
+
+          // If the local symbol belongs to a section we are discarding,
+          // and that section is a debug section, try to find the
+          // corresponding kept section and map this symbol to its
+          // counterpart in the kept section.  The symbol must not 
+          // correspond to a section we are folding.
+	  bool is_ordinary;
+	  unsigned int shndx = psymval->input_shndx(&is_ordinary);
+	  if (is_ordinary
+	      && shndx != elfcpp::SHN_UNDEF
+	      && !arm_object->is_section_included(shndx) 
+              && !(relinfo->symtab->is_section_folded(arm_object, shndx)))
+	    {
+	      if (comdat_behavior == CB_UNDETERMINED)
+	        {
+	          std::string name =
+		    arm_object->section_name(relinfo->data_shndx);
+	          comdat_behavior = get_comdat_behavior(name.c_str());
+	        }
+	      if (comdat_behavior == CB_PRETEND)
+	        {
+                  bool found;
+	          typename elfcpp::Elf_types<32>::Elf_Addr value =
+	            arm_object->map_to_kept_section(shndx, &found);
+	          if (found)
+	            symval.set_output_value(value + psymval->input_value());
+                  else
+                    symval.set_output_value(0);
+	        }
+	      else
+	        {
+                  symval.set_output_value(0);
+	        }
+	      symval.set_no_output_symtab_entry();
+	      psymval = &symval;
+	    }
+	}
+      else
+	{
+	  const Symbol* gsym = arm_object->global_symbol(r_sym);
+	  gold_assert(gsym != NULL);
+	  if (gsym->is_forwarder())
+	    gsym = relinfo->symtab->resolve_forwards(gsym);
+
+	  sym = static_cast<const Sized_symbol<32>*>(gsym);
+	  if (sym->has_symtab_index())
+	    symval.set_output_symtab_index(sym->symtab_index());
+	  else
+	    symval.set_no_output_symtab_entry();
+
+	  // We need to compute the would-be final value of this global
+	  // symbol.
+	  const Symbol_table* symtab = relinfo->symtab;
+	  const Sized_symbol<32>* sized_symbol =
+	    symtab->get_sized_symbol<32>(gsym);
+	  Symbol_table::Compute_final_value_status status;
+	  Arm_address value =
+	    symtab->compute_final_value<32>(sized_symbol, &status);
+
+	  // Skip this if the symbol has not output section.
+	  if (status == Symbol_table::CFVS_NO_OUTPUT_SECTION)
+	    continue;
+
+	  symval.set_output_value(value);
+	  psymval = &symval;
+	}
+
+      // If symbol is a section symbol, we don't know the actual type of
+      // destination.  Give up.
+      if (psymval->is_section_symbol())
+	continue;
+
+      this->scan_reloc_for_stub(relinfo, r_type, sym, r_sym, psymval,
+				addend, view_address + offset);
+    }
+}
+
+// Scan an input section for stub generation.
+
+template<bool big_endian>
+void
+Target_arm<big_endian>::scan_section_for_stubs(
+    const Relocate_info<32, big_endian>* relinfo,
+    unsigned int sh_type,
+    const unsigned char* prelocs,
+    size_t reloc_count,
+    Output_section* output_section,
+    bool needs_special_offset_handling,
+    const unsigned char* view,
+    Arm_address view_address,
+    section_size_type view_size)
+{
+  if (sh_type == elfcpp::SHT_REL)
+    this->scan_reloc_section_for_stubs<elfcpp::SHT_REL>(
+	relinfo,
+	prelocs,
+	reloc_count,
+	output_section,
+	needs_special_offset_handling,
+	view,
+	view_address,
+	view_size);
+  else if (sh_type == elfcpp::SHT_RELA)
+    // We do not support RELA type relocations yet.  This is provided for
+    // completeness.
+    this->scan_reloc_section_for_stubs<elfcpp::SHT_RELA>(
+	relinfo,
+	prelocs,
+	reloc_count,
+	output_section,
+	needs_special_offset_handling,
+	view,
+	view_address,
+	view_size);
+  else
+    gold_unreachable();
+}
+
+// Group input sections for stub generation.
+//
+// We goup input sections in an output sections so that the total size,
+// including any padding space due to alignment is smaller than GROUP_SIZE
+// unless the only input section in group is bigger than GROUP_SIZE already.
+// Then an ARM stub table is created to follow the last input section
+// in group.  For each group an ARM stub table is created an is placed
+// after the last group.  If STUB_ALWATS_AFTER_BRANCH is false, we further
+// extend the group after the stub table.
+
+template<bool big_endian>
+void
+Target_arm<big_endian>::group_sections(
+    Layout* layout,
+    section_size_type group_size,
+    bool stubs_always_after_branch)
+{
+  // Group input sections and insert stub table
+  Layout::Section_list section_list;
+  layout->get_allocated_sections(&section_list);
+  for (Layout::Section_list::const_iterator p = section_list.begin();
+       p != section_list.end();
+       ++p)
+    {
+      Arm_output_section<big_endian>* output_section =
+	Arm_output_section<big_endian>::as_arm_output_section(*p);
+      output_section->group_sections(group_size, stubs_always_after_branch,
+				     this);
+    }
+}
+
+// Relaxation hook.  This is where we do stub generation.
+
+template<bool big_endian>
+bool
+Target_arm<big_endian>::do_relax(
+    int pass,
+    const Input_objects* input_objects,
+    Symbol_table* symtab,
+    Layout* layout)
+{
+  // No need to generate stubs if this is a relocatable link.
+  gold_assert(!parameters->options().relocatable());
+
+  // If this is the first pass, we need to group input sections into
+  // stub groups.
+  bool done_exidx_fixup = false;
+  if (pass == 1)
+    {
+      // Determine the stub group size.  The group size is the absolute
+      // value of the parameter --stub-group-size.  If --stub-group-size
+      // is passed a negative value, we restict stubs to be always after
+      // the stubbed branches.
+      int32_t stub_group_size_param =
+	parameters->options().stub_group_size();
+      bool stubs_always_after_branch = stub_group_size_param < 0;
+      section_size_type stub_group_size = abs(stub_group_size_param);
+
+      // The Cortex-A8 erratum fix depends on stubs not being in the same 4K
+      // page as the first half of a 32-bit branch straddling two 4K pages.
+      // This is a crude way of enforcing that.
+      if (this->fix_cortex_a8_)
+	stubs_always_after_branch = true;
+
+      if (stub_group_size == 1)
+	{
+	  // Default value.
+	  // Thumb branch range is +-4MB has to be used as the default
+	  // maximum size (a given section can contain both ARM and Thumb
+	  // code, so the worst case has to be taken into account).
+	  //
+	  // This value is 24K less than that, which allows for 2025
+	  // 12-byte stubs.  If we exceed that, then we will fail to link.
+	  // The user will have to relink with an explicit group size
+	  // option.
+	  stub_group_size = 4170000;
+	}
+
+      group_sections(layout, stub_group_size, stubs_always_after_branch);
+     
+      // Also fix .ARM.exidx section coverage.
+      Output_section* os = layout->find_output_section(".ARM.exidx");
+      if (os != NULL && os->type() == elfcpp::SHT_ARM_EXIDX)
+	{
+	  Arm_output_section<big_endian>* exidx_output_section =
+	    Arm_output_section<big_endian>::as_arm_output_section(os);
+	  this->fix_exidx_coverage(layout, exidx_output_section, symtab);
+	  done_exidx_fixup = true;
+	}
+    }
+
+  // The Cortex-A8 stubs are sensitive to layout of code sections.  At the
+  // beginning of each relaxation pass, just blow away all the stubs.
+  // Alternatively, we could selectively remove only the stubs and reloc
+  // information for code sections that have moved since the last pass.
+  // That would require more book-keeping.
+  typedef typename Stub_table_list::iterator Stub_table_iterator;
+  if (this->fix_cortex_a8_)
+    {
+      // Clear all Cortex-A8 reloc information.
+      for (typename Cortex_a8_relocs_info::const_iterator p =
+	     this->cortex_a8_relocs_info_.begin();
+	   p != this->cortex_a8_relocs_info_.end();
+	   ++p)
+	delete p->second;
+      this->cortex_a8_relocs_info_.clear();
+
+      // Remove all Cortex-A8 stubs.
+      for (Stub_table_iterator sp = this->stub_tables_.begin();
+	   sp != this->stub_tables_.end();
+	   ++sp)
+	(*sp)->remove_all_cortex_a8_stubs();
+    }
+  
+  // Scan relocs for relocation stubs
+  for (Input_objects::Relobj_iterator op = input_objects->relobj_begin();
+       op != input_objects->relobj_end();
+       ++op)
+    {
+      Arm_relobj<big_endian>* arm_relobj =
+	Arm_relobj<big_endian>::as_arm_relobj(*op);
+      arm_relobj->scan_sections_for_stubs(this, symtab, layout);
+    }
+
+  // Check all stub tables to see if any of them have their data sizes
+  // or addresses alignments changed.  These are the only things that
+  // matter.
+  bool any_stub_table_changed = false;
+  Unordered_set<const Output_section*> sections_needing_adjustment;
+  for (Stub_table_iterator sp = this->stub_tables_.begin();
+       (sp != this->stub_tables_.end()) && !any_stub_table_changed;
+       ++sp)
+    {
+      if ((*sp)->update_data_size_and_addralign())
+	{
+	  // Update data size of stub table owner.
+	  Arm_input_section<big_endian>* owner = (*sp)->owner();
+	  uint64_t address = owner->address();
+	  off_t offset = owner->offset();
+	  owner->reset_address_and_file_offset();
+	  owner->set_address_and_file_offset(address, offset);
+
+	  sections_needing_adjustment.insert(owner->output_section());
+	  any_stub_table_changed = true;
+	}
+    }
+
+  // Output_section_data::output_section() returns a const pointer but we
+  // need to update output sections, so we record all output sections needing
+  // update above and scan the sections here to find out what sections need
+  // to be updated.
+  for(Layout::Section_list::const_iterator p = layout->section_list().begin();
+      p != layout->section_list().end();
+      ++p)
+    {
+      if (sections_needing_adjustment.find(*p)
+	  != sections_needing_adjustment.end())
+	(*p)->set_section_offsets_need_adjustment();
+    }
+
+  // Stop relaxation if no EXIDX fix-up and no stub table change.
+  bool continue_relaxation = done_exidx_fixup || any_stub_table_changed;
+
+  // Finalize the stubs in the last relaxation pass.
+  if (!continue_relaxation)
+    {
+      for (Stub_table_iterator sp = this->stub_tables_.begin();
+	   (sp != this->stub_tables_.end()) && !any_stub_table_changed;
+	    ++sp)
+	(*sp)->finalize_stubs();
+
+      // Update output local symbol counts of objects if necessary.
+      for (Input_objects::Relobj_iterator op = input_objects->relobj_begin();
+	   op != input_objects->relobj_end();
+	   ++op)
+	{
+	  Arm_relobj<big_endian>* arm_relobj =
+	    Arm_relobj<big_endian>::as_arm_relobj(*op);
+
+	  // Update output local symbol counts.  We need to discard local
+	  // symbols defined in parts of input sections that are discarded by
+	  // relaxation.
+	  if (arm_relobj->output_local_symbol_count_needs_update())
+	    arm_relobj->update_output_local_symbol_count();
+	}
+    }
+
+  return continue_relaxation;
+}
+
+// Relocate a stub.
+
+template<bool big_endian>
+void
+Target_arm<big_endian>::relocate_stub(
+    Stub* stub,
+    const Relocate_info<32, big_endian>* relinfo,
+    Output_section* output_section,
+    unsigned char* view,
+    Arm_address address,
+    section_size_type view_size)
+{
+  Relocate relocate;
+  const Stub_template* stub_template = stub->stub_template();
+  for (size_t i = 0; i < stub_template->reloc_count(); i++)
+    {
+      size_t reloc_insn_index = stub_template->reloc_insn_index(i);
+      const Insn_template* insn = &stub_template->insns()[reloc_insn_index];
+
+      unsigned int r_type = insn->r_type();
+      section_size_type reloc_offset = stub_template->reloc_offset(i);
+      section_size_type reloc_size = insn->size();
+      gold_assert(reloc_offset + reloc_size <= view_size);
+
+      // This is the address of the stub destination.
+      Arm_address target = stub->reloc_target(i) + insn->reloc_addend();
+      Symbol_value<32> symval;
+      symval.set_output_value(target);
+
+      // Synthesize a fake reloc just in case.  We don't have a symbol so
+      // we use 0.
+      unsigned char reloc_buffer[elfcpp::Elf_sizes<32>::rel_size];
+      memset(reloc_buffer, 0, sizeof(reloc_buffer));
+      elfcpp::Rel_write<32, big_endian> reloc_write(reloc_buffer);
+      reloc_write.put_r_offset(reloc_offset);
+      reloc_write.put_r_info(elfcpp::elf_r_info<32>(0, r_type));
+      elfcpp::Rel<32, big_endian> rel(reloc_buffer);
+
+      relocate.relocate(relinfo, this, output_section,
+			this->fake_relnum_for_stubs, rel, r_type,
+			NULL, &symval, view + reloc_offset,
+			address + reloc_offset, reloc_size);
+    }
+}
+
+// Determine whether an object attribute tag takes an integer, a
+// string or both.
+
+template<bool big_endian>
+int
+Target_arm<big_endian>::do_attribute_arg_type(int tag) const
+{
+  if (tag == Object_attribute::Tag_compatibility)
+    return (Object_attribute::ATTR_TYPE_FLAG_INT_VAL
+	    | Object_attribute::ATTR_TYPE_FLAG_STR_VAL);
+  else if (tag == elfcpp::Tag_nodefaults)
+    return (Object_attribute::ATTR_TYPE_FLAG_INT_VAL
+	    | Object_attribute::ATTR_TYPE_FLAG_NO_DEFAULT);
+  else if (tag == elfcpp::Tag_CPU_raw_name || tag == elfcpp::Tag_CPU_name)
+    return Object_attribute::ATTR_TYPE_FLAG_STR_VAL;
+  else if (tag < 32)
+    return Object_attribute::ATTR_TYPE_FLAG_INT_VAL;
+  else
+    return ((tag & 1) != 0
+	    ? Object_attribute::ATTR_TYPE_FLAG_STR_VAL
+	    : Object_attribute::ATTR_TYPE_FLAG_INT_VAL);
+}
+
+// Reorder attributes.
+//
+// The ABI defines that Tag_conformance should be emitted first, and that
+// Tag_nodefaults should be second (if either is defined).  This sets those
+// two positions, and bumps up the position of all the remaining tags to
+// compensate.
+
+template<bool big_endian>
+int
+Target_arm<big_endian>::do_attributes_order(int num) const
+{
+  // Reorder the known object attributes in output.  We want to move
+  // Tag_conformance to position 4 and Tag_conformance to position 5
+  // and shift eveything between 4 .. Tag_conformance - 1 to make room.
+  if (num == 4)
+    return elfcpp::Tag_conformance;
+  if (num == 5)
+    return elfcpp::Tag_nodefaults;
+  if ((num - 2) < elfcpp::Tag_nodefaults)
+    return num - 2;
+  if ((num - 1) < elfcpp::Tag_conformance)
+    return num - 1;
+  return num;
+}
+
+// Scan a span of THUMB code for Cortex-A8 erratum.
+
+template<bool big_endian>
+void
+Target_arm<big_endian>::scan_span_for_cortex_a8_erratum(
+    Arm_relobj<big_endian>* arm_relobj,
+    unsigned int shndx,
+    section_size_type span_start,
+    section_size_type span_end,
+    const unsigned char* view,
+    Arm_address address)
+{
+  // Scan for 32-bit Thumb-2 branches which span two 4K regions, where:
+  //
+  // The opcode is BLX.W, BL.W, B.W, Bcc.W
+  // The branch target is in the same 4KB region as the
+  // first half of the branch.
+  // The instruction before the branch is a 32-bit
+  // length non-branch instruction.
+  section_size_type i = span_start;
+  bool last_was_32bit = false;
+  bool last_was_branch = false;
+  while (i < span_end)
+    {
+      typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
+      const Valtype* wv = reinterpret_cast<const Valtype*>(view + i);
+      uint32_t insn = elfcpp::Swap<16, big_endian>::readval(wv);
+      bool is_blx = false, is_b = false;
+      bool is_bl = false, is_bcc = false;
+
+      bool insn_32bit = (insn & 0xe000) == 0xe000 && (insn & 0x1800) != 0x0000;
+      if (insn_32bit)
+	{
+	  // Load the rest of the insn (in manual-friendly order).
+	  insn = (insn << 16) | elfcpp::Swap<16, big_endian>::readval(wv + 1);
+
+	  // Encoding T4: B<c>.W.
+	  is_b = (insn & 0xf800d000U) == 0xf0009000U;
+	  // Encoding T1: BL<c>.W.
+      	  is_bl = (insn & 0xf800d000U) == 0xf000d000U;
+       	  // Encoding T2: BLX<c>.W.
+       	  is_blx = (insn & 0xf800d000U) == 0xf000c000U;
+	  // Encoding T3: B<c>.W (not permitted in IT block).
+	  is_bcc = ((insn & 0xf800d000U) == 0xf0008000U
+		    && (insn & 0x07f00000U) != 0x03800000U);
+	}
+
+      bool is_32bit_branch = is_b || is_bl || is_blx || is_bcc;
+			   
+      // If this instruction is a 32-bit THUMB branch that crosses a 4K
+      // page boundary and it follows 32-bit non-branch instruction,
+      // we need to work around.
+      if (is_32bit_branch
+	  && ((address + i) & 0xfffU) == 0xffeU
+	  && last_was_32bit
+	  && !last_was_branch)
+	{
+	  // Check to see if there is a relocation stub for this branch.
+	  bool force_target_arm = false;
+	  bool force_target_thumb = false;
+	  const Cortex_a8_reloc* cortex_a8_reloc = NULL;
+	  Cortex_a8_relocs_info::const_iterator p =
+	    this->cortex_a8_relocs_info_.find(address + i);
+
+	  if (p != this->cortex_a8_relocs_info_.end())
+	    {
+	      cortex_a8_reloc = p->second;
+	      bool target_is_thumb = (cortex_a8_reloc->destination() & 1) != 0;
+
+	      if (cortex_a8_reloc->r_type() == elfcpp::R_ARM_THM_CALL
+		  && !target_is_thumb)
+		force_target_arm = true;
+	      else if (cortex_a8_reloc->r_type() == elfcpp::R_ARM_THM_CALL
+		       && target_is_thumb)
+		force_target_thumb = true;
+	    }
+
+	  off_t offset;
+	  Stub_type stub_type = arm_stub_none;
+
+	  // Check if we have an offending branch instruction.
+	  uint16_t upper_insn = (insn >> 16) & 0xffffU;
+	  uint16_t lower_insn = insn & 0xffffU;
+	  typedef struct Arm_relocate_functions<big_endian> RelocFuncs;
+
+	  if (cortex_a8_reloc != NULL
+	      && cortex_a8_reloc->reloc_stub() != NULL)
+	    // We've already made a stub for this instruction, e.g.
+	    // it's a long branch or a Thumb->ARM stub.  Assume that
+	    // stub will suffice to work around the A8 erratum (see
+	    // setting of always_after_branch above).
+	    ;
+	  else if (is_bcc)
+	    {
+	      offset = RelocFuncs::thumb32_cond_branch_offset(upper_insn,
+							      lower_insn);
+	      stub_type = arm_stub_a8_veneer_b_cond;
+	    }
+	  else if (is_b || is_bl || is_blx)
+	    {
+	      offset = RelocFuncs::thumb32_branch_offset(upper_insn,
+							 lower_insn);
+	      if (is_blx)
+	        offset &= ~3;
+
+	      stub_type = (is_blx
+			   ? arm_stub_a8_veneer_blx
+			   : (is_bl
+			      ? arm_stub_a8_veneer_bl
+			      : arm_stub_a8_veneer_b));
+	    }
+
+	  if (stub_type != arm_stub_none)
+	    {
+	      Arm_address pc_for_insn = address + i + 4;
+
+	      // The original instruction is a BL, but the target is
+	      // an ARM instruction.  If we were not making a stub,
+	      // the BL would have been converted to a BLX.  Use the
+	      // BLX stub instead in that case.
+	      if (this->may_use_blx() && force_target_arm
+		  && stub_type == arm_stub_a8_veneer_bl)
+		{
+		  stub_type = arm_stub_a8_veneer_blx;
+		  is_blx = true;
+		  is_bl = false;
+		}
+	      // Conversely, if the original instruction was
+	      // BLX but the target is Thumb mode, use the BL stub.
+	      else if (force_target_thumb
+		       && stub_type == arm_stub_a8_veneer_blx)
+		{
+		  stub_type = arm_stub_a8_veneer_bl;
+		  is_blx = false;
+		  is_bl = true;
+		}
+
+	      if (is_blx)
+		pc_for_insn &= ~3;
+
+              // If we found a relocation, use the proper destination,
+	      // not the offset in the (unrelocated) instruction.
+	      // Note this is always done if we switched the stub type above.
+              if (cortex_a8_reloc != NULL)
+                offset = (off_t) (cortex_a8_reloc->destination() - pc_for_insn);
+
+              Arm_address target = (pc_for_insn + offset) | (is_blx ? 0 : 1);
+
+	      // Add a new stub if destination address in in the same page.
+              if (((address + i) & ~0xfffU) == (target & ~0xfffU))
+                {
+		  Cortex_a8_stub* stub =
+		    this->stub_factory_.make_cortex_a8_stub(stub_type,
+							    arm_relobj, shndx,
+							    address + i,
+							    target, insn);
+		  Stub_table<big_endian>* stub_table =
+		    arm_relobj->stub_table(shndx);
+		  gold_assert(stub_table != NULL);
+		  stub_table->add_cortex_a8_stub(address + i, stub);
+                }
+            }
+        }
+
+      i += insn_32bit ? 4 : 2;
+      last_was_32bit = insn_32bit;
+      last_was_branch = is_32bit_branch;
+    }
+}
+
+// Apply the Cortex-A8 workaround.
+
+template<bool big_endian>
+void
+Target_arm<big_endian>::apply_cortex_a8_workaround(
+    const Cortex_a8_stub* stub,
+    Arm_address stub_address,
+    unsigned char* insn_view,
+    Arm_address insn_address)
+{
+  typedef typename elfcpp::Swap<16, big_endian>::Valtype Valtype;
+  Valtype* wv = reinterpret_cast<Valtype*>(insn_view);
+  Valtype upper_insn = elfcpp::Swap<16, big_endian>::readval(wv);
+  Valtype lower_insn = elfcpp::Swap<16, big_endian>::readval(wv + 1);
+  off_t branch_offset = stub_address - (insn_address + 4);
+
+  typedef struct Arm_relocate_functions<big_endian> RelocFuncs;
+  switch (stub->stub_template()->type())
+    {
+    case arm_stub_a8_veneer_b_cond:
+      gold_assert(!utils::has_overflow<21>(branch_offset));
+      upper_insn = RelocFuncs::thumb32_cond_branch_upper(upper_insn,
+							 branch_offset);
+      lower_insn = RelocFuncs::thumb32_cond_branch_lower(lower_insn,
+							 branch_offset);
+      break;
+
+    case arm_stub_a8_veneer_b:
+    case arm_stub_a8_veneer_bl:
+    case arm_stub_a8_veneer_blx:
+      if ((lower_insn & 0x5000U) == 0x4000U)
+	// For a BLX instruction, make sure that the relocation is
+	// rounded up to a word boundary.  This follows the semantics of
+	// the instruction which specifies that bit 1 of the target
+	// address will come from bit 1 of the base address.
+	branch_offset = (branch_offset + 2) & ~3;
+
+      // Put BRANCH_OFFSET back into the insn.
+      gold_assert(!utils::has_overflow<25>(branch_offset));
+      upper_insn = RelocFuncs::thumb32_branch_upper(upper_insn, branch_offset);
+      lower_insn = RelocFuncs::thumb32_branch_lower(lower_insn, branch_offset);
+      break;
+
+    default:
+      gold_unreachable();
+    }
+
+  // Put the relocated value back in the object file:
+  elfcpp::Swap<16, big_endian>::writeval(wv, upper_insn);
+  elfcpp::Swap<16, big_endian>::writeval(wv + 1, lower_insn);
+}
 
 template<bool big_endian>
 class Target_selector_arm : public Target_selector
@@ -2481,6 +10638,52 @@ class Target_selector_arm : public Target_selector
   { return new Target_arm<big_endian>(); }
 };
 
+// Fix .ARM.exidx section coverage.
+
+template<bool big_endian>
+void
+Target_arm<big_endian>::fix_exidx_coverage(
+    Layout* layout,
+    Arm_output_section<big_endian>* exidx_section,
+    Symbol_table* symtab)
+{
+  // We need to look at all the input sections in output in ascending
+  // order of of output address.  We do that by building a sorted list
+  // of output sections by addresses.  Then we looks at the output sections
+  // in order.  The input sections in an output section are already sorted
+  // by addresses within the output section.
+
+  typedef std::set<Output_section*, output_section_address_less_than>
+      Sorted_output_section_list;
+  Sorted_output_section_list sorted_output_sections;
+  Layout::Section_list section_list;
+  layout->get_allocated_sections(&section_list);
+  for (Layout::Section_list::const_iterator p = section_list.begin();
+       p != section_list.end();
+       ++p)
+    {
+      // We only care about output sections that contain executable code.
+      if (((*p)->flags() & elfcpp::SHF_EXECINSTR) != 0)
+	sorted_output_sections.insert(*p);
+    }
+
+  // Go over the output sections in ascending order of output addresses.
+  typedef typename Arm_output_section<big_endian>::Text_section_list
+      Text_section_list;
+  Text_section_list sorted_text_sections;
+  for(typename Sorted_output_section_list::iterator p =
+	sorted_output_sections.begin();
+      p != sorted_output_sections.end();
+      ++p)
+    {
+      Arm_output_section<big_endian>* arm_output_section =
+	Arm_output_section<big_endian>::as_arm_output_section(*p);
+      arm_output_section->append_text_sections_to_list(&sorted_text_sections);
+    } 
+
+  exidx_section->fix_exidx_coverage(layout, sorted_text_sections, symtab);
+}
+
 Target_selector_arm<false> target_selector_arm;
 Target_selector_arm<true> target_selector_armbe;
 
diff --git a/gold/attributes.cc b/gold/attributes.cc
new file mode 100644
index 0000000..2deb9bd
--- /dev/null
+++ b/gold/attributes.cc
@@ -0,0 +1,458 @@
+// attributes.cc -- object attributes for gold
+
+// Copyright 2009 Free Software Foundation, Inc.
+// Written by Doug Kwan <dougkwan@google.com>.
+// This file contains code adapted from BFD.
+
+// This file is part of gold.
+
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+// MA 02110-1301, USA.
+
+#include "gold.h"
+
+#include <limits>
+
+#include "attributes.h"
+#include "elfcpp.h"
+#include "target.h"
+#include "parameters.h"
+#include "int_encoding.h"
+
+namespace gold
+{
+
+// Object_attribute methods.
+
+// Return size of attribute encode in ULEB128.
+
+size_t
+Object_attribute::size(int tag) const
+{
+  // Attributes with default values are not written out.
+  if (this->is_default_attribute())
+    return 0;
+
+  size_t size = get_length_as_unsigned_LEB_128(tag);
+  if (Object_attribute::attribute_type_has_int_value(this->type_))
+    size += get_length_as_unsigned_LEB_128(this->int_value_);
+  if (Object_attribute::attribute_type_has_string_value(this->type_))
+    size += this->string_value_.size() + 1;
+  return size;
+}
+
+// Whether this has the default value (0/"").
+
+bool
+Object_attribute::is_default_attribute() const
+{
+  if (Object_attribute::attribute_type_has_int_value(this->type_)
+      && this->int_value_ != 0)
+    return false;
+  if (Object_attribute::attribute_type_has_string_value(this->type_)
+      && !this->string_value_.empty())
+    return false;
+  if (Object_attribute::attribute_type_has_no_default(this->type_))
+    return false;
+
+  return true;
+}
+
+// Whether this matches another Object_attribute OA in merging.
+// Two Object_attributes match if they have the same values.
+
+bool
+Object_attribute::matches(const Object_attribute& oa) const
+{
+  return ((this->int_value_ != oa.int_value_)
+	  && (this->string_value_ == oa.string_value_));
+}
+
+// Write this with TAG to a BUFFER.
+
+void
+Object_attribute::write(
+    int tag,
+    std::vector<unsigned char>* buffer) const
+{
+  // No need to write default attributes.
+  if (this->is_default_attribute())
+    return;
+  
+  // Write tag.
+  write_unsigned_LEB_128(buffer, convert_types<uint64_t, int>(tag));
+
+  // Write integer value.
+  if (Object_attribute::attribute_type_has_int_value(this->type_))
+    write_unsigned_LEB_128(buffer,
+			   convert_types<uint64_t, int>(this->int_value_));
+
+  // Write string value.
+  if (Object_attribute::attribute_type_has_string_value(this->type_))
+    {
+      const unsigned char* start =
+	reinterpret_cast<const unsigned char*>(this->string_value_.c_str());
+      const unsigned char* end = start + this->string_value_.size() + 1;
+      buffer->insert(buffer->end(), start, end); 
+    }
+}
+
+// Vendor_object_attributes methods.
+
+// Copying constructor.
+
+Vendor_object_attributes::Vendor_object_attributes(
+    const Vendor_object_attributes& voa)
+{
+  this->vendor_ = voa.vendor_;
+
+  for (int i = 0; i < NUM_KNOWN_ATTRIBUTES; ++i)
+    this->known_attributes_[i] = voa.known_attributes_[i];
+
+  // We do not handle attribute deletion.  So this must be empty.
+  gold_assert(this->other_attributes_.empty());
+
+  for (Other_attributes::const_iterator p = voa.other_attributes_.begin();
+       p != voa.other_attributes_.end();
+       ++p)
+    this->other_attributes_[p->first] = new Object_attribute(*(p->second));
+}
+
+// Size of this in number of bytes.
+
+size_t
+Vendor_object_attributes::size() const
+{
+  if (this->name() == NULL)
+    return 0;
+
+  size_t data_size = 0;
+  for (int i = 4; i < NUM_KNOWN_ATTRIBUTES; ++i)
+    data_size += this->known_attributes_[i].size(i);
+
+  for (Other_attributes::const_iterator p = this->other_attributes_.begin();
+       p != this->other_attributes_.end();
+       ++p)
+    data_size += p->second->size(p->first);
+
+  // <size> <vendor_name> NUL 0x1 <size>
+  return ((data_size != 0
+	   || this->vendor_ == Object_attribute::OBJ_ATTR_PROC)
+	  ? data_size + strlen(this->name()) + 2 + 2 * 4
+	  : 0);
+}
+
+// Return a new attribute associated with TAG.
+
+Object_attribute*
+Vendor_object_attributes::new_attribute(int tag)
+{
+  int type = Object_attribute::arg_type(this->vendor_, tag);
+
+  if (tag < NUM_KNOWN_ATTRIBUTES)
+    {
+      this->known_attributes_[tag].set_type(type);
+      return &this->known_attributes_[tag];
+    }
+  else
+    {
+      Object_attribute* attr = new Object_attribute();
+
+      // This should be the first time we insert this.
+      std::pair<Other_attributes::iterator, bool> ins =
+	this->other_attributes_.insert(std::make_pair(tag, attr));
+      gold_assert(ins.second);
+
+      attr->set_type(type);
+      return attr;
+    }
+}
+
+// Return an attribute associated with TAG.
+
+Object_attribute*
+Vendor_object_attributes::get_attribute(int tag)
+{
+  if (tag < NUM_KNOWN_ATTRIBUTES)
+    return &this->known_attributes_[tag];
+  else
+    {
+      Other_attributes::iterator p =
+	this->other_attributes_.find(tag);
+      return p != this->other_attributes_.end() ? p->second : NULL;
+    }
+}
+
+const Object_attribute*
+Vendor_object_attributes::get_attribute(int tag) const
+{
+  if (tag < NUM_KNOWN_ATTRIBUTES)
+    return &this->known_attributes_[tag];
+  else
+    {
+      Other_attributes::const_iterator p =
+	this->other_attributes_.find(tag);
+      return p != this->other_attributes_.end() ? p->second : NULL;
+    }
+}
+
+// Write attributes to BUFFER.
+
+void
+Vendor_object_attributes::write(std::vector<unsigned char>* buffer) const
+{
+  // Write subsection size.
+  size_t voa_size = this->size();
+  uint32_t voa_size_as_u32 = convert_types<uint32_t, size_t>(voa_size);
+  insert_into_vector<32>(buffer, voa_size_as_u32);
+
+  // Write vendor name.
+  const unsigned char* vendor_start =
+    reinterpret_cast<const unsigned char*>(this->name());
+  size_t vendor_length = strlen(this->name()) + 1;
+  const unsigned char* vendor_end = vendor_start + vendor_length;
+  buffer->insert(buffer->end(), vendor_start, vendor_end);
+
+  // Write file tag.
+  buffer->push_back(Object_attribute::Tag_File);
+
+  // Write attributes size.
+  uint32_t attributes_size_as_u32 =
+    convert_types<uint32_t, size_t>(voa_size - 4 - vendor_length);
+  insert_into_vector<32>(buffer, attributes_size_as_u32);
+
+  // Write known attributes, skipping any defaults.
+  for (int i = 4; i < NUM_KNOWN_ATTRIBUTES; ++i)
+    {
+      // A target may write known attributes in a special order. 
+      // Call target hook to remap tags.  Attributes_order is the identity
+      // function if no re-ordering is required.
+      int tag = parameters->target().attributes_order(i);
+      this->known_attributes_[tag].write(tag, buffer);
+    }
+
+  // Write other attributes.
+  for (Other_attributes::const_iterator q = this->other_attributes_.begin();
+       q != this->other_attributes_.end();
+       ++q)
+    q->second->write(q->first, buffer);
+}
+
+// Attributes_section_data methods.
+
+// Compute encoded size of this.
+
+size_t
+Attributes_section_data::size() const
+{
+  size_t data_size = 0;
+  for(int vendor = OBJ_ATTR_FIRST; vendor <= OBJ_ATTR_LAST; ++vendor)
+    data_size += this->vendor_object_attributes_[vendor]->size();
+
+  // 'A' <sections for each vendor>
+  return data_size != 0 ? data_size + 1 : 0;
+}
+
+// Construct an Attributes_section_data object by parsing section contents
+// specified by VIEW and SIZE.
+
+Attributes_section_data::Attributes_section_data(
+    const unsigned char* view,
+    section_size_type size)
+{
+  for (int vendor = OBJ_ATTR_FIRST; vendor <= OBJ_ATTR_LAST; ++vendor)
+    this->vendor_object_attributes_[vendor] =
+      new Vendor_object_attributes(vendor);
+
+  const unsigned char *p = view;
+  p = view;
+  if (size > 0 && p != NULL && *(p++) == 'A')
+    {
+      size--;
+      while (size > 0)
+	{
+	  // Size of vendor attributes section.
+	  section_size_type section_size =
+	    convert_to_section_size_type(read_from_pointer<32>(&p));
+
+	  if (section_size > size)
+	    section_size = size;
+	  size -= section_size;
+
+	  const char* section_name = reinterpret_cast<const char*>(p);
+	  section_size_type section_name_size = strlen(section_name) + 1;
+	  section_size -= section_name_size + 4;
+
+	  int vendor;
+	  const char *std_section = parameters->target().attributes_vendor();
+	  if (std_section != NULL && strcmp(section_name, std_section) == 0)
+	    vendor = Object_attribute::OBJ_ATTR_PROC;
+	  else if (strcmp(section_name, "gnu") == 0)
+	    vendor = Object_attribute::OBJ_ATTR_GNU;
+	  else
+	    {
+	      // Other vendor section.  Ignore it.
+	      p += section_name_size + section_size;
+	      continue;
+	    }
+	  p += section_name_size;
+
+	  while (section_size > 0)
+	    {
+	      const unsigned char* subsection_start = p;
+
+	      // Read vendor subsection index and size.
+	      size_t uleb128_len;
+	      uint64_t val = read_unsigned_LEB_128(p, &uleb128_len);
+	      p += uleb128_len;
+
+	      int tag = convert_types<int, uint64_t>(val);
+	      section_size_type subsection_size =
+		convert_to_section_size_type(read_from_pointer<32>(&p));
+	      section_size -= subsection_size;
+	      subsection_size -= (p - subsection_start);
+
+	      const unsigned char* end = p + subsection_size;
+	      switch (tag)
+		{
+		case Object_attribute::Tag_File:
+		  while (p < end)
+		    {
+		      val = read_unsigned_LEB_128(p, &uleb128_len);
+		      p += uleb128_len;
+		      tag = convert_types<int, uint64_t>(val);
+		      Vendor_object_attributes* pvoa =
+			this->vendor_object_attributes_[vendor];
+		      Object_attribute* attr = pvoa->new_attribute(tag);
+		      const char* string_arg;
+		      unsigned int int_arg;
+
+		      int type = Object_attribute::arg_type(vendor, tag);
+		      switch (type
+			      & (Object_attribute::ATTR_TYPE_FLAG_INT_VAL
+				 | Object_attribute::ATTR_TYPE_FLAG_STR_VAL))
+			{
+			case (Object_attribute::ATTR_TYPE_FLAG_INT_VAL
+			      | Object_attribute::ATTR_TYPE_FLAG_STR_VAL):
+			  val = read_unsigned_LEB_128(p, &uleb128_len);
+			  p += uleb128_len;
+			  int_arg = convert_types<unsigned int, uint64_t>(val);
+			  string_arg = reinterpret_cast<const char *>(p);
+			  attr->set_int_value(int_arg);
+			  p += strlen(string_arg) + 1;
+			  break;
+			case Object_attribute::ATTR_TYPE_FLAG_STR_VAL:
+			  string_arg = reinterpret_cast<const char *>(p);
+			  attr->set_string_value(string_arg);
+			  p += strlen(string_arg) + 1;
+			  break;
+			case Object_attribute::ATTR_TYPE_FLAG_INT_VAL:
+			  val = read_unsigned_LEB_128(p, &uleb128_len);
+			  p += uleb128_len;
+			  int_arg = convert_types<unsigned int, uint64_t>(val);
+			  attr->set_int_value(int_arg);
+			  break;
+			default:
+			  gold_unreachable();
+			}
+		    }
+		  break;
+		case Object_attribute::Tag_Section:
+		case Object_attribute::Tag_Symbol:
+		  // Don't have anywhere convenient to attach these.
+		  // Fall through for now.
+		default:
+		  // Ignore things we don't know about.
+		  p += subsection_size;
+		  subsection_size = 0;
+		  break;
+		}
+	    }
+	}
+    }
+}
+
+// Merge target-independent attributes from another Attribute_section_data
+// ASD from an object called NAME into this.
+
+void
+Attributes_section_data::merge(
+    const char* name,
+    const Attributes_section_data* pasd)
+{
+  // The only common attribute is currently Tag_compatibility,
+  // accepted in both processor and "gnu" sections.
+  for (int vendor = OBJ_ATTR_FIRST; vendor <= OBJ_ATTR_LAST; ++vendor)
+    {
+      // Handle Tag_compatibility.  The tags are only compatible if the flags
+      // are identical and, if the flags are '1', the strings are identical.
+      // If the flags are non-zero, then we can only use the string "gnu".
+      const Object_attribute* in_attr =
+	&pasd->known_attributes(vendor)[Object_attribute::Tag_compatibility];
+      Object_attribute* out_attr =
+	&this->known_attributes(vendor)[Object_attribute::Tag_compatibility];
+
+      if (in_attr->int_value() > 0
+	  && in_attr->string_value() != "gnu")
+	{
+	  gold_error(_("%s: must be processed by '%s' toolchain"),
+		     name, in_attr->string_value().c_str());
+	  return;
+	}
+
+      if (in_attr->int_value() != out_attr->int_value()
+	  || in_attr->string_value() != out_attr->string_value())
+	{
+	  gold_error(_("%s: object tag '%d, %s' is "
+		       "incompatible with tag '%d, %s'"),
+		     name, in_attr->int_value(),
+		     in_attr->string_value().c_str(),
+		     out_attr->int_value(),
+		     out_attr->string_value().c_str());
+	}
+    }
+}
+
+// Write to a buffer.
+
+void
+Attributes_section_data::write(std::vector<unsigned char>* buffer) const
+{
+  buffer->push_back('A');
+  for (int vendor = OBJ_ATTR_FIRST; vendor <= OBJ_ATTR_LAST; ++vendor)
+    if (this->vendor_object_attributes_[vendor]->size() != 0)
+      this->vendor_object_attributes_[vendor]->write(buffer);
+}
+
+// Methods for Output_attributes_section_data.
+
+// Write attributes section data to file OF.
+
+void
+Output_attributes_section_data::do_write(Output_file* of)
+{
+  off_t offset = this->offset();
+  const section_size_type oview_size =
+    convert_to_section_size_type(this->data_size());
+  unsigned char* const oview = of->get_output_view(offset, oview_size);
+
+  std::vector<unsigned char> buffer;
+  this->attributes_section_data_.write(&buffer);
+  gold_assert(convert_to_section_size_type(buffer.size()) == oview_size);
+  memcpy(oview, buffer.data(), buffer.size());
+  of->write_output_view(this->offset(), oview_size, oview);
+}
+
+} // End namespace gold.
diff --git a/gold/attributes.h b/gold/attributes.h
new file mode 100644
index 0000000..7c4baf4
--- /dev/null
+++ b/gold/attributes.h
@@ -0,0 +1,406 @@
+// attributes.h -- object attributes for gold   -*- C++ -*-
+
+// Copyright 2009 Free Software Foundation, Inc.
+// Written by Doug Kwan <dougkwan@google.com>.
+// This file contains code adapted from BFD.
+
+// This file is part of gold.
+
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+// MA 02110-1301, USA.
+
+// Handle object attributes.
+
+#ifndef GOLD_ATTRIBUTES_H
+#define GOLD_ATTRIBUTES_H
+
+#include <map>
+
+#include "parameters.h"
+#include "target.h"
+#include "output.h"
+#include "reduced_debug_output.h"
+
+namespace gold
+{
+
+// Object attribute values.  The attribute tag is not stored in this object.
+
+class Object_attribute
+{
+ public:
+  // The value of an object attribute.  The type indicates whether the
+  // attribute holds and integer, a string, or both.  It can also indicate that
+  // there can be no default (i.e. all values must be written to file, even
+  // zero).
+  enum
+  {
+    ATTR_TYPE_FLAG_INT_VAL = (1 << 0),
+    ATTR_TYPE_FLAG_STR_VAL = (1 << 1),
+    ATTR_TYPE_FLAG_NO_DEFAULT = (1 << 2)
+  };
+
+  // Object attributes may either be defined by the processor ABI, index
+  // OBJ_ATTR_PROC in the *_obj_attributes arrays, or be GNU-specific
+  // (and possibly also processor-specific), index OBJ_ATTR_GNU.
+  enum
+  {
+    OBJ_ATTR_PROC,
+    OBJ_ATTR_GNU,
+    OBJ_ATTR_FIRST = OBJ_ATTR_PROC,
+    OBJ_ATTR_LAST = OBJ_ATTR_GNU
+  };
+
+  // The following object attribute tags are taken as generic, for all
+  // targets and for "gnu" where there is no target standard. 
+  enum
+  {
+    Tag_NULL = 0,
+    Tag_File = 1,
+    Tag_Section = 2,
+    Tag_Symbol = 3,
+    Tag_compatibility = 32
+  };
+
+  Object_attribute()
+   : type_(0), int_value_(0), string_value_()
+  { }
+
+  // Copying constructor.  We need to implement this to copy the string value.
+  Object_attribute(const Object_attribute& oa)
+   : type_(oa.type_), int_value_(oa.int_value_), string_value_(oa.string_value_)
+  { }
+
+  ~Object_attribute()
+  { }
+
+  // Assignment operator.  We need to implement this to copy the string value.
+  Object_attribute&
+  operator=(const Object_attribute& source)
+  {
+    this->type_ = source.type_;
+    this->int_value_ = source.int_value_;
+    this->string_value_ = source.string_value_;
+    return *this;
+  }
+
+  // Return attribute type.
+  int
+  type() const
+  { return this->type_; }
+
+  // Set attribute type.
+  void
+  set_type(int type)
+  { this->type_ = type; }
+
+  // Return integer value.
+  unsigned int
+  int_value() const
+  { return this->int_value_; }
+
+  // Set integer value.
+  void
+  set_int_value(unsigned int i)
+  { this->int_value_ = i; }
+
+  // Return string value.
+  const std::string&
+  string_value() const
+  { return this->string_value_; }
+
+  // Set string value.
+  void
+  set_string_value(const std::string& s)
+  { this->string_value_ = s; }
+
+  void
+  set_string_value(const char* s)
+  { this->string_value_ = s; }
+
+  // Whether attribute type has integer value.
+  static bool
+  attribute_type_has_int_value(int type)
+  { return (type & ATTR_TYPE_FLAG_INT_VAL) != 0; }
+
+  // Whether attribute type has string value.
+  static bool
+  attribute_type_has_string_value(int type)
+  { return (type & ATTR_TYPE_FLAG_STR_VAL) != 0; }
+
+  // Whether attribute type has no default value.
+  static bool
+  attribute_type_has_no_default(int type)
+  { return (type & ATTR_TYPE_FLAG_NO_DEFAULT) != 0; }
+
+  // Whether this has default value (0/"").
+  bool
+  is_default_attribute() const;
+
+  // Return ULEB128 encoded size of tag and attribute.  
+  size_t
+  size(int tag) const;
+
+  // Whether this matches another object attribute in merging.
+  bool
+  matches(const Object_attribute& oa) const;
+  
+  // Write to attribute with tag to BUFFER.
+  void
+  write(int tag, std::vector<unsigned char>* buffer) const;
+
+  // Determine what arguments an attribute tag takes.
+  static int
+  arg_type (int vendor, int tag)
+  {
+    switch (vendor)
+      {
+      case OBJ_ATTR_PROC:
+	return parameters->target().attribute_arg_type(tag);
+      case OBJ_ATTR_GNU:
+	return Object_attribute::gnu_arg_type(tag);
+      default:
+	gold_unreachable();
+     }
+  }
+
+ private:
+  // Determine whether a GNU object attribute tag takes an integer, a
+  // string or both.  */
+  static int
+  gnu_arg_type (int tag)
+  {
+    // Except for Tag_compatibility, for GNU attributes we follow the
+    // same rule ARM ones > 32 follow: odd-numbered tags take strings
+    // and even-numbered tags take integers.  In addition, tag & 2 is
+    // nonzero for architecture-independent tags and zero for
+    // architecture-dependent ones.
+    if (tag == Object_attribute::Tag_compatibility)
+      return ATTR_TYPE_FLAG_INT_VAL | ATTR_TYPE_FLAG_STR_VAL;
+    else
+      return (tag & 1) != 0 ? ATTR_TYPE_FLAG_STR_VAL : ATTR_TYPE_FLAG_INT_VAL;
+  }
+
+  // Attribute type.
+  int type_;
+  // Integer value.
+  int int_value_;
+  // String value.
+  std::string string_value_;
+};
+
+// This class contains attributes of a particular vendor.
+
+class Vendor_object_attributes
+{
+ public:
+  // The maximum number of known object attributes for any target.
+  static const int NUM_KNOWN_ATTRIBUTES = 71;
+
+  Vendor_object_attributes(int vendor)
+    : vendor_(vendor), other_attributes_() 
+  { }
+
+  // Copying constructor.
+  Vendor_object_attributes(const Vendor_object_attributes&);
+
+  ~Vendor_object_attributes()
+  {
+    for (Other_attributes::iterator p = this->other_attributes_.begin();
+	 p != this->other_attributes_.end();
+	 ++p)
+      delete p->second;
+  }
+
+  // Size of this in number of bytes.
+  size_t
+  size() const;
+  
+  // Name of this written vendor subsection.
+  const char*
+  name() const
+  {
+    return (this->vendor_ == Object_attribute::OBJ_ATTR_PROC
+	    ? parameters->target().attributes_vendor()
+	    : "gnu");
+  }
+
+  // Return an array of known attributes.
+  Object_attribute*
+  known_attributes()
+  { return &this->known_attributes_[0]; }
+
+  const Object_attribute*
+  known_attributes() const
+  { return &this->known_attributes_[0]; }
+
+  typedef std::map<int, Object_attribute*> Other_attributes;
+
+  // Return attributes other than the known ones.
+  Other_attributes*
+  other_attributes()
+  { return &this->other_attributes_; }
+
+  const Other_attributes*
+  other_attributes() const
+  { return &this->other_attributes_; }
+
+  // Return a new attribute asssociated with TAG.
+  Object_attribute*
+  new_attribute(int tag);
+
+  // Get an attribute
+  Object_attribute*
+  get_attribute(int tag);
+
+  const Object_attribute*
+  get_attribute(int tag) const;
+
+  // Write to BUFFER.
+  void
+  write(std::vector<unsigned char>* buffer) const;
+
+ private:
+  // Vendor of the object attributes.
+  int vendor_;
+  // Attributes with known tags.  There are store in an array for fast
+  // access.
+  Object_attribute known_attributes_[NUM_KNOWN_ATTRIBUTES];
+  // Attributes with known tags.  There are stored in a sorted container.
+  Other_attributes other_attributes_;
+};
+
+// This class contains contents of an attributes section.
+
+class Attributes_section_data
+{
+ public:
+  // Construct an Attributes_section_data object by parsing section contents
+  // in VIEW of SIZE.
+  Attributes_section_data(const unsigned char* view, section_size_type size);
+
+  // Copying constructor.
+  Attributes_section_data(const Attributes_section_data& asd)
+  {
+    for (int vendor = Object_attribute::OBJ_ATTR_FIRST;
+	 vendor <= Object_attribute::OBJ_ATTR_LAST;
+	 ++vendor)
+      this->vendor_object_attributes_[vendor] =
+	new Vendor_object_attributes(*asd.vendor_object_attributes_[vendor]);
+  }
+  
+  ~Attributes_section_data()
+  {
+    for (int vendor = Object_attribute::OBJ_ATTR_FIRST;
+	 vendor <= Object_attribute::OBJ_ATTR_LAST;
+	 ++vendor)
+      delete this->vendor_object_attributes_[vendor];
+  }
+ 
+  // Return the size of this as number of bytes.
+  size_t
+  size() const;
+
+  // Return an array of known attributes.
+  Object_attribute*
+  known_attributes(int vendor)
+  {
+    gold_assert(vendor >= OBJ_ATTR_FIRST && vendor <= OBJ_ATTR_LAST);
+    return this->vendor_object_attributes_[vendor]->known_attributes();
+  }
+
+  const Object_attribute*
+  known_attributes(int vendor) const
+  {
+    gold_assert(vendor >= OBJ_ATTR_FIRST && vendor <= OBJ_ATTR_LAST);
+    return this->vendor_object_attributes_[vendor]->known_attributes();
+  }
+
+  // Return the other attributes.
+  Vendor_object_attributes::Other_attributes*
+  other_attributes(int vendor)
+  {
+    gold_assert(vendor >= OBJ_ATTR_FIRST && vendor <= OBJ_ATTR_LAST);
+    return this->vendor_object_attributes_[vendor]->other_attributes();
+  }
+
+  // Return the other attributes.
+  const Vendor_object_attributes::Other_attributes*
+  other_attributes(int vendor) const
+  {
+    gold_assert(vendor >= OBJ_ATTR_FIRST && vendor <= OBJ_ATTR_LAST);
+    return this->vendor_object_attributes_[vendor]->other_attributes();
+  }
+
+  // Return an attribute.
+  Object_attribute*
+  get_attribute(int vendor, int tag)
+  {
+    gold_assert(vendor >= OBJ_ATTR_FIRST && vendor <= OBJ_ATTR_LAST);
+    return this->vendor_object_attributes_[vendor]->get_attribute(tag);
+  }
+  
+  const Object_attribute*
+  get_attribute(int vendor, int tag) const
+  {
+    gold_assert(vendor >= OBJ_ATTR_FIRST && vendor <= OBJ_ATTR_LAST);
+    return this->vendor_object_attributes_[vendor]->get_attribute(tag);
+  }
+  
+  // Merge target-independent attributes from another Attributes_section_data
+  // of an object called NAME.
+  void
+  merge(const char* name, const Attributes_section_data* pasd);
+
+  // Write to byte stream in an unsigned char vector.
+  void
+  write(std::vector<unsigned char>*) const;
+
+ private:
+  // For convenience.
+  static const int OBJ_ATTR_FIRST = Object_attribute::OBJ_ATTR_FIRST;
+  static const int OBJ_ATTR_LAST = Object_attribute::OBJ_ATTR_LAST;
+
+  // Vendor object attributes.
+  Vendor_object_attributes* vendor_object_attributes_[OBJ_ATTR_LAST+1];
+};
+
+// This class is used for writing out an Attribute_section_data.
+
+class Output_attributes_section_data : public Output_section_data
+{
+ public:
+  Output_attributes_section_data(const Attributes_section_data& asd)
+    : Output_section_data(1), attributes_section_data_(asd)
+  { }
+
+ protected:
+  // Write the data to the output file.
+  void
+  do_write(Output_file*);
+  
+  // Set final data size.
+  void
+  set_final_data_size()
+  { this->set_data_size(attributes_section_data_.size()); }
+
+ private:
+  // Attributes_section_data corresponding to this.
+  const Attributes_section_data& attributes_section_data_;
+};
+
+} // End namespace gold.
+
+#endif	// !defined(GOLD_ATTRIBUTES_H)
diff --git a/gold/common.cc b/gold/common.cc
index f90ae40..c4ff047 100644
--- a/gold/common.cc
+++ b/gold/common.cc
@@ -64,21 +64,26 @@ Allocate_commons_task::run(Workqueue*)
   this->symtab_->allocate_commons(this->layout_, this->mapfile_);
 }
 
-// This class is used to sort the common symbol by size.  We put the
-// larger common symbols first.
+// This class is used to sort the common symbol.  We normally put the
+// larger common symbols first.  This can be changed by using
+// --sort-commons, which tells the linker to sort by alignment.
 
 template<int size>
 class Sort_commons
 {
  public:
-  Sort_commons(const Symbol_table* symtab)
-    : symtab_(symtab)
+  Sort_commons(const Symbol_table* symtab,
+	       Symbol_table::Sort_commons_order sort_order)
+    : symtab_(symtab), sort_order_(sort_order)
   { }
 
   bool operator()(const Symbol* a, const Symbol* b) const;
 
  private:
+  // The symbol table.
   const Symbol_table* symtab_;
+  // How to sort.
+  Symbol_table::Sort_commons_order sort_order_;
 };
 
 template<int size>
@@ -94,22 +99,48 @@ Sort_commons<size>::operator()(const Symbol* pa, const Symbol* pb) const
   const Sized_symbol<size>* psa = symtab->get_sized_symbol<size>(pa);
   const Sized_symbol<size>* psb = symtab->get_sized_symbol<size>(pb);
 
-  // Sort by largest size first.
+  // The size.
   typename Sized_symbol<size>::Size_type sa = psa->symsize();
   typename Sized_symbol<size>::Size_type sb = psb->symsize();
+
+  // The alignment.
+  typename Sized_symbol<size>::Value_type aa = psa->value();
+  typename Sized_symbol<size>::Value_type ab = psb->value();
+
+  if (this->sort_order_ == Symbol_table::SORT_COMMONS_BY_ALIGNMENT_DESCENDING)
+    {
+      if (aa < ab)
+	return false;
+      else if (ab < aa)
+	return true;
+    }
+  else if (this->sort_order_
+	   == Symbol_table::SORT_COMMONS_BY_ALIGNMENT_ASCENDING)
+    {
+      if (aa < ab)
+	return true;
+      else if (ab < aa)
+	return false;
+    }
+  else
+    gold_assert(this->sort_order_
+		== Symbol_table::SORT_COMMONS_BY_SIZE_DESCENDING);
+
+  // Sort by descending size.
   if (sa < sb)
     return false;
   else if (sb < sa)
     return true;
 
-  // When the symbols are the same size, we sort them by alignment,
-  // largest alignment first.
-  typename Sized_symbol<size>::Value_type va = psa->value();
-  typename Sized_symbol<size>::Value_type vb = psb->value();
-  if (va < vb)
-    return false;
-  else if (vb < va)
-    return true;
+  if (this->sort_order_ == Symbol_table::SORT_COMMONS_BY_SIZE_DESCENDING)
+    {
+      // When the symbols are the same size, we sort them by
+      // alignment, largest alignment first.
+      if (aa < ab)
+	return false;
+      else if (ab < aa)
+	return true;
+    }
 
   // Otherwise we stabilize the sort by sorting by name.
   return strcmp(psa->name(), psb->name()) < 0;
@@ -120,10 +151,27 @@ Sort_commons<size>::operator()(const Symbol* pa, const Symbol* pb) const
 void
 Symbol_table::allocate_commons(Layout* layout, Mapfile* mapfile)
 {
+  Sort_commons_order sort_order;
+  if (!parameters->options().user_set_sort_common())
+    sort_order = SORT_COMMONS_BY_SIZE_DESCENDING;
+  else
+    {
+      const char* order = parameters->options().sort_common();
+      if (*order == '\0' || strcmp(order, "descending") == 0)
+	sort_order = SORT_COMMONS_BY_ALIGNMENT_DESCENDING;
+      else if (strcmp(order, "ascending") == 0)
+	sort_order = SORT_COMMONS_BY_ALIGNMENT_ASCENDING;
+      else
+	{
+	  gold_error("invalid --sort-common argument: %s", order);
+	  sort_order = SORT_COMMONS_BY_SIZE_DESCENDING;
+	}
+    }
+
   if (parameters->target().get_size() == 32)
     {
 #if defined(HAVE_TARGET_32_LITTLE) || defined(HAVE_TARGET_32_BIG)
-      this->do_allocate_commons<32>(layout, mapfile);
+      this->do_allocate_commons<32>(layout, mapfile, sort_order);
 #else
       gold_unreachable();
 #endif
@@ -131,7 +179,7 @@ Symbol_table::allocate_commons(Layout* layout, Mapfile* mapfile)
   else if (parameters->target().get_size() == 64)
     {
 #if defined(HAVE_TARGET_64_LITTLE) || defined(HAVE_TARGET_64_BIG)
-      this->do_allocate_commons<64>(layout, mapfile);
+      this->do_allocate_commons<64>(layout, mapfile, sort_order);
 #else
       gold_unreachable();
 #endif
@@ -144,20 +192,25 @@ Symbol_table::allocate_commons(Layout* layout, Mapfile* mapfile)
 
 template<int size>
 void
-Symbol_table::do_allocate_commons(Layout* layout, Mapfile* mapfile)
+Symbol_table::do_allocate_commons(Layout* layout, Mapfile* mapfile,
+				  Sort_commons_order sort_order)
 {
   if (!this->commons_.empty())
     this->do_allocate_commons_list<size>(layout, COMMONS_NORMAL,
-					 &this->commons_, mapfile);
+					 &this->commons_, mapfile,
+					 sort_order);
   if (!this->tls_commons_.empty())
     this->do_allocate_commons_list<size>(layout, COMMONS_TLS,
-					 &this->tls_commons_, mapfile);
+					 &this->tls_commons_, mapfile,
+					 sort_order);
   if (!this->small_commons_.empty())
     this->do_allocate_commons_list<size>(layout, COMMONS_SMALL,
-					 &this->small_commons_, mapfile);
+					 &this->small_commons_, mapfile,
+					 sort_order);
   if (!this->large_commons_.empty())
     this->do_allocate_commons_list<size>(layout, COMMONS_LARGE,
-					 &this->large_commons_, mapfile);
+					 &this->large_commons_, mapfile,
+					 sort_order);
 }
 
 // Allocate the common symbols in a list.  IS_TLS indicates whether
@@ -169,7 +222,8 @@ Symbol_table::do_allocate_commons_list(
     Layout* layout,
     Commons_section_type commons_section_type,
     Commons_type* commons,
-    Mapfile* mapfile)
+    Mapfile* mapfile,
+    Sort_commons_order sort_order)
 {
   typedef typename Sized_symbol<size>::Value_type Value_type;
   typedef typename Sized_symbol<size>::Size_type Size_type;
@@ -202,10 +256,9 @@ Symbol_table::do_allocate_commons_list(
   if (!any)
     return;
 
-  // Sort the common symbols by size, so that they pack better into
-  // memory.
+  // Sort the common symbols.
   std::sort(commons->begin(), commons->end(),
-	    Sort_commons<size>(this));
+	    Sort_commons<size>(this, sort_order));
 
   // Place them in a newly allocated BSS section.
   elfcpp::Elf_Xword flags = elfcpp::SHF_WRITE | elfcpp::SHF_ALLOC;
@@ -239,7 +292,8 @@ Symbol_table::do_allocate_commons_list(
   Output_data_space *poc = new Output_data_space(addralign, ds_name);
   Output_section *os = layout->add_output_section_data(name,
 						       elfcpp::SHT_NOBITS,
-						       flags, poc);
+						       flags, poc, false,
+						       false, false, false);
   if (os != NULL)
     {
       if (commons_section_type == COMMONS_SMALL)
diff --git a/gold/configure b/gold/configure
index e4eb9fb..cf99f4a 100755
--- a/gold/configure
+++ b/gold/configure
@@ -3410,6 +3410,9 @@ fi
   fi
 done
 
+# Remove any duplicates.
+targetobjs=`echo $targetobjs | tr ' ' '\n' | sort | uniq | tr '\n' ' '`
+
 if test -n "$targ_32_little"; then
 
 $as_echo "#define HAVE_TARGET_32_LITTLE 1" >>confdefs.h
diff --git a/gold/configure.ac b/gold/configure.ac
index 85e23f9..73ad132 100644
--- a/gold/configure.ac
+++ b/gold/configure.ac
@@ -162,6 +162,9 @@ for targ in $target $canon_targets; do
   fi
 done
 
+# Remove any duplicates.
+targetobjs=`echo $targetobjs | tr ' ' '\n' | sort | uniq | tr '\n' ' '`
+
 if test -n "$targ_32_little"; then
   AC_DEFINE(HAVE_TARGET_32_LITTLE, 1,
 	      [Define to support 32-bit little-endian targets])
diff --git a/gold/configure.tgt b/gold/configure.tgt
index de6d4f9..0f3b1c3 100644
--- a/gold/configure.tgt
+++ b/gold/configure.tgt
@@ -106,6 +106,7 @@ powerpc64-*)
   ;;
 armeb*-*-*|armbe*-*-*)
  targ_obj=arm
+ targ_extra_obj=arm-reloc-property
  targ_machine=EM_ARM
  targ_size=32
  targ_big_endian=true
@@ -113,6 +114,7 @@ armeb*-*-*|armbe*-*-*)
  ;;
 arm*-*-*)
  targ_obj=arm
+ targ_extra_obj=arm-reloc-property
  targ_machine=EM_ARM
  targ_size=32
  targ_big_endian=false
diff --git a/gold/copy-relocs.cc b/gold/copy-relocs.cc
index 6ef72d3..4a98f83 100644
--- a/gold/copy-relocs.cc
+++ b/gold/copy-relocs.cc
@@ -138,7 +138,8 @@ Copy_relocs<sh_type, size, big_endian>::emit_copy_reloc(
       layout->add_output_section_data(".bss",
 				      elfcpp::SHT_NOBITS,
 				      elfcpp::SHF_ALLOC | elfcpp::SHF_WRITE,
-				      this->dynbss_);
+				      this->dynbss_, false, false, false,
+				      false);
     }
 
   Output_data_space* dynbss = this->dynbss_;
diff --git a/gold/dwarf_reader.cc b/gold/dwarf_reader.cc
index d142586..4062fe6 100644
--- a/gold/dwarf_reader.cc
+++ b/gold/dwarf_reader.cc
@@ -31,77 +31,10 @@
 #include "parameters.h"
 #include "reloc.h"
 #include "dwarf_reader.h"
+#include "int_encoding.h"
 
 namespace gold {
 
-// Read an unsigned LEB128 number.  Each byte contains 7 bits of
-// information, plus one bit saying whether the number continues or
-// not.
-
-uint64_t
-read_unsigned_LEB_128(const unsigned char* buffer, size_t* len)
-{
-  uint64_t result = 0;
-  size_t num_read = 0;
-  unsigned int shift = 0;
-  unsigned char byte;
-
-  do
-    {
-      if (num_read >= 64 / 7) 
-        {
-          gold_warning(_("Unusually large LEB128 decoded, "
-			 "debug information may be corrupted"));
-          break;
-        }
-      byte = *buffer++;
-      num_read++;
-      result |= (static_cast<uint64_t>(byte & 0x7f)) << shift;
-      shift += 7;
-    }
-  while (byte & 0x80);
-
-  *len = num_read;
-
-  return result;
-}
-
-// Read a signed LEB128 number.  These are like regular LEB128
-// numbers, except the last byte may have a sign bit set.
-
-int64_t
-read_signed_LEB_128(const unsigned char* buffer, size_t* len)
-{
-  int64_t result = 0;
-  int shift = 0;
-  size_t num_read = 0;
-  unsigned char byte;
-
-  do
-    {
-      if (num_read >= 64 / 7) 
-        {
-          gold_warning(_("Unusually large LEB128 decoded, "
-			 "debug information may be corrupted"));
-          break;
-        }
-      byte = *buffer++;
-      num_read++;
-      result |= (static_cast<uint64_t>(byte & 0x7f) << shift);
-      shift += 7;
-    }
-  while (byte & 0x80);
-
-  if ((shift < 8 * static_cast<int>(sizeof(result))) && (byte & 0x40))
-    result |= -((static_cast<int64_t>(1)) << shift);
-  *len = num_read;
-  return result;
-}
-
-// This is the format of a DWARF2/3 line state machine that we process
-// opcodes using.  There is no need for anything outside the lineinfo
-// processor to know how this works.
-
 struct LineStateMachine
 {
   int file_num;
diff --git a/gold/dwarf_reader.h b/gold/dwarf_reader.h
index c18ed89..e2b8aa0 100644
--- a/gold/dwarf_reader.h
+++ b/gold/dwarf_reader.h
@@ -38,12 +38,6 @@ template<int size, bool big_endian>
 class Track_relocs;
 struct LineStateMachine;
 
-uint64_t
-read_unsigned_LEB_128(const unsigned char* buffer, size_t* len);
-
-int64_t
-read_signed_LEB_128(const unsigned char* buffer, size_t* len);
-
 // We can't do better than to keep the offsets in a sorted vector.
 // Here, offset is the key, and file_num/line_num is the value.
 struct Offset_to_lineno_entry
diff --git a/gold/dynobj.cc b/gold/dynobj.cc
index b14d06d..fe94f06 100644
--- a/gold/dynobj.cc
+++ b/gold/dynobj.cc
@@ -1498,7 +1498,9 @@ Versions::finalize(Symbol_table* symtab, unsigned int dynsym_index,
       if (!(*p)->is_symbol_created())
 	{
 	  Symbol* vsym = symtab->define_as_constant((*p)->name(),
-						    (*p)->name(), 0, 0,
+						    (*p)->name(),
+						    Symbol_table::PREDEFINED,
+						    0, 0,
 						    elfcpp::STT_OBJECT,
 						    elfcpp::STB_GLOBAL,
 						    elfcpp::STV_DEFAULT, 0,
diff --git a/gold/expression.cc b/gold/expression.cc
index 25f3ac3..134b0fa 100644
--- a/gold/expression.cc
+++ b/gold/expression.cc
@@ -66,6 +66,8 @@ struct Expression::Expression_eval_info
   Output_section* dot_section;
   // Points to where the section of the result should be stored.
   Output_section** result_section_pointer;
+  // Pointer to where the alignment of the result should be stored.
+  uint64_t* result_alignment_pointer;
 };
 
 // Evaluate an expression.
@@ -76,7 +78,7 @@ Expression::eval(const Symbol_table* symtab, const Layout* layout,
 {
   Output_section* dummy;
   return this->eval_maybe_dot(symtab, layout, check_assertions,
-			      false, 0, NULL, &dummy);
+			      false, 0, NULL, &dummy, NULL);
 }
 
 // Evaluate an expression which may refer to the dot symbol.
@@ -85,10 +87,12 @@ uint64_t
 Expression::eval_with_dot(const Symbol_table* symtab, const Layout* layout,
 			  bool check_assertions, uint64_t dot_value,
 			  Output_section* dot_section,
-			  Output_section** result_section_pointer)
+			  Output_section** result_section_pointer,
+			  uint64_t* result_alignment_pointer)
 {
   return this->eval_maybe_dot(symtab, layout, check_assertions, true,
-			      dot_value, dot_section, result_section_pointer);
+			      dot_value, dot_section, result_section_pointer,
+			      result_alignment_pointer);
 }
 
 // Evaluate an expression which may or may not refer to the dot
@@ -98,7 +102,8 @@ uint64_t
 Expression::eval_maybe_dot(const Symbol_table* symtab, const Layout* layout,
 			   bool check_assertions, bool is_dot_available,
 			   uint64_t dot_value, Output_section* dot_section,
-			   Output_section** result_section_pointer)
+			   Output_section** result_section_pointer,
+			   uint64_t* result_alignment_pointer)
 {
   Expression_eval_info eei;
   eei.symtab = symtab;
@@ -113,6 +118,8 @@ Expression::eval_maybe_dot(const Symbol_table* symtab, const Layout* layout,
   *result_section_pointer = NULL;
   eei.result_section_pointer = result_section_pointer;
 
+  eei.result_alignment_pointer = result_alignment_pointer;
+
   return this->value(&eei);
 }
 
@@ -247,7 +254,8 @@ class Unary_expression : public Expression
 				      eei->is_dot_available,
 				      eei->dot_value,
 				      eei->dot_section,
-				      arg_section_pointer);
+				      arg_section_pointer,
+				      eei->result_alignment_pointer);
   }
 
   void
@@ -317,26 +325,30 @@ class Binary_expression : public Expression
  protected:
   uint64_t
   left_value(const Expression_eval_info* eei,
-	     Output_section** section_pointer) const
+	     Output_section** section_pointer,
+	     uint64_t* alignment_pointer) const
   {
     return this->left_->eval_maybe_dot(eei->symtab, eei->layout,
 				       eei->check_assertions,
 				       eei->is_dot_available,
 				       eei->dot_value,
 				       eei->dot_section,
-				       section_pointer);
+				       section_pointer,
+				       alignment_pointer);
   }
 
   uint64_t
   right_value(const Expression_eval_info* eei,
-	      Output_section** section_pointer) const
+	      Output_section** section_pointer,
+	      uint64_t* alignment_pointer) const
   {
     return this->right_->eval_maybe_dot(eei->symtab, eei->layout,
 					eei->check_assertions,
 					eei->is_dot_available,
 					eei->dot_value,
 					eei->dot_section,
-					section_pointer);
+					section_pointer,
+					alignment_pointer);
   }
 
   void
@@ -385,15 +397,27 @@ class Binary_expression : public Expression
     value(const Expression_eval_info* eei)				\
     {									\
       Output_section* left_section;					\
-      uint64_t left = this->left_value(eei, &left_section);		\
+      uint64_t left_alignment;						\
+      uint64_t left = this->left_value(eei, &left_section,		\
+				       &left_alignment);		\
       Output_section* right_section;					\
-      uint64_t right = this->right_value(eei, &right_section);		\
+      uint64_t right_alignment;						\
+      uint64_t right = this->right_value(eei, &right_section,		\
+					 &right_alignment);		\
       if (KEEP_RIGHT && left_section == NULL && right_section != NULL)	\
-	*eei->result_section_pointer = right_section;			\
+	{								\
+	  *eei->result_section_pointer = right_section;			\
+	  if (eei->result_alignment_pointer != NULL)			\
+	    *eei->result_alignment_pointer = right_alignment;		\
+	}								\
       else if (KEEP_LEFT						\
 	       && left_section != NULL					\
 	       && right_section == NULL)				\
-	*eei->result_section_pointer = left_section;			\
+	{								\
+	  *eei->result_section_pointer = left_section;			\
+	  if (eei->result_alignment_pointer != NULL)			\
+	    *eei->result_alignment_pointer = right_alignment;		\
+	}								\
       else if ((WARN || left_section != right_section)			\
 	       && (left_section != NULL || right_section != NULL)	\
 	       && parameters->options().relocatable())			\
@@ -469,31 +493,36 @@ class Trinary_expression : public Expression
 				       eei->is_dot_available,
 				       eei->dot_value,
 				       eei->dot_section,
-				       section_pointer);
+				       section_pointer,
+				       NULL);
   }
 
   uint64_t
   arg2_value(const Expression_eval_info* eei,
-	     Output_section** section_pointer) const
+	     Output_section** section_pointer,
+	     uint64_t* alignment_pointer) const
   {
     return this->arg1_->eval_maybe_dot(eei->symtab, eei->layout,
 				       eei->check_assertions,
 				       eei->is_dot_available,
 				       eei->dot_value,
 				       eei->dot_section,
-				       section_pointer);
+				       section_pointer,
+				       alignment_pointer);
   }
 
   uint64_t
   arg3_value(const Expression_eval_info* eei,
-	     Output_section** section_pointer) const
+	     Output_section** section_pointer,
+	     uint64_t* alignment_pointer) const
   {
     return this->arg1_->eval_maybe_dot(eei->symtab, eei->layout,
 				       eei->check_assertions,
 				       eei->is_dot_available,
 				       eei->dot_value,
 				       eei->dot_section,
-				       section_pointer);
+				       section_pointer,
+				       alignment_pointer);
   }
 
   void
@@ -529,8 +558,10 @@ class Trinary_cond : public Trinary_expression
     Output_section* arg1_section;
     uint64_t arg1 = this->arg1_value(eei, &arg1_section);
     return (arg1
-	    ? this->arg2_value(eei, eei->result_section_pointer)
-	    : this->arg3_value(eei, eei->result_section_pointer));
+	    ? this->arg2_value(eei, eei->result_section_pointer,
+			       eei->result_alignment_pointer)
+	    : this->arg3_value(eei, eei->result_section_pointer,
+			       eei->result_alignment_pointer));
   }
 
   void
@@ -565,14 +596,27 @@ class Max_expression : public Binary_expression
   value(const Expression_eval_info* eei)
   {
     Output_section* left_section;
-    uint64_t left = this->left_value(eei, &left_section);
+    uint64_t left_alignment;
+    uint64_t left = this->left_value(eei, &left_section, &left_alignment);
     Output_section* right_section;
-    uint64_t right = this->right_value(eei, &right_section);
+    uint64_t right_alignment;
+    uint64_t right = this->right_value(eei, &right_section, &right_alignment);
     if (left_section == right_section)
       *eei->result_section_pointer = left_section;
     else if ((left_section != NULL || right_section != NULL)
 	     && parameters->options().relocatable())
       gold_warning(_("max applied to section relative value"));
+    if (eei->result_alignment_pointer != NULL)
+      {
+	uint64_t ra = *eei->result_alignment_pointer;
+	if (left > right)
+	  ra = std::max(ra, left_alignment);
+	else if (right > left)
+	  ra = std::max(ra, right_alignment);
+	else
+	  ra = std::max(ra, std::max(left_alignment, right_alignment));
+	*eei->result_alignment_pointer = ra;
+      }
     return std::max(left, right);
   }
 
@@ -600,14 +644,27 @@ class Min_expression : public Binary_expression
   value(const Expression_eval_info* eei)
   {
     Output_section* left_section;
-    uint64_t left = this->left_value(eei, &left_section);
+    uint64_t left_alignment;
+    uint64_t left = this->left_value(eei, &left_section, &left_alignment);
     Output_section* right_section;
-    uint64_t right = this->right_value(eei, &right_section);
+    uint64_t right_alignment;
+    uint64_t right = this->right_value(eei, &right_section, &right_alignment);
     if (left_section == right_section)
       *eei->result_section_pointer = left_section;
     else if ((left_section != NULL || right_section != NULL)
 	     && parameters->options().relocatable())
       gold_warning(_("min applied to section relative value"));
+    if (eei->result_alignment_pointer != NULL)
+      {
+	uint64_t ra = *eei->result_alignment_pointer;
+	if (left < right)
+	  ra = std::max(ra, left_alignment);
+	else if (right < left)
+	  ra = std::max(ra, right_alignment);
+	else
+	  ra = std::max(ra, std::max(left_alignment, right_alignment));
+	*eei->result_alignment_pointer = ra;
+      }
     return std::min(left, right);
   }
 
@@ -734,12 +791,21 @@ class Align_expression : public Binary_expression
   value(const Expression_eval_info* eei)
   {
     Output_section* align_section;
-    uint64_t align = this->right_value(eei, &align_section);
+    uint64_t align = this->right_value(eei, &align_section, NULL);
     if (align_section != NULL
 	&& parameters->options().relocatable())
       gold_warning(_("aligning to section relative value"));
 
-    uint64_t value = this->left_value(eei, eei->result_section_pointer);
+    if (eei->result_alignment_pointer != NULL
+	&& align > *eei->result_alignment_pointer)
+      {
+	uint64_t a = align;
+	while ((a & (a - 1)) != 0)
+	  a &= a - 1;
+	*eei->result_alignment_pointer = a;
+      }
+
+    uint64_t value = this->left_value(eei, eei->result_section_pointer, NULL);
     if (align <= 1)
       return value;
     return ((value + align - 1) / align) * align;
@@ -1113,17 +1179,62 @@ script_exp_function_sizeof_headers()
   return new Sizeof_headers_expression();
 }
 
-// In the GNU linker SEGMENT_START basically returns the value for
-// -Ttext, -Tdata, or -Tbss.  We could implement this by copying the
-// values from General_options to Parameters.  But I doubt that
-// anybody actually uses it.  The point of it for the GNU linker was
-// because -Ttext set the address of the .text section rather than the
-// text segment.  In gold -Ttext sets the text segment address anyhow.
+// SEGMENT_START.
+
+class Segment_start_expression : public Unary_expression
+{
+ public:
+  Segment_start_expression(const char* segment_name, size_t segment_name_len,
+			   Expression* default_value)
+    : Unary_expression(default_value),
+      segment_name_(segment_name, segment_name_len)
+  { }
+
+  uint64_t
+  value(const Expression_eval_info*);
+
+  void
+  print(FILE* f) const
+  {
+    fprintf(f, "SEGMENT_START(\"%s\", ", this->segment_name_.c_str());
+    this->arg_print(f);
+    fprintf(f, ")");
+  }
+
+ private:
+  std::string segment_name_;
+};
+
+uint64_t
+Segment_start_expression::value(const Expression_eval_info* eei)
+{
+  // Check for command line overrides.
+  if (parameters->options().user_set_Ttext()
+      && this->segment_name_ == ".text")
+    return parameters->options().Ttext();
+  else if (parameters->options().user_set_Tdata()
+	   && this->segment_name_ == ".data")
+    return parameters->options().Tdata();
+  else if (parameters->options().user_set_Tbss()
+	   && this->segment_name_ == ".bss")
+    return parameters->options().Tbss();
+  else
+    {
+      Output_section* dummy;
+      uint64_t ret = this->arg_value(eei, &dummy);
+      // Force the value to be absolute.
+      *eei->result_section_pointer = NULL;
+      return ret;
+    }
+}
 
 extern "C" Expression*
-script_exp_function_segment_start(const char*, size_t, Expression*)
+script_exp_function_segment_start(const char* segment_name,
+				  size_t segment_name_len,
+				  Expression* default_value)
 {
-  gold_fatal(_("SEGMENT_START not implemented"));
+  return new Segment_start_expression(segment_name, segment_name_len,
+				      default_value);
 }
 
 // Functions for memory regions.  These can not be implemented unless
diff --git a/gold/gc.h b/gold/gc.h
index 757a33d..4dd3507 100644
--- a/gold/gc.h
+++ b/gold/gc.h
@@ -28,6 +28,7 @@
 
 #include "elfcpp.h"
 #include "symtab.h"
+#include "object.h"
 #include "icf.h"
 
 namespace gold
@@ -45,21 +46,17 @@ class Output_section;
 class General_options;
 class Layout;
 
-typedef std::pair<Object *, unsigned int> Section_id;
-
 class Garbage_collection
 {
-  struct Section_id_hash
-  {
-    size_t operator()(const Section_id& loc) const
-    { return reinterpret_cast<uintptr_t>(loc.first) ^ loc.second; }
-  };
-
  public:
 
   typedef Unordered_set<Section_id, Section_id_hash> Sections_reachable;
   typedef std::map<Section_id, Sections_reachable> Section_ref;
   typedef std::queue<Section_id> Worklist_type;
+  // This maps the name of the section which can be represented as a C
+  // identifier (cident) to the list of sections that have that name.
+  // Different object files can have cident sections with the same name.
+  typedef std::map<std::string, Sections_reachable> Cident_section_map;
 
   Garbage_collection()
   : is_worklist_ready_(false)
@@ -94,12 +91,38 @@ class Garbage_collection
   is_section_garbage(Object* obj, unsigned int shndx)
   { return (this->referenced_list().find(Section_id(obj, shndx))
             == this->referenced_list().end()); }
+
+  Cident_section_map*
+  cident_sections()
+  { return &cident_sections_; }
+
+  void
+  add_cident_section(std::string section_name,
+		     Section_id secn)
+  { this->cident_sections_[section_name].insert(secn); }
+
+  // Add a reference from the SRC_SHNDX-th section of SRC_OBJECT to
+  // DST_SHNDX-th section of DST_OBJECT.
+  void
+  add_reference(Object* src_object, unsigned int src_shndx,
+		Object* dst_object, unsigned int dst_shndx)
+  {
+    Section_id src_id(src_object, src_shndx);
+    Section_id dst_id(dst_object, dst_shndx);
+    Section_ref::iterator p = this->section_reloc_map_.find(src_id);
+    if (p == this->section_reloc_map_.end())
+      this->section_reloc_map_[src_id].insert(dst_id);
+    else
+      p->second.insert(dst_id);
+  }
+
  private:
 
   Worklist_type work_list_;
   bool is_worklist_ready_;
   Section_ref section_reloc_map_;
   Sections_reachable referenced_list_;
+  Cident_section_map cident_sections_;
 };
 
 // Data to pass between successive invocations of do_layout
@@ -138,7 +161,6 @@ template<int size, bool big_endian, typename Target_type, int sh_type,
 	 typename Scan>
 inline void
 gc_process_relocs(
-    const General_options& ,
     Symbol_table* symtab,
     Layout*,
     Target_type* ,
@@ -162,6 +184,7 @@ gc_process_relocs(
   std::vector<Symbol*>* symvec = NULL;
   std::vector<std::pair<long long, long long> >* addendvec = NULL;
   bool is_icf_tracked = false;
+  const char* cident_section_name = NULL;
 
   if (parameters->options().icf_enabled()
       && is_prefix_of(".text.", (src_obj)->section_name(src_indx).c_str()))
@@ -219,6 +242,19 @@ gc_process_relocs(
           if (!is_ordinary)
             continue;
           Section_id dst_id(dst_obj, dst_indx);
+          // If the symbol name matches '__start_XXX' then the section with
+          // the C identifier like name 'XXX' should not be garbage collected.
+          // A similar treatment to symbols with the name '__stop_XXX'.
+          if (is_prefix_of(cident_section_start_prefix, gsym->name()))
+            {
+              cident_section_name = (gsym->name() 
+                                     + strlen(cident_section_start_prefix));
+            }
+          else if (is_prefix_of(cident_section_stop_prefix, gsym->name()))
+            {
+              cident_section_name = (gsym->name() 
+                                     + strlen(cident_section_stop_prefix));
+            }
           if (is_icf_tracked)
             {
               (*secvec).push_back(dst_id);
@@ -233,18 +269,24 @@ gc_process_relocs(
         }
       if (parameters->options().gc_sections())
         {
-          Section_id src_id(src_obj, src_indx);
-          Section_id dst_id(dst_obj, dst_indx);
-          Garbage_collection::Section_ref::iterator map_it;
-          map_it = symtab->gc()->section_reloc_map().find(src_id);
-          if (map_it == symtab->gc()->section_reloc_map().end())
-            {
-              symtab->gc()->section_reloc_map()[src_id].insert(dst_id);
-            }
-          else
+	  symtab->gc()->add_reference(src_obj, src_indx, dst_obj, dst_indx);
+          if (cident_section_name != NULL)
             {
-              Garbage_collection::Sections_reachable& v(map_it->second);
-              v.insert(dst_id);
+              Garbage_collection::Cident_section_map::iterator ele =
+                symtab->gc()->cident_sections()->find(std::string(cident_section_name));
+              if (ele == symtab->gc()->cident_sections()->end())
+                continue;
+	      Section_id src_id(src_obj, src_indx);
+              Garbage_collection::Sections_reachable&
+                v(symtab->gc()->section_reloc_map()[src_id]);
+              Garbage_collection::Sections_reachable& cident_secn(ele->second);
+              for (Garbage_collection::Sections_reachable::iterator it_v
+                     = cident_secn.begin();
+                   it_v != cident_secn.end();
+                   ++it_v)
+                {
+                  v.insert(*it_v);
+                }
             }
         }
     }
diff --git a/gold/gold.cc b/gold/gold.cc
index 4ac1e3d..ddb05b5 100644
--- a/gold/gold.cc
+++ b/gold/gold.cc
@@ -229,7 +229,7 @@ queue_initial_tasks(const General_options& options,
       || parameters->options().icf_enabled())
     {
       workqueue->queue(new Task_function(new Gc_runner(options,
-                                                       input_objects,
+						       input_objects,
                                                        symtab,
                                                        layout,
                                                        mapfile),
@@ -273,8 +273,8 @@ queue_middle_gc_tasks(const General_options& options,
     {
       // We can read and process the relocations in any order.  
       blocker->add_blocker();
-      workqueue->queue(new Read_relocs(options, symtab, layout, *p,
-				       symtab_lock, blocker));
+      workqueue->queue(new Read_relocs(symtab, layout, *p, symtab_lock,
+				       blocker));
     }
 
   Task_token* this_blocker = new Task_token(true);
@@ -485,8 +485,9 @@ queue_middle_tasks(const General_options& options,
            ++p)
         {
           blocker->add_blocker();
-          workqueue->queue(new Scan_relocs(options, symtab, layout, *p, 
-                           (*p)->get_relocs_data(),symtab_lock, blocker));
+          workqueue->queue(new Scan_relocs(symtab, layout, *p, 
+					   (*p)->get_relocs_data(),
+					   symtab_lock, blocker));
         }
     }
   else
@@ -512,8 +513,8 @@ queue_middle_tasks(const General_options& options,
           // relocations.  That task will in turn queue a task to wait
           // until it can write to the symbol table.
           blocker->add_blocker();
-          workqueue->queue(new Read_relocs(options, symtab, layout, *p,
-                   symtab_lock, blocker));
+          workqueue->queue(new Read_relocs(symtab, layout, *p, symtab_lock,
+					   blocker));
         }
     }
 
@@ -600,7 +601,7 @@ queue_final_tasks(const General_options& options,
       if (input_sections_blocker != NULL)
 	input_sections_blocker->add_blocker();
       final_blocker->add_blocker();
-      workqueue->queue(new Relocate_task(options, symtab, layout, *p, of,
+      workqueue->queue(new Relocate_task(symtab, layout, *p, of,
 					 input_sections_blocker,
 					 output_sections_blocker,
 					 final_blocker));
diff --git a/gold/gold.h b/gold/gold.h
index 3f514cd..5c98de0 100644
--- a/gold/gold.h
+++ b/gold/gold.h
@@ -1,6 +1,6 @@
 // gold.h -- general definitions for gold   -*- C++ -*-
 
-// Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
+// Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
 // Written by Ian Lance Taylor <iant@google.com>.
 
 // This file is part of gold.
@@ -349,6 +349,58 @@ is_prefix_of(const char* prefix, const char* str)
   return strncmp(prefix, str, strlen(prefix)) == 0;
 }
 
+const char* const cident_section_start_prefix = "__start_";
+const char* const cident_section_stop_prefix = "__stop_";
+
+// Returns true if the name is a valid C identifier
+inline bool
+is_cident(const char* name)
+{
+  return (name[strspn(name,
+	 	      ("0123456789"
+		       "ABCDEFGHIJKLMNOPWRSTUVWXYZ"
+		       "abcdefghijklmnopqrstuvwxyz"
+		       "_"))]
+	  == '\0');
+}
+
+// We sometimes need to hash strings.  Ideally we should use std::tr1::hash or
+// __gnu_cxx::hash on some systems but there is no guarantee that either
+// one is available.  For portability, we define simple string hash functions.
+
+template<typename Char_type>
+inline size_t
+string_hash(const Char_type* s, size_t length)
+{
+  // This is the hash function used by the dynamic linker for
+  // DT_GNU_HASH entries.  I compared this to a Fowler/Noll/Vo hash
+  // for a C++ program with 385,775 global symbols.  This hash
+  // function was very slightly worse.  However, it is much faster to
+  // compute.  Overall wall clock time was a win.
+  const unsigned char* p = reinterpret_cast<const unsigned char*>(s);
+  size_t h = 5381;
+  for (size_t i = 0; i < length * sizeof(Char_type); ++i)
+    h = h * 33 + *p++;
+  return h;
+}
+
+// Same as above except we expect the string to be zero terminated.
+
+template<typename Char_type>
+inline size_t
+string_hash(const Char_type* s)
+{
+  const unsigned char* p = reinterpret_cast<const unsigned char*>(s);
+  size_t h = 5381;
+  for (size_t i = 0; s[i] != 0; ++i)
+    {
+      for (size_t j = 0; j < sizeof(Char_type); j++)
+	h = h * 33 + *p++;
+    }
+
+  return h;
+}
+
 } // End namespace gold.
 
 #endif // !defined(GOLD_GOLD_H)
diff --git a/gold/i386.cc b/gold/i386.cc
index 445a7ac..91abd4e 100644
--- a/gold/i386.cc
+++ b/gold/i386.cc
@@ -67,8 +67,7 @@ class Target_i386 : public Target_freebsd<32, false>
   // Process the relocations to determine unreferenced sections for 
   // garbage collection.
   void
-  gc_process_relocs(const General_options& options,
-                    Symbol_table* symtab,
+  gc_process_relocs(Symbol_table* symtab,
                     Layout* layout,
                     Sized_relobj<32, false>* object,
                     unsigned int data_shndx,
@@ -82,8 +81,7 @@ class Target_i386 : public Target_freebsd<32, false>
 
   // Scan the relocations to look for symbol adjustments.
   void
-  scan_relocs(const General_options& options,
-	      Symbol_table* symtab,
+  scan_relocs(Symbol_table* symtab,
 	      Layout* layout,
 	      Sized_relobj<32, false>* object,
 	      unsigned int data_shndx,
@@ -97,7 +95,7 @@ class Target_i386 : public Target_freebsd<32, false>
 
   // Finalize the sections.
   void
-  do_finalize_sections(Layout*);
+  do_finalize_sections(Layout*, const Input_objects*, Symbol_table*);
 
   // Return the value to use for a dynamic which requires special
   // treatment.
@@ -119,8 +117,7 @@ class Target_i386 : public Target_freebsd<32, false>
 
   // Scan the relocs during a relocatable link.
   void
-  scan_relocatable_relocs(const General_options& options,
-			  Symbol_table* symtab,
+  scan_relocatable_relocs(Symbol_table* symtab,
 			  Layout* layout,
 			  Sized_relobj<32, false>* object,
 			  unsigned int data_shndx,
@@ -190,8 +187,7 @@ class Target_i386 : public Target_freebsd<32, false>
   struct Scan
   {
     inline void
-    local(const General_options& options, Symbol_table* symtab,
-	  Layout* layout, Target_i386* target,
+    local(Symbol_table* symtab, Layout* layout, Target_i386* target,
 	  Sized_relobj<32, false>* object,
 	  unsigned int data_shndx,
 	  Output_section* output_section,
@@ -199,8 +195,7 @@ class Target_i386 : public Target_freebsd<32, false>
 	  const elfcpp::Sym<32, false>& lsym);
 
     inline void
-    global(const General_options& options, Symbol_table* symtab,
-	   Layout* layout, Target_i386* target,
+    global(Symbol_table* symtab, Layout* layout, Target_i386* target,
 	   Sized_relobj<32, false>* object,
 	   unsigned int data_shndx,
 	   Output_section* output_section,
@@ -446,7 +441,9 @@ const Target::Target_info Target_i386::i386_info =
   elfcpp::SHN_UNDEF,	// small_common_shndx
   elfcpp::SHN_UNDEF,	// large_common_shndx
   0,			// small_common_section_flags
-  0			// large_common_section_flags
+  0,			// large_common_section_flags
+  NULL,			// attributes_section
+  NULL			// attributes_vendor
 };
 
 // Get the GOT section, creating it if necessary.
@@ -464,25 +461,25 @@ Target_i386::got_section(Symbol_table* symtab, Layout* layout)
       os = layout->add_output_section_data(".got", elfcpp::SHT_PROGBITS,
 					   (elfcpp::SHF_ALLOC
 					    | elfcpp::SHF_WRITE),
-					   this->got_);
-      os->set_is_relro();
+					   this->got_, false, true, true,
+					   false);
 
-      // The old GNU linker creates a .got.plt section.  We just
-      // create another set of data in the .got section.  Note that we
-      // always create a PLT if we create a GOT, although the PLT
-      // might be empty.
       this->got_plt_ = new Output_data_space(4, "** GOT PLT");
-      os = layout->add_output_section_data(".got", elfcpp::SHT_PROGBITS,
+      os = layout->add_output_section_data(".got.plt", elfcpp::SHT_PROGBITS,
 					   (elfcpp::SHF_ALLOC
 					    | elfcpp::SHF_WRITE),
-					   this->got_plt_);
-      os->set_is_relro();
+					   this->got_plt_, false, false, false,
+					   true);
 
       // The first three entries are reserved.
       this->got_plt_->set_current_data_size(3 * 4);
 
+      // Those bytes can go into the relro segment.
+      layout->increase_relro(3 * 4);
+
       // Define _GLOBAL_OFFSET_TABLE_ at the start of the PLT.
       symtab->define_in_output_data("_GLOBAL_OFFSET_TABLE_", NULL,
+				    Symbol_table::PREDEFINED,
 				    this->got_plt_,
 				    0, 0, elfcpp::STT_OBJECT,
 				    elfcpp::STB_LOCAL,
@@ -503,7 +500,8 @@ Target_i386::rel_dyn_section(Layout* layout)
       gold_assert(layout != NULL);
       this->rel_dyn_ = new Reloc_section(parameters->options().combreloc());
       layout->add_output_section_data(".rel.dyn", elfcpp::SHT_REL,
-				      elfcpp::SHF_ALLOC, this->rel_dyn_);
+				      elfcpp::SHF_ALLOC, this->rel_dyn_, true,
+				      false, false, false);
     }
   return this->rel_dyn_;
 }
@@ -578,7 +576,8 @@ Output_data_plt_i386::Output_data_plt_i386(Layout* layout,
 {
   this->rel_ = new Reloc_section(false);
   layout->add_output_section_data(".rel.plt", elfcpp::SHT_REL,
-				  elfcpp::SHF_ALLOC, this->rel_);
+				  elfcpp::SHF_ALLOC, this->rel_, true,
+				  false, false, false);
 }
 
 void
@@ -763,7 +762,7 @@ Target_i386::make_plt_entry(Symbol_table* symtab, Layout* layout, Symbol* gsym)
       layout->add_output_section_data(".plt", elfcpp::SHT_PROGBITS,
 				      (elfcpp::SHF_ALLOC
 				       | elfcpp::SHF_EXECINSTR),
-				      this->plt_);
+				      this->plt_, false, false, false, false);
     }
 
   this->plt_->add_entry(gsym);
@@ -782,6 +781,7 @@ Target_i386::define_tls_base_symbol(Symbol_table* symtab, Layout* layout)
     {
       bool is_exec = parameters->options().output_is_executable();
       symtab->define_in_output_segment("_TLS_MODULE_BASE_", NULL,
+				       Symbol_table::PREDEFINED,
 				       tls_segment, 0, 0,
 				       elfcpp::STT_TLS,
 				       elfcpp::STB_LOCAL,
@@ -884,8 +884,7 @@ Target_i386::Scan::unsupported_reloc_local(Sized_relobj<32, false>* object,
 // Scan a relocation for a local symbol.
 
 inline void
-Target_i386::Scan::local(const General_options&,
-			 Symbol_table* symtab,
+Target_i386::Scan::local(Symbol_table* symtab,
 			 Layout* layout,
 			 Target_i386* target,
 			 Sized_relobj<32, false>* object,
@@ -1175,8 +1174,7 @@ Target_i386::Scan::unsupported_reloc_global(Sized_relobj<32, false>* object,
 // Scan a relocation for a global symbol.
 
 inline void
-Target_i386::Scan::global(const General_options&,
-			  Symbol_table* symtab,
+Target_i386::Scan::global(Symbol_table* symtab,
 			  Layout* layout,
 			  Target_i386* target,
 			  Sized_relobj<32, false>* object,
@@ -1492,8 +1490,7 @@ Target_i386::Scan::global(const General_options&,
 // Process relocations for gc.
 
 void
-Target_i386::gc_process_relocs(const General_options& options,
-                               Symbol_table* symtab,
+Target_i386::gc_process_relocs(Symbol_table* symtab,
                                Layout* layout,
                                Sized_relobj<32, false>* object,
                                unsigned int data_shndx,
@@ -1507,7 +1504,6 @@ Target_i386::gc_process_relocs(const General_options& options,
 {
   gold::gc_process_relocs<32, false, Target_i386, elfcpp::SHT_REL,
 		          Target_i386::Scan>(
-    options,
     symtab,
     layout,
     this,
@@ -1524,8 +1520,7 @@ Target_i386::gc_process_relocs(const General_options& options,
 // Scan relocations for a section.
 
 void
-Target_i386::scan_relocs(const General_options& options,
-			 Symbol_table* symtab,
+Target_i386::scan_relocs(Symbol_table* symtab,
 			 Layout* layout,
 			 Sized_relobj<32, false>* object,
 			 unsigned int data_shndx,
@@ -1546,7 +1541,6 @@ Target_i386::scan_relocs(const General_options& options,
 
   gold::scan_relocs<32, false, Target_i386, elfcpp::SHT_REL,
 		    Target_i386::Scan>(
-    options,
     symtab,
     layout,
     this,
@@ -1563,7 +1557,10 @@ Target_i386::scan_relocs(const General_options& options,
 // Finalize the sections.
 
 void
-Target_i386::do_finalize_sections(Layout* layout)
+Target_i386::do_finalize_sections(
+    Layout* layout,
+    const Input_objects*,
+    Symbol_table*)
 {
   // Fill in some more dynamic tags.
   Output_data_dynamic* const odyn = layout->dynamic_data();
@@ -2537,8 +2534,7 @@ Target_i386::Relocatable_size_for_reloc::get_size_for_reloc(
 // Scan the relocs during a relocatable link.
 
 void
-Target_i386::scan_relocatable_relocs(const General_options& options,
-				     Symbol_table* symtab,
+Target_i386::scan_relocatable_relocs(Symbol_table* symtab,
 				     Layout* layout,
 				     Sized_relobj<32, false>* object,
 				     unsigned int data_shndx,
@@ -2558,7 +2554,6 @@ Target_i386::scan_relocatable_relocs(const General_options& options,
 
   gold::scan_relocatable_relocs<32, false, elfcpp::SHT_REL,
       Scan_relocatable_relocs>(
-    options,
     symtab,
     layout,
     object,
diff --git a/gold/icf.h b/gold/icf.h
index b87b992..954469b 100644
--- a/gold/icf.h
+++ b/gold/icf.h
@@ -27,6 +27,7 @@
 
 #include "elfcpp.h"
 #include "symtab.h"
+#include "object.h"
 
 namespace gold
 {
@@ -35,17 +36,9 @@ class Object;
 class Input_objects;
 class Symbol_table;
 
-typedef std::pair<Object*, unsigned int> Section_id;
-
 class Icf
 {
  public:
-  struct Section_id_hash
-  {
-    size_t operator()(const Section_id& loc) const
-    { return reinterpret_cast<uintptr_t>(loc.first) ^ loc.second; }
-  };
-
   typedef std::vector<Section_id> Sections_reachable_list;
   typedef std::vector<Symbol*> Symbol_info;
   typedef std::vector<std::pair<long long, long long> > Addend_info;
diff --git a/gold/int_encoding.cc b/gold/int_encoding.cc
new file mode 100644
index 0000000..ef58749
--- /dev/null
+++ b/gold/int_encoding.cc
@@ -0,0 +1,131 @@
+// varint.cc -- variable length and unaligned integer encoding support.
+
+// Copyright 2009 Free Software Foundation, Inc.
+// Written by Doug Kwan <dougkwan@google.com> by refactoring scattered
+// contents from other files in gold.  Original code written by Ian
+// Lance Taylor <iant@google.com> and Caleb Howe <cshowe@google.com>.
+
+// This file is part of gold.
+
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+// MA 02110-1301, USA.
+
+#include "gold.h"
+
+#include <vector>
+
+#include "int_encoding.h"
+
+namespace gold {
+
+// Read an unsigned LEB128 number.  Each byte contains 7 bits of
+// information, plus one bit saying whether the number continues or
+// not.
+
+uint64_t
+read_unsigned_LEB_128(const unsigned char* buffer, size_t* len)
+{
+  uint64_t result = 0;
+  size_t num_read = 0;
+  unsigned int shift = 0;
+  unsigned char byte;
+
+  do
+    {
+      if (num_read >= 64 / 7) 
+        {
+          gold_warning(_("Unusually large LEB128 decoded, "
+			 "debug information may be corrupted"));
+          break;
+        }
+      byte = *buffer++;
+      num_read++;
+      result |= (static_cast<uint64_t>(byte & 0x7f)) << shift;
+      shift += 7;
+    }
+  while (byte & 0x80);
+
+  *len = num_read;
+
+  return result;
+}
+
+// Read a signed LEB128 number.  These are like regular LEB128
+// numbers, except the last byte may have a sign bit set.
+
+int64_t
+read_signed_LEB_128(const unsigned char* buffer, size_t* len)
+{
+  int64_t result = 0;
+  int shift = 0;
+  size_t num_read = 0;
+  unsigned char byte;
+
+  do
+    {
+      if (num_read >= 64 / 7) 
+        {
+          gold_warning(_("Unusually large LEB128 decoded, "
+			 "debug information may be corrupted"));
+          break;
+        }
+      byte = *buffer++;
+      num_read++;
+      result |= (static_cast<uint64_t>(byte & 0x7f) << shift);
+      shift += 7;
+    }
+  while (byte & 0x80);
+
+  if ((shift < 8 * static_cast<int>(sizeof(result))) && (byte & 0x40))
+    result |= -((static_cast<int64_t>(1)) << shift);
+  *len = num_read;
+  return result;
+}
+
+void
+write_unsigned_LEB_128(std::vector<unsigned char>* buffer, uint64_t value)
+{
+  do
+    {
+      unsigned char current_byte = value & 0x7f;
+      value >>= 7;
+      if (value != 0)
+        {
+          current_byte |= 0x80;
+        }
+      buffer->push_back(current_byte);
+    }
+  while (value != 0);
+}
+
+size_t
+get_length_as_unsigned_LEB_128(uint64_t value)
+{
+  size_t length = 0;
+  do
+    {
+      unsigned char current_byte = value & 0x7f;
+      value >>= 7;
+      if (value != 0)
+        {
+          current_byte |= 0x80;
+        }
+      length++;
+    }
+  while (value != 0);
+  return length;
+}
+
+} // End namespace gold.
diff --git a/gold/int_encoding.h b/gold/int_encoding.h
new file mode 100644
index 0000000..b60e969
--- /dev/null
+++ b/gold/int_encoding.h
@@ -0,0 +1,112 @@
+// int_encoding.h -- variable length and unaligned integers -*- C++ -*-
+
+// Copyright 2009 Free Software Foundation, Inc.
+// Written by Doug Kwan <dougkwan@google.com> by refactoring scattered
+// contents from other files in gold.  Original code written by Ian
+// Lance Taylor <iant@google.com> and Caleb Howe  <cshowe@google.com>.
+
+// This file is part of gold.
+
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+// MA 02110-1301, USA.
+
+#ifndef GOLD_INT_ENCODING_H
+#define GOLD_INT_ENCODING_H
+
+#include <vector>
+#include "elfcpp.h"
+#include "target.h"
+#include "parameters.h"
+
+namespace gold
+{
+
+//
+// LEB 128 encoding support.
+//
+
+// Read a ULEB 128 encoded integer from BUFFER.  Return the length of the
+// encoded integer at the location PLEN. 
+
+uint64_t
+read_unsigned_LEB_128(const unsigned char* buffer, size_t* plen);
+
+// Read an SLEB 128 encoded integer from BUFFER.  Return the length of the
+// encoded integer at the location PLEN. 
+
+int64_t
+read_signed_LEB_128(const unsigned char* buffer, size_t* plen);
+
+// Write a ULEB 128 encoded VALUE to BUFFER.
+
+void
+write_unsigned_LEB_128(std::vector<unsigned char>* buffer, uint64_t value);
+
+// Return the ULEB 128 encoded size of VALUE.
+
+size_t
+get_length_as_unsigned_LEB_128(uint64_t value);
+
+//
+// Unaligned integer encoding support.
+//
+
+// Insert VALSIZE-bit integer VALUE into DESTINATION.
+
+template <int valsize>
+void insert_into_vector(std::vector<unsigned char>* destination,
+                        typename elfcpp::Valtype_base<valsize>::Valtype value)
+{
+  unsigned char buffer[valsize / 8];
+  if (parameters->target().is_big_endian())
+    elfcpp::Swap_unaligned<valsize, true>::writeval(buffer, value);
+  else
+    elfcpp::Swap_unaligned<valsize, false>::writeval(buffer, value);
+  destination->insert(destination->end(), buffer, buffer + valsize / 8);
+}
+
+// Read a possibly unaligned integer of SIZE.  Update SOURCE after read.
+
+template <int valsize>
+typename elfcpp::Valtype_base<valsize>::Valtype
+read_from_pointer(unsigned char** source)
+{
+  typename elfcpp::Valtype_base<valsize>::Valtype return_value;
+  if (parameters->target().is_big_endian())
+    return_value = elfcpp::Swap_unaligned<valsize, true>::readval(*source);
+  else
+    return_value = elfcpp::Swap_unaligned<valsize, false>::readval(*source);
+  *source += valsize / 8;
+  return return_value;
+}
+
+// Same as the above except for use with const unsigned char data.
+
+template <int valsize>
+typename elfcpp::Valtype_base<valsize>::Valtype
+read_from_pointer(const unsigned char** source)
+{
+  typename elfcpp::Valtype_base<valsize>::Valtype return_value;
+  if (parameters->target().is_big_endian())
+    return_value = elfcpp::Swap_unaligned<valsize, true>::readval(*source);
+  else
+    return_value = elfcpp::Swap_unaligned<valsize, false>::readval(*source);
+  *source += valsize / 8;
+  return return_value;
+}
+
+} // End namespace gold.
+
+#endif // !defined(GOLD_INT_ENCODING_H)
diff --git a/gold/layout.cc b/gold/layout.cc
index 028703a..46a6a34 100644
--- a/gold/layout.cc
+++ b/gold/layout.cc
@@ -175,6 +175,7 @@ Layout::Layout(int number_of_input_files, Script_options* script_options)
     section_headers_(NULL),
     tls_segment_(NULL),
     relro_segment_(NULL),
+    increase_relro_(0),
     symtab_section_(NULL),
     symtab_xindex_(NULL),
     dynsym_section_(NULL),
@@ -388,11 +389,18 @@ Layout::find_output_segment(elfcpp::PT type, elfcpp::Elf_Word set,
 
 // Return the output section to use for section NAME with type TYPE
 // and section flags FLAGS.  NAME must be canonicalized in the string
-// pool, and NAME_KEY is the key.
+// pool, and NAME_KEY is the key.  IS_INTERP is true if this is the
+// .interp section.  IS_DYNAMIC_LINKER_SECTION is true if this section
+// is used by the dynamic linker.  IS_RELRO is true for a relro
+// section.  IS_LAST_RELRO is true for the last relro section.
+// IS_FIRST_NON_RELRO is true for the first non-relro section.
 
 Output_section*
 Layout::get_output_section(const char* name, Stringpool::Key name_key,
-			   elfcpp::Elf_Word type, elfcpp::Elf_Xword flags)
+			   elfcpp::Elf_Word type, elfcpp::Elf_Xword flags,
+			   bool is_interp, bool is_dynamic_linker_section,
+			   bool is_relro, bool is_last_relro,
+			   bool is_first_non_relro)
 {
   elfcpp::Elf_Xword lookup_flags = flags;
 
@@ -441,7 +449,9 @@ Layout::get_output_section(const char* name, Stringpool::Key name_key,
 	}
 
       if (os == NULL)
-	os = this->make_output_section(name, type, flags);
+	os = this->make_output_section(name, type, flags, is_interp,
+				       is_dynamic_linker_section, is_relro,
+				       is_last_relro, is_first_non_relro);
       ins.first->second = os;
       return os;
     }
@@ -451,13 +461,19 @@ Layout::get_output_section(const char* name, Stringpool::Key name_key,
 // RELOBJ, with type TYPE and flags FLAGS.  RELOBJ may be NULL for a
 // linker created section.  IS_INPUT_SECTION is true if we are
 // choosing an output section for an input section found in a input
-// file.  This will return NULL if the input section should be
-// discarded.
+// file.  IS_INTERP is true if this is the .interp section.
+// IS_DYNAMIC_LINKER_SECTION is true if this section is used by the
+// dynamic linker.  IS_RELRO is true for a relro section.
+// IS_LAST_RELRO is true for the last relro section.
+// IS_FIRST_NON_RELRO is true for the first non-relro section.  This
+// will return NULL if the input section should be discarded.
 
 Output_section*
 Layout::choose_output_section(const Relobj* relobj, const char* name,
 			      elfcpp::Elf_Word type, elfcpp::Elf_Xword flags,
-			      bool is_input_section)
+			      bool is_input_section, bool is_interp,
+			      bool is_dynamic_linker_section, bool is_relro,
+			      bool is_last_relro, bool is_first_non_relro)
 {
   // We should not see any input sections after we have attached
   // sections to segments.
@@ -479,13 +495,27 @@ Layout::choose_output_section(const Relobj* relobj, const char* name,
       Script_sections* ss = this->script_options_->script_sections();
       const char* file_name = relobj == NULL ? NULL : relobj->name().c_str();
       Output_section** output_section_slot;
-      name = ss->output_section_name(file_name, name, &output_section_slot);
+      Script_sections::Section_type script_section_type;
+      name = ss->output_section_name(file_name, name, &output_section_slot,
+				     &script_section_type);
       if (name == NULL)
 	{
 	  // The SECTIONS clause says to discard this input section.
 	  return NULL;
 	}
 
+      // We can only handle script section types ST_NONE and ST_NOLOAD.
+      switch (script_section_type)
+	{
+	case Script_sections::ST_NONE:
+	  break;
+	case Script_sections::ST_NOLOAD:
+	  flags &= elfcpp::SHF_ALLOC;
+	  break;
+	default:
+	  gold_unreachable();
+	}
+
       // If this is an orphan section--one not mentioned in the linker
       // script--then OUTPUT_SECTION_SLOT will be NULL, and we do the
       // default processing below.
@@ -505,8 +535,30 @@ Layout::choose_output_section(const Relobj* relobj, const char* name,
 
 	  name = this->namepool_.add(name, false, NULL);
 
-	  Output_section* os = this->make_output_section(name, type, flags);
+	  Output_section* os =
+	    this->make_output_section(name, type, flags, is_interp,
+				      is_dynamic_linker_section, is_relro,
+				      is_last_relro, is_first_non_relro);
 	  os->set_found_in_sections_clause();
+
+	  // Special handling for NOLOAD sections.
+	  if (script_section_type == Script_sections::ST_NOLOAD)
+	    {
+	      os->set_is_noload();
+
+	      // The constructor of Output_section sets addresses of non-ALLOC
+	      // sections to 0 by default.  We don't want that for NOLOAD
+	      // sections even if they have no SHF_ALLOC flag.
+	      if ((os->flags() & elfcpp::SHF_ALLOC) == 0
+		  && os->is_address_valid())
+		{
+		  gold_assert(os->address() == 0
+			      && !os->is_offset_valid()
+			      && !os->is_data_size_valid());
+		  os->reset_address_and_file_offset();
+		}
+	    }
+
 	  *output_section_slot = os;
 	  return os;
 	}
@@ -528,7 +580,9 @@ Layout::choose_output_section(const Relobj* relobj, const char* name,
 
   // Find or make the output section.  The output section is selected
   // based on the section name, type, and flags.
-  return this->get_output_section(name, name_key, type, flags);
+  return this->get_output_section(name, name_key, type, flags, is_interp,
+				  is_dynamic_linker_section, is_relro,
+				  is_last_relro, is_first_non_relro);
 }
 
 // Return the output section to use for input section SHNDX, with name
@@ -561,12 +615,14 @@ Layout::layout(Sized_relobj<size, big_endian>* object, unsigned int shndx,
     {
       name = this->namepool_.add(name, true, NULL);
       os = this->make_output_section(name, shdr.get_sh_type(),
-				     shdr.get_sh_flags());
+				     shdr.get_sh_flags(), false, false,
+				     false, false, false);
     }
   else
     {
       os = this->choose_output_section(object, name, shdr.get_sh_type(),
-				       shdr.get_sh_flags(), true);
+				       shdr.get_sh_flags(), true, false,
+				       false, false, false, false);
       if (os == NULL)
 	return NULL;
     }
@@ -617,7 +673,8 @@ Layout::layout_reloc(Sized_relobj<size, big_endian>* object,
   Output_section* os = this->choose_output_section(object, name.c_str(),
 						   sh_type,
 						   shdr.get_sh_flags(),
-						   false);
+						   false, false, false,
+						   false, false, false);
 
   os->set_should_link_to_symtab();
   os->set_info_section(data_section);
@@ -664,7 +721,9 @@ Layout::layout_group(Symbol_table* symtab,
   group_section_name = this->namepool_.add(group_section_name, true, NULL);
   Output_section* os = this->make_output_section(group_section_name,
 						 elfcpp::SHT_GROUP,
-						 shdr.get_sh_flags());
+						 shdr.get_sh_flags(),
+						 false, false, false,
+						 false, false);
 
   // We need to find a symbol with the signature in the symbol table.
   // If we don't find one now, we need to look again later.
@@ -718,7 +777,8 @@ Layout::layout_eh_frame(Sized_relobj<size, big_endian>* object,
 						   name,
 						   elfcpp::SHT_PROGBITS,
 						   elfcpp::SHF_ALLOC,
-						   false);
+						   false, false, false,
+						   false, false, false);
   if (os == NULL)
     return NULL;
 
@@ -734,7 +794,8 @@ Layout::layout_eh_frame(Sized_relobj<size, big_endian>* object,
 					".eh_frame_hdr",
 					elfcpp::SHT_PROGBITS,
 					elfcpp::SHF_ALLOC,
-					false);
+					false, false, false,
+					false, false, false);
 
 	  if (hdr_os != NULL)
 	    {
@@ -749,7 +810,7 @@ Layout::layout_eh_frame(Sized_relobj<size, big_endian>* object,
 		  Output_segment* hdr_oseg;
 		  hdr_oseg = this->make_output_segment(elfcpp::PT_GNU_EH_FRAME,
 						       elfcpp::PF_R);
-		  hdr_oseg->add_output_section(hdr_os, elfcpp::PF_R);
+		  hdr_oseg->add_output_section(hdr_os, elfcpp::PF_R, false);
 		}
 
 	      this->eh_frame_data_->set_eh_frame_hdr(hdr_posd);
@@ -800,10 +861,16 @@ Layout::layout_eh_frame(Sized_relobj<size, big_endian>* object,
 Output_section*
 Layout::add_output_section_data(const char* name, elfcpp::Elf_Word type,
 				elfcpp::Elf_Xword flags,
-				Output_section_data* posd)
+				Output_section_data* posd,
+				bool is_dynamic_linker_section,
+				bool is_relro, bool is_last_relro,
+				bool is_first_non_relro)
 {
   Output_section* os = this->choose_output_section(NULL, name, type, flags,
-						   false);
+						   false, false,
+						   is_dynamic_linker_section,
+						   is_relro, is_last_relro,
+						   is_first_non_relro);
   if (os != NULL)
     os->add_output_section_data(posd);
   return os;
@@ -838,11 +905,17 @@ is_compressible_debug_section(const char* secname)
 }
 
 // Make a new Output_section, and attach it to segments as
-// appropriate.
+// appropriate.  IS_INTERP is true if this is the .interp section.
+// IS_DYNAMIC_LINKER_SECTION is true if this section is used by the
+// dynamic linker.  IS_RELRO is true if this is a relro section.
+// IS_LAST_RELRO is true if this is the last relro section.
+// IS_FIRST_NON_RELRO is true if this is the first non relro section.
 
 Output_section*
 Layout::make_output_section(const char* name, elfcpp::Elf_Word type,
-			    elfcpp::Elf_Xword flags)
+			    elfcpp::Elf_Xword flags, bool is_interp,
+			    bool is_dynamic_linker_section, bool is_relro,
+			    bool is_last_relro, bool is_first_non_relro)
 {
   Output_section* os;
   if ((flags & elfcpp::SHF_ALLOC) == 0
@@ -850,7 +923,6 @@ Layout::make_output_section(const char* name, elfcpp::Elf_Word type,
       && is_compressible_debug_section(name))
     os = new Output_compressed_section(&parameters->options(), name, type,
 				       flags);
-
   else if ((flags & elfcpp::SHF_ALLOC) == 0
            && parameters->options().strip_debug_non_line()
            && strcmp(".debug_abbrev", name) == 0)
@@ -876,6 +948,17 @@ Layout::make_output_section(const char* name, elfcpp::Elf_Word type,
       os = target->make_output_section(name, type, flags);
     }
 
+  if (is_interp)
+    os->set_is_interp();
+  if (is_dynamic_linker_section)
+    os->set_is_dynamic_linker_section();
+  if (is_relro)
+    os->set_is_relro();
+  if (is_last_relro)
+    os->set_is_last_relro();
+  if (is_first_non_relro)
+    os->set_is_first_non_relro();
+
   parameters->target().new_output_section(os);
 
   this->section_list_.push_back(os);
@@ -971,6 +1054,10 @@ Layout::attach_allocated_section_to_segment(Output_section* os)
 
   elfcpp::Elf_Word seg_flags = Layout::section_flags_to_segment(flags);
 
+  // Check for --section-start.
+  uint64_t addr;
+  bool is_address_set = parameters->options().section_start(os->name(), &addr);
+
   // In general the only thing we really care about for PT_LOAD
   // segments is whether or not they are writable, so that is how we
   // search for them.  Large data sections also go into their own
@@ -998,7 +1085,18 @@ Layout::attach_allocated_section_to_segment(Output_section* os)
       if (os->is_large_data_section() && !(*p)->is_large_data_segment())
 	continue;
 
-      (*p)->add_output_section(os, seg_flags);
+      if (is_address_set)
+	{
+	  if ((*p)->are_addresses_set())
+	    continue;
+
+	  (*p)->add_initial_output_data(os);
+	  (*p)->update_flags_for_output_section(seg_flags);
+	  (*p)->set_addresses(addr, addr);
+	  break;
+	}
+
+      (*p)->add_output_section(os, seg_flags, true);
       break;
     }
 
@@ -1008,7 +1106,9 @@ Layout::attach_allocated_section_to_segment(Output_section* os)
                                                        seg_flags);
       if (os->is_large_data_section())
 	oseg->set_is_large_data_segment();
-      oseg->add_output_section(os, seg_flags);
+      oseg->add_output_section(os, seg_flags, true);
+      if (is_address_set)
+	oseg->set_addresses(addr, addr);
     }
 
   // If we see a loadable SHT_NOTE section, we create a PT_NOTE
@@ -1024,7 +1124,7 @@ Layout::attach_allocated_section_to_segment(Output_section* os)
               && (((*p)->flags() & elfcpp::PF_W)
                   == (seg_flags & elfcpp::PF_W)))
             {
-              (*p)->add_output_section(os, seg_flags);
+              (*p)->add_output_section(os, seg_flags, false);
               break;
             }
         }
@@ -1033,7 +1133,7 @@ Layout::attach_allocated_section_to_segment(Output_section* os)
         {
           Output_segment* oseg = this->make_output_segment(elfcpp::PT_NOTE,
                                                            seg_flags);
-          oseg->add_output_section(os, seg_flags);
+          oseg->add_output_section(os, seg_flags, false);
         }
     }
 
@@ -1043,7 +1143,7 @@ Layout::attach_allocated_section_to_segment(Output_section* os)
     {
       if (this->tls_segment_ == NULL)
 	this->make_output_segment(elfcpp::PT_TLS, seg_flags);
-      this->tls_segment_->add_output_section(os, seg_flags);
+      this->tls_segment_->add_output_section(os, seg_flags, false);
     }
 
   // If -z relro is in effect, and we see a relro section, we create a
@@ -1053,19 +1153,27 @@ Layout::attach_allocated_section_to_segment(Output_section* os)
       gold_assert(seg_flags == (elfcpp::PF_R | elfcpp::PF_W));
       if (this->relro_segment_ == NULL)
 	this->make_output_segment(elfcpp::PT_GNU_RELRO, seg_flags);
-      this->relro_segment_->add_output_section(os, seg_flags);
+      this->relro_segment_->add_output_section(os, seg_flags, false);
     }
 }
 
 // Make an output section for a script.
 
 Output_section*
-Layout::make_output_section_for_script(const char* name)
+Layout::make_output_section_for_script(
+    const char* name,
+    Script_sections::Section_type section_type)
 {
   name = this->namepool_.add(name, false, NULL);
+  elfcpp::Elf_Xword sh_flags = elfcpp::SHF_ALLOC;
+  if (section_type == Script_sections::ST_NOLOAD)
+    sh_flags = 0;
   Output_section* os = this->make_output_section(name, elfcpp::SHT_PROGBITS,
-						 elfcpp::SHF_ALLOC);
+						 sh_flags, false,
+						 false, false, false, false);
   os->set_found_in_sections_clause();
+  if (section_type == Script_sections::ST_NOLOAD)
+    os->set_is_noload();
   return os;
 }
 
@@ -1134,10 +1242,11 @@ Layout::create_initial_dynamic_sections(Symbol_table* symtab)
 						       elfcpp::SHT_DYNAMIC,
 						       (elfcpp::SHF_ALLOC
 							| elfcpp::SHF_WRITE),
-						       false);
-  this->dynamic_section_->set_is_relro();
+						       false, false, true,
+						       true, false, false);
 
-  symtab->define_in_output_data("_DYNAMIC", NULL, this->dynamic_section_, 0, 0,
+  symtab->define_in_output_data("_DYNAMIC", NULL, Symbol_table::PREDEFINED,
+				this->dynamic_section_, 0, 0,
 				elfcpp::STT_OBJECT, elfcpp::STB_LOCAL,
 				elfcpp::STV_HIDDEN, 0, false, false);
 
@@ -1158,19 +1267,17 @@ Layout::define_section_symbols(Symbol_table* symtab)
        ++p)
     {
       const char* const name = (*p)->name();
-      if (name[strspn(name,
-		      ("0123456789"
-		       "ABCDEFGHIJKLMNOPWRSTUVWXYZ"
-		       "abcdefghijklmnopqrstuvwxyz"
-		       "_"))]
-	  == '\0')
+      if (is_cident(name))
 	{
 	  const std::string name_string(name);
-	  const std::string start_name("__start_" + name_string);
-	  const std::string stop_name("__stop_" + name_string);
+	  const std::string start_name(cident_section_start_prefix
+                                       + name_string);
+	  const std::string stop_name(cident_section_stop_prefix
+                                      + name_string);
 
 	  symtab->define_in_output_data(start_name.c_str(),
 					NULL, // version
+					Symbol_table::PREDEFINED,
 					*p,
 					0, // value
 					0, // symsize
@@ -1183,6 +1290,7 @@ Layout::define_section_symbols(Symbol_table* symtab)
 
 	  symtab->define_in_output_data(stop_name.c_str(),
 					NULL, // version
+					Symbol_table::PREDEFINED,
 					*p,
 					0, // value
 					0, // symsize
@@ -1323,8 +1431,15 @@ Layout::clean_up_after_relaxation()
        p != this->section_list_.end();
        ++p)
     {
-      (*p)->reset_address_and_file_offset();
       (*p)->restore_states();
+
+      // If an input section changes size because of relaxation,
+      // we need to adjust the section offsets of all input sections.
+      // after such a section.
+      if ((*p)->section_offsets_need_adjustment())
+	(*p)->adjust_section_offsets();
+
+      (*p)->reset_address_and_file_offset();
     }
   
   // Reset special output object address and file offsets.
@@ -1425,6 +1540,14 @@ Layout::relaxation_loop_body(
 	      || load_seg != NULL
 	      || this->script_options_->saw_sections_clause());
 
+  // If the address of the load segment we found has been set by
+  // --section-start rather than by a script, then we don't want to
+  // use it for the file and segment headers.
+  if (load_seg != NULL
+      && load_seg->are_addresses_set()
+      && !this->script_options_->saw_sections_clause())
+    load_seg = NULL;
+
   // Lay out the segment headers.
   if (!parameters->options().relocatable())
     {
@@ -1509,7 +1632,7 @@ off_t
 Layout::finalize(const Input_objects* input_objects, Symbol_table* symtab,
 		 Target* target, const Task* task)
 {
-  target->finalize_sections(this);
+  target->finalize_sections(this, input_objects, symtab);
 
   this->count_local_symbols(task, input_objects);
 
@@ -1732,7 +1855,8 @@ Layout::create_note(const char* name, int note_type,
     flags = elfcpp::SHF_ALLOC;
   Output_section* os = this->choose_output_section(NULL, section_name,
 						   elfcpp::SHT_NOTE,
-						   flags, false);
+						   flags, false, false,
+						   false, false, false, false);
   if (os == NULL)
     return NULL;
 
@@ -1811,7 +1935,8 @@ Layout::create_executable_stack_info()
       elfcpp::Elf_Xword flags = 0;
       if (is_stack_executable)
 	flags |= elfcpp::SHF_EXECINSTR;
-      this->make_output_section(name, elfcpp::SHT_PROGBITS, flags);
+      this->make_output_section(name, elfcpp::SHT_PROGBITS, flags, false,
+				false, false, false, false);
     }
   else
     {
@@ -1971,7 +2096,8 @@ Layout::create_incremental_info_sections()
     this->namepool_.add(".gnu_incremental_inputs", false, NULL);
   Output_section* inputs_os =
     this->make_output_section(incremental_inputs_name,
-			      elfcpp::SHT_GNU_INCREMENTAL_INPUTS, 0);
+			      elfcpp::SHT_GNU_INCREMENTAL_INPUTS, 0,
+			      false, false, false, false, false);
   Output_section_data* posd =
       this->incremental_inputs_->create_incremental_inputs_section_data();
   inputs_os->add_output_section_data(posd);
@@ -1981,7 +2107,8 @@ Layout::create_incremental_info_sections()
     this->namepool_.add(".gnu_incremental_strtab", false, NULL);
   Output_section* strtab_os = this->make_output_section(incremental_strtab_name,
                                                         elfcpp::SHT_STRTAB,
-                                                        0);
+                                                        0, false, false,
+							false, false, false);
   Output_data_strtab* strtab_data =
     new Output_data_strtab(this->incremental_inputs_->get_stringpool());
   strtab_os->add_output_section_data(strtab_data);
@@ -2167,6 +2294,10 @@ Layout::set_segment_offsets(const Target* target, Output_segment* load_seg,
 	}
     }
 
+  unsigned int increase_relro = this->increase_relro_;
+  if (this->script_options_->saw_sections_clause())
+    increase_relro = 0;
+
   const bool check_sections = parameters->options().check_sections();
   Output_segment* last_load_segment = NULL;
 
@@ -2255,6 +2386,7 @@ Layout::set_segment_offsets(const Target* target, Output_segment* load_seg,
 
 	  unsigned int shndx_hold = *pshndx;
 	  uint64_t new_addr = (*p)->set_section_addresses(this, false, addr,
+							  increase_relro,
                                                           &off, pshndx);
 
 	  // Now that we know the size of this segment, we may be able
@@ -2281,6 +2413,7 @@ Layout::set_segment_offsets(const Target* target, Output_segment* load_seg,
 		  off = orig_off + ((addr - orig_addr) & (abi_pagesize - 1));
 		  off = align_file_offset(off, addr, abi_pagesize);
 		  new_addr = (*p)->set_section_addresses(this, true, addr,
+							 increase_relro,
                                                          &off, pshndx);
 		}
 	    }
@@ -2318,7 +2451,9 @@ Layout::set_segment_offsets(const Target* target, Output_segment* load_seg,
        ++p)
     {
       if ((*p)->type() != elfcpp::PT_LOAD)
-	(*p)->set_offset();
+	(*p)->set_offset((*p)->type() == elfcpp::PT_GNU_RELRO
+			 ? increase_relro
+			 : 0);
     }
 
   // Set the TLS offsets for each section in the PT_TLS segment.
@@ -2593,7 +2728,8 @@ Layout::create_symtab_sections(const Input_objects* input_objects,
       const char* symtab_name = this->namepool_.add(".symtab", false, NULL);
       Output_section* osymtab = this->make_output_section(symtab_name,
 							  elfcpp::SHT_SYMTAB,
-							  0);
+							  0, false, false,
+							  false, false, false);
       this->symtab_section_ = osymtab;
 
       Output_section_data* pos = new Output_data_fixed_space(off - startoff,
@@ -2614,7 +2750,8 @@ Layout::create_symtab_sections(const Input_objects* input_objects,
 							       false, NULL);
 	  Output_section* osymtab_xindex =
 	    this->make_output_section(symtab_xindex_name,
-				      elfcpp::SHT_SYMTAB_SHNDX, 0);
+				      elfcpp::SHT_SYMTAB_SHNDX, 0, false,
+				      false, false, false, false);
 
 	  size_t symcount = (off - startoff) / symsize;
 	  this->symtab_xindex_ = new Output_symtab_xindex(symcount);
@@ -2636,7 +2773,8 @@ Layout::create_symtab_sections(const Input_objects* input_objects,
       const char* strtab_name = this->namepool_.add(".strtab", false, NULL);
       Output_section* ostrtab = this->make_output_section(strtab_name,
 							  elfcpp::SHT_STRTAB,
-							  0);
+							  0, false, false,
+							  false, false, false);
 
       Output_section_data* pstr = new Output_data_strtab(&this->sympool_);
       ostrtab->add_output_section_data(pstr);
@@ -2663,7 +2801,9 @@ Layout::create_shstrtab()
 
   const char* name = this->namepool_.add(".shstrtab", false, NULL);
 
-  Output_section* os = this->make_output_section(name, elfcpp::SHT_STRTAB, 0);
+  Output_section* os = this->make_output_section(name, elfcpp::SHT_STRTAB, 0,
+						 false, false, false, false,
+						 false);
 
   // We can't write out this section until we've set all the section
   // names, and we don't set the names of compressed output sections
@@ -2776,7 +2916,8 @@ Layout::create_dynamic_symtab(const Input_objects* input_objects,
   Output_section* dynsym = this->choose_output_section(NULL, ".dynsym",
 						       elfcpp::SHT_DYNSYM,
 						       elfcpp::SHF_ALLOC,
-						       false);
+						       false, false, true,
+						       false, false, false);
 
   Output_section_data* odata = new Output_data_fixed_space(index * symsize,
 							   align,
@@ -2806,7 +2947,7 @@ Layout::create_dynamic_symtab(const Input_objects* input_objects,
 	this->choose_output_section(NULL, ".dynsym_shndx",
 				    elfcpp::SHT_SYMTAB_SHNDX,
 				    elfcpp::SHF_ALLOC,
-				    false);
+				    false, false, true, false, false, false);
 
       this->dynsym_xindex_ = new Output_symtab_xindex(index);
 
@@ -2829,7 +2970,8 @@ Layout::create_dynamic_symtab(const Input_objects* input_objects,
   Output_section* dynstr = this->choose_output_section(NULL, ".dynstr",
 						       elfcpp::SHT_STRTAB,
 						       elfcpp::SHF_ALLOC,
-						       false);
+						       false, false, true,
+						       false, false, false);
 
   Output_section_data* strdata = new Output_data_strtab(&this->dynpool_);
   dynstr->add_output_section_data(strdata);
@@ -2855,6 +2997,8 @@ Layout::create_dynamic_symtab(const Input_objects* input_objects,
       Output_section* hashsec = this->choose_output_section(NULL, ".hash",
 							    elfcpp::SHT_HASH,
 							    elfcpp::SHF_ALLOC,
+							    false, false, true,
+							    false, false,
 							    false);
 
       Output_section_data* hashdata = new Output_data_const_buffer(phash,
@@ -2880,6 +3024,8 @@ Layout::create_dynamic_symtab(const Input_objects* input_objects,
       Output_section* hashsec = this->choose_output_section(NULL, ".gnu.hash",
 							    elfcpp::SHT_GNU_HASH,
 							    elfcpp::SHF_ALLOC,
+							    false, false, true,
+							    false, false,
 							    false);
 
       Output_section_data* hashdata = new Output_data_const_buffer(phash,
@@ -2978,7 +3124,8 @@ Layout::sized_create_version_sections(
   Output_section* vsec = this->choose_output_section(NULL, ".gnu.version",
 						     elfcpp::SHT_GNU_versym,
 						     elfcpp::SHF_ALLOC,
-						     false);
+						     false, false, true,
+						     false, false, false);
 
   unsigned char* vbuf;
   unsigned int vsize;
@@ -3003,6 +3150,7 @@ Layout::sized_create_version_sections(
       vdsec= this->choose_output_section(NULL, ".gnu.version_d",
 					 elfcpp::SHT_GNU_verdef,
 					 elfcpp::SHF_ALLOC,
+					 false, false, true, false, false,
 					 false);
 
       unsigned char* vdbuf;
@@ -3028,6 +3176,7 @@ Layout::sized_create_version_sections(
       vnsec = this->choose_output_section(NULL, ".gnu.version_r",
 					  elfcpp::SHT_GNU_verneed,
 					  elfcpp::SHF_ALLOC,
+					  false, false, true, false, false,
 					  false);
 
       unsigned char* vnbuf;
@@ -3068,14 +3217,15 @@ Layout::create_interp(const Target* target)
   Output_section* osec = this->choose_output_section(NULL, ".interp",
 						     elfcpp::SHT_PROGBITS,
 						     elfcpp::SHF_ALLOC,
-						     false);
+						     false, true, true,
+						     false, false, false);
   osec->add_output_section_data(odata);
 
   if (!this->script_options_->saw_phdrs_clause())
     {
       Output_segment* oseg = this->make_output_segment(elfcpp::PT_INTERP,
 						       elfcpp::PF_R);
-      oseg->add_output_section(osec, elfcpp::PF_R);
+      oseg->add_output_section(osec, elfcpp::PF_R, false);
     }
 }
 
@@ -3091,7 +3241,8 @@ Layout::finish_dynamic_section(const Input_objects* input_objects,
 						       (elfcpp::PF_R
 							| elfcpp::PF_W));
       oseg->add_output_section(this->dynamic_section_,
-			       elfcpp::PF_R | elfcpp::PF_W);
+			       elfcpp::PF_R | elfcpp::PF_W,
+			       false);
     }
 
   Output_data_dynamic* const odyn = this->dynamic_data_;
@@ -3305,9 +3456,9 @@ const Layout::Section_name_mapping Layout::section_name_mapping[] =
   MAPPING_INIT(".gnu.linkonce.lr.", ".lrodata"),
   MAPPING_INIT(".gnu.linkonce.l.", ".ldata"),
   MAPPING_INIT(".gnu.linkonce.lb.", ".lbss"),
-  MAPPING_INIT(".ARM.extab.", ".ARM.extab"),
+  MAPPING_INIT(".ARM.extab", ".ARM.extab"),
   MAPPING_INIT(".gnu.linkonce.armextab.", ".ARM.extab"),
-  MAPPING_INIT(".ARM.exidx.", ".ARM.exidx"),
+  MAPPING_INIT(".ARM.exidx", ".ARM.exidx"),
   MAPPING_INIT(".gnu.linkonce.armexidx.", ".ARM.exidx"),
 };
 #undef MAPPING_INIT
diff --git a/gold/layout.h b/gold/layout.h
index 675c658..c509571 100644
--- a/gold/layout.h
+++ b/gold/layout.h
@@ -360,11 +360,23 @@ class Layout
   layout_gnu_stack(bool seen_gnu_stack, uint64_t gnu_stack_flags);
 
   // Add an Output_section_data to the layout.  This is used for
-  // special sections like the GOT section.
+  // special sections like the GOT section.  IS_DYNAMIC_LINKER_SECTION
+  // is true for sections which are used by the dynamic linker, such
+  // as dynamic reloc sections.  IS_RELRO is true for relro sections.
+  // IS_LAST_RELRO is true for the last relro section.
+  // IS_FIRST_NON_RELRO is true for the first section after the relro
+  // sections.
   Output_section*
   add_output_section_data(const char* name, elfcpp::Elf_Word type,
 			  elfcpp::Elf_Xword flags,
-			  Output_section_data*);
+			  Output_section_data*, bool is_dynamic_linker_section,
+			  bool is_relro, bool is_last_relro,
+			  bool is_first_non_relro);
+
+  // Increase the size of the relro segment by this much.
+  void
+  increase_relro(unsigned int s)
+  { this->increase_relro_ += s; }
 
   // Create dynamic sections if necessary.
   void
@@ -574,7 +586,8 @@ class Layout
 
   // Make a section for a linker script to hold data.
   Output_section*
-  make_output_section_for_script(const char* name);
+  make_output_section_for_script(const char* name,
+				 Script_sections::Section_type section_type);
 
   // Make a segment.  This is used by the linker script code.
   Output_segment*
@@ -745,18 +758,25 @@ class Layout
   // Return the output section for NAME, TYPE and FLAGS.
   Output_section*
   get_output_section(const char* name, Stringpool::Key name_key,
-		     elfcpp::Elf_Word type, elfcpp::Elf_Xword flags);
+		     elfcpp::Elf_Word type, elfcpp::Elf_Xword flags,
+		     bool is_interp, bool is_dynamic_linker_section,
+		     bool is_relro, bool is_last_relro,
+		     bool is_first_non_relro);
 
   // Choose the output section for NAME in RELOBJ.
   Output_section*
   choose_output_section(const Relobj* relobj, const char* name,
 			elfcpp::Elf_Word type, elfcpp::Elf_Xword flags,
-			bool is_input_section);
+			bool is_input_section, bool is_interp,
+			bool is_dynamic_linker_section, bool is_relro,
+			bool is_last_relro, bool is_first_non_relro);
 
   // Create a new Output_section.
   Output_section*
   make_output_section(const char* name, elfcpp::Elf_Word type,
-		      elfcpp::Elf_Xword flags);
+		      elfcpp::Elf_Xword flags, bool is_interp,
+		      bool is_dynamic_linker_section, bool is_relro,
+		      bool is_last_relro, bool is_first_non_relro);
 
   // Attach a section to a segment.
   void
@@ -932,6 +952,9 @@ class Layout
   Output_segment* tls_segment_;
   // A pointer to the PT_GNU_RELRO segment if there is one.
   Output_segment* relro_segment_;
+  // A backend may increase the size of the PT_GNU_RELRO segment if
+  // there is one.  This is the amount to increase it by.
+  unsigned int increase_relro_;
   // The SHT_SYMTAB output section.
   Output_section* symtab_section_;
   // The SHT_SYMTAB_SHNDX for the regular symbol table if there is one.
diff --git a/gold/object.cc b/gold/object.cc
index e9826b0..66e08a7 100644
--- a/gold/object.cc
+++ b/gold/object.cc
@@ -1138,6 +1138,12 @@ Sized_relobj<size, big_endian>::do_layout(Symbol_table* symtab,
 		omit[i] = true;
 	    }
 
+	  // Skip attributes section.
+	  if (parameters->target().is_attributes_section(name))
+	    {
+	      omit[i] = true;
+	    }
+
           bool discard = omit[i];
           if (!discard)
             {
@@ -1174,6 +1180,14 @@ Sized_relobj<size, big_endian>::do_layout(Symbol_table* symtab,
             {
               symtab->gc()->worklist().push(Section_id(this, i)); 
             }
+          // If the section name XXX can be represented as a C identifier
+          // it cannot be discarded if there are references to
+          // __start_XXX and __stop_XXX symbols.  These need to be
+          // specially handled.
+          if (is_cident(name))
+            {
+              symtab->gc()->add_cident_section(name, Section_id(this, i));
+            }
         }
 
       // When doing a relocatable link we are going to copy input
@@ -1677,7 +1691,15 @@ Sized_relobj<size, big_endian>::do_finalize_local_symbols(unsigned int index,
               os = folded_obj->output_section(folded.second);
               gold_assert(os != NULL);
               secoffset = folded_obj->get_output_section_offset(folded.second);
-              gold_assert(secoffset != invalid_address);
+
+	      // This could be a relaxed input section.
+              if (secoffset == invalid_address)
+		{
+		  const Output_relaxed_input_section* relaxed_section =
+		    os->find_relaxed_input_section(folded_obj, folded.second);
+		  gold_assert(relaxed_section != NULL);
+		  secoffset = relaxed_section->address() - os->address();
+		}
             }
 
 	  if (os == NULL)
@@ -1711,12 +1733,18 @@ Sized_relobj<size, big_endian>::do_finalize_local_symbols(unsigned int index,
 		}
 	      else if (!os->find_starting_output_address(this, shndx, &start))
 		{
-		  // This is a section symbol, but apparently not one
-		  // in a merged section.  Just use the start of the
-		  // output section.  This happens with relocatable
-		  // links when the input object has section symbols
-		  // for arbitrary non-merge sections.
-		  lv.set_output_value(os->address());
+		  // This is a section symbol, but apparently not one in a
+		  // merged section.  First check to see if this is a relaxed
+		  // input section.  If so, use its address.  Otherwise just
+		  // use the start of the output section.  This happens with
+		  // relocatable links when the input object has section
+		  // symbols for arbitrary non-merge sections.
+		  const Output_section_data* posd =
+		    os->find_relaxed_input_section(this, shndx);
+		  if (posd != NULL)
+		    lv.set_output_value(posd->address());
+		  else
+		    lv.set_output_value(os->address());
 		}
 	      else
 		{
diff --git a/gold/object.h b/gold/object.h
index ff96682..d0b6a98 100644
--- a/gold/object.h
+++ b/gold/object.h
@@ -659,15 +659,13 @@ class Relobj : public Object
 
   // Process the relocs, during garbage collection only.
   void
-  gc_process_relocs(const General_options& options, Symbol_table* symtab,
-	            Layout* layout, Read_relocs_data* rd)
-  { return this->do_gc_process_relocs(options, symtab, layout, rd); }
+  gc_process_relocs(Symbol_table* symtab, Layout* layout, Read_relocs_data* rd)
+  { return this->do_gc_process_relocs(symtab, layout, rd); }
 
   // Scan the relocs and adjust the symbol table.
   void
-  scan_relocs(const General_options& options, Symbol_table* symtab,
-	      Layout* layout, Read_relocs_data* rd)
-  { return this->do_scan_relocs(options, symtab, layout, rd); }
+  scan_relocs(Symbol_table* symtab, Layout* layout, Read_relocs_data* rd)
+  { return this->do_scan_relocs(symtab, layout, rd); }
 
   // The number of local symbols in the input symbol table.
   virtual unsigned int
@@ -701,9 +699,8 @@ class Relobj : public Object
 
   // Relocate the input sections and write out the local symbols.
   void
-  relocate(const General_options& options, const Symbol_table* symtab,
-	   const Layout* layout, Output_file* of)
-  { return this->do_relocate(options, symtab, layout, of); }
+  relocate(const Symbol_table* symtab, const Layout* layout, Output_file* of)
+  { return this->do_relocate(symtab, layout, of); }
 
   // Return whether an input section is being included in the link.
   bool
@@ -723,6 +720,16 @@ class Relobj : public Object
     return this->output_sections_[shndx];
   }
 
+  // The the output section of the input section with index SHNDX.
+  // This is only used currently to remove a section from the link in
+  // relaxation.
+  void
+  set_output_section(unsigned int shndx, Output_section* os)
+  {
+    gold_assert(shndx < this->output_sections_.size());
+    this->output_sections_[shndx] = os;
+  }
+  
   // Given a section index, return the offset in the Output_section.
   // The return value will be -1U if the section is specially mapped,
   // such as a merge section.
@@ -790,13 +797,11 @@ class Relobj : public Object
 
   // Process the relocs--implemented by child class.
   virtual void
-  do_gc_process_relocs(const General_options&, Symbol_table*, Layout*,
-		 Read_relocs_data*) = 0;
+  do_gc_process_relocs(Symbol_table*, Layout*, Read_relocs_data*) = 0;
 
   // Scan the relocs--implemented by child class.
   virtual void
-  do_scan_relocs(const General_options&, Symbol_table*, Layout*,
-		 Read_relocs_data*) = 0;
+  do_scan_relocs(Symbol_table*, Layout*, Read_relocs_data*) = 0;
 
   // Return the number of local symbols--implemented by child class.
   virtual unsigned int
@@ -824,8 +829,7 @@ class Relobj : public Object
   // Relocate the input sections and write out the local
   // symbols--implemented by child class.
   virtual void
-  do_relocate(const General_options& options, const Symbol_table* symtab,
-	      const Layout*, Output_file* of) = 0;
+  do_relocate(const Symbol_table* symtab, const Layout*, Output_file* of) = 0;
 
   // Get the offset of a section--implemented by child class.
   virtual uint64_t
@@ -1463,11 +1467,6 @@ class Sized_relobj : public Relobj
   Address
   map_to_kept_section(unsigned int shndx, bool* found) const;
 
-  // Make section offset invalid.  This is needed for relaxation.
-  void
-  invalidate_section_offset(unsigned int shndx)
-  { this->do_invalidate_section_offset(shndx); }
-
  protected:
   // Set up.
   virtual void
@@ -1502,13 +1501,11 @@ class Sized_relobj : public Relobj
   // Process the relocs to find list of referenced sections. Used only
   // during garbage collection.
   void
-  do_gc_process_relocs(const General_options&, Symbol_table*, Layout*,
-		       Read_relocs_data*);
+  do_gc_process_relocs(Symbol_table*, Layout*, Read_relocs_data*);
 
   // Scan the relocs and adjust the symbol table.
   void
-  do_scan_relocs(const General_options&, Symbol_table*, Layout*,
-		 Read_relocs_data*);
+  do_scan_relocs(Symbol_table*, Layout*, Read_relocs_data*);
 
   // Count the local symbols.
   void
@@ -1529,8 +1526,7 @@ class Sized_relobj : public Relobj
 
   // Relocate the input sections and write out the local symbols.
   void
-  do_relocate(const General_options& options, const Symbol_table* symtab,
-	      const Layout*, Output_file* of);
+  do_relocate(const Symbol_table* symtab, const Layout*, Output_file* of);
 
   // Get the size of a section.
   uint64_t
@@ -1603,15 +1599,10 @@ class Sized_relobj : public Relobj
   do_set_section_offset(unsigned int shndx, uint64_t off)
   {
     gold_assert(shndx < this->section_offsets_.size());
-    this->section_offsets_[shndx] = convert_types<Address, uint64_t>(off);
-  }
-
-  // Set the offset of a section to invalid_address.
-  virtual void
-  do_invalidate_section_offset(unsigned int shndx)
-  {
-    gold_assert(shndx < this->section_offsets_.size());
-    this->section_offsets_[shndx] = invalid_address;
+    this->section_offsets_[shndx] =
+      (off == static_cast<uint64_t>(-1)
+       ? invalid_address
+       : convert_types<Address, uint64_t>(off));
   }
 
   // Adjust a section index if necessary.
@@ -1648,6 +1639,29 @@ class Sized_relobj : public Relobj
   local_values()
   { return &this->local_values_; }
 
+  // Views and sizes when relocating.
+  struct View_size
+  {
+    unsigned char* view;
+    typename elfcpp::Elf_types<size>::Elf_Addr address;
+    off_t offset;
+    section_size_type view_size;
+    bool is_input_output_view;
+    bool is_postprocessing_view;
+  };
+
+  typedef std::vector<View_size> Views;
+
+  // This may be overriden by a child class.
+  virtual void
+  do_relocate_sections(const Symbol_table* symtab, const Layout* layout,
+		       const unsigned char* pshdrs, Views* pviews);
+
+  // Allow a child to set output local symbol count.
+  void
+  set_output_local_symbol_count(unsigned int value)
+  { this->output_local_symbol_count_ = value; }
+   
  private:
   // For convenience.
   typedef Sized_relobj<size, big_endian> This;
@@ -1702,19 +1716,6 @@ class Sized_relobj : public Relobj
                  typename This::Shdr& shdr, unsigned int reloc_shndx,
                  unsigned int reloc_type);
 
-  // Views and sizes when relocating.
-  struct View_size
-  {
-    unsigned char* view;
-    typename elfcpp::Elf_types<size>::Elf_Addr address;
-    off_t offset;
-    section_size_type view_size;
-    bool is_input_output_view;
-    bool is_postprocessing_view;
-  };
-
-  typedef std::vector<View_size> Views;
-
   // Write section data to the output file.  Record the views and
   // sizes in VIEWS for use when relocating.
   void
@@ -1722,20 +1723,20 @@ class Sized_relobj : public Relobj
 
   // Relocate the sections in the output file.
   void
-  relocate_sections(const General_options& options, const Symbol_table*,
-		    const Layout*, const unsigned char* pshdrs, Views*);
+  relocate_sections(const Symbol_table* symtab, const Layout* layout,
+		    const unsigned char* pshdrs, Views* pviews)
+  { this->do_relocate_sections(symtab, layout, pshdrs, pviews); }
 
   // Scan the input relocations for --emit-relocs.
   void
-  emit_relocs_scan(const General_options&, Symbol_table*, Layout*,
-		   const unsigned char* plocal_syms,
+  emit_relocs_scan(Symbol_table*, Layout*, const unsigned char* plocal_syms,
 		   const Read_relocs_data::Relocs_list::iterator&);
 
   // Scan the input relocations for --emit-relocs, templatized on the
   // type of the relocation section.
   template<int sh_type>
   void
-  emit_relocs_scan_reltype(const General_options&, Symbol_table*, Layout*,
+  emit_relocs_scan_reltype(Symbol_table*, Layout*,
 			   const unsigned char* plocal_syms,
 			   const Read_relocs_data::Relocs_list::iterator&,
 			   Relocatable_relocs*);
@@ -1997,8 +1998,6 @@ class Input_objects
 template<int size, bool big_endian>
 struct Relocate_info
 {
-  // Command line options.
-  const General_options* options;
   // Symbol table.
   const Symbol_table* symtab;
   // Layout.
@@ -2020,6 +2019,31 @@ struct Relocate_info
   location(size_t relnum, off_t reloffset) const;
 };
 
+// This is used to represent a section in an object and is used as the
+// key type for various section maps.
+typedef std::pair<Object*, unsigned int> Section_id;
+
+// This is similar to Section_id but is used when the section
+// pointers are const.
+typedef std::pair<const Object*, unsigned int> Const_section_id;
+
+// The hash value is based on the address of an object in memory during
+// linking.  It is okay to use this for looking up sections but never use
+// this in an unordered container that we want to traverse in a repeatable
+// manner.
+
+struct Section_id_hash
+{
+  size_t operator()(const Section_id& loc) const
+  { return reinterpret_cast<uintptr_t>(loc.first) ^ loc.second; }
+};
+
+struct Const_section_id_hash
+{
+  size_t operator()(const Const_section_id& loc) const
+  { return reinterpret_cast<uintptr_t>(loc.first) ^ loc.second; }
+};
+
 // Return whether INPUT_FILE contains an ELF object start at file
 // offset OFFSET.  This sets *START to point to a view of the start of
 // the file.  It sets *READ_SIZE to the number of bytes in the view.
diff --git a/gold/options.cc b/gold/options.cc
index 299a748..defc921 100644
--- a/gold/options.cc
+++ b/gold/options.cc
@@ -395,6 +395,63 @@ General_options::parse_just_symbols(const char*, const char* arg,
   cmdline->inputs().add_file(file);
 }
 
+// Handle --section-start.
+
+void
+General_options::parse_section_start(const char*, const char* arg,
+				     Command_line*)
+{
+  const char* eq = strchr(arg, '=');
+  if (eq == NULL)
+    {
+      gold_error(_("invalid argument to --section-start; "
+		   "must be SECTION=ADDRESS"));
+      return;
+    }
+
+  std::string section_name(arg, eq - arg);
+
+  ++eq;
+  const char* val_start = eq;
+  if (eq[0] == '0' && (eq[1] == 'x' || eq[1] == 'X'))
+    eq += 2;
+  if (*eq == '\0')
+    {
+      gold_error(_("--section-start address missing"));
+      return;
+    }
+  uint64_t addr = 0;
+  hex_init();
+  for (; *eq != '\0'; ++eq)
+    {
+      if (!hex_p(*eq))
+	{
+	  gold_error(_("--section-start argument %s is not a valid hex number"),
+		     val_start);
+	  return;
+	}
+      addr <<= 4;
+      addr += hex_value(*eq);
+    }
+
+  this->section_starts_[section_name] = addr;
+}
+
+// Look up a --section-start value.
+
+bool
+General_options::section_start(const char* secname, uint64_t* paddr) const
+{
+  if (this->section_starts_.empty())
+    return false;
+  std::map<std::string, uint64_t>::const_iterator p =
+    this->section_starts_.find(secname);
+  if (p == this->section_starts_.end())
+    return false;
+  *paddr = p->second;
+  return true;
+}
+
 void
 General_options::parse_static(const char*, const char*, Command_line*)
 {
@@ -526,6 +583,20 @@ General_options::string_to_object_format(const char* arg)
     }
 }
 
+void
+General_options::parse_fix_v4bx(const char*, const char*,
+                                Command_line*)
+{
+  this->fix_v4bx_ = FIX_V4BX_REPLACE;
+}
+
+void
+General_options::parse_fix_v4bx_interworking(const char*, const char*,
+					     Command_line*)
+{
+  this->fix_v4bx_ = FIX_V4BX_INTERWORKING;
+}
+
 } // End namespace gold.
 
 namespace
@@ -746,9 +817,17 @@ namespace gold
 
 General_options::General_options()
   : printed_version_(false),
-    execstack_status_(General_options::EXECSTACK_FROM_INPUT), static_(false),
-    do_demangle_(false), plugins_(),
-    incremental_disposition_(INCREMENTAL_CHECK), implicit_incremental_(false)
+    execstack_status_(EXECSTACK_FROM_INPUT),
+    icf_status_(ICF_NONE),
+    static_(false),
+    do_demangle_(false),
+    plugins_(NULL),
+    dynamic_list_(),
+    incremental_disposition_(INCREMENTAL_CHECK),
+    implicit_incremental_(false),
+    excluded_libs_(),
+    symbols_to_retain_(),
+    section_starts_()
 {
   // Turn off option registration once construction is complete.
   gold::options::ready_to_register = false;
@@ -964,7 +1043,7 @@ General_options::finalize()
 	}
       while (next_pos != std::string::npos);
     }
-  else
+  else if (!this->nostdlib())
     {
       // Even if they don't specify it, we add -L /lib and -L /usr/lib.
       // FIXME: We should only do this when configured in native mode.
diff --git a/gold/options.h b/gold/options.h
index cbb45b5..95979e5 100644
--- a/gold/options.h
+++ b/gold/options.h
@@ -39,6 +39,7 @@
 #include <cstdlib>
 #include <cstring>
 #include <list>
+#include <map>
 #include <string>
 #include <vector>
 
@@ -308,7 +309,10 @@ struct Struct_special : public Struct_var
     void                                                                 \
     parse_to_value(const char*, const char*,                             \
                    Command_line*, General_options* options)              \
-    { options->set_##varname__(false); }                                 \
+    {                                                                    \
+      options->set_##varname__(false);                                   \
+      options->set_user_set_##varname__();                               \
+    }                                                                    \
                                                                          \
     options::One_option option;                                          \
   };                                                                     \
@@ -588,6 +592,10 @@ class General_options
               N_("Only set DT_NEEDED for dynamic libs if used"),
               N_("Always DT_NEEDED for dynamic libs"));
 
+  DEFINE_enum(assert, options::ONE_DASH, '\0', NULL,
+	      N_("Ignored"), N_("[ignored]"),
+	      {"definitions", "nodefinitions", "nosymbolic", "pure-text"});
+
   // This should really be an "enum", but it's too easy for folks to
   // forget to update the list as they add new targets.  So we just
   // accept any string.  We'll fail later (when the string is parsed),
@@ -690,9 +698,28 @@ class General_options
   DEFINE_string(fini, options::ONE_DASH, '\0', "_fini",
                 N_("Call SYMBOL at unload-time"), N_("SYMBOL"));
 
+  DEFINE_bool(fix_cortex_a8, options::TWO_DASHES, '\0', false,
+	      N_("(ARM only) Fix binaries for Cortex-A8 erratum."),
+	      N_("(ARM only) Do not fix binaries for Cortex-A8 erratum."));
+
+  DEFINE_special(fix_v4bx, options::TWO_DASHES, '\0',
+                 N_("(ARM only) Rewrite BX rn as MOV pc, rn for ARMv4"),
+                 NULL);
+
+  DEFINE_special(fix_v4bx_interworking, options::TWO_DASHES, '\0',
+                 N_("(ARM only) Rewrite BX rn branch to ARMv4 interworking "
+                    "veneer"),
+                 NULL);
+
+  DEFINE_bool(g, options::EXACTLY_ONE_DASH, '\0', false,
+	      N_("Ignored"), NULL);
+
   DEFINE_string(soname, options::ONE_DASH, 'h', NULL,
                 N_("Set shared library name"), N_("FILENAME"));
 
+  DEFINE_bool(i, options::EXACTLY_ONE_DASH, '\0', false,
+	      N_("Ignored"), NULL);
+
   DEFINE_double(hash_bucket_empty_fraction, options::TWO_DASHES, '\0', 0.0,
 		N_("Min fraction of empty buckets in dynamic hash"),
 		N_("FRACTION"));
@@ -729,6 +756,10 @@ class General_options
   DEFINE_dirlist(library_path, options::TWO_DASHES, 'L',
                  N_("Add directory to search path"), N_("DIR"));
 
+  DEFINE_bool(nostdlib, options::ONE_DASH, '\0', false,
+              N_(" Only search directories specified on the command line."),
+              NULL);
+
   DEFINE_string(m, options::EXACTLY_ONE_DASH, 'm', "",
                 N_("Ignored for compatibility"), N_("EMULATION"));
 
@@ -811,6 +842,13 @@ class General_options
                  N_("Add DIR to link time shared library search path"),
                  N_("DIR"));
 
+  DEFINE_special(section_start, options::TWO_DASHES, '\0',
+		 N_("Set address of section"), N_("SECTION=ADDRESS"));
+
+  DEFINE_optional_string(sort_common, options::TWO_DASHES, '\0', NULL,
+			 N_("Sort common symbols by alignment"),
+			 N_("[={ascending,descending}]"));
+
   DEFINE_bool(strip_all, options::TWO_DASHES, 's', false,
               N_("Strip all symbols"), NULL);
   DEFINE_bool(strip_debug, options::TWO_DASHES, 'S', false,
@@ -833,7 +871,7 @@ class General_options
               N_("Use less memory and more disk I/O "
                  "(included only for compatibility with GNU ld)"), NULL);
 
-  DEFINE_bool(shared, options::ONE_DASH, '\0', false,
+  DEFINE_bool(shared, options::ONE_DASH, 'G', false,
               N_("Generate shared library"), NULL);
 
   DEFINE_bool(Bshareable, options::ONE_DASH, '\0', false,
@@ -912,6 +950,10 @@ class General_options
   DEFINE_special(version_script, options::TWO_DASHES, '\0',
                  N_("Read version script"), N_("FILE"));
 
+  DEFINE_bool(warn_common, options::TWO_DASHES, '\0', false,
+	      N_("Warn about duplicate common symbols"),
+	      N_("Do not warn about duplicate common symbols (default)"));
+
   DEFINE_bool(warn_search_mismatch, options::TWO_DASHES, '\0', true,
 	      N_("Warn when skipping an incompatible library"),
 	      N_("Don't warn when skipping an incompatible library"));
@@ -1115,6 +1157,26 @@ class General_options
   bool
   check_excluded_libs (const std::string &s) const;
 
+  // If an explicit start address was given for section SECNAME with
+  // the --section-start option, return true and set *PADDR to the
+  // address.  Otherwise return false.
+  bool
+  section_start(const char* secname, uint64_t* paddr) const;
+
+  enum Fix_v4bx
+  {
+    // Leave original instruction.
+    FIX_V4BX_NONE,
+    // Replace instruction.
+    FIX_V4BX_REPLACE,
+    // Generate an interworking veneer.
+    FIX_V4BX_INTERWORKING
+  };
+
+  Fix_v4bx
+  fix_v4bx() const
+  { return (this->fix_v4bx_); }
+
  private:
   // Don't copy this structure.
   General_options(const General_options&);
@@ -1202,6 +1264,10 @@ class General_options
   Unordered_set<std::string> excluded_libs_;
   // List of symbol-names to keep, via -retain-symbol-info.
   Unordered_set<std::string> symbols_to_retain_;
+  // Map from section name to address from --section-start.
+  std::map<std::string, uint64_t> section_starts_;
+  // Whether to process armv4 bx instruction relocation.
+  Fix_v4bx fix_v4bx_;
 };
 
 // The position-dependent options.  We use this to store the state of
diff --git a/gold/output.cc b/gold/output.cc
index e2d7585..73bb7e5 100644
--- a/gold/output.cc
+++ b/gold/output.cc
@@ -459,10 +459,7 @@ Output_file_header::do_sized_write(Output_file* of)
     oehdr.put_e_phoff(this->segment_header_->offset());
 
   oehdr.put_e_shoff(this->section_header_->offset());
-
-  // FIXME: The target needs to set the flags.
-  oehdr.put_e_flags(0);
-
+  oehdr.put_e_flags(this->target_->processor_specific_flags());
   oehdr.put_e_ehsize(elfcpp::Elf_sizes<size>::ehdr_size);
 
   if (this->segment_header_ == NULL)
@@ -1798,15 +1795,22 @@ Output_section::Output_section(const char* name, elfcpp::Elf_Word type,
     attached_input_sections_are_sorted_(false),
     is_relro_(false),
     is_relro_local_(false),
+    is_last_relro_(false),
+    is_first_non_relro_(false),
     is_small_section_(false),
     is_large_section_(false),
+    is_interp_(false),
+    is_dynamic_linker_section_(false),
+    generate_code_fills_at_write_(false),
+    is_entsize_zero_(false),
+    section_offsets_need_adjustment_(false),
+    is_noload_(false),
     tls_offset_(0),
     checkpoint_(NULL),
     merge_section_map_(),
     merge_section_by_properties_map_(),
     relaxed_input_section_map_(),
-    is_relaxed_input_section_map_valid_(true),
-    generate_code_fills_at_write_(false)
+    is_relaxed_input_section_map_valid_(true)
 {
   // An unallocated section has no address.  Forcing this means that
   // we don't need special treatment for symbols defined in debug
@@ -1825,10 +1829,15 @@ Output_section::~Output_section()
 void
 Output_section::set_entsize(uint64_t v)
 {
-  if (this->entsize_ == 0)
+  if (this->is_entsize_zero_)
+    ;
+  else if (this->entsize_ == 0)
     this->entsize_ = v;
-  else
-    gold_assert(this->entsize_ == v);
+  else if (this->entsize_ != v)
+    {
+      this->entsize_ = 0;
+      this->is_entsize_zero_ = 1;
+    }
 }
 
 // Add the input section SHNDX, with header SHDR, named SECNAME, in
@@ -1864,8 +1873,6 @@ Output_section::add_input_section(Sized_relobj<size, big_endian>* object,
     this->addralign_ = addralign;
 
   typename elfcpp::Elf_types<size>::Elf_WXword sh_flags = shdr.get_sh_flags();
-  this->update_flags_for_input_section(sh_flags);
-
   uint64_t entsize = shdr.get_sh_entsize();
 
   // .debug_str is a mergeable string section, but is not always so
@@ -1876,6 +1883,9 @@ Output_section::add_input_section(Sized_relobj<size, big_endian>* object,
       entsize = 1;
     }
 
+  this->update_flags_for_input_section(sh_flags);
+  this->set_entsize(entsize);
+
   // If this is a SHF_MERGE section, we pass all the input sections to
   // a Output_data_merge.  We don't try to handle relocations for such
   // a section.  We don't try to handle empty merge sections--they
@@ -1977,8 +1987,8 @@ Output_section::add_relaxed_input_section(Output_relaxed_input_section* poris)
   this->add_output_section_data(&inp);
   if (this->is_relaxed_input_section_map_valid_)
     {
-      Input_section_specifier iss(poris->relobj(), poris->shndx());
-      this->relaxed_input_section_map_[iss] = poris;
+      Const_section_id csid(poris->relobj(), poris->shndx());
+      this->relaxed_input_section_map_[csid] = poris;
     }
 
   // For a relaxed section, we use the current data size.  Linker scripts
@@ -2050,8 +2060,8 @@ Output_section::add_merge_input_section(Relobj* object, unsigned int shndx,
 		  && merge_section->addralign() == addralign);
 
       // Link input section to found merge section.
-      Input_section_specifier iss(object, shndx);
-      this->merge_section_map_[iss] = merge_section;
+      Const_section_id csid(object, shndx);
+      this->merge_section_map_[csid] = merge_section;
       return true;
     }
 
@@ -2086,8 +2096,8 @@ Output_section::add_merge_input_section(Relobj* object, unsigned int shndx,
   // Add input section to new merge section and link input section to new
   // merge section in map.
   pomb->add_input_section(object, shndx);
-  Input_section_specifier iss(object, shndx);
-  this->merge_section_map_[iss] = pomb;
+  Const_section_id csid(object, shndx);
+  this->merge_section_map_[csid] = pomb;
 
   return true;
 }
@@ -2106,15 +2116,15 @@ Output_section::build_relaxation_map(
       const Input_section& is(input_sections[i]);
       if (is.is_input_section() || is.is_relaxed_input_section())
 	{
-	  Input_section_specifier iss(is.relobj(), is.shndx());
-	  (*relaxation_map)[iss] = i;
+	  Section_id sid(is.relobj(), is.shndx());
+	  (*relaxation_map)[sid] = i;
 	}
     }
 }
 
 // Convert regular input sections in INPUT_SECTIONS into relaxed input
-// sections in RELAXED_SECTIONS.  MAP is a prebuilt map from input section
-// specifier to indices of INPUT_SECTIONS.
+// sections in RELAXED_SECTIONS.  MAP is a prebuilt map from section id
+// indices of INPUT_SECTIONS.
 
 void
 Output_section::convert_input_sections_in_list_to_relaxed_sections(
@@ -2125,8 +2135,8 @@ Output_section::convert_input_sections_in_list_to_relaxed_sections(
   for (size_t i = 0; i < relaxed_sections.size(); ++i)
     {
       Output_relaxed_input_section* poris = relaxed_sections[i];
-      Input_section_specifier iss(poris->relobj(), poris->shndx());
-      Relaxation_map::const_iterator p = map.find(iss);
+      Section_id sid(poris->relobj(), poris->shndx());
+      Relaxation_map::const_iterator p = map.find(sid);
       gold_assert(p != map.end());
       gold_assert((*input_sections)[p->second].is_input_section());
       (*input_sections)[p->second] = Input_section(poris);
@@ -2182,6 +2192,15 @@ Output_section::convert_input_sections_to_relaxed_sections(
 	    relaxed_sections,
 	    map,
 	    &this->input_sections_);
+
+  // Update fast look-up map.
+  if (this->is_relaxed_input_section_map_valid_)
+    for (size_t i = 0; i < relaxed_sections.size(); ++i)
+      {
+	Output_relaxed_input_section* poris = relaxed_sections[i];
+	Const_section_id csid(poris->relobj(), poris->shndx());
+	this->relaxed_input_section_map_[csid] = poris;
+      }
 }
 
 // Update the output section flags based on input section flags.
@@ -2200,6 +2219,22 @@ Output_section::update_flags_for_input_section(elfcpp::Elf_Xword flags)
 		   & (elfcpp::SHF_WRITE
 		      | elfcpp::SHF_ALLOC
 		      | elfcpp::SHF_EXECINSTR));
+
+  if ((flags & elfcpp::SHF_MERGE) == 0)
+    this->flags_ &=~ elfcpp::SHF_MERGE;
+  else
+    {
+      if (this->current_data_size_for_child() == 0)
+	this->flags_ |= elfcpp::SHF_MERGE;
+    }
+
+  if ((flags & elfcpp::SHF_STRINGS) == 0)
+    this->flags_ &=~ elfcpp::SHF_STRINGS;
+  else
+    {
+      if (this->current_data_size_for_child() == 0)
+	this->flags_ |= elfcpp::SHF_STRINGS;
+    }
 }
 
 // Find the merge section into which an input section with index SHNDX in
@@ -2209,9 +2244,9 @@ Output_section_data*
 Output_section::find_merge_section(const Relobj* object,
 				   unsigned int shndx) const
 {
-  Input_section_specifier iss(object, shndx);
+  Const_section_id csid(object, shndx);
   Output_section_data_by_input_section_map::const_iterator p =
-    this->merge_section_map_.find(iss);
+    this->merge_section_map_.find(csid);
   if (p != this->merge_section_map_.end())
     {
       Output_section_data* posd = p->second;
@@ -2225,7 +2260,7 @@ Output_section::find_merge_section(const Relobj* object,
 // Find an relaxed input section corresponding to an input section
 // in OBJECT with index SHNDX.
 
-const Output_section_data*
+const Output_relaxed_input_section*
 Output_section::find_relaxed_input_section(const Relobj* object,
 					   unsigned int shndx) const
 {
@@ -2240,16 +2275,16 @@ Output_section::find_relaxed_input_section(const Relobj* object,
 	   ++p)
 	if (p->is_relaxed_input_section())
 	  {
-	    Input_section_specifier iss(p->relobj(), p->shndx());
-	    this->relaxed_input_section_map_[iss] =
+	    Const_section_id csid(p->relobj(), p->shndx());
+	    this->relaxed_input_section_map_[csid] =
 	      p->relaxed_input_section();
 	  }
       this->is_relaxed_input_section_map_valid_ = true;
     }
 
-  Input_section_specifier iss(object, shndx);
-  Output_section_data_by_input_section_map::const_iterator p =
-    this->relaxed_input_section_map_.find(iss);
+  Const_section_id csid(object, shndx);
+  Output_relaxed_input_section_by_input_section_map::const_iterator p =
+    this->relaxed_input_section_map_.find(csid);
   if (p != this->relaxed_input_section_map_.end())
     return p->second;
   else
@@ -2450,8 +2485,9 @@ Output_section::do_reset_address_and_file_offset()
 {
   // An unallocated section has no address.  Forcing this means that
   // we don't need special treatment for symbols defined in debug
-  // sections.  We do the same in the constructor.
-  if ((this->flags_ & elfcpp::SHF_ALLOC) == 0)
+  // sections.  We do the same in the constructor.  This does not
+  // apply to NOLOAD sections though.
+  if (((this->flags_ & elfcpp::SHF_ALLOC) == 0) && !this->is_noload_)
      this->set_address(0);
 
   for (Input_section_list::iterator p = this->input_sections_.begin();
@@ -2923,12 +2959,12 @@ Output_section::get_input_sections(
   return data_size;
 }
 
-// Add an input section from a script.
+// Add an simple input section.
 
 void
-Output_section::add_input_section_for_script(const Simple_input_section& sis,
-					     off_t data_size,
-					     uint64_t addralign)
+Output_section::add_simple_input_section(const Simple_input_section& sis,
+					 off_t data_size,
+					 uint64_t addralign)
 {
   if (addralign > this->addralign_)
     this->addralign_ = addralign;
@@ -2947,7 +2983,7 @@ Output_section::add_input_section_for_script(const Simple_input_section& sis,
   this->input_sections_.push_back(is);
 }
 
-//
+// Save states for relaxation.
 
 void
 Output_section::save_states()
@@ -2963,6 +2999,19 @@ Output_section::save_states()
 }
 
 void
+Output_section::discard_states()
+{
+  gold_assert(this->checkpoint_ != NULL);
+  delete this->checkpoint_;
+  this->checkpoint_ = NULL;
+  gold_assert(this->fills_.empty());
+
+  // Simply invalidate the relaxed input section map since we do not keep
+  // track of it.
+  this->is_relaxed_input_section_map_valid_ = false;
+}
+
+void
 Output_section::restore_states()
 {
   gold_assert(this->checkpoint_ != NULL);
@@ -2996,6 +3045,29 @@ Output_section::restore_states()
   this->is_relaxed_input_section_map_valid_ = false;
 }
 
+// Update the section offsets of input sections in this.  This is required if
+// relaxation causes some input sections to change sizes.
+
+void
+Output_section::adjust_section_offsets()
+{
+  if (!this->section_offsets_need_adjustment_)
+    return;
+
+  off_t off = 0;
+  for (Input_section_list::iterator p = this->input_sections_.begin();
+       p != this->input_sections_.end();
+       ++p)
+    {
+      off = align_address(off, p->addralign());
+      if (p->is_input_section())
+	p->relobj()->set_section_offset(p->shndx(), off);
+      off += p->data_size();
+    }
+
+  this->section_offsets_need_adjustment_ = false;
+}
+
 // Print to the map file.
 
 void
@@ -3039,20 +3111,24 @@ Output_segment::Output_segment(elfcpp::Elf_Word type, elfcpp::Elf_Word flags)
     are_addresses_set_(false),
     is_large_data_segment_(false)
 {
+  // The ELF ABI specifies that a PT_TLS segment always has PF_R as
+  // the flags.
+  if (type == elfcpp::PT_TLS)
+    this->flags_ = elfcpp::PF_R;
 }
 
 // Add an Output_section to an Output_segment.
 
 void
 Output_segment::add_output_section(Output_section* os,
-				   elfcpp::Elf_Word seg_flags)
+				   elfcpp::Elf_Word seg_flags,
+				   bool do_sort)
 {
   gold_assert((os->flags() & elfcpp::SHF_ALLOC) != 0);
   gold_assert(!this->is_max_align_known_);
   gold_assert(os->is_large_data_section() == this->is_large_data_segment());
 
-  // Update the segment flags.
-  this->flags_ |= seg_flags;
+  this->update_flags_for_output_section(seg_flags);
 
   Output_segment::Output_data_list* pdl;
   if (os->type() == elfcpp::SHT_NOBITS)
@@ -3060,6 +3136,10 @@ Output_segment::add_output_section(Output_section* os,
   else
     pdl = &this->output_data_;
 
+  // Note that while there may be many input sections in an output
+  // section, there are normally only a few output sections in an
+  // output segment.  The loops below are expected to be fast.
+
   // So that PT_NOTE segments will work correctly, we need to ensure
   // that all SHT_NOTE sections are adjacent.  This will normally
   // happen automatically, because all the SHT_NOTE input sections
@@ -3068,11 +3148,6 @@ Output_segment::add_output_section(Output_section* os,
   // flags, and thus be in different output sections, but for the
   // different section flags to map into the same segment flags and
   // thus the same output segment.
-
-  // Note that while there may be many input sections in an output
-  // section, there are normally only a few output sections in an
-  // output segment.  This loop is expected to be fast.
-
   if (os->type() == elfcpp::SHT_NOTE && !pdl->empty())
     {
       Output_segment::Output_data_list::iterator p = pdl->end();
@@ -3094,8 +3169,8 @@ Output_segment::add_output_section(Output_section* os,
   // case: we group the SHF_TLS/SHT_NOBITS sections right after the
   // SHF_TLS/SHT_PROGBITS sections.  This lets us set up PT_TLS
   // correctly.  SHF_TLS sections get added to both a PT_LOAD segment
-  // and the PT_TLS segment -- we do this grouping only for the
-  // PT_LOAD segment.
+  // and the PT_TLS segment; we do this grouping only for the PT_LOAD
+  // segment.
   if (this->type_ != elfcpp::PT_TLS
       && (os->flags() & elfcpp::SHF_TLS) != 0)
     {
@@ -3140,26 +3215,52 @@ Output_segment::add_output_section(Output_section* os,
       // location in the section list.
     }
 
-  // For the PT_GNU_RELRO segment, we need to group relro sections,
-  // and we need to put them before any non-relro sections.  Also,
-  // relro local sections go before relro non-local sections.
-  if (parameters->options().relro() && os->is_relro())
+  if (do_sort)
     {
-      gold_assert(pdl == &this->output_data_);
-      Output_segment::Output_data_list::iterator p;
-      for (p = pdl->begin(); p != pdl->end(); ++p)
+      // For the PT_GNU_RELRO segment, we need to group relro
+      // sections, and we need to put them before any non-relro
+      // sections.  Any relro local sections go before relro non-local
+      // sections.  One section may be marked as the last relro
+      // section.
+      if (os->is_relro())
 	{
-	  if (!(*p)->is_section())
-	    break;
+	  gold_assert(pdl == &this->output_data_);
+	  Output_segment::Output_data_list::iterator p;
+	  for (p = pdl->begin(); p != pdl->end(); ++p)
+	    {
+	      if (!(*p)->is_section())
+		break;
+
+	      Output_section* pos = (*p)->output_section();
+	      if (!pos->is_relro()
+		  || (os->is_relro_local() && !pos->is_relro_local())
+		  || (!os->is_last_relro() && pos->is_last_relro()))
+		break;
+	    }
 
-	  Output_section* pos = (*p)->output_section();
-	  if (!pos->is_relro()
-	      || (os->is_relro_local() && !pos->is_relro_local()))
-	    break;
+	  pdl->insert(p, os);
+	  return;
 	}
 
-      pdl->insert(p, os);
-      return;
+      // One section may be marked as the first section which follows
+      // the relro sections.
+      if (os->is_first_non_relro())
+	{
+	  gold_assert(pdl == &this->output_data_);
+	  Output_segment::Output_data_list::iterator p;
+	  for (p = pdl->begin(); p != pdl->end(); ++p)
+	    {
+	      if (!(*p)->is_section())
+		break;
+
+	      Output_section* pos = (*p)->output_section();
+	      if (!pos->is_relro())
+		break;
+	    }
+
+	  pdl->insert(p, os);
+	  return;
+	}
     }
 
   // Small data sections go at the end of the list of data sections.
@@ -3225,6 +3326,67 @@ Output_segment::add_output_section(Output_section* os,
       gold_unreachable();
     }
 
+  // We do some further output section sorting in order to make the
+  // generated program run more efficiently.  We should only do this
+  // when not using a linker script, so it is controled by the DO_SORT
+  // parameter.
+  if (do_sort)
+    {
+      // FreeBSD requires the .interp section to be in the first page
+      // of the executable.  That is a more efficient location anyhow
+      // for any OS, since it means that the kernel will have the data
+      // handy after it reads the program headers.
+      if (os->is_interp() && !pdl->empty())
+	{
+	  pdl->insert(pdl->begin(), os);
+	  return;
+	}
+
+      // Put loadable non-writable notes immediately after the .interp
+      // sections, so that the PT_NOTE segment is on the first page of
+      // the executable.
+      if (os->type() == elfcpp::SHT_NOTE
+	  && (os->flags() & elfcpp::SHF_WRITE) == 0
+	  && !pdl->empty())
+	{
+	  Output_segment::Output_data_list::iterator p = pdl->begin();
+	  if ((*p)->is_section() && (*p)->output_section()->is_interp())
+	    ++p;
+	  pdl->insert(p, os);
+	}
+
+      // If this section is used by the dynamic linker, and it is not
+      // writable, then put it first, after the .interp section and
+      // any loadable notes.  This makes it more likely that the
+      // dynamic linker will have to read less data from the disk.
+      if (os->is_dynamic_linker_section()
+	  && !pdl->empty()
+	  && (os->flags() & elfcpp::SHF_WRITE) == 0)
+	{
+	  bool is_reloc = (os->type() == elfcpp::SHT_REL
+			   || os->type() == elfcpp::SHT_RELA);
+	  Output_segment::Output_data_list::iterator p = pdl->begin();
+	  while (p != pdl->end()
+		 && (*p)->is_section()
+		 && ((*p)->output_section()->is_dynamic_linker_section()
+		     || (*p)->output_section()->type() == elfcpp::SHT_NOTE))
+	    {
+	      // Put reloc sections after the other ones.  Putting the
+	      // dynamic reloc sections first confuses BFD, notably
+	      // objcopy and strip.
+	      if (!is_reloc
+		  && ((*p)->output_section()->type() == elfcpp::SHT_REL
+		      || (*p)->output_section()->type() == elfcpp::SHT_RELA))
+		break;
+	      ++p;
+	    }
+	  pdl->insert(p, os);
+	  return;
+	}
+    }
+
+  // If there were no constraints on the output section, just add it
+  // to the end of the list.
   pdl->push_back(os);
 }
 
@@ -3249,8 +3411,8 @@ Output_segment::remove_output_section(Output_section* os)
   gold_unreachable();
 }
 
-// Add an Output_data (which is not an Output_section) to the start of
-// a segment.
+// Add an Output_data (which need not be an Output_section) to the
+// start of a segment.
 
 void
 Output_segment::add_initial_output_data(Output_data* od)
@@ -3286,19 +3448,6 @@ Output_segment::maximum_alignment()
       if (addralign > this->max_align_)
 	this->max_align_ = addralign;
 
-      // If -z relro is in effect, and the first section in this
-      // segment is a relro section, then the segment must be aligned
-      // to at least the common page size.  This ensures that the
-      // PT_GNU_RELRO segment will start at a page boundary.
-      if (this->type_ == elfcpp::PT_LOAD
-	  && parameters->options().relro()
-	  && this->is_first_section_relro())
-	{
-	  addralign = parameters->target().common_pagesize();
-	  if (addralign > this->max_align_)
-	    this->max_align_ = addralign;
-	}
-
       this->is_max_align_known_ = true;
     }
 
@@ -3352,11 +3501,57 @@ Output_segment::dynamic_reloc_count_list(const Output_data_list* pdl) const
 
 uint64_t
 Output_segment::set_section_addresses(const Layout* layout, bool reset,
-                                      uint64_t addr, off_t* poff,
+                                      uint64_t addr,
+				      unsigned int increase_relro,
+				      off_t* poff,
 				      unsigned int* pshndx)
 {
   gold_assert(this->type_ == elfcpp::PT_LOAD);
 
+  off_t orig_off = *poff;
+
+  // If we have relro sections, we need to pad forward now so that the
+  // relro sections plus INCREASE_RELRO end on a common page boundary.
+  if (parameters->options().relro()
+      && this->is_first_section_relro()
+      && (!this->are_addresses_set_ || reset))
+    {
+      uint64_t relro_size = 0;
+      off_t off = *poff;
+      for (Output_data_list::iterator p = this->output_data_.begin();
+	   p != this->output_data_.end();
+	   ++p)
+	{
+	  if (!(*p)->is_section())
+	    break;
+	  Output_section* pos = (*p)->output_section();
+	  if (!pos->is_relro())
+	    break;
+	  gold_assert(!(*p)->is_section_flag_set(elfcpp::SHF_TLS));
+	  if ((*p)->is_address_valid())
+	    relro_size += (*p)->data_size();
+	  else
+	    {
+	      // FIXME: This could be faster.
+	      (*p)->set_address_and_file_offset(addr + relro_size,
+						off + relro_size);
+	      relro_size += (*p)->data_size();
+	      (*p)->reset_address_and_file_offset();
+	    }
+	}
+      relro_size += increase_relro;
+
+      uint64_t page_align = parameters->target().common_pagesize();
+
+      // Align to offset N such that (N + RELRO_SIZE) % PAGE_ALIGN == 0.
+      uint64_t desired_align = page_align - (relro_size % page_align);
+      if (desired_align < *poff % page_align)
+	*poff += page_align - *poff % page_align;
+      *poff += desired_align - *poff % page_align;
+      addr += *poff - orig_off;
+      orig_off = *poff;
+    }
+
   if (!reset && this->are_addresses_set_)
     {
       gold_assert(this->paddr_ == addr);
@@ -3371,15 +3566,10 @@ Output_segment::set_section_addresses(const Layout* layout, bool reset,
 
   bool in_tls = false;
 
-  bool in_relro = (parameters->options().relro()
-		   && this->is_first_section_relro());
-
-  off_t orig_off = *poff;
   this->offset_ = orig_off;
 
   addr = this->set_section_list_addresses(layout, reset, &this->output_data_,
-					  addr, poff, pshndx, &in_tls,
-					  &in_relro);
+					  addr, poff, pshndx, &in_tls);
   this->filesz_ = *poff - orig_off;
 
   off_t off = *poff;
@@ -3387,7 +3577,7 @@ Output_segment::set_section_addresses(const Layout* layout, bool reset,
   uint64_t ret = this->set_section_list_addresses(layout, reset,
                                                   &this->output_bss_,
 						  addr, poff, pshndx,
-                                                  &in_tls, &in_relro);
+                                                  &in_tls);
 
   // If the last section was a TLS section, align upward to the
   // alignment of the TLS segment, so that the overall size of the TLS
@@ -3398,14 +3588,6 @@ Output_segment::set_section_addresses(const Layout* layout, bool reset,
       *poff = align_address(*poff, segment_align);
     }
 
-  // If all the sections were relro sections, align upward to the
-  // common page size.
-  if (in_relro)
-    {
-      uint64_t page_align = parameters->target().common_pagesize();
-      *poff = align_address(*poff, page_align);
-    }
-
   this->memsz_ = *poff - orig_off;
 
   // Ignore the file offset adjustments made by the BSS Output_data
@@ -3423,7 +3605,7 @@ Output_segment::set_section_list_addresses(const Layout* layout, bool reset,
                                            Output_data_list* pdl,
 					   uint64_t addr, off_t* poff,
 					   unsigned int* pshndx,
-                                           bool* in_tls, bool* in_relro)
+                                           bool* in_tls)
 {
   off_t startoff = *poff;
 
@@ -3474,19 +3656,6 @@ Output_segment::set_section_list_addresses(const Layout* layout, bool reset,
                 }
             }
 
-	  // If this is a non-relro section after a relro section,
-	  // align it to a common page boundary so that the dynamic
-	  // linker has a page to mark as read-only.
-	  if (*in_relro
-	      && (!(*p)->is_section()
-		  || !(*p)->output_section()->is_relro()))
-	    {
-	      uint64_t page_align = parameters->target().common_pagesize();
-	      if (page_align > align)
-		align = page_align;
-	      *in_relro = false;
-	    }
-
 	  off = align_address(off, align);
 	  (*p)->set_address_and_file_offset(addr + (off - startoff), off);
 	}
@@ -3503,15 +3672,20 @@ Output_segment::set_section_list_addresses(const Layout* layout, bool reset,
 	      else
 		{
 		  Output_section* os = (*p)->output_section();
+
+		  // Cast to unsigned long long to avoid format warnings.
+		  unsigned long long previous_dot =
+		    static_cast<unsigned long long>(addr + (off - startoff));
+		  unsigned long long dot =
+		    static_cast<unsigned long long>((*p)->address());
+
 		  if (os == NULL)
 		    gold_error(_("dot moves backward in linker script "
-				 "from 0x%llx to 0x%llx"),
-			       addr + (off - startoff), (*p)->address());
+				 "from 0x%llx to 0x%llx"), previous_dot, dot);
 		  else
 		    gold_error(_("address of section '%s' moves backward "
 				 "from 0x%llx to 0x%llx"),
-			       os->name(), addr + (off - startoff),
-			       (*p)->address());
+			       os->name(), previous_dot, dot);
 		}
 	    }
 	  (*p)->set_file_offset(off);
@@ -3537,10 +3711,10 @@ Output_segment::set_section_list_addresses(const Layout* layout, bool reset,
 }
 
 // For a non-PT_LOAD segment, set the offset from the sections, if
-// any.
+// any.  Add INCREASE to the file size and the memory size.
 
 void
-Output_segment::set_offset()
+Output_segment::set_offset(unsigned int increase)
 {
   gold_assert(this->type_ != elfcpp::PT_LOAD);
 
@@ -3548,6 +3722,7 @@ Output_segment::set_offset()
 
   if (this->output_data_.empty() && this->output_bss_.empty())
     {
+      gold_assert(increase == 0);
       this->vaddr_ = 0;
       this->paddr_ = 0;
       this->are_addresses_set_ = true;
@@ -3589,6 +3764,9 @@ Output_segment::set_offset()
 		  + last->data_size()
 		  - this->vaddr_);
 
+  this->filesz_ += increase;
+  this->memsz_ += increase;
+
   // If this is a TLS segment, align the memory size.  The code in
   // set_section_list ensures that the section after the TLS segment
   // is aligned to give us room.
@@ -3598,16 +3776,6 @@ Output_segment::set_offset()
       gold_assert(this->vaddr_ == align_address(this->vaddr_, segment_align));
       this->memsz_ = align_address(this->memsz_, segment_align);
     }
-
-  // If this is a RELRO segment, align the memory size.  The code in
-  // set_section_list ensures that the section after the RELRO segment
-  // is aligned to give us room.
-  if (this->type_ == elfcpp::PT_GNU_RELRO)
-    {
-      uint64_t page_align = parameters->target().common_pagesize();
-      gold_assert(this->vaddr_ == align_address(this->vaddr_, page_align));
-      this->memsz_ = align_address(this->memsz_, page_align);
-    }
 }
 
 // Set the TLS offsets of the sections in the PT_TLS segment.
diff --git a/gold/output.h b/gold/output.h
index bc10950..5b02375 100644
--- a/gold/output.h
+++ b/gold/output.h
@@ -47,71 +47,6 @@ class Sized_target;
 template<int size, bool big_endian>
 class Sized_relobj;
 
-// This class specifies an input section.  It is used as a key type
-// for maps.
-
-class Input_section_specifier
-{
- public:
-  Input_section_specifier(const Relobj* relobj, unsigned int shndx)
-    : relobj_(relobj), shndx_(shndx)
-  { }
-   
-  // Return Relobj of this.
-  const Relobj*
-  relobj() const
-  { return this->relobj_; }
-
-  // Return section index of this.
-  unsigned int
-  shndx() const
-  { return this->shndx_; }
-
-  // Whether this equals to another specifier ISS.
-  bool
-  eq(const Input_section_specifier& iss) const
-  { return this->relobj_ == iss.relobj_ && this->shndx_ == iss.shndx_; }
-
-  // Compute a hash value of this.
-  size_t
-  hash_value() const
-  { return this->string_hash(this->relobj_->name().c_str()) ^ this->shndx_; }
-
-  // Functors for containers.
-  struct equal_to
-  {
-    bool
-    operator()(const Input_section_specifier& iss1,
-	       const Input_section_specifier& iss2) const
-    { return iss1.eq(iss2); }
-  };
- 
-  struct hash
-  {
-    size_t
-    operator()(const Input_section_specifier& iss) const
-    { return iss.hash_value(); }
-  };
-
- private:
-  // For portability, we use our own string hash function instead of assuming
-  // __gnu_cxx::hash or std::tr1::hash is available.  This is the same hash
-  // function used in Stringpool_template::string_hash.
-  static size_t
-  string_hash(const char* s)
-  {
-    size_t h = 5381;
-    while (*s != '\0')
-      h = h * 33 + *s++;
-    return h;
-  }
-
-  // An object.
-  const Relobj* relobj_;
-  // A section index. 
-  unsigned int shndx_;
-};
-
 // An abtract class for data which has to go into the output file.
 
 class Output_data
@@ -2360,6 +2295,35 @@ class Output_section : public Output_data
   set_is_relro_local()
   { this->is_relro_local_ = true; }
 
+  // True if this must be the last relro section.
+  bool
+  is_last_relro() const
+  { return this->is_last_relro_; }
+
+  // Record that this must be the last relro section.
+  void
+  set_is_last_relro()
+  {
+    gold_assert(this->is_relro_);
+    this->is_last_relro_ = true;
+  }
+
+  // True if this must be the first section following the relro sections.
+  bool
+  is_first_non_relro() const
+  {
+    gold_assert(!this->is_relro_);
+    return this->is_first_non_relro_;
+  }
+
+  // Record that this must be the first non-relro section.
+  void
+  set_is_first_non_relro()
+  {
+    gold_assert(!this->is_relro_);
+    this->is_first_non_relro_ = true;
+  }
+
   // True if this is a small section: a section which holds small
   // variables.
   bool
@@ -2387,6 +2351,27 @@ class Output_section : public Output_data
   is_large_data_section()
   { return this->is_large_section_ && this->type_ != elfcpp::SHT_NOBITS; }
 
+  // True if this is the .interp section which goes into the PT_INTERP
+  // segment.
+  bool
+  is_interp() const
+  { return this->is_interp_; }
+
+  // Record that this is the interp section.
+  void
+  set_is_interp()
+  { this->is_interp_ = true; }
+
+  // True if this is a section used by the dynamic linker.
+  bool
+  is_dynamic_linker_section() const
+  { return this->is_dynamic_linker_section_; }
+
+  // Record that this is a section used by the dynamic linker.
+  void
+  set_is_dynamic_linker_section()
+  { this->is_dynamic_linker_section_ = true; }
+
   // Return whether this section should be written after all the input
   // sections are complete.
   bool
@@ -2554,10 +2539,10 @@ class Output_section : public Output_data
   get_input_sections(uint64_t address, const std::string& fill,
 		     std::list<Simple_input_section>*);
 
-  // Add an input section from a script.
+  // Add a simple input section.
   void
-  add_input_section_for_script(const Simple_input_section& input_section,
-			       off_t data_size, uint64_t addralign);
+  add_simple_input_section(const Simple_input_section& input_section,
+			   off_t data_size, uint64_t addralign);
 
   // Set the current size of the output section.
   void
@@ -2580,11 +2565,45 @@ class Output_section : public Output_data
   void
   restore_states();
 
+  // Discard states.
+  void
+  discard_states();
+
   // Convert existing input sections to relaxed input sections.
   void
   convert_input_sections_to_relaxed_sections(
       const std::vector<Output_relaxed_input_section*>& sections);
 
+  // Find a relaxed input section to an input section in OBJECT
+  // with index SHNDX.  Return NULL if none is found.
+  const Output_relaxed_input_section*
+  find_relaxed_input_section(const Relobj* object, unsigned int shndx) const;
+  
+  // Whether section offsets need adjustment due to relaxation.
+  bool
+  section_offsets_need_adjustment() const
+  { return this->section_offsets_need_adjustment_; }
+
+  // Set section_offsets_need_adjustment to be true.
+  void
+  set_section_offsets_need_adjustment()
+  { this->section_offsets_need_adjustment_ = true; }
+
+  // Adjust section offsets of input sections in this.  This is
+  // requires if relaxation caused some input sections to change sizes.
+  void
+  adjust_section_offsets();
+
+  // Whether this is a NOLOAD section.
+  bool
+  is_noload() const
+  { return this->is_noload_; }
+
+  // Set NOLOAD flag.
+  void
+  set_is_noload()
+  { this->is_noload_ = true; }
+
   // Print merge statistics to stderr.
   void
   print_merge_stats();
@@ -3167,19 +3186,20 @@ class Output_section : public Output_data
 			Merge_section_properties::equal_to>
     Merge_section_by_properties_map;
 
-  // Map that link Input_section_specifier to Output_section_data.
-  typedef Unordered_map<Input_section_specifier, Output_section_data*,
-			Input_section_specifier::hash,
-			Input_section_specifier::equal_to>
+  // Map that link Const_section_id to Output_section_data.
+  typedef Unordered_map<Const_section_id, Output_section_data*,
+			Const_section_id_hash>
     Output_section_data_by_input_section_map;
 
+  // Map that link Const_section_id to Output_relaxed_input_section.
+  typedef Unordered_map<Const_section_id, Output_relaxed_input_section*,
+			Const_section_id_hash>
+    Output_relaxed_input_section_by_input_section_map;
+
   // Map used during relaxation of existing sections.  This map
-  // an input section specifier to an input section list index.
-  // We assume that Input_section_list is a vector.
-  typedef Unordered_map<Input_section_specifier, size_t,
-			Input_section_specifier::hash,
-			Input_section_specifier::equal_to>
-    Relaxation_map;
+  // a section id an input section list index.  We assume that
+  // Input_section_list is a vector.
+  typedef Unordered_map<Section_id, size_t, Section_id_hash> Relaxation_map;
 
   // Add a new output section by Input_section.
   void
@@ -3208,11 +3228,6 @@ class Output_section : public Output_data
   Output_section_data*
   find_merge_section(const Relobj* object, unsigned int shndx) const;
 
-  // Find a relaxed input section to an input section in OBJECT
-  // with index SHNDX.  Return NULL if none is found.
-  const Output_section_data*
-  find_relaxed_input_section(const Relobj* object, unsigned int shndx) const;
-  
   // Build a relaxation map.
   void
   build_relaxation_map(
@@ -3323,10 +3338,27 @@ class Output_section : public Output_data
   bool is_relro_ : 1;
   // True if this section holds relro local data.
   bool is_relro_local_ : 1;
+  // True if this must be the last relro section.
+  bool is_last_relro_ : 1;
+  // True if this must be the first section after the relro sections.
+  bool is_first_non_relro_ : 1;
   // True if this is a small section.
   bool is_small_section_ : 1;
   // True if this is a large section.
   bool is_large_section_ : 1;
+  // True if this is the .interp section going into the PT_INTERP
+  // segment.
+  bool is_interp_ : 1;
+  // True if this is section is read by the dynamic linker.
+  bool is_dynamic_linker_section_ : 1;
+  // Whether code-fills are generated at write.
+  bool generate_code_fills_at_write_ : 1;
+  // Whether the entry size field should be zero.
+  bool is_entsize_zero_ : 1;
+  // Whether section offsets need adjustment due to relaxation.
+  bool section_offsets_need_adjustment_ : 1;
+  // Whether this is a NOLOAD section.
+  bool is_noload_ : 1;
   // For SHT_TLS sections, the offset of this section relative to the base
   // of the TLS segment.
   uint64_t tls_offset_;
@@ -3337,13 +3369,12 @@ class Output_section : public Output_data
   // Map from merge section properties to merge_sections;
   Merge_section_by_properties_map merge_section_by_properties_map_;
   // Map from input sections to relaxed input sections.  This is mutable
-  // beacause it is udpated lazily.  We may need to update it in a
+  // because it is updated lazily.  We may need to update it in a
   // const qualified method.
-  mutable Output_section_data_by_input_section_map relaxed_input_section_map_;
+  mutable Output_relaxed_input_section_by_input_section_map
+    relaxed_input_section_map_;
   // Whether relaxed_input_section_map_ is valid.
   mutable bool is_relaxed_input_section_map_valid_;
-  // Whether code-fills are generated at write.
-  bool generate_code_fills_at_write_;
 };
 
 // An output segment.  PT_LOAD segments are built from collections of
@@ -3412,17 +3443,20 @@ class Output_segment
   uint64_t
   maximum_alignment();
 
-  // Add an Output_section to this segment.
+  // Add the Output_section OS to this segment.  SEG_FLAGS is the
+  // segment flags to use.  DO_SORT is true if we should sort the
+  // placement of the input section for more efficient generated code.
   void
-  add_output_section(Output_section* os, elfcpp::Elf_Word seg_flags);
+  add_output_section(Output_section* os, elfcpp::Elf_Word seg_flags,
+		     bool do_sort);
 
   // Remove an Output_section from this segment.  It is an error if it
   // is not present.
   void
   remove_output_section(Output_section* os);
 
-  // Add an Output_data (which is not an Output_section) to the start
-  // of this segment.
+  // Add an Output_data (which need not be an Output_section) to the
+  // start of this segment.
   void
   add_initial_output_data(Output_data*);
 
@@ -3454,6 +3488,17 @@ class Output_segment
     this->are_addresses_set_ = true;
   }
 
+  // Update the flags for the flags of an output section added to this
+  // segment.
+  void
+  update_flags_for_output_section(elfcpp::Elf_Xword flags)
+  {
+    // The ELF ABI specifies that a PT_TLS segment should always have
+    // PF_R as the flags.
+    if (this->type() != elfcpp::PT_TLS)
+      this->flags_ |= flags;
+  }
+
   // Set the segment flags.  This is only used if we have a PHDRS
   // clause which explicitly specifies the flags.
   void
@@ -3468,19 +3513,23 @@ class Output_segment
   // address of the immediately following segment.  Update *POFF and
   // *PSHNDX.  This should only be called for a PT_LOAD segment.
   uint64_t
-  set_section_addresses(const Layout*, bool reset, uint64_t addr, off_t* poff,
+  set_section_addresses(const Layout*, bool reset, uint64_t addr,
+			unsigned int increase_relro, off_t* poff,
 			unsigned int* pshndx);
 
   // Set the minimum alignment of this segment.  This may be adjusted
   // upward based on the section alignments.
   void
   set_minimum_p_align(uint64_t align)
-  { this->min_p_align_ = align; }
+  {
+    if (align > this->min_p_align_)
+      this->min_p_align_ = align;
+  }
 
   // Set the offset of this segment based on the section.  This should
   // only be called for a non-PT_LOAD segment.
   void
-  set_offset();
+  set_offset(unsigned int increase);
 
   // Set the TLS offsets of the sections contained in the PT_TLS segment.
   void
@@ -3526,7 +3575,7 @@ class Output_segment
   uint64_t
   set_section_list_addresses(const Layout*, bool reset, Output_data_list*,
                              uint64_t addr, off_t* poff, unsigned int* pshndx,
-                             bool* in_tls, bool* in_relro);
+                             bool* in_tls);
 
   // Return the number of Output_sections in an Output_data_list.
   unsigned int
diff --git a/gold/parameters.cc b/gold/parameters.cc
index 2a53998..9cf7808 100644
--- a/gold/parameters.cc
+++ b/gold/parameters.cc
@@ -141,7 +141,10 @@ set_parameters_options(const General_options* options)
 
 void
 set_parameters_target(Target* target)
-{ static_parameters.set_target(target); }
+{
+  static_parameters.set_target(target);
+  target->select_as_default_target();
+}
 
 void
 set_parameters_doing_static_link(bool doing_static_link)
diff --git a/gold/powerpc.cc b/gold/powerpc.cc
index 71f2ae4..5988371 100644
--- a/gold/powerpc.cc
+++ b/gold/powerpc.cc
@@ -65,8 +65,7 @@ class Target_powerpc : public Sized_target<size, big_endian>
   // Process the relocations to determine unreferenced sections for 
   // garbage collection.
   void
-  gc_process_relocs(const General_options& options,
-	            Symbol_table* symtab,
+  gc_process_relocs(Symbol_table* symtab,
 	            Layout* layout,
 	            Sized_relobj<size, big_endian>* object,
 	            unsigned int data_shndx,
@@ -80,8 +79,7 @@ class Target_powerpc : public Sized_target<size, big_endian>
 
   // Scan the relocations to look for symbol adjustments.
   void
-  scan_relocs(const General_options& options,
-	      Symbol_table* symtab,
+  scan_relocs(Symbol_table* symtab,
 	      Layout* layout,
 	      Sized_relobj<size, big_endian>* object,
 	      unsigned int data_shndx,
@@ -94,7 +92,7 @@ class Target_powerpc : public Sized_target<size, big_endian>
 	      const unsigned char* plocal_symbols);
   // Finalize the sections.
   void
-  do_finalize_sections(Layout*);
+  do_finalize_sections(Layout*, const Input_objects*, Symbol_table*);
 
   // Return the value to use for a dynamic which requires special
   // treatment.
@@ -116,8 +114,7 @@ class Target_powerpc : public Sized_target<size, big_endian>
 
   // Scan the relocs during a relocatable link.
   void
-  scan_relocatable_relocs(const General_options& options,
-			  Symbol_table* symtab,
+  scan_relocatable_relocs(Symbol_table* symtab,
 			  Layout* layout,
 			  Sized_relobj<size, big_endian>* object,
 			  unsigned int data_shndx,
@@ -171,8 +168,7 @@ class Target_powerpc : public Sized_target<size, big_endian>
     { }
 
     inline void
-    local(const General_options& options, Symbol_table* symtab,
-	  Layout* layout, Target_powerpc* target,
+    local(Symbol_table* symtab, Layout* layout, Target_powerpc* target,
 	  Sized_relobj<size, big_endian>* object,
 	  unsigned int data_shndx,
 	  Output_section* output_section,
@@ -180,8 +176,7 @@ class Target_powerpc : public Sized_target<size, big_endian>
 	  const elfcpp::Sym<size, big_endian>& lsym);
 
     inline void
-    global(const General_options& options, Symbol_table* symtab,
-	   Layout* layout, Target_powerpc* target,
+    global(Symbol_table* symtab, Layout* layout, Target_powerpc* target,
 	   Sized_relobj<size, big_endian>* object,
 	   unsigned int data_shndx,
 	   Output_section* output_section,
@@ -347,7 +342,9 @@ Target::Target_info Target_powerpc<32, true>::powerpc_info =
   elfcpp::SHN_UNDEF,	// small_common_shndx
   elfcpp::SHN_UNDEF,	// large_common_shndx
   0,			// small_common_section_flags
-  0			// large_common_section_flags
+  0,			// large_common_section_flags
+  NULL,			// attributes_section
+  NULL			// attributes_vendor
 };
 
 template<>
@@ -368,7 +365,9 @@ Target::Target_info Target_powerpc<32, false>::powerpc_info =
   elfcpp::SHN_UNDEF,	// small_common_shndx
   elfcpp::SHN_UNDEF,	// large_common_shndx
   0,			// small_common_section_flags
-  0			// large_common_section_flags
+  0,			// large_common_section_flags
+  NULL,			// attributes_section
+  NULL			// attributes_vendor
 };
 
 template<>
@@ -389,7 +388,9 @@ Target::Target_info Target_powerpc<64, true>::powerpc_info =
   elfcpp::SHN_UNDEF,	// small_common_shndx
   elfcpp::SHN_UNDEF,	// large_common_shndx
   0,			// small_common_section_flags
-  0			// large_common_section_flags
+  0,			// large_common_section_flags
+  NULL,			// attributes_section
+  NULL			// attributes_vendor
 };
 
 template<>
@@ -410,7 +411,9 @@ Target::Target_info Target_powerpc<64, false>::powerpc_info =
   elfcpp::SHN_UNDEF,	// small_common_shndx
   elfcpp::SHN_UNDEF,	// large_common_shndx
   0,			// small_common_section_flags
-  0			// large_common_section_flags
+  0,			// large_common_section_flags
+  NULL,			// attributes_section
+  NULL			// attributes_vendor
 };
 
 template<int size, bool big_endian>
@@ -713,7 +716,7 @@ Target_powerpc<size, big_endian>::got_section(Symbol_table* symtab,
 
       layout->add_output_section_data(".got", elfcpp::SHT_PROGBITS,
 				      elfcpp::SHF_ALLOC | elfcpp::SHF_WRITE,
-				      this->got_);
+				      this->got_, false, false, false, false);
 
       // Create the GOT2 or TOC in the .got section.
       if (size == 32)
@@ -722,7 +725,8 @@ Target_powerpc<size, big_endian>::got_section(Symbol_table* symtab,
 	  layout->add_output_section_data(".got2", elfcpp::SHT_PROGBITS,
 					  elfcpp::SHF_ALLOC
 					  | elfcpp::SHF_WRITE,
-					  this->got2_);
+					  this->got2_, false, false, false,
+					  false);
 	}
       else
 	{
@@ -730,11 +734,13 @@ Target_powerpc<size, big_endian>::got_section(Symbol_table* symtab,
 	  layout->add_output_section_data(".toc", elfcpp::SHT_PROGBITS,
 					  elfcpp::SHF_ALLOC
 					  | elfcpp::SHF_WRITE,
-					  this->toc_);
+					  this->toc_, false, false, false,
+					  false);
 	}
 
       // Define _GLOBAL_OFFSET_TABLE_ at the start of the .got section.
       symtab->define_in_output_data("_GLOBAL_OFFSET_TABLE_", NULL,
+				    Symbol_table::PREDEFINED,
 				    this->got_,
 				    0, 0, elfcpp::STT_OBJECT,
 				    elfcpp::STB_LOCAL,
@@ -756,7 +762,8 @@ Target_powerpc<size, big_endian>::rela_dyn_section(Layout* layout)
       gold_assert(layout != NULL);
       this->rela_dyn_ = new Reloc_section(parameters->options().combreloc());
       layout->add_output_section_data(".rela.dyn", elfcpp::SHT_RELA,
-				      elfcpp::SHF_ALLOC, this->rela_dyn_);
+				      elfcpp::SHF_ALLOC, this->rela_dyn_, true,
+				      false, false, false);
     }
   return this->rela_dyn_;
 }
@@ -816,7 +823,8 @@ Output_data_plt_powerpc<size, big_endian>::Output_data_plt_powerpc(Layout* layou
 {
   this->rel_ = new Reloc_section(false);
   layout->add_output_section_data(".rela.plt", elfcpp::SHT_RELA,
-				  elfcpp::SHF_ALLOC, this->rel_);
+				  elfcpp::SHF_ALLOC, this->rel_, true, false,
+				  false, false);
 }
 
 template<int size, bool big_endian>
@@ -945,10 +953,11 @@ Target_powerpc<size, big_endian>::make_plt_entry(Symbol_table* symtab,
 				      (elfcpp::SHF_ALLOC
 				       | elfcpp::SHF_EXECINSTR
 				       | elfcpp::SHF_WRITE),
-				      this->plt_);
+				      this->plt_, false, false, false, false);
 
       // Define _PROCEDURE_LINKAGE_TABLE_ at the start of the .plt section.
       symtab->define_in_output_data("_PROCEDURE_LINKAGE_TABLE_", NULL,
+				    Symbol_table::PREDEFINED,
 				    this->plt_,
 				    0, 0, elfcpp::STT_OBJECT,
 				    elfcpp::STB_LOCAL,
@@ -1113,7 +1122,6 @@ Target_powerpc<size, big_endian>::Scan::check_non_pic(Relobj* object,
 template<int size, bool big_endian>
 inline void
 Target_powerpc<size, big_endian>::Scan::local(
-			const General_options&,
 			Symbol_table* symtab,
 			Layout* layout,
 			Target_powerpc<size, big_endian>* target,
@@ -1248,7 +1256,6 @@ Target_powerpc<size, big_endian>::Scan::unsupported_reloc_global(
 template<int size, bool big_endian>
 inline void
 Target_powerpc<size, big_endian>::Scan::global(
-				const General_options&,
 				Symbol_table* symtab,
 				Layout* layout,
 				Target_powerpc<size, big_endian>* target,
@@ -1444,7 +1451,6 @@ Target_powerpc<size, big_endian>::Scan::global(
 template<int size, bool big_endian>
 void
 Target_powerpc<size, big_endian>::gc_process_relocs(
-			const General_options& options,
 			Symbol_table* symtab,
 			Layout* layout,
 			Sized_relobj<size, big_endian>* object,
@@ -1461,7 +1467,6 @@ Target_powerpc<size, big_endian>::gc_process_relocs(
   typedef typename Target_powerpc<size, big_endian>::Scan Scan;
 
   gold::gc_process_relocs<size, big_endian, Powerpc, elfcpp::SHT_RELA, Scan>(
-    options,
     symtab,
     layout,
     this,
@@ -1480,7 +1485,6 @@ Target_powerpc<size, big_endian>::gc_process_relocs(
 template<int size, bool big_endian>
 void
 Target_powerpc<size, big_endian>::scan_relocs(
-			const General_options& options,
 			Symbol_table* symtab,
 			Layout* layout,
 			Sized_relobj<size, big_endian>* object,
@@ -1512,8 +1516,10 @@ Target_powerpc<size, big_endian>::scan_relocs(
     Output_section* os = layout->add_output_section_data(".sdata", 0,
 							 elfcpp::SHF_ALLOC
 							 | elfcpp::SHF_WRITE,
-							 sdata);
+							 sdata, false,
+							 false, false, false);
     symtab->define_in_output_data("_SDA_BASE_", NULL,
+				  Symbol_table::PREDEFINED,
 				  os,
 				  32768, 0,
 				  elfcpp::STT_OBJECT,
@@ -1523,7 +1529,6 @@ Target_powerpc<size, big_endian>::scan_relocs(
   }
 
   gold::scan_relocs<size, big_endian, Powerpc, elfcpp::SHT_RELA, Scan>(
-    options,
     symtab,
     layout,
     this,
@@ -1541,7 +1546,10 @@ Target_powerpc<size, big_endian>::scan_relocs(
 
 template<int size, bool big_endian>
 void
-Target_powerpc<size, big_endian>::do_finalize_sections(Layout* layout)
+Target_powerpc<size, big_endian>::do_finalize_sections(
+    Layout* layout,
+    const Input_objects*,
+    Symbol_table*)
 {
   // Fill in some more dynamic tags.
   Output_data_dynamic* const odyn = layout->dynamic_data();
@@ -1897,7 +1905,6 @@ Target_powerpc<size, big_endian>::Relocatable_size_for_reloc::get_size_for_reloc
 template<int size, bool big_endian>
 void
 Target_powerpc<size, big_endian>::scan_relocatable_relocs(
-			const General_options& options,
 			Symbol_table* symtab,
 			Layout* layout,
 			Sized_relobj<size, big_endian>* object,
@@ -1918,7 +1925,6 @@ Target_powerpc<size, big_endian>::scan_relocatable_relocs(
 
   gold::scan_relocatable_relocs<size, big_endian, elfcpp::SHT_RELA,
       Scan_relocatable_relocs>(
-    options,
     symtab,
     layout,
     object,
diff --git a/gold/reduced_debug_output.cc b/gold/reduced_debug_output.cc
index 4834694..5bc8053 100644
--- a/gold/reduced_debug_output.cc
+++ b/gold/reduced_debug_output.cc
@@ -27,71 +27,13 @@
 #include "dwarf.h"
 #include "dwarf_reader.h"
 #include "reduced_debug_output.h"
+#include "int_encoding.h"
 
 #include <vector>
 
 namespace gold
 {
 
-void
-write_unsigned_LEB_128(std::vector<unsigned char>* buffer, uint64_t value)
-{
-  do
-    {
-      unsigned char current_byte = value & 0x7f;
-      value >>= 7;
-      if (value != 0)
-        {
-          current_byte |= 0x80;
-        }
-      buffer->push_back(current_byte);
-    }
-  while (value != 0);
-}
-
-size_t
-get_length_as_unsigned_LEB_128(uint64_t value)
-{
-  size_t length = 0;
-  do
-    {
-      unsigned char current_byte = value & 0x7f;
-      value >>= 7;
-      if (value != 0)
-        {
-          current_byte |= 0x80;
-        }
-      length++;
-    }
-  while (value != 0);
-  return length;
-}
-
-template <int valsize>
-void insert_into_vector(std::vector<unsigned char>* destination,
-                        typename elfcpp::Valtype_base<valsize>::Valtype value)
-{
-  unsigned char buffer[valsize / 8];
-  if (parameters->target().is_big_endian())
-    elfcpp::Swap_unaligned<valsize, true>::writeval(buffer, value);
-  else
-    elfcpp::Swap_unaligned<valsize, false>::writeval(buffer, value);
-  destination->insert(destination->end(), buffer, buffer + valsize / 8);
-}
-
-template <int valsize>
-typename elfcpp::Valtype_base<valsize>::Valtype
-read_from_pointer(unsigned char** source)
-{
-  typename elfcpp::Valtype_base<valsize>::Valtype return_value;
-  if (parameters->target().is_big_endian())
-    return_value = elfcpp::Swap_unaligned<valsize, true>::readval(*source);
-  else
-    return_value = elfcpp::Swap_unaligned<valsize, false>::readval(*source);
-  *source += valsize / 8;
-  return return_value;
-}
-
 // Given a pointer to the beginning of a die and the beginning of the associated
 // abbreviation fills in die_end with the end of the information entry.  If
 // successful returns true.  Get_die_end also takes a pointer to the end of the
diff --git a/gold/reloc.cc b/gold/reloc.cc
index 3018dc3..858778e 100644
--- a/gold/reloc.cc
+++ b/gold/reloc.cc
@@ -72,8 +72,7 @@ Read_relocs::run(Workqueue* workqueue)
   if (parameters->options().gc_sections()
       || parameters->options().icf_enabled())
     {
-      workqueue->queue_next(new Gc_process_relocs(this->options_,
-                                                  this->symtab_,
+      workqueue->queue_next(new Gc_process_relocs(this->symtab_,
                                                   this->layout_, 
                                                   this->object_, rd,
                                                   this->symtab_lock_, 
@@ -81,8 +80,8 @@ Read_relocs::run(Workqueue* workqueue)
     }
   else
     {
-      workqueue->queue_next(new Scan_relocs(this->options_, this->symtab_,
-                                            this->layout_, this->object_, rd,
+      workqueue->queue_next(new Scan_relocs(this->symtab_, this->layout_,
+					    this->object_, rd,
                                             this->symtab_lock_, 
                                             this->blocker_));
     }
@@ -120,8 +119,7 @@ Gc_process_relocs::locks(Task_locker* tl)
 void
 Gc_process_relocs::run(Workqueue*)
 {
-  this->object_->gc_process_relocs(this->options_, this->symtab_, this->layout_,
-            	     this->rd_);
+  this->object_->gc_process_relocs(this->symtab_, this->layout_, this->rd_);
   this->object_->release();
 }
 
@@ -166,8 +164,7 @@ Scan_relocs::locks(Task_locker* tl)
 void
 Scan_relocs::run(Workqueue*)
 {
-  this->object_->scan_relocs(this->options_, this->symtab_, this->layout_,
-			     this->rd_);
+  this->object_->scan_relocs(this->symtab_, this->layout_, this->rd_);
   this->object_->release();
   delete this->rd_;
   this->rd_ = NULL;
@@ -216,8 +213,7 @@ Relocate_task::locks(Task_locker* tl)
 void
 Relocate_task::run(Workqueue*)
 {
-  this->object_->relocate(this->options_, this->symtab_, this->layout_,
-			  this->of_);
+  this->object_->relocate(this->symtab_, this->layout_, this->of_);
 
   // This is normally the last thing we will do with an object, so
   // uncache all views.
@@ -360,10 +356,9 @@ Sized_relobj<size, big_endian>::do_read_relocs(Read_relocs_data* rd)
 
 template<int size, bool big_endian>
 void
-Sized_relobj<size, big_endian>::do_gc_process_relocs(const General_options& options,
-					       Symbol_table* symtab,
-					       Layout* layout,
-					       Read_relocs_data* rd)
+Sized_relobj<size, big_endian>::do_gc_process_relocs(Symbol_table* symtab,
+						     Layout* layout,
+						     Read_relocs_data* rd)
 {  
   Sized_target<size, big_endian>* target =
     parameters->sized_target<size, big_endian>();
@@ -384,7 +379,7 @@ Sized_relobj<size, big_endian>::do_gc_process_relocs(const General_options& opti
 	    // only scan allocated sections.  We may see a non-allocated
 	    // section here if we are emitting relocs.
 	    if (p->is_data_section_allocated)
-              target->gc_process_relocs(options, symtab, layout, this, 
+              target->gc_process_relocs(symtab, layout, this, 
                                         p->data_shndx, p->sh_type, 
                                         p->contents->data(), p->reloc_count, 
                                         p->output_section,
@@ -401,8 +396,7 @@ Sized_relobj<size, big_endian>::do_gc_process_relocs(const General_options& opti
 
 template<int size, bool big_endian>
 void
-Sized_relobj<size, big_endian>::do_scan_relocs(const General_options& options,
-					       Symbol_table* symtab,
+Sized_relobj<size, big_endian>::do_scan_relocs(Symbol_table* symtab,
 					       Layout* layout,
 					       Read_relocs_data* rd)
 {
@@ -434,21 +428,21 @@ Sized_relobj<size, big_endian>::do_scan_relocs(const General_options& options,
 	  // only scan allocated sections.  We may see a non-allocated
 	  // section here if we are emitting relocs.
 	  if (p->is_data_section_allocated)
-	    target->scan_relocs(options, symtab, layout, this, p->data_shndx,
+	    target->scan_relocs(symtab, layout, this, p->data_shndx,
 				p->sh_type, p->contents->data(),
 				p->reloc_count, p->output_section,
 				p->needs_special_offset_handling,
 				this->local_symbol_count_,
 				local_symbols);
 	  if (parameters->options().emit_relocs())
-	    this->emit_relocs_scan(options, symtab, layout, local_symbols, p);
+	    this->emit_relocs_scan(symtab, layout, local_symbols, p);
 	}
       else
 	{
 	  Relocatable_relocs* rr = this->relocatable_relocs(p->reloc_shndx);
 	  gold_assert(rr != NULL);
 	  rr->set_reloc_count(p->reloc_count);
-	  target->scan_relocatable_relocs(options, symtab, layout, this,
+	  target->scan_relocatable_relocs(symtab, layout, this,
 					  p->data_shndx, p->sh_type,
 					  p->contents->data(),
 					  p->reloc_count,
@@ -510,7 +504,6 @@ class Emit_relocs_strategy
 template<int size, bool big_endian>
 void
 Sized_relobj<size, big_endian>::emit_relocs_scan(
-    const General_options& options,
     Symbol_table* symtab,
     Layout* layout,
     const unsigned char* plocal_syms,
@@ -521,14 +514,13 @@ Sized_relobj<size, big_endian>::emit_relocs_scan(
   rr->set_reloc_count(p->reloc_count);
 
   if (p->sh_type == elfcpp::SHT_REL)
-    this->emit_relocs_scan_reltype<elfcpp::SHT_REL>(options, symtab, layout,
+    this->emit_relocs_scan_reltype<elfcpp::SHT_REL>(symtab, layout,
 						    plocal_syms, p, rr);
   else
     {
       gold_assert(p->sh_type == elfcpp::SHT_RELA);
-      this->emit_relocs_scan_reltype<elfcpp::SHT_RELA>(options, symtab,
-						       layout, plocal_syms, p,
-						       rr);
+      this->emit_relocs_scan_reltype<elfcpp::SHT_RELA>(symtab, layout,
+						       plocal_syms, p, rr);
     }
 }
 
@@ -539,7 +531,6 @@ template<int size, bool big_endian>
 template<int sh_type>
 void
 Sized_relobj<size, big_endian>::emit_relocs_scan_reltype(
-    const General_options& options,
     Symbol_table* symtab,
     Layout* layout,
     const unsigned char* plocal_syms,
@@ -548,7 +539,6 @@ Sized_relobj<size, big_endian>::emit_relocs_scan_reltype(
 {
   scan_relocatable_relocs<size, big_endian, sh_type,
 			  Emit_relocs_strategy<sh_type> >(
-    options,
     symtab,
     layout,
     this,
@@ -566,8 +556,7 @@ Sized_relobj<size, big_endian>::emit_relocs_scan_reltype(
 
 template<int size, bool big_endian>
 void
-Sized_relobj<size, big_endian>::do_relocate(const General_options& options,
-					    const Symbol_table* symtab,
+Sized_relobj<size, big_endian>::do_relocate(const Symbol_table* symtab,
 					    const Layout* layout,
 					    Output_file* of)
 {
@@ -593,7 +582,7 @@ Sized_relobj<size, big_endian>::do_relocate(const General_options& options,
 
   // Apply relocations.
 
-  this->relocate_sections(options, symtab, layout, pshdrs, &views);
+  this->relocate_sections(symtab, layout, pshdrs, &views);
 
   // After we've done the relocations, we release the hash tables,
   // since we no longer need them.
@@ -799,8 +788,7 @@ Sized_relobj<size, big_endian>::write_sections(const unsigned char* pshdrs,
 
 template<int size, bool big_endian>
 void
-Sized_relobj<size, big_endian>::relocate_sections(
-    const General_options& options,
+Sized_relobj<size, big_endian>::do_relocate_sections(
     const Symbol_table* symtab,
     const Layout* layout,
     const unsigned char* pshdrs,
@@ -814,7 +802,6 @@ Sized_relobj<size, big_endian>::relocate_sections(
   const std::vector<Address>& out_offsets(this->section_offsets_);
 
   Relocate_info<size, big_endian> relinfo;
-  relinfo.options = &options;
   relinfo.symtab = symtab;
   relinfo.layout = layout;
   relinfo.object = this;
@@ -1431,44 +1418,39 @@ Sized_relobj<64, true>::do_read_relocs(Read_relocs_data* rd);
 #ifdef HAVE_TARGET_32_LITTLE
 template
 void
-Sized_relobj<32, false>::do_gc_process_relocs(const General_options& options,
-					Symbol_table* symtab,
-					Layout* layout,
-					Read_relocs_data* rd);
+Sized_relobj<32, false>::do_gc_process_relocs(Symbol_table* symtab,
+					      Layout* layout,
+					      Read_relocs_data* rd);
 #endif
 
 #ifdef HAVE_TARGET_32_BIG
 template
 void
-Sized_relobj<32, true>::do_gc_process_relocs(const General_options& options,
-				       Symbol_table* symtab,
-				       Layout* layout,
-				       Read_relocs_data* rd);
+Sized_relobj<32, true>::do_gc_process_relocs(Symbol_table* symtab,
+					     Layout* layout,
+					     Read_relocs_data* rd);
 #endif
 
 #ifdef HAVE_TARGET_64_LITTLE
 template
 void
-Sized_relobj<64, false>::do_gc_process_relocs(const General_options& options,
-					Symbol_table* symtab,
-					Layout* layout,
-					Read_relocs_data* rd);
+Sized_relobj<64, false>::do_gc_process_relocs(Symbol_table* symtab,
+					      Layout* layout,
+					      Read_relocs_data* rd);
 #endif
 
 #ifdef HAVE_TARGET_64_BIG
 template
 void
-Sized_relobj<64, true>::do_gc_process_relocs(const General_options& options,
-				       Symbol_table* symtab,
-				       Layout* layout,
-				       Read_relocs_data* rd);
+Sized_relobj<64, true>::do_gc_process_relocs(Symbol_table* symtab,
+					     Layout* layout,
+					     Read_relocs_data* rd);
 #endif
 
 #ifdef HAVE_TARGET_32_LITTLE
 template
 void
-Sized_relobj<32, false>::do_scan_relocs(const General_options& options,
-					Symbol_table* symtab,
+Sized_relobj<32, false>::do_scan_relocs(Symbol_table* symtab,
 					Layout* layout,
 					Read_relocs_data* rd);
 #endif
@@ -1476,8 +1458,7 @@ Sized_relobj<32, false>::do_scan_relocs(const General_options& options,
 #ifdef HAVE_TARGET_32_BIG
 template
 void
-Sized_relobj<32, true>::do_scan_relocs(const General_options& options,
-				       Symbol_table* symtab,
+Sized_relobj<32, true>::do_scan_relocs(Symbol_table* symtab,
 				       Layout* layout,
 				       Read_relocs_data* rd);
 #endif
@@ -1485,8 +1466,7 @@ Sized_relobj<32, true>::do_scan_relocs(const General_options& options,
 #ifdef HAVE_TARGET_64_LITTLE
 template
 void
-Sized_relobj<64, false>::do_scan_relocs(const General_options& options,
-					Symbol_table* symtab,
+Sized_relobj<64, false>::do_scan_relocs(Symbol_table* symtab,
 					Layout* layout,
 					Read_relocs_data* rd);
 #endif
@@ -1494,8 +1474,7 @@ Sized_relobj<64, false>::do_scan_relocs(const General_options& options,
 #ifdef HAVE_TARGET_64_BIG
 template
 void
-Sized_relobj<64, true>::do_scan_relocs(const General_options& options,
-				       Symbol_table* symtab,
+Sized_relobj<64, true>::do_scan_relocs(Symbol_table* symtab,
 				       Layout* layout,
 				       Read_relocs_data* rd);
 #endif
@@ -1503,8 +1482,7 @@ Sized_relobj<64, true>::do_scan_relocs(const General_options& options,
 #ifdef HAVE_TARGET_32_LITTLE
 template
 void
-Sized_relobj<32, false>::do_relocate(const General_options& options,
-				     const Symbol_table* symtab,
+Sized_relobj<32, false>::do_relocate(const Symbol_table* symtab,
 				     const Layout* layout,
 				     Output_file* of);
 #endif
@@ -1512,8 +1490,7 @@ Sized_relobj<32, false>::do_relocate(const General_options& options,
 #ifdef HAVE_TARGET_32_BIG
 template
 void
-Sized_relobj<32, true>::do_relocate(const General_options& options,
-				    const Symbol_table* symtab,
+Sized_relobj<32, true>::do_relocate(const Symbol_table* symtab,
 				    const Layout* layout,
 				    Output_file* of);
 #endif
@@ -1521,8 +1498,7 @@ Sized_relobj<32, true>::do_relocate(const General_options& options,
 #ifdef HAVE_TARGET_64_LITTLE
 template
 void
-Sized_relobj<64, false>::do_relocate(const General_options& options,
-				     const Symbol_table* symtab,
+Sized_relobj<64, false>::do_relocate(const Symbol_table* symtab,
 				     const Layout* layout,
 				     Output_file* of);
 #endif
@@ -1530,12 +1506,91 @@ Sized_relobj<64, false>::do_relocate(const General_options& options,
 #ifdef HAVE_TARGET_64_BIG
 template
 void
-Sized_relobj<64, true>::do_relocate(const General_options& options,
-				    const Symbol_table* symtab,
+Sized_relobj<64, true>::do_relocate(const Symbol_table* symtab,
 				    const Layout* layout,
 				    Output_file* of);
 #endif
 
+#ifdef HAVE_TARGET_32_LITTLE
+template
+void
+Sized_relobj<32, false>::do_relocate_sections(
+    const Symbol_table* symtab,
+    const Layout* layout,
+    const unsigned char* pshdrs,
+    Views* pviews);
+#endif
+
+#ifdef HAVE_TARGET_32_BIG
+template
+void
+Sized_relobj<32, true>::do_relocate_sections(
+    const Symbol_table* symtab,
+    const Layout* layout,
+    const unsigned char* pshdrs,
+    Views* pviews);
+#endif
+
+#ifdef HAVE_TARGET_64_LITTLE
+template
+void
+Sized_relobj<64, false>::do_relocate_sections(
+    const Symbol_table* symtab,
+    const Layout* layout,
+    const unsigned char* pshdrs,
+    Views* pviews);
+#endif
+
+#ifdef HAVE_TARGET_64_BIG
+template
+void
+Sized_relobj<64, true>::do_relocate_sections(
+    const Symbol_table* symtab,
+    const Layout* layout,
+    const unsigned char* pshdrs,
+    Views* pviews);
+#endif
+
+#ifdef HAVE_TARGET_32_LITTLE
+template
+void
+Sized_relobj<32, false>::initialize_input_to_output_maps();
+
+template
+void
+Sized_relobj<32, false>::free_input_to_output_maps();
+#endif
+
+#ifdef HAVE_TARGET_32_BIG
+template
+void
+Sized_relobj<32, true>::initialize_input_to_output_maps();
+
+template
+void
+Sized_relobj<32, true>::free_input_to_output_maps();
+#endif
+
+#ifdef HAVE_TARGET_64_LITTLE
+template
+void
+Sized_relobj<64, false>::initialize_input_to_output_maps();
+
+template
+void
+Sized_relobj<64, false>::free_input_to_output_maps();
+#endif
+
+#ifdef HAVE_TARGET_64_BIG
+template
+void
+Sized_relobj<64, true>::initialize_input_to_output_maps();
+
+template
+void
+Sized_relobj<64, true>::free_input_to_output_maps();
+#endif
+
 #if defined(HAVE_TARGET_32_LITTLE) || defined(HAVE_TARGET_32_BIG)
 template
 class Merged_symbol_value<32>;
diff --git a/gold/reloc.h b/gold/reloc.h
index 2229421..5dd4c85 100644
--- a/gold/reloc.h
+++ b/gold/reloc.h
@@ -64,10 +64,9 @@ class Read_relocs : public Task
  public:
   // SYMTAB_LOCK is used to lock the symbol table.  BLOCKER should be
   // unblocked when the Scan_relocs task completes.
-  Read_relocs(const General_options& options, Symbol_table* symtab,
-	      Layout* layout, Relobj* object, Task_token* symtab_lock,
-	      Task_token* blocker)
-    : options_(options), symtab_(symtab), layout_(layout), object_(object),
+  Read_relocs(Symbol_table* symtab, Layout* layout, Relobj* object,
+	      Task_token* symtab_lock, Task_token* blocker)
+    : symtab_(symtab), layout_(layout), object_(object),
       symtab_lock_(symtab_lock), blocker_(blocker)
   { }
 
@@ -86,7 +85,6 @@ class Read_relocs : public Task
   get_name() const;
 
  private:
-  const General_options& options_;
   Symbol_table* symtab_;
   Layout* layout_;
   Relobj* object_;
@@ -102,11 +100,11 @@ class Gc_process_relocs : public Task
  public:
   // SYMTAB_LOCK is used to lock the symbol table.  BLOCKER should be
   // unblocked when the task completes.
-  Gc_process_relocs(const General_options& options, Symbol_table* symtab,
-	      Layout* layout, Relobj* object, Read_relocs_data* rd,
-	      Task_token* symtab_lock, Task_token* blocker)
-    : options_(options), symtab_(symtab), layout_(layout), object_(object),
-      rd_(rd), symtab_lock_(symtab_lock), blocker_(blocker)
+  Gc_process_relocs(Symbol_table* symtab, Layout* layout, Relobj* object,
+		    Read_relocs_data* rd, Task_token* symtab_lock,
+		    Task_token* blocker)
+    : symtab_(symtab), layout_(layout), object_(object), rd_(rd),
+      symtab_lock_(symtab_lock), blocker_(blocker)
   { }
 
   // The standard Task methods.
@@ -124,7 +122,6 @@ class Gc_process_relocs : public Task
   get_name() const;
 
  private:
-  const General_options& options_;
   Symbol_table* symtab_;
   Layout* layout_;
   Relobj* object_;
@@ -141,11 +138,11 @@ class Scan_relocs : public Task
  public:
   // SYMTAB_LOCK is used to lock the symbol table.  BLOCKER should be
   // unblocked when the task completes.
-  Scan_relocs(const General_options& options, Symbol_table* symtab,
-	      Layout* layout, Relobj* object, Read_relocs_data* rd,
-	      Task_token* symtab_lock, Task_token* blocker)
-    : options_(options), symtab_(symtab), layout_(layout), object_(object),
-      rd_(rd), symtab_lock_(symtab_lock), blocker_(blocker)
+  Scan_relocs(Symbol_table* symtab, Layout* layout, Relobj* object,
+	      Read_relocs_data* rd, Task_token* symtab_lock,
+	      Task_token* blocker)
+    : symtab_(symtab), layout_(layout), object_(object), rd_(rd),
+      symtab_lock_(symtab_lock), blocker_(blocker)
   { }
 
   // The standard Task methods.
@@ -163,7 +160,6 @@ class Scan_relocs : public Task
   get_name() const;
 
  private:
-  const General_options& options_;
   Symbol_table* symtab_;
   Layout* layout_;
   Relobj* object_;
@@ -177,12 +173,12 @@ class Scan_relocs : public Task
 class Relocate_task : public Task
 {
  public:
-  Relocate_task(const General_options& options, const Symbol_table* symtab,
-		const Layout* layout, Relobj* object, Output_file* of,
+  Relocate_task(const Symbol_table* symtab, const Layout* layout,
+		Relobj* object, Output_file* of,
 		Task_token* input_sections_blocker,
 		Task_token* output_sections_blocker, Task_token* final_blocker)
-    : options_(options), symtab_(symtab), layout_(layout), object_(object),
-      of_(of), input_sections_blocker_(input_sections_blocker),
+    : symtab_(symtab), layout_(layout), object_(object), of_(of),
+      input_sections_blocker_(input_sections_blocker),
       output_sections_blocker_(output_sections_blocker),
       final_blocker_(final_blocker)
   { }
@@ -202,7 +198,6 @@ class Relocate_task : public Task
   get_name() const;
 
  private:
-  const General_options& options_;
   const Symbol_table* symtab_;
   const Layout* layout_;
   Relobj* object_;
diff --git a/gold/resolve.cc b/gold/resolve.cc
index 82af9b4..086c7ca 100644
--- a/gold/resolve.cc
+++ b/gold/resolve.cc
@@ -302,25 +302,41 @@ Symbol_table::resolve(Sized_symbol<size>* to,
                                          sym.get_st_type());
 
   bool adjust_common_sizes;
-  if (Symbol_table::should_override(to, frombits, object,
+  typename Sized_symbol<size>::Size_type tosize = to->symsize();
+  if (Symbol_table::should_override(to, frombits, OBJECT, object,
 				    &adjust_common_sizes))
     {
-      typename Sized_symbol<size>::Size_type tosize = to->symsize();
-
       this->override(to, sym, st_shndx, is_ordinary, object, version);
-
       if (adjust_common_sizes && tosize > to->symsize())
         to->set_symsize(tosize);
     }
   else
     {
-      if (adjust_common_sizes && sym.get_st_size() > to->symsize())
+      if (adjust_common_sizes && sym.get_st_size() > tosize)
         to->set_symsize(sym.get_st_size());
       // The ELF ABI says that even for a reference to a symbol we
       // merge the visibility.
       to->override_visibility(sym.get_st_visibility());
     }
 
+  if (adjust_common_sizes && parameters->options().warn_common())
+    {
+      if (tosize > sym.get_st_size())
+	Symbol_table::report_resolve_problem(false,
+					     _("common of '%s' overriding "
+					       "smaller common"),
+					     to, OBJECT, object);
+      else if (tosize < sym.get_st_size())
+	Symbol_table::report_resolve_problem(false,
+					     _("common of '%s' overidden by "
+					       "larger common"),
+					     to, OBJECT, object);
+      else
+	Symbol_table::report_resolve_problem(false,
+					     _("multiple common of '%s'"),
+					     to, OBJECT, object);
+    }
+
   // A new weak undefined reference, merging with an old weak
   // reference, could be a One Definition Rule (ODR) violation --
   // especially if the types or sizes of the references differ.  We'll
@@ -361,7 +377,8 @@ Symbol_table::resolve(Sized_symbol<size>* to,
 
 bool
 Symbol_table::should_override(const Symbol* to, unsigned int frombits,
-                              Object* object, bool* adjust_common_sizes)
+                              Defined defined, Object* object,
+			      bool* adjust_common_sizes)
 {
   *adjust_common_sizes = false;
 
@@ -419,17 +436,12 @@ Symbol_table::should_override(const Symbol* to, unsigned int frombits,
       // --just-symbols, then don't warn.  This is for compatibility
       // with the GNU linker.  FIXME: This is a hack.
       if ((to->source() == Symbol::FROM_OBJECT && to->object()->just_symbols())
-          || object->just_symbols())
+          || (object != NULL && object->just_symbols()))
         return false;
 
-      // FIXME: Do a better job of reporting locations.
-      gold_error(_("%s: multiple definition of %s"),
-		 object != NULL ? object->name().c_str() : _("command line"),
-		 to->demangled_name().c_str());
-      gold_error(_("%s: previous definition here"),
-		 (to->source() == Symbol::FROM_OBJECT
-		  ? to->object()->name().c_str()
-		  : _("command line")));
+      Symbol_table::report_resolve_problem(true,
+					   _("multiple definition of '%s'"),
+					   to, defined, object);
       return false;
 
     case WEAK_DEF * 16 + DEF:
@@ -464,8 +476,12 @@ Symbol_table::should_override(const Symbol* to, unsigned int frombits,
     case DYN_COMMON * 16 + DEF:
     case DYN_WEAK_COMMON * 16 + DEF:
       // We've seen a common symbol and now we see a definition.  The
-      // definition overrides.  FIXME: We should optionally issue, version a
-      // warning.
+      // definition overrides.
+      if (parameters->options().warn_common())
+	Symbol_table::report_resolve_problem(false,
+					     _("definition of '%s' overriding "
+					       "common"),
+					     to, defined, object);
       return true;
 
     case DEF * 16 + WEAK_DEF:
@@ -495,7 +511,12 @@ Symbol_table::should_override(const Symbol* to, unsigned int frombits,
     case DYN_COMMON * 16 + WEAK_DEF:
     case DYN_WEAK_COMMON * 16 + WEAK_DEF:
       // A weak definition does override a definition in a dynamic
-      // object.  FIXME: We should optionally issue a warning.
+      // object.
+      if (parameters->options().warn_common())
+	Symbol_table::report_resolve_problem(false,
+					     _("definition of '%s' overriding "
+					       "dynamic common definition"),
+					     to, defined, object);
       return true;
 
     case DEF * 16 + DYN_DEF:
@@ -611,6 +632,11 @@ Symbol_table::should_override(const Symbol* to, unsigned int frombits,
 
     case DEF * 16 + COMMON:
       // A common symbol does not override a definition.
+      if (parameters->options().warn_common())
+	Symbol_table::report_resolve_problem(false,
+					     _("common '%s' overridden by "
+					       "previous definition"),
+					     to, defined, object);
       return false;
 
     case WEAK_DEF * 16 + COMMON:
@@ -716,16 +742,73 @@ Symbol_table::should_override(const Symbol* to, unsigned int frombits,
     }
 }
 
+// Issue an error or warning due to symbol resolution.  IS_ERROR
+// indicates an error rather than a warning.  MSG is the error
+// message; it is expected to have a %s for the symbol name.  TO is
+// the existing symbol.  DEFINED/OBJECT is where the new symbol was
+// found.
+
+// FIXME: We should have better location information here.  When the
+// symbol is defined, we should be able to pull the location from the
+// debug info if there is any.
+
+void
+Symbol_table::report_resolve_problem(bool is_error, const char* msg,
+				     const Symbol* to, Defined defined,
+				     Object* object)
+{
+  std::string demangled(to->demangled_name());
+  size_t len = strlen(msg) + demangled.length() + 10;
+  char* buf = new char[len];
+  snprintf(buf, len, msg, demangled.c_str());
+
+  const char* objname;
+  switch (defined)
+    {
+    case OBJECT:
+      objname = object->name().c_str();
+      break;
+    case COPY:
+      objname = _("COPY reloc");
+      break;
+    case DEFSYM:
+    case UNDEFINED:
+      objname = _("command line");
+      break;
+    case SCRIPT:
+      objname = _("linker script");
+      break;
+    case PREDEFINED:
+      objname = _("linker defined");
+      break;
+    default:
+      gold_unreachable();
+    }
+
+  if (is_error)
+    gold_error("%s: %s", objname, buf);
+  else
+    gold_warning("%s: %s", objname, buf);
+
+  delete[] buf;
+
+  if (to->source() == Symbol::FROM_OBJECT)
+    objname = to->object()->name().c_str();
+  else
+    objname = _("command line");
+  gold_info("%s: %s: previous definition here", program_name, objname);
+}
+
 // A special case of should_override which is only called for a strong
 // defined symbol from a regular object file.  This is used when
 // defining special symbols.
 
 bool
-Symbol_table::should_override_with_special(const Symbol* to)
+Symbol_table::should_override_with_special(const Symbol* to, Defined defined)
 {
   bool adjust_common_sizes;
   unsigned int frombits = global_flag | regular_flag | def_flag;
-  bool ret = Symbol_table::should_override(to, frombits, NULL,
+  bool ret = Symbol_table::should_override(to, frombits, defined, NULL,
 					   &adjust_common_sizes);
   gold_assert(!adjust_common_sizes);
   return ret;
@@ -774,9 +857,8 @@ Symbol::override_base_with_special(const Symbol* from)
 
   // We shouldn't see these flags.  If we do, we need to handle them
   // somehow.
-  gold_assert(!from->is_target_special_ || this->is_target_special_);
   gold_assert(!from->is_forwarder_);
-  gold_assert(!from->has_plt_offset_);
+  gold_assert(!from->has_plt_offset());
   gold_assert(!from->has_warning_);
   gold_assert(!from->is_copied_from_dynobj_);
   gold_assert(!from->is_forced_local_);
@@ -829,7 +911,10 @@ Symbol_table::override_with_special(Sized_symbol<size>* tosym,
 // script to restrict this to only the ones needed for implemented
 // targets.
 
-#ifdef HAVE_TARGET_32_LITTLE
+// We have to instantiate both big and little endian versions because
+// these are used by other templates that depends on size only.
+
+#if defined(HAVE_TARGET_32_LITTLE) || defined(HAVE_TARGET_32_BIG)
 template
 void
 Symbol_table::resolve<32, false>(
@@ -840,9 +925,7 @@ Symbol_table::resolve<32, false>(
     unsigned int orig_st_shndx,
     Object* object,
     const char* version);
-#endif
 
-#ifdef HAVE_TARGET_32_BIG
 template
 void
 Symbol_table::resolve<32, true>(
@@ -855,7 +938,7 @@ Symbol_table::resolve<32, true>(
     const char* version);
 #endif
 
-#ifdef HAVE_TARGET_64_LITTLE
+#if defined(HAVE_TARGET_64_LITTLE) || defined(HAVE_TARGET_64_BIG)
 template
 void
 Symbol_table::resolve<64, false>(
@@ -866,9 +949,7 @@ Symbol_table::resolve<64, false>(
     unsigned int orig_st_shndx,
     Object* object,
     const char* version);
-#endif
 
-#ifdef HAVE_TARGET_64_BIG
 template
 void
 Symbol_table::resolve<64, true>(
diff --git a/gold/script-c.h b/gold/script-c.h
index 37016b0..77b4aa4 100644
--- a/gold/script-c.h
+++ b/gold/script-c.h
@@ -61,6 +61,18 @@ typedef Expression* Expression_ptr;
 typedef void* Expression_ptr;
 #endif
 
+/* Script_section type.  */
+enum Script_section_type
+{
+  /* No section type.  */
+  SCRIPT_SECTION_TYPE_NONE,
+  SCRIPT_SECTION_TYPE_NOLOAD,
+  SCRIPT_SECTION_TYPE_DSECT,
+  SCRIPT_SECTION_TYPE_COPY,
+  SCRIPT_SECTION_TYPE_INFO,
+  SCRIPT_SECTION_TYPE_OVERLAY
+};
+
 /* A constraint for whether to use a particular output section
    definition.  */
 
@@ -83,6 +95,8 @@ struct Parser_output_section_header
 {
   /* The address.  This may be NULL.  */
   Expression_ptr address;
+  /* Section type.  May be NULL string.  */ 
+  enum Script_section_type section_type;
   /* The load address, from the AT specifier.  This may be NULL.  */
   Expression_ptr load_address;
   /* The alignment, from the ALIGN specifier.  This may be NULL.  */
@@ -389,6 +403,11 @@ script_data_segment_align(void* closure);
 extern void
 script_data_segment_relro_end(void* closure);
 
+/* Record the fact that a SEGMENT_START expression is seen.  */
+
+extern void
+script_saw_segment_start_expression(void* closure);
+
 /* Called by the bison parser for expressions.  */
 
 extern Expression_ptr
diff --git a/gold/script-sections.cc b/gold/script-sections.cc
index a541e9a..45e98b0 100644
--- a/gold/script-sections.cc
+++ b/gold/script-sections.cc
@@ -337,7 +337,8 @@ class Sections_element
   // section name.  This only real implementation is in
   // Output_section_definition.
   virtual const char*
-  output_section_name(const char*, const char*, Output_section***)
+  output_section_name(const char*, const char*, Output_section***,
+		      Script_sections::Section_type*)
   { return NULL; }
 
   // Initialize OSP with an output section.
@@ -349,7 +350,8 @@ class Sections_element
   // Set section addresses.  This includes applying assignments if the
   // the expression is an absolute value.
   virtual void
-  set_section_addresses(Symbol_table*, Layout*, uint64_t*, uint64_t*)
+  set_section_addresses(Symbol_table*, Layout*, uint64_t*, uint64_t*,
+			uint64_t*)
   { }
 
   // Check a constraint (ONLY_IF_RO, etc.) on an output section.  If
@@ -406,7 +408,7 @@ class Sections_element_assignment : public Sections_element
  public:
   Sections_element_assignment(const char* name, size_t namelen,
 			      Expression* val, bool provide, bool hidden)
-    : assignment_(name, namelen, val, provide, hidden)
+    : assignment_(name, namelen, false, val, provide, hidden)
   { }
 
   // Add the symbol to the symbol table.
@@ -427,7 +429,7 @@ class Sections_element_assignment : public Sections_element
   // absolute symbols when setting dot.
   void
   set_section_addresses(Symbol_table* symtab, Layout* layout,
-			uint64_t* dot_value, uint64_t*)
+			uint64_t* dot_value, uint64_t*, uint64_t*)
   {
     this->assignment_.set_if_absolute(symtab, layout, true, *dot_value);
   }
@@ -464,17 +466,18 @@ class Sections_element_dot_assignment : public Sections_element
     // to be absolute.
     Output_section* dummy;
     *dot_value = this->val_->eval_with_dot(symtab, layout, true, *dot_value,
-					   NULL, &dummy);
+					   NULL, &dummy, NULL);
   }
 
   // Update the dot symbol while setting section addresses.
   void
   set_section_addresses(Symbol_table* symtab, Layout* layout,
-			uint64_t* dot_value, uint64_t* load_address)
+			uint64_t* dot_value, uint64_t* dot_alignment,
+			uint64_t* load_address)
   {
     Output_section* dummy;
     *dot_value = this->val_->eval_with_dot(symtab, layout, false, *dot_value,
-					   NULL, &dummy);
+					   NULL, &dummy, dot_alignment);
     *load_address = *dot_value;
   }
 
@@ -557,7 +560,7 @@ class Output_section_element
   // the expression is an absolute value.
   virtual void
   set_section_addresses(Symbol_table*, Layout*, Output_section*, uint64_t,
-			uint64_t*, Output_section**, std::string*,
+			uint64_t*, uint64_t*, Output_section**, std::string*,
 			Input_section_list*)
   { }
 
@@ -593,7 +596,7 @@ class Output_section_element_assignment : public Output_section_element
   Output_section_element_assignment(const char* name, size_t namelen,
 				    Expression* val, bool provide,
 				    bool hidden)
-    : assignment_(name, namelen, val, provide, hidden)
+    : assignment_(name, namelen, false, val, provide, hidden)
   { }
 
   // Add the symbol to the symbol table.
@@ -615,8 +618,8 @@ class Output_section_element_assignment : public Output_section_element
   // absolute symbols when setting dot.
   void
   set_section_addresses(Symbol_table* symtab, Layout* layout, Output_section*,
-			uint64_t, uint64_t* dot_value, Output_section**,
-			std::string*, Input_section_list*)
+			uint64_t, uint64_t* dot_value, uint64_t*,
+			Output_section**, std::string*, Input_section_list*)
   {
     this->assignment_.set_if_absolute(symtab, layout, true, *dot_value);
   }
@@ -648,14 +651,14 @@ class Output_section_element_dot_assignment : public Output_section_element
 		   uint64_t* dot_value, Output_section** dot_section)
   {
     *dot_value = this->val_->eval_with_dot(symtab, layout, true, *dot_value,
-					   *dot_section, dot_section);
+					   *dot_section, dot_section, NULL);
   }
 
   // Update the dot symbol while setting section addresses.
   void
   set_section_addresses(Symbol_table* symtab, Layout* layout, Output_section*,
-			uint64_t, uint64_t* dot_value, Output_section**,
-			std::string*, Input_section_list*);
+			uint64_t, uint64_t* dot_value, uint64_t*,
+			Output_section**, std::string*, Input_section_list*);
 
   // Print for debugging.
   void
@@ -679,13 +682,14 @@ Output_section_element_dot_assignment::set_section_addresses(
     Output_section* output_section,
     uint64_t,
     uint64_t* dot_value,
+    uint64_t* dot_alignment,
     Output_section** dot_section,
     std::string* fill,
     Input_section_list*)
 {
   uint64_t next_dot = this->val_->eval_with_dot(symtab, layout, false,
 						*dot_value, *dot_section,
-						dot_section);
+						dot_section, dot_alignment);
   if (next_dot < *dot_value)
     gold_error(_("dot may not move backward"));
   if (next_dot > *dot_value && output_section != NULL)
@@ -787,7 +791,7 @@ Output_data_expression::do_write_to_buffer(unsigned char* buf)
   Output_section* dummy;
   uint64_t val = this->val_->eval_with_dot(this->symtab_, this->layout_,
 					   true, this->dot_value_,
-					   this->dot_section_, &dummy);
+					   this->dot_section_, &dummy, NULL);
 
   if (parameters->target().is_big_endian())
     this->endian_write_to_buffer<true>(val, buf);
@@ -848,8 +852,8 @@ class Output_section_element_data : public Output_section_element
   // Store the value in the section.
   void
   set_section_addresses(Symbol_table*, Layout*, Output_section*, uint64_t,
-			uint64_t* dot_value, Output_section**, std::string*,
-			Input_section_list*);
+			uint64_t* dot_value, uint64_t*, Output_section**,
+			std::string*, Input_section_list*);
 
   // Print for debugging.
   void
@@ -873,6 +877,7 @@ Output_section_element_data::set_section_addresses(
     Output_section* os,
     uint64_t,
     uint64_t* dot_value,
+    uint64_t*,
     Output_section** dot_section,
     std::string*,
     Input_section_list*)
@@ -929,14 +934,14 @@ class Output_section_element_fill : public Output_section_element
   // Update the fill value while setting section addresses.
   void
   set_section_addresses(Symbol_table* symtab, Layout* layout, Output_section*,
-			uint64_t, uint64_t* dot_value,
+			uint64_t, uint64_t* dot_value, uint64_t*,
 			Output_section** dot_section,
 			std::string* fill, Input_section_list*)
   {
     Output_section* fill_section;
     uint64_t fill_val = this->val_->eval_with_dot(symtab, layout, false,
 						  *dot_value, *dot_section,
-						  &fill_section);
+						  &fill_section, NULL);
     if (fill_section != NULL)
       gold_warning(_("fill value is not absolute"));
     // FIXME: The GNU linker supports fill values of arbitrary length.
@@ -992,7 +997,7 @@ class Output_section_element_input : public Output_section_element
   // Set the section address.
   void
   set_section_addresses(Symbol_table* symtab, Layout* layout, Output_section*,
-			uint64_t subalign, uint64_t* dot_value,
+			uint64_t subalign, uint64_t* dot_value, uint64_t*,
 			Output_section**, std::string* fill,
 			Input_section_list*);
 
@@ -1289,6 +1294,7 @@ Output_section_element_input::set_section_addresses(
     Output_section* output_section,
     uint64_t subalign,
     uint64_t* dot_value,
+    uint64_t*,
     Output_section** dot_section,
     std::string* fill,
     Input_section_list* input_sections)
@@ -1409,9 +1415,9 @@ Output_section_element_input::set_section_addresses(
 	      layout->new_output_section_data_from_script(posd);
 	    }
 
-	  output_section->add_input_section_for_script(p->input_section(),
-						       p->size(),
-						       this_subalign);
+	  output_section->add_simple_input_section(p->input_section(),
+						   p->size(),
+						   this_subalign);
 
 	  dot = address + p->size();
 	}
@@ -1598,7 +1604,7 @@ class Output_section_definition : public Sections_element
   // section name.
   const char*
   output_section_name(const char* file_name, const char* section_name,
-		      Output_section***);
+		      Output_section***, Script_sections::Section_type*);
 
   // Initialize OSP with an output section.
   void
@@ -1609,7 +1615,8 @@ class Output_section_definition : public Sections_element
   // Set the section address.
   void
   set_section_addresses(Symbol_table* symtab, Layout* layout,
-			uint64_t* dot_value, uint64_t* load_address);
+			uint64_t* dot_value, uint64_t*,
+			uint64_t* load_address);
 
   // Check a constraint (ONLY_IF_RO, etc.) on an output section.  If
   // this section is constrained, and the input sections do not match,
@@ -1646,7 +1653,14 @@ class Output_section_definition : public Sections_element
   void
   print(FILE*) const;
 
+  // Return the output section type if specified or Script_sections::ST_NONE.
+  Script_sections::Section_type
+  section_type() const;
+
  private:
+  static const char*
+  script_section_type_name(Script_section_type);
+
   typedef std::vector<Output_section_element*> Output_section_elements;
 
   // The output section name.
@@ -1679,6 +1693,8 @@ class Output_section_definition : public Sections_element
   uint64_t evaluated_addralign_;
   // The output section is relro.
   bool is_relro_;
+  // The output section type if specified.
+  enum Script_section_type script_section_type_;
 };
 
 // Constructor.
@@ -1700,7 +1716,8 @@ Output_section_definition::Output_section_definition(
     evaluated_address_(0),
     evaluated_load_address_(0),
     evaluated_addralign_(0),
-    is_relro_(false)
+    is_relro_(false),
+    script_section_type_(header->section_type)
 {
 }
 
@@ -1796,7 +1813,8 @@ Output_section_definition::create_sections(Layout* layout)
       if ((*p)->needs_output_section())
 	{
 	  const char* name = this->name_.c_str();
-	  this->output_section_ = layout->make_output_section_for_script(name);
+	  this->output_section_ =
+	    layout->make_output_section_for_script(name, this->section_type());
 	  return;
 	}
     }
@@ -1830,7 +1848,7 @@ Output_section_definition::finalize_symbols(Symbol_table* symtab,
 	  Output_section* dummy;
 	  address = this->address_->eval_with_dot(symtab, layout, true,
 						  *dot_value, NULL,
-						  &dummy);
+						  &dummy, NULL);
 	}
       if (this->align_ != NULL)
 	{
@@ -1838,7 +1856,7 @@ Output_section_definition::finalize_symbols(Symbol_table* symtab,
 	  uint64_t align = this->align_->eval_with_dot(symtab, layout, true,
 						       *dot_value,
 						       NULL,
-						       &dummy);
+						       &dummy, NULL);
 	  address = align_address(address, align);
 	}
       *dot_value = address;
@@ -1854,9 +1872,11 @@ Output_section_definition::finalize_symbols(Symbol_table* symtab,
 // Return the output section name to use for an input section name.
 
 const char*
-Output_section_definition::output_section_name(const char* file_name,
-					       const char* section_name,
-					       Output_section*** slot)
+Output_section_definition::output_section_name(
+    const char* file_name,
+    const char* section_name,
+    Output_section*** slot,
+    Script_sections::Section_type *psection_type)
 {
   // Ask each element whether it matches NAME.
   for (Output_section_elements::const_iterator p = this->elements_.begin();
@@ -1868,6 +1888,7 @@ Output_section_definition::output_section_name(const char* file_name,
 	  // We found a match for NAME, which means that it should go
 	  // into this output section.
 	  *slot = &this->output_section_;
+	  *psection_type = this->section_type();
 	  return this->name_.c_str();
 	}
     }
@@ -1884,16 +1905,30 @@ void
 Output_section_definition::set_section_addresses(Symbol_table* symtab,
 						 Layout* layout,
 						 uint64_t* dot_value,
+						 uint64_t* dot_alignment,
                                                  uint64_t* load_address)
 {
   uint64_t address;
-  if (this->address_ == NULL)
-    address = *dot_value;
-  else
+  uint64_t old_dot_value = *dot_value;
+  uint64_t old_load_address = *load_address;
+
+  // Check for --section-start.
+  bool is_address_set = false;
+  if (this->output_section_ != NULL)
+    is_address_set =
+      parameters->options().section_start(this->output_section_->name(),
+                                          &address);
+  if (!is_address_set)
     {
-      Output_section* dummy;
-      address = this->address_->eval_with_dot(symtab, layout, true,
-					      *dot_value, NULL, &dummy);
+      if (this->address_ == NULL)
+        address = *dot_value;
+      else
+        {
+          Output_section* dummy;
+          address = this->address_->eval_with_dot(symtab, layout, true,
+                                                  *dot_value, NULL, &dummy,
+                                                  dot_alignment);
+        }
     }
 
   uint64_t align;
@@ -1908,7 +1943,7 @@ Output_section_definition::set_section_addresses(Symbol_table* symtab,
     {
       Output_section* align_section;
       align = this->align_->eval_with_dot(symtab, layout, true, *dot_value,
-					  NULL, &align_section);
+					  NULL, &align_section, NULL);
       if (align_section != NULL)
 	gold_warning(_("alignment of section %s is not absolute"),
 		     this->name_.c_str());
@@ -1922,10 +1957,11 @@ Output_section_definition::set_section_addresses(Symbol_table* symtab,
 
   *dot_value = address;
 
-  // The address of non-SHF_ALLOC sections is forced to zero,
-  // regardless of what the linker script wants.
+  // Except for NOLOAD sections, the address of non-SHF_ALLOC sections is
+  // forced to zero, regardless of what the linker script wants.
   if (this->output_section_ != NULL
-      && (this->output_section_->flags() & elfcpp::SHF_ALLOC) != 0)
+      && ((this->output_section_->flags() & elfcpp::SHF_ALLOC) != 0
+	  || this->output_section_->is_noload()))
     this->output_section_->set_address(address);
 
   this->evaluated_address_ = address;
@@ -1938,7 +1974,8 @@ Output_section_definition::set_section_addresses(Symbol_table* symtab,
       Output_section* dummy;
       uint64_t laddr =
 	this->load_address_->eval_with_dot(symtab, layout, true, *dot_value,
-					   this->output_section_, &dummy);
+					   this->output_section_, &dummy,
+					   NULL);
       if (this->output_section_ != NULL)
         this->output_section_->set_load_address(laddr);
       this->evaluated_load_address_ = laddr;
@@ -1952,7 +1989,7 @@ Output_section_definition::set_section_addresses(Symbol_table* symtab,
       Output_section* subalign_section;
       subalign = this->subalign_->eval_with_dot(symtab, layout, true,
 						*dot_value, NULL,
-						&subalign_section);
+						&subalign_section, NULL);
       if (subalign_section != NULL)
 	gold_warning(_("subalign of section %s is not absolute"),
 		     this->name_.c_str());
@@ -1966,8 +2003,8 @@ Output_section_definition::set_section_addresses(Symbol_table* symtab,
       Output_section* fill_section;
       uint64_t fill_val = this->fill_->eval_with_dot(symtab, layout, true,
 						     *dot_value,
-						     NULL,
-						     &fill_section);
+						     NULL, &fill_section,
+						     NULL);
       if (fill_section != NULL)
 	gold_warning(_("fill of section %s is not absolute"),
 		     this->name_.c_str());
@@ -1993,8 +2030,8 @@ Output_section_definition::set_section_addresses(Symbol_table* symtab,
        p != this->elements_.end();
        ++p)
     (*p)->set_section_addresses(symtab, layout, this->output_section_,
-				subalign, dot_value, &dot_section, &fill,
-				&input_sections);
+				subalign, dot_value, dot_alignment,
+				&dot_section, &fill, &input_sections);
 
   gold_assert(input_sections.empty());
 
@@ -2010,6 +2047,13 @@ Output_section_definition::set_section_addresses(Symbol_table* symtab,
 	this->output_section_->set_is_relro();
       else
 	this->output_section_->clear_is_relro();
+
+      // If this is a NOLOAD section, keep dot and load address unchanged.
+      if (this->output_section_->is_noload())
+	{
+	  *dot_value = old_dot_value;
+	  *load_address = old_load_address;
+	}
     }
 }
 
@@ -2107,13 +2151,16 @@ Output_section*
 Output_section_definition::allocate_to_segment(String_list** phdrs_list,
 					       bool* orphan)
 {
+  // Update phdrs_list even if we don't have an output section. It
+  // might be used by the following sections.
+  if (this->phdrs_ != NULL)
+    *phdrs_list = this->phdrs_;
+
   if (this->output_section_ == NULL)
     return NULL;
   if ((this->output_section_->flags() & elfcpp::SHF_ALLOC) == 0)
     return NULL;
   *orphan = false;
-  if (this->phdrs_ != NULL)
-    *phdrs_list = this->phdrs_;
   return this->output_section_;
 }
 
@@ -2167,6 +2214,10 @@ Output_section_definition::print(FILE* f) const
       fprintf(f, " ");
     }
 
+  if (this->script_section_type_ != SCRIPT_SECTION_TYPE_NONE)
+      fprintf(f, "(%s) ",
+	      this->script_section_type_name(this->script_section_type_));
+
   fprintf(f, ": ");
 
   if (this->load_address_ != NULL)
@@ -2216,6 +2267,52 @@ Output_section_definition::print(FILE* f) const
   fprintf(f, "\n");
 }
 
+Script_sections::Section_type
+Output_section_definition::section_type() const
+{
+  switch (this->script_section_type_)
+    {
+    case SCRIPT_SECTION_TYPE_NONE:
+      return Script_sections::ST_NONE;
+    case SCRIPT_SECTION_TYPE_NOLOAD:
+      return Script_sections::ST_NOLOAD;
+    case SCRIPT_SECTION_TYPE_COPY:
+    case SCRIPT_SECTION_TYPE_DSECT:
+    case SCRIPT_SECTION_TYPE_INFO:
+    case SCRIPT_SECTION_TYPE_OVERLAY:
+      // There are not really support so we treat them as ST_NONE.  The
+      // parse should have issued errors for them already.
+      return Script_sections::ST_NONE;
+    default:
+      gold_unreachable();
+    }
+}
+
+// Return the name of a script section type.
+
+const char*
+Output_section_definition::script_section_type_name (
+    Script_section_type script_section_type)
+{
+  switch (script_section_type)
+    {
+    case SCRIPT_SECTION_TYPE_NONE:
+      return "NONE";
+    case SCRIPT_SECTION_TYPE_NOLOAD:
+      return "NOLOAD";
+    case SCRIPT_SECTION_TYPE_DSECT:
+      return "DSECT";
+    case SCRIPT_SECTION_TYPE_COPY:
+      return "COPY";
+    case SCRIPT_SECTION_TYPE_INFO:
+      return "INFO";
+    case SCRIPT_SECTION_TYPE_OVERLAY:
+      return "OVERLAY";
+    default:
+      gold_unreachable();
+    }
+}
+
 // An output section created to hold orphaned input sections.  These
 // do not actually appear in linker scripts.  However, for convenience
 // when setting the output section addresses, we put a marker to these
@@ -2244,7 +2341,8 @@ class Orphan_output_section : public Sections_element
 
   // Set section addresses.
   void
-  set_section_addresses(Symbol_table*, Layout*, uint64_t*, uint64_t*);
+  set_section_addresses(Symbol_table*, Layout*, uint64_t*, uint64_t*,
+			uint64_t*);
 
   // Get the list of segments to use for an allocated section when
   // using a PHDRS clause.
@@ -2273,6 +2371,7 @@ class Orphan_output_section : public Sections_element
 void
 Orphan_output_section::set_section_addresses(Symbol_table*, Layout*,
 					     uint64_t* dot_value,
+					     uint64_t*,
                                              uint64_t* load_address)
 {
   typedef std::list<Output_section::Simple_input_section> Input_section_list;
@@ -2315,7 +2414,7 @@ Orphan_output_section::set_section_addresses(Symbol_table*, Layout*,
       }
 
       address = align_address(address, addralign);
-      this->os_->add_input_section_for_script(*p, size, addralign);
+      this->os_->add_simple_input_section(*p, size, addralign);
       address += size;
     }
 
@@ -2487,7 +2586,8 @@ Script_sections::Script_sections()
     orphan_section_placement_(NULL),
     data_segment_align_start_(),
     saw_data_segment_align_(false),
-    saw_relro_end_(false)
+    saw_relro_end_(false),
+    saw_segment_start_expression_(false)
 {
 }
 
@@ -2704,16 +2804,19 @@ Script_sections::finalize_symbols(Symbol_table* symtab, const Layout* layout)
 // and section name.
 
 const char*
-Script_sections::output_section_name(const char* file_name,
-				     const char* section_name,
-				     Output_section*** output_section_slot)
+Script_sections::output_section_name(
+    const char* file_name,
+    const char* section_name,
+    Output_section*** output_section_slot,
+    Script_sections::Section_type *psection_type)
 {
   for (Sections_elements::const_iterator p = this->sections_elements_->begin();
        p != this->sections_elements_->end();
        ++p)
     {
       const char* ret = (*p)->output_section_name(file_name, section_name,
-						  output_section_slot);
+						  output_section_slot,
+						  psection_type);
 
       if (ret != NULL)
 	{
@@ -2722,6 +2825,7 @@ Script_sections::output_section_name(const char* file_name,
 	  if (strcmp(ret, "/DISCARD/") == 0)
 	    {
 	      *output_section_slot = NULL;
+	      *psection_type = Script_sections::ST_NONE;
 	      return NULL;
 	    }
 	  return ret;
@@ -2732,6 +2836,7 @@ Script_sections::output_section_name(const char* file_name,
   // gets the name of the input section.
 
   *output_section_slot = NULL;
+  *psection_type = Script_sections::ST_NONE;
 
   return section_name;
 }
@@ -2849,11 +2954,55 @@ Script_sections::set_section_addresses(Symbol_table* symtab, Layout* layout)
 
   // For a relocatable link, we implicitly set dot to zero.
   uint64_t dot_value = 0;
+  uint64_t dot_alignment = 0;
   uint64_t load_address = 0;
+
+  // Check to see if we want to use any of -Ttext, -Tdata and -Tbss options
+  // to set section addresses.  If the script has any SEGMENT_START
+  // expression, we do not set the section addresses.
+  bool use_tsection_options =
+    (!this->saw_segment_start_expression_
+     && (parameters->options().user_set_Ttext()
+	 || parameters->options().user_set_Tdata()
+	 || parameters->options().user_set_Tbss()));
+
   for (Sections_elements::iterator p = this->sections_elements_->begin();
        p != this->sections_elements_->end();
        ++p)
-    (*p)->set_section_addresses(symtab, layout, &dot_value, &load_address);
+    {
+      Output_section* os = (*p)->get_output_section();
+
+      // Handle -Ttext, -Tdata and -Tbss options.  We do this by looking for
+      // the special sections by names and doing dot assignments. 
+      if (use_tsection_options
+	  && os != NULL
+	  && (os->flags() & elfcpp::SHF_ALLOC) != 0)
+	{
+	  uint64_t new_dot_value = dot_value;
+
+	  if (parameters->options().user_set_Ttext()
+	      && strcmp(os->name(), ".text") == 0)
+	    new_dot_value = parameters->options().Ttext();
+	  else if (parameters->options().user_set_Tdata()
+	      && strcmp(os->name(), ".data") == 0)
+	    new_dot_value = parameters->options().Tdata();
+	  else if (parameters->options().user_set_Tbss()
+	      && strcmp(os->name(), ".bss") == 0)
+	    new_dot_value = parameters->options().Tbss();
+
+	  // Update dot and load address if necessary.
+	  if (new_dot_value < dot_value)
+	    gold_error(_("dot may not move backward"));
+	  else if (new_dot_value != dot_value)
+	    {
+	      dot_value = new_dot_value;
+	      load_address = new_dot_value;
+	    }
+	}
+
+      (*p)->set_section_addresses(symtab, layout, &dot_value, &dot_alignment,
+				  &load_address);
+    } 
 
   if (this->phdrs_elements_ != NULL)
     {
@@ -2863,7 +3012,7 @@ Script_sections::set_section_addresses(Symbol_table* symtab, Layout* layout)
 	(*p)->eval_load_address(symtab, layout);
     }
 
-  return this->create_segments(layout);
+  return this->create_segments(layout, dot_alignment);
 }
 
 // Sort the sections in order to put them into segments.
@@ -2905,6 +3054,12 @@ Sort_output_sections::operator()(const Output_section* os1,
   if (os1->type() == elfcpp::SHT_NOBITS && os2->type() == elfcpp::SHT_PROGBITS)
     return false;
 
+  // Sort non-NOLOAD before NOLOAD.
+  if (os1->is_noload() && !os2->is_noload())
+    return true;
+  if (!os1->is_noload() && os2->is_noload())
+    return true;
+  
   // Otherwise we don't care.
   return false;
 }
@@ -2965,7 +3120,7 @@ Script_sections::header_size_adjustment(uint64_t lma,
 // if any.
 
 Output_segment*
-Script_sections::create_segments(Layout* layout)
+Script_sections::create_segments(Layout* layout, uint64_t dot_alignment)
 {
   gold_assert(this->saw_sections_clause_);
 
@@ -2973,7 +3128,7 @@ Script_sections::create_segments(Layout* layout)
     return NULL;
 
   if (this->saw_phdrs_clause())
-    return create_segments_from_phdrs_clause(layout);
+    return create_segments_from_phdrs_clause(layout, dot_alignment);
 
   Layout::Section_list sections;
   layout->get_allocated_sections(&sections);
@@ -3046,12 +3201,13 @@ Script_sections::create_segments(Layout* layout)
 	  current_seg = layout->make_output_segment(elfcpp::PT_LOAD,
 						    seg_flags);
 	  current_seg->set_addresses(vma, lma);
+	  current_seg->set_minimum_p_align(dot_alignment);
 	  if (first_seg == NULL)
 	    first_seg = current_seg;
 	  is_current_seg_readonly = true;
 	}
 
-      current_seg->add_output_section(*p, seg_flags);
+      current_seg->add_output_section(*p, seg_flags, false);
 
       if (((*p)->flags() & elfcpp::SHF_WRITE) != 0)
 	is_current_seg_readonly = false;
@@ -3130,7 +3286,7 @@ Script_sections::create_note_and_tls_segments(
 	    Layout::section_flags_to_segment((*p)->flags());
 	  Output_segment* oseg = layout->make_output_segment(elfcpp::PT_NOTE,
 							     seg_flags);
-	  oseg->add_output_section(*p, seg_flags);
+	  oseg->add_output_section(*p, seg_flags, false);
 
 	  // Incorporate any subsequent SHT_NOTE sections, in the
 	  // hopes that the script is sensible.
@@ -3139,7 +3295,7 @@ Script_sections::create_note_and_tls_segments(
 		 && (*pnext)->type() == elfcpp::SHT_NOTE)
 	    {
 	      seg_flags = Layout::section_flags_to_segment((*pnext)->flags());
-	      oseg->add_output_section(*pnext, seg_flags);
+	      oseg->add_output_section(*pnext, seg_flags, false);
 	      p = pnext;
 	      ++pnext;
 	    }
@@ -3154,14 +3310,14 @@ Script_sections::create_note_and_tls_segments(
 	    Layout::section_flags_to_segment((*p)->flags());
 	  Output_segment* oseg = layout->make_output_segment(elfcpp::PT_TLS,
 							     seg_flags);
-	  oseg->add_output_section(*p, seg_flags);
+	  oseg->add_output_section(*p, seg_flags, false);
 
 	  Layout::Section_list::const_iterator pnext = p + 1;
 	  while (pnext != sections->end()
 		 && ((*pnext)->flags() & elfcpp::SHF_TLS) != 0)
 	    {
 	      seg_flags = Layout::section_flags_to_segment((*pnext)->flags());
-	      oseg->add_output_section(*pnext, seg_flags);
+	      oseg->add_output_section(*pnext, seg_flags, false);
 	      p = pnext;
 	      ++pnext;
 	    }
@@ -3239,10 +3395,11 @@ Script_sections::expected_segment_count(const Layout* layout) const
 // should hold the file header and program headers, if any.
 
 Output_segment*
-Script_sections::create_segments_from_phdrs_clause(Layout* layout)
+Script_sections::create_segments_from_phdrs_clause(Layout* layout,
+						   uint64_t dot_alignment)
 {
   this->attach_sections_using_phdrs_clause(layout);
-  return this->set_phdrs_clause_addresses(layout);
+  return this->set_phdrs_clause_addresses(layout, dot_alignment);
 }
 
 // Create the segments from the PHDRS clause, and put the output
@@ -3315,7 +3472,7 @@ Script_sections::attach_sections_using_phdrs_clause(Layout* layout)
 
 	      elfcpp::Elf_Word seg_flags =
 		Layout::section_flags_to_segment(os->flags());
-	      r->second->add_output_section(os, seg_flags);
+	      r->second->add_output_section(os, seg_flags, false);
 
 	      if (r->second->type() == elfcpp::PT_LOAD)
 		{
@@ -3336,7 +3493,8 @@ Script_sections::attach_sections_using_phdrs_clause(Layout* layout)
 // if any.
 
 Output_segment*
-Script_sections::set_phdrs_clause_addresses(Layout* layout)
+Script_sections::set_phdrs_clause_addresses(Layout* layout,
+					    uint64_t dot_alignment)
 {
   Output_segment* load_seg = NULL;
   for (Phdrs_elements::const_iterator p = this->phdrs_elements_->begin();
@@ -3359,6 +3517,8 @@ Script_sections::set_phdrs_clause_addresses(Layout* layout)
 	  continue;
 	}
 
+      oseg->set_minimum_p_align(dot_alignment);
+
       // The output sections should have addresses from the SECTIONS
       // clause.  The addresses don't have to be in order, so find the
       // one with the lowest load address.  Use that to set the
diff --git a/gold/script-sections.h b/gold/script-sections.h
index b326eae..f18b06c 100644
--- a/gold/script-sections.h
+++ b/gold/script-sections.h
@@ -52,6 +52,20 @@ class Script_sections
   typedef std::list<Sections_element*> Sections_elements;
 
  public:
+
+  // Logical script section types.  We map section types returned by the
+  // parser into these since some section types have the same semantics.
+  enum Section_type
+  {
+    // No section type specified.
+    ST_NONE,
+    // Section is NOLOAD.  We allocate space in the output but section
+    // is not loaded in runtime.
+    ST_NOLOAD,
+    // No space is allocated to section.
+    ST_NOALLOC
+  };
+
   Script_sections();
 
   // Start a SECTIONS clause.
@@ -147,9 +161,13 @@ class Script_sections
   // 3) If the input section is not mapped by the SECTIONS clause,
   //    this returns SECTION_NAME, and sets *OUTPUT_SECTION_SLOT to
   //    NULL.
+  // PSCRIPT_SECTION_TYPE points to a location for returning the section
+  // type specified in script.  This can be SCRIPT_SECTION_TYPE_NONE if
+  // no type is specified.
   const char*
   output_section_name(const char* file_name, const char* section_name,
-		      Output_section*** output_section_slot);
+		      Output_section*** output_section_slot,
+		      Section_type* pscript_section_type);
 
   // Place a marker for an orphan output section into the SECTIONS
   // clause.
@@ -191,6 +209,17 @@ class Script_sections
   void
   release_segments();
 
+  // Whether we ever saw a SEGMENT_START expression, the presence of which
+  // changes the behaviour of -Ttext, -Tdata and -Tbss options.
+  bool
+  saw_segment_start_expression() const
+  { return this->saw_segment_start_expression_; }
+
+  // Set the flag which indicates whether we saw a SEGMENT_START expression.
+  void
+  set_saw_segment_start_expression(bool value)
+  { this->saw_segment_start_expression_ = value; }
+
   // Print the contents to the FILE.  This is for debugging.
   void
   print(FILE*) const;
@@ -203,7 +232,7 @@ class Script_sections
 
   // Create segments.
   Output_segment*
-  create_segments(Layout*);
+  create_segments(Layout*, uint64_t);
 
   // Create PT_NOTE and PT_TLS segments.
   void
@@ -224,7 +253,7 @@ class Script_sections
 
   // Create the segments from a PHDRS clause.
   Output_segment*
-  create_segments_from_phdrs_clause(Layout* layout);
+  create_segments_from_phdrs_clause(Layout* layout, uint64_t);
 
   // Attach sections to segments from a PHDRS clause.
   void
@@ -232,7 +261,7 @@ class Script_sections
 
   // Set addresses of segments from a PHDRS clause.
   Output_segment*
-  set_phdrs_clause_addresses(Layout*);
+  set_phdrs_clause_addresses(Layout*, uint64_t);
 
   // True if we ever saw a SECTIONS clause.
   bool saw_sections_clause_;
@@ -253,6 +282,8 @@ class Script_sections
   bool saw_data_segment_align_;
   // Whether we have seen DATA_SEGMENT_RELRO_END.
   bool saw_relro_end_;
+  // Whether we have seen SEGMENT_START.
+  bool saw_segment_start_expression_;
 };
 
 } // End namespace gold.
diff --git a/gold/script.cc b/gold/script.cc
index d0ffe41..279cf5f 100644
--- a/gold/script.cc
+++ b/gold/script.cc
@@ -874,6 +874,9 @@ Symbol_assignment::add_to_table(Symbol_table* symtab)
   elfcpp::STV vis = this->hidden_ ? elfcpp::STV_HIDDEN : elfcpp::STV_DEFAULT;
   this->sym_ = symtab->define_as_constant(this->name_.c_str(),
 					  NULL, // version
+					  (this->is_defsym_
+					   ? Symbol_table::DEFSYM
+					   : Symbol_table::SCRIPT),
 					  0, // value
 					  0, // size
 					  elfcpp::STT_NOTYPE,
@@ -952,7 +955,7 @@ Symbol_assignment::sized_finalize(Symbol_table* symtab, const Layout* layout,
   uint64_t final_val = this->val_->eval_maybe_dot(symtab, layout, true,
 						  is_dot_available,
 						  dot_value, dot_section,
-						  &section);
+						  &section, NULL);
   Sized_symbol<size>* ssym = symtab->get_sized_symbol<size>(this->sym_);
   ssym->set_value(final_val);
   if (section != NULL)
@@ -971,7 +974,7 @@ Symbol_assignment::set_if_absolute(Symbol_table* symtab, const Layout* layout,
   Output_section* val_section;
   uint64_t val = this->val_->eval_maybe_dot(symtab, layout, false,
 					    is_dot_available, dot_value,
-					    NULL, &val_section);
+					    NULL, &val_section, NULL);
   if (val_section != NULL)
     return;
 
@@ -1051,18 +1054,21 @@ Script_options::Script_options()
 
 void
 Script_options::add_symbol_assignment(const char* name, size_t length,
-				      Expression* value, bool provide,
-				      bool hidden)
+				      bool is_defsym, Expression* value,
+				      bool provide, bool hidden)
 {
   if (length != 1 || name[0] != '.')
     {
       if (this->script_sections_.in_sections_clause())
-	this->script_sections_.add_symbol_assignment(name, length, value,
-						     provide, hidden);
-      else
 	{
-	  Symbol_assignment* p = new Symbol_assignment(name, length, value,
+	  gold_assert(!is_defsym);
+	  this->script_sections_.add_symbol_assignment(name, length, value,
 						       provide, hidden);
+	}
+      else
+	{
+	  Symbol_assignment* p = new Symbol_assignment(name, length, is_defsym,
+						       value, provide, hidden);
 	  this->symbol_assignments_.push_back(p);
 	}
     }
@@ -1162,13 +1168,14 @@ class Parser_closure
  public:
   Parser_closure(const char* filename,
 		 const Position_dependent_options& posdep_options,
-		 bool in_group, bool is_in_sysroot,
+		 bool parsing_defsym, bool in_group, bool is_in_sysroot,
                  Command_line* command_line,
 		 Script_options* script_options,
 		 Lex* lex,
 		 bool skip_on_incompatible_target)
     : filename_(filename), posdep_options_(posdep_options),
-      in_group_(in_group), is_in_sysroot_(is_in_sysroot),
+      parsing_defsym_(parsing_defsym), in_group_(in_group),
+      is_in_sysroot_(is_in_sysroot),
       skip_on_incompatible_target_(skip_on_incompatible_target),
       found_incompatible_target_(false),
       command_line_(command_line), script_options_(script_options),
@@ -1191,6 +1198,11 @@ class Parser_closure
   position_dependent_options()
   { return this->posdep_options_; }
 
+  // Whether we are parsing a --defsym.
+  bool
+  parsing_defsym() const
+  { return this->parsing_defsym_; }
+
   // Return whether this script is being run in a group.
   bool
   in_group() const
@@ -1322,6 +1334,8 @@ class Parser_closure
   const char* filename_;
   // The position dependent options.
   Position_dependent_options posdep_options_;
+  // True if we are parsing a --defsym.
+  bool parsing_defsym_;
   // Whether we are currently in a --start-group/--end-group.
   bool in_group_;
   // Whether the script was found in a sysrooted directory.
@@ -1374,6 +1388,7 @@ read_input_script(Workqueue* workqueue, Symbol_table* symtab, Layout* layout,
 
   Parser_closure closure(input_file->filename().c_str(),
 			 input_argument->file().options(),
+			 false,
 			 input_group != NULL,
 			 input_file->is_in_sysroot(),
                          NULL,
@@ -1469,6 +1484,7 @@ read_script_file(const char* filename, Command_line* cmdline,
 
   Parser_closure closure(filename,
 			 cmdline->position_dependent_options(),
+			 first_token == Lex::DYNAMIC_LIST,
 			 false,
 			 input_file.is_in_sysroot(),
                          cmdline,
@@ -1532,8 +1548,8 @@ Script_options::define_symbol(const char* definition)
   // Dummy value.
   Position_dependent_options posdep_options;
 
-  Parser_closure closure("command line", posdep_options, false, false, NULL,
-			 this, &lex, false);
+  Parser_closure closure("command line", posdep_options, true,
+			 false, false, NULL, this, &lex, false);
 
   if (yyparse(&closure) != 0)
     return false;
@@ -1619,11 +1635,13 @@ script_keyword_parsecodes[] =
   { "BYTE", BYTE },
   { "CONSTANT", CONSTANT },
   { "CONSTRUCTORS", CONSTRUCTORS },
+  { "COPY", COPY },
   { "CREATE_OBJECT_SYMBOLS", CREATE_OBJECT_SYMBOLS },
   { "DATA_SEGMENT_ALIGN", DATA_SEGMENT_ALIGN },
   { "DATA_SEGMENT_END", DATA_SEGMENT_END },
   { "DATA_SEGMENT_RELRO_END", DATA_SEGMENT_RELRO_END },
   { "DEFINED", DEFINED },
+  { "DSECT", DSECT },
   { "ENTRY", ENTRY },
   { "EXCLUDE_FILE", EXCLUDE_FILE },
   { "EXTERN", EXTERN },
@@ -1633,6 +1651,7 @@ script_keyword_parsecodes[] =
   { "GROUP", GROUP },
   { "HLL", HLL },
   { "INCLUDE", INCLUDE },
+  { "INFO", INFO },
   { "INHIBIT_COMMON_ALLOCATION", INHIBIT_COMMON_ALLOCATION },
   { "INPUT", INPUT },
   { "KEEP", KEEP },
@@ -1646,6 +1665,7 @@ script_keyword_parsecodes[] =
   { "NEXT", NEXT },
   { "NOCROSSREFS", NOCROSSREFS },
   { "NOFLOAT", NOFLOAT },
+  { "NOLOAD", NOLOAD },
   { "ONLY_IF_RO", ONLY_IF_RO },
   { "ONLY_IF_RW", ONLY_IF_RW },
   { "OPTION", OPTION },
@@ -2266,8 +2286,9 @@ script_set_symbol(void* closurev, const char* name, size_t length,
   Parser_closure* closure = static_cast<Parser_closure*>(closurev);
   const bool provide = providei != 0;
   const bool hidden = hiddeni != 0;
-  closure->script_options()->add_symbol_assignment(name, length, value,
-						   provide, hidden);
+  closure->script_options()->add_symbol_assignment(name, length,
+						   closure->parsing_defsym(),
+						   value, provide, hidden);
   closure->clear_skip_on_incompatible_target();
 }
 
@@ -2362,7 +2383,7 @@ script_add_search_dir(void* closurev, const char* option, size_t length)
     gold_warning(_("%s:%d:%d: ignoring SEARCH_DIR; SEARCH_DIR is only valid"
 		   " for scripts specified via -T/--script"),
 		 closure->filename(), closure->lineno(), closure->charpos());
-  else
+  else if (!closure->command_line()->options().nostdlib())
     {
       std::string s = "-L" + std::string(option, length);
       script_parse_option(closurev, s.c_str(), s.size());
@@ -2739,3 +2760,11 @@ script_phdr_string_to_type(void* closurev, const char* name, size_t namelen)
   yyerror(closurev, _("unknown PHDR type (try integer)"));
   return elfcpp::PT_NULL;
 }
+
+extern "C" void
+script_saw_segment_start_expression(void* closurev)
+{
+  Parser_closure* closure = static_cast<Parser_closure*>(closurev);
+  Script_sections* ss = closure->script_options()->script_sections();
+  ss->set_saw_segment_start_expression(true);
+}
diff --git a/gold/script.h b/gold/script.h
index 755bb79..82a0648 100644
--- a/gold/script.h
+++ b/gold/script.h
@@ -84,11 +84,14 @@ class Expression
   // value is defined.  If the value is absolute *RESULT_SECTION will
   // be NULL.  Note that the returned value is still an absolute
   // value; to get a section relative value the caller must subtract
-  // the section address.
+  // the section address.  If RESULT_ALIGNMENT is not NULL, this sets
+  // *RESULT_ALIGNMENT to the alignment of the value of that alignment
+  // is larger than *RESULT_ALIGNMENT; this will only be non-zero if
+  // this is an ALIGN expression.
   uint64_t
   eval_with_dot(const Symbol_table*, const Layout*, bool check_assertions,
 		uint64_t dot_value, Output_section* dot_section,
-		Output_section** result_section);
+		Output_section** result_section, uint64_t* result_alignment);
 
   // Return the value of an expression which may or may not be
   // permitted to refer to the dot symbol, depending on
@@ -97,7 +100,7 @@ class Expression
   eval_maybe_dot(const Symbol_table*, const Layout*, bool check_assertions,
 		 bool is_dot_available, uint64_t dot_value,
 		 Output_section* dot_section,
-		 Output_section** result_section);
+		 Output_section** result_section, uint64_t* result_alignment);
 
   // Print the expression to the FILE.  This is for debugging.
   virtual void
@@ -200,10 +203,10 @@ class Version_script_info
 class Symbol_assignment
 {
  public:
-  Symbol_assignment(const char* name, size_t namelen, Expression* val,
-		    bool provide, bool hidden)
-    : name_(name, namelen), val_(val), provide_(provide), hidden_(hidden),
-      sym_(NULL)
+  Symbol_assignment(const char* name, size_t namelen, bool is_defsym,
+		    Expression* val, bool provide, bool hidden)
+    : name_(name, namelen), val_(val), is_defsym_(is_defsym),
+      provide_(provide), hidden_(hidden), sym_(NULL)
   { }
 
   // Add the symbol to the symbol table.
@@ -246,6 +249,9 @@ class Symbol_assignment
   std::string name_;
   // Expression to assign to symbol.
   Expression* val_;
+  // True if this symbol is defined by a --defsym, false if it is
+  // defined in a linker script.
+  bool is_defsym_;
   // Whether the assignment should be provided (only set if there is
   // an undefined reference to the symbol.
   bool provide_;
@@ -298,8 +304,8 @@ class Script_options
 
   // Add a symbol to be defined.
   void
-  add_symbol_assignment(const char* name, size_t length, Expression* value,
-			bool provide, bool hidden);
+  add_symbol_assignment(const char* name, size_t length, bool is_defsym,
+			Expression* value, bool provide, bool hidden);
 
   // Add an assertion.
   void
diff --git a/gold/sparc.cc b/gold/sparc.cc
index eac983f..c6eb28e 100644
--- a/gold/sparc.cc
+++ b/gold/sparc.cc
@@ -67,8 +67,7 @@ class Target_sparc : public Sized_target<size, big_endian>
   // Process the relocations to determine unreferenced sections for 
   // garbage collection.
   void
-  gc_process_relocs(const General_options& options,
-	            Symbol_table* symtab,
+  gc_process_relocs(Symbol_table* symtab,
 	            Layout* layout,
 	            Sized_relobj<size, big_endian>* object,
 	            unsigned int data_shndx,
@@ -82,8 +81,7 @@ class Target_sparc : public Sized_target<size, big_endian>
 
   // Scan the relocations to look for symbol adjustments.
   void
-  scan_relocs(const General_options& options,
-	      Symbol_table* symtab,
+  scan_relocs(Symbol_table* symtab,
 	      Layout* layout,
 	      Sized_relobj<size, big_endian>* object,
 	      unsigned int data_shndx,
@@ -96,7 +94,7 @@ class Target_sparc : public Sized_target<size, big_endian>
 	      const unsigned char* plocal_symbols);
   // Finalize the sections.
   void
-  do_finalize_sections(Layout*);
+  do_finalize_sections(Layout*, const Input_objects*, Symbol_table*);
 
   // Return the value to use for a dynamic which requires special
   // treatment.
@@ -118,8 +116,7 @@ class Target_sparc : public Sized_target<size, big_endian>
 
   // Scan the relocs during a relocatable link.
   void
-  scan_relocatable_relocs(const General_options& options,
-			  Symbol_table* symtab,
+  scan_relocatable_relocs(Symbol_table* symtab,
 			  Layout* layout,
 			  Sized_relobj<size, big_endian>* object,
 			  unsigned int data_shndx,
@@ -181,8 +178,7 @@ class Target_sparc : public Sized_target<size, big_endian>
     { }
 
     inline void
-    local(const General_options& options, Symbol_table* symtab,
-	  Layout* layout, Target_sparc* target,
+    local(Symbol_table* symtab, Layout* layout, Target_sparc* target,
 	  Sized_relobj<size, big_endian>* object,
 	  unsigned int data_shndx,
 	  Output_section* output_section,
@@ -190,8 +186,7 @@ class Target_sparc : public Sized_target<size, big_endian>
 	  const elfcpp::Sym<size, big_endian>& lsym);
 
     inline void
-    global(const General_options& options, Symbol_table* symtab,
-	   Layout* layout, Target_sparc* target,
+    global(Symbol_table* symtab, Layout* layout, Target_sparc* target,
 	   Sized_relobj<size, big_endian>* object,
 	   unsigned int data_shndx,
 	   Output_section* output_section,
@@ -366,7 +361,9 @@ Target::Target_info Target_sparc<32, true>::sparc_info =
   elfcpp::SHN_UNDEF,	// small_common_shndx
   elfcpp::SHN_UNDEF,	// large_common_shndx
   0,			// small_common_section_flags
-  0			// large_common_section_flags
+  0,			// large_common_section_flags
+  NULL,			// attributes_section
+  NULL			// attributes_vendor
 };
 
 template<>
@@ -387,7 +384,9 @@ Target::Target_info Target_sparc<64, true>::sparc_info =
   elfcpp::SHN_UNDEF,	// small_common_shndx
   elfcpp::SHN_UNDEF,	// large_common_shndx
   0,			// small_common_section_flags
-  0			// large_common_section_flags
+  0,			// large_common_section_flags
+  NULL,			// attributes_section
+  NULL			// attributes_vendor
 };
 
 // We have to take care here, even when operating in little-endian
@@ -1027,11 +1026,12 @@ Target_sparc<size, big_endian>::got_section(Symbol_table* symtab,
       os = layout->add_output_section_data(".got", elfcpp::SHT_PROGBITS,
 					   (elfcpp::SHF_ALLOC
 					    | elfcpp::SHF_WRITE),
-					   this->got_);
-      os->set_is_relro();
+					   this->got_, false, true, false,
+					   false);
 
       // Define _GLOBAL_OFFSET_TABLE_ at the start of the .got section.
       symtab->define_in_output_data("_GLOBAL_OFFSET_TABLE_", NULL,
+				    Symbol_table::PREDEFINED,
 				    this->got_,
 				    0, 0, elfcpp::STT_OBJECT,
 				    elfcpp::STB_LOCAL,
@@ -1053,7 +1053,8 @@ Target_sparc<size, big_endian>::rela_dyn_section(Layout* layout)
       gold_assert(layout != NULL);
       this->rela_dyn_ = new Reloc_section(parameters->options().combreloc());
       layout->add_output_section_data(".rela.dyn", elfcpp::SHT_RELA,
-				      elfcpp::SHF_ALLOC, this->rela_dyn_);
+				      elfcpp::SHF_ALLOC, this->rela_dyn_, true,
+				      false, false, false);
     }
   return this->rela_dyn_;
 }
@@ -1155,7 +1156,8 @@ Output_data_plt_sparc<size, big_endian>::Output_data_plt_sparc(Layout* layout)
 {
   this->rel_ = new Reloc_section(false);
   layout->add_output_section_data(".rela.plt", elfcpp::SHT_RELA,
-				  elfcpp::SHF_ALLOC, this->rel_);
+				  elfcpp::SHF_ALLOC, this->rel_, true,
+				  false, false, false);
 }
 
 template<int size, bool big_endian>
@@ -1372,10 +1374,11 @@ Target_sparc<size, big_endian>::make_plt_entry(Symbol_table* symtab,
 				      (elfcpp::SHF_ALLOC
 				       | elfcpp::SHF_EXECINSTR
 				       | elfcpp::SHF_WRITE),
-				      this->plt_);
+				      this->plt_, false, false, false, false);
 
       // Define _PROCEDURE_LINKAGE_TABLE_ at the start of the .plt section.
       symtab->define_in_output_data("_PROCEDURE_LINKAGE_TABLE_", NULL,
+				    Symbol_table::PREDEFINED,
 				    this->plt_,
 				    0, 0, elfcpp::STT_OBJECT,
 				    elfcpp::STB_LOCAL,
@@ -1600,7 +1603,6 @@ Target_sparc<size, big_endian>::Scan::check_non_pic(Relobj* object, unsigned int
 template<int size, bool big_endian>
 inline void
 Target_sparc<size, big_endian>::Scan::local(
-			const General_options&,
 			Symbol_table* symtab,
 			Layout* layout,
 			Target_sparc<size, big_endian>* target,
@@ -1902,7 +1904,6 @@ Target_sparc<size, big_endian>::Scan::unsupported_reloc_global(
 template<int size, bool big_endian>
 inline void
 Target_sparc<size, big_endian>::Scan::global(
-				const General_options&,
 				Symbol_table* symtab,
 				Layout* layout,
 				Target_sparc<size, big_endian>* target,
@@ -2250,7 +2251,6 @@ Target_sparc<size, big_endian>::Scan::global(
 template<int size, bool big_endian>
 void
 Target_sparc<size, big_endian>::gc_process_relocs(
-			const General_options& options,
 			Symbol_table* symtab,
 			Layout* layout,
 			Sized_relobj<size, big_endian>* object,
@@ -2267,7 +2267,6 @@ Target_sparc<size, big_endian>::gc_process_relocs(
   typedef typename Target_sparc<size, big_endian>::Scan Scan;
 
   gold::gc_process_relocs<size, big_endian, Sparc, elfcpp::SHT_RELA, Scan>(
-    options,
     symtab,
     layout,
     this,
@@ -2286,7 +2285,6 @@ Target_sparc<size, big_endian>::gc_process_relocs(
 template<int size, bool big_endian>
 void
 Target_sparc<size, big_endian>::scan_relocs(
-			const General_options& options,
 			Symbol_table* symtab,
 			Layout* layout,
 			Sized_relobj<size, big_endian>* object,
@@ -2310,7 +2308,6 @@ Target_sparc<size, big_endian>::scan_relocs(
     }
 
   gold::scan_relocs<size, big_endian, Sparc, elfcpp::SHT_RELA, Scan>(
-    options,
     symtab,
     layout,
     this,
@@ -2328,7 +2325,10 @@ Target_sparc<size, big_endian>::scan_relocs(
 
 template<int size, bool big_endian>
 void
-Target_sparc<size, big_endian>::do_finalize_sections(Layout* layout)
+Target_sparc<size, big_endian>::do_finalize_sections(
+    Layout* layout,
+    const Input_objects*,
+    Symbol_table*)
 {
   // Fill in some more dynamic tags.
   Output_data_dynamic* const odyn = layout->dynamic_data();
@@ -3149,7 +3149,6 @@ Target_sparc<size, big_endian>::Relocatable_size_for_reloc::get_size_for_reloc(
 template<int size, bool big_endian>
 void
 Target_sparc<size, big_endian>::scan_relocatable_relocs(
-			const General_options& options,
 			Symbol_table* symtab,
 			Layout* layout,
 			Sized_relobj<size, big_endian>* object,
@@ -3170,7 +3169,6 @@ Target_sparc<size, big_endian>::scan_relocatable_relocs(
 
   gold::scan_relocatable_relocs<size, big_endian, elfcpp::SHT_RELA,
       Scan_relocatable_relocs>(
-    options,
     symtab,
     layout,
     object,
diff --git a/gold/stringpool.cc b/gold/stringpool.cc
index 05d1d68..d9f4050 100644
--- a/gold/stringpool.cc
+++ b/gold/stringpool.cc
@@ -153,16 +153,7 @@ size_t
 Stringpool_template<Stringpool_char>::string_hash(const Stringpool_char* s,
 						  size_t length)
 {
-  // This is the hash function used by the dynamic linker for
-  // DT_GNU_HASH entries.  I compared this to a Fowler/Noll/Vo hash
-  // for a C++ program with 385,775 global symbols.  This hash
-  // function was very slightly worse.  However, it is much faster to
-  // compute.  Overall wall clock time was a win.
-  const unsigned char* p = reinterpret_cast<const unsigned char*>(s);
-  size_t h = 5381;
-  for (size_t i = 0; i < length * sizeof(Stringpool_char); ++i)
-    h = h * 33 + *p++;
-  return h;
+  return gold::string_hash<Stringpool_char>(s, length);
 }
 
 // Add the string S to the list of canonical strings.  Return a
diff --git a/gold/symtab.cc b/gold/symtab.cc
index 5dbab35..455bd4d 100644
--- a/gold/symtab.cc
+++ b/gold/symtab.cc
@@ -59,24 +59,23 @@ Symbol::init_fields(const char* name, const char* version,
   this->symtab_index_ = 0;
   this->dynsym_index_ = 0;
   this->got_offsets_.init();
-  this->plt_offset_ = 0;
+  this->plt_offset_ = -1U;
   this->type_ = type;
   this->binding_ = binding;
   this->visibility_ = visibility;
   this->nonvis_ = nonvis;
-  this->is_target_special_ = false;
   this->is_def_ = false;
   this->is_forwarder_ = false;
   this->has_alias_ = false;
   this->needs_dynsym_entry_ = false;
   this->in_reg_ = false;
   this->in_dyn_ = false;
-  this->has_plt_offset_ = false;
   this->has_warning_ = false;
   this->is_copied_from_dynobj_ = false;
   this->is_forced_local_ = false;
   this->is_ordinary_shndx_ = false;
   this->in_real_elf_ = false;
+  this->is_defined_in_discarded_section_ = false;
 }
 
 // Return the demangled version of the symbol's name, but only
@@ -1069,10 +1068,14 @@ Symbol_table::add_from_relobj(
 
       // A symbol defined in a section which we are not including must
       // be treated as an undefined symbol.
+      bool is_defined_in_discarded_section = false;
       if (st_shndx != elfcpp::SHN_UNDEF
 	  && is_ordinary
 	  && !relobj->is_section_included(st_shndx))
-	st_shndx = elfcpp::SHN_UNDEF;
+	{
+	  st_shndx = elfcpp::SHN_UNDEF;
+	  is_defined_in_discarded_section = true;
+	}
 
       // In an object file, an '@' in the name separates the symbol
       // name from the version name.  If there are two '@' characters,
@@ -1187,6 +1190,9 @@ Symbol_table::add_from_relobj(
       if (local)
 	this->force_local(res);
 
+      if (is_defined_in_discarded_section)
+	res->set_is_defined_in_discarded_section();
+
       (*sympointers)[i] = res;
     }
 }
@@ -1684,6 +1690,7 @@ Symbol_table::define_special_symbol(const char** pname, const char** pversion,
 Symbol*
 Symbol_table::define_in_output_data(const char* name,
 				    const char* version,
+				    Defined defined,
 				    Output_data* od,
 				    uint64_t value,
 				    uint64_t symsize,
@@ -1697,7 +1704,7 @@ Symbol_table::define_in_output_data(const char* name,
   if (parameters->target().get_size() == 32)
     {
 #if defined(HAVE_TARGET_32_LITTLE) || defined(HAVE_TARGET_32_BIG)
-      return this->do_define_in_output_data<32>(name, version, od,
+      return this->do_define_in_output_data<32>(name, version, defined, od,
                                                 value, symsize, type, binding,
                                                 visibility, nonvis,
                                                 offset_is_from_end,
@@ -1709,7 +1716,7 @@ Symbol_table::define_in_output_data(const char* name,
   else if (parameters->target().get_size() == 64)
     {
 #if defined(HAVE_TARGET_64_LITTLE) || defined(HAVE_TARGET_64_BIG)
-      return this->do_define_in_output_data<64>(name, version, od,
+      return this->do_define_in_output_data<64>(name, version, defined, od,
                                                 value, symsize, type, binding,
                                                 visibility, nonvis,
                                                 offset_is_from_end,
@@ -1729,6 +1736,7 @@ Sized_symbol<size>*
 Symbol_table::do_define_in_output_data(
     const char* name,
     const char* version,
+    Defined defined,
     Output_data* od,
     typename elfcpp::Elf_types<size>::Elf_Addr value,
     typename elfcpp::Elf_types<size>::Elf_WXword symsize,
@@ -1780,7 +1788,7 @@ Symbol_table::do_define_in_output_data(
       return sym;
     }
 
-  if (Symbol_table::should_override_with_special(oldsym))
+  if (Symbol_table::should_override_with_special(oldsym, defined))
     this->override_with_special(oldsym, sym);
 
   if (resolve_oldsym)
@@ -1796,7 +1804,9 @@ Symbol_table::do_define_in_output_data(
 
 Symbol*
 Symbol_table::define_in_output_segment(const char* name,
-				       const char* version, Output_segment* os,
+				       const char* version,
+				       Defined defined,
+				       Output_segment* os,
 				       uint64_t value,
 				       uint64_t symsize,
 				       elfcpp::STT type,
@@ -1809,7 +1819,7 @@ Symbol_table::define_in_output_segment(const char* name,
   if (parameters->target().get_size() == 32)
     {
 #if defined(HAVE_TARGET_32_LITTLE) || defined(HAVE_TARGET_32_BIG)
-      return this->do_define_in_output_segment<32>(name, version, os,
+      return this->do_define_in_output_segment<32>(name, version, defined, os,
                                                    value, symsize, type,
                                                    binding, visibility, nonvis,
                                                    offset_base, only_if_ref);
@@ -1820,7 +1830,7 @@ Symbol_table::define_in_output_segment(const char* name,
   else if (parameters->target().get_size() == 64)
     {
 #if defined(HAVE_TARGET_64_LITTLE) || defined(HAVE_TARGET_64_BIG)
-      return this->do_define_in_output_segment<64>(name, version, os,
+      return this->do_define_in_output_segment<64>(name, version, defined, os,
                                                    value, symsize, type,
                                                    binding, visibility, nonvis,
                                                    offset_base, only_if_ref);
@@ -1839,6 +1849,7 @@ Sized_symbol<size>*
 Symbol_table::do_define_in_output_segment(
     const char* name,
     const char* version,
+    Defined defined,
     Output_segment* os,
     typename elfcpp::Elf_types<size>::Elf_Addr value,
     typename elfcpp::Elf_types<size>::Elf_WXword symsize,
@@ -1890,7 +1901,7 @@ Symbol_table::do_define_in_output_segment(
       return sym;
     }
 
-  if (Symbol_table::should_override_with_special(oldsym))
+  if (Symbol_table::should_override_with_special(oldsym, defined))
     this->override_with_special(oldsym, sym);
 
   if (resolve_oldsym)
@@ -1908,6 +1919,7 @@ Symbol_table::do_define_in_output_segment(
 Symbol*
 Symbol_table::define_as_constant(const char* name,
 				 const char* version,
+				 Defined defined,
 				 uint64_t value,
 				 uint64_t symsize,
 				 elfcpp::STT type,
@@ -1920,7 +1932,7 @@ Symbol_table::define_as_constant(const char* name,
   if (parameters->target().get_size() == 32)
     {
 #if defined(HAVE_TARGET_32_LITTLE) || defined(HAVE_TARGET_32_BIG)
-      return this->do_define_as_constant<32>(name, version, value,
+      return this->do_define_as_constant<32>(name, version, defined, value,
                                              symsize, type, binding,
                                              visibility, nonvis, only_if_ref,
                                              force_override);
@@ -1931,7 +1943,7 @@ Symbol_table::define_as_constant(const char* name,
   else if (parameters->target().get_size() == 64)
     {
 #if defined(HAVE_TARGET_64_LITTLE) || defined(HAVE_TARGET_64_BIG)
-      return this->do_define_as_constant<64>(name, version, value,
+      return this->do_define_as_constant<64>(name, version, defined, value,
                                              symsize, type, binding,
                                              visibility, nonvis, only_if_ref,
                                              force_override);
@@ -1950,6 +1962,7 @@ Sized_symbol<size>*
 Symbol_table::do_define_as_constant(
     const char* name,
     const char* version,
+    Defined defined,
     typename elfcpp::Elf_types<size>::Elf_Addr value,
     typename elfcpp::Elf_types<size>::Elf_WXword symsize,
     elfcpp::STT type,
@@ -2006,7 +2019,8 @@ Symbol_table::do_define_as_constant(
       return sym;
     }
 
-  if (force_override || Symbol_table::should_override_with_special(oldsym))
+  if (force_override
+      || Symbol_table::should_override_with_special(oldsym, defined))
     this->override_with_special(oldsym, sym);
 
   if (resolve_oldsym)
@@ -2029,14 +2043,14 @@ Symbol_table::define_symbols(const Layout* layout, int count,
     {
       Output_section* os = layout->find_output_section(p->output_section);
       if (os != NULL)
-	this->define_in_output_data(p->name, NULL, os, p->value,
+	this->define_in_output_data(p->name, NULL, PREDEFINED, os, p->value,
 				    p->size, p->type, p->binding,
 				    p->visibility, p->nonvis,
 				    p->offset_is_from_end,
 				    only_if_ref || p->only_if_ref);
       else
-	this->define_as_constant(p->name, NULL, 0, p->size, p->type,
-				 p->binding, p->visibility, p->nonvis,
+	this->define_as_constant(p->name, NULL, PREDEFINED, 0, p->size,
+				 p->type, p->binding, p->visibility, p->nonvis,
 				 only_if_ref || p->only_if_ref,
                                  false);
     }
@@ -2055,14 +2069,14 @@ Symbol_table::define_symbols(const Layout* layout, int count,
 						       p->segment_flags_set,
 						       p->segment_flags_clear);
       if (os != NULL)
-	this->define_in_output_segment(p->name, NULL, os, p->value,
+	this->define_in_output_segment(p->name, NULL, PREDEFINED, os, p->value,
 				       p->size, p->type, p->binding,
 				       p->visibility, p->nonvis,
 				       p->offset_base,
 				       only_if_ref || p->only_if_ref);
       else
-	this->define_as_constant(p->name, NULL, 0, p->size, p->type,
-				 p->binding, p->visibility, p->nonvis,
+	this->define_as_constant(p->name, NULL, PREDEFINED, 0, p->size,
+				 p->type, p->binding, p->visibility, p->nonvis,
 				 only_if_ref || p->only_if_ref,
                                  false);
     }
@@ -2091,7 +2105,7 @@ Symbol_table::define_with_copy_reloc(
   if (binding == elfcpp::STB_WEAK)
     binding = elfcpp::STB_GLOBAL;
 
-  this->define_in_output_data(csym->name(), csym->version(),
+  this->define_in_output_data(csym->name(), csym->version(), COPY,
 			      posd, value, csym->symsize(),
 			      csym->type(), binding,
 			      csym->visibility(), csym->nonvis(),
@@ -2405,7 +2419,6 @@ Symbol_table::compute_final_value(
 	  {
 	    Relobj* relobj = static_cast<Relobj*>(symobj);
 	    Output_section* os = relobj->output_section(shndx);
-            uint64_t secoff64 = relobj->output_section_offset(shndx);
 
             if (this->is_section_folded(relobj, shndx))
               {
@@ -2415,11 +2428,17 @@ Symbol_table::compute_final_value(
                                                                    shndx);
                 gold_assert(folded.first != NULL);
                 Relobj* folded_obj = reinterpret_cast<Relobj*>(folded.first);
-                os = folded_obj->output_section(folded.second);  
+		unsigned folded_shndx = folded.second;
+
+                os = folded_obj->output_section(folded_shndx);  
                 gold_assert(os != NULL);
-                secoff64 = folded_obj->output_section_offset(folded.second);
+
+		// Replace (relobj, shndx) with canonical ICF input section.
+		shndx = folded_shndx;
+		relobj = folded_obj;
               }
 
+            uint64_t secoff64 = relobj->output_section_offset(shndx);
  	    if (os == NULL)
 	      {
                 bool static_or_reloc = (parameters->doing_static_link() ||
diff --git a/gold/symtab.h b/gold/symtab.h
index d1cd647..4595db6 100644
--- a/gold/symtab.h
+++ b/gold/symtab.h
@@ -1,6 +1,6 @@
 // symtab.h -- the gold symbol table   -*- C++ -*-
 
-// Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
+// Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
 // Written by Ian Lance Taylor <iant@google.com>.
 
 // This file is part of gold.
@@ -298,6 +298,18 @@ class Symbol
   set_in_real_elf()
   { this->in_real_elf_ = true; }
 
+  // Return whether this symbol was defined in a section that was
+  // discarded from the link.  This is used to control some error
+  // reporting.
+  bool
+  is_defined_in_discarded_section() const
+  { return this->is_defined_in_discarded_section_; }
+
+  // Mark this symbol as having been defined in a discarded section.
+  void
+  set_is_defined_in_discarded_section()
+  { this->is_defined_in_discarded_section_ = true; }
+
   // Return the index of this symbol in the output file symbol table.
   // A value of -1U means that this symbol is not going into the
   // output file.  This starts out as zero, and is set to a non-zero
@@ -373,7 +385,7 @@ class Symbol
   // Return whether this symbol has an entry in the PLT section.
   bool
   has_plt_offset() const
-  { return this->has_plt_offset_; }
+  { return this->plt_offset_ != -1U; }
 
   // Return the offset into the PLT section of this symbol.
   unsigned int
@@ -387,7 +399,7 @@ class Symbol
   void
   set_plt_offset(unsigned int plt_offset)
   {
-    this->has_plt_offset_ = true;
+    gold_assert(plt_offset != -1U);
     this->plt_offset_ = plt_offset;
   }
 
@@ -860,16 +872,14 @@ class Symbol
   // non-zero value during Layout::finalize.
   unsigned int dynsym_index_;
 
-  // If this symbol has an entry in the GOT section (has_got_offset_
-  // is true), this holds the offset from the start of the GOT section.
-  // A symbol may have more than one GOT offset (e.g., when mixing
-  // modules compiled with two different TLS models), but will usually
-  // have at most one.
+  // The GOT section entries for this symbol.  A symbol may have more
+  // than one GOT offset (e.g., when mixing modules compiled with two
+  // different TLS models), but will usually have at most one.
   Got_offset_list got_offsets_;
 
-  // If this symbol has an entry in the PLT section (has_plt_offset_
-  // is true), then this is the offset from the start of the PLT
-  // section.
+  // If this symbol has an entry in the PLT section, then this is the
+  // offset from the start of the PLT section.  This is -1U if there
+  // is no PLT entry.
   unsigned int plt_offset_;
 
   // Symbol type (bits 0 to 3).
@@ -882,10 +892,7 @@ class Symbol
   unsigned int nonvis_ : 6;
   // The type of symbol (bits 16 to 18).
   Source source_ : 3;
-  // True if this symbol always requires special target-specific
-  // handling (bit 19).
-  bool is_target_special_ : 1;
-  // True if this is the default version of the symbol (bit 20).
+  // True if this is the default version of the symbol (bit 19).
   bool is_def_ : 1;
   // True if this symbol really forwards to another symbol.  This is
   // used when we discover after the fact that two different entries
@@ -893,37 +900,38 @@ class Symbol
   // never be set for a symbol found in the hash table, but may be set
   // for a symbol found in the list of symbols attached to an Object.
   // It forwards to the symbol found in the forwarders_ map of
-  // Symbol_table (bit 21).
+  // Symbol_table (bit 20).
   bool is_forwarder_ : 1;
   // True if the symbol has an alias in the weak_aliases table in
-  // Symbol_table (bit 22).
+  // Symbol_table (bit 21).
   bool has_alias_ : 1;
   // True if this symbol needs to be in the dynamic symbol table (bit
-  // 23).
+  // 22).
   bool needs_dynsym_entry_ : 1;
-  // True if we've seen this symbol in a regular object (bit 24).
+  // True if we've seen this symbol in a regular object (bit 23).
   bool in_reg_ : 1;
-  // True if we've seen this symbol in a dynamic object (bit 25).
+  // True if we've seen this symbol in a dynamic object (bit 24).
   bool in_dyn_ : 1;
-  // True if the symbol has an entry in the PLT section (bit 26).
-  bool has_plt_offset_ : 1;
   // True if this is a dynamic symbol which needs a special value in
-  // the dynamic symbol table (bit 27).
+  // the dynamic symbol table (bit 25).
   bool needs_dynsym_value_ : 1;
-  // True if there is a warning for this symbol (bit 28).
+  // True if there is a warning for this symbol (bit 26).
   bool has_warning_ : 1;
   // True if we are using a COPY reloc for this symbol, so that the
-  // real definition lives in a dynamic object (bit 29).
+  // real definition lives in a dynamic object (bit 27).
   bool is_copied_from_dynobj_ : 1;
   // True if this symbol was forced to local visibility by a version
-  // script (bit 30).
+  // script (bit 28).
   bool is_forced_local_ : 1;
   // True if the field u_.from_object.shndx is an ordinary section
   // index, not one of the special codes from SHN_LORESERVE to
-  // SHN_HIRESERVE (bit 31).
+  // SHN_HIRESERVE (bit 29).
   bool is_ordinary_shndx_ : 1;
-  // True if we've seen this symbol in a real ELF object.
+  // True if we've seen this symbol in a real ELF object (bit 30).
   bool in_real_elf_ : 1;
+  // True if this symbol is defined in a section which was discarded
+  // (bit 31).
+  bool is_defined_in_discarded_section_ : 1;
 };
 
 // The parts of a symbol which are size specific.  Using a template
@@ -1168,6 +1176,31 @@ class Warnings
 class Symbol_table
 {
  public:
+  // The different places where a symbol definition can come from.
+  enum Defined
+  {
+    // Defined in an object file--the normal case.
+    OBJECT,
+    // Defined for a COPY reloc.
+    COPY,
+    // Defined on the command line using --defsym.
+    DEFSYM,
+    // Defined (so to speak) on the command line using -u.
+    UNDEFINED,
+    // Defined in a linker script.
+    SCRIPT,
+    // Predefined by the linker.
+    PREDEFINED,
+  };
+
+  // The order in which we sort common symbols.
+  enum Sort_commons_order
+  {
+    SORT_COMMONS_BY_SIZE_DESCENDING,
+    SORT_COMMONS_BY_ALIGNMENT_DESCENDING,
+    SORT_COMMONS_BY_ALIGNMENT_ASCENDING
+  };
+
   // COUNT is an estimate of how many symbosl will be inserted in the
   // symbol table.  It's ok to put 0 if you don't know; a correct
   // guess will just save some CPU by reducing hashtable resizes.
@@ -1249,7 +1282,7 @@ class Symbol_table
   // Define a special symbol based on an Output_data.  It is a
   // multiple definition error if this symbol is already defined.
   Symbol*
-  define_in_output_data(const char* name, const char* version,
+  define_in_output_data(const char* name, const char* version, Defined,
 			Output_data*, uint64_t value, uint64_t symsize,
 			elfcpp::STT type, elfcpp::STB binding,
 			elfcpp::STV visibility, unsigned char nonvis,
@@ -1258,7 +1291,7 @@ class Symbol_table
   // Define a special symbol based on an Output_segment.  It is a
   // multiple definition error if this symbol is already defined.
   Symbol*
-  define_in_output_segment(const char* name, const char* version,
+  define_in_output_segment(const char* name, const char* version, Defined,
 			   Output_segment*, uint64_t value, uint64_t symsize,
 			   elfcpp::STT type, elfcpp::STB binding,
 			   elfcpp::STV visibility, unsigned char nonvis,
@@ -1267,7 +1300,7 @@ class Symbol_table
   // Define a special symbol with a constant value.  It is a multiple
   // definition error if this symbol is already defined.
   Symbol*
-  define_as_constant(const char* name, const char* version,
+  define_as_constant(const char* name, const char* version, Defined,
 		     uint64_t value, uint64_t symsize, elfcpp::STT type,
 		     elfcpp::STB binding, elfcpp::STV visibility,
 		     unsigned char nonvis, bool only_if_ref,
@@ -1486,7 +1519,12 @@ class Symbol_table
   // Whether we should override a symbol, based on flags in
   // resolve.cc.
   static bool
-  should_override(const Symbol*, unsigned int, Object*, bool*);
+  should_override(const Symbol*, unsigned int, Defined, Object*, bool*);
+
+  // Report a problem in symbol resolution.
+  static void
+  report_resolve_problem(bool is_error, const char* msg, const Symbol* to,
+			 Defined, Object* object);
 
   // Override a symbol.
   template<int size, bool big_endian>
@@ -1499,7 +1537,7 @@ class Symbol_table
   // Whether we should override a symbol with a special symbol which
   // is automatically defined by the linker.
   static bool
-  should_override_with_special(const Symbol*);
+  should_override_with_special(const Symbol*, Defined);
 
   // Override a symbol with a special symbol.
   template<int size>
@@ -1522,7 +1560,8 @@ class Symbol_table
   // Define a symbol in an Output_data, sized version.
   template<int size>
   Sized_symbol<size>*
-  do_define_in_output_data(const char* name, const char* version, Output_data*,
+  do_define_in_output_data(const char* name, const char* version, Defined,
+			   Output_data*,
 			   typename elfcpp::Elf_types<size>::Elf_Addr value,
 			   typename elfcpp::Elf_types<size>::Elf_WXword ssize,
 			   elfcpp::STT type, elfcpp::STB binding,
@@ -1533,7 +1572,7 @@ class Symbol_table
   template<int size>
   Sized_symbol<size>*
   do_define_in_output_segment(
-    const char* name, const char* version, Output_segment* os,
+    const char* name, const char* version, Defined, Output_segment* os,
     typename elfcpp::Elf_types<size>::Elf_Addr value,
     typename elfcpp::Elf_types<size>::Elf_WXword ssize,
     elfcpp::STT type, elfcpp::STB binding,
@@ -1544,7 +1583,7 @@ class Symbol_table
   template<int size>
   Sized_symbol<size>*
   do_define_as_constant(
-    const char* name, const char* version,
+    const char* name, const char* version, Defined,
     typename elfcpp::Elf_types<size>::Elf_Addr value,
     typename elfcpp::Elf_types<size>::Elf_WXword ssize,
     elfcpp::STT type, elfcpp::STB binding,
@@ -1570,13 +1609,13 @@ class Symbol_table
   // Allocate the common symbols, sized version.
   template<int size>
   void
-  do_allocate_commons(Layout*, Mapfile*);
+  do_allocate_commons(Layout*, Mapfile*, Sort_commons_order);
 
   // Allocate the common symbols from one list.
   template<int size>
   void
   do_allocate_commons_list(Layout*, Commons_section_type, Commons_type*,
-			   Mapfile*);
+			   Mapfile*, Sort_commons_order);
 
   // Implement detect_odr_violations.
   template<int size, bool big_endian>
diff --git a/gold/target-reloc.h b/gold/target-reloc.h
index bc00123..4855291 100644
--- a/gold/target-reloc.h
+++ b/gold/target-reloc.h
@@ -1,6 +1,6 @@
 // target-reloc.h -- target specific relocation support  -*- C++ -*-
 
-// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
+// Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
 // Written by Ian Lance Taylor <iant@google.com>.
 
 // This file is part of gold.
@@ -43,7 +43,6 @@ template<int size, bool big_endian, typename Target_type, int sh_type,
 	 typename Scan>
 inline void
 scan_relocs(
-    const General_options& options,
     Symbol_table* symtab,
     Layout* layout,
     Target_type* target,
@@ -104,7 +103,7 @@ scan_relocs(
 	      continue;
 	    }
 
-	  scan.local(options, symtab, layout, target, object, data_shndx,
+	  scan.local(symtab, layout, target, object, data_shndx,
 		     output_section, reloc, r_type, lsym);
 	}
       else
@@ -114,7 +113,7 @@ scan_relocs(
 	  if (gsym->is_forwarder())
 	    gsym = symtab->resolve_forwards(gsym);
 
-	  scan.global(options, symtab, layout, target, object, data_shndx,
+	  scan.global(symtab, layout, target, object, data_shndx,
 		      output_section, reloc, r_type, gsym);
 	}
     }
@@ -218,6 +217,8 @@ relocate_section(
 
       Symbol_value<size> symval;
       const Symbol_value<size> *psymval;
+      bool is_defined_in_discarded_section;
+      unsigned int shndx;
       if (r_sym < local_count
 	  && (reloc_symbol_changes == NULL
 	      || (*reloc_symbol_changes)[i] == NULL))
@@ -231,38 +232,12 @@ relocate_section(
           // counterpart in the kept section.  The symbol must not 
           // correspond to a section we are folding.
 	  bool is_ordinary;
-	  unsigned int shndx = psymval->input_shndx(&is_ordinary);
-	  if (is_ordinary
-	      && shndx != elfcpp::SHN_UNDEF
-	      && !object->is_section_included(shndx) 
-              && !(relinfo->symtab->is_section_folded(object, shndx)))
-	    {
-	      if (comdat_behavior == CB_UNDETERMINED)
-	        {
-	          std::string name = object->section_name(relinfo->data_shndx);
-	          comdat_behavior = get_comdat_behavior(name.c_str());
-	        }
-	      if (comdat_behavior == CB_PRETEND)
-	        {
-                  bool found;
-	          typename elfcpp::Elf_types<size>::Elf_Addr value =
-	            object->map_to_kept_section(shndx, &found);
-	          if (found)
-	            symval.set_output_value(value + psymval->input_value());
-                  else
-                    symval.set_output_value(0);
-	        }
-	      else
-	        {
-	          if (comdat_behavior == CB_WARNING)
-                    gold_warning_at_location(relinfo, i, offset,
-                                             _("relocation refers to discarded "
-                                               "comdat section"));
-                  symval.set_output_value(0);
-	        }
-	      symval.set_no_output_symtab_entry();
-	      psymval = &symval;
-	    }
+	  shndx = psymval->input_shndx(&is_ordinary);
+	  is_defined_in_discarded_section =
+	    (is_ordinary
+	     && shndx != elfcpp::SHN_UNDEF
+	     && !object->is_section_included(shndx)
+	     && !relinfo->symtab->is_section_folded(object, shndx));
 	}
       else
 	{
@@ -285,6 +260,46 @@ relocate_section(
 	    symval.set_no_output_symtab_entry();
 	  symval.set_output_value(sym->value());
 	  psymval = &symval;
+
+	  is_defined_in_discarded_section =
+	    (gsym->is_defined_in_discarded_section()
+	     && gsym->is_undefined());
+	  shndx = 0;
+	}
+
+      Symbol_value<size> symval2;
+      if (is_defined_in_discarded_section)
+	{
+	  if (comdat_behavior == CB_UNDETERMINED)
+	    {
+	      std::string name = object->section_name(relinfo->data_shndx);
+	      comdat_behavior = get_comdat_behavior(name.c_str());
+	    }
+	  if (comdat_behavior == CB_PRETEND)
+	    {
+	      // FIXME: This case does not work for global symbols.
+	      // We have no place to store the original section index.
+	      // Fortunately this does not matter for comdat sections,
+	      // only for sections explicitly discarded by a linker
+	      // script.
+	      bool found;
+	      typename elfcpp::Elf_types<size>::Elf_Addr value =
+		object->map_to_kept_section(shndx, &found);
+	      if (found)
+		symval2.set_output_value(value + psymval->input_value());
+	      else
+		symval2.set_output_value(0);
+	    }
+	  else
+	    {
+	      if (comdat_behavior == CB_WARNING)
+		gold_warning_at_location(relinfo, i, offset,
+					 _("relocation refers to discarded "
+					   "section"));
+	      symval2.set_output_value(0);
+	    }
+	  symval2.set_no_output_symtab_entry();
+	  psymval = &symval2;
 	}
 
       if (!relocate.relocate(relinfo, target, output_section, i, reloc,
@@ -303,6 +318,7 @@ relocate_section(
       if (sym != NULL
 	  && sym->is_undefined()
 	  && sym->binding() != elfcpp::STB_WEAK
+	  && !is_defined_in_discarded_section
           && !target->is_defined_by_abi(sym)
 	  && (!parameters->options().shared()       // -shared
               || parameters->options().defs()))     // -z defs
@@ -384,7 +400,6 @@ template<int size, bool big_endian, int sh_type,
 	 typename Scan_relocatable_reloc>
 void
 scan_relocatable_relocs(
-    const General_options&,
     Symbol_table*,
     Layout*,
     Sized_relobj<size, big_endian>* object,
diff --git a/gold/target.h b/gold/target.h
index 67397c3..05ef97e 100644
--- a/gold/target.h
+++ b/gold/target.h
@@ -41,7 +41,6 @@
 namespace gold
 {
 
-class General_options;
 class Object;
 class Relobj;
 template<int size, bool big_endian>
@@ -55,6 +54,7 @@ template<int size>
 class Sized_symbol;
 class Symbol_table;
 class Output_section;
+class Input_objects;
 
 // The abstract class for target specific handling.
 
@@ -80,6 +80,16 @@ class Target
   machine_code() const
   { return this->pti_->machine_code; }
 
+  // Processor specific flags to store in e_flags field of ELF header.
+  elfcpp::Elf_Word
+  processor_specific_flags() const
+  { return this->processor_specific_flags_; }
+
+  // Whether processor specific flags are set at least once.
+  bool
+  are_processor_specific_flags_set() const
+  { return this->are_processor_specific_flags_set_; }
+
   // Whether this target has a specific make_symbol function.
   bool
   has_make_symbol() const
@@ -184,8 +194,9 @@ class Target
   // This is called to tell the target to complete any sections it is
   // handling.  After this all sections must have their final size.
   void
-  finalize_sections(Layout* layout)
-  { return this->do_finalize_sections(layout); }
+  finalize_sections(Layout* layout, const Input_objects* input_objects,
+		    Symbol_table* symtab)
+  { return this->do_finalize_sections(layout, input_objects, symtab); }
 
   // Return the value to use for a global symbol which needs a special
   // value in the dynamic symbol table.  This will only be called if
@@ -271,6 +282,45 @@ class Target
     return this->do_relax(pass, input_objects, symtab, layout);
   } 
 
+  // Return the target-specific name of attributes section.  This is
+  // NULL if a target does not use attributes section or if it uses
+  // the default section name ".gnu.attributes".
+  const char*
+  attributes_section() const
+  { return this->pti_->attributes_section; }
+
+  // Return the vendor name of vendor attributes.
+  const char*
+  attributes_vendor() const
+  { return this->pti_->attributes_vendor; }
+
+  // Whether a section called NAME is an attribute section.
+  bool
+  is_attributes_section(const char* name) const
+  {
+    return ((this->pti_->attributes_section != NULL
+	     && strcmp(name, this->pti_->attributes_section) == 0)
+	    || strcmp(name, ".gnu.attributes") == 0); 
+  }
+
+  // Return a bit mask of argument types for attribute with TAG.
+  int
+  attribute_arg_type(int tag) const
+  { return this->do_attribute_arg_type(tag); }
+
+  // Return the attribute tag of the position NUM in the list of fixed
+  // attributes.  Normally there is no reordering and
+  // attributes_order(NUM) == NUM.
+  int
+  attributes_order(int num) const
+  { return this->do_attributes_order(num); }
+
+  // When a target is selected as the default target, we call this method,
+  // which may be used for expensive, target-specific initialization.
+  void
+  select_as_default_target()
+  { this->do_select_as_default_target(); } 
+
  protected:
   // This struct holds the constant information for a child class.  We
   // use a struct to avoid the overhead of virtual function calls for
@@ -312,10 +362,15 @@ class Target
     elfcpp::Elf_Xword small_common_section_flags;
     // Section flags for large common section.
     elfcpp::Elf_Xword large_common_section_flags;
+    // Name of attributes section if it is not ".gnu.attributes".
+    const char* attributes_section;
+    // Vendor name of vendor attributes.
+    const char* attributes_vendor;
   };
 
   Target(const Target_info* pti)
-    : pti_(pti)
+    : pti_(pti), processor_specific_flags_(0),
+      are_processor_specific_flags_set_(false)
   { }
 
   // Virtual function which may be implemented by the child class.
@@ -325,7 +380,7 @@ class Target
 
   // Virtual function which may be implemented by the child class.
   virtual void
-  do_finalize_sections(Layout*)
+  do_finalize_sections(Layout*, const Input_objects*, Symbol_table*)
   { }
 
   // Virtual function which may be implemented by the child class.
@@ -365,6 +420,14 @@ class Target
   // make_elf_object hooks.  There are four versions of these for
   // different address sizes and endianities.
 
+  // Set processor specific flags.
+  void
+  set_processor_specific_flags(elfcpp::Elf_Word flags)
+  {
+    this->processor_specific_flags_ = flags;
+    this->are_processor_specific_flags_set_ = true;
+  }
+  
 #ifdef HAVE_TARGET_32_LITTLE
   // Virtual functions which may be overriden by the child class.
   virtual Object*
@@ -420,6 +483,22 @@ class Target
   set_view_to_nop(unsigned char* view, section_size_type view_size,
 		  section_offset_type offset, size_t len) const;
 
+  // This must be overriden by the child class if it has target-specific
+  // attributes subsection in the attribute section. 
+  virtual int
+  do_attribute_arg_type(int) const
+  { gold_unreachable(); }
+
+  // This may be overridden by the child class.
+  virtual int
+  do_attributes_order(int num) const
+  { return num; }
+
+  // This may be overridden by the child class.
+  virtual void
+  do_select_as_default_target()
+  { }
+
  private:
   // The implementations of the four do_make_elf_object virtual functions are
   // almost identical except for their sizes and endianity.  We use a template.
@@ -434,6 +513,10 @@ class Target
 
   // The target information.
   const Target_info* pti_;
+  // Processor-specific flags.
+  elfcpp::Elf_Word processor_specific_flags_;
+  // Whether the processor-specific flags are set at least once.
+  bool are_processor_specific_flags_set_;
 };
 
 // The abstract class for a specific size and endianness of target.
@@ -467,34 +550,32 @@ class Sized_target : public Target
   // used to determine unreferenced garbage sections. This procedure is
   // only called during garbage collection.
   virtual void
-  gc_process_relocs(const General_options& options,
-	      Symbol_table* symtab,
-	      Layout* layout,
-	      Sized_relobj<size, big_endian>* object,
-	      unsigned int data_shndx,
-	      unsigned int sh_type,
-	      const unsigned char* prelocs,
-	      size_t reloc_count,
-	      Output_section* output_section,
-	      bool needs_special_offset_handling,
-	      size_t local_symbol_count,
-	      const unsigned char* plocal_symbols) = 0;
+  gc_process_relocs(Symbol_table* symtab,
+		    Layout* layout,
+		    Sized_relobj<size, big_endian>* object,
+		    unsigned int data_shndx,
+		    unsigned int sh_type,
+		    const unsigned char* prelocs,
+		    size_t reloc_count,
+		    Output_section* output_section,
+		    bool needs_special_offset_handling,
+		    size_t local_symbol_count,
+		    const unsigned char* plocal_symbols) = 0;
 
   // Scan the relocs for a section, and record any information
-  // required for the symbol.  OPTIONS is the command line options.
-  // SYMTAB is the symbol table.  OBJECT is the object in which the
-  // section appears.  DATA_SHNDX is the section index that these
-  // relocs apply to.  SH_TYPE is the type of the relocation section,
-  // SHT_REL or SHT_RELA.  PRELOCS points to the relocation data.
-  // RELOC_COUNT is the number of relocs.  LOCAL_SYMBOL_COUNT is the
-  // number of local symbols.  OUTPUT_SECTION is the output section.
+  // required for the symbol.  SYMTAB is the symbol table.  OBJECT is
+  // the object in which the section appears.  DATA_SHNDX is the
+  // section index that these relocs apply to.  SH_TYPE is the type of
+  // the relocation section, SHT_REL or SHT_RELA.  PRELOCS points to
+  // the relocation data.  RELOC_COUNT is the number of relocs.
+  // LOCAL_SYMBOL_COUNT is the number of local symbols.
+  // OUTPUT_SECTION is the output section.
   // NEEDS_SPECIAL_OFFSET_HANDLING is true if offsets to the output
   // sections are not mapped as usual.  PLOCAL_SYMBOLS points to the
   // local symbol data from OBJECT.  GLOBAL_SYMBOLS is the array of
   // pointers to the global symbol table from OBJECT.
   virtual void
-  scan_relocs(const General_options& options,
-	      Symbol_table* symtab,
+  scan_relocs(Symbol_table* symtab,
 	      Layout* layout,
 	      Sized_relobj<size, big_endian>* object,
 	      unsigned int data_shndx,
@@ -533,8 +614,7 @@ class Sized_target : public Target
   // like scan_relocs, with an additional Relocatable_relocs
   // parameter, used to record the disposition of the relocs.
   virtual void
-  scan_relocatable_relocs(const General_options& options,
-			  Symbol_table* symtab,
+  scan_relocatable_relocs(Symbol_table* symtab,
 			  Layout* layout,
 			  Sized_relobj<size, big_endian>* object,
 			  unsigned int data_shndx,
diff --git a/gold/testsuite/Makefile.am b/gold/testsuite/Makefile.am
index 09d7325..0771f2c 100644
--- a/gold/testsuite/Makefile.am
+++ b/gold/testsuite/Makefile.am
@@ -128,6 +128,16 @@ gc_tls_test:gc_tls_test.o gcctestdir/ld
 gc_tls_test.stdout: gc_tls_test
 	$(TEST_NM) -C gc_tls_test > gc_tls_test.stdout
 
+check_SCRIPTS += gc_orphan_section_test.sh
+check_DATA += gc_orphan_section_test.stdout
+MOSTLYCLEANFILES += gc_orphan_section_test
+gc_orphan_section_test.o: gc_orphan_section_test.cc
+	$(CXXCOMPILE) -O0 -c -g -o $@ $<
+gc_orphan_section_test:gc_orphan_section_test.o gcctestdir/ld
+	$(CXXLINK) -Bgcctestdir/ -Wl,--gc-sections gc_orphan_section_test.o
+gc_orphan_section_test.stdout: gc_orphan_section_test
+	$(TEST_NM) gc_orphan_section_test > gc_orphan_section_test.stdout
+
 check_SCRIPTS += icf_test.sh
 check_DATA += icf_test.stdout
 MOSTLYCLEANFILES += icf_test
@@ -1009,6 +1019,32 @@ script_test_5: script_test_5.o gcctestdir/ld $(srcdir)/script_test_5.t
 script_test_5.stdout: script_test_5
 	$(TEST_READELF) -SW script_test_5 > script_test_5.stdout
 
+check_SCRIPTS += script_test_6.sh
+check_DATA += script_test_6.stdout
+MOSTLYCLEANFILES += script_test_6
+script_test_6: basic_test.o gcctestdir/ld $(srcdir)/script_test_6.t
+	$(CXXLINK) -Bgcctestdir/ basic_test.o -T $(srcdir)/script_test_6.t \
+	-Wl,-Ttext=0x10001000 -Wl,-Tdata=0x10200000 -Wl,-Tbss=0x10400000
+script_test_6.stdout: script_test_6
+	$(TEST_READELF) -SlW script_test_6 > script_test_6.stdout
+
+check_SCRIPTS += script_test_7.sh
+check_DATA += script_test_7.stdout
+MOSTLYCLEANFILES += script_test_7
+script_test_7: basic_test.o gcctestdir/ld $(srcdir)/script_test_7.t
+	$(CXXLINK) -Bgcctestdir/ basic_test.o -T $(srcdir)/script_test_7.t
+script_test_7.stdout: script_test_7
+	$(TEST_READELF) -SlW script_test_7 > script_test_7.stdout
+
+check_SCRIPTS += script_test_8.sh
+check_DATA += script_test_8.stdout
+MOSTLYCLEANFILES += script_test_8
+script_test_8: basic_test.o gcctestdir/ld $(srcdir)/script_test_7.t
+	$(CXXLINK) -Bgcctestdir/ basic_test.o -T $(srcdir)/script_test_7.t \
+	-Wl,-Ttext=0x20001000 -Wl,-Tdata=0x20200000 -Wl,-Tbss=0x20400000
+script_test_8.stdout: script_test_8
+	$(TEST_READELF) -SlW script_test_8 > script_test_8.stdout
+
 # Test --dynamic-list, --dynamic-list-data, --dynamic-list-cpp-new,
 # and --dynamic-list-cpp-typeinfo
 
@@ -1301,3 +1337,22 @@ MOSTLYCLEANFILES += split_x86_64_1 split_x86_64_2 split_x86_64_3 \
 	split_x86_64_4 split_x86_64_r
 
 endif DEFAULT_TARGET_X86_64
+
+if DEFAULT_TARGET_ARM
+
+check_SCRIPTS += arm_abs_global.sh
+check_DATA += arm_abs_global.stdout
+arm_abs_lib.o: arm_abs_lib.s
+	$(TEST_AS) -march=armv7-a -o $@ $<
+libarm_abs.so: arm_abs_lib.o
+	../ld-new -shared -o $@ arm_abs_lib.o
+arm_abs_global.o: arm_abs_global.s
+	$(TEST_AS) -march=armv7-a -o $@ $<
+arm_abs_global: arm_abs_global.o libarm_abs.so
+	../ld-new -o $@ arm_abs_global.o -L. -larm_abs
+arm_abs_global.stdout: arm_abs_global
+	$(TEST_READELF) -r $< > $@
+
+MOSTLYCLEANFILES += arm_abs_global
+
+endif DEFAULT_TARGET_ARM
diff --git a/gold/testsuite/Makefile.in b/gold/testsuite/Makefile.in
index 3f5459f..fe193bc 100644
--- a/gold/testsuite/Makefile.in
+++ b/gold/testsuite/Makefile.in
@@ -55,8 +55,10 @@ check_PROGRAMS = object_unittest$(EXEEXT) binary_unittest$(EXEEXT) \
 
 # Test --dynamic-list, --dynamic-list-data, --dynamic-list-cpp-new,
 # and --dynamic-list-cpp-typeinfo
-@GCC_TRUE@@NATIVE_LINKER_TRUE@am__append_1 = gc_comdat_test.sh \
-@GCC_TRUE@@NATIVE_LINKER_TRUE@	gc_tls_test.sh icf_test.sh \
+@GCC_TRUE@@NATIVE_LINKER_TRUE@am__append_1 = incremental_test.sh \
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	gc_comdat_test.sh gc_tls_test.sh \
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	gc_orphan_section_test.sh \
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	icf_test.sh \
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	icf_keep_unique_test.sh \
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	icf_safe_test.sh \
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	two_file_shared.sh weak_plt.sh \
@@ -67,7 +69,10 @@ check_PROGRAMS = object_unittest$(EXEEXT) binary_unittest$(EXEEXT) \
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	ver_matching_test.sh \
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	script_test_3.sh \
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	script_test_4.sh \
-@GCC_TRUE@@NATIVE_LINKER_TRUE@	script_test_5.sh dynamic_list.sh
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	script_test_5.sh \
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	script_test_6.sh \
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	script_test_7.sh \
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	script_test_8.sh dynamic_list.sh
 
 # Create the data files that debug_msg.sh analyzes.
 
@@ -75,8 +80,10 @@ check_PROGRAMS = object_unittest$(EXEEXT) binary_unittest$(EXEEXT) \
 
 # We also want to make sure we do something reasonable when there's no
 # debug info available.  For the best test, we use .so's.
-@GCC_TRUE@@NATIVE_LINKER_TRUE@am__append_2 = gc_comdat_test.stdout \
+@GCC_TRUE@@NATIVE_LINKER_TRUE@am__append_2 = incremental_test.stdout \
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	gc_comdat_test.stdout \
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	gc_tls_test.stdout \
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	gc_orphan_section_test.stdout \
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	icf_test.stdout \
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	icf_keep_unique_test.stdout \
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	icf_safe_test.stdout \
@@ -92,9 +99,13 @@ check_PROGRAMS = object_unittest$(EXEEXT) binary_unittest$(EXEEXT) \
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	script_test_3.stdout \
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	script_test_4.stdout \
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	script_test_5.stdout \
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	script_test_6.stdout \
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	script_test_7.stdout \
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	script_test_8.stdout \
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	dynamic_list.stdout
-@GCC_TRUE@@NATIVE_LINKER_TRUE@am__append_3 = gc_comdat_test \
-@GCC_TRUE@@NATIVE_LINKER_TRUE@	gc_tls_test icf_test \
+@GCC_TRUE@@NATIVE_LINKER_TRUE@am__append_3 = incremental_test \
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	gc_comdat_test gc_tls_test \
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	gc_orphan_section_test icf_test \
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	icf_keep_unique_test \
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	icf_safe_test \
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	two_file_shared.dbg \
@@ -242,9 +253,10 @@ check_PROGRAMS = object_unittest$(EXEEXT) binary_unittest$(EXEEXT) \
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	ver_matching_test.stdout \
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	script_test_3.stdout \
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	script_test_4 script_test_5 \
-@GCC_TRUE@@NATIVE_LINKER_TRUE@	dynamic_list dynamic_list.stdout \
-@GCC_TRUE@@NATIVE_LINKER_TRUE@	libthin1.a libthin3.a \
-@GCC_TRUE@@NATIVE_LINKER_TRUE@	libthinall.a \
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	script_test_6 script_test_7 \
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	script_test_8 dynamic_list \
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	dynamic_list.stdout libthin1.a \
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	libthin3.a libthinall.a \
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	alt/thin_archive_test_2.o \
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	alt/thin_archive_test_4.o \
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	alt/libthin2.a alt/libthin4.a
@@ -406,6 +418,9 @@ check_PROGRAMS = object_unittest$(EXEEXT) binary_unittest$(EXEEXT) \
 @DEFAULT_TARGET_X86_64_TRUE@am__append_37 = split_x86_64_1 split_x86_64_2 split_x86_64_3 \
 @DEFAULT_TARGET_X86_64_TRUE@	split_x86_64_4 split_x86_64_r
 
+@DEFAULT_TARGET_ARM_TRUE@am__append_38 = arm_abs_global.sh
+@DEFAULT_TARGET_ARM_TRUE@am__append_39 = arm_abs_global.stdout
+@DEFAULT_TARGET_ARM_TRUE@am__append_40 = arm_abs_global
 subdir = testsuite
 DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
@@ -1451,15 +1466,16 @@ TEST_AS = $(top_builddir)/../gas/as-new
 # the right choice for files 'make' builds that people rebuild.
 MOSTLYCLEANFILES = *.so *.syms *.stdout $(am__append_3) \
 	$(am__append_8) $(am__append_17) $(am__append_25) \
-	$(am__append_29) $(am__append_34) $(am__append_37)
+	$(am__append_29) $(am__append_34) $(am__append_37) \
+	$(am__append_40)
 
 # We will add to these later, for each individual test.  Note
 # that we add each test under check_SCRIPTS or check_PROGRAMS;
 # the TESTS variable is automatically populated from these.
 check_SCRIPTS = $(am__append_1) $(am__append_23) $(am__append_27) \
-	$(am__append_32) $(am__append_35)
+	$(am__append_32) $(am__append_35) $(am__append_38)
 check_DATA = $(am__append_2) $(am__append_24) $(am__append_28) \
-	$(am__append_33) $(am__append_36)
+	$(am__append_33) $(am__append_36) $(am__append_39)
 BUILT_SOURCES = $(am__append_16)
 TESTS = $(check_SCRIPTS) $(check_PROGRAMS)
 
@@ -2621,6 +2637,14 @@ uninstall-am:
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	$(CXXCOMPILE) -O0 -g -c -o $@ $<
 @GCC_TRUE@@NATIVE_LINKER_TRUE@flagstest_ndebug.o: constructor_test.cc
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	$(CXXCOMPILE) -O0 -c -o $@ $<
+@GCC_TRUE@@NATIVE_LINKER_TRUE@incremental_test_1.o: incremental_test_1.c
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	$(COMPILE) -O0 -c -ffunction-sections -g -o $@ $<
+@GCC_TRUE@@NATIVE_LINKER_TRUE@incremental_test_2.o: incremental_test_2.c
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	$(COMPILE) -O0 -c -ffunction-sections -g -o $@ $<
+@GCC_TRUE@@NATIVE_LINKER_TRUE@incremental_test: incremental_test_1.o incremental_test_2.o gcctestdir/ld
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	$(LINK) -Bgcctestdir/ -Wl,-incremental incremental_test_1.o incremental_test_2.o -Wl,-debug 2> incremental_test.cmdline
+@GCC_TRUE@@NATIVE_LINKER_TRUE@incremental_test.stdout: incremental_test ../incremental-dump
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	../incremental-dump incremental_test > $@
 @GCC_TRUE@@NATIVE_LINKER_TRUE@gc_comdat_test_1.o: gc_comdat_test_1.cc 
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	$(CXXCOMPILE) -O0 -c -ffunction-sections -g -o $@ $<
 @GCC_TRUE@@NATIVE_LINKER_TRUE@gc_comdat_test_2.o: gc_comdat_test_2.cc 
@@ -2635,6 +2659,12 @@ uninstall-am:
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	$(CXXLINK) -Bgcctestdir/ -Wl,--gc-sections gc_tls_test.o
 @GCC_TRUE@@NATIVE_LINKER_TRUE@gc_tls_test.stdout: gc_tls_test
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	$(TEST_NM) -C gc_tls_test > gc_tls_test.stdout
+@GCC_TRUE@@NATIVE_LINKER_TRUE@gc_orphan_section_test.o: gc_orphan_section_test.cc
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	$(CXXCOMPILE) -O0 -c -g -o $@ $<
+@GCC_TRUE@@NATIVE_LINKER_TRUE@gc_orphan_section_test:gc_orphan_section_test.o gcctestdir/ld
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	$(CXXLINK) -Bgcctestdir/ -Wl,--gc-sections gc_orphan_section_test.o
+@GCC_TRUE@@NATIVE_LINKER_TRUE@gc_orphan_section_test.stdout: gc_orphan_section_test
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	$(TEST_NM) gc_orphan_section_test > gc_orphan_section_test.stdout
 @GCC_TRUE@@NATIVE_LINKER_TRUE@icf_test.o: icf_test.cc 
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	$(CXXCOMPILE) -O0 -c -ffunction-sections -g -o $@ $<
 @GCC_TRUE@@NATIVE_LINKER_TRUE@icf_test: icf_test.o gcctestdir/ld
@@ -2972,6 +3002,20 @@ uninstall-am:
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	$(CXXLINK) -Bgcctestdir/ script_test_5.o -T $(srcdir)/script_test_5.t
 @GCC_TRUE@@NATIVE_LINKER_TRUE@script_test_5.stdout: script_test_5
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	$(TEST_READELF) -SW script_test_5 > script_test_5.stdout
+@GCC_TRUE@@NATIVE_LINKER_TRUE@script_test_6: basic_test.o gcctestdir/ld $(srcdir)/script_test_6.t
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	$(CXXLINK) -Bgcctestdir/ basic_test.o -T $(srcdir)/script_test_6.t \
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	-Wl,-Ttext=0x10001000 -Wl,-Tdata=0x10200000 -Wl,-Tbss=0x10400000
+@GCC_TRUE@@NATIVE_LINKER_TRUE@script_test_6.stdout: script_test_6
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	$(TEST_READELF) -SlW script_test_6 > script_test_6.stdout
+@GCC_TRUE@@NATIVE_LINKER_TRUE@script_test_7: basic_test.o gcctestdir/ld $(srcdir)/script_test_7.t
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	$(CXXLINK) -Bgcctestdir/ basic_test.o -T $(srcdir)/script_test_7.t
+@GCC_TRUE@@NATIVE_LINKER_TRUE@script_test_7.stdout: script_test_7
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	$(TEST_READELF) -SlW script_test_7 > script_test_7.stdout
+@GCC_TRUE@@NATIVE_LINKER_TRUE@script_test_8: basic_test.o gcctestdir/ld $(srcdir)/script_test_7.t
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	$(CXXLINK) -Bgcctestdir/ basic_test.o -T $(srcdir)/script_test_7.t \
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	-Wl,-Ttext=0x20001000 -Wl,-Tdata=0x20200000 -Wl,-Tbss=0x20400000
+@GCC_TRUE@@NATIVE_LINKER_TRUE@script_test_8.stdout: script_test_8
+@GCC_TRUE@@NATIVE_LINKER_TRUE@	$(TEST_READELF) -SlW script_test_8 > script_test_8.stdout
 @GCC_TRUE@@NATIVE_LINKER_TRUE@dynamic_list: basic_test.o gcctestdir/ld $(srcdir)/dynamic_list.t
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	$(CXXLINK) -Bgcctestdir/ basic_test.o \
 @GCC_TRUE@@NATIVE_LINKER_TRUE@	  -Wl,--dynamic-list $(srcdir)/dynamic_list.t \
@@ -3135,6 +3179,16 @@ uninstall-am:
 @DEFAULT_TARGET_X86_64_TRUE@	$(TEST_OBJDUMP) -d $< > $@
 @DEFAULT_TARGET_X86_64_TRUE@split_x86_64_r.stdout: split_x86_64_1.o split_x86_64_n.o ../ld-new
 @DEFAULT_TARGET_X86_64_TRUE@	../ld-new -r split_x86_64_1.o split_x86_64_n.o -o split_x86_64_r > $@ 2>&1 || exit 0
+@DEFAULT_TARGET_ARM_TRUE@arm_abs_lib.o: arm_abs_lib.s
+@DEFAULT_TARGET_ARM_TRUE@	$(TEST_AS) -march=armv7-a -o $@ $<
+@DEFAULT_TARGET_ARM_TRUE@libarm_abs.so: arm_abs_lib.o
+@DEFAULT_TARGET_ARM_TRUE@	../ld-new -shared -o $@ arm_abs_lib.o
+@DEFAULT_TARGET_ARM_TRUE@arm_abs_global.o: arm_abs_global.s
+@DEFAULT_TARGET_ARM_TRUE@	$(TEST_AS) -march=armv7-a -o $@ $<
+@DEFAULT_TARGET_ARM_TRUE@arm_abs_global: arm_abs_global.o libarm_abs.so
+@DEFAULT_TARGET_ARM_TRUE@	../ld-new -o $@ arm_abs_global.o -L. -larm_abs
+@DEFAULT_TARGET_ARM_TRUE@arm_abs_global.stdout: arm_abs_global
+@DEFAULT_TARGET_ARM_TRUE@	$(TEST_READELF) -r $< > $@
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff --git a/gold/testsuite/arm_abs_global.s b/gold/testsuite/arm_abs_global.s
new file mode 100644
index 0000000..65cb309
--- /dev/null
+++ b/gold/testsuite/arm_abs_global.s
@@ -0,0 +1,31 @@
+	.syntax	unified
+
+	.text
+	.align	2
+
+	.global	_start
+	.type	_start, %function
+_start:
+	bx	lr
+	.size	_start, .-_start
+
+	.global	_arm_test
+	.type	_arm_test, %function
+_arm_test:
+	movt	r0, #:upper16:_movt_abs_global
+	movw	r0, #:lower16:_movw_abs_global
+	bx	lr
+	.size	_arm_test, .-_arm_test
+
+	.thumb
+	.global	_thumb_test
+_thumb_test:
+	movt	r0, #:upper16:_thm_movt_abs_global
+	movw	r0, #:lower16:_thm_movw_abs_global
+	bx	lr
+	.size	_thumb_test, .-_thumb_test
+
+	.data
+_data_test:
+	.word	_abs32_global
+	.word	_abs32_global_plt
diff --git a/gold/testsuite/arm_abs_global.sh b/gold/testsuite/arm_abs_global.sh
new file mode 100644
index 0000000..26abc24
--- /dev/null
+++ b/gold/testsuite/arm_abs_global.sh
@@ -0,0 +1,57 @@
+#!/bin/sh
+
+# arm_abs_global.sh -- test ARM absolute relocations against global symbols.
+
+# Copyright 2010 Free Software Foundation, Inc.
+# Written by Doug Kwan <dougkwan@google.com>
+
+# This file is part of gold.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+# MA 02110-1301, USA.
+
+# This file goes with the assembler source file arm_abs_global.s,
+# that is assembled and linked with a shared object libarm_abs.so.  We
+# want to check that a MOV[TW] instruction referencing an external function
+# causes a PLT to be created.
+
+check()
+{
+    file=$1
+    sym=$2
+    reloc=$3
+
+    found=`grep " $sym\$" $file`
+    if test -z "$found"; then
+	echo "Symbol $sym not found."
+	exit 1
+    fi
+
+    match_reloc=`grep " $sym\$" $file | grep " $reloc "`
+    if test -z "$match_reloc"; then
+	echo "Expected symbol $sym to have relocation $reloc but found"
+	echo "$found"
+	exit 1
+    fi
+}
+
+check "arm_abs_global.stdout" "_movt_abs_global" "R_ARM_JUMP_SLOT"
+check "arm_abs_global.stdout" "_movw_abs_global" "R_ARM_JUMP_SLOT"
+check "arm_abs_global.stdout" "_thm_movt_abs_global" "R_ARM_JUMP_SLOT"
+check "arm_abs_global.stdout" "_thm_movw_abs_global" "R_ARM_JUMP_SLOT"
+check "arm_abs_global.stdout" "_abs32_global_plt" "R_ARM_JUMP_SLOT"
+check "arm_abs_global.stdout" "_abs32_global" "R_ARM_ABS32"
+
+exit 0
diff --git a/gold/testsuite/arm_abs_lib.s b/gold/testsuite/arm_abs_lib.s
new file mode 100644
index 0000000..a2d7207
--- /dev/null
+++ b/gold/testsuite/arm_abs_lib.s
@@ -0,0 +1,37 @@
+	.syntax	unified
+
+	.text
+	.align	2
+	.global	_movt_abs_global
+	.type	_movt_abs_global, %function
+_movt_abs_global:
+	bx	lr
+	.size	_movt_abs_global, .-_movt_abs_global
+
+	.global	_movw_abs_global
+	.type	_movw_abs_global, %function
+_movw_abs_global:
+	bx	lr
+	.size	_movw_abs_global, .-_movw_abs_global
+
+	.thumb
+	.align	2
+	.global	_thm_movt_abs_global
+	.type	_thm_movt_abs_global, %function
+_thm_movt_abs_global:
+	bx	lr
+	.size	_thm_movt_abs_global, .-_thm_movt_abs_global
+
+	.global	_thm_movw_abs_global
+	.type	_thm_movw_abs_global, %function
+_thm_movw_abs_global:
+	bx	lr
+	.size	_thm_movw_abs_global, .-_thm_movw_abs_global
+
+	.global	_abs32_global_plt
+	.type	_abs32_global_plt, %function
+_abs32_global_plt:
+	bx	lr
+	.size	_abs32_global_plt, .-_abs32_global_plt
+
+	.comm	_abs32_global,4,4
diff --git a/gold/testsuite/gc_orphan_section_test.cc b/gold/testsuite/gc_orphan_section_test.cc
new file mode 100644
index 0000000..3443f8d
--- /dev/null
+++ b/gold/testsuite/gc_orphan_section_test.cc
@@ -0,0 +1,36 @@
+// gc_orphan_section_test.cc -- a test case for gold
+
+// Copyright 2010 Free Software Foundation, Inc.
+// Written by Sriraman Tallam <tmsriram@google.com>.
+
+// This file is part of gold.
+
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+// MA 02110-1301, USA.
+
+// The goal of this program is to verify if garbage collection does not
+// discard orphan sections when references to them through __start_XXX
+// and __stop_XXX are present.  Here section _foo must not be gc'ed but
+// _boo should be gc'ed.
+
+extern const int *__start__foo;
+int foo __attribute__((__section__("_foo"))) = 1;
+int boo __attribute__((__section__("_boo"))) = 1;
+
+int main()
+{
+  return *__start__foo;
+}
+
diff --git a/gold/testsuite/gc_orphan_section_test.sh b/gold/testsuite/gc_orphan_section_test.sh
new file mode 100755
index 0000000..6ce524d
--- /dev/null
+++ b/gold/testsuite/gc_orphan_section_test.sh
@@ -0,0 +1,46 @@
+#!/bin/sh
+
+# gc_orphan_section_test.sh -- test --gc-sections
+
+# Copyright 2010 Free Software Foundation, Inc.
+# Written by Sriraman Tallam <tmsriram@google.com>.
+
+# This file is part of gold.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+# MA 02110-1301, USA.
+
+# The goal of this program is to verify if gc-sections works as expected
+# with orphan sections.
+# File gc_orphan_sections_test.cc is in this test. This program checks if
+# the orphan sections are retained when they are referenced through
+# __start_XXX and __stop_XXX symbols.
+
+check()
+{
+    if grep -q " boo" "$1"
+    then
+        echo "Garbage collection failed to collect boo"
+	exit 1
+    fi
+    grep_foo=`grep -q " foo" $1`
+    if [ $? != 0 ];
+    then
+        echo "Garbage collection should not discard foo"
+	exit 1
+    fi
+}
+
+check gc_orphan_section_test.stdout
diff --git a/gold/testsuite/relro_script_test.t b/gold/testsuite/relro_script_test.t
index cacb84d..3a6e3e9 100644
--- a/gold/testsuite/relro_script_test.t
+++ b/gold/testsuite/relro_script_test.t
@@ -46,6 +46,8 @@ SECTIONS
 
   . = DATA_SEGMENT_RELRO_END(0, .);
 
+  .got.plt : { *(.got.plt) }
+
   .data : { *(.data .data.* .gnu.linkonce.d.*) }
 
   . = DATA_SEGMENT_END (.);
diff --git a/gold/testsuite/script_test_3.sh b/gold/testsuite/script_test_3.sh
index cddb69a..d114edd 100755
--- a/gold/testsuite/script_test_3.sh
+++ b/gold/testsuite/script_test_3.sh
@@ -85,4 +85,18 @@ if test "$section_size" != "$segment_size"; then
   exit 1
 fi
 
+# At least one PT_LOAD segment should have an alignment >= 0x100000.
+found=no
+for a in `grep LOAD script_test_3.stdout | sed -e 's/^.* 0x/0x/'`; do
+  script="BEGIN { if ($a >= 0x100000) { print \"true\" } else { print \"false\" } }"
+  x=`awk "$script" < /dev/null`
+  if test "$x" = "true"; then
+    found=yes
+  fi
+done
+if test "$found" = "no"; then
+  echo "no LOAD segment has required alignment"
+  exit 1
+fi
+
 exit 0
diff --git a/gold/testsuite/script_test_3.t b/gold/testsuite/script_test_3.t
index 9910349..c9572db 100644
--- a/gold/testsuite/script_test_3.t
+++ b/gold/testsuite/script_test_3.t
@@ -33,7 +33,7 @@ SECTIONS
   .dynamic : { *(.dynamic) } :data :dynamic
   .data : { *(.data) } :data
   . += 0x100000;
-  . = ALIGN(0x100);
+  . = ALIGN(0x100000);
   .bss : { *(.bss) } :bss
 }
 
diff --git a/gold/testsuite/script_test_6.sh b/gold/testsuite/script_test_6.sh
new file mode 100755
index 0000000..bbc96d8
--- /dev/null
+++ b/gold/testsuite/script_test_6.sh
@@ -0,0 +1,43 @@
+#!/bin/sh
+
+# script_test_6.sh -- test for -Ttext, -Tdata and -Tbss with a script.
+
+# Copyright 2009 Free Software Foundation, Inc.
+# Written by Doug Kwan <dougkwan@google.com>.
+
+# This file is part of gold.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+# MA 02110-1301, USA.
+
+# This file goes with script_test_4.t, which is a linker script which
+# starts the program at an unaligned address.
+
+check()
+{
+    if ! grep -q "$2" "$1"
+    then
+	echo "Did not find expected section in $1:"
+	echo "   $2"
+	echo ""
+	echo "Actual output below:"
+	cat "$1"
+	exit 1
+    fi
+}
+
+check script_test_6.stdout "\\.text[ 	]*PROGBITS[ 	]*0*10001000"
+check script_test_6.stdout "\\.data[ 	]*PROGBITS[ 	]*0*10200000"
+check script_test_6.stdout "\\.bss[ 	]*NOBITS[ 	]*0*10400000"
diff --git a/gold/testsuite/script_test_6.t b/gold/testsuite/script_test_6.t
new file mode 100644
index 0000000..9676371
--- /dev/null
+++ b/gold/testsuite/script_test_6.t
@@ -0,0 +1,41 @@
+/* script_test_5.t -- linker script test 5 for gold
+
+   Copyright 2009 Free Software Foundation, Inc.
+   Written by Cary Coutant <ccoutant@google.com>.
+
+   This file is part of gold.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+/* We won't try to run this program, just ensure that it links
+   as expected.  */
+
+SECTIONS
+{
+  . = 0x10000000;
+
+  /* With luck this will be enough to get the program working.  */
+  .interp : { *(.interp) }
+  .text : { *(.text .text.*) }
+  .rodata : { *(.rodata .rodata.*) }
+  . += 0x100000;
+  . = ALIGN(0x100);
+  .dynamic : { *(.dynamic) }
+  .data : { *(.data) }
+  . += 0x100000;
+  . = ALIGN(0x100);
+  .bss : { *(.bss) }
+}
diff --git a/gold/testsuite/script_test_7.sh b/gold/testsuite/script_test_7.sh
new file mode 100755
index 0000000..982a1c1
--- /dev/null
+++ b/gold/testsuite/script_test_7.sh
@@ -0,0 +1,43 @@
+#!/bin/sh
+
+# script_test_7.sh -- test for SEGMENT_START expressions.
+
+# Copyright 2009 Free Software Foundation, Inc.
+# Written by Doug Kwan <dougkwan@google.com>.
+
+# This file is part of gold.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+# MA 02110-1301, USA.
+
+# This file goes with script_test_4.t, which is a linker script which
+# starts the program at an unaligned address.
+
+check()
+{
+    if ! grep -q "$2" "$1"
+    then
+	echo "Did not find expected section in $1:"
+	echo "   $2"
+	echo ""
+	echo "Actual output below:"
+	cat "$1"
+	exit 1
+    fi
+}
+
+check script_test_7.stdout "\\.interp[ 	]*PROGBITS[ 	]*0*10000100"
+check script_test_7.stdout "\\.data[ 	]*PROGBITS[ 	]*0*10200000"
+check script_test_7.stdout "\\.bss[ 	]*NOBITS[ 	]*0*10400..."
diff --git a/gold/testsuite/script_test_7.t b/gold/testsuite/script_test_7.t
new file mode 100644
index 0000000..a4c4973
--- /dev/null
+++ b/gold/testsuite/script_test_7.t
@@ -0,0 +1,41 @@
+/* script_test_5.t -- linker script test 5 for gold
+
+   Copyright 2009 Free Software Foundation, Inc.
+   Written by Cary Coutant <ccoutant@google.com>.
+
+   This file is part of gold.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+/* We won't try to run this program, just ensure that it links
+   as expected.  */
+
+SECTIONS
+{
+  . = SEGMENT_START(".text", 0x10000100);
+
+  /* With luck this will be enough to get the program working.  */
+  .interp : { *(.interp) }
+  .text : { *(.text .text.*) }
+  .rodata : { *(.rodata .rodata.*) }
+  .dynamic : { *(.dynamic) }
+
+  . = SEGMENT_START(".data", 0x10200000);
+  .data : { *(.data) }
+
+  . = SEGMENT_START(".bss", 0x10400000);
+  .bss : { *(.bss) }
+}
diff --git a/gold/testsuite/script_test_8.sh b/gold/testsuite/script_test_8.sh
new file mode 100755
index 0000000..83e8e72
--- /dev/null
+++ b/gold/testsuite/script_test_8.sh
@@ -0,0 +1,44 @@
+#!/bin/sh
+
+# script_test_8.sh -- test for SEGMENT_START expressions with
+# -Ttext, -Tdata and -Tbss in a script.
+
+# Copyright 2009 Free Software Foundation, Inc.
+# Written by Doug Kwan <dougkwan@google.com>.
+
+# This file is part of gold.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+# MA 02110-1301, USA.
+
+# This file goes with script_test_4.t, which is a linker script which
+# starts the program at an unaligned address.
+
+check()
+{
+    if ! grep -q "$2" "$1"
+    then
+	echo "Did not find expected section in $1:"
+	echo "   $2"
+	echo ""
+	echo "Actual output below:"
+	cat "$1"
+	exit 1
+    fi
+}
+
+check script_test_8.stdout "\\.interp[ 	]*PROGBITS[ 	]*0*20001000"
+check script_test_8.stdout "\\.data[ 	]*PROGBITS[ 	]*0*20200000"
+check script_test_8.stdout "\\.bss[ 	]*NOBITS[ 	]*0*2040...."
diff --git a/gold/testsuite/script_test_9.cc b/gold/testsuite/script_test_9.cc
new file mode 100644
index 0000000..84f12f6
--- /dev/null
+++ b/gold/testsuite/script_test_9.cc
@@ -0,0 +1,29 @@
+// script_test_9.cc -- a test case for gold
+
+// Copyright 2010 Free Software Foundation, Inc.
+// Written by Rafael Avila de Espindola <espindola@google.com>.
+
+// This file is part of gold.
+
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+// MA 02110-1301, USA.
+
+// This program checks that the default renaming of ".text.xxx"
+// sections does not take place in the presence of a linker script
+// with a SECTIONS clause.
+
+int main() {
+  return 0;
+}
diff --git a/gold/testsuite/script_test_9.sh b/gold/testsuite/script_test_9.sh
new file mode 100644
index 0000000..9f9aba6
--- /dev/null
+++ b/gold/testsuite/script_test_9.sh
@@ -0,0 +1,42 @@
+#!/bin/sh
+
+# script_test_9.sh -- Check that the script_test_9.t script has placed
+# .init and .text in the same segment.
+
+# Copyright 2010 Free Software Foundation, Inc.
+# Written by Rafael Avila de Espindola <espindola@google.com>.
+
+# This file is part of gold.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+# MA 02110-1301, USA.
+
+check()
+{
+    if ! grep -q "$2" "$1"
+    then
+	echo "Did not find expected section in $1:"
+	echo "   $2"
+	echo ""
+	echo "Actual output below:"
+	cat "$1"
+	exit 1
+    fi
+}
+
+check script_test_9.stdout "LOAD .*R E "
+check script_test_9.stdout "LOAD .*RW "
+check script_test_9.stdout "00 .*\.text .init"
+check script_test_9.stdout "01 .*\.data "
diff --git a/gold/testsuite/script_test_9.t b/gold/testsuite/script_test_9.t
new file mode 100644
index 0000000..58cc350
--- /dev/null
+++ b/gold/testsuite/script_test_9.t
@@ -0,0 +1,18 @@
+PHDRS
+{
+  text    PT_LOAD FLAGS(5);
+  data    PT_LOAD FLAGS(6);
+}
+
+SECTIONS
+{
+  .init           :
+  {
+  } :text
+  .text           :
+  {
+  }
+  .data :
+  {
+  } :data
+}
diff --git a/gold/testsuite/testfile.cc b/gold/testsuite/testfile.cc
index d66189a..7f53792 100644
--- a/gold/testsuite/testfile.cc
+++ b/gold/testsuite/testfile.cc
@@ -44,17 +44,15 @@ class Target_test : public Sized_target<size, big_endian>
   { }
 
   void
-  gc_process_relocs(const General_options&, Symbol_table*, Layout*,
-                    Sized_relobj<size, big_endian>*, unsigned int,
-                    unsigned int, const unsigned char*, size_t, Output_section*,
-                    bool, size_t, const unsigned char*)
+  gc_process_relocs(Symbol_table*, Layout*, Sized_relobj<size, big_endian>*,
+		    unsigned int, unsigned int, const unsigned char*, size_t,
+		    Output_section*, bool, size_t, const unsigned char*)
   { ERROR("call to Target_test::gc_process_relocs"); }
 
   void
-  scan_relocs(const General_options&, Symbol_table*, Layout*,
-	      Sized_relobj<size, big_endian>*, unsigned int,
-	      unsigned int, const unsigned char*, size_t, Output_section*,
-	      bool, size_t, const unsigned char*)
+  scan_relocs(Symbol_table*, Layout*, Sized_relobj<size, big_endian>*,
+	      unsigned int, unsigned int, const unsigned char*, size_t,
+	      Output_section*, bool, size_t, const unsigned char*)
   { ERROR("call to Target_test::scan_relocs"); }
 
   void
@@ -65,7 +63,7 @@ class Target_test : public Sized_target<size, big_endian>
   { ERROR("call to Target_test::relocate_section"); }
 
   void
-  scan_relocatable_relocs(const General_options&, Symbol_table*, Layout*,
+  scan_relocatable_relocs(Symbol_table*, Layout*,
 			  Sized_relobj<size, big_endian>*, unsigned int,
 			  unsigned int, const unsigned char*,
 			  size_t, Output_section*, bool, size_t,
@@ -103,7 +101,9 @@ const Target::Target_info Target_test<size, big_endian>::test_target_info =
   elfcpp::SHN_UNDEF,			// small_common_shndx
   elfcpp::SHN_UNDEF,			// large_common_shndx
   0,					// small_common_section_flags
-  0					// large_common_section_flags
+  0,					// large_common_section_flags
+  NULL,					// attributes_section
+  NULL					// attributes_vendor
 };
 
 // The test targets.
diff --git a/gold/x86_64.cc b/gold/x86_64.cc
index 3562065..c46cdf6 100644
--- a/gold/x86_64.cc
+++ b/gold/x86_64.cc
@@ -74,8 +74,7 @@ class Target_x86_64 : public Target_freebsd<64, false>
 
   // Scan the relocations to look for symbol adjustments.
   void
-  gc_process_relocs(const General_options& options,
-	            Symbol_table* symtab,
+  gc_process_relocs(Symbol_table* symtab,
 	            Layout* layout,
 	            Sized_relobj<64, false>* object,
 	            unsigned int data_shndx,
@@ -89,8 +88,7 @@ class Target_x86_64 : public Target_freebsd<64, false>
 
   // Scan the relocations to look for symbol adjustments.
   void
-  scan_relocs(const General_options& options,
-	      Symbol_table* symtab,
+  scan_relocs(Symbol_table* symtab,
 	      Layout* layout,
 	      Sized_relobj<64, false>* object,
 	      unsigned int data_shndx,
@@ -104,7 +102,7 @@ class Target_x86_64 : public Target_freebsd<64, false>
 
   // Finalize the sections.
   void
-  do_finalize_sections(Layout*);
+  do_finalize_sections(Layout*, const Input_objects*, Symbol_table*);
 
   // Return the value to use for a dynamic which requires special
   // treatment.
@@ -126,8 +124,7 @@ class Target_x86_64 : public Target_freebsd<64, false>
 
   // Scan the relocs during a relocatable link.
   void
-  scan_relocatable_relocs(const General_options& options,
-			  Symbol_table* symtab,
+  scan_relocatable_relocs(Symbol_table* symtab,
 			  Layout* layout,
 			  Sized_relobj<64, false>* object,
 			  unsigned int data_shndx,
@@ -189,8 +186,7 @@ class Target_x86_64 : public Target_freebsd<64, false>
     { }
 
     inline void
-    local(const General_options& options, Symbol_table* symtab,
-	  Layout* layout, Target_x86_64* target,
+    local(Symbol_table* symtab, Layout* layout, Target_x86_64* target,
 	  Sized_relobj<64, false>* object,
 	  unsigned int data_shndx,
 	  Output_section* output_section,
@@ -198,8 +194,7 @@ class Target_x86_64 : public Target_freebsd<64, false>
 	  const elfcpp::Sym<64, false>& lsym);
 
     inline void
-    global(const General_options& options, Symbol_table* symtab,
-	   Layout* layout, Target_x86_64* target,
+    global(Symbol_table* symtab, Layout* layout, Target_x86_64* target,
 	   Sized_relobj<64, false>* object,
 	   unsigned int data_shndx,
 	   Output_section* output_section,
@@ -444,7 +439,9 @@ const Target::Target_info Target_x86_64::x86_64_info =
   elfcpp::SHN_UNDEF,	// small_common_shndx
   elfcpp::SHN_X86_64_LCOMMON,	// large_common_shndx
   0,			// small_common_section_flags
-  elfcpp::SHF_X86_64_LARGE	// large_common_section_flags
+  elfcpp::SHF_X86_64_LARGE,	// large_common_section_flags
+  NULL,			// attributes_section
+  NULL			// attributes_vendor
 };
 
 // This is called when a new output section is created.  This is where
@@ -472,25 +469,25 @@ Target_x86_64::got_section(Symbol_table* symtab, Layout* layout)
       os = layout->add_output_section_data(".got", elfcpp::SHT_PROGBITS,
 					   (elfcpp::SHF_ALLOC
 					    | elfcpp::SHF_WRITE),
-					   this->got_);
-      os->set_is_relro();
+					   this->got_, false, true, true,
+					   false);
 
-      // The old GNU linker creates a .got.plt section.  We just
-      // create another set of data in the .got section.  Note that we
-      // always create a PLT if we create a GOT, although the PLT
-      // might be empty.
       this->got_plt_ = new Output_data_space(8, "** GOT PLT");
-      os = layout->add_output_section_data(".got", elfcpp::SHT_PROGBITS,
+      os = layout->add_output_section_data(".got.plt", elfcpp::SHT_PROGBITS,
 					   (elfcpp::SHF_ALLOC
 					    | elfcpp::SHF_WRITE),
-					   this->got_plt_);
-      os->set_is_relro();
+					   this->got_plt_, false, false,
+					   false, true);
 
       // The first three entries are reserved.
       this->got_plt_->set_current_data_size(3 * 8);
 
+      // Those bytes can go into the relro segment.
+      layout->increase_relro(3 * 8);
+
       // Define _GLOBAL_OFFSET_TABLE_ at the start of the PLT.
       symtab->define_in_output_data("_GLOBAL_OFFSET_TABLE_", NULL,
+				    Symbol_table::PREDEFINED,
 				    this->got_plt_,
 				    0, 0, elfcpp::STT_OBJECT,
 				    elfcpp::STB_LOCAL,
@@ -511,7 +508,8 @@ Target_x86_64::rela_dyn_section(Layout* layout)
       gold_assert(layout != NULL);
       this->rela_dyn_ = new Reloc_section(parameters->options().combreloc());
       layout->add_output_section_data(".rela.dyn", elfcpp::SHT_RELA,
-				      elfcpp::SHF_ALLOC, this->rela_dyn_);
+				      elfcpp::SHF_ALLOC, this->rela_dyn_, true,
+				      false, false, false);
     }
   return this->rela_dyn_;
 }
@@ -611,7 +609,8 @@ Output_data_plt_x86_64::Output_data_plt_x86_64(Layout* layout,
 {
   this->rel_ = new Reloc_section(false);
   layout->add_output_section_data(".rela.plt", elfcpp::SHT_RELA,
-				  elfcpp::SHF_ALLOC, this->rel_);
+				  elfcpp::SHF_ALLOC, this->rel_, true,
+				  false, false, false);
 }
 
 void
@@ -807,7 +806,7 @@ Target_x86_64::make_plt_section(Symbol_table* symtab, Layout* layout)
       layout->add_output_section_data(".plt", elfcpp::SHT_PROGBITS,
 				      (elfcpp::SHF_ALLOC
 				       | elfcpp::SHF_EXECINSTR),
-				      this->plt_);
+				      this->plt_, false, false, false, false);
     }
 }
 
@@ -839,6 +838,7 @@ Target_x86_64::define_tls_base_symbol(Symbol_table* symtab, Layout* layout)
     {
       bool is_exec = parameters->options().output_is_executable();
       symtab->define_in_output_segment("_TLS_MODULE_BASE_", NULL,
+				       Symbol_table::PREDEFINED,
 				       tls_segment, 0, 0,
 				       elfcpp::STT_TLS,
 				       elfcpp::STB_LOCAL,
@@ -1002,8 +1002,7 @@ Target_x86_64::Scan::check_non_pic(Relobj* object, unsigned int r_type)
 // Scan a relocation for a local symbol.
 
 inline void
-Target_x86_64::Scan::local(const General_options&,
-                           Symbol_table* symtab,
+Target_x86_64::Scan::local(Symbol_table* symtab,
                            Layout* layout,
                            Target_x86_64* target,
                            Sized_relobj<64, false>* object,
@@ -1283,8 +1282,7 @@ Target_x86_64::Scan::unsupported_reloc_global(Sized_relobj<64, false>* object,
 // Scan a relocation for a global symbol.
 
 inline void
-Target_x86_64::Scan::global(const General_options&,
-                            Symbol_table* symtab,
+Target_x86_64::Scan::global(Symbol_table* symtab,
                             Layout* layout,
                             Target_x86_64* target,
                             Sized_relobj<64, false>* object,
@@ -1576,8 +1574,7 @@ Target_x86_64::Scan::global(const General_options&,
 }
 
 void
-Target_x86_64::gc_process_relocs(const General_options& options,
-                                 Symbol_table* symtab,
+Target_x86_64::gc_process_relocs(Symbol_table* symtab,
                                  Layout* layout,
                                  Sized_relobj<64, false>* object,
                                  unsigned int data_shndx,
@@ -1597,7 +1594,6 @@ Target_x86_64::gc_process_relocs(const General_options& options,
 
    gold::gc_process_relocs<64, false, Target_x86_64, elfcpp::SHT_RELA,
                            Target_x86_64::Scan>(
-    options,
     symtab,
     layout,
     this,
@@ -1614,8 +1610,7 @@ Target_x86_64::gc_process_relocs(const General_options& options,
 // Scan relocations for a section.
 
 void
-Target_x86_64::scan_relocs(const General_options& options,
-                           Symbol_table* symtab,
+Target_x86_64::scan_relocs(Symbol_table* symtab,
                            Layout* layout,
                            Sized_relobj<64, false>* object,
                            unsigned int data_shndx,
@@ -1636,7 +1631,6 @@ Target_x86_64::scan_relocs(const General_options& options,
 
   gold::scan_relocs<64, false, Target_x86_64, elfcpp::SHT_RELA,
       Target_x86_64::Scan>(
-    options,
     symtab,
     layout,
     this,
@@ -1653,7 +1647,10 @@ Target_x86_64::scan_relocs(const General_options& options,
 // Finalize the sections.
 
 void
-Target_x86_64::do_finalize_sections(Layout* layout)
+Target_x86_64::do_finalize_sections(
+    Layout* layout,
+    const Input_objects*,
+    Symbol_table*)
 {
   // Fill in some more dynamic tags.
   Output_data_dynamic* const odyn = layout->dynamic_data();
@@ -2526,8 +2523,7 @@ Target_x86_64::Relocatable_size_for_reloc::get_size_for_reloc(
 // Scan the relocs during a relocatable link.
 
 void
-Target_x86_64::scan_relocatable_relocs(const General_options& options,
-				       Symbol_table* symtab,
+Target_x86_64::scan_relocatable_relocs(Symbol_table* symtab,
 				       Layout* layout,
 				       Sized_relobj<64, false>* object,
 				       unsigned int data_shndx,
@@ -2547,7 +2543,6 @@ Target_x86_64::scan_relocatable_relocs(const General_options& options,
 
   gold::scan_relocatable_relocs<64, false, elfcpp::SHT_RELA,
       Scan_relocatable_relocs>(
-    options,
     symtab,
     layout,
     object,
diff --git a/gold/yyscript.y b/gold/yyscript.y
index 0d52882..f762536 100644
--- a/gold/yyscript.y
+++ b/gold/yyscript.y
@@ -77,6 +77,7 @@
   struct Version_dependency_list* deplist;
   struct Version_expression_list* versyms;
   struct Version_tree* versnode;
+  enum Script_section_type section_type;
 }
 
 /* Operators, including a precedence table for expressions.  */
@@ -121,11 +122,13 @@
 %token BYTE
 %token CONSTANT
 %token CONSTRUCTORS
+%token COPY
 %token CREATE_OBJECT_SYMBOLS
 %token DATA_SEGMENT_ALIGN
 %token DATA_SEGMENT_END
 %token DATA_SEGMENT_RELRO_END
 %token DEFINED
+%token DSECT
 %token ENTRY
 %token EXCLUDE_FILE
 %token EXTERN
@@ -137,6 +140,7 @@
 %token HLL
 %token INCLUDE
 %token INHIBIT_COMMON_ALLOCATION
+%token INFO
 %token INPUT
 %token KEEP
 %token LENGTH		/* LENGTH, l, len */
@@ -150,6 +154,7 @@
 %token NEXT
 %token NOCROSSREFS
 %token NOFLOAT
+%token NOLOAD
 %token ONLY_IF_RO
 %token ONLY_IF_RW
 %token ORIGIN		/* ORIGIN, o, org */
@@ -197,9 +202,10 @@
 
 /* Non-terminal types, where needed.  */
 
-%type <expr> parse_exp exp opt_address_and_section_type
+%type <expr> parse_exp exp
 %type <expr> opt_at opt_align opt_subalign opt_fill
-%type <output_section_header> section_header
+%type <output_section_header> section_header opt_address_and_section_type
+%type <section_type> section_type
 %type <output_section_trailer> section_trailer
 %type <constraint> opt_constraint
 %type <string_list> opt_phdr
@@ -343,7 +349,8 @@ section_header:
 	    { script_pop_lex_mode(closure); }
 	  opt_constraint
 	    {
-	      $$.address = $2;
+	      $$.address = $2.address;
+	      $$.section_type = $2.section_type;
 	      $$.load_address = $3;
 	      $$.align = $4;
 	      $$.subalign = $5;
@@ -356,18 +363,61 @@ section_header:
    '(' in section_header.  */
 
 opt_address_and_section_type:
-	  ':'
-	    { $$ = NULL; }
+	':'
+	    {
+	      $$.address = NULL;
+	      $$.section_type = SCRIPT_SECTION_TYPE_NONE;
+	    }
 	| '(' ')' ':'
-	    { $$ = NULL; }
+	    {
+	      $$.address = NULL;
+	      $$.section_type = SCRIPT_SECTION_TYPE_NONE;
+	    }
 	| exp ':'
-	    { $$ = $1; }
+	    {
+	      $$.address = $1;
+	      $$.section_type = SCRIPT_SECTION_TYPE_NONE;
+	    }
 	| exp '(' ')' ':'
-	    { $$ = $1; }
-	| exp '(' string ')' ':'
 	    {
-	      yyerror(closure, "section types are not supported");
-	      $$ = $1;
+	      $$.address = $1;
+	      $$.section_type = SCRIPT_SECTION_TYPE_NONE;
+	    }
+	| '(' section_type ')' ':'
+	    {
+	      $$.address = NULL;
+	      $$.section_type = $2;
+	    }
+	| exp '(' section_type ')' ':'
+	    {
+	      $$.address = $1;
+	      $$.section_type = $3;
+	    }
+	;
+
+/* We only support NOLOAD.  */
+section_type:
+	NOLOAD
+	    { $$ = SCRIPT_SECTION_TYPE_NOLOAD; }
+	| DSECT
+	    {
+	      yyerror(closure, "DSECT section type is unsupported");
+	      $$ = SCRIPT_SECTION_TYPE_DSECT;
+	    }
+	| COPY
+	    {
+	      yyerror(closure, "COPY section type is unsupported");
+	      $$ = SCRIPT_SECTION_TYPE_COPY;
+	    }
+	| INFO
+	    {
+	      yyerror(closure, "INFO section type is unsupported");
+	      $$ = SCRIPT_SECTION_TYPE_INFO;
+	    }
+	| OVERLAY
+	    {
+	      yyerror(closure, "OVERLAY section type is unsupported");
+	      $$ = SCRIPT_SECTION_TYPE_OVERLAY;
 	    }
 	;
 
@@ -861,6 +911,10 @@ exp:
 	| SEGMENT_START '(' string ',' exp ')'
 	    {
 	      $$ = script_exp_function_segment_start($3.value, $3.length, $5);
+	      /* We need to take note of any SEGMENT_START expressions
+		 because they change the behaviour of -Ttext, -Tdata and
+		 -Tbss options.  */
+	      script_saw_segment_start_expression(closure);
 	    }
 	| ASSERT_K '(' exp ',' string ')'
 	    { $$ = script_exp_function_assert($3, $5.value, $5.length); }
diff --git a/include/ChangeLog b/include/ChangeLog
index 9e6fb59..244610a 100644
--- a/include/ChangeLog
+++ b/include/ChangeLog
@@ -1,3 +1,13 @@
+2009-10-09  Rafael Espindola  <espindola@google.com>
+
+	* plugin-api.h (ld_plugin_add_input_library): Change argument name to
+	libname.
+
+2008-10-03  Rafael Espindola  <espindola@google.com>
+
+	* plugin-api.h: New.
+	* lto-symtab.h: New.
+
 2009-09-09  Martin Thuresson  <martin@mtme.org>
 
 	* bfdlink.h (struct bfd_link_hash_common_entry): Move to top
diff --git a/include/plugin-api.h b/include/plugin-api.h
index f536d57..a026e7a 100644
--- a/include/plugin-api.h
+++ b/include/plugin-api.h
@@ -1,6 +1,6 @@
 /* plugin-api.h -- External linker plugin API.  */
 
-/* Copyright 2008 Free Software Foundation, Inc.
+/* Copyright 2009 Free Software Foundation, Inc.
    Written by Cary Coutant <ccoutant@google.com>.
 
    This file is part of binutils.
@@ -111,13 +111,34 @@ enum ld_plugin_symbol_visibility
 enum ld_plugin_symbol_resolution
 {
   LDPR_UNKNOWN = 0,
+
+  /* Symbol is still undefined at this point.  */
   LDPR_UNDEF,
+
+  /* This is the prevailing definition of the symbol, with references from
+     regular object code.  */
   LDPR_PREVAILING_DEF,
+
+  /* This is the prevailing definition of the symbol, with no
+     references from regular objects.  It is only referenced from IR
+     code.  */
   LDPR_PREVAILING_DEF_IRONLY,
+
+  /* This definition was pre-empted by a definition in a regular
+     object file.  */
   LDPR_PREEMPTED_REG,
+
+  /* This definition was pre-empted by a definition in another IR file.  */
   LDPR_PREEMPTED_IR,
+
+  /* This symbol was resolved by a definition in another IR file.  */
   LDPR_RESOLVED_IR,
+
+  /* This symbol was resolved by a definition in a regular object
+     linked into the main executable.  */
   LDPR_RESOLVED_EXEC,
+
+  /* This symbol was resolved by a definition in a shared object.  */
   LDPR_RESOLVED_DYN
 };
 
@@ -193,6 +214,12 @@ typedef
 enum ld_plugin_status
 (*ld_plugin_add_input_file) (char *pathname);
 
+/* The linker's interface for adding a library that should be searched.  */
+
+typedef
+enum ld_plugin_status
+(*ld_plugin_add_input_library) (char *libname);
+
 /* The linker's interface for issuing a warning or error message.  */
 
 typedef
@@ -224,7 +251,8 @@ enum ld_plugin_tag
   LDPT_ADD_INPUT_FILE,
   LDPT_MESSAGE,
   LDPT_GET_INPUT_FILE,
-  LDPT_RELEASE_INPUT_FILE
+  LDPT_RELEASE_INPUT_FILE,
+  LDPT_ADD_INPUT_LIBRARY
 };
 
 /* The plugin transfer vector.  */
@@ -245,6 +273,7 @@ struct ld_plugin_tv
     ld_plugin_message tv_message;
     ld_plugin_get_input_file tv_get_input_file;
     ld_plugin_release_input_file tv_release_input_file;
+    ld_plugin_add_input_library tv_add_input_library;
   } tv_u;
 };
 
