diff -uNr gcc-4.4.0.orig/config/lib-prefix.m4 gcc-4.4.0/config/lib-prefix.m4
--- gcc-4.4.0.orig/config/lib-prefix.m4	2004-09-23 01:53:59.000000000 +0200
+++ gcc-4.4.0/config/lib-prefix.m4	2009-06-24 00:57:00.000000000 +0200
@@ -71,7 +71,7 @@
         if test "X$additional_includedir" = "X/usr/local/include"; then
           if test -n "$GCC"; then
             case $host_os in
-              linux*) haveit=yes;;
+              linux* | nacl*) haveit=yes;;
             esac
           fi
         fi
@@ -102,7 +102,7 @@
         if test "X$additional_libdir" = "X/usr/local/lib"; then
           if test -n "$GCC"; then
             case $host_os in
-              linux*) haveit=yes;;
+              linux* | nacl*) haveit=yes;;
             esac
           fi
         fi
diff -uNr gcc-4.4.0.orig/config.sub gcc-4.4.0/config.sub
--- gcc-4.4.0.orig/config.sub	2008-12-18 04:27:27.000000000 +0100
+++ gcc-4.4.0/config.sub	2009-06-24 00:57:00.000000000 +0200
@@ -122,7 +122,7 @@
 case $maybe_os in
   nto-qnx* | linux-gnu* | linux-dietlibc | linux-newlib* | linux-uclibc* | \
   uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* | \
-  storm-chaos* | os2-emx* | rtmk-nova*)
+  storm-chaos* | os2-emx* | rtmk-nova* | nacl*)
     os=-$maybe_os
     basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
     ;;
@@ -753,6 +753,10 @@
 		basic_machine=i370-ibm
 		os=-mvs
 		;;
+        nacl)
+                basic_machine=i686-pc
+                os=-nacl
+                ;;
 	ncr3000)
 		basic_machine=i486-ncr
 		os=-sysv4
@@ -1276,7 +1280,7 @@
 	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
 	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
 	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
-	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops*)
+	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -nacl*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
 	-qnx*)
diff -uNr gcc-4.4.0.orig/configure gcc-4.4.0/configure
--- gcc-4.4.0.orig/configure	2009-04-21 11:08:08.000000000 +0200
+++ gcc-4.4.0/configure	2009-06-24 00:57:00.000000000 +0200
@@ -2179,6 +2179,9 @@
     *-*-freebsd*)
         # Enable libmudflap by default in FreeBSD.
 	;;
+    *-*-nacl*)
+        # Enable libmudflap by default in NativeClient.
+        ;;
     *)
         # Disable it by default everywhere else.
 	noconfigdirs="$noconfigdirs target-libmudflap"
@@ -2198,6 +2201,8 @@
 	;;
     *-*-darwin* | *-*-aix*)
 	;;
+    *-*-nacl*)
+	;;
     *)
 	noconfigdirs="$noconfigdirs target-libgomp"
 	;;
@@ -2688,7 +2693,7 @@
   ip2k-*-*)
     noconfigdirs="$noconfigdirs target-libiberty target-libstdc++-v3 ${libgcj}"
     ;;
-  *-*-linux* | *-*-gnu* | *-*-k*bsd*-gnu | *-*-kopensolaris*-gnu)
+  *-*-linux* | *-*-gnu* | *-*-k*bsd*-gnu | *-*-kopensolaris*-gnu | *-*-nacl*)
     noconfigdirs="$noconfigdirs target-newlib target-libgloss"
     ;;
   *-*-lynxos*)
diff -uNr gcc-4.4.0.orig/configure.ac gcc-4.4.0/configure.ac
--- gcc-4.4.0.orig/configure.ac	2009-04-14 10:57:33.000000000 +0200
+++ gcc-4.4.0/configure.ac	2009-06-24 00:57:00.000000000 +0200
@@ -414,6 +414,9 @@
     *-*-freebsd*)
         # Enable libmudflap by default in FreeBSD.
 	;;
+    *-*-nacl*)
+        # Enable libmudflap by default in NativeClient.
+        ;;
     *)
         # Disable it by default everywhere else.
 	noconfigdirs="$noconfigdirs target-libmudflap"
@@ -433,6 +436,8 @@
 	;;
     *-*-darwin* | *-*-aix*)
 	;;
+    *-*-nacl*)
+	;;
     *)
 	noconfigdirs="$noconfigdirs target-libgomp"
 	;;
@@ -923,7 +928,7 @@
   ip2k-*-*)
     noconfigdirs="$noconfigdirs target-libiberty target-libstdc++-v3 ${libgcj}"
     ;;
-  *-*-linux* | *-*-gnu* | *-*-k*bsd*-gnu | *-*-kopensolaris*-gnu)
+  *-*-linux* | *-*-gnu* | *-*-k*bsd*-gnu | *-*-kopensolaris*-gnu | *-*-nacl*)
     noconfigdirs="$noconfigdirs target-newlib target-libgloss"
     ;;
   *-*-lynxos*)
diff -uNr gcc-4.4.0.orig/gcc/Makefile.in gcc-4.4.0/gcc/Makefile.in
--- gcc-4.4.0.orig/gcc/Makefile.in	2009-03-25 13:00:32.000000000 +0100
+++ gcc-4.4.0/gcc/Makefile.in	2009-06-24 00:57:00.000000000 +0200
@@ -1076,6 +1076,7 @@
 	coverage.o \
 	cse.o \
 	cselib.o \
+	ctrl-intg.o \
 	dbxout.o \
 	dbgcnt.o \
 	dce.o \
@@ -2662,6 +2663,8 @@
    output.h $(FUNCTION_H) $(BASIC_BLOCK_H) $(GGC_H) $(TM_P_H) $(TIMEVAR_H) \
    except.h $(TARGET_H) $(PARAMS_H) rtlhooks-def.h tree-pass.h $(REAL_H) \
    $(DF_H) $(DBGCNT_H)
+ctrl-intg.o : ctrl-intg.c $(CONFIG_H) $(SYSTEM_H) $(BCONFIG_H) \
+   $(TREE_H) $(RTL_H) $(TM_H) $(EXPR_H) $(FLAGS_H) $(BASIC_BLOCK_H)
 dce.o : dce.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
    $(TREE_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) $(DF_H) cselib.h \
    $(DBGCNT_H) dce.h $(TIMEVAR_H) tree-pass.h $(DBGCNT_H) $(TM_P_H)
diff -uNr gcc-4.4.0.orig/gcc/cfgrtl.c gcc-4.4.0/gcc/cfgrtl.c
--- gcc-4.4.0.orig/gcc/cfgrtl.c	2008-12-12 22:16:09.000000000 +0100
+++ gcc-4.4.0/gcc/cfgrtl.c	2009-06-24 00:57:00.000000000 +0200
@@ -1054,6 +1054,9 @@
     }
   else
     {
+      if ((e->flags & EDGE_FALLTHRU) == 0) {
+        printf("Edge flags were incorrect %x\n", e->flags);
+      }
       gcc_assert (e->flags & EDGE_FALLTHRU);
       if (e->src == ENTRY_BLOCK_PTR)
 	{
diff -uNr gcc-4.4.0.orig/gcc/config/i386/crtfastmath.c gcc-4.4.0/gcc/config/i386/crtfastmath.c
--- gcc-4.4.0.orig/gcc/config/i386/crtfastmath.c	2009-04-10 01:23:07.000000000 +0200
+++ gcc-4.4.0/gcc/config/i386/crtfastmath.c	2009-06-24 00:57:00.000000000 +0200
@@ -27,8 +27,13 @@
 #ifndef __x86_64__
 /* All 64-bit targets have SSE and DAZ;
    only check them explicitly for 32-bit ones. */
+#ifndef __native_client__
+  /* Native Client does not allow several instructions used here, notably
+     setting model specific registers.  We're going to want to revisit this
+     as a possible syscall */
 #include "cpuid.h"
 #endif
+#endif
 
 static void __attribute__((constructor))
 #ifndef __x86_64__
@@ -40,6 +45,10 @@
 set_fast_math (void)
 {
 #ifndef __x86_64__
+#ifndef __native_client__
+  /* Native Client does not allow several instructions used here, notably
+     setting model specific registers.  We're going to want to revisit this
+     as a possible syscall */
   unsigned int eax, ebx, ecx, edx;
 
   if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))
@@ -81,6 +90,7 @@
 
       __builtin_ia32_ldmxcsr (mxcsr);
     }
+#endif
 #else
   unsigned int mxcsr = __builtin_ia32_stmxcsr ();
   mxcsr |= MXCSR_DAZ | MXCSR_FTZ;
diff -uNr gcc-4.4.0.orig/gcc/config/i386/i386.c gcc-4.4.0/gcc/config/i386/i386.c
--- gcc-4.4.0.orig/gcc/config/i386/i386.c	2009-04-14 22:27:30.000000000 +0200
+++ gcc-4.4.0/gcc/config/i386/i386.c	2009-06-24 00:57:00.000000000 +0200
@@ -7368,6 +7368,8 @@
 	  (*targetm.asm_out.unique_section) (decl, 0);
 	  switch_to_section (get_named_section (decl, NULL, 0));
 
+	  if (flag_control_integrity && !getenv("NONACLRET"))
+	    fprintf (asm_out_file, ".p2align %d\n", NACL_ALIGN_POW2);
 	  (*targetm.asm_out.globalize_label) (asm_out_file, name);
 	  fputs ("\t.hidden\t", asm_out_file);
 	  assemble_name (asm_out_file, name);
@@ -7377,13 +7379,24 @@
       else
 	{
 	  switch_to_section (text_section);
+	  if (flag_control_integrity && !getenv("NONACLRET"))
+	    fprintf (asm_out_file, ".p2align %d\n", NACL_ALIGN_POW2);
 	  ASM_OUTPUT_LABEL (asm_out_file, name);
 	}
 
-      xops[0] = gen_rtx_REG (Pmode, regno);
-      xops[1] = gen_rtx_MEM (Pmode, stack_pointer_rtx);
-      output_asm_insn ("mov%z0\t{%1, %0|%0, %1}", xops);
-      output_asm_insn ("ret", xops);
+      if (flag_control_integrity && !getenv("NONACLRET"))
+        {
+          xops[0] = gen_rtx_REG (Pmode, regno);
+          output_asm_insn ("pop{l}\t%0", xops);
+          output_asm_insn ("nacljmp\t%0", xops);
+        }
+      else
+        {
+          xops[0] = gen_rtx_REG (Pmode, regno);
+          xops[1] = gen_rtx_MEM (Pmode, stack_pointer_rtx);
+          output_asm_insn ("mov%z0\t{%1, %0|%0, %1}", xops);
+          output_asm_insn ("ret", xops);
+        }
     }
 
   if (NEED_INDICATE_EXEC_STACK)
@@ -8608,7 +8621,8 @@
 	 return address, do explicit add, and jump indirectly to the
 	 caller.  */
 
-      if (crtl->args.pops_args >= 65536)
+      if ((flag_control_integrity && !getenv("NONACLRET")) ||
+	  (crtl->args.pops_args >= 65536))
 	{
 	  rtx ecx = gen_rtx_REG (SImode, CX_REG);
 
@@ -8617,13 +8631,30 @@
 
 	  emit_insn (gen_popsi1 (ecx));
 	  emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, popc));
-	  emit_jump_insn (gen_return_indirect_internal (ecx));
+	  if (flag_control_integrity && !getenv("NONACLRET")) {
+	    emit_jump_insn (gen_nacl_return_indirect (ecx));
+	  } else {
+	    emit_jump_insn (gen_return_indirect_internal (ecx));
+	  }
 	}
       else
 	emit_jump_insn (gen_return_pop_internal (popc));
     }
   else
-    emit_jump_insn (gen_return_internal ());
+    {
+      if (flag_control_integrity && !getenv("NONACLRET"))
+        {
+	  rtx ecx = gen_rtx_REG (SImode, 2);
+
+	  /* There is no "pascal" calling convention in 64bit ABI.  */
+	  gcc_assert (!TARGET_64BIT);
+
+	  emit_insn (gen_popsi1 (ecx));
+          emit_jump_insn (gen_nacl_return_indirect (ecx));
+        }
+      else
+        emit_jump_insn (gen_return_internal ());
+    }
 }
 
 /* Reset from the function's potential modifications.  */
diff -uNr gcc-4.4.0.orig/gcc/config/i386/i386.md gcc-4.4.0/gcc/config/i386/i386.md
--- gcc-4.4.0.orig/gcc/config/i386/i386.md	2009-03-17 19:55:40.000000000 +0100
+++ gcc-4.4.0/gcc/config/i386/i386.md	2009-06-24 00:57:00.000000000 +0200
@@ -154,6 +154,11 @@
    (UNSPEC_SP_TLS_SET		102)
    (UNSPEC_SP_TLS_TEST		103)
 
+   ; NativeClient opcodes
+   (UNSPEC_NACLCALL		104)
+   (UNSPEC_NACLJMP		105)
+   (UNSPEC_NACLRET		106)
+
    ; SSSE3
    (UNSPEC_PSHUFB		120)
    (UNSPEC_PSIGN		121)
@@ -9686,6 +9691,104 @@
   [(set_attr "type" "alu")
    (set_attr "mode" "SI")])
 
+(define_insn "naclcall"
+  [(unspec [(mem:QI (match_operand:SI 0 "register_operand" "r"))
+	          (match_operand 1 "" "")] UNSPEC_NACLCALL)]
+  "!SIBLING_CALL_P (insn) && !TARGET_64BIT"
+{
+  gcc_assert (flag_control_integrity);
+  return "naclcall\t%0";
+}
+  [(set_attr "type" "call")])
+
+(define_insn "naclsibcall"
+  [(unspec [(mem:QI (match_operand:SI 0 "register_operand" "s,c,d,a"))
+	          (match_operand 1 "" "")] UNSPEC_NACLCALL)]
+  "SIBLING_CALL_P (insn) && !TARGET_64BIT"
+{
+  gcc_assert (flag_control_integrity);
+  return "nacljmp\t%0";
+}
+  [(set_attr "type" "call")])
+
+(define_insn "naclcall_pop"
+  [(unspec [(mem:QI (match_operand:SI 0 "register_operand" "r"))
+	          (match_operand:SI 1 "" "")] UNSPEC_NACLCALL)
+   (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG)
+			    (match_operand:SI 2 "immediate_operand" "i")))]
+  "!TARGET_64BIT"
+{
+  gcc_assert (flag_control_integrity);
+  if (SIBLING_CALL_P (insn))
+    return "nacljmp\t%0";
+  else
+    return "naclcall\t%0";
+}
+  [(set_attr "type" "call")])
+
+(define_insn "naclcall_value"
+  [(set (match_operand 0 "" "")
+        (unspec [(mem:QI (match_operand:SI 1 "register_operand" "r"))
+	               (match_operand 2 "" "")] UNSPEC_NACLCALL))]
+  "!SIBLING_CALL_P (insn) && !TARGET_64BIT"
+{
+  gcc_assert (flag_control_integrity);
+  return "naclcall\t%1";
+}
+  [(set_attr "type" "callv")])
+
+(define_insn "naclsibcall_value"
+  [(set (match_operand 0 "" "")
+        (unspec [(mem:QI (match_operand:SI 1 "register_operand" "s,c,d,a"))
+	               (match_operand 2 "" "")] UNSPEC_NACLCALL))]
+  "SIBLING_CALL_P (insn) && !TARGET_64BIT"
+{
+  gcc_assert (flag_control_integrity);
+  return "nacljmp\t%1";
+}
+  [(set_attr "type" "callv")])
+
+(define_insn "naclcall_value_pop"
+  [(set (match_operand 0 "" "")
+	      (unspec [(mem:QI (match_operand:SI 1 "register_operand" "r"))
+	               (match_operand:SI 2 "" "")] UNSPEC_NACLCALL))
+   (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG)
+			    (match_operand:SI 3 "immediate_operand" "i")))]
+  "!TARGET_64BIT"
+{
+  gcc_assert (flag_control_integrity);
+  if (SIBLING_CALL_P (insn))
+    return "nacljmp\t%1";
+  else
+    return "naclcall\t%1";
+}
+  [(set_attr "type" "callv")])
+
+(define_insn "nacljmp_indirect"
+  [(set (pc) (unspec [(match_operand:SI 0 "register_operand" "r")]
+    UNSPEC_NACLJMP))]
+  "!TARGET_64BIT"
+  "nacljmp\t%0"
+  [(set_attr "type" "ibr")
+   (set_attr "length_immediate" "0")])
+
+(define_insn "nacljmp_table"
+  [(set (pc) (unspec [(match_operand:SI 0 "register_operand" "r")]
+    UNSPEC_NACLJMP))
+   (use (label_ref (match_operand 1 "" "")))]
+  "!TARGET_64BIT"
+  "nacljmp\t%0"
+  [(set_attr "type" "ibr")
+   (set_attr "length_immediate" "0")])
+
+(define_insn "nacl_return_indirect"
+  [(unspec [(return) (use (match_operand:SI 0 "register_operand" "r"))]
+    UNSPEC_NACLRET)]
+  "!TARGET_64BIT"
+  "nacljmp\t%0"
+  [(set_attr "type" "ibr")
+   (set_attr "length_immediate" "0")])
+
 (define_insn "*iorsi_3"
   [(set (reg FLAGS_REG)
 	(compare (ior:SI (match_operand:SI 1 "nonimmediate_operand" "%0")
@@ -14841,7 +14944,7 @@
 (define_insn "*indirect_jump"
   [(set (pc) (match_operand:P 0 "nonimmediate_operand" "rm"))]
   ""
-  "jmp\t%A0"
+  "nacljmp\t%0"
   [(set_attr "type" "ibr")
    (set_attr "length_immediate" "0")])
 
@@ -15234,7 +15337,15 @@
   if (crtl->args.pops_args)
     {
       rtx popc = GEN_INT (crtl->args.pops_args);
-      emit_jump_insn (gen_return_pop_internal (popc));
+      if (flag_control_integrity && !getenv("NONACLRET"))
+	{
+	  rtx ecx = gen_rtx_REG (SImode, 2);
+	  emit_insn (gen_popsi1 (ecx));
+	  emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, popc));
+	  emit_jump_insn (gen_nacl_return_indirect (ecx));
+	}
+      else
+	emit_jump_insn (gen_return_pop_internal (popc));
       DONE;
     }
 })
@@ -15242,9 +15353,14 @@
 (define_insn "return_internal"
   [(return)]
   "reload_completed"
-  "ret"
-  [(set_attr "length" "1")
-   (set_attr "length_immediate" "0")
+  {
+    if (flag_control_integrity && !getenv("NONACLRET"))
+      return "pop{l}\t%%ecx\nnacljmp\t%%ecx";
+    else
+      return "ret";
+    /* USED TO HAVE [(set_attr "length" "1") */
+  }
+  [(set_attr "length_immediate" "0")
    (set_attr "modrm" "0")])
 
 ;; Used by x86_machine_dependent_reorg to avoid penalty on single byte RET
@@ -15254,9 +15370,14 @@
   [(return)
    (unspec [(const_int 0)] UNSPEC_REP)]
   "reload_completed"
-  "rep\;ret"
-  [(set_attr "length" "1")
-   (set_attr "length_immediate" "0")
+  {
+    if (flag_control_integrity && !getenv("NONACLRET"))
+      return "pop{l}\t%%ecx\nnacljmp\t%%ecx";
+    else
+      return "rep\;ret";
+    /* USED TO HAVE [(set_attr "length" "1") */
+  }
+  [(set_attr "length_immediate" "0")
    (set_attr "prefix_rep" "1")
    (set_attr "modrm" "0")])
 
@@ -15264,9 +15385,14 @@
   [(return)
    (use (match_operand:SI 0 "const_int_operand" ""))]
   "reload_completed"
-  "ret\t%0"
-  [(set_attr "length" "3")
-   (set_attr "length_immediate" "2")
+  {
+    if (flag_control_integrity && !getenv("NONACLRET"))
+      return "pop{l}\t%%ecx\nadd{l}\t%%esp,%0\nnacljmp\t%%ecx";
+    else
+      return "ret\t%0";
+      /* USED TO HAVE [(set_attr "length" "3") */
+  }
+  [(set_attr "length_immediate" "2")
    (set_attr "modrm" "0")])
 
 (define_insn "return_indirect_internal"
diff -uNr gcc-4.4.0.orig/gcc/config/i386/nacl.h gcc-4.4.0/gcc/config/i386/nacl.h
--- gcc-4.4.0.orig/gcc/config/i386/nacl.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.0/gcc/config/i386/nacl.h	2009-06-24 00:57:00.000000000 +0200
@@ -0,0 +1,75 @@
+/* Target definitions for GCC for NativeClient using ELF
+   Copyright (C) 1988, 1991, 1995, 2000, 2001, 2002
+   Free Software Foundation, Inc.
+
+   Derived from sysv4.h written by Ron Guilmette (rfg@netcom.com).
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* These definitions modify those in i386elf.h. */
+
+#undef TARGET_VERSION
+#define TARGET_VERSION fprintf (stderr, " (NativeClient)");
+
+/* Pass the NativeClient specific options to the assembler */
+#undef  ASM_SPEC
+#define ASM_SPEC \
+  "%{v:-V} %{Qy:} %{!Qn:-Qy} %{n} %{T} " \
+  "%{fnacl-library-mode:-nacl-library-mode} " \
+  "%{fnacl-align-16:-nacl-align=4} " \
+  "%{fnacl-align-32:-nacl-align=5} " \
+  "%{Ym,*} %{Yd,*} %{Wa,*:%*}"
+
+#undef	LIB_SPEC
+#define LIB_SPEC \
+  "%{pthread:-lpthread} \
+   %{shared:-lc} \
+   %{!shared:%{mieee-fp:-lieee} %{profile:-lc_p}%{!profile:-lc}} -lnacl -lsrpc"
+
+/*
+ * Set the linker emulation to be elf_nacl rather than linux.h's default
+ * (elf_i386).
+ */
+#ifdef LINK_EMULATION
+#undef LINK_EMULATION
+#endif
+#define LINK_EMULATION "elf_nacl"
+
+/*
+ * Because of NaCl's use of segment registers, negative offsets from gs: will
+ * not work.  Hence we need to make TLS references explicitly compute the
+ * tls base pointer and then indirect relative to it using the default
+ * segment descriptor (DS).  That is, instead of
+ *    movl gs:i@NTPOFF, %ecx
+ * we use
+ *   movl %gs:0, %eax
+ *   movl i@NTPOFF(%eax), %ecx
+ * There is a slight performance penalty for TLS accesses, but there does not
+ * seem a way around it.
+ */
+#undef TARGET_TLS_DIRECT_SEG_REFS_DEFAULT
+#define TARGET_TLS_DIRECT_SEG_REFS_DEFAULT 0
+
+#undef TARGET_OS_CPP_BUILTINS
+#define TARGET_OS_CPP_BUILTINS()			\
+  do							\
+    {							\
+	LINUX_TARGET_OS_CPP_BUILTINS();			\
+	builtin_define ("__native_client__=1");		\
+  }							\
+  while (0)
diff -uNr gcc-4.4.0.orig/gcc/config/nacl.opt gcc-4.4.0/gcc/config/nacl.opt
--- gcc-4.4.0.orig/gcc/config/nacl.opt	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.0/gcc/config/nacl.opt	2009-06-24 00:57:00.000000000 +0200
@@ -0,0 +1,54 @@
+; Processor-independent options for GNU/Linux.
+;
+; Copyright (C) 2006, 2007 Free Software Foundation, Inc.
+; Contributed by Google
+;
+; This file is part of GCC.
+;
+; GCC is free software; you can redistribute it and/or modify it under
+; the terms of the GNU General Public License as published by the Free
+; Software Foundation; either version 3, or (at your option) any later
+; version.
+;
+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+; WARRANTY; without even the implied warranty of MERCHANTABILITY or
+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+; for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with GCC; see the file COPYING3.  If not see
+; <http://www.gnu.org/licenses/>.
+
+fcontrol-integrity
+Common Report Var(flag_control_integrity) Init(1)
+Expand indirect call, jmp, and rets
+
+falign-functions
+Common Report Var(align_functions,NACL_ALIGN_BYTES) Init(NACL_ALIGN_BYTES)
+Align the start of functions
+
+falign-functions=
+Common RejectNegative Joined UInteger
+
+falign-jumps
+Common Report Var(align_jumps,NACL_ALIGN_BYTES) Init(NACL_ALIGN_BYTES)
+Align labels which are only reached by jumping
+
+falign-jumps=
+Common RejectNegative Joined UInteger
+
+falign-labels
+Common Report Var(align_labels,NACL_ALIGN_BYTES) Init(NACL_ALIGN_BYTES)
+Align all labels
+
+falign-labels=
+Common RejectNegative Joined UInteger
+
+fnacl-library-mode
+Common Report Var(flag_nacl_library_mode,1) Init(0)
+
+fnacl-align-16
+Common Report Var(flag_nacl_align_pow2,4) Init(NACL_ALIGN_POW2)
+
+fnacl-align-32
+Common Report Var(flag_nacl_align_pow2,5)
diff -uNr gcc-4.4.0.orig/gcc/config.gcc gcc-4.4.0/gcc/config.gcc
--- gcc-4.4.0.orig/gcc/config.gcc	2009-04-17 13:58:41.000000000 +0200
+++ gcc-4.4.0/gcc/config.gcc	2009-06-24 00:57:00.000000000 +0200
@@ -482,7 +482,20 @@
   esac
   fbsd_tm_file="${fbsd_tm_file} freebsd-spec.h freebsd.h"
   ;;
-*-*-linux* | frv-*-*linux* | *-*-kfreebsd*-gnu | *-*-knetbsd*-gnu | *-*-gnu* | *-*-kopensolaris*-gnu)
+*-*-nnacl*)
+  extra_parts="crtbegin.o crtbeginS.o crtbeginT.o crtend.o crtendS.o"
+  extra_options="${extra_options} linux.opt nacl.opt"
+  gas=yes
+  gnu_ld=yes
+  case ${enable_threads} in
+    "" | yes | posix) thread_file='posix' ;;
+  esac
+  tmake_file="t-slibgcc-elf-ver t-linux"
+  tm_defines="${tm_defines} UCLIBC_DEFAULT=0"
+  # Assume that glibc or uClibc are being used and so __cxa_atexit is provided.
+  default_use_cxa_atexit=yes
+  ;;
+*-*-linux* | frv-*-*linux* | *-*-kfreebsd*-gnu | *-*-knetbsd*-gnu | *-*-gnu* | *-*-kopensolaris*-gnu | *-*-nacl*)
   extra_parts="crtbegin.o crtbeginS.o crtbeginT.o crtend.o crtendS.o"
   gas=yes
   gnu_ld=yes
@@ -508,6 +521,10 @@
     *-*-*uclibc*)
       tm_defines="${tm_defines} UCLIBC_DEFAULT=1"
       ;;
+    *-*-nacl*)
+      extra_options="${extra_options} nacl.opt"
+      tm_defines="${tm_defines} UCLIBC_DEFAULT=0"
+      ;;
     *)
       tm_defines="${tm_defines} UCLIBC_DEFAULT=0"
       ;;
@@ -1076,7 +1093,13 @@
 i[34567]86-*-coff*)
 	tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h dbxcoff.h i386/i386-coff.h"
 	;;
-i[34567]86-*-linux* | i[34567]86-*-kfreebsd*-gnu | i[34567]86-*-knetbsd*-gnu | i[34567]86-*-gnu* | i[34567]86-*-kopensolaris*-gnu)
+*-*-nnacl*)
+	# Intel 80386's running NativeClient /*
+	# with ELF format using glibc 2
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h linux.h i386/linux.h"
+	tmake_file="${tmake_file} i386/t-crtstuff i386/t-crtfm t-dfprules"
+	;;
+i[34567]86-*-linux* | i[34567]86-*-kfreebsd*-gnu | i[34567]86-*-knetbsd*-gnu | i[34567]86-*-gnu* | i[34567]86-*-kopensolaris*-gnu | *-*-nacl*)
 			# Intel 80386's running GNU/*
 			# with ELF format using glibc 2
 	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h linux.h"
@@ -1109,6 +1132,7 @@
 	i[34567]86-*-kfreebsd*-gnu) tm_file="${tm_file} i386/linux.h kfreebsd-gnu.h i386/kfreebsd-gnu.h" ;;
 	i[34567]86-*-kopensolaris*-gnu) tm_file="${tm_file} i386/linux.h kopensolaris-gnu.h i386/kopensolaris-gnu.h" ;;
 	i[34567]86-*-gnu*) tm_file="$tm_file i386/linux.h gnu.h i386/gnu.h";;
+        *-*-nacl*) tm_file="${tm_file} i386/nacl.h" ;;
 	esac
 	tmake_file="${tmake_file} i386/t-crtstuff i386/t-crtpc i386/t-crtfm t-dfprules"
 	;;
diff -uNr gcc-4.4.0.orig/gcc/configure gcc-4.4.0/gcc/configure
--- gcc-4.4.0.orig/gcc/configure	2009-03-24 18:46:03.000000000 +0100
+++ gcc-4.4.0/gcc/configure	2009-06-24 00:57:00.000000000 +0200
@@ -7835,7 +7835,7 @@
 else
 
   case $target in
-    powerpc*-*-linux* | i?86*-*-linux* | x86_64*-*-linux*)
+    powerpc*-*-linux* | i?86*-*-linux* | x86_64*-*-linux* | i?86*-*-nacl*)
       enable_decimal_float=yes
       ;;
     *)
@@ -11701,7 +11701,7 @@
                 if test "X$additional_includedir" = "X/usr/local/include"; then
                   if test -n "$GCC"; then
                     case $host_os in
-                      linux*) haveit=yes;;
+                      linux* | nacl*) haveit=yes;;
                     esac
                   fi
                 fi
@@ -11745,7 +11745,7 @@
                       if test "X$additional_libdir" = "X/usr/local/lib"; then
                         if test -n "$GCC"; then
                           case $host_os in
-                            linux*) haveit=yes;;
+                            linux* | nacl*) haveit=yes;;
                           esac
                         fi
                       fi
@@ -13333,7 +13333,7 @@
     # default
     target_thread_file='single'
     ;;
-  aix | dce | gnat | irix | posix | posix95 | rtems | \
+  aix | dce | gnat | irix | nacl | posix | posix95 | rtems | \
   single | solaris | vxworks | win32 | mipssde)
     target_thread_file=${enable_threads}
     ;;
@@ -20817,6 +20817,7 @@
 	in_tree_ld_is_elf=no
 	if (grep 'EMUL = .*elf' ../ld/Makefile \
 	    || grep 'EMUL = .*linux' ../ld/Makefile \
+	    || grep 'EMUL = .*nacl' ../ld/Makefile \
 	    || grep 'EMUL = .*lynx' ../ld/Makefile) > /dev/null; then
 	  in_tree_ld_is_elf=yes
 	fi
diff -uNr gcc-4.4.0.orig/gcc/configure.ac gcc-4.4.0/gcc/configure.ac
--- gcc-4.4.0.orig/gcc/configure.ac	2009-03-24 18:46:03.000000000 +0100
+++ gcc-4.4.0/gcc/configure.ac	2009-06-24 00:57:00.000000000 +0200
@@ -605,7 +605,7 @@
 ],
 [
   case $target in
-    powerpc*-*-linux* | i?86*-*-linux* | x86_64*-*-linux*)
+    powerpc*-*-linux* | i?86*-*-linux* | x86_64*-*-linux* | i?86*-*-nacl*)
       enable_decimal_float=yes
       ;;
     *)
@@ -1353,7 +1353,7 @@
     # default
     target_thread_file='single'
     ;;
-  aix | dce | gnat | irix | posix | posix95 | rtems | \
+  aix | dce | gnat | irix | nacl | posix | posix95 | rtems | \
   single | solaris | vxworks | win32 | mipssde)
     target_thread_file=${enable_threads}
     ;;
@@ -1928,6 +1928,7 @@
 	in_tree_ld_is_elf=no
 	if (grep 'EMUL = .*elf' ../ld/Makefile \
 	    || grep 'EMUL = .*linux' ../ld/Makefile \
+	    || grep 'EMUL = .*nacl' ../ld/Makefile \
 	    || grep 'EMUL = .*lynx' ../ld/Makefile) > /dev/null; then
 	  in_tree_ld_is_elf=yes
 	fi
@@ -2506,7 +2507,7 @@
 	tls_first_major=2
 	tls_first_minor=17
 	;;
-  i[34567]86-*-*)
+  i[34567]86*-*-*)
     conftest_s='
 	.section ".tdata","awT",@progbits
 foo:	.long	25
@@ -2940,7 +2941,7 @@
     ;;
 
 changequote(,)dnl
-  i[34567]86-*-* | x86_64-*-*)
+  i[34567]86*-*-* | x86_64-*-*)
 changequote([,])dnl
     case $target_os in
       cygwin* | pe | mingw32*)
diff -uNr gcc-4.4.0.orig/gcc/ctrl-intg.c gcc-4.4.0/gcc/ctrl-intg.c
--- gcc-4.4.0.orig/gcc/ctrl-intg.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.0/gcc/ctrl-intg.c	2009-06-24 01:01:46.000000000 +0200
@@ -0,0 +1,355 @@
+/* Patch RTL to enforce control flow integrity for GCC.
+   Copyright (C) 1987, 1988, 1992, 1997, 1998, 1999, 2000, 2002, 2003,
+   2004, 2005, 2007
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* This file is compiled twice: once for the generator programs,
+   once for the compiler.  */
+#ifdef GENERATOR_FILE
+#include "bconfig.h"
+#else
+#include "config.h"
+#endif
+
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "rtl.h"
+#include "tree-pass.h"
+#include "expr.h"
+
+/* These headers all define things which are not available in
+   generator programs.  */
+#ifndef GENERATOR_FILE
+#include "tree.h"
+#include "real.h"
+#include "flags.h"
+#include "hard-reg-set.h"
+#include "basic-block.h"
+#endif
+
+static bool
+gate_func (void) {
+  return getenv("NACLSHUTDOWN") == NULL;
+  /* return flag_control_integrity; */
+}
+
+static void
+process_call_insn(rtx insn) {
+  rtx return_value_expr, call_expr, mem_expr, addr_expr, parallel_expr;
+  rtx sp_size_expr;
+
+  /*
+   * Get the expression to be examined from the instruction.
+   */
+  call_expr = XEXP (insn, 5);
+
+  if (GET_CODE (call_expr) == PARALLEL) {
+    /*
+     * Calls that pop the stack use a PARALLEL containing a CALL and a SET.
+     */
+    parallel_expr = call_expr;
+    sp_size_expr = XEXP (XEXP (XVECEXP (call_expr, 0, 1), 1), 1);
+    call_expr = XVECEXP (call_expr, 0, 0);
+  }
+  else {
+    parallel_expr = NULL_RTX;
+  }
+
+  /*
+   * Get the call expression and return value (if any).
+   */
+  if (GET_CODE (call_expr) == SET) {
+    /*
+     * Functions with return values use a SET instruction wrapper.
+     * Get the call out of the set if needed.
+     */
+    return_value_expr = XEXP (call_expr, 0);
+    call_expr = XEXP (call_expr, 1);
+  }
+  else {
+    return_value_expr = NULL_RTX;
+  }
+
+  /*
+   *  Extract the target address expression of the function.
+   */
+  mem_expr = XEXP (call_expr, 0);
+
+  /*
+   * Get the address expression from the MEM.
+   */
+
+  gcc_assert (GET_CODE (mem_expr) == MEM);
+  addr_expr = XEXP (mem_expr, 0);
+
+  if (GET_CODE (addr_expr) != SYMBOL_REF) {
+    rtx insns_head, call, call_insn;
+    int enable_print;
+
+    {
+      static int calls_converted=0;
+      static int printed=0;
+      char* call_limit = getenv("NONACLCALL");
+      char* name_compare = getenv("NACLBINS");
+      if (name_compare && strcmp(main_input_filename, name_compare) > 0) {
+        if (printed == 0) {
+          fprintf(stderr, "NACL: name test shut off\n");
+          printed = 1;
+        }
+        return;
+      }
+
+      ++calls_converted;
+      enable_print = (call_limit && calls_converted == atoi(call_limit));
+      if (call_limit && calls_converted > atoi(call_limit)) {
+        if (printed == 0) {
+          fprintf(stderr, "NACL: '%s' call limit exceeded\n",
+                  main_input_filename);
+          printed = 1;
+        }
+        return;
+      }
+      /* fprintf(stderr, "NACL: converted call %d\n", calls_converted); */
+    }
+
+    if (return_value_expr && parallel_expr) {
+      if (getenv("NACLDBGBOTH")) return;
+    } else if (return_value_expr) {
+      if (getenv("NACLDBGRET")) return;
+    } else if (parallel_expr) {
+      if (getenv("NACLDBGPAR")) return;
+    } else {
+      if (SIBLING_CALL_P (insn)) {
+        if (getenv("NACLDBGNONE1")) return;
+      } else {
+        char* str = getenv("NACLDBGNONE2");
+        if (str) {
+          FILE* fp = fopen("/home/sehr/NACLDBGCOUNT", "r+");
+          int current_count;
+          fscanf(fp, "%d\n", &current_count);
+            fprintf(stderr, "NACLDEBUGCOUNT = %d \n", current_count);
+          rewind(fp);
+          fprintf(fp, "%d\n", current_count+1);
+          fclose(fp);
+          if (current_count > atoi(str)) {
+            fprintf(stderr, "NACLDEBUGCOUNT %d exceeded %d\n",
+                    current_count, atoi(str));
+            return;
+          }
+        }
+      }
+    }
+
+    start_sequence ();
+
+    if (enable_print) {
+      fprintf(stderr, "Before:\n");
+      print_rtl_single(stderr, insn);
+    }
+
+    /*
+     * Force the called function address to be in a register.
+     */
+    addr_expr = force_reg (GET_MODE (addr_expr), addr_expr);
+
+    /*
+     * Generate the appropriate template for the call
+     */
+    if (return_value_expr && parallel_expr) {
+      call = gen_naclcall_value_pop (return_value_expr, addr_expr,
+                                     XEXP (call_expr, 1), sp_size_expr);
+    } else if (return_value_expr) {
+      if (SIBLING_CALL_P (insn)) {
+        call = gen_naclsibcall_value (return_value_expr,
+                                      addr_expr, XEXP (call_expr, 1));
+      } else {
+        call = gen_naclcall_value (return_value_expr,
+                                   addr_expr, XEXP (call_expr, 1));
+      }
+    } else if (parallel_expr) {
+      call = gen_naclcall_pop (addr_expr, XEXP (call_expr, 1),
+                               sp_size_expr);
+    } else {
+      if (SIBLING_CALL_P (insn)) {
+        call = gen_naclsibcall (addr_expr, XEXP (call_expr, 1));
+      } else {
+        call = gen_naclcall (addr_expr, XEXP (call_expr, 1));
+      }
+    }
+
+    call_insn = emit_call_insn (call);
+
+    RTL_CONST_CALL_P (call_insn) = RTL_CONST_CALL_P (insn);
+    RTL_PURE_CALL_P (call_insn) = RTL_PURE_CALL_P (insn);
+    SIBLING_CALL_P (call_insn) = SIBLING_CALL_P (insn);
+
+    insns_head = get_insns ();
+
+    if (enable_print) {
+      fprintf(stderr, "After: (%d, %d) \n", RTL_CONST_OR_PURE_CALL_P (call_insn),
+              SIBLING_CALL_P (call_insn));
+      print_rtl(stderr, insns_head);
+    }
+
+    end_sequence ();
+    emit_insn_before (insns_head, insn);
+
+    delete_insn (insn);
+  }
+}
+
+
+static void
+process_jump_insn(rtx insn) {
+  rtx par_expr, set_expr, addr_expr;
+  rtx jmp;
+
+  /*
+   * Get the contained expression.
+   */
+  par_expr = XEXP (insn, 5);
+
+  if (GET_CODE (par_expr) == PARALLEL) {
+    set_expr = XVECEXP (par_expr, 0, 0);
+
+    if (GET_CODE (set_expr) == SET) {
+      addr_expr = XEXP (set_expr, 1);
+
+      if (GET_CODE (addr_expr) == IF_THEN_ELSE) {
+        /*
+         * Ordinary branches uses parallel/set/if_then_else.
+         * Leave them unmodified.
+         */
+      }
+      else {
+        /*
+         * A table indirect jump instruction has parallel/set/other
+         */
+        rtx insns_head, jmp_insn;
+        int enable_print;
+
+        {
+          static int calls_converted=0;
+          static int printed=0;
+          char* name_compare = getenv("NACLBINS");
+          char* call_limit = getenv("NONACLJMP");
+          if (name_compare && strcmp(main_input_filename, name_compare) > 0) {
+            fprintf(stderr, "NACL: name test shut off\n");
+            return;
+          }
+
+          ++calls_converted;
+          enable_print = (call_limit && calls_converted == atoi(call_limit));
+          if (call_limit && calls_converted > atoi(call_limit)) {
+            if (printed == 0) {
+              fprintf(stderr, "NACL: '%s' call limit exceeded\n",
+                      main_input_filename);
+              printed = 1;
+            }
+            return;
+          }
+          /*fprintf(stderr, "NACL: converted branch %d\n", calls_converted);*/
+        }
+
+        start_sequence ();
+
+        if (enable_print) {
+          fprintf(stderr, "Before:\n");
+          print_rtl_single(stderr, insn);
+        }
+        addr_expr = force_reg (GET_MODE (addr_expr), addr_expr);
+        jmp = gen_nacljmp_table (addr_expr,
+                                 XEXP (XEXP (XVECEXP (par_expr, 0, 1), 0), 0));
+        jmp_insn = emit_jump_insn (jmp);
+
+        if (JUMP_LABEL (insn) != NULL_RTX) {
+           JUMP_LABEL (jmp_insn) = JUMP_LABEL (insn);
+           LABEL_NUSES (JUMP_LABEL (insn))++;
+        }
+
+        insns_head = get_insns ();
+        if (enable_print) {
+          fprintf(stderr, "After %p:\n", (void*) JUMP_LABEL (jmp_insn));
+          print_rtl(stderr, insns_head);
+        }
+
+        end_sequence ();
+        emit_insn_before (insns_head, insn);
+
+        delete_insn (insn);
+      }
+    }
+  } else {
+    /*
+     * Other indirect jumps remain to be identified.
+     */
+  }
+}
+
+extern int nacl_special_commands;
+
+static int
+execute_func (void) {
+  basic_block bb;
+
+  int save_nacl_special_commands = nacl_special_commands;
+  nacl_special_commands = 1;
+  
+  if (getenv("NACLSHUTDOWN4")) return 0;
+  /* Even if reload is not yet completed - fake it to make reload impossible */
+  FOR_EACH_BB (bb) {
+    rtx insn, last;
+
+    if (getenv("NACLSHUTDOWN3")) continue;
+    for (insn = BB_HEAD (bb), last = NEXT_INSN (BB_END (bb)); insn != last;
+         insn = NEXT_INSN(insn)) {
+      if (getenv("NACLSHUTDOWN2")) continue;
+      if (JUMP_P (insn)) {
+        if (flag_control_integrity)
+          process_jump_insn (insn);
+      }
+      if (CALL_P (insn)) {
+        if (flag_control_integrity)
+          process_call_insn (insn);
+      }
+    }
+  }
+
+  nacl_special_commands = save_nacl_special_commands;
+  return 0;
+}
+
+struct rtl_opt_pass pass_control_integrity = {
+  {
+    RTL_PASS,
+    "ctrl_intg_insert",
+    gate_func,
+    execute_func,
+    0, /* sub */
+    0, /* next */
+    0, /* static_pass_number */
+    0, /* tv_id */
+    0, /* properties_required */
+    0, /* properties_provided */
+    0, /* properties_destroyed */
+    TODO_dump_func, /* todo_flags_start */
+    TODO_dump_func, /* todo_flags_finish */
+  }
+};
diff -uNr gcc-4.4.0.orig/gcc/dwarf2out.c gcc-4.4.0/gcc/dwarf2out.c
--- gcc-4.4.0.orig/gcc/dwarf2out.c	2009-03-24 00:21:38.000000000 +0100
+++ gcc-4.4.0/gcc/dwarf2out.c	2009-06-24 00:57:00.000000000 +0200
@@ -1414,8 +1414,16 @@
 	    insn = XVECEXP (insn, 0, 0);
 	  if (GET_CODE (insn) == SET)
 	    insn = SET_SRC (insn);
-	  gcc_assert (GET_CODE (insn) == CALL);
-	  dwarf2out_args_size ("", INTVAL (XEXP (insn, 1)));
+	  if (GET_CODE (insn) == CALL) {
+	    dwarf2out_args_size ("", INTVAL (XEXP (insn, 1)));
+	  }
+	  else if ((GET_CODE (insn) == UNSPEC) &&
+		   (XINT (insn, 1) == UNSPEC_NACLCALL)) {
+	    dwarf2out_args_size ("", INTVAL (XVECEXP (insn, 0, 1)));
+	  }
+	  else {
+	    internal_error ("Not recognized as a call or naclcall");
+	  }
 	}
       return;
     }
diff -uNr gcc-4.4.0.orig/gcc/emit-rtl.c gcc-4.4.0/gcc/emit-rtl.c
--- gcc-4.4.0.orig/gcc/emit-rtl.c	2009-03-04 02:57:29.000000000 +0100
+++ gcc-4.4.0/gcc/emit-rtl.c	2009-06-24 01:00:11.000000000 +0200
@@ -852,6 +852,10 @@
     return -subreg_lowpart_offset (inner_mode, outer_mode);
 }
 
+/* NaCl require temporary variables in places where usually it's
+   not allowed */
+int nacl_special_commands = 0;
+
 /* Generate a REG rtx for a new pseudo register of mode MODE.
    This pseudo is assigned the next sequential register number.  */
 
@@ -861,7 +865,7 @@
   rtx val;
   unsigned int align = GET_MODE_ALIGNMENT (mode);
 
-  gcc_assert (can_create_pseudo_p ());
+  gcc_assert (can_create_pseudo_p () || nacl_special_commands);
 
   /* If a virtual register with bigger mode alignment is generated,
      increase stack alignment estimation because it might be spilled
diff -uNr gcc-4.4.0.orig/gcc/final.c gcc-4.4.0/gcc/final.c
--- gcc-4.4.0.orig/gcc/final.c	2008-12-10 09:46:40.000000000 +0100
+++ gcc-4.4.0/gcc/final.c	2009-06-24 00:57:00.000000000 +0200
@@ -1755,7 +1755,8 @@
   gcc_assert (CALL_P (insn));
   x = PATTERN (insn);
 
-  while (GET_CODE (x) != CALL)
+  while (GET_CODE (x) != CALL &&
+         !(GET_CODE (x) == UNSPEC && XINT (x, 1) == UNSPEC_NACLCALL))
     {
       switch (GET_CODE (x))
 	{
diff -uNr gcc-4.4.0.orig/gcc/gthr-nacl.h gcc-4.4.0/gcc/gthr-nacl.h
--- gcc-4.4.0.orig/gcc/gthr-nacl.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.0/gcc/gthr-nacl.h	2009-06-24 00:57:00.000000000 +0200
@@ -0,0 +1,553 @@
+/* Threads compatibility routines for libgcc2 and libobjc.  */
+/* Compile this one with gcc.  */
+/* Copyright (C) 1997, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 2, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to the Free
+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301, USA.  */
+
+/* As a special exception, if you link this library with other files,
+   some of which are compiled with GCC, to produce an executable,
+   this library does not by itself cause the resulting executable
+   to be covered by the GNU General Public License.
+   This exception does not however invalidate any other reasons why
+   the executable file might be covered by the GNU General Public License.  */
+
+#ifndef GCC_GTHR_POSIX_H
+#define GCC_GTHR_POSIX_H
+
+/* POSIX threads specific definitions.
+   Easy, since the interface is just one-to-one mapping.  */
+
+#define __GTHREADS 1
+
+/* Some implementations of <pthread.h> require this to be defined.  */
+#if !defined(_REENTRANT) && defined(__osf__)
+#define _REENTRANT 1
+#endif
+
+#include <pthread.h>
+#include <unistd.h>
+
+typedef pthread_key_t __gthread_key_t;
+typedef pthread_once_t __gthread_once_t;
+typedef pthread_mutex_t __gthread_mutex_t;
+typedef pthread_mutex_t __gthread_recursive_mutex_t;
+
+#define __GTHREAD_MUTEX_INIT PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
+#define __GTHREAD_ONCE_INIT PTHREAD_ONCE_INIT
+#define __GTHREAD_RECURSIVE_MUTEX_INIT PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
+
+#if SUPPORTS_WEAK && GTHREAD_USE_WEAK
+# ifndef __gthrw_pragma
+#  define __gthrw_pragma(pragma)
+# endif
+# define __gthrw2(name,name2,type) \
+  static __typeof(type) name __attribute__ ((__weakref__(#name2))); \
+  __gthrw_pragma(weak type)
+# define __gthrw_(name) __gthrw_ ## name
+#else
+# define __gthrw2(name,name2,type)
+# define __gthrw_(name) name
+#endif
+
+/* Typically, __gthrw_foo is a weak reference to symbol foo.  */
+#define __gthrw(name) __gthrw2(__gthrw_ ## name,name,name)
+
+__gthrw(pthread_once)
+__gthrw(pthread_getspecific)
+__gthrw(pthread_setspecific)
+__gthrw(pthread_create)
+__gthrw(pthread_mutex_lock)
+__gthrw(pthread_mutex_trylock)
+__gthrw(pthread_mutex_unlock)
+__gthrw(pthread_mutex_init)
+
+__gthrw(pthread_key_create)
+__gthrw(pthread_key_delete)
+
+
+#if defined(_LIBOBJC) || defined(_LIBOBJC_WEAK)
+/* Objective-C.  */
+__gthrw(pthread_cond_broadcast)
+__gthrw(pthread_cond_destroy)
+__gthrw(pthread_cond_init)
+__gthrw(pthread_cond_signal)
+__gthrw(pthread_cond_wait)
+__gthrw(pthread_exit)
+__gthrw(pthread_mutex_destroy)
+__gthrw(pthread_self)
+#ifdef _POSIX_PRIORITY_SCHEDULING
+#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING
+__gthrw(sched_get_priority_max)
+__gthrw(sched_get_priority_min)
+#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */
+#endif /* _POSIX_PRIORITY_SCHEDULING */
+__gthrw(sched_yield)
+__gthrw(pthread_attr_destroy)
+__gthrw(pthread_attr_init)
+__gthrw(pthread_attr_setdetachstate)
+#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING
+__gthrw(pthread_getschedparam)
+__gthrw(pthread_setschedparam)
+#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */
+#endif /* _LIBOBJC || _LIBOBJC_WEAK */
+
+static inline int
+__gthread_active_p (void)
+{
+  /*
+   * The threading library is active if a basic thread creation/destruction
+   * primitive is referenced.  Unfortunately we don't have those yet.
+   * TODO: change to reference a thread creation/destruction function
+   *             when one becomes available.
+   */
+  static void *const __gthread_active_ptr
+    = __extension__ (void *) &__gthrw_(pthread_mutex_lock);
+  return __gthread_active_ptr != 0;
+}
+
+#ifdef _LIBOBJC
+
+/* This is the config.h file in libobjc/ */
+#include <config.h>
+
+#ifdef HAVE_SCHED_H
+# include <sched.h>
+#endif
+
+/* Key structure for maintaining thread specific storage */
+static pthread_key_t _objc_thread_storage;
+static pthread_attr_t _objc_thread_attribs;
+
+/* Thread local storage for a single thread */
+static void *thread_local_storage = NULL;
+
+/* Backend initialization functions */
+
+/* Initialize the threads subsystem.  */
+static inline int
+__gthread_objc_init_thread_system (void)
+{
+  if (__gthread_active_p ())
+    {
+      /* Initialize the thread storage key.  */
+      if (__gthrw_(pthread_key_create) (&_objc_thread_storage, NULL) == 0)
+	{
+	  /* The normal default detach state for threads is
+	   * PTHREAD_CREATE_JOINABLE which causes threads to not die
+	   * when you think they should.  */
+	  if (__gthrw_(pthread_attr_init) (&_objc_thread_attribs) == 0
+	      && __gthrw_(pthread_attr_setdetachstate) (&_objc_thread_attribs,
+					      PTHREAD_CREATE_DETACHED) == 0)
+	    return 0;
+	}
+    }
+
+  return -1;
+}
+
+/* Close the threads subsystem.  */
+static inline int
+__gthread_objc_close_thread_system (void)
+{
+  if (__gthread_active_p ()
+      && __gthrw_(pthread_key_delete) (_objc_thread_storage) == 0
+      && __gthrw_(pthread_attr_destroy) (&_objc_thread_attribs) == 0)
+    return 0;
+
+  return -1;
+}
+
+/* Backend thread functions */
+
+/* Create a new thread of execution.  */
+static inline objc_thread_t
+__gthread_objc_thread_detach (void (*func)(void *), void *arg)
+{
+  objc_thread_t thread_id;
+  pthread_t new_thread_handle;
+
+  if (!__gthread_active_p ())
+    return NULL;
+
+  if (!(__gthrw_(pthread_create) (&new_thread_handle, NULL, (void *) func, arg)))
+    thread_id = (objc_thread_t) new_thread_handle;
+  else
+    thread_id = NULL;
+
+  return thread_id;
+}
+
+/* Set the current thread's priority.  */
+static inline int
+__gthread_objc_thread_set_priority (int priority)
+{
+  if (!__gthread_active_p ())
+    return -1;
+  else
+    {
+#ifdef _POSIX_PRIORITY_SCHEDULING
+#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING
+      pthread_t thread_id = __gthrw_(pthread_self) ();
+      int policy;
+      struct sched_param params;
+      int priority_min, priority_max;
+
+      if (__gthrw_(pthread_getschedparam) (thread_id, &policy, &params) == 0)
+	{
+	  if ((priority_max = __gthrw_(sched_get_priority_max) (policy)) == -1)
+	    return -1;
+
+	  if ((priority_min = __gthrw_(sched_get_priority_min) (policy)) == -1)
+	    return -1;
+
+	  if (priority > priority_max)
+	    priority = priority_max;
+	  else if (priority < priority_min)
+	    priority = priority_min;
+	  params.sched_priority = priority;
+
+	  /*
+	   * The solaris 7 and several other man pages incorrectly state that
+	   * this should be a pointer to policy but pthread.h is universally
+	   * at odds with this.
+	   */
+	  if (__gthrw_(pthread_setschedparam) (thread_id, policy, &params) == 0)
+	    return 0;
+	}
+#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */
+#endif /* _POSIX_PRIORITY_SCHEDULING */
+      return -1;
+    }
+}
+
+/* Return the current thread's priority.  */
+static inline int
+__gthread_objc_thread_get_priority (void)
+{
+#ifdef _POSIX_PRIORITY_SCHEDULING
+#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING
+  if (__gthread_active_p ())
+    {
+      int policy;
+      struct sched_param params;
+
+      if (__gthrw_(pthread_getschedparam) (__gthrw_(pthread_self) (), &policy, &params) == 0)
+	return params.sched_priority;
+      else
+	return -1;
+    }
+  else
+#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */
+#endif /* _POSIX_PRIORITY_SCHEDULING */
+    return OBJC_THREAD_INTERACTIVE_PRIORITY;
+}
+
+/* Yield our process time to another thread.  */
+static inline void
+__gthread_objc_thread_yield (void)
+{
+  if (__gthread_active_p ())
+    __gthrw_(sched_yield) ();
+}
+
+/* Terminate the current thread.  */
+static inline int
+__gthread_objc_thread_exit (void)
+{
+  if (__gthread_active_p ())
+    /* exit the thread */
+    __gthrw_(pthread_exit) (&__objc_thread_exit_status);
+
+  /* Failed if we reached here */
+  return -1;
+}
+
+/* Returns an integer value which uniquely describes a thread.  */
+static inline objc_thread_t
+__gthread_objc_thread_id (void)
+{
+  if (__gthread_active_p ())
+    return (objc_thread_t) __gthrw_(pthread_self) ();
+  else
+    return (objc_thread_t) 1;
+}
+
+/* Sets the thread's local storage pointer.  */
+static inline int
+__gthread_objc_thread_set_data (void *value)
+{
+  if (__gthread_active_p ())
+    return __gthrw_(pthread_setspecific) (_objc_thread_storage, value);
+  else
+    {
+      thread_local_storage = value;
+      return 0;
+    }
+}
+
+/* Returns the thread's local storage pointer.  */
+static inline void *
+__gthread_objc_thread_get_data (void)
+{
+  if (__gthread_active_p ())
+    return __gthrw_(pthread_getspecific) (_objc_thread_storage);
+  else
+    return thread_local_storage;
+}
+
+/* Backend mutex functions */
+
+/* Allocate a mutex.  */
+static inline int
+__gthread_objc_mutex_allocate (objc_mutex_t mutex)
+{
+  if (__gthread_active_p ())
+    {
+      mutex->backend = objc_malloc (sizeof (pthread_mutex_t));
+
+      if (__gthrw_(pthread_mutex_init) ((pthread_mutex_t *) mutex->backend, NULL))
+	{
+	  objc_free (mutex->backend);
+	  mutex->backend = NULL;
+	  return -1;
+	}
+    }
+
+  return 0;
+}
+
+/* Deallocate a mutex.  */
+static inline int
+__gthread_objc_mutex_deallocate (objc_mutex_t mutex)
+{
+  if (__gthread_active_p ())
+    {
+      int count;
+
+      /*
+       * Posix Threads specifically require that the thread be unlocked
+       * for __gthrw_(pthread_mutex_destroy) to work.
+       */
+
+      do
+	{
+	  count = __gthrw_(pthread_mutex_unlock) ((pthread_mutex_t *) mutex->backend);
+	  if (count < 0)
+	    return -1;
+	}
+      while (count);
+
+      if (__gthrw_(pthread_mutex_destroy) ((pthread_mutex_t *) mutex->backend))
+	return -1;
+
+      objc_free (mutex->backend);
+      mutex->backend = NULL;
+    }
+  return 0;
+}
+
+/* Grab a lock on a mutex.  */
+static inline int
+__gthread_objc_mutex_lock (objc_mutex_t mutex)
+{
+  if (__gthread_active_p ()
+      && __gthrw_(pthread_mutex_lock) ((pthread_mutex_t *) mutex->backend) != 0)
+    {
+      return -1;
+    }
+
+  return 0;
+}
+
+/* Try to grab a lock on a mutex.  */
+static inline int
+__gthread_objc_mutex_trylock (objc_mutex_t mutex)
+{
+  if (__gthread_active_p ()
+      && __gthrw_(pthread_mutex_trylock) ((pthread_mutex_t *) mutex->backend) != 0)
+    {
+      return -1;
+    }
+
+  return 0;
+}
+
+/* Unlock the mutex */
+static inline int
+__gthread_objc_mutex_unlock (objc_mutex_t mutex)
+{
+  if (__gthread_active_p ()
+      && __gthrw_(pthread_mutex_unlock) ((pthread_mutex_t *) mutex->backend) != 0)
+    {
+      return -1;
+    }
+
+  return 0;
+}
+
+/* Backend condition mutex functions */
+
+/* Allocate a condition.  */
+static inline int
+__gthread_objc_condition_allocate (objc_condition_t condition)
+{
+  if (__gthread_active_p ())
+    {
+      condition->backend = objc_malloc (sizeof (pthread_cond_t));
+
+      if (__gthrw_(pthread_cond_init) ((pthread_cond_t *) condition->backend, NULL))
+	{
+	  objc_free (condition->backend);
+	  condition->backend = NULL;
+	  return -1;
+	}
+    }
+
+  return 0;
+}
+
+/* Deallocate a condition.  */
+static inline int
+__gthread_objc_condition_deallocate (objc_condition_t condition)
+{
+  if (__gthread_active_p ())
+    {
+      if (__gthrw_(pthread_cond_destroy) ((pthread_cond_t *) condition->backend))
+	return -1;
+
+      objc_free (condition->backend);
+      condition->backend = NULL;
+    }
+  return 0;
+}
+
+/* Wait on the condition */
+static inline int
+__gthread_objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)
+{
+  if (__gthread_active_p ())
+    return __gthrw_(pthread_cond_wait) ((pthread_cond_t *) condition->backend,
+			      (pthread_mutex_t *) mutex->backend);
+  else
+    return 0;
+}
+
+/* Wake up all threads waiting on this condition.  */
+static inline int
+__gthread_objc_condition_broadcast (objc_condition_t condition)
+{
+  if (__gthread_active_p ())
+    return __gthrw_(pthread_cond_broadcast) ((pthread_cond_t *) condition->backend);
+  else
+    return 0;
+}
+
+/* Wake up one thread waiting on this condition.  */
+static inline int
+__gthread_objc_condition_signal (objc_condition_t condition)
+{
+  if (__gthread_active_p ())
+    return __gthrw_(pthread_cond_signal) ((pthread_cond_t *) condition->backend);
+  else
+    return 0;
+}
+
+#else /* _LIBOBJC */
+
+static inline int
+__gthread_once (__gthread_once_t *once, void (*func) (void))
+{
+  if (__gthread_active_p ())
+    return __gthrw_(pthread_once) (once, func);
+  else
+    return -1;
+}
+
+static inline int
+__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))
+{
+  return __gthrw_(pthread_key_create) (key, dtor);
+}
+
+static inline int
+__gthread_key_delete (__gthread_key_t key)
+{
+  return __gthrw_(pthread_key_delete) (key);
+}
+
+static inline void *
+__gthread_getspecific (__gthread_key_t key)
+{
+  return __gthrw_(pthread_getspecific) (key);
+}
+
+static inline int
+__gthread_setspecific (__gthread_key_t key, const void *ptr)
+{
+  return __gthrw_(pthread_setspecific) (key, ptr);
+}
+
+static inline int
+__gthread_mutex_lock (__gthread_mutex_t *mutex)
+{
+  if (__gthread_active_p ())
+    return __gthrw_(pthread_mutex_lock) (mutex);
+  else
+    return 0;
+}
+
+static inline int
+__gthread_mutex_trylock (__gthread_mutex_t *mutex)
+{
+  if (__gthread_active_p ())
+    return __gthrw_(pthread_mutex_trylock) (mutex);
+  else
+    return 0;
+}
+
+static inline int
+__gthread_mutex_unlock (__gthread_mutex_t *mutex)
+{
+  if (__gthread_active_p ())
+    return __gthrw_(pthread_mutex_unlock) (mutex);
+  else
+    return 0;
+}
+
+static inline int
+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)
+{
+  return __gthread_mutex_lock (mutex);
+}
+
+static inline int
+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)
+{
+  return __gthread_mutex_trylock (mutex);
+}
+
+static inline int
+__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)
+{
+  return __gthread_mutex_unlock (mutex);
+}
+
+#endif /* _LIBOBJC */
+
+#endif /* ! GCC_GTHR_POSIX_H */
diff -uNr gcc-4.4.0.orig/gcc/opts.c gcc-4.4.0/gcc/opts.c
--- gcc-4.4.0.orig/gcc/opts.c	2009-03-28 18:28:45.000000000 +0100
+++ gcc-4.4.0/gcc/opts.c	2009-06-24 00:57:00.000000000 +0200
@@ -941,9 +941,12 @@
   /* Just -O1/-O0 optimizations.  */
   opt1_max = (optimize <= 1);
   align_loops = opt1_max;
-  align_jumps = opt1_max;
-  align_labels = opt1_max;
-  align_functions = opt1_max;
+  if (!flag_control_integrity)
+  {
+    align_jumps = opt1_max;
+    align_labels = opt1_max;
+    align_functions = opt1_max;
+  }
 
   if (optimize_size)
     {
@@ -1082,6 +1085,21 @@
       flag_ira_algorithm = IRA_ALGORITHM_PRIORITY;
     }
 
+  /* NativeClient: set the alignment based on command line flags. */
+  if (flag_nacl_align_pow2 != NACL_ALIGN_POW2)
+    {
+      align_jumps = (1 << flag_nacl_align_pow2);
+      align_labels = (1 << flag_nacl_align_pow2);
+      align_functions = (1 << flag_nacl_align_pow2);
+    }
+
+  if (flag_nacl_library_mode)
+    {
+      align_jumps = 32;
+      align_labels = 32;
+      align_functions = 32;
+    }
+
   /* Save the current optimization options if this is the first call.  */
   if (first_time_p)
     {
diff -uNr gcc-4.4.0.orig/gcc/passes.c gcc-4.4.0/gcc/passes.c
--- gcc-4.4.0.orig/gcc/passes.c	2009-02-20 16:20:38.000000000 +0100
+++ gcc-4.4.0/gcc/passes.c	2009-06-24 00:57:00.000000000 +0200
@@ -764,6 +764,7 @@
       NEXT_PASS (pass_stack_ptr_mod);
       NEXT_PASS (pass_mode_switching);
       NEXT_PASS (pass_see);
+      NEXT_PASS (pass_control_integrity);
       NEXT_PASS (pass_match_asm_constraints);
       NEXT_PASS (pass_sms);
       NEXT_PASS (pass_sched);
diff -uNr gcc-4.4.0.orig/gcc/reg-stack.c gcc-4.4.0/gcc/reg-stack.c
--- gcc-4.4.0.orig/gcc/reg-stack.c	2009-02-20 16:20:38.000000000 +0100
+++ gcc-4.4.0/gcc/reg-stack.c	2009-06-24 00:57:00.000000000 +0200
@@ -1864,6 +1864,25 @@
 		compare_for_stack_reg (insn, regstack, pat_src);
 		break;
 
+              case UNSPEC_NACLCALL:
+	        {
+	          int count = hard_regno_nregs[REGNO (*dest)][GET_MODE (*dest)];
+	          while (--count >= 0)
+		    {
+		      regstack->reg[++regstack->top] = REGNO (*dest) + count;
+		      SET_HARD_REG_BIT (regstack->reg_set, 
+                                        REGNO (*dest) + count);
+		    }
+	        }
+	        replace_reg (dest, FIRST_STACK_REG);
+                break;
+
+              case UNSPEC_NACLJMP:
+                break;
+
+              case UNSPEC_NACLRET:
+                break;
+
 	      default:
 		gcc_unreachable ();
 	      }
diff -uNr gcc-4.4.0.orig/gcc/tree-pass.h gcc-4.4.0/gcc/tree-pass.h
--- gcc-4.4.0.orig/gcc/tree-pass.h	2009-02-20 16:20:38.000000000 +0100
+++ gcc-4.4.0/gcc/tree-pass.h	2009-06-24 00:57:00.000000000 +0200
@@ -389,6 +389,8 @@
 extern struct gimple_opt_pass pass_build_cgraph_edges;
 extern struct gimple_opt_pass pass_reset_cc_flags;
 
+extern struct rtl_opt_pass pass_control_integrity;
+
 /* IPA Passes */
 extern struct ipa_opt_pass pass_ipa_inline;
 extern struct ipa_opt_pass pass_ipa_cp;
diff -uNr gcc-4.4.0.orig/libgcc/config.host gcc-4.4.0/libgcc/config.host
--- gcc-4.4.0.orig/libgcc/config.host	2009-04-17 13:58:41.000000000 +0200
+++ gcc-4.4.0/libgcc/config.host	2009-06-24 00:57:00.000000000 +0200
@@ -149,7 +149,7 @@
   # machine-specific sections may refine and add to this
   # configuration.
   ;;
-*-*-linux* | frv-*-*linux* | *-*-kfreebsd*-gnu | *-*-knetbsd*-gnu | *-*-gnu*)
+*-*-linux* | frv-*-*linux* | *-*-kfreebsd*-gnu | *-*-knetbsd*-gnu | *-*-gnu* | *-*-nacl*)
   extra_parts="crtbegin.o crtbeginS.o crtbeginT.o crtend.o crtendS.o"
   ;;
 *-*-netbsd*)
@@ -293,7 +293,7 @@
 	;;
 i[34567]86-*-coff*)
 	;;
-i[34567]86-*-linux* | i[34567]86-*-kfreebsd*-gnu | i[34567]86-*-knetbsd*-gnu | i[34567]86-*-gnu*)
+i[34567]86-*-linux* | i[34567]86-*-kfreebsd*-gnu | i[34567]86-*-knetbsd*-gnu | i[34567]86-*-gnu* | i[34567]86-*-nacl*)
 	extra_parts="$extra_parts crtprec32.o crtprec64.o crtprec80.o crtfastmath.o"
 	tmake_file="${tmake_file} i386/t-crtpc i386/t-crtfm"
 	;;
diff -uNr gcc-4.4.0.orig/libgomp/configure.tgt gcc-4.4.0/libgomp/configure.tgt
--- gcc-4.4.0.orig/libgomp/configure.tgt	2008-09-19 22:27:11.000000000 +0200
+++ gcc-4.4.0/libgomp/configure.tgt	2009-06-24 00:57:00.000000000 +0200
@@ -48,7 +48,7 @@
 	;;
 
     # Note that bare i386 is not included here.  We need cmpxchg.
-    i[456]86-*-linux*)
+    i[456]86*-*-linux* | i[456]86*-*-nacl*)
 	config_path="linux/x86 linux posix"
 	case " ${CC} ${CFLAGS} " in
 	  *" -m64 "*)
diff -uNr gcc-4.4.0.orig/libmudflap/configure gcc-4.4.0/libmudflap/configure
--- gcc-4.4.0.orig/libmudflap/configure	2009-03-01 18:49:31.000000000 +0100
+++ gcc-4.4.0/libmudflap/configure	2009-06-24 00:57:00.000000000 +0200
@@ -6225,7 +6225,7 @@
   ;;
 
 # This must be Linux ELF.
-linux* | k*bsd*-gnu | kopensolaris*-gnu)
+linux* | k*bsd*-gnu | kopensolaris*-gnu | nacl*)
   lt_cv_deplibs_check_method=pass_all
   ;;
 
diff -uNr gcc-4.4.0.orig/libssp/configure gcc-4.4.0/libssp/configure
--- gcc-4.4.0.orig/libssp/configure	2009-03-01 18:49:31.000000000 +0100
+++ gcc-4.4.0/libssp/configure	2009-06-24 00:57:00.000000000 +0200
@@ -5199,7 +5199,7 @@
   ;;
 
 # This must be Linux ELF.
-linux* | k*bsd*-gnu | kopensolaris*-gnu)
+linux* | k*bsd*-gnu | kopensolaris*-gnu | nacl*)
   lt_cv_deplibs_check_method=pass_all
   ;;
 
diff -uNr gcc-4.4.0.orig/libstdc++-v3/configure gcc-4.4.0/libstdc++-v3/configure
--- gcc-4.4.0.orig/libstdc++-v3/configure	2009-03-01 18:49:31.000000000 +0100
+++ gcc-4.4.0/libstdc++-v3/configure	2009-06-24 00:57:00.000000000 +0200
@@ -4989,7 +4989,7 @@
   fi
   ;;
 
-gnu*)
+gnu* | nc)
   lt_cv_deplibs_check_method=pass_all
   ;;
 
@@ -5027,7 +5027,7 @@
   ;;
 
 # This must be Linux ELF.
-linux* | k*bsd*-gnu | kopensolaris*-gnu)
+linux* | k*bsd*-gnu | kopensolaris*-gnu | nc)
   lt_cv_deplibs_check_method=pass_all
   ;;
 
@@ -15124,7 +15124,7 @@
   # Default to "generic".
   if test $enable_clocale_flag = auto; then
     case ${target_os} in
-      linux* | gnu* | kfreebsd*-gnu | knetbsd*-gnu)
+      linux* | gnu* | kfreebsd*-gnu | knetbsd*-gnu | nc)
         enable_clocale_flag=gnu
         ;;
       darwin* | freebsd*)
@@ -15870,7 +15870,7 @@
   # Default to "new".
   if test $enable_libstdcxx_allocator_flag = auto; then
     case ${target_os} in
-      linux* | gnu* | kfreebsd*-gnu | knetbsd*-gnu)
+      linux* | gnu* | kfreebsd*-gnu | knetbsd*-gnu | nc)
         enable_libstdcxx_allocator_flag=new
         ;;
       *)
