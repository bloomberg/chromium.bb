#!/usr/bin/env python
# Copyright 2014 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Adaptor script called through build/isolate.gypi.

Creates a wrapping .isolate which 'includes' the original one, that can be
consumed by tools/swarming_client/isolate.py. Path variables are determined
based on the current working directory. The relative_cwd in the .isolated file
is determined based on *the .isolate file that declare the 'command' variable to
be used* so the wrapping .isolate doesn't affect this value.

It packages all the dynamic libraries found in this wrapping .isolate. This is
inefficient and non-deterministic. In the very near future, it will parse
build.ninja, find back the root target and find all the dynamic libraries that
are marked as a dependency to this target.
"""

import glob
import os
import posixpath
import subprocess
import sys

TOOLS_DIR = os.path.dirname(os.path.abspath(__file__))
SWARMING_CLIENT_DIR = os.path.join(TOOLS_DIR, 'swarming_client')
SRC_DIR = os.path.dirname(TOOLS_DIR)

sys.path.insert(0, SWARMING_CLIENT_DIR)

import isolate_format



# Location to grab binaries based on the OS.
DYNAMIC_LIBRARIES = {
  'darwin': '*.dylib',
  'linux2': 'lib/*.so',
  'win32': '*.dll',
}


def create_wrapper(args, isolate_index, isolated_index):
  """Creates a wrapper .isolate that add dynamic libs.

  The original .isolate is not modified.
  """
  cwd = os.getcwd()
  isolate = args[isolate_index]
  # The code assumes the .isolate file is always specified path-less in cwd. Fix
  # if this assumption doesn't hold true.
  assert os.path.basename(isolate) == isolate, isolate

  # This will look like ../out/Debug. This is based against cwd. Note that this
  # must equal the value provided as PRODUCT_DIR.
  build_dir = os.path.dirname(args[isolated_index])

  # This will look like chrome/unit_tests.isolate. It is based against SRC_DIR.
  # It's used to calculate temp_isolate.
  src_isolate = os.path.relpath(os.path.join(cwd, isolate), SRC_DIR)

  # The wrapping .isolate. This will look like
  # ../out/Debug/gen/chrome/unit_tests.isolate.
  temp_isolate = os.path.join(build_dir, 'gen', src_isolate)
  temp_isolate_dir = os.path.dirname(temp_isolate)

  # Relative path between the new and old .isolate file.
  isolate_relpath = os.path.relpath(
      '.', temp_isolate_dir).replace(os.path.sep, '/')

  # This will look like [../out/Debug/lib/libuser_prefs.so].
  dynamic_libs = [
    i.replace(os.path.sep, '/')
    for i in glob.iglob(
        os.path.join(build_dir, DYNAMIC_LIBRARIES[sys.platform]))
  ]
  # And now like ['<(PRODUCT_DIR)/lib/flibuser_prefs.so'].
  rebased_libs = [
    '<(PRODUCT_DIR)/%s' % i[len(build_dir)+1:]
    for i in dynamic_libs
  ]

  # Now do actual wrapping .isolate.
  out = {
    'includes': [
      posixpath.join(isolate_relpath, isolate),
    ],
    'variables': {
      isolate_format.KEY_TRACKED: rebased_libs,
    },
  }
  if not os.path.isdir(temp_isolate_dir):
    os.makedirs(temp_isolate_dir)
  comment = (
      '# Warning: this file was AUTOGENERATED.\n'
      '# DO NO EDIT.\n')
  with open(temp_isolate, 'wb') as f:
    isolate_format.print_all(comment, out, f)
  if '--verbose' in args:
    print('Added %d dynamic libs' % len(dynamic_libs))
  args[isolate_index] = temp_isolate


def main():
  args = sys.argv[1:]
  isolate = None
  isolated = None
  is_component = False
  for i, arg in enumerate(args):
    if arg == '--isolate':
      isolate = i + 1
    if arg == '--isolated':
      isolated = i + 1
    if arg == 'component=shared_library':
      is_component = True
  if isolate is None or isolated is None:
    print >> sys.stderr, 'Internal failure'
    return 1

  if is_component:
    create_wrapper(args, isolate, isolated)

  swarming_client = os.path.join(SRC_DIR, 'tools', 'swarming_client')
  sys.stdout.flush()
  result = subprocess.call(
      [sys.executable, os.path.join(swarming_client, 'isolate.py')] + args)
  return result


if __name__ == '__main__':
  sys.exit(main())
