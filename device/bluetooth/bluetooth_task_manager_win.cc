// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "device/bluetooth/bluetooth_task_manager_win.h"

#include <BluetoothAPIs.h>
#if defined(_WIN32_WINNT_WIN8) && _MSC_VER < 1700
// The Windows 8 SDK defines FACILITY_VISUALCPP in winerror.h.
#undef FACILITY_VISUALCPP
#endif
#include <delayimp.h>
#include <string>

#include "base/bind.h"
#include "base/memory/ref_counted.h"
#include "base/message_loop.h"
#include "base/sequenced_task_runner.h"
#include "base/stringprintf.h"
#include "base/sys_string_conversions.h"
#include "base/threading/sequenced_worker_pool.h"
#include "base/threading/thread_restrictions.h"
#include "base/win/scoped_handle.h"

#pragma comment(lib, "Bthprops.lib")

namespace {

const int kNumThreadsInWorkerPool = 3;
const char kBluetoothThreadName[] = "BluetoothPollingThreadWin";

// A frame-based exception handler filter function for a handler for exceptions
// generated by the Visual C++ delay loader helper function.
int FilterVisualCPPExceptions(DWORD exception_code) {
  return HRESULT_FACILITY(exception_code) == FACILITY_VISUALCPP ?
      EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH;
}  // namespace

// Populates bluetooth adapter state using adapter_handle.
void GetAdapterState(HANDLE adapter_handle,
                     device::BluetoothTaskManagerWin::AdapterState* state) {
  std::string name;
  std::string address;
  bool powered = false;
  BLUETOOTH_RADIO_INFO adapter_info = { sizeof(BLUETOOTH_RADIO_INFO), 0 };
  if (adapter_handle &&
      ERROR_SUCCESS == BluetoothGetRadioInfo(adapter_handle,
                                             &adapter_info)) {
    name = base::SysWideToUTF8(adapter_info.szName);
    address = base::StringPrintf("%02X:%02X:%02X:%02X:%02X:%02X",
        adapter_info.address.rgBytes[5],
        adapter_info.address.rgBytes[4],
        adapter_info.address.rgBytes[3],
        adapter_info.address.rgBytes[2],
        adapter_info.address.rgBytes[1],
        adapter_info.address.rgBytes[0]);
    powered = !!BluetoothIsConnectable(adapter_handle);
  }
  state->name = name;
  state->address = address;
  state->powered = powered;
}

}

namespace device {

// static
const int BluetoothTaskManagerWin::kPollIntervalMs = 500;

// static
bool BluetoothTaskManagerWin::HasBluetoothStack() {
  static enum {
    HBS_UNKNOWN,
    HBS_YES,
    HBS_NO,
  } has_bluetooth_stack = HBS_UNKNOWN;

  if (has_bluetooth_stack == HBS_UNKNOWN) {
    base::ThreadRestrictions::AssertIOAllowed();
    HRESULT hr = E_FAIL;
    __try {
      hr = __HrLoadAllImportsForDll("bthprops.cpl");
    } __except(FilterVisualCPPExceptions(::GetExceptionCode())) {
      hr = E_FAIL;
    }
    has_bluetooth_stack = SUCCEEDED(hr) ? HBS_YES : HBS_NO;
  }

  return has_bluetooth_stack == HBS_YES;
}

BluetoothTaskManagerWin::BluetoothTaskManagerWin(
    scoped_refptr<base::SequencedTaskRunner> ui_task_runner)
    : ui_task_runner_(ui_task_runner),
      worker_pool_(new base::SequencedWorkerPool(kNumThreadsInWorkerPool,
                                                 kBluetoothThreadName)),
      bluetooth_task_runner_(
          worker_pool_->GetSequencedTaskRunnerWithShutdownBehavior(
              worker_pool_->GetSequenceToken(),
              base::SequencedWorkerPool::CONTINUE_ON_SHUTDOWN)) {
}

BluetoothTaskManagerWin::BluetoothTaskManagerWin(
      scoped_refptr<base::SequencedTaskRunner> ui_task_runner,
      scoped_refptr<base::SequencedTaskRunner> bluetooth_task_runner)
    : ui_task_runner_(ui_task_runner),
      bluetooth_task_runner_(bluetooth_task_runner) {
}

BluetoothTaskManagerWin::~BluetoothTaskManagerWin() {
}

void BluetoothTaskManagerWin::AddObserver(Observer* observer) {
  DCHECK(observer);
  observers_.AddObserver(observer);
}

void BluetoothTaskManagerWin::RemoveObserver(Observer* observer) {
  DCHECK(observer);
  observers_.RemoveObserver(observer);
}

void BluetoothTaskManagerWin::Initialize() {
  DCHECK(ui_task_runner_->RunsTasksOnCurrentThread());
  bluetooth_task_runner_->PostTask(
      FROM_HERE,
      base::Bind(&BluetoothTaskManagerWin::StartPolling,
                 this));
}

void BluetoothTaskManagerWin::StartPolling() {
  DCHECK(bluetooth_task_runner_->RunsTasksOnCurrentThread());

  // TODO(youngki): Handle this check where BluetoothAdapter is initialized.
  if (HasBluetoothStack()) {
    PollAdapter();
  }
}

void BluetoothTaskManagerWin::Shutdown() {
  DCHECK(ui_task_runner_->RunsTasksOnCurrentThread());
  worker_pool_->Shutdown();
}

void BluetoothTaskManagerWin::OnAdapterStateChanged(const AdapterState* state) {
  DCHECK(ui_task_runner_->RunsTasksOnCurrentThread());
  FOR_EACH_OBSERVER(BluetoothTaskManagerWin::Observer, observers_,
                    AdapterStateChanged(*state));
}

void BluetoothTaskManagerWin::PollAdapter() {
  DCHECK(bluetooth_task_runner_->RunsTasksOnCurrentThread());

  base::win::ScopedHandle adapter_handle;
  const BLUETOOTH_FIND_RADIO_PARAMS adapter_param =
      { sizeof(BLUETOOTH_FIND_RADIO_PARAMS) };
  HBLUETOOTH_RADIO_FIND handle = BluetoothFindFirstRadio(
      &adapter_param, adapter_handle.Receive());

  if (handle)
    BluetoothFindRadioClose(handle);

  AdapterState* state = new AdapterState();
  GetAdapterState(adapter_handle, state);

  // Notify the UI thread of the Bluetooth Adapter state.
  ui_task_runner_->PostTask(
      FROM_HERE,
      base::Bind(&BluetoothTaskManagerWin::OnAdapterStateChanged,
                 this,
                 base::Owned(state)));

  // Re-poll.
  bluetooth_task_runner_->PostDelayedTask(
      FROM_HERE,
      base::Bind(&BluetoothTaskManagerWin::PollAdapter,
                 this),
      base::TimeDelta::FromMilliseconds(kPollIntervalMs));
}

}  // namespace device