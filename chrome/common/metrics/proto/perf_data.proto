// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto2";

option optimize_for = LITE_RUNTIME;

package metrics;

// Stores information from a perf session generated via running:
// "perf record"
//
// See $kernel/tools/perf/design.txt for more details.

// Next tag: 5
message PerfDataProto {

  // Perf event attribute. Stores the event description.
  // This data structure is defined in the linux kernel:
  // $kernel/tools/perf/util/event.h.
  // Next tag: 36
  message PerfEventAttr {
    // Type of the event. Type is an enumeration and can be:
    // IP: an instruction-pointer was stored in the event.
    // MMAP: a DLL was loaded.
    // FORK: a process was forked.
    // etc.
    optional uint32 type = 1;

    // Size of the event data in bytes.
    optional uint32 size = 2;

    // The config stores the CPU-specific counter information.
    optional uint64 config = 3;

    // Sample period of the event. Indicates how often the event is
    // triggered in terms of # of events. After |sample_period| events, an event
    // will be recorded and stored.
    optional uint64 sample_period = 4;

    // Sample frequency of the event. Indicates how often the event is
    // triggered in terms of # per second. The kernel will try to record
    // |sample_freq| events per second.
    optional uint64 sample_freq = 5;

    // Sample type is a bitfield that records attributes of the sample. Example,
    // whether an entire callchain was recorded, etc.
    optional uint64 sample_type = 6;

    // Bitfield that indicates whether reads on the counter will return the
    // total time enabled and total time running.
    optional uint64 read_format = 7;

    // Indicates whether the counter starts off disabled.
    optional bool disabled = 8;

    // Indicates whether child processes inherit the counter.
    optional bool inherit = 9;

    // Indicates whether the counter is pinned to a particular CPU.
    optional bool pinned = 10;

    // Indicates whether this counter's group has exclusive access to the CPU's
    // counters.
    optional bool exclusive = 11;

    // The following bits restrict events to be counted when the CPU is in user,
    // kernel, hypervisor or idle modes.
    optional bool exclude_user = 12;
    optional bool exclude_kernel = 13;
    optional bool exclude_hv = 14;
    optional bool exclude_idle = 15;

    // Indicates whether mmap events should be recorded.
    optional bool mmap = 16;

    // Indicates whether process comm information should be recorded upon
    // process creation.
    optional bool comm = 17;

    // Indicates that we are in frequency mode, not period mode.
    optional bool freq = 18;

    // Indicates whether we have per-task counts.
    optional bool inherit_stat = 19;

    // Indicates whether we enable perf events after an exec() function call.
    optional bool enable_on_exec = 20;

    // Indicates whether we trace fork/exit.
    optional bool task = 21;

    // Indicates whether we are using a watermark to wake up.
    optional bool watermark = 22;

    // CPUs often "skid" when recording events. That means the instruction
    // pointer may not be the same as the one that caused the counter overflow.
    // Indicates the capabilities of the CPU in terms of recording precise
    // instruction pointer.
    optional uint32 precise_ip = 23;

    // Indicates whether we have non-exec mmap data.
    optional bool mmap_data = 24;

    // If set, all the event types will have the same sample_type.
    optional bool sample_id_all = 25;

    // Indicates whether we are counting events from the host (when running a
    // VM).
    optional bool exclude_host = 26;

    // Exclude events that happen on a guest OS.
    optional bool exclude_guest = 27;

    // Contains the number of events after which we wake up.
    optional uint32 wakeup_events = 28;

    // Contains the number of bytes after which we wake up.
    optional uint32 wakeup_watermark = 29;

    // Information about the type of the breakpoint.
    optional uint32 bp_type = 30;

    // Contains the breakpoint address.
    optional uint64 bp_addr = 31;

    // This is an extension of config (see above).
    optional uint64 config1 = 32;

    // The length of the breakpoint data in bytes.
    optional uint64 bp_len = 33;

    // This is an extension of config (see above).
    optional uint64 config2 = 34;

    // Contains the type of branch, example: user, kernel, call, return, etc.
    optional uint64 branch_sample_type = 35;
  }

  // Describes a perf.data file attribute.
  // Next tag: 3
  message PerfFileAttr {
    optional PerfEventAttr attr = 1;

    // List of perf file attribute ids. Each id describes an event.
    repeated uint64 ids = 2;
  }

  // This message contains information about a perf sample itself, as opposed to
  // a perf event captured by a sample.
  // Next tag: 6
  message SampleInfo {
    // Process ID / thread ID from which this sample was taken.
    optional uint32 pid = 1;
    optional uint32 tid = 2;

    // Time this sample was taken (NOT the same as an event time).
    // It is the number of nanoseconds since bootup.
    optional uint64 sample_time_ns = 3;

    // The ID of the sample's event type (cycles, instructions, etc).
    // The event type IDs are defined in PerfFileAttr.
    optional uint64 id = 4;

    // The CPU on which this sample was taken.
    optional uint32 cpu = 5;
  }

  // Next tag: 7
  message CommEvent {
    // Process id.
    optional uint32 pid = 1;

    // Thread id.
    optional uint32 tid = 2;

    // Comm string's md5 prefix.
    // The comm string was field 3 and has been intentionally left out.
    optional uint64 comm_md5_prefix = 4;

    // Time the sample was taken.
    // Deprecated, use |sample_info| instead.
    optional uint64 sample_time = 5 [deprecated=true];

    // Info about the perf sample containing this event.
    optional SampleInfo sample_info = 6;
  }

  // Next tag: 9
  message MMapEvent {
    // Process id.
    optional uint32 pid = 1;

    // Thread id.
    optional uint32 tid = 2;

    // Start address.
    optional uint64 start = 3;

    // Length.
    optional uint64 len = 4;

    // PG Offset.
    optional uint64 pgoff = 5;

    // Filename's md5 prefix.
    // The filename was field 6 and has been intentionally left out.
    optional uint64 filename_md5_prefix = 7;

    // Info about the perf sample containing this event.
    optional SampleInfo sample_info = 8;
  }

  // Next tag: 11
  message SampleEvent {
    // Instruction pointer.
    optional uint64 ip = 1;

    // Process id.
    optional uint32 pid = 2;

    // Thread id.
    optional uint32 tid = 3;

    // The time after boot when the sample was recorded, in nanoseconds.
    optional uint64 sample_time_ns = 4;

    // The address of the sample.
    optional uint64 addr = 5;

    // The id of the sample.
    optional uint64 id = 6;

    // The stream id of the sample.
    optional uint64 stream_id = 7;

    // The period of the sample.
    optional uint64 period = 8;

    // The CPU where the event was recorded.
    optional uint32 cpu = 9;

    // The raw size of the event in bytes.
    optional uint32 raw_size = 10;
  }

  // ForkEvent is used for both FORK and EXIT events, which have the same data
  // format.  We don't want to call this "ForkOrExitEvent", in case a separate
  // exit event is introduced in the future.
  // Next tag: 12
  message ForkEvent {
    // Forked process ID.
    optional uint32 pid = 1;

    // Parent process ID.
    optional uint32 ppid = 2;

    // Forked process thread ID.
    optional uint32 tid = 3;

    // Parent process thread ID.
    optional uint32 ptid = 4;

    // Time of fork event in nanoseconds since bootup.
    optional uint64 fork_time_ns = 5;

    // Info about the perf sample containing this event.
    optional SampleInfo sample_info = 11;
  }

  // Next tag: 4
  message EventHeader {
    // Type of event.
    optional uint32 type = 1;
    optional uint32 misc = 2;
    // Size of event.
    optional uint32 size = 3;
  }

  // Next tag: 6
  message PerfEvent {
    optional EventHeader header = 1;

    optional MMapEvent mmap_event = 2;
    optional SampleEvent sample_event = 3;
    optional CommEvent comm_event = 4;
    optional ForkEvent fork_event = 5;
  }

  // Next tag: 8
  message PerfEventStats {
    // Total number of events read from perf data.
    optional uint32 num_events_read = 1;

    // Total number of various types of events.
    optional uint32 num_sample_events = 2;
    optional uint32 num_mmap_events = 3;
    optional uint32 num_fork_events = 4;
    optional uint32 num_exit_events = 5;

    // Number of sample events that were successfully mapped by the address
    // mapper, a quipper module that is used to obscure addresses and convert
    // them to DSO name + offset.  Sometimes it fails to process sample events.
    // This field allows us to track the success rate of the address mapper.
    optional uint32 num_sample_events_mapped = 6;

    // Whether address remapping was enabled.
    optional bool did_remap = 7;
  }

  repeated PerfFileAttr file_attrs = 1;
  repeated PerfEvent events = 2;

  // Time when quipper generated this perf data / protobuf, given as seconds
  // since the epoch.
  optional uint64 timestamp_sec = 3;

  // Records some stats about the serialized perf events.
  optional PerfEventStats stats = 4;
}
