<!DOCTYPE html><!-- This page is a placeholder for generated extensions api doc. Note:
    1) The <head> information in this page is significant, should be uniform
       across api docs and should be edited only with knowledge of the
       templating mechanism.
    3) All <body>.innerHTML is genereated as an rendering step. If viewed in a
       browser, it will be re-generated from the template, json schema and
       authored overview content.
    4) The <body>.innerHTML is also generated by an offline step so that this
       page may easily be indexed by search engines.
--><html xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link href="../css/print.css" rel="stylesheet" type="text/css" media="print">
    <script type="text/javascript" src="../../../../third_party/jstemplate/jstemplate_compiled.js">
    </script>
    <script type="text/javascript" src="../../../../../third_party/json_minify/minify-sans-regexp.js">
    </script>
    <script type="text/javascript" src="../js/api_page_generator.js"></script>
    <script type="text/javascript" src="../js/bootstrap.js"></script>
    <script type="text/javascript" src="../js/sidebar.js"></script>
  <title>Accessing Hardware Devices - Google Chrome Extensions - Google Code</title></head>
  <body doc-family="apps">  <link href="../css/ApiRefStyles_apps.css" rel="stylesheet" type="text/css">
  <link href="../css/prettify.css" rel="stylesheet" type="text/css">
  <link href="../css/shared.css" rel="stylesheet" type="text/css">
  <div id="devModeWarning" class="displayModeWarning">
    You are viewing extension docs in chrome via the 'file:' scheme: are you expecting to see local changes when you refresh? You'll need run chrome with --allow-file-access-from-files.
  </div>
  <div id="branchWarning" class="displayModeWarning">
    <span>WARNING: This is the <span id="branchName">BETA</span> documentation.
    It may not work with the stable release of Chrome.</span>
    <select id="branchChooser">
      <option>Choose a different version...
      </option><option value="">Stable
      </option><option value="beta">Beta
      </option><option value="dev">Dev
      </option><option value="trunk">Trunk
    </option></select>
  </div>
  <div id="unofficialWarning" class="displayModeWarning">
    <span>WARNING: This is unofficial documentation. It may not work with the
    current release of Chrome.</span>
    <button id="goToOfficialDocs">Go to the official docs</button>
  </div>
  <div id="gc-container" class="labs">
      <!-- SUBTEMPLATES: DO NOT MOVE FROM THIS LOCATION -->
      <!-- In particular, sub-templates that recurse, must be used by allowing
           jstemplate to make a copy of the template in this section which
           are not operated on by way of the jsskip="true" -->
       <!-- /SUBTEMPLATES -->
  <a id="top"></a>
    <div id="skipto">
      <a href="#gc-pagecontent">Skip to page content</a>
      <a href="#gc-toc">Skip to main navigation</a>
    </div>
    <!-- API HEADER -->
    <table id="header" width="100%" cellspacing="0" border="0">
      <tbody><tr>
        <td valign="middle"><a href="http://code.google.com/"><img src="../images/chrome_logo.gif" alt="Google Code" style="border:0; margin:0;"></a></td>
        <td valign="middle" width="100%" style="padding-left:0.6em;">
          <form action="http://www.google.com/cse" id="cse" style="margin-top:0.5em">
            <div id="gsc-search-box">
              <input type="hidden" name="cx" value="002967670403910741006:61_cvzfqtno">
              <input type="hidden" name="ie" value="UTF-8">
              <input id="gsc-search-input" type="text" name="q" value="" size="55">
              <button class="gsc-search-button" type="submit" name="sa">
                <img class="gsc-search-button-lens" src="../images/search.png" alt="Search">
              </button>
              <br>
              <span class="greytext">e.g. "page action" or "tabs"</span>
            </div>
          </form>
          <script type="text/javascript" src="https://www.google.com/jsapi"></script>
          <script type="text/javascript">google.load("elements", "1", {packages: "transliteration"});</script>
          <script type="text/javascript" src="https://www.google.com/coop/cse/t13n?form=cse&amp;t13n_langs=en"></script>
          <script type="text/javascript" src="https://www.google.com/coop/cse/brand?form=cse&amp;lang=en"></script>
        </td>
      </tr>
    </tbody></table>
    <div id="codesiteContent" class="">
      <a id="gc-topnav-anchor"></a>
      <div id="gc-topnav">
        <h1>Packaged Apps</h1>
        <ul id="home" class="gc-topnav-tabs">
          <li id="home_link">
            <a href="app_landing.html" title="Packaged Apps home page"><span>Home</span></a>
          </li>
          <li id="docs_link">
            <a href="about_apps.html" title="Official Packaged apps documentation"><span>Docs</span></a>
          </li>
          <li id="samples_link">
            <a href="app_samples.html" title="Sample apps (with source code)"><span>Samples</span></a>
          </li>
          <li id="group_link">
            <a href="http://groups.google.com/a/chromium.org/group/chromium-extensions" title="Google Chrome Extensions developer forum"><span>Group</span></a>
          </li>
          <li id="so_link">
            <a href="http://stackoverflow.com/questions/tagged/google-chrome-extension" title="[google-chrome-extension] tag on Stack Overflow"><span>Questions?</span></a>
          </li>
        </ul>
      </div> <!-- end gc-topnav -->
    <div class="g-section g-tpl-170">
      <!-- SIDENAV -->
      <div class="g-unit g-first" id="gc-toc">
        <ul>
          <li><h2>Getting Started</h2>
            <ul>
              <li><a href="about_apps.html">What Are Packaged Apps?</a></li>
              <li><a href="app_architecture.html">Understand the Architecture</a></li>
              <li><a href="first_app.html">Create Your First App</a></li>
            </ul>
          </li>
          <li><h2>Developing</h2>
            <ul>
              <li><a href="develop_apps.html">Before You Start</a></li>
              <li><span>The Fundamentals</span>
                <ul>
                  <li><a href="app_lifecycle.html">Manage App Lifecycle</a></li>
                  <li><a href="app_storage.html">Manage Data</a></li>
                  <li><a href="offline_apps.html">Offline First</a></li>
                  <li><a href="app_external.html">Embed Content</a></li>
                </ul>
              </li>
              <li><span>Security &amp; Privacy</span>
                <ul>
                  <li><a href="app_security.html">About Security &amp; Privacy</a></li>
                  <li><a href="app_identity.html">Identify User</a></li>
                  <li><a href="app_permissions.html">Manage User Permissions</a></li>
                  <li><a href="app_csp">Comply with CSP</a></li>
                </ul>
              </li>
              <li><span>Advanced Technologies</span>
                <ul>
                  <li><a href="app_network.html">Communicate across Network</a></li>
                  <li class="leftNavSelected">Access Hardware Devices</li>
                  <li><a href="app_intents.html">Connect Apps with Web Intents</a></li>
                </ul>
              </li>
              <li><a href="app_frameworks.html">Recommended Frameworks</a></li>
            </ul>
          </li>
          <li><h2>Deploying</h2>
            <ul>
              <li><a href="publish_app.html">Publish</a></li>
              <li><a href="sell_app.html">Sell</a></li>
            </ul>
          </li>
          <li><h2>Reference</h2>
            <ul>
              <li><a href="manifest.html">Manifest Files</a></li>
              <li><a href="api_index.html">Chrome JavaScript APIs</a></li>
              <li><a href="experimental.html">Experimental APIs</a></li>
              <li><a href="api_other.html">Supported Libraries</a></li>
              <li><a href="app_deprecated.html">Disabled Web Features</a></li>
            </ul>
          </li>
          <li><h2><a href="app_samples.html">Samples</a></h2></li>
        </ul>
      </div>
      <script>
        initToggles();
      </script>
    <div class="g-unit" id="gc-pagecontent">
      <div id="pageTitle">
        <h1 class="page_title">Accessing Hardware Devices</h1>
      </div>
        <!-- TABLE OF CONTENTS -->
        <div id="toc">
          <h2>Contents</h2>
          <ol>
            <li>
              <a href="#usb">Accessing USB devices</a>
              <ol>
                <li>
                  <a href="#H3-1">Manifest requirement</a>
                </li><li>
                  <a href="#H3-2">Finding a device</a>
                </li><li>
                  <a href="#H3-3">USB transfers and receiving data from device</a>
                </li><li>
                  <a href="#H3-4">Sending data - control transfers</a>
                </li><li>
                  <a href="#H3-5">Sending data - isochronous transfers</a>
                </li><li>
                  <a href="#H3-6">Sending data - bulk transfers</a>
                </li><li>
                  <a href="#H3-7">Sending data - interrupt transfers</a>
                </li><li>
                  <a href="#H3-8">Caveats</a>
                </li>
              </ol>
            </li><li>
              <a href="#serial">Accessing serial devices</a>
              <ol>
                <li>
                  <a href="#H3-10">Manifest requirement</a>
                </li><li>
                  <a href="#H3-11">Listing available serial ports</a>
                </li><li>
                  <a href="#H3-12">Opening a serial device</a>
                </li><li>
                  <a href="#H3-13">Closing a serial device</a>
                </li><li>
                  <a href="#H3-14">Reading from a serial device</a>
                </li><li>
                  <a href="#H3-15">Writing to a serial device</a>
                </li><li>
                  <a href="#H3-16">Flushing a serial device buffer</a>
                </li>
              </ol>
            </li>
          </ol>
        </div>
        <!-- /TABLE OF CONTENTS -->
        <!-- Standard content lead-in for experimental API pages -->
        <!-- STATIC CONTENT PLACEHOLDER -->
        <div id="static"><div id="pageData-name" class="pageData">Accessing Hardware Devices</div>
<div id="pageData-showTOC" class="pageData">true</div>
<p>
This doc shows you how packaged apps can connect to USB devices
and read from and write to a user's serial ports.
See also the reference docs for the
<a href="http://code.google.com/chrome/extensions/trunk/experimental.usb.html">USB API</a>
and the
<a href="http://code.google.com/chrome/extensions/trunk/experimental.serial.html">Serial API</a>.
</p>
<p class="note">
<b>API Samples: </b>
Want to play with the code?
Check out the
<a href="https://github.com/GoogleChrome/chrome-apps/blob/master/serial">serial</a>,
<a href="https://github.com/GoogleChrome/chrome-apps/blob/master/servo">servo</a>,
and <a href="https://github.com/GoogleChrome/chrome-apps/blob/master/usb">usb</a> samples.
</p>
<h2 id="usb">Accessing USB devices</h2>
<p>
You can use the USB API to send messages to any device in the bus.
</p>
<p class="warning">
<b>Warning: </b>
The following sections require a basic understanding
of how the USB bus works.
</p>
<a name="H3-1"></a><h3>Manifest requirement</h3>
<p>
You must add the "usb" permission
to the manifest file:
</p>
<pre>"permissions": [
  "appWindow",
  "experimental",
  "usb"
]
</pre>
<a name="H3-2"></a><h3>Finding a device</h3>
<p>
Every device in a USB bus is identified
by its vendor and product IDs.
To find a device,
use the <code>findDevice()</code> method
which has four parameters:
</p>
<pre>chrome.experimental.usb.findDevice(vendorId, productId, eventCallbacks, onDeviceFoundCallback)
</pre>
<br>
<table border="0">
  <tbody><tr>
    <th scope="col"> Parameter </th>
    <th scope="col"> Description </th>
  </tr>
  <tr>
    <td>vendorId (long)</td>
    <td>USB device vendor ID (in Linux, use lsusb to find it).</td>
  </tr>
  <tr>
    <td>productId (long)</td>
    <td>USB device product ID (in Linux, use lsusb to find it).</td>
  </tr>
  <tr>
    <td>eventCallbacks(object)</td>
    <td>An object with a single key,
      <code>onEvent()</code>,
      to be called whenever an event occurs on the corresponding device;
      this is called when the device sends data to the host computer.
      Host-initiated USB protocol is complex,
      so read on to find out more.
    </td>
  </tr>
  <tr>
    <td>onDevideFoundCallback()</td>
    <td>Called when the device is found.
      The callback's parameter is <code>NULL</code>,
      if no device is found;
      or it's an object with three properties:
      <code>handle</code>, <code>vendorId</code>,
      <code>productId</code>.
      Save this object
      as it's required to send messages to the device.</td>
  </tr>
</tbody></table>
<p>
Example:
</p>
<pre>var onDeviceFound = function(device) {
  deviceObj=device;
  if (device) {
     console.log(“Device found: ”+device.handle);
  } else {
     console.log(“Device could not be found”);
  }
};
var onUsbEvent = function(event) {
     console.log(“USB event!”);
};
chrome.experimental.usb.findDevice(vendorId, productId, {"onEvent": onUsbEvent}, onDeviceFound);
</pre>
<a name="H3-3"></a><h3>USB transfers and receiving data from device</h3>
<p>
USB protocol defines four types of transfers:
control, bulk, isochronous and interrupt.
Theoretically they can all occur in both directions:<br>
device-&gt;host and host-&gt;device.
Host-&gt;device is initiated by your code and is described in the next sections.
</p>
<p>
Device-&gt;host messages are handled by Chrome and delivered
to the <code>onEvent()</code> callback
defined in the <code>findDevice()</code> method.
The callback receives an event object
with the following properties:
</p>
<br>
<table border="0">
  <tbody><tr>
    <th scope="col"> Property </th>
    <th scope="col"> Description </th>
  </tr>
  <tr>
    <td>type (string)</td>
    <td>Currently always contains the string "transferResult".</td>
  </tr>
  <tr>
    <td>resultCode (integer)</td>
    <td>0 is success; other values indicate failure.</td>
  </tr>
  <tr>
    <td>data (integer array)</td>
    <td>Contains the data sent by the device.
    </td>
  </tr>
</tbody></table>
<p>
Example:
</p>
<pre>var onUsbEvent = function(event) {
    if (event &amp;&amp; event.resultCode===0 &amp;&amp; event.data) {
     console.log(“got ”+event.data.length+" bytes");
    }
};
chrome.experimental.usb.findDevice( vendorId, productId, {"onEvent": onUsbEvent}, onDeviceFound);
</pre>
<a name="H3-4"></a><h3>Sending data - control transfers</h3>
<p>
Control transfers are generally used to send configuration
or command parameters to a USB device.
The method is simple and receives three parameters:
</p>
<pre>chrome.experimental.usb.controlTransfer(deviceObj, transferInfo, transferCallback)
</pre>
<br>
<table border="0">
  <tbody><tr>
    <th scope="col"> Parameter </th>
    <th scope="col"> Description </th>
  </tr>
  <tr>
    <td>deviceObj</td>
    <td>Object sent on <code>findDevice()</code> callback.</td>
  </tr>
  <tr>
    <td>transferInfo</td>
    <td>Parameter object with the values in the table below.
      Check your USB device protocol specification
      to know what values you should use.</td>
  </tr>
  <tr>
    <td>transferCallback()</td>
    <td>Invoked when the transfer has completed.
      Notice that this callback doesn't represent any response from the device.
      It's just to notify your code that the asynchronous transfer request
      has been processed and you can go ahead.
      The device's response, if any, will always be sent through
      the <code>onEvent()</code> callback set on <code>findDevice()</code>.
    </td>
  </tr>
</tbody></table>
<p>
Values for <code>transferInfo</code> object:
</p>
<table border="0">
  <tbody><tr>
    <th scope="col"> Value </th>
    <th scope="col"> Description </th>
  </tr>
  <tr>
    <td>requestType (string)</td>
    <td>"vendor", "standard", "class" or "reserved".</td>
  </tr>
  <tr>
    <td>recipient (string)</td>
    <td>"device", "interface", "endpoint" or "other".</td>
  </tr>
  <tr>
    <td>direction (string)</td>
    <td>in" or "out".
      IN direction is used to notify the device
      that it should send information to the host.
      All communication in a USB bus is host-initiated,
      so take an "in" transfer as a "here, device,
      take your token so you can speak".</td>
  </tr>
  <tr>
    <td>request (integer)</td>
    <td>Defined by your device's protocol.</td>
  </tr>
  <tr>
    <td>value (integer)</td>
    <td>Defined by your device's protocol.</td>
  </tr>
  <tr>
    <td>index (integer)</td>
    <td>Defined by your device's protocol.</td>
  </tr>
  <tr>
    <td>length (integer)</td>
    <td>Only used when direction is "in".
      Notifies the device that this is the amount
      of data the host is expecting in response.</td>
  </tr>
  <tr>
    <td>data (integer array)</td>
    <td>Defined by your device's protocol,
      required when direction is "out".
      <b>WARNING: </b>in the near future,
      this parameter will likely change
      to <code>ArrayBuffer</code>.</td>
  </tr>
</tbody></table>
<p>
Example:
</p>
<pre>var transferInfo = {
   "requestType": "vendor",
   "recipient": "device", 
   "direction": "out", 
   "request":  0x31,
   "value": 120, 
   "index": 0,
   "data": [4, 8, 15, 16, 23, 42]
 };
chrome.experimental.usb.controlTransfer(deviceObj, transferInfo, optionalCallback);
</pre>
<a name="H3-5"></a><h3>Sending data - isochronous transfers</h3>
<p>
Isochronous transfers are commonly used for streams of data.
Video and sound, for example, are good candidates for this transfer type.
To send an isochronous transfer, use:
</p>
<pre>chrome.experimental.usb.isochronousTransfer(deviceObj, isochronousTransferInfo, transferCallback)
</pre>
<br>
<table border="0">
  <tbody><tr>
    <th scope="col"> Parameter </th>
    <th scope="col"> Description </th>
  </tr>
  <tr>
    <td>deviceObj</td>
    <td>Object sent on <code>findDevice()</code> callback.</td>
  </tr>
  <tr>
    <td>isochronousTransferInfo</td>
    <td>Parameter object with the values in the table below.</td>
  </tr>
  <tr>
    <td>transferCallback()</td>
    <td>Invoked when the transfer has completed.
      Notice that this callback doesn't represent any response from the device.
      It's just to notify your code that the asynchronous transfer request
      has been processed and you can go ahead.
      The device's response, if any, will always be sent through
      the <code>onEvent()</code> callback set on <code>findDevice()</code>.
    </td>
  </tr>
</tbody></table>
<p>
Values for <code>isochronousTransferInfo</code> object:
</p>
<table border="0">
  <tbody><tr>
    <th scope="col"> Value </th>
    <th scope="col"> Description </th>
  </tr>
  <tr>
    <td>transferInfo (object)</td>
    <td>A parameter object with the following parameters:<br>
      <b>direction (string): </b>"in" or "out".<br>
      <b>endpoint (integer): </b>defined by your device's protocol.<br>
      <b>length (integer): </b>only used when direction is "in".
      Notifies the device that this is the amount
      of data the host is expecting in response<br>
      <b>data (integer array): </b>defined by your device's protocol;
      only used when direction is "out".
    </td>
  </tr>
  <tr>
    <td>packets (integer)</td>
    <td>Total number of packets expected in this transfer.</td>
  </tr>
  <tr>
    <td>packetLength (integer)</td>
    <td>Expected length of each packet in this transfer.</td>
  </tr>
</tbody></table>
<p>
Example:
</p>
<pre>var transferInfo = {
   "direction": "in", 
   "endpoint": 1,
   "length": 2560
 };
var isoTransferInfo = {
  "transferInfo": transferInfo,
  "packets": 20,
  "packetLength": 128
};
chrome.experimental.usb.isochronousTransfer(deviceObj, isoTransferInfo, optionalCallback);
</pre>
<a name="H3-6"></a><h3>Sending data - bulk transfers</h3>
<p>
Bulk transfer is a USB transfer type commonly used
to transfer a large amount of data reliably.
The method has three parameters:
</p>
<pre>chrome.experimental.usb.bulkTransfer(deviceObj, transferInfo, transferCallback)
</pre>
<br>
<table border="0">
  <tbody><tr>
    <th scope="col"> Parameter </th>
    <th scope="col"> Description </th>
  </tr>
  <tr>
    <td>deviceObj</td>
    <td>Object sent on <code>findDevice()</code> callback.</td>
  </tr>
  <tr>
    <td>transferInfo</td>
    <td>Parameter object with the values in the table below.</td>
  </tr>
  <tr>
    <td>transferCallback()</td>
    <td>Invoked when the transfer has completed.
      Notice that this callback doesn't represent any response from the device.
      It's just to notify your code that the asynchronous transfer request
      has been processed and you can go ahead.
      The device's response, if any, will always be sent through
      the <code>onEvent()</code> callback set on <code>findDevice()</code>.
    </td>
  </tr>
</tbody></table>
<p>
Values for <code>transferInfo</code> object:
</p>
<table border="0">
  <tbody><tr>
    <th scope="col"> Value </th>
    <th scope="col"> Description </th>
  </tr>
  <tr>
    <td>direction (string)</td>
    <td>"in" or "out".</td>
  </tr>
  <tr>
    <td>endpoint (integer)</td>
    <td>Defined by your device's protocol.</td>
  </tr>
  <tr>
    <td>length (integer)</td>
    <td>Only used when direction is "in".
      Notifies the device that this is the amount
      of data the host is expecting in response.</td>
  </tr>
  <tr>
    <td>data (integer array)</td>
    <td>Defined by your device's protocol;
      only used when direction is "out".</td>
  </tr>
</tbody></table>
<p>
Example:
</p>
<pre>var transferInfo = {
   "direction": "out", 
   "endpoint": 1,
   "data": [4, 8, 15, 16, 23, 42]
 };
</pre>
<a name="H3-7"></a><h3>Sending data - interrupt transfers</h3>
<p>
Interrupt transfers are used to send important notifications.
Since all USB communication is initiated by the host,
host code usually polls the device periodically,
sending interrupt IN transfers that will make the device send data back
if there is anything on the interrupt queue.
The method has three parameters:
</p>
<pre>chrome.experimental.usb.interruptTransfer(deviceObj, transferInfo, transferCallback)
</pre>
<br>
<table border="0">
  <tbody><tr>
    <th scope="col"> Parameter </th>
    <th scope="col"> Description </th>
  </tr>
  <tr>
    <td>deviceObj</td>
    <td>Object sent on <code>findDevice()</code> callback.</td>
  </tr>
  <tr>
    <td>transferInfo</td>
    <td>Parameter object with the values in the table below.</td>
  </tr>
  <tr>
    <td>transferCallback()</td>
    <td>Invoked when the transfer has completed.
      Notice that this callback doesn't represent any response from the device.
      It's just to notify your code that the asynchronous transfer request
      has been processed and you can go ahead.
      The device's response, if any, will always be sent through
      the <code>onEvent()</code> callback set on <code>findDevice()</code>.
    </td>
  </tr>
</tbody></table>
<p>
Values for <code>transferInfo</code> object:
</p>
<p>
Example:
</p><pre>var transferInfo = {
   "direction": "in", 
   "endpoint": 1,
   "length": 2
 };
chrome.experimental.usb.interruptTransfer(deviceObj, transferInfo, optionalCallback);
</pre><a name="H3-8"></a><h3>Caveats</h3><p>
On Linux,
you must have specific permission to access USB devices.
Create a file: <code>/etc/udev/rules.d/50-yourdevicename.rules</code>.
Add the following content:
</p><pre>SUBSYSTEM=="usb", ATTR{idVendor}=="yourdevicevendor", MODE="0664", GROUP="plugdev"
</pre><p>
On MacOSX,
devices which expose a HID profile cannot be managed
using this low level API due to system restrictions.
Currently there is no workaround.
</p><h2 id="serial">Accessing serial devices</h2><p>
You can use the serial API to read
and write from a serial device.
</p><a name="H3-10"></a><h3>Manifest requirement</h3><p>
The "serial" permission is not yet required;
"experimental" is enough for now:
</p><pre>"permissions": ["experimental"]
</pre><a name="H3-11"></a><h3>Listing available serial ports</h3><p>
To get a list of available serial ports,
use the <code>getPorts()</code> method:
</p><pre>var onGetPorts = function(ports) {
  for (var i=0; i&lt;ports.length; i++) {
    console.log(ports[i]);
  }
}
chrome.experimental.serial.getPorts(onGetPorts);
</pre><a name="H3-12"></a><h3>Opening a serial device</h3><p>
Here's how to open a serial device:
</p><pre>var onOpen = function(connectionInfo) {
   // The serial device has been opened. Save its id to use later.
  var conId = connectionInfo.connectionId;
  // Do whatever you need to do with the opened device.
}
// Open the serial device /dev/ttyS01
chrome.experimental.serial.open("/dev/ttyS01", onOpen);
</pre><a name="H3-13"></a><h3>Closing a serial device</h3><p>
Here's how to close a serial device:
</p><pre>var onClose = function(result) {
 console.log(“Serial port closed”);
}
chrome.experimental.serial.close(conId, onClose);
</pre><a name="H3-14"></a><h3>Reading from a serial device</h3><p>
The serial API reads from the serial port and
delivers the read bytes as an ArrayBuffer.
There is no guarantee that all the available bytes will be read in one chunk
(they are currently read one byte per time, but this might change in the future).
The following procedure can accumulate read bytes until a new line is read,
and then call a listener with the <code>ArrayBuffer</code> bytes converted to a String:
</p><pre>var dataRead='';
var onCharRead=function(readInfo) {
    if (!connectionInfo) {
      return;
    }
    if (readInfo &amp;&amp; readInfo.bytesRead&gt;0 &amp;&amp; readInfo.data) {
      var str=ab2str(readInfo.data);
      if (str[str.length-1]==='\n') {
        dataRead+=str.substring(0, str.length-1);
        onLineRead(dataRead);
        dataRead="";
      } else {
        dataRead+=str;
      }
    }
    chrome.experimental.serial.read(connectionInfo.connectionId, onCharRead);
  }
/* Convert an ArrayBuffer to a String, using UTF-8 as the encoding scheme.
   This is consistent with how Arduino sends characters by default */
  var ab2str=function(buf) {
    return String.fromCharCode.apply(null, new Uint8Array(buf));
  };
</pre><a name="H3-15"></a><h3>Writing to a serial device</h3><p>
The writing routine is simpler than the reading,
since the writing can occur all at once.
The only catch is that if your data protocol is String based,
you have to convert your output string to an <code>ArrayBuffer</code>
to compy with write's method signature.
See the code below:
</p><pre>var writeSerial=function(str) {
  chrome.experimental.serial.write(connectionInfo.connectionId, str2ab(str), onWrite);
}
var str2ab=function(str) {
  var buf=new ArrayBuffer(str.length);
  var bufView=new Uint8Array(buf);
  for (var i=0; i&lt;str.length; i++) {
    bufView[i]=str.charCodeAt(i);
  }
  return buf;
}
</pre><a name="H3-16"></a><h3>Flushing a serial device buffer</h3><p>
You can flush your serial device buffer by issuing the flush command on the API:
</p><pre>var flushSerial=function(str) {
  chrome.experimental.serial.flush(connectionInfo.connectionId, onFlush);
}
</pre><p class="backtotop"><a href="#top">Back to top</a></p><table border="0">
  <tbody><tr>
    <th scope="col"> Value </th>
    <th scope="col"> Description </th>
  </tr>
  <tr>
    <td>direction (string)</td>
    <td>"in" or "out".</td>
  </tr>
  <tr>
    <td>endpoint (integer)</td>
    <td>Defined by your device's protocol.</td>
  </tr>
  <tr>
    <td>length (integer)</td>
    <td>Only used when direction is "in".
      Notifies the device that this is the amount
      of data the host is expecting in response.</td>
  </tr>
  <tr>
    <td>data (integer array)</td>
    <td>Defined by your device's protocol;
      only used when direction is "out".</td>
  </tr>
</tbody></table></div>
        <!-- API PAGE -->
         <!-- /apiPage -->
      </div> <!-- /gc-pagecontent -->
    </div> <!-- /g-section -->
  </div> <!-- /codesiteContent -->
    <div id="gc-footer" --="">
      <div class="text">
  <p>
  Except as otherwise <a href="http://code.google.com/policies.html#restrictions">noted</a>,
  the content of this page is licensed under the <a rel="license" href="http://creativecommons.org/licenses/by/3.0/">Creative Commons
  Attribution 3.0 License</a>, and code samples are licensed under the
  <a rel="license" href="http://code.google.com/google_bsd_license.html">BSD License</a>.
  </p>
  <p>
  ©2011 Google
  </p>
<!-- begin analytics -->
<script src="https://www.google-analytics.com/urchin.js" type="text/javascript"></script>
<script src="https://www.google-analytics.com/ga.js" type="text/javascript"></script>
<script src="../js/prettify.js" type="text/javascript"></script>
<script>
  // Auto syntax highlight all pre tags.
  var pres = document.querySelectorAll('pre');
  for (var i = 0, pre; pre = pres[i]; ++i) {
    pre.className += ' prettyprint';
  };
  prettyPrint();
</script>
<script type="text/javascript">
  // chrome doc tracking
  try {
    var engdocs = _gat._getTracker("YT-10763712-2");
    engdocs._trackPageview();
  } catch(err) {}
  // code.google.com site-wide tracking
  try {
    _uacct="UA-18071-1";
    _uanchor=1;
    _uff=0;
    urchinTracker();
  }
  catch(e) {/* urchinTracker not available. */}
</script>
<!-- end analytics -->
      </div>
    </div> <!-- /gc-footer -->
  </div> <!-- /gc-container -->
</body></html>
