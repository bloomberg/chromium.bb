<!doctype html>
<!--
Tests that a Gamepad API gamepad is or is not returned under different
circumstances.
-->
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="../resources/webxr_e2e.css">
  </head>
  <body>
    <canvas id="webgl-canvas"></canvas>
    <script src="../../../../../../third_party/blink/web_tests/resources/testharness.js"></script>
    <script src="../resources/webxr_e2e.js"></script>
    <script src="../resources/webxr_boilerplate.js"></script>
    <script>
      // We apparently need to register a listener, otherwise all gamepads are
      // always null.
      window.addEventListener("gamepadconnected", function(e) {});

      function assertNumNavigatorGamepadsMatchesExpectation(numExpectedGamepads) {
        let numGamepads = 0;
        for (gamepad of navigator.getGamepads()) {
          if (gamepad !== null) {
            numGamepads++;
          }
        }
        assert_equals(numGamepads, numExpectedGamepads,
            "Number of returned gamepads matches expectation");
      }

      let validateFirstGamepadStateCallback = null;
      function validateInsufficientGamepadData() {
        onImmersiveXRFrameCallback = function(session) {
          // We don't expect to have attached any non-vr gamepads, and vr
          // gamepads shouldn't show up in navigator.getGamepads()
          assertNumNavigatorGamepadsMatchesExpectation(0);
          let input_sources = session.getInputSources();
          assert_equals(input_sources.length, 1, "There should only be one input source");
          assert_equals(input_sources[0].gamepad, null,
              "There should not be enough data to make a gamepad");
          onImmersiveXRFrameCallback = null;

          finishJavaScriptStep();
        }
      }

      function validateGamepad() {
        onImmersiveXRFrameCallback = function(session) {
          // We don't expect to have attached any non-vr gamepads, and vr
          // gamepads shouldn't show up in navigator.getGamepads()
          assertNumNavigatorGamepadsMatchesExpectation(0);
          let input_sources = session.getInputSources();
          assert_equals(input_sources.length, 1, "There should only be one input source");
          assert_not_equals(input_sources[0].gamepad, null,
              "There should be enough data to make a gamepad");
          assert_equals(input_sources[0].gamepad.mapping, "xr-standard");
          if (validateFirstGamepadStateCallback) {
            validateFirstGamepadStateCallback(input_sources[0].gamepad);
          }
          onImmersiveXRFrameCallback = null;

          finishJavaScriptStep();
        }
      }

      function validateButtonNotPressed(button_index) {
        validateFirstGamepadStateCallback = function(gamepad) {
          assert_less_than(button_index, gamepad.buttons.length,
            "Verify that we have at least as many buttons as requested");
          assert_false(gamepad.buttons[button_index].pressed);

          validateFirstGamepadStateCallback = null;
        }

        validateGamepad();
      }

      function validateButtonPressed(button_index) {
        validateFirstGamepadStateCallback = function(gamepad) {
          assert_less_than(button_index, gamepad.buttons.length,
            "Verify that we have at least as many buttons as requested");
          assert_true(gamepad.buttons[button_index].pressed);

          validateFirstGamepadStateCallback = null;
        }

        validateGamepad();
      }

      function validateButtonTouched(button_index) {
        validateFirstGamepadStateCallback = function(gamepad) {
          assert_less_than(button_index, gamepad.buttons.length,
            "Verify that we have at least as many buttons as requested");
          assert_true(gamepad.buttons[button_index].touched);

          validateFirstGamepadStateCallback = null;
        }

        validateGamepad();
      }

      function validateAxesValues(axes_pair_index, x_axis_value, y_axis_value) {
        validateFirstGamepadStateCallback = function(gamepad) {
          let epsilon = 0.001;
          let x_index = (2 * axes_pair_index);
          let y_index = (2 * axes_pair_index) + 1;

          assert_less_than(y_index, gamepad.axes.length,
            "Verify that we have at least as many axes as requested");
          assert_true(Math.abs(gamepad.axes[x_index] - x_axis_value) < epsilon,
            "X approximately equals expected");
          assert_true(Math.abs(gamepad.axes[y_index] - y_axis_value) < epsilon,
            "Y approximately equals expected");

          validateFirstGamepadStateCallback = null;
        }

        validateGamepad();
      }
    </script>
  </body>
</html>
