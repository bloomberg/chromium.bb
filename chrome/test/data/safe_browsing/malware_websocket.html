<title>Test whether a WebSocket connection triggers a SafeBrowsing interstitial</title>
<script>
const url = new URL(document.location.href);
const type = url.searchParams.get('type');
// Construct the WebSocket URL from the page URL. The server should be
// configured to accept a WebSocket handshake at this endpoint.
const wsUrl = new URL('/safe_browsing/malware-ws', url);
wsUrl.protocol = 'ws';

function workerTest() {
  const worker = new Worker('malware_websocket_worker.js');
  worker.onmessage = e => signalComplete(e.data);
  worker.postMessage(wsUrl.toString());
}

function sharedWorkerTest() {
  const worker = new SharedWorker('malware_websocket_worker.js');
  worker.onerror = e => signalComplete('SHARED_WORKER_ERROR');
  const port = worker.port;
  port.onmessage = e => signalComplete(e.data);
  port.postMessage(wsUrl.toString());
}

async function serviceWorkerTest() {
  try {
    await navigator.serviceWorker.register('malware_websocket_worker.js');
    const registration = await navigator.serviceWorker.ready;
    const messageChannel = new MessageChannel();
    messageChannel.port1.onmessage = e => signalComplete(e.data);
    registration.active.postMessage(wsUrl.toString(), [messageChannel.port2]);
  } catch (err) {
    signalComplete(`${err}`);
  }
}

function windowTest() {
  const ws = new WebSocket(wsUrl.href);
  ws.onerror = () => signalComplete('ERROR');
  ws.onopen = () => signalComplete('NOT BLOCKED');
}

function signalComplete(message) {
  // The "not blocked" test looks for this title change to verify that the
  // request has not been blocked.
  document.title = message;
}

switch (type) {
  case 'worker':
    workerTest();
    break;

  case 'shared-worker':
    sharedWorkerTest();
    break;

  case 'service-worker':
    serviceWorkerTest();
    break;

  default:
    windowTest();
    break;
}
</script>
