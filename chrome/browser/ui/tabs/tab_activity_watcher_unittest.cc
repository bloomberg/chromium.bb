// Copyright 2017 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/browser/ui/tabs/tab_activity_watcher.h"

#include <memory>

#include "base/macros.h"
#include "chrome/browser/browser_process.h"
#include "chrome/browser/engagement/site_engagement_service.h"
#include "chrome/browser/resource_coordinator/tab_manager.h"
#include "chrome/browser/ui/browser.h"
#include "chrome/browser/ui/tabs/tab_activity_watcher.h"
#include "chrome/browser/ui/tabs/tab_metrics_event.pb.h"
#include "chrome/browser/ui/tabs/tab_metrics_logger_impl.h"
#include "chrome/browser/ui/tabs/tab_strip_model.h"
#include "chrome/test/base/chrome_render_view_host_test_harness.h"
#include "chrome/test/base/test_browser_window.h"
#include "chrome/test/base/testing_profile.h"
#include "components/ukm/test_ukm_recorder.h"
#include "components/ukm/ukm_source.h"
#include "content/public/browser/render_view_host.h"
#include "content/public/browser/render_widget_host.h"
#include "content/public/browser/web_contents.h"
#include "content/public/test/web_contents_tester.h"
#include "services/metrics/public/cpp/ukm_builders.h"
#include "services/metrics/public/interfaces/ukm_interface.mojom.h"
#include "testing/gtest/include/gtest/gtest.h"
#include "third_party/WebKit/public/platform/WebInputEvent.h"
#include "third_party/WebKit/public/platform/WebMouseEvent.h"

using blink::WebInputEvent;
using content::WebContentsTester;
using metrics::TabMetricsEvent;
using ukm::builders::TabManager_TabMetrics;

// A UKM entry consists of named metrics with int64_t values. Use a map to
// specify expected metrics to test against an actual entry for tests.
using UkmMetricMap = std::map<const char*, int64_t>;

namespace {

const char* kEntryName = TabManager_TabMetrics::kEntryName;

const GURL kTestUrls[] = {
    GURL("https://example.com/"), GURL("https://google.fake"),
    GURL("https://example3.com"),
};

// The default metric values for a tab.
const UkmMetricMap kBasicMetricValues({
    {TabManager_TabMetrics::kContentTypeName,
     TabMetricsEvent::CONTENT_TYPE_TEXT_HTML},
    // TODO(michaelpg): Test HasBeforeUnloadHandler in a browser_test.
    {TabManager_TabMetrics::kHasBeforeUnloadHandlerName, 0},
    {TabManager_TabMetrics::kHasFormEntryName, 0},
    {TabManager_TabMetrics::kIsExtensionProtectedName, 0},
    {TabManager_TabMetrics::kIsPinnedName, 0},
    {TabManager_TabMetrics::kKeyEventCountName, 0},
    {TabManager_TabMetrics::kMouseEventCountName, 0},
    {TabManager_TabMetrics::kSiteEngagementScoreName, 0},
    {TabManager_TabMetrics::kTouchEventCountName, 0},
    {TabManager_TabMetrics::kWasRecentlyAudibleName, 0},
});

// Helper class to respond to WebContents lifecycle events we can't
// trigger/simulate.
class TestWebContentsObserver : public content::WebContentsObserver {
 public:
  explicit TestWebContentsObserver(content::WebContents* web_contents)
      : content::WebContentsObserver(web_contents) {}

  // content::WebContentsObserver:
  void WebContentsDestroyed() override {
    // Verify that a WebContents being destroyed does not trigger logging.
    web_contents()->WasHidden();
  }

 private:
  DISALLOW_COPY_AND_ASSIGN(TestWebContentsObserver);
};

blink::WebMouseEvent CreateMouseEvent(WebInputEvent::Type event_type) {
  return blink::WebMouseEvent(event_type, WebInputEvent::kNoModifiers,
                              WebInputEvent::kTimeStampForTesting);
}

}  // namespace

// Tests UKM entries generated by TabMetricsLogger at the request of
// TabActivityWatcher.
// Inherits from ChromeRenderViewHostTestHarness to use TestWebContents and
// Profile.
class TabActivityWatcherTest : public ChromeRenderViewHostTestHarness {
 protected:
  TabActivityWatcherTest() {
    TabActivityWatcher::GetInstance()->DisableLogTimeoutForTest();
  }

  void TearDown() override {
    EXPECT_FALSE(WasNewEntryRecorded());
    ChromeRenderViewHostTestHarness::TearDown();
  }

  // Creates a new WebContents suitable for testing, adds it to the tab strip
  // and commits a navigation to |initial_url|. The WebContents is owned by the
  // TabStripModel, so its tab must be closed later, e.g. via CloseAllTabs().
  content::WebContents* AddWebContentsAndNavigate(
      TabStripModel* tab_strip_model,
      const GURL& initial_url) {
    content::WebContents::CreateParams params(profile(), nullptr);
    // Create as a background tab if there are other tabs in the tab strip.
    params.initially_hidden = tab_strip_model->count() > 0;
    content::WebContents* test_contents =
        WebContentsTester::CreateTestWebContents(params);

    // Create the TestWebContentsObserver to observe |test_contents|. When the
    // WebContents is destroyed, the observer will be reset automatically.
    observers_.push_back(
        std::make_unique<TestWebContentsObserver>(test_contents));

    tab_strip_model->AppendWebContents(test_contents, false);
    WebContentsTester::For(test_contents)->NavigateAndCommit(initial_url);
    return test_contents;
  }

  // Sets |new_index| as the active tab in its tab strip, hiding the previously
  // active tab.
  void SwitchToTabAt(TabStripModel* tab_strip_model, int new_index) {
    int active_index = tab_strip_model->active_index();
    EXPECT_NE(new_index, active_index);

    content::WebContents* active_contents =
        tab_strip_model->GetWebContentsAt(active_index);
    ASSERT_TRUE(active_contents);
    content::WebContents* new_contents =
        tab_strip_model->GetWebContentsAt(new_index);
    ASSERT_TRUE(new_contents);

    // Activate the tab. Normally this would hide the active tab's aura::Window,
    // which is what actually triggers TabActivityWatcher to log the change. For
    // a TestWebContents, we must manually call WasHidden(), and do the reverse
    // for the newly activated tab.
    tab_strip_model->ActivateTabAt(new_index, /*user_gesture=*/true);
    active_contents->WasHidden();
    new_contents->WasShown();
  }

  // Expects that exactly one new TabManager.TabMetrics entry has been recorded,
  // and that it matches the values and the given URL.
  void ExpectNewEntry(const GURL& source_url,
                      const UkmMetricMap& expected_metrics) {
    num_entries_++;  // There should only be 1 more entry than before.
    std::vector<const ukm::mojom::UkmEntry*> entries =
        ukm_recorder()->GetEntriesByName(kEntryName);
    ASSERT_EQ(num_entries_, entries.size());

    // Verify the entry is associated with the correct URL.
    const ukm::mojom::UkmEntry* entry = entries.back();
    ukm_recorder()->ExpectEntrySourceHasUrl(entry, source_url);

    // Each expected metric should match a named value in the UKM entry.
    for (const std::pair<const char*, uint64_t>& pair : expected_metrics)
      ukm::TestUkmRecorder::ExpectEntryMetric(entry, pair.first, pair.second);
  }

  bool WasNewEntryRecorded() {
    return ukm_recorder()->GetEntriesByName(kEntryName).size() > num_entries_;
  }

  ukm::TestUkmRecorder* ukm_recorder() { return &ukm_recorder_; }

 private:
  ukm::TestAutoSetUkmRecorder ukm_recorder_;
  TabMetricsLoggerImpl tab_metrics_logger_;

  // Tracks the expected number of entries to ensure we don't log duplicate or
  // incorrect entries.
  size_t num_entries_ = 0;

  // Owns the observers we've created.
  std::vector<std::unique_ptr<TestWebContentsObserver>> observers_;

  DISALLOW_COPY_AND_ASSIGN(TabActivityWatcherTest);
};

TEST_F(TabActivityWatcherTest, Basic) {
  Browser::CreateParams params(profile(), true);
  auto browser = CreateBrowserWithTestWindowForParams(&params);

  TabStripModel* tab_strip_model = browser->tab_strip_model();
  content::WebContents* fg_contents =
      AddWebContentsAndNavigate(tab_strip_model, GURL(kTestUrls[0]));
  tab_strip_model->ActivateTabAt(0, false);
  WebContentsTester::For(fg_contents)->TestSetIsLoading(false);

  // Adding, loading and activating a foreground tab doesn't trigger logging.
  EXPECT_FALSE(WasNewEntryRecorded());

  // The second web contents is added as a background tab, so it logs an entry
  // when it stops loading.
  content::WebContents* bg_contents =
      AddWebContentsAndNavigate(tab_strip_model, GURL(kTestUrls[1]));
  WebContentsTester::For(bg_contents)->TestSetIsLoading(false);
  ExpectNewEntry(kTestUrls[1], kBasicMetricValues);

  // Activating a tab logs the deactivated tab.
  SwitchToTabAt(tab_strip_model, 1);
  {
    SCOPED_TRACE("");
    ExpectNewEntry(kTestUrls[0], kBasicMetricValues);
  }

  SwitchToTabAt(tab_strip_model, 0);
  {
    SCOPED_TRACE("");
    ExpectNewEntry(kTestUrls[1], kBasicMetricValues);
  }

  // Closing the tabs destroys the WebContentses but should not trigger logging.
  // The TestWebContentsObserver simulates hiding these tabs as they are closed;
  // we verify in TearDown() that no logging occurred.
  tab_strip_model->CloseAllTabs();
}

// Tests when tab events like pinning and navigating trigger logging.
TEST_F(TabActivityWatcherTest, TabEvents) {
  Browser::CreateParams params(profile(), true);
  auto browser = CreateBrowserWithTestWindowForParams(&params);

  TabStripModel* tab_strip_model = browser->tab_strip_model();
  content::WebContents* test_contents_1 =
      AddWebContentsAndNavigate(tab_strip_model, GURL(kTestUrls[0]));
  tab_strip_model->ActivateTabAt(0, false);

  // Opening the background tab triggers logging once the page finishes loading.
  content::WebContents* test_contents_2 =
      AddWebContentsAndNavigate(tab_strip_model, GURL(kTestUrls[1]));
  EXPECT_FALSE(WasNewEntryRecorded());
  WebContentsTester::For(test_contents_2)->TestSetIsLoading(false);
  {
    SCOPED_TRACE("");
    ExpectNewEntry(GURL(kTestUrls[1]), kBasicMetricValues);
  }

  // Navigating the active tab doesn't trigger logging.
  WebContentsTester::For(test_contents_1)->NavigateAndCommit(kTestUrls[2]);
  WebContentsTester::For(test_contents_1)->TestSetIsLoading(false);
  EXPECT_FALSE(WasNewEntryRecorded());

  // Pinning the active tab doesn't trigger logging.
  tab_strip_model->SetTabPinned(0, true);
  EXPECT_FALSE(WasNewEntryRecorded());

  // Pinning and unpinning the background tab triggers logging.
  tab_strip_model->SetTabPinned(1, true);
  UkmMetricMap expected_metrics(kBasicMetricValues);
  expected_metrics[TabManager_TabMetrics::kIsPinnedName] = 1;
  {
    SCOPED_TRACE("");
    ExpectNewEntry(GURL(kTestUrls[1]), expected_metrics);
  }
  tab_strip_model->SetTabPinned(1, false);
  expected_metrics[TabManager_TabMetrics::kIsPinnedName] = 0;
  {
    SCOPED_TRACE("");
    ExpectNewEntry(GURL(kTestUrls[1]), kBasicMetricValues);
  }

  // Navigating the background tab triggers logging once the page finishes
  // loading.
  WebContentsTester::For(test_contents_2)->NavigateAndCommit(kTestUrls[0]);
  EXPECT_FALSE(WasNewEntryRecorded());
  WebContentsTester::For(test_contents_2)->TestSetIsLoading(false);
  {
    SCOPED_TRACE("");
    ExpectNewEntry(GURL(kTestUrls[0]), kBasicMetricValues);
  }

  tab_strip_model->CloseAllTabs();
}

// Tests setting and changing tab metrics.
TEST_F(TabActivityWatcherTest, TabMetrics) {
  Browser::CreateParams params(profile(), true);
  auto browser = CreateBrowserWithTestWindowForParams(&params);

  TabStripModel* tab_strip_model = browser->tab_strip_model();
  content::WebContents* test_contents_1 =
      AddWebContentsAndNavigate(tab_strip_model, GURL(kTestUrls[0]));
  tab_strip_model->ActivateTabAt(0, false);

  // Expected metrics for tab event.
  UkmMetricMap expected_metrics(kBasicMetricValues);

  // Load background contents and verify UKM entry.
  content::WebContents* test_contents_2 =
      AddWebContentsAndNavigate(tab_strip_model, GURL(kTestUrls[1]));
  WebContentsTester::For(test_contents_2)->TestSetIsLoading(false);
  {
    SCOPED_TRACE("");
    ExpectNewEntry(kTestUrls[1], expected_metrics);
  }

  // Simulate an extension protecting the tab.
  g_browser_process->GetTabManager()->SetTabAutoDiscardableState(
      test_contents_2, false);
  expected_metrics[TabManager_TabMetrics::kIsExtensionProtectedName] = 1;

  // Site engagement score should round down to the nearest 10.
  SiteEngagementService::Get(profile())->ResetBaseScoreForURL(kTestUrls[1], 45);
  expected_metrics[TabManager_TabMetrics::kSiteEngagementScoreName] = 40;

  WebContentsTester::For(test_contents_2)->SetWasRecentlyAudible(true);
  expected_metrics[TabManager_TabMetrics::kWasRecentlyAudibleName] = 1;

  // Pin the background tab to log an event. (This moves it to index 0.)
  tab_strip_model->SetTabPinned(1, true);
  expected_metrics[TabManager_TabMetrics::kIsPinnedName] = 1;
  {
    SCOPED_TRACE("");
    ExpectNewEntry(kTestUrls[1], expected_metrics);
  }

  // Unset WasRecentlyAudible and navigate the background tab to a new domain.
  // Site engagement score for the new domain is 0.
  WebContentsTester::For(test_contents_2)->SetWasRecentlyAudible(false);
  expected_metrics[TabManager_TabMetrics::kWasRecentlyAudibleName] = 0;
  WebContentsTester::For(test_contents_2)->NavigateAndCommit(kTestUrls[2]);
  expected_metrics[TabManager_TabMetrics::kSiteEngagementScoreName] = 0;

  WebContentsTester::For(test_contents_2)->TestSetIsLoading(false);
  {
    SCOPED_TRACE("");
    ExpectNewEntry(kTestUrls[2], expected_metrics);
  }

  // Navigate the active tab and switch away from it. The entry should reflect
  // the new URL (even when the page hasn't finished loading).
  WebContentsTester::For(test_contents_1)->NavigateAndCommit(kTestUrls[2]);
  SwitchToTabAt(tab_strip_model, 0);
  {
    SCOPED_TRACE("");
    // This tab still has the default metrics.
    ExpectNewEntry(kTestUrls[2], kBasicMetricValues);
  }

  tab_strip_model->CloseAllTabs();
}

// Tests counting input events. TODO(michaelpg): Currently only tests mouse
// events.
TEST_F(TabActivityWatcherTest, InputEvents) {
  Browser::CreateParams params(profile(), true);
  auto browser = CreateBrowserWithTestWindowForParams(&params);

  TabStripModel* tab_strip_model = browser->tab_strip_model();
  content::WebContents* test_contents_1 =
      AddWebContentsAndNavigate(tab_strip_model, GURL(kTestUrls[0]));
  content::WebContents* test_contents_2 =
      AddWebContentsAndNavigate(tab_strip_model, GURL(kTestUrls[1]));
  tab_strip_model->ActivateTabAt(0, false);

  UkmMetricMap expected_metrics_1(kBasicMetricValues);
  UkmMetricMap expected_metrics_2(kBasicMetricValues);

  // Fake some input events.
  content::RenderWidgetHost* widget_1 =
      test_contents_1->GetRenderViewHost()->GetWidget();
  widget_1->ForwardMouseEvent(CreateMouseEvent(WebInputEvent::kMouseDown));
  widget_1->ForwardMouseEvent(CreateMouseEvent(WebInputEvent::kMouseUp));
  widget_1->ForwardMouseEvent(CreateMouseEvent(WebInputEvent::kMouseMove));
  expected_metrics_1[TabManager_TabMetrics::kMouseEventCountName] = 3;

  // Switch to the background tab. The current tab is deactivated and logged.
  SwitchToTabAt(tab_strip_model, 1);
  {
    SCOPED_TRACE("");
    ExpectNewEntry(kTestUrls[0], expected_metrics_1);
  }

  // The second tab's counts are independent of the other's.
  content::RenderWidgetHost* widget_2 =
      test_contents_2->GetRenderViewHost()->GetWidget();
  widget_2->ForwardMouseEvent(CreateMouseEvent(WebInputEvent::kMouseMove));
  expected_metrics_2[TabManager_TabMetrics::kMouseEventCountName] = 1;

  // Switch back to the first tab to log the second tab.
  SwitchToTabAt(tab_strip_model, 0);
  {
    SCOPED_TRACE("");
    ExpectNewEntry(kTestUrls[1], expected_metrics_2);
  }

  // New events are added to the first tab's existing counts.
  widget_1->ForwardMouseEvent(CreateMouseEvent(WebInputEvent::kMouseMove));
  widget_1->ForwardMouseEvent(CreateMouseEvent(WebInputEvent::kMouseMove));
  expected_metrics_1[TabManager_TabMetrics::kMouseEventCountName] = 5;
  test_contents_1->WasHidden();
  {
    SCOPED_TRACE("");
    ExpectNewEntry(kTestUrls[0], expected_metrics_1);
  }
  test_contents_1->WasShown();

  // After a navigation, test that the counts are reset.
  WebContentsTester::For(test_contents_1)->NavigateAndCommit(kTestUrls[2]);
  // The widget may have been invalidated by the navigation.
  widget_1 = test_contents_1->GetRenderViewHost()->GetWidget();
  widget_1->ForwardMouseEvent(CreateMouseEvent(WebInputEvent::kMouseMove));
  expected_metrics_1[TabManager_TabMetrics::kMouseEventCountName] = 1;
  test_contents_1->WasHidden();
  {
    SCOPED_TRACE("");
    ExpectNewEntry(kTestUrls[2], expected_metrics_1);
  }

  tab_strip_model->CloseAllTabs();
}

// Tests that logging happens when the browser window is hidden (even if the
// WebContents is still the active tab).
TEST_F(TabActivityWatcherTest, HideWindow) {
  Browser::CreateParams params(profile(), true);
  auto browser = CreateBrowserWithTestWindowForParams(&params);

  TabStripModel* tab_strip_model = browser->tab_strip_model();
  content::WebContents* test_contents =
      AddWebContentsAndNavigate(tab_strip_model, GURL(kTestUrls[0]));
  tab_strip_model->ActivateTabAt(0, false);

  // Hiding the window triggers the log.
  test_contents->WasHidden();
  {
    SCOPED_TRACE("");
    ExpectNewEntry(kTestUrls[0], kBasicMetricValues);
  }

  // Showing the window does not.
  test_contents->WasShown();
  EXPECT_FALSE(WasNewEntryRecorded());

  tab_strip_model->CloseAllTabs();
}
