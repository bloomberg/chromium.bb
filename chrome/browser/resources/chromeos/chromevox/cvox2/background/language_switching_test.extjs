// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Include test fixture.
GEN_INCLUDE(['../../testing/chromevox_next_e2e_test_base.js']);
GEN_INCLUDE(['../../testing/mock_feedback.js']);

/**
 * Test fixture for ChromeVox LanguageSwitching.
 * @constructor
 * @extends {ChromeVoxE2ETest}
 */
function ChromeVoxLanguageSwitchingTest() {
  ChromeVoxNextE2ETest.call(this);
}

ChromeVoxLanguageSwitchingTest.prototype = {
  __proto__: ChromeVoxNextE2ETest.prototype,

  /** @override */
  testGenCppIncludes: function() {
    GEN(`
// The following includes are copy-pasted from chromevox_e2e_test_base.js.
#include "ash/accessibility/accessibility_delegate.h"
#include "ash/shell.h"
#include "base/bind.h"
#include "base/callback.h"
#include "chrome/browser/chromeos/accessibility/accessibility_manager.h"
#include "chrome/common/extensions/extension_constants.h"

// The following includes are necessary for this test file.
#include "base/command_line.h"
#include "ui/accessibility/accessibility_switches.h"
#include "ui/base/ui_base_switches.h"
    `);
  },

  /** @override */
  testGenPreamble: function() {
    GEN(`
  base::CommandLine::ForCurrentProcess()->AppendSwitch(
    ::switches::kEnableExperimentalAccessibilityLanguageDetection);
  base::CommandLine::ForCurrentProcess()->AppendSwitch(
    ::switches::kEnableExperimentalAccessibilityChromeVoxLanguageSwitching);
  base::CommandLine::ForCurrentProcess()->AppendSwitchASCII(::switches::kLang, "en-US");

  // Copy-pasted from chromevox_e2e_test_base.js.
  base::Closure load_cb =
    base::Bind(&chromeos::AccessibilityManager::EnableSpokenFeedback,
        base::Unretained(chromeos::AccessibilityManager::Get()),
        true);
  WaitForExtension(extension_misc::kChromeVoxExtensionId, load_cb);
    `);
  },

  /** @override */
  setUp: function() {
    window.doCmd = this.doCmd;
  },

  /**
   * @return {!MockFeedback}
   */
  createMockFeedback: function() {
    var mockFeedback = new MockFeedback(this.newCallback(),
      this.newCallback.bind(this));

    mockFeedback.install();
    return mockFeedback;
  },

  /**
   * Create a function which performs the command |cmd|.
   * @param {string} cmd
   * @return {function(): void}
   */
  doCmd: function(cmd) {
    return function() {
      CommandHandler.onCommand(cmd);
    }
  },

  multipleLanguagesDoc: function() {/*!
    <p lang="es">Hola.</p>
    <p lang="en">Hello.</p>
    <p lang="fr">Salut.</p>
    <span lang="it">Ciao amico.</span>
  */},

  nestedLanguagesDoc: function() {/*!
    <p id="breakfast" lang="en">In the morning, I sometimes eat breakfast.</p>
    <p id="lunch" lang="fr">Dans l'apres-midi, je dejeune.</p>
    <p id="greeting" lang="en">
      Hello it's a pleasure to meet you.
      <span lang="fr">Comment ca va?</span>Switching back to English.
      <span lang="es">Hola.</span>Goodbye.
    </p>
  */},

  buttonAndLinkDoc: function() {/*!
    <body lang="es">
      <p>This is a paragraph, spoken in English.</p>
      <button type="submit">This is a button, spoken in English.</button>
      <a href="https://www.google.com">Este es un enlace.</a>
    </body>
  */},

  japaneseAndEnglishDoc: function() {/*!
    <meta charset="utf-8">
    <p>Hello, my name is 太田あきひろ. It's a pleasure to meet you. どうぞよろしくお願いします.</p>
  */},

  switchWhenUnlabeledDoc: function() {/*!
  <meta charset="utf-8">
  <p>This text should be read in English. 차에 한하여 중임할 수. Followed by English.</p>
  */},

  noSwitchEnglishFrenchDoc: function() {/*!
    <p>
      This entire object should be read in English, even the following French passage:
      salut mon ami! Ca va? Bien, et toi? It's hard to differentiate between latin-based languages.
    </p>
  */},

  japaneseAndChineseUnlabeledDoc: function() {/*!
    <meta charset="utf-8">
    <p>
      天気はいいですね. 右万諭全中結社原済権人点掲年難出面者会追
    </p>
  */},

  japaneseAndKoreanNotEnoughJapaneseDoc: function() {/*!
    <meta charset="utf-8">
    <p lang="ko">
      私は. 법률이 정하는 바에 의하여 대법관이 아닌 법관을 둘 수 있다
    </p>
  */},

  unlabeledSingleCharacterDoc: function() {/*!
    <meta charset="utf-8">
    <p>ど</p>
  */},

  // The purpose of this doc is to test functionality with three-letter language
  // codes. Asturian has a language code of 'ast'. It is a language spoken
  // in Principality of Asturias, Spain.
  asturianAndJapaneseDoc: function() {/*!
    <meta charset="utf-8">
    <p lang="ja">ど</p>
    <p lang="ast">
      Pretend that this text is Asturian. Testing three-letter language code logic.
    </p>
  */},
};

TEST_F('ChromeVoxLanguageSwitchingTest', 'MultipleLanguagesTest', function() {
  var mockFeedback = this.createMockFeedback();
  this.runWithLoadedTree(this.multipleLanguagesDoc, function() {
    // Turn on language switching.
    localStorage['languageSwitching'] = 'true';
    mockFeedback.call(doCmd('jumpToTop')).expectSpeechWithLanguage('es', 'español: Hola.');
    mockFeedback.call(doCmd('nextLine')).expectSpeechWithLanguage('en', 'English: Hello.');
    mockFeedback.call(doCmd('nextLine')).expectSpeechWithLanguage('fr', 'français: Salut.');
    mockFeedback.call(doCmd('nextLine')).expectSpeechWithLanguage('it', 'italiano: Ciao amico.');
    mockFeedback.replay();
  });
});

TEST_F('ChromeVoxLanguageSwitchingTest', 'NestedLanguagesTest', function() {
  var mockFeedback = this.createMockFeedback();
  this.runWithLoadedTree(this.nestedLanguagesDoc, function() {
    localStorage['languageSwitching'] = 'true';
    // We should be able to switch languages when each component is labeled
    // with a language.
    mockFeedback.call(doCmd('jumpToTop'))
        // LanguageSwitching.currentLanguage_ is initialized to 'en'. Do not
        // prepend 'English' because language does not switch.
        .expectSpeechWithLanguage('en', 'In the morning, I sometimes eat breakfast.');
    mockFeedback.call(doCmd('nextLine'))
        .expectSpeechWithLanguage('fr', "français: Dans l'apres-midi, je dejeune.");
    mockFeedback.call(doCmd('nextLine'))
        .expectSpeechWithLanguage('en', "English: Hello it's a pleasure to meet you. ");
    mockFeedback.call(doCmd('nextLine'))
        .expectSpeechWithLanguage('fr', 'français: Comment ca va?');
    mockFeedback.call(doCmd('nextLine'))
        .expectSpeechWithLanguage('en', 'English: Switching back to English. ');
    mockFeedback.call(doCmd('nextLine'))
        .expectSpeechWithLanguage('es', 'español: Hola.');
    mockFeedback.call(doCmd('nextLine'))
        .expectSpeechWithLanguage('en', 'English: Goodbye.');
    mockFeedback.replay();
  });
});

TEST_F('ChromeVoxLanguageSwitchingTest', 'ButtonAndLinkTest', function() {
  var mockFeedback = this.createMockFeedback();
  this.runWithLoadedTree(this.buttonAndLinkDoc, function(root) {
    localStorage['languageSwitching'] = 'true';
    mockFeedback.call(doCmd('jumpToTop'))
      // Inner-node language detection is able to label this as 'en' and
      // overwrite the author-provided language of 'es'.
      // LanguageSwitching.currentLanguage_ is initialized to 'en'. Do not
      // prepend 'English' because language does not switch.
      .expectSpeechWithLanguage('en', 'This is a paragraph, spoken in English.')
      .call(doCmd('nextObject'))
      // Even though this is unlabeled, CLD3 is able to determine, with high
      // confidence, that this is English text.
      .expectSpeechWithLanguage('en', 'This is a button, spoken in English.')
      .expectSpeechWithLanguage(undefined, 'Button', 'Press Search+Space to activate.')
      .call(doCmd('nextObject'))
      .expectSpeechWithLanguage('es', 'español: Este es un enlace.')
      .expectSpeechWithLanguage(undefined, 'Link');
    mockFeedback.replay();
  });
});

TEST_F('ChromeVoxLanguageSwitchingTest', 'JapaneseAndEnglishUnlabeledTest', function() {
  var mockFeedback = this.createMockFeedback();
  this.runWithLoadedTree(this.japaneseAndEnglishDoc, function(root) {
    localStorage['languageSwitching'] = 'true';
    // We are able to separate out English and Japanese because they use
    // different scripts.
    mockFeedback.call(doCmd('jumpToTop'))
      // LanguageSwitching.currentLanguage_ is initialized to 'en'. Do not
      // prepend 'English' because language does not switch.
      .expectSpeechWithLanguage('en', 'Hello, my name is ')
      .expectSpeechWithLanguage('ja', '日本語: 太田あきひろ. ')
      // Expect 'en-us' because inner-node language of 'en' doesn't come with
      // high enough probability. We fall back on node-level detected language,
      // which is 'en-us'.
      .expectSpeechWithLanguage('en-us', "English: It's a pleasure to meet you. ")
      .expectSpeechWithLanguage('ja', '日本語: どうぞよろしくお願いします.');
    mockFeedback.replay();
  });
});

TEST_F('ChromeVoxLanguageSwitchingTest', 'SwitchWhenUnlabeledTest', function() {
  var mockFeedback = this.createMockFeedback();
  this.runWithLoadedTree(this.switchWhenUnlabeledDoc, function(root) {
    localStorage['languageSwitching'] = 'true';
    // We are able to separate out English and Korean because they use
    // different scripts.
    mockFeedback.call(doCmd('jumpToTop'))
      // LanguageSwitching.currentLanguage_ is initialized to 'en'. Do not
      // prepend 'English' because language does not switch.
      .expectSpeechWithLanguage('en', 'This text should be read in English. ')
      .expectSpeechWithLanguage('ko', '한국어: 차에 한하여 중임할 수. ')
      // Expect 'en-us' because inner-node language of 'en' doesn't come with
      // high enough probability. We fall back on node-level detected language,
      // which is 'en-us'.
      .expectSpeechWithLanguage('en-us', 'English: Followed by English.');
    mockFeedback.replay();
  });
});

TEST_F('ChromeVoxLanguageSwitchingTest', 'NoSwitchEnglishFrenchTest', function() {
  var mockFeedback = this.createMockFeedback();
  this.runWithLoadedTree(this.noSwitchEnglishFrenchDoc, function(root) {
    localStorage['languageSwitching'] = 'true';
    // Unable to separate out English and French when unlabeled.
    mockFeedback.call(doCmd('jumpToTop'))
      // LanguageSwitching.currentLanguage_ is initialized to 'en'. Do not
      // prepend 'English' because language does not switch.
      .expectSpeechWithLanguage('en', 'This entire object should be read in English, even'
      + ' the following French passage: salut mon ami! Ca va? Bien, et toi? It\'s hard to'
      + ' differentiate between latin-based languages.');
    mockFeedback.replay();
  });
});

TEST_F('ChromeVoxLanguageSwitchingTest', 'UnlabeledSingleCharacterTest', function() {
  var mockFeedback = this.createMockFeedback();
  this.runWithLoadedTree(this.unlabeledSingleCharacterDoc, function(root) {
    localStorage['languageSwitching'] = 'true';
    // We are able to detect and switch at the character level if the character
    // is unique to a certian script. In this case, 'ど' only appears in
    // Japanese, and therefore we can confidently switch languages.
    mockFeedback.call(doCmd('jumpToTop'))
        .expectSpeechWithLanguage('ja', '日本語: ど');
    mockFeedback.replay();
  });
});

TEST_F('ChromeVoxLanguageSwitchingTest', 'JapaneseAndChineseUnlabeled', function() {
  var mockFeedback = this.createMockFeedback();
  this.runWithLoadedTree(this.japaneseAndChineseUnlabeledDoc, function(root) {
    localStorage['languageSwitching'] = 'true';
    // Unable to separate out Japanese and Chinese if unlabeled.
    mockFeedback.call(doCmd('jumpToTop'))
        .expectSpeechWithLanguage('ja',
          '日本語: 天気はいいですね. 右万諭全中結社原済権人点掲年難出面者会追');
    mockFeedback.replay();
  });
});

TEST_F('ChromeVoxLanguageSwitchingTest', 'JapaneseAndKoreanNotEnoughJapanese', function() {
  var mockFeedback = this.createMockFeedback();
  this.runWithLoadedTree(this.japaneseAndKoreanNotEnoughJapaneseDoc, function(root) {
    localStorage['languageSwitching'] = 'true';
    // Unable to separate out Japanese and Korean if unlabeled.
    mockFeedback.call(doCmd('jumpToTop'))
        .expectSpeechWithLanguage('ko',
        '한국어: 私は. 법률이 정하는 바에 의하여 대법관이 아닌 법관을 둘 수 있다');
    mockFeedback.replay();
  });
});

TEST_F('ChromeVoxLanguageSwitchingTest', 'AsturianTest', function() {
  var mockFeedback = this.createMockFeedback();
  this.runWithLoadedTree(this.asturianAndJapaneseDoc, function(root) {
    localStorage['languageSwitching'] = 'true';
    mockFeedback.call(doCmd('jumpToTop'))
        .expectSpeechWithLanguage('ja', '日本語: ど')
        .call(doCmd('nextObject'))
        .expectSpeechWithLanguage('ast', 'asturianu: Pretend that this text is Asturian. Testing'
        + ' three-letter language code logic.');
    mockFeedback.replay();
  });
});

TEST_F('ChromeVoxLanguageSwitchingTest', 'LanguageSwitchingOffTest', function() {
  var mockFeedback = this.createMockFeedback();
  this.runWithLoadedTree(this.multipleLanguagesDoc, function(root) {
    localStorage['languageSwitching'] = 'false';
    // Language should not be set if the language switching feature is off.
    mockFeedback.call(doCmd('jumpToTop'))
        .expectSpeechWithLanguage(undefined, 'Hola.')
        .call(doCmd('nextObject'))
        .expectSpeechWithLanguage(undefined, 'Hello.')
        .call(doCmd('nextObject'))
        .expectSpeechWithLanguage(undefined, 'Salut.')
        .call(doCmd('nextObject'))
        .expectSpeechWithLanguage(undefined, 'Ciao amico.')
    mockFeedback.replay();
  });
});
