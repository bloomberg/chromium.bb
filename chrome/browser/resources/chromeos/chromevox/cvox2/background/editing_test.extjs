// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Include test fixture.
GEN_INCLUDE(['../../testing/chromevox_next_e2e_test_base.js',
             '../../testing/assert_additions.js']);

GEN_INCLUDE(['../../testing/mock_feedback.js']);

/**
 * Test fixture for editing tests.
 * @constructor
 * @extends {ChromeVoxNextE2ETest}
 */
function EditingTest() {
  ChromeVoxNextE2ETest.call(this);
  window.RoleType = chrome.automation.RoleType;
}

EditingTest.prototype = {
  __proto__: ChromeVoxNextE2ETest.prototype,

  /**
   * @return {!MockFeedback}
   */
  createMockFeedback: function() {
    var mockFeedback = new MockFeedback(this.newCallback(),
                                        this.newCallback.bind(this));
    mockFeedback.install();
    return mockFeedback;
  },

  assertLineData: function(doc, data) {
    this.runWithLoadedTree(doc, function(root) {
      var input = root.find({role: RoleType.TEXT_FIELD});
      input.addEventListener('focus', this.newCallback(function() {
        var textHandler = ChromeVoxState.desktopAutomationHandler
            .textEditHandler_.editableText_;

        var offset = 0;
        for (var i = 0; i < data.length; i++) {
          var line = data[i];
          var actualStart = textHandler.getLineStart(i);
          var actualEnd = textHandler.getLineEnd(i);
          assertEquals(line.start, actualStart,
                       'Unexpected start: ' + actualStart);
          assertEquals(line.end, actualEnd,
                      'Unexpected end: ' + actualEnd);
          assertEquals(line.text, textHandler.getLine(i));
          var offset = textHandler.getLineStart(i);
          for (var j = 0; j < line.text.length; j++, offset++) {
            assertEquals(i, textHandler.getLineIndex(offset),
                'Unexpected Line: ' + line.text + ' at index: ' + offset);
          }
        }
      }), true);
      input.focus();
    });
  },

};

var doc = function() {/*!
  <label for='singleLine'>singleLine</label>
  <input type='text' id='singleLine' value='Single line field'><br>
  <label for='textarea'>textArea</label>
  <textarea id='textarea'>
Line 1&#xa;
line 2&#xa;
line 3
</textarea>
*/};

TEST_F('EditingTest', 'Focus', function() {
  var mockFeedback = this.createMockFeedback();
  this.runWithLoadedTree(doc, function(root) {
    var singleLine = root.find({role: RoleType.TEXT_FIELD,
                                attributes: {name: 'singleLine'}});
    var textarea = root.find({role: RoleType.TEXT_FIELD,
                              attributes: {name: 'textArea'}});
    singleLine.focus();
    mockFeedback
        .expectSpeech('singleLine', 'Single line field', 'Edit text')
        .expectBraille('singleLine Single line field ed',
                       {startIndex: 11, endIndex: 11})
        .call(textarea.focus.bind(textarea))
        .expectSpeech('textArea',
                      'Line 1\nline 2\nline 3',
                      'Text area')
        .expectBraille('textArea Line 1 mled',
                      {startIndex: 9, endIndex: 9});

    mockFeedback.replay();
  });
});

TEST_F('EditingTest', 'Multiline', function() {
  var mockFeedback = this.createMockFeedback();
  this.runWithLoadedTree(doc, function(root) {
    var textarea = root.find({role: RoleType.TEXT_FIELD,
                              attributes: {name: 'textArea'}});
    textarea.focus();
    mockFeedback
        .expectSpeech('textArea',
                      'Line 1\nline 2\nline 3',
                      'Text area')
        .expectBraille('textArea Line 1 mled',
                      {startIndex: 9, endIndex: 9})
        .call(textarea.setSelection.bind(textarea, 1, 1))
        .expectSpeech('i')
        .expectBraille('textArea Line 1 mled',
                       {startIndex: 10, endIndex: 10})
        .call(textarea.setSelection.bind(textarea, 7, 7))
        .expectSpeech('line 2')
        .expectBraille('line 2',
                       {startIndex: 0, endIndex: 0})
        .call(textarea.setSelection.bind(textarea, 7, 13))
        .expectSpeech('line 2', 'selected')
        .expectBraille('line 2',
                       {startIndex: 0, endIndex: 6});

    mockFeedback.replay();
  });
});

TEST_F('EditingTest', 'TextButNoSelectionChange', function() {
  var mockFeedback = this.createMockFeedback();
  this.runWithLoadedTree(
    function() {/*!
      <h1>Test doc</h1>
      <input type='text' id='input' value='text1'>
      <!-- We don't seem to get an event in js when the automation
           setSelection function is called, so poll for the actual change. -->

      <script>
        var timer;
        var input = document.getElementById('input');
        function poll(e) {
          if (input.selectionStart == 0)
            return;
          console.log('TIM' + 'ER');
          input.value = 'text2';
          window.clearInterval(timer);
        }
        timer = window.setInterval(poll, 200);
      </script>
    */},
    function(root) {
      var input = root.find({role: RoleType.TEXT_FIELD});
      input.focus();
      mockFeedback
          .expectSpeech('text1', 'Edit text')
          .expectBraille('text1 ed', {startIndex: 0, endIndex: 0})
          .call(input.setSelection.bind(input, 5, 5))
          .expectBraille('text2 ed', {startIndex: 5, endIndex: 5})
          .expectSpeech('text2');

      mockFeedback.replay();
    });
});

TEST_F('EditingTest', 'OneLineBreak', function() {
  this.assertLineData(function() {/*!
      <div role="textbox" contenteditable>this is a<br>test</div>
    */},
    [
      {start: 0, end: 9, text: 'this is a'},
      {start: 10, end: 14, text: 'test'}
    ]);
});

TEST_F('EditingTest', 'TwoLineBreaks', function() {
  this.assertLineData(function() {/*!
      <div role="textbox" contenteditable>this is a<br><br>
          test</div>
    */},
    [
      {start: 0, end: 9, text: 'this is a'},
      {start: 10, end: 10, text: ''},
      {start: 11, end: 15, text: 'test'},
    ]);
});

TEST_F('EditingTest', 'InitialBreaks', function() {
  this.assertLineData(function() {/*!
      <div role="textbox" contenteditable><br><br><br>
        this is a</div>
    */},
    [
      {start: 0, end: 0, text: ''},
      {start: 1, end: 1, text: ''},
      {start: 2, end: 2, text: ''},
      {start: 3, end: 12, text: 'this is a'},
    ]);
});

TEST_F('EditingTest', 'SingleCharacterLine', function() {
  this.assertLineData(function() {/*!
      <div role="textbox" contenteditable>
        <div>this</div><br>
        <div><br>
            I<br>
            can test</div></div>
    */},
    [
      {start: 0, end: 4, text: 'this'},
      {start: 5, end: 5, text: ''},
      {start: 6, end: 6, text: ''},
      {start: 7, end: 8, text: 'I'},
      {start: 9, end: 17, text: 'can test'},
    ]);
});

// Fails flakily, see https://crbug.com/724847.
TEST_F('EditingTest', 'DISABLED_RichTextMoveByLine', function() {
  editing.useRichText = true;
  var mockFeedback = this.createMockFeedback();
  this.runWithLoadedTree(function() {/*!
    <div id="go" role="textbox" contenteditable>
      <h2>hello</h2>
      <div><br></div>
      <p>This is a <a href="#test">test</a> of rich text</p>
    </div>
    <script>
      var dir = 'forward';
      var line = 0;
      document.getElementById('go').addEventListener('click', function() {
        var sel = getSelection();
        sel.modify('move', dir, 'line');
        if (dir == 'forward')
          line++;
        else
          line--;

        if (line == 0)
          dir = 'forward';
        if (line == 2)
          dir = 'backward';
      }, true);
    </script>
  */}, function(root) {
    var input = root.find({role: RoleType.TEXT_FIELD});
    var moveByLine = input.doDefault.bind(input);
    mockFeedback.call(input.focus.bind(input))
        .expectSpeech('Text area')
        .call(moveByLine)
        .expectSpeech('\n')
        .expectBraille('\n')
        .call(moveByLine)
        .expectSpeech('This is a ', 'test', 'Link', ' of rich text')
        .expectBraille('This is a test lnk of rich text')
        .call(moveByLine)
        .expectSpeech('\n')
        .expectBraille('\n')
        .call(moveByLine)
        .expectSpeech('hello', 'Heading 2')
        .expectBraille('hello h2')
        .replay();
  });
});

// Fails flakily, see https://crbug.com/732000.
TEST_F('EditingTest', 'DISABLED_RichTextMoveByCharacter', function() {
  editing.useRichText = true;
  var mockFeedback = this.createMockFeedback();
  this.runWithLoadedTree(function() {/*!
    <div id="go" role="textbox" contenteditable>This <b>is</b> a test.</div>

    <script>
      var dir = 'forward';
      var char = 0;
      document.getElementById('go').addEventListener('click', function() {
        var sel = getSelection();
        sel.modify('move', dir, 'character');
        if (dir == 'forward')
          char++;
        else
          char--;

        if (char == 0)
          dir = 'forward';
        if (line == 16)
          dir = 'backward';
      }, true);
    </script>
  */}, function(root) {
    var input = root.find({role: RoleType.TEXT_FIELD});
    var moveByChar = input.doDefault.bind(input)
    var lineText = 'This is a test.';

    mockFeedback.call(input.focus.bind(input))
        .expectSpeech(lineText)
        .expectSpeech('Text area')
        .call(moveByChar)
        .expectSpeech('h')
        .expectBraille(lineText, { startIndex: 1, endIndex: 1 })
        .call(moveByChar)
        .expectSpeech('i')
        .expectBraille(lineText, { startIndex: 2, endIndex: 2 })
        .call(moveByChar)
        .expectSpeech('s')
        .expectBraille(lineText, { startIndex: 3, endIndex: 3 })
        .call(moveByChar)
        .expectSpeech(' ')
        .expectBraille(lineText, { startIndex: 4, endIndex: 4 })

        .call(moveByChar)
        .expectSpeech('i')
        .expectSpeech('Bold start')
        .expectBraille(lineText, { startIndex: 5, endIndex: 5 })

        .call(moveByChar)
        .expectSpeech('s')
        .expectSpeech('Bold end')
        .expectBraille(lineText, { startIndex: 6, endIndex: 6 })

        .call(moveByChar)
        .expectSpeech(' ')
        .expectBraille(lineText, { startIndex: 7, endIndex: 7 })

        .call(moveByChar)
        .expectSpeech('a')
        .expectBraille(lineText, { startIndex: 8, endIndex: 8 })

        .call(moveByChar)
        .expectSpeech(' ')
        .expectBraille(lineText, { startIndex: 9, endIndex: 9 })

        .replay();
  });
});

// Tests specifically for cursor workarounds.
// Fails flakily, see https://crbug.com/731825.
TEST_F('EditingTest', 'DISABLED_RichTextMoveByCharacterNodeWorkaround', function() {
  editing.useRichText = true;
  var mockFeedback = this.createMockFeedback();
  this.runWithLoadedTree(function() {/*!
    <div id="go" role="textbox" contenteditable>hello <b>world</b></div>

    <script>
      document.getElementById('go').addEventListener('click', function() {
        var sel = getSelection();
        sel.modify('move', 'forward', 'character');
      }, true);
    </script>
  */}, function(root) {
    var input = root.find({role: RoleType.TEXT_FIELD});
    var moveByChar = input.doDefault.bind(input)
    var lineText = 'hello world';

    mockFeedback.call(input.focus.bind(input))
        .expectSpeech(lineText)
        .expectSpeech('Text area')
        .call(moveByChar)
        .expectSpeech('e')
        .expectBraille(lineText, { startIndex: 1, endIndex: 1 })
        .call(moveByChar)
        .expectSpeech('l')
        .expectBraille(lineText, { startIndex: 2, endIndex: 2 })
        .call(moveByChar)
        .expectSpeech('l')
        .expectBraille(lineText, { startIndex: 3, endIndex: 3 })
        .call(moveByChar)
        .expectSpeech('o')
        .expectBraille(lineText, { startIndex: 4, endIndex: 4 })
        .call(moveByChar)
        .expectSpeech(' ')
        .expectBraille(lineText, { startIndex: 5, endIndex: 5 })
        .call(moveByChar)
        .expectSpeech('w')
        .expectBraille(lineText, { startIndex: 6, endIndex: 6 })
        .replay();
  });
});
