// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Test fixture for rect_helper.js.
 * @constructor
 * @extends {testing.Test}
 */
function SwitchAccessRectHelperUnitTest() {
  testing.Test.call(this);
}

SwitchAccessRectHelperUnitTest.prototype = {
  __proto__: testing.Test.prototype,

  /** @override */
  extraLibraries: [
    'rect_helper.js',
  ],
};

TEST_F('SwitchAccessRectHelperUnitTest', 'Equals', function() {
  const rect1 = {left: 0, top: 0, width: 10, height: 10};
  const rect2 = {left: 0, top: 0, width: 10, height: 10};
  const rect3 = {left: 1, top: 0, width: 10, height: 10};
  const rect4 = {left: 0, top: 1, width: 10, height: 10};
  const rect5 = {left: 0, top: 0, width: 11, height: 10};
  const rect6 = {left: 0, top: 0, width: 10, height: 11};

  assertTrue(RectHelper.areEqual(rect1, rect1), 'areEqual should be reflexive');
  assertTrue(RectHelper.areEqual(rect1, rect2),
      'Rect1 and Rect2 should be equal');
  assertTrue(RectHelper.areEqual(rect2, rect1),
      'areEqual should be symmetric (1)');
  assertFalse(RectHelper.areEqual(rect1, rect3),
      'rect1 and rect3 should not be equal');
  assertFalse(RectHelper.areEqual(rect3, rect1),
      'areEqual should be symmetric (2)');
  assertFalse(RectHelper.areEqual(rect1, rect4),
      'rect1 and rect4 should not be equal');
  assertFalse(RectHelper.areEqual(rect4, rect1),
      'areEqual should be symmetric (3)');
  assertFalse(RectHelper.areEqual(rect1, rect5),
      'rect1 and rect5 should not be equal');
  assertFalse(RectHelper.areEqual(rect5, rect1),
      'areEqual should be symmetric (4)');
  assertFalse(RectHelper.areEqual(rect1, rect6),
      'rect1 and rect6 should not be equal');
  assertFalse(RectHelper.areEqual(rect6, rect1),
      'areEqual should be symmetric (5)');
});

TEST_F('SwitchAccessRectHelperUnitTest', 'Center', function() {
  const rect1 = {left: 0, top: 0, width: 10, height: 10};
  const rect2 = {left: 10, top: 20, width: 10, height: 40};

  const center1 = RectHelper.center(rect1);
  assertEquals(5, center1.x, 'Center1 x should be 5');
  assertEquals(5, center1.y, 'Center1 y should be 5');

  const center2 = RectHelper.center(rect2);
  assertEquals(15, center2.x, 'Center2 x should be 15');
  assertEquals(40, center2.y, 'Center2 y should be 40');
});

TEST_F('SwitchAccessRectHelperUnitTest', 'Union', function() {
  const rect1 = {left: 0, top: 0, width: 10, height: 10};
  const rect2 = {left: 4, top: 4, width: 2, height: 2};
  const rect3 = {left: 10, top: 20, width: 10, height: 40};
  const rect4 = {left: 0, top: 10, width: 10, height: 10};
  const rect5 = {left: 5, top: 5, width: 10, height: 10};

  // When one rect entirely contains the other, that rect is returned.
  const union_1_2 = RectHelper.union(rect1, rect2);
  assertTrue(RectHelper.areEqual(rect1, union_1_2),
      'Union of rect1 and rect2 should be rect1');

  const union_1_3 = RectHelper.union(rect1, rect3);
  let expected = {left: 0, top: 0, width: 20, height: 60};
  assertTrue(RectHelper.areEqual(expected, union_1_3),
      'Union of rect1 and rect3 does not match expected value');

  const union_1_4 = RectHelper.union(rect1, rect4);
  expected = {left: 0, top: 0, width: 10, height: 20};
  assertTrue(RectHelper.areEqual(expected, union_1_4),
      'Union of rect1 and rect4 does not match expected value');

  const union_1_5 = RectHelper.union(rect1, rect5);
  expected = {left: 0, top: 0, width: 15, height: 15};
  assertTrue(RectHelper.areEqual(expected, union_1_5),
      'Union of rect1 and rect5 does not match expected value');
});

TEST_F('SwitchAccessRectHelperUnitTest', 'UnionAll', function() {
  const rect1 = {left: 0, top: 0, width: 10, height: 10};
  const rect2 = {left: 0, top: 10, width: 10, height: 10};
  const rect3 = {left: 10, top: 0, width: 10, height: 10};
  const rect4 = {left: 10, top: 10, width: 10, height: 10};
  const rect5 = {left: 0, top: 0, width: 100, height: 10};

  const union1 = RectHelper.unionAll([rect1, rect2, rect3, rect4]);
  let expected = {left: 0, top: 0, width: 20, height: 20};
  assertTrue(RectHelper.areEqual(expected, union1),
      'Union of rects 1-4 does not match expected value');

  const union2 = RectHelper.unionAll([rect1, rect2, rect3, rect4, rect5]);
  expected = {left: 0, top: 0, width: 100, height: 20};
  assertTrue(RectHelper.areEqual(expected, union2),
      'Union of rects 1-5 does not match expected value');
});

TEST_F('SwitchAccessRectHelperUnitTest', 'ExpandToFitWithPadding', function() {
  const padding = 5;
  let inner = {left: 100, top: 100, width: 100, height: 100};
  let outer = {left: 120, top: 120, width: 20, height: 20};
  let expected = {left: 95, top: 95, width: 110, height: 110};
  assertTrue(RectHelper.areEqual(expected,
      RectHelper.expandToFitWithPadding(padding, outer, inner)),
      'When outer is contained in inner, expandToFitWithPadding does not ' +
      'match expected value');

  inner = {left: 100, top: 100, width: 100, height: 100};
  outer = {left: 50, top: 50, width: 200, height: 200};
  assertTrue(RectHelper.areEqual(outer,
      RectHelper.expandToFitWithPadding(padding, outer, inner)),
      'When outer contains inner, expandToFitWithPadding should equal outer');

  inner = {left: 100, top: 100, width: 100, height: 100};
  outer = {left: 10, top: 10, width: 10, height: 10};
  expected = {left: 10, top: 10, width: 195, height: 195};
  assertTrue(RectHelper.areEqual(expected,
      RectHelper.expandToFitWithPadding(padding, outer, inner)),
      'When there is no overlap, expandToFitWithPadding does not match ' +
      'expected value');

  inner = {left: 100, top: 100, width: 100, height: 100};
  outer = {left: 120, top: 50, width: 200, height: 200};
  expected = {left: 95, top: 50, width: 225, height: 200};
  assertTrue(RectHelper.areEqual(expected,
      RectHelper.expandToFitWithPadding(padding, outer, inner)),
      'When there is some overlap, expandToFitWithPadding does not match ' +
      'expected value');

  inner = {left: 100, top: 100, width: 100, height: 100};
  outer = {left: 97, top: 95, width: 108, height: 110};
  expected = {left: 95, top: 95, width: 110, height: 110};
  assertTrue(RectHelper.areEqual(expected,
      RectHelper.expandToFitWithPadding(padding, outer, inner)),
      'When outer contains inner but without sufficient padding, ' +
      'expandToFitWithPadding does not match expected value');
});
