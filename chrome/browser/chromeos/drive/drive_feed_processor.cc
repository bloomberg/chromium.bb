// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include <utility>

#include "base/metrics/histogram.h"
#include "chrome/browser/chromeos/drive/document_entry_conversion.h"
#include "chrome/browser/chromeos/drive/drive_feed_processor.h"
#include "chrome/browser/chromeos/drive/drive_files.h"
#include "chrome/browser/chromeos/drive/drive_resource_metadata.h"
#include "content/public/browser/browser_thread.h"

using content::BrowserThread;

namespace drive {

class DriveFeedProcessor::FeedToEntryProtoMapUMAStats {
 public:
  FeedToEntryProtoMapUMAStats()
    : num_regular_files_(0),
      num_hosted_documents_(0) {
  }

  // Increment number of files.
  void IncrementNumFiles(bool is_hosted_document) {
    is_hosted_document ? num_hosted_documents_++ : num_regular_files_++;
  }

  // Updates UMA histograms with file counts.
  void UpdateFileCountUmaHistograms() {
    const int num_total_files = num_hosted_documents_ + num_regular_files_;
    UMA_HISTOGRAM_COUNTS("Drive.NumberOfRegularFiles", num_regular_files_);
    UMA_HISTOGRAM_COUNTS("Drive.NumberOfHostedDocuments",
                         num_hosted_documents_);
    UMA_HISTOGRAM_COUNTS("Drive.NumberOfTotalFiles", num_total_files);
  }

 private:
  int num_regular_files_;
  int num_hosted_documents_;
};

DriveFeedProcessor::DriveFeedProcessor(
    DriveResourceMetadata* resource_metadata)
  : resource_metadata_(resource_metadata),
    ALLOW_THIS_IN_INITIALIZER_LIST(weak_ptr_factory_(this)) {
}

DriveFeedProcessor::~DriveFeedProcessor() {
}

void DriveFeedProcessor::ApplyFeeds(
    const ScopedVector<google_apis::DocumentFeed>& feed_list,
    int64 start_changestamp,
    int64 root_feed_changestamp,
    const base::Closure& on_complete_callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(!on_complete_callback.is_null());

  const bool is_delta_feed = start_changestamp != 0;

  int64 delta_feed_changestamp = 0;
  FeedToEntryProtoMapUMAStats uma_stats;
  GURL root_upload_url;
  FeedToEntryProtoMap(feed_list,
                      &delta_feed_changestamp,
                      &root_upload_url,
                      &uma_stats);
  // Note FeedToEntryProtoMap calls Clear() which resets on_complete_callback_.
  on_complete_callback_ = on_complete_callback;
  ApplyEntryProtoMap(
      is_delta_feed,
      is_delta_feed ? delta_feed_changestamp : root_feed_changestamp);
  if (root_upload_url.is_valid())
    resource_metadata_->root()->set_upload_url(root_upload_url);

  // Shouldn't record histograms when processing delta feeds.
  if (!is_delta_feed)
    uma_stats.UpdateFileCountUmaHistograms();
}

void DriveFeedProcessor::ApplyEntryProtoMap(bool is_delta_feed,
                                            int64 feed_changestamp) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (!is_delta_feed) {  // Full update.
    resource_metadata_->root()->RemoveChildren();
    changed_dirs_.insert(resource_metadata_->root()->GetFilePath());
    resource_metadata_->set_loaded(true);
  }
  resource_metadata_->set_largest_changestamp(feed_changestamp);

  // Go through all entries generated by the feed and apply them to the local
  // snapshot of the file system.
  ApplyNextEntryProtoAsync();
}

void DriveFeedProcessor::ApplyNextEntryProtoAsync() {
  base::MessageLoopProxy::current()->PostTask(
      FROM_HERE,
      base::Bind(&DriveFeedProcessor::ApplyNextEntryProto,
                 weak_ptr_factory_.GetWeakPtr()));
}

void DriveFeedProcessor::ApplyNextEntryProto() {
  DCHECK(!on_complete_callback_.is_null());

  if (entry_proto_map_.empty()) {
    // All entries have been processed.
    on_complete_callback_.Run();
    return;
  }

  ApplyNextByIterator(entry_proto_map_.begin());
}

void DriveFeedProcessor::ApplyNextByIterator(DriveEntryProtoMap::iterator it) {
  DriveEntryProto entry_proto = it->second;
  DCHECK_EQ(it->first, entry_proto.resource_id());

  // The parent of this entry may not yet be processed. We need the parent
  // to be rooted in the metadata tree before we can add the child, so process
  // the parent first.
  DriveEntryProtoMap::iterator parent_it = entry_proto_map_.find(
      entry_proto.parent_resource_id());
  if (parent_it != entry_proto_map_.end()) {
    base::MessageLoopProxy::current()->PostTask(
        FROM_HERE,
        base::Bind(&DriveFeedProcessor::ApplyNextByIterator,
                   weak_ptr_factory_.GetWeakPtr(),
                   parent_it));
  } else {
    // Erase the entry so the deleted entry won't be referenced.
    entry_proto_map_.erase(it);
    ApplyEntryProto(entry_proto);
  }
}

void DriveFeedProcessor::ApplyEntryProto(const DriveEntryProto& entry_proto) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  // Lookup the entry.
  resource_metadata_->GetEntryInfoByResourceId(
      entry_proto.resource_id(),
      base::Bind(&DriveFeedProcessor::ContinueApplyEntryProto,
                 weak_ptr_factory_.GetWeakPtr(),
                 entry_proto));
}

void DriveFeedProcessor::ContinueApplyEntryProto(
    const DriveEntryProto& entry_proto,
    DriveFileError error,
    const FilePath& file_path,
    scoped_ptr<DriveEntryProto> old_entry_proto) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (error == DRIVE_FILE_OK) {
    if (entry_proto.deleted()) {
      // Deleted file/directory.
      RemoveEntryFromParent(entry_proto, file_path);
    } else {
      // Entry exists and needs to be refreshed.
      RefreshEntryProto(entry_proto, file_path);
    }
  } else if (error == DRIVE_FILE_ERROR_NOT_FOUND && !entry_proto.deleted()) {
    // Adding a new entry.
    AddEntryToParent(entry_proto);
  } else {
    // Continue.
    ApplyNextEntryProtoAsync();
  }
}

void DriveFeedProcessor::RefreshEntryProto(const DriveEntryProto& entry_proto,
                                           const FilePath& file_path) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  resource_metadata_->RefreshEntryProto(
      entry_proto,
      base::Bind(&DriveFeedProcessor::NotifyForRefreshEntryProto,
                 weak_ptr_factory_.GetWeakPtr(),
                 file_path));
}

void DriveFeedProcessor::NotifyForRefreshEntryProto(
    const FilePath& old_file_path,
    DriveFileError error,
    const FilePath& file_path,
    scoped_ptr<DriveEntryProto> entry_proto) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  DVLOG(1) << "NotifyForRefreshEntryProto " << file_path.value();
  if (error == DRIVE_FILE_OK) {
    // Notify old parent.
    changed_dirs_.insert(old_file_path.DirName());

    // Notify new parent.
    changed_dirs_.insert(file_path.DirName());

    // Notify self if entry is a directory.
    if (entry_proto->file_info().is_directory()) {
      // Notify new self.
      changed_dirs_.insert(file_path);
      // Notify old self.
      changed_dirs_.insert(old_file_path);
    }
  }

  ApplyNextEntryProtoAsync();
}

void DriveFeedProcessor::AddEntryToParent(const DriveEntryProto& entry_proto) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  resource_metadata_->AddEntryToParent(entry_proto,
      base::Bind(&DriveFeedProcessor::NotifyForAddEntryToParent,
                 weak_ptr_factory_.GetWeakPtr(),
                 entry_proto.file_info().is_directory()));
}

void DriveFeedProcessor::NotifyForAddEntryToParent(bool is_directory,
                                                   DriveFileError error,
                                                   const FilePath& file_path) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  DVLOG(1) << "NotifyForAddEntryToParent " << file_path.value();
  if (error == DRIVE_FILE_OK) {
    // Notify if a directory has been created.
    if (is_directory)
      changed_dirs_.insert(file_path);

    // Notify parent.
    changed_dirs_.insert(file_path.DirName());
  }

  ApplyNextEntryProtoAsync();
}


void DriveFeedProcessor::RemoveEntryFromParent(
    const DriveEntryProto& entry_proto,
    const FilePath& file_path) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(!file_path.empty());

  if (!entry_proto.file_info().is_directory()) {
    // No children if entry is a file.
    OnGetChildrenForRemove(entry_proto,
                           file_path,
                           std::set<FilePath>());
  } else {
    // If entry is a directory, notify its children.
    resource_metadata_->GetChildDirectories(
        entry_proto.resource_id(),
        base::Bind(&DriveFeedProcessor::OnGetChildrenForRemove,
                   weak_ptr_factory_.GetWeakPtr(),
                   entry_proto,
                   file_path));
  }
}

void DriveFeedProcessor::OnGetChildrenForRemove(
    const DriveEntryProto& entry_proto,
    const FilePath& file_path,
    const std::set<FilePath>& changed_directories) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(!file_path.empty());

  resource_metadata_->RemoveEntryFromParent(
      entry_proto.resource_id(),
      base::Bind(&DriveFeedProcessor::NotifyForRemoveEntryFromParent,
                 weak_ptr_factory_.GetWeakPtr(),
                 entry_proto.file_info().is_directory(),
                 file_path,
                 changed_directories));
}

void DriveFeedProcessor::NotifyForRemoveEntryFromParent(
    bool is_directory,
    const FilePath& file_path,
    const std::set<FilePath>& changed_directories,
    DriveFileError error,
    const FilePath& parent_path) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  DVLOG(1) << "NotifyForRemoveEntryFromParent " << file_path.value();
  if (error == DRIVE_FILE_OK) {
    // Notify parent.
    changed_dirs_.insert(parent_path);

    // Notify children, if any.
    changed_dirs_.insert(changed_directories.begin(),
                         changed_directories.end());

    // If entry is a directory, notify self.
    if (is_directory)
      changed_dirs_.insert(file_path);
  }

  // Continue.
  ApplyNextEntryProtoAsync();
}

void DriveFeedProcessor::AddEntryToParentDeprecated(DriveEntry* entry) {
  DriveDirectory* parent = ResolveParent(entry);

  if (!parent) {  // Orphan.
    delete entry;
    return;
  }
  parent->AddEntry(entry);

  // Notify this directory that has been created.
  if (entry->AsDriveDirectory())
    changed_dirs_.insert(entry->GetFilePath());

  // Notify |parent| only if it already exists by checking if it is attached to
  // the tree (has parent) or if it is root. The parent of |parent| may not
  // exist here if it is about to be created later in the same feed.
  if (parent->parent() || parent == resource_metadata_->root())
    changed_dirs_.insert(parent->GetFilePath());
}

void DriveFeedProcessor::RemoveEntryFromParent(DriveEntry* entry) {
  DriveDirectory* parent = entry->parent();
  if (!parent) {
    NOTREACHED();
    return;
  }

  DriveDirectory* dir = entry->AsDriveDirectory();
  // Notify all children of entry, if entry is a directory.
  if (dir)
    dir->GetChildDirectoryPaths(&changed_dirs_);

  parent->RemoveEntry(entry);

  // Notify parent.
  changed_dirs_.insert(parent->GetFilePath());
}

DriveDirectory* DriveFeedProcessor::ResolveParent(DriveEntry* new_entry) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  const std::string& parent_resource_id = new_entry->parent_resource_id();
  if (parent_resource_id.empty()) {
    DVLOG(1) << "Root parent for " << new_entry->base_name();
    return resource_metadata_->root();
  }

  DriveEntry* parent =
      resource_metadata_->GetEntryByResourceId(parent_resource_id);
  return parent ? parent->AsDriveDirectory() : NULL;
}

void DriveFeedProcessor::FeedToEntryProtoMap(
    const ScopedVector<google_apis::DocumentFeed>& feed_list,
    int64* feed_changestamp,
    GURL* root_upload_url,
    FeedToEntryProtoMapUMAStats* uma_stats) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  Clear();

  for (size_t i = 0; i < feed_list.size(); ++i) {
    const google_apis::DocumentFeed* feed = feed_list[i];

    // Get upload url from the root feed. Links for all other collections will
    // be handled in ConvertDocumentEntryToDriveEntryProto.
    if (i == 0) {
      if (root_upload_url) {
        const google_apis::Link* root_feed_upload_link =
            feed->GetLinkByType(google_apis::Link::LINK_RESUMABLE_CREATE_MEDIA);
        if (root_feed_upload_link)
          *root_upload_url = root_feed_upload_link->href();
      }
      if (feed_changestamp)
        *feed_changestamp = feed->largest_changestamp();
      DCHECK_GE(feed->largest_changestamp(), 0);
    }

    for (size_t j = 0; j < feed->entries().size(); ++j) {
      const google_apis::DocumentEntry* doc = feed->entries()[j];
      DriveEntryProto entry_proto = ConvertDocumentEntryToDriveEntryProto(*doc);
      // Some document entries don't map into files (i.e. sites).
      if (entry_proto.resource_id().empty())
        continue;

      // Count the number of files.
      if (uma_stats && !entry_proto.file_info().is_directory()) {
        uma_stats->IncrementNumFiles(
            entry_proto.file_specific_info().is_hosted_document());
      }

      std::pair<DriveEntryProtoMap::iterator, bool> ret = entry_proto_map_.
          insert(std::make_pair(entry_proto.resource_id(), entry_proto));
      DCHECK(ret.second);
      if (!ret.second)
        LOG(WARNING) << "Found duplicate file " << entry_proto.base_name();
    }
  }
}

void DriveFeedProcessor::Clear() {
  entry_proto_map_.clear();
  changed_dirs_.clear();
  on_complete_callback_.Reset();
}

}  // namespace drive
