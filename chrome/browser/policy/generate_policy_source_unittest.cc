// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include <string>

#include "base/memory/scoped_ptr.h"
#include "base/values.h"
#include "components/policy/core/common/schema.h"
#include "policy/policy_constants.h"
#include "testing/gtest/include/gtest/gtest.h"

// This unittest tests the code generated by
// chrome/tools/build/generate_policy_source.py.

namespace policy {

TEST(GeneratePolicySource, ChromeSchemaData) {
  scoped_ptr<SchemaOwner> schema_owner =
      SchemaOwner::Wrap(GetChromeSchemaData());
  ASSERT_TRUE(schema_owner);

  Schema schema = schema_owner->schema();
  EXPECT_EQ(base::Value::TYPE_DICTIONARY, schema.type());

  Schema subschema = schema.GetAdditionalProperties();
  EXPECT_FALSE(subschema.valid());

  subschema = schema.GetProperty("no such policy exists");
  EXPECT_FALSE(subschema.valid());

  subschema = schema.GetProperty(key::kAlternateErrorPagesEnabled);
  ASSERT_TRUE(subschema.valid());
  EXPECT_EQ(base::Value::TYPE_BOOLEAN, subschema.type());

  subschema = schema.GetProperty(key::kIncognitoModeAvailability);
  ASSERT_TRUE(subschema.valid());
  EXPECT_EQ(base::Value::TYPE_INTEGER, subschema.type());

  subschema = schema.GetProperty(key::kProxyMode);
  ASSERT_TRUE(subschema.valid());
  EXPECT_EQ(base::Value::TYPE_STRING, subschema.type());

  subschema = schema.GetProperty(key::kCookiesAllowedForUrls);
  ASSERT_TRUE(subschema.valid());
  EXPECT_EQ(base::Value::TYPE_LIST, subschema.type());
  ASSERT_TRUE(subschema.GetItems().valid());
  EXPECT_EQ(base::Value::TYPE_STRING, subschema.GetItems().type());

  subschema = schema.GetProperty(key::kProxySettings);
  ASSERT_TRUE(subschema.valid());
  EXPECT_EQ(base::Value::TYPE_DICTIONARY, subschema.type());
  EXPECT_FALSE(subschema.GetAdditionalProperties().valid());
  EXPECT_FALSE(subschema.GetProperty("no such proxy key exists").valid());
  ASSERT_TRUE(subschema.GetProperty(key::kProxyMode).valid());
  ASSERT_TRUE(subschema.GetProperty(key::kProxyServer).valid());
  ASSERT_TRUE(subschema.GetProperty(key::kProxyServerMode).valid());
  ASSERT_TRUE(subschema.GetProperty(key::kProxyPacUrl).valid());
  ASSERT_TRUE(subschema.GetProperty(key::kProxyBypassList).valid());

  // The properties are iterated in order.
  const char* kExpectedProperties[] = {
    key::kProxyBypassList,
    key::kProxyMode,
    key::kProxyPacUrl,
    key::kProxyServer,
    key::kProxyServerMode,
    NULL,
  };
  const char** next = kExpectedProperties;
  for (Schema::Iterator it(subschema.GetPropertiesIterator());
       !it.IsAtEnd(); it.Advance(), ++next) {
    ASSERT_TRUE(*next != NULL);
    EXPECT_STREQ(*next, it.key());
    ASSERT_TRUE(it.schema().valid());
    EXPECT_EQ(base::Value::TYPE_STRING, it.schema().type());
  }
  EXPECT_TRUE(*next == NULL);
}

}  // namespace policy
