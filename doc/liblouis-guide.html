<html>
<head>
<title>liblouis Guide</title>
<style>
Body {
margin: 10px;
}

h1 {
color: 003333;
margin-left: 0px;
text-align: center;
vertical-align: bottom;
display: inline;
}

h2 {
color: 333999;
background-color: DDDDDD;
margin-bottom: 10px;
margin-top: 10px;
border: 1px;
border-left: 10px;
border-style: solid;
padding-left: 10px
}

h3 {
color: FF3999;
background-color: DDDDDD;
margin-bottom: 10px;
margin-top: 10px;
border: 1px;
border-left: 10px;
border-style: solid;
padding-left: 10px
}

p {
text-align: justify;
margin: 10px 25px 10px 25px;
}

ul {
list-style-type: square;
list-style-position: outside;
}

a {
text-decoration: none;
color: blue;
}

a:hover {
text-decoration: underline;
background-color: #FFFFDD;
}

a:focus {
text-decoration: underline;
background-color: #FFFFDD;
}
</style>
</head>
<body>

<p align="center"><strong>Liblouis: Programmer's and User's 
Guide</strong></p>

<p><em>Copyright (C) 2004,2007<br/>
by<br/>
ViewPlus Technologies, Inc.<br/>
and<br/>
JJB Software, Inc.<br/>
All rights reserved.</em></p>

<p>Report bugs to the maintainer, john.boyer@jjb-software.com</p>

<h1>Table of Contents</h1>

<ul>
<li><a href="#intro">Introduction</a></li>

<li><a href="#programming">Programming with Liblouis</a></li>

<li><a href="#tests">Test Programs</a></li>

<li><a href="#writing">How to Write Translation Tables</a></li>

<li><a href="#hyphen">Hyphenation Tables</a></li>

<li><a href="#chardef">Character-Definition Opcodes</a></li>

<li><a href="#indicator">Braille Indicator Opcodes</a></li>

<li><a href="#emphasis">Emphasis Opcodes</a></li>

<li><a href="#specsym">Special-Symbol opcodes</a></li>

<li><a href="#specproc">Special Processing Opcodes</a></li>

<li><a href="#translation">Translation Opcodes</a></li>

<li><a href="#class">Character-Class Opcodes</a></li>

<li><a href="#conpass">Context and Multipass Opcodes</a></li>

<li><a href="#correct">The Correct Opcode</a></li>

<li><a href="#misc">Miscellaneous Opcodes</a></li>

<li><a href="#backtrans">Notes on Back-Translation</a></li>

<li><a href="#index">Index of Opcodes</a></li>
</ul>

<h1><a name="intro">Introduction</a></h1>

<p>Liblouis is an open-source braille translator and back-translator
based on the translation routines in the BRLTTY screenreader for Linux.
It has, however, gone far beyond these routines. It is named in honor of
Louis Braille. In Linux and Mac OSX it is a shared library, and in
Windows it is a DLL. For installation instructions see the REAGME file.
Please report bugs and oddities to the maintainer,
john.boyer@jjb-software.com</p>

<p>This documentation is based on Chapter 7 of the BRLTTY manual, but it
has been extensively rewritten to cover new features.</p>

<p>Please read the following copyright and warranty information. 
Note that this information also applies to all source code, tables 
and other files in this distribution of liblouis.</p>

<p>The liblouis Braille Translation and Back-Translation Library is
based on the Linux screenreader BRLTTY, copyright (C) 1999-2006 by the
BRLTTY Team.</p>

<p>It is also Copyright (C) 2004, 2005, 2006 by ViewPlus Technologies, Inc.
www.viewplus.com and JJB Software, Inc. www.jjb-software.com . All
rights reserved.</p>

<p>This file is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.</p>

<p>In addition to the permissions and restrictions contained in the GNU
General Public License (GPL), the copyright holders grant two explicit
permissions and impose one explicit restriction. The permissions are:</p>

<p>1) Using, copying, merging, publishing, distributing, sublicensing,
and/or selling copies of this software that are either compiled or loaded
as part of and/or linked into other code is not bound by the GPL.</p>

<p>2) Modifying copies of this software as needed in order to facilitate
compiling and/or linking with other code is not bound by the GPL.</p>

<p>The restriction is:</p>

<p>3. The translation tables that are read at run-time are considered part
of this code and are under the terms of the GPL. Any changes to these
tables and any additional tables that are created for use by this code
must be made publicly available.</p>

<p>All other uses, including modifications not required for compiling or linking
and distribution of code which is not linked into a combined executable, are
bound by the terms of the GPL.</p>

<p>This file is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.</p>

<p>You should have received a copy of the GNU General Public License
along with this program; see the file COPYING. If not, write to
the Free Software Foundation, 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.</p>

<p>This file is maintained by John J. Boyer john.boyer@jjb-software.com .</p>

<p>Persons who wish to write translation tables but will not be
programming with liblouis may want to skip ahead to the sections <a
href="#tests">Test Programs</a> or <a href="#writing">How to Write
Translation Tables</a>.</p>

<h1><a name="programming">Programming with liblouis</a></h1>

<ul>
<li><a href="#license">License</a></h2>
<li><a href="#progover">Overview</a></li>
<li><a href="#louversion">lou_version</a></li>
<li><a href="#loutransstring">lou_translateString</a></li>
<li><a href="#loutrans">lou_translate</a></li>
<li><a href="#loubacktransstring">lou_backTranslateString</a></li>
<li><a href="#loubacktrans">lou_backTranslate</a></li>
<li><a href="#louhyph">lou_hyphenate</a></li>
<li><a href="#loulogname">lou_logFileName</a></li>
<li><a href="#loulogprint">lou_logPrint</a></li>
<li><a href="#lougettab">lou_getTable</a></li>
<li><a href="#loureadchar">lou_readCharFromFile</a></li>
<li><a href="#loufree">lou_free</a></li>
</ul>

<h2><a name="license">License</a></h2>

<p>liblouis Braille Translation and Back-Translation Library</p>

<p>This file may contain code borrowed from the Linux screenreader
BRLTTY, copyright (C) 1999-2006 by
the BRLTTY Team.</p>

<p>Copyright (C) 2004-2007<br/>
ViewPlus Technologies, Inc. www.viewplus.com<br/>
and<br/>
JJB Software, Inc. www.jjb-software.com<br/>
All rigets reserved</p>

<p>This file is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.</p>

<p>In addition to the permissions and restrictions contained in the GNU
General Public License (GPL), the copyright holders grant two explicit
permissions and impose one explicit restriction. The permissions 
are:</p>

<p>1) Using, copying, merging, publishing, distributing, sublicensing, 
and/or selling copies of this software that are either compiled or loaded 
as part of and/or linked into other code is not bound by the GPL.</p>

<p>2) Modifying copies of this software as needed in order to facilitate 
compiling and/or linking with other code is not bound by the GPL.</p>

<p>The restriction is:</p>

<p>3. The translation, semantic-action and configuration tables that are 
read at run-time are considered part of this code and are under the terms 
of the GPL. Any changes to these tables and any additional tables that are 
created for use by this code must be made publicly available.</p>

<p>All other uses, including modifications not required for compiling or 
linking 
and distribution of code which is not linked into a combined executable, are 
bound by the terms of the GPL.</p>

<p>This file is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.</p>

<p>You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.  If not, write to the
Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
02110-1301, USA.</p>

<h2><a name="progover">Overview</a></h2>

<p>You use the liblouis library by calling eleven functionss,
lou_translateString, lou_backTranslateString, lou_logFileName,
lou_logPrint, lou_getTable, lou_translate, lou_backTranslate,
lou_hyphenate, lou_readCharFromFile and lou_free. These are described
below. The header file, liblouis.h, also contains brief descriptions.
Liblouis is written in straight C. It has just three code modules,
compileTranslationTable.c, lou_translateString.c and
lou_backTranslateString.c. In addition, there are two header files,
liblouis.h, which defines the API, and louis.h, used only internally.
The latter includes liblouis.h.</p>

<p>CompileTranslationTable.c keeps track of all translation tables which
an application has used. It is called by the translation, hyphenation
and checking functions when they start. If a table has not yet been
compiled compileTranslationTable.c checks it for correctness and
compiles it into an efficient insernal representation. The main entry
point is lou_getTable. Since it is the module that keeps track of memory
usage, it also contains the lou_free function. In addition, it conaains
the lou_logFileName and lou_logPrint functions, plus some utility
functions which are used by the other modules.</p>

<p>By default, liblouis handles all characters internally as 16-bit
unsigned integers. It can be compiled for 32-bit characters as explained
below.  The meanings of these integers are not hard-coded. rather they
are defined by the character-definition opcodes. However, the standard
printable characters, from decimal 32 to 126 are recognized for the
purpose of processing the opcodes. Hence, the following definition is
included in liblouis.h. It is correct for computers with at least 32-bit
processors.</p>

<p>#define widechar unsigned short int</p>

<p>To make liblouis handle 32-bit Unicode simply remove the word "short"
in the above define. This will cause the translate and back-translate
functions to expect input in 32-bit form and to deliver their output in
this form. The input to the compiler (tables) is unaffected except that
two new escape sequences for 20-bit and 32-bit characters are
recohnized.</p>

<p>Here are the definitions of the eleven liblouis functions and their
parameters. They are given in terms of 16-bit Unicode. If liblouis has
been compiled for 32-bit unicode simply read 32 instead of 16.</p>

<h2><a name="louversion">lou_version</a></h2>

<p>char *lou_veriion ()</p>

<p>This function returns a pointer to a character string containing the 
version of liblouis, plus other information, such as the release date 
and perhaps notable changes.</p>

<h2><a name="loutransstring">lou_translateString</a></h2>

<p>int lou_translateString (const char *const trantab, const widechar
*const inbuf, int *inlen, widechar *outbuf, int *outlen, 
char *typeform, char *spacing, int mode);</p>

<p>This function takes a string of 16-bit Unicode characters in inbuf and
translates it into a string of 16-bit characters in outbuf. Each 16-bit
character produces a particular dot pattern in one braille cell when
sent to an embosser or braille display or to a screen typefont. Which
16-bit character represents which dot pattern is indicated by the
character-definition and display opcodes in the translation table.</p>

<p>The trantab parameter points to a list of translation tables separated
by commas. If only one table is given, no comma should be used after
it. It is these tables which control just how the translation is made,
whether in Grade 2, Grade 1, or something else. The first table in the
list must be a full pathname, unless the tables are in the current
directory. The pathname is extracted up to the filename. The first
table is then compiled. The pathname is then added to the name of the
second table, which is compiled, and so on. The tables in a list are
all compiled into the same internal table. The list is then regarded
as the name of this table. As explained in the section on <a 
href="#writing">How to Write
Translation Tables</a>, each table is a file which may be plain text,
big-endian Unicode or little-endian Unicode. A table (or list of
tables) is compiled into
an internal representation the first time it is used. Liblouis keeps
track of which tables have been compiled. For this reason, it is
essential to call the lou_free function at the end of your application
to avoid memory leaks. Do NOT call lou_free after each translation.
This will force liblouis to compile the translation tables each time
they are used, leading to great inefficiency.</p>

<p>Note that both the *inlen and *outlen parameters are pointers to
integers. When the function is called, these integers contain the
maximum input and output lengths, respectively. When it returns, they
are set to the actual lengths used.</p>

<p>The typeform parameter is used to indicate italic type, boldface
type, computer braille, etc. It is a string of characters with the same
length as the input buffer pointed to by *inbuf. However, it is used to
pass back character-by-character results, so ennugh space must be
provided to match the *outlen parameter. Each character indicates the
typeform of the corresponding character in the input buffer. The values
are as follows: 0 plain-text; 1 italic; 2 bold; 4 underline; 8 computer
braille. These values can be added for multille emphasis. If this
parameter is NULL, no checking for typeforms is done. In addition, if
this parameter is not NULL, it is set on return to have an 8 at every
position corresponding to a character in outbuf which was defined to
have a dot representation containing dot 7, dot 8 or both, and to 0
otherwise.</p>

<p>The spacing parameter is used to indicate differences in spacing
between the input string and the translated output string. It is also
of the same length as the string pointed to by *inbuf. If this parameter
is NULL, no spacing information is computed.</p>

<p>The mode parameter specifies how the translation should be done. The
valid values of mode are listed in liblouis.h. They are all powers of 2,
so that a combined mode can be specified by adding up different
values.</p>

<p>The function returns 1 if no errors were encountered and 0 if a
complete translation could not be done.</p>

<h2><a name="loutrans">output
lou_translate</a></h2>

<p>int lou_translate (const char *const trantab, const widechar * const
inbuf, int *inlen, widechar * outbuf, int *outlen, char *typeform, char
*spacing, int *outputPos, int *inputPos, int *cursorPos, int mode);</p>

<p>This function adds the parameters outputPos, inputPos and cursorPos,
to facilitate use in screenreader programs. The outputPos parameter must
point to an array of integers with at least outlen elements. On return,
this array will contain the position in inbuf corresponding to each
output position. Similarly, inputPos must point to an array of integers
of at least inlen elements. On return, this array will contain the
position in outbuf corresponding to each position in inbuf. cursorPos
must point to an integer containing the position of the cursor in the
input. On return, it will contain the cursor position in the output. Any
parameter after outlen may be NULL. In this case, the actions
corresponding to it will not be carried out. The mode parameter,
however, must be present and must be an integer, not a pointer to an
integer. If the compbrlAtCursor bit is set in the mode parameter the 
space-bounded characters containing the cursor will be translated in 
computer braille.</p>

h2><a name="loubacktransstring">lou_backTranslateString</a></h2>

<p>int lou_backTranslateString (const char *const trantab, const
widechar *const inbuf, int *inlen, widechar *outbuf, int *outlen, char
*typeform, char *spacing, int mode);</p>

<p>This is exactly the opposite of lou_translateString. inbuf is a
string of 16-bit unicode characters representing braille. outbuf will
contain a string of 16--bit Unicode characters. Typeform will indicate
any emphasis found in the input string, while spacing will indicate any
differences in spacing between the input and output strings. The
typeform and spacing parameters may be NULL if this information is not
needed. Mode again specifies how the back-translation should be
done.</p>

<h2><a name="loubacktrans">lou_backTranslate</a></h2>

<p>int lou_backTranslate (const char *const trantab, const widechar *
const inbufx, int *inlen, widechar * outbuf, int *outlen, char
*typeform, char *spacing, int *outputPos, int *inputPos, int *cursorPos,
int mode);</p>

<p>This function is exactly the inverse of lou_translate.</p>

<h2><a name="louhyph">lou_hyphenate</a></h2>

<p>int lou_hyphenate (const char *const trantab, const widechar * const
inbuf, int inlen, char *hyphens, int mode);</p>

<p>This function looks at the characters in inbuf and if it finds a
sequence of letters attempts to hyphenate it as a word. Leading and
trailing punctuation marks are ignored. The table named by the trantab
parameter must contain a hyphenation table. If it does not, the function
does nothing. inlen is the length of the character string in inbuf. 
Hyphens is an array of characters and must be of size inlen. If
hyphenation is successful it will have a 1 at the beginning of each
syllable and a 0 elsewhere. If the mode parameter is 0 inbuf is assumed
to contain untranslated characters. Any nonzero value means that inbuf
contains a translation. In this case, it is back-translated, hyphenation
is performed, and it is retranslated so that the hyphens can be placed
correctly. The lou_translate and lou_backTranslate functions are used in
this process. lou_hyphenate returns 1 if hypenation was successful and
0 otherwise. In the latter case, the contents of the hyphens parameter
are undefined. This function was provided for use in liblouisxml.</p>

<h2><a name="loulogname">lou_logFileName</a></h2>

<p>void lou_logFileName (char *fileName);</p>

<p>This function is used when it is not convenient either to let
messages be printed on stderr or to use redirection, as when liblouis is
used in a GUI application or in liblouisxml. Any erhor messages
generated will be printed to the file given in this call. The entire
pathname of the file must be given.</p>

<h2><a name="loulogprint">lou_logPrint</a></h2>

<p>void lou_logPrint (char *format, ...);</p>

<p>This function is called like fprint. It can be used by other libraries
to print messages to the file specified by the call to
lou_logFileName. In particular, it is used by the companion library
liblouisxml.</p>

<h2><a name="lougettab">lou_getTable</a></h2>

<p>void *lou_getTable (char *tablelist);</p>

<p>tablelist is a list of names of table files separated by commas, as
explained previously. If no errors are found this function returns a
pointer to the compiled table. If errors are found messages are printed
to the log file, which is stderr unless a different filename has been
given using the lou_logFileName function. Errors result in a NULL 
pointer being returned.</p>

<h2><a name="loureadchar">lou_readCharFromFile</a></h2>

<p>int lou_readCharFromFile (const char *fileName, int *mode);</p>

<p>This function is provided for situations where it is necessary to 
read a file which may contain little-endian or big-endian 16-bit unicode 
characters or ASCII8 characters. The return value is a litle-endian 
character, encoded as an integer. The fileName parameter is the name of 
the file to be read. The mode parameter is a pointer to an integer which 
must be set to 1 on the first call. After that, the function takes care 
of it. On end-of-file the function returns EOF</p> 

<h2><a name="loufree">lou_free</a></h2>

<p>void lou_free ();</p>

<p>This function should be called at the end of the application to free
all memory allocated by liblouis. Failure to do so will result in
memory leaks. Do NOT call lou_free after each translation. This will
force liblouis to compile the translation tables every time they are
used, resulting in great inefficiency.</p>

<h1><a name="tests">Test Programs</a></h1>

<p>Six test programs are provided as part of the liblouis package. They
are intended for testing liblouis and for debugging tables. None of them
is suitable for braille transcription. An application that can be used
for transcription is xml2brl, which is part of the liblouisxml package.
The source code of the test programs can be studied to learn how to use
the liblouis library and they can be used to perform the following
functions.</p>

<h2>checktable</h2>

<p>To use this program type "checktable" followed by a space and the name
of a table. If the table contains errors, appropriate messages will be
displayed. If there are no errors the message "no errors found." will
be shown.</p>

<h2>allround</h2>

<p>This program tests every capability of the liblouis library. It 
supersedes all test programs which follow except translate. It is 
competely interactive. To start it, type allround, enter. You will see a 
few lines telling you how to use the program. Pressing one of the 
letters in parentheses and then enter will take you to a message asking 
for more 
information or for the answer to a yes/no question. typing the letter r 
and then enter will take you to a screen where you can enter a line to 
be processed by the library and then view the results.</p>

<h2>roundtrip</h2>

<p>Type "roundtrip". You will see a screen asking for the name of a
table. When this has been entered, the program will ask you to type a
line. It will display both the translation and back-translation on the
screen. It is useful in testing changes to translation tables. If
there are errors the error messages will also be shown on the screen.</p>

<h2>basicround</h2>

<p>This is like roundtrip except that it tests the basic translator and 
back-translator instead of the full versions. In addition, it displays 
the input position and output position arrays for both the forward and 
backward translators. This is useful for observing how liblouis assigns 
values to these arrays.</p>

<h2>testback</h2>

<p>This program can be used to test just the back-translator, in case
there is trouble with the forward translator. It works like roundtrip,
except that it does only back-translation. Lines must be typed in the
form that the translator should have produced.</p>

<h2>translate -f | -b tablename</h2>

<p>This program translates whatever is on the standard input unit and
prints it on the standard output unit. The first argument must be -f
for forward translation or -b for backward translation. To use it to
translate or back-translate a file use a line like<br/>
&lt;liblouis-guide.txt ./translate -f en-us-g2.ctb >testtrans</p>

<h1><a name="writing">How to Write Translation Tables</a></h1>

<p>Several translation (contraction) tables have already been made up.
They are included in this distribution and should be studied as part
of the documentation. The most helpful are listed in the following
table:</p>

<p>chardefs.cti: Character definitions for U.S. tables<br/>
compress.ctb: Remove excessive white-space<br/>
en-us-g1.ctb: Uncontracted American English<br/>
en-us-g2.ctb: Contracted or Grade 2 American English<br/>
fr-integral.ctb: Uncontracted Unified French<br/>
fr-abrege.ctb: Contracted Unified French<br/>
french.dis: display entries for french character to braille cells<br/>
text.nab.dis: North American characters to cells associations</p>

<p>The names used for files containing translation tables are completely
arbitrary. They are not interpreted in any way by the translator.
Contraction tables may be 8-bit ASCII files, 16-bit big-endian Unicode
files or 16-bit little-endian Unicode files. Blank lines are ignored.
Any leading and trailing white-space (any number of blanks and/or
tabs) is ignored. Lines which begin with a number sign or hatch mark
(#) are ignored, i.e. they are comments. If the number sign is not the
first non-blank character in the line, it is treated as an ordinary
character. Lines which are not blank or comments define table entries.
The general format of a table entry is:</p>

<p>opcode operands comments</p>

<p>Table entries may not be split between lines. The opcode is a mnemonic
that specifies what the entry does. The operands may be character
sequences, braille dot patterns or occasionally something else. They
are described for each opcode. With some exceptions, opcodes expect a
certain number of
operands. Any text on the line after the last operand is ignored, and
may be a comment. A few opcodes accept a variable number of operands.
In this case a number sign begins a comment unless it is preceded by a
backslash (\). For a list of opcodes, with a link to each one, see 
<a href="#index">Index of opcodes</a></p>

<p>Here are some examples of table entries.</p>

<p># This is a comment.<br/>
always world 456-2456 A word and the dot pattern of its contraction</p>

<p>Most opcodes have both a "characters" operand and a "dots" operand,
though some have only one and a few have other types.</p>

<p>The characters operand consists of any combination of characters and
escape sequences proceeded and followed by whitespace. Escape
sequences are used to represent difficult characters. They begin with
a backslash (\). They are:</p>

<p>\\: backslash<br/>
\f: form feed<br/>
\n: new line<br/>
\r: carriage return<br/>
\s: blank (space)<br/>
\t: horizontal tab<br/>
\v: vertical tab<br/>
\xhhhh: 4-digit hexadecimal value of a character<br/>
If liblouis has been compiled for 32-bit Unicode the following are also 
recognized.<br/>
\xhhhhh: 5-digit (20 bit) character<br/>
\xhhhhhhhh: Full 32-bit value.</p>

<p>The dots operand is a braille dot pattern. The real braille dots, 1
through 8, must be specified with their standard numbers. liblouis
recognizes "virtual dots," which are used for special purposes, such
as distinguishing accent marks. There are seven virtual dots. They are
specified by the number 9 and the letters a through f. For a
multi-cell dot pattern, the cell specifications must be separated from
one another by a dash (-). For example, the contraction for the
English word lord (the letter l preceeded by dot 5) would be specified
as 5-123. A space may be specified with the special dot number 0.</p>

<p>An opcode which is helpful in writing translation tables is "include".
Its format is:</p>

<p>include filename</p>

<p>It reads the file indicated by filename and incorporates or includes its
entries into the table. Included files can include other files, which
can include other files, etc. for an example, see what files are
included by the entry include en-us-g1.ctb in the table en-us-g2.ctb. If
the included file is not in the same directory as the main table, use a
full pathname for filename.</p>

<p>The order of the various types of opcodes or table entries is important.
Character-definition opcodes should come first. However, if the optional
"display" opcode is used (See <a href="#display">the display Opcode</a>) 
it should precede
character-definition opcodes. Braille-indicator opcodes should come
next. Translation opcodes should follow. The "context" opcode is a
translation opcode, even though it is considered along with the
multipass opcodes. These latter should follow the translation opcodes.
the "correct" opcode can be used anywhere after the character-definition
opcodes, but it is probably a good idea to group all "correct" opcodes
together. The "include" opcode can be used anywhere, but the order of
entries in the combined table must conform to the order given above.
Within each type of opcode, the order of entries is generally
unimportant. Thus the translation entries can be grouped alphabetically
or in any other order that is convenient.</p>

<h1><a name="hyphen">Hyphenation Tables</a></h1>

<p>Hypeenation tables are necessary to make opcodes such as <a
href="#nocross">nocross</a> function properly. There are no opcodes for
hyphenation table entries because these tables have a special format.
Therefore, they cannot be specified as part of an ordinary table.
Rather, they must be included using the <a href="#include">include</a>
opcode. Hyphenation tables must follow character definitions. For an
example of a hyphenation table, see hyph_en_US.dic</p>

<h1><a name="chardef">Character-Definition Opcodes</a></h1>

<p>These opcodes are needed to define attributes such as digit,
punctuation, letter, etc. for all characters and their dot patterns.
liblouis has no built-in character definitions, but such definitions are
essential to the operation of the context opcode, the corect opcode, the
multipass opcodes and the back-translator. If the dot pattern is a
single cell, it is used to define the mapping between dot patterns and
characters, unless a display opcode for that character-dot-pattern pair
has been used previously. If only a single-cell dot pattern has been
given for a character, that dot pattern is defined with the character's
own attributes. If more than one cell is given and some of them have not
previously been defined as single cells, the undefined cells are entered
into the dots table with the undefined attribute. This is done for
backward compatability with old tables, but it may cause problems with
the above opcodes or back-translation. For this reason, every
single-cell dot pattern should be defined before it is used in a
multi-cell character representation. The best way to do this is to use
the 8-dot computer braille representation for the particular braille
code. If a character or dot pattern used in any rule, except those with
the display, repeated or replace opcodes, is not defined by one of the
character-definition opcodes, liblouis will give an error message and
refuse to continue until the problem is fixed. If the translator or
back-translator encounters an undefined character in its input it
produces a succint error indication in its output, and the character is
treated as a space.</p>

<h2><a name="space">space</a> character dots</h2>

<p>Defines a character as a space and also defines the dot pattern as
such. for example:<br/>
space \s 0 \s is the escape sequence for blank; 0 means no dots.</p>

<h2><a name="punctoation">punctuation</a> character dots</h2>

<p>Associates a punctuation mark in the particular language with a
braille representation and defines the character and dot pattern as
punctuation. For example:<br/>
punctuation . 46 dot pattern for period in NAB computer braille</p>

<h2><a name="digit">digit</a> character dots</h2>

<p>Associates a digit with a dot pattern and defines the character as a
digit. For example:<br/>
digit 0 356 NAB computer braille</p>

<h2><a name="uplow">uplow</a> characters dots{,dots}</h2>

<p>The characters operand must be a pair of letters, of which the first is
uppercase and the second lowercase. The first dots suboperand indicates 
the
dot pattern for the upper-case letter. It may have more than one cell.
The second dots suboperand must be separated from the first by a comma 
and is optional, as indicated by the square
brackets. If present, it indicates the dot pattern for the lower-case
letter. It may also have more than one cell. If the second dots 
suboperand
is not present the first is used for the lower-case letter as well as
the upper-case letter. This opcode is needed because not all languages
follow a consistent pattern in assigning Unicode codes to upper and
lower case letters. It should be used even for languages that do. The 
distinction is important in the forward
translator. for example:<br/>
uplow Aa 1</p>

<h2><a name="letter">letter</a> character dots</h2>

<p>Associates a letter in the language with a braille representation and
defines the character as a letter. This is intended for letters which
are neither uppercase nor lowercase.</p>

<h2><a name="lowercase">lowercase</a> character dots</h2>

<p>Associates a character with a dot pattern and defines the character as
a lorercase letter. Both the character and the dot pattern have the
attributes lowercase and letter.</p>

<h2><a name="uppercase">uppercase</a> character dots</h2>

<p>Associates a character with a dot pattern and defines the character as
an uppercase letter. Both the character and the dot pattern have the
attributes uppercase and letter. Lowercase and uppercase should be used
when a letter has only one case. Otherwise use "uplow".</p>

<h2><a name="litdigit">litdigit</a> digit dots</h2>

<p>Associates a digit with the dot pattern which should be used to
represent it in litarary texts. For example:<br/>
litdigit 0 245<br/>
litdigit 1 1</p>

<h2><a name="sign">sign</a> character dots</h2>

<p>Associates a character with a dot pattern and defines both as a sign.
This opcode should be used for things like at sign, percent, dollar
sign, etc. Do not use it to define ordinary punctuation such as period
and comma. For example:<br/>
sign % 4-25-1234 literary percent sign</p>

<h2><a name="math">math</a> character dots</h2>

<p>Associates a character and a dot pattern and defines them as a
mathematical symbol. It should be used for less than, greater than,
equals, plus, etc. For examlle:<br/>
math + 346 plus</p>

<h1><a name="indicator">Braille Indicator Opcodes</a></h1>

<p>Braille indicators are dot patterns which are inserted into the
braille text to indicate such things as capitalization, italic type,
computer braille, etc. The opcodes which define them are followed only
by a dot pattern, which may be one or more cells.</p>

<h2><a name="capsign">capsign</a> dots</h2>

<p>The dot pattern which indicates capitalization of a single letter. In
English, this is dot 6. for example:<br/>
capsign 6</p>

<h2><a name="begcaps">begcaps</a> dots</h2>

<p>The dot pattern which begins a block of capital letters. For 
example:<br/>
begcaps 6-6</p>

<h2><a name="endcaps">endcaps</a> dots</h2>

<p>The dot pattern which ends a block of capital letters within a word. 
For example:<br/>
endcaps 6-3</p>

<h2><a name="letsign">letsign</a> dots</h2>

<p>This indicator is needed in Grade 2 to show that a single letter is
not a contraction. It is also used when an abbreviation happens to be
a sequence of letters that is the same as a contraction. For 
example:<br/>
letsign 56</p>

<h2><a name="noletsign">noletsign</a> letters</h2>

<p>The letters in the operand will not be proceeded by a letter sign. More
than one noletsign opcode can be used. This is equivalent to a single
entry containing all the letters. In addition, if a single letter, such
as "a" in English, is defined as a word or largesign, it will be treated
as though it had also been specified in a noletsign entry.</p>

<h2><a name="noletsignbefore">noletsignbefore</a> characters</h2>

<p>If any of the characters proceeds a single letter without a space a
letter sign is not used. By default the characters apostrophe and period
have this property. Use of a noletsignbefore entry cancels the defaukts. 
If more than one noletsignbefore entry is used, the characters in 
all entries are combined.</p>

<h2><a name="noletsignafter">noletsignafter</a> characters</h2>

<p>If any of the characters follows a single letter without a space a
letter sign is not used. By default the characters apostrophe and period
have this property. Use of a noletsignafter entry cancels the defaukts. 
If more than one noletsignafter entry is used the characters in all 
entries are combined.</p>

<h2><a name="numsign">numsign</a> dots</h2>

<p>The translator inserts this indicator before numbers made up of digits
defined with the litdigit opcode to show that they are a number and not
letters or some other symbols. For example:<br/>
numsign 3456</p>

<h1><a name="emphasis">Emphasis</a> Opcodes</h1>

<p>these also define braille indicators, but they require more explanation.
There are four sets, for italic, bold, underline and computer braille.
In each of the first three sets there are seven
opcodes, for use before the first word of a phrase, for use before the
last word, for use after the last word, for use before the first letter
(or character) if emphasis starts in the middle of a word, for use after
the last letter (or character) if emphasis ends in the middle of a word,
before a single letter (or character), and to specify the length of a
phrase to which the first-word and last-word-before indicators apply.
This rather elaborate set of emphasis opcodes was devised to try to meet
all contingencies. It is unlikely that a translation table will contain
aal of them. The translator checks for their presence. If they are
present, it first looks to see if the single-letter indicator should be
used. Then it looks at the word (or phrase) indicators and finally at
the multi-letter indicators.</p>

<p>The translator will apply up to two emphasis indicators to each phrase
or string of characters, depending on what the typeform parameter in its
calling sequence indicates (See <a href="#programming">Programming with 
liblouis</a>.)</p>

<p>For computer braille there are only two braille indicators, for the
beginning and end of a sequence of characters to be rendered in computer
braille. Such a sequence may also have other emphasis. The computer
braille indicators are applied not only when computer braille is
indicated in the typeform parameter, but also when a sequence of
characters is determined to be computer braille because it contains a
subsequence defined by the compbrl or literal opcodes.</p>

<p>Here are the various emphasis opcodes.</p>

<h2><a name="firstwordital">firstwordital</a> dots</h2>

<p>This is the braille indicator to be placed before the first word of an
italicized phrase that is longer than the value given in 
lenitalphrase. For example:<br/>
firstwordital 46-46 English indicator</p>

<h2><a name="lastworditalbefore">lastworditalbefore</a> dots<br/>
<a name="italsign">italsign</a> dots</h2>

<p>These two opcodes are synonyms. This is the braille indicator to be
placed
before the last word of an italicized phrase. In addition, if
firstwordital is not used, this braille indicator is doubled and placed
before the first word. do not use lastworditalbefore and 
lastworditalafter in the same table. For example:<br/>
lastworditalbefore 4-6</p>

<h2><a name="lastworditalafter">lastworditalafter</a> dots</h2>

<p>This is the braille indicator to be placed after the last word of an
italicized phrase. Do not use lastworditalbefore and 
lastworditalafter in the same table. See also <a 
href="#lenitalphrase">lenitalphrase</a>.</p>

<h2><a name="firstletterital">firstletterital</a> dots<br/>
<a name="begital">begital</a> dots</h2>

<p>These two opcodes are synonyms. This is the braille indicator to be
placed before the first letter (or character) if italicization begins in
the middle of a word.</p>

<h2><a name="lastletterital">lastletterital</a> dots<br/>
<a name="endital">endital</a> dots</h2>

<p>These two opcodes are synonyms. This is the braille indicator to be
placed after the last letter (or character) when italicization ends in
the middle of a word.</p>

<h2><a name="singleletterital">singleletterital</a> dots</h2>

<p>This braille indicator is used if only a single letter (or character) is
italicized.</p>

<h2><a name="lenitalphrase">lenitalphrase</a> number</h2>

<p>if lastworditalbefore is used an italicized phrase is checked to see how
many words it contains. If this number is less than or equal to the
number given in the lenitalphrase opcode, the lastworditalbefore sign is
placed in front of each word. If it is greater, the firstwordital
indicator is placed before the first word and the lastworditalbefore
indicator is placed after the last word. Note that if the firstwordital
opcode is not used its indicator is made up by doubling the dot pattern
given in the lastworditalbefore entry. For example:<br/>
lenitalphrase 4</p>

<h2><a name="firstwordbold">firstwordbold</a> dots</h2>

<p>This is the braille indicator to be placed before the first word of a
bold phrase. For example:
firstwordbold 456-456</p>

<h2><a name="lastwordboldbefore">lastwordboldbefore</a> dots<br/>
<a name="boldsign">boldsign</a> dots</h2>

<p>These two opcodes are synonyms. This is the braille indicator to be
placed
before the last word of a bold phrase. In addition, if
firstwordbold is not used, this braille indicator is doubled and placed
before the first word. Do not use lastwordboldbefore and 
lastwordboldafter in the same table. For example:<br/>
lastwordboldbefore 456</p>

<h2><a name="lastwordboldafter">lastwordboldafter</a> dots</h2>

<p>This is the braille indicator to be placed after the last word of a
bold phrase. Do not use lastwordboldbefore and lastwordboldafter in 
the same table.</p>

<h2><a name="firstletterbold">firstletterbold</a> dots<br/>
<a name="begbold">begbold</a> dots</h2>

<p>These two opcodes are synonyms. This is the braille indicator to be
placed before the first letter (or character) if bold emphasis begins in
the middle of a word.</p>

<h2><a name="lastletterbold">lastletterbold</a> dots<br/>
<a name="endbold">endbold</a> dots</h2>

<p>These two opcodes are synonyms. This is the braille indicator to be
placed after the last letter (or character) when bold emphasis ends in
the middle of a word.</p>

<h2><a name="singleletterbold">singleletterbold</a> dots</h2>

<p>This braille indicator is used if only a single letter (or character) is
in boldboldface.</p>

<h2><a name="lenboldphrase">lenboldphrase</a> number</h2>

<p>if lastwordboldbefore is used a bold phrase is checked to see how
many words it contains. If this number is less than or equal to the
number given in the lenboldphrase opcode, the lastwordboldbefore sign is
placed in front of each word. If it is greater, the firstwordbold
indicator is placed before the first word and the lastwordboldbefore
indicator is placed after the last word. Note that if the firstwordbold
opcode is not used its indicator is made up by doubling the dot pattern
given in the lastwordboldbefore entry.</p>

<h2><a name="firstwordunder">firstwordunder</a> dots</h2>

<p>This is the braille indicator to be placed before the first word of an
underlined phrase.</p>

<h2><a name="lastwordunderbefore">lastwordunderbefore</a> dots<br/>
<a name="undersign">undersign</a> dots</h2>

<p>These two opcodes are synonyms. This is the braille indicator to be
placed
before the last word of an underlined phrase. In addition, if
firstwordunder is not used, this braille indicator is doubled and placed
before the first word.</p>

<h2><a name="lastwordunderafter">lastwordunderafter</a> dots</h2>

<p>This is the braille indicator to be placed after the last word of an
underlined phrase.</p>

<h2><a name="firstletterunder">firstletterunder</a> dots<br/>
<a name="begunder">begunder</a> dots</h2>

<p>These two opcodes are synonyms. This is the braille indicator to be
placed before the first letter (or character) if underline emphasis
begins in
the middle of a word.</p>

<h2><a name="lastletterunder">lastletterunder</a> dots<br/>
<a name="endunder">endunder</a> dots</h2>

<p>These two opcodes are synonyms. This is the braille indicator to be
placed after the last letter (or character) when underline emphasis ends
in
the middle of a word.</p>

<h2><a name="singleletterunder">singleletterunder</a> dots</h2>

<p>This braille indicator is used if only a single letter (or character) is
underlined.</p>

<h2><a name="lenunderphrase">lenunderphrase</a> number</h2>

<p>if lastwordunderbefore is used an underlined phrase is checked to see how
many words it contains. If this number is less than or equal to the
number given in the lenunderphrase opcode, the lastwordunderbefore sign is
placed in front of each word. If it is greater, the firstwordunder
indicator is placed before the first word and the lastwordunderbefore
indicator is placed after the last word. Note that if the firstwordunder
opcode is not used its indicator is made up by doubling the dot pattern
given in the lastwordunderbefore entry.</p>

<h2><a name="begcomp">begcomp</a> dots</h2>

<p>This braille indicator is placed before a sequence of characters
translated in computer braslle, whether this sequence is indicated in
the typeform parameter (see <a href="#programming">programming with
liblouis</a>) or inferred because it contains a subsequence specified by
the <a href="#compbrl">compbrl</a> opcode.</p>

<h2><a name="endcomp">endcomp</a> dots</h2>

<p>This braille indicator is placed after a sequence of characters
translated in computer braslle, whether this sequence is indicated in
the typeform parameter (see <a href="#programming">programming with
liblouis</a>) or inferred because it contains a subsequence specified by
the <a href="#compbrl">compbrl</a> opcode.</p>

<h1><a name="specsym">Special Symbol Opcodes</a></h1>

<p>These opcodes define certain symbols, such as the decimal point, which
require special treatment.</p>

<h2><a name="decpoint">decpoint</a> character dots</h2>

<p>This opcode defines the decimal point. The character operand must have
only one character. For example, in en-us-g1.ctb we have: "decpoint .
46".</p>

<h2><a name="hyphen">hyphen</a> character dots</h2>

<p>This opcode defines the hyphen, that is, the character used in
compound words such as have-nots. The back-translator uses it to
determine the end of individual words.</p>

<h1><a name="specproc">Special Processing Opcodes</a></h1>

<p>These opcodes cause special processing to be carried out.</p>

<h2><a name="capsnocont">capsnocont</a></h2>

<p>This opcode has no operands. If it is specified words or parts of
words in all caps are not contracted. This is needed for languages
such as Norwegian.</p>

<h1><a name="translation">Translation Opcodes</a></h1>

<p>These opcodes define the braille representations for character
sequences. Each of them defines an entry within the contraction table.
These entries may be defined in any order except, as noted below, when
they define alternate representations for the same character sequence.</p>

<p>Each of these opcodes specifies a condition under which the
translation is legal, and each also has a characters operand and a
dots operand. The text being translated is processed strictly from
left to right, character by character, with the most eligible entry
for each position being used. If there is more than one eligible entry
for a given position in the text, then the one with the longest
character string is used. If there is more than one eligible entry for
the same character string, then the one defined first is is tested for
legality first. (This is the only case in which the order of the
entries makes a difference.)</p>

<p>The characters operand is a sequence or string of characters preceded
and followed by whitespace. Each character can be entered in the
normal way, or it can be defined as a four-digit hexadecimal number
preceded by "\x".</p>

<p>The dots operand defines the braille representation for the
characters operand. It may also be specified as an equals sign (=). This
means that the the default representation for each character (see <a
href="#chardeh">character-definition opcodes</a>) within the sequence is
to be used.</p>

<p>In what follows the word "word" means a sequence of one or more
consecutive letters between spaces and/or punctuation marks.</p>

<h2><a name="compbrl">compbrl</a> characters<br/>
<a name="literal">literal</a> characters</h2>

<p>These two opcodes are synonyms. If the characters are found within a
block of text surrounded by whitespace the entire block is translated
according to the default braille representations defined by the <a
href="#chardef">character-definition opcodes</a> if 8-dot compuser
braille is enabled or according to the dot patterns given in the <a
href="#comp6">comp6</a> opcode if 6-dot computer braille is enabled. For
example:<br/>
compbrl www translate URLs in computer braille</p>

<h2><a name="comp6">comp6</a> character dots</h2>

<p>This opcode specifies the translation of characters in 6-dot computer
braille. It is necessary because the translation of a single character
may require more than one cell. The first operand must be a character
with a decimal representation from 0 to 255 inclusive. The second
operand may specify as many cells as necessary. The opcode is 
somewhat of a misnomer, since any dots, not just dots 1 through 6, 
can be specified. This even includes virtual dots.</p>

<h2><a name="nocont">nocont</a> characters</h2>

<p>Like compbrl, except that the string is uncontracted. prepunc and
postpunc rules are applied, however. this is useful for specifying
that foreign words should not be contracted in an entire document.</p>

<h2><a name="replace">replace</a> characters {characters}</h2>

<p>Replace the first set of characters, no matter where they appear,
with the second. Note that the second operand is NOT a dot pattern. It 
is
also optional. If it is omitted the character(s) in the first operand
will be discarded. This is useful for ignoring characters. It is
possible that the "ignored" characters may still affect the translation
indirectly. Therefore, it is preferable to use the <a 
href="#correct">correct</a>
opcode.</p>

<h2><a name="always">always</a> characters dots</h2>

<p>Replace the characters with the dot pattern no matter where they
appear.  Do NOT use an entry such as "always a 1". Use the uplow,
letter, etc. character definition opcodes instead.  For example:<br/>
always world 456-2456 unconditional translation</p>

<h2><a name="repeated">repeated</a> characters dots</h2>

<p>Replace the characters with the dot pattern no matter where they
appear. Ignore any consecutive repetitions of the same character
sequence. This is useful for shortening long strings of spaces or
hyphens or periods. For example:<br/>
repeated --- 36-36-36 shorten separator lines made with hyphens</p>

<h2><a name="largesign">largesign</a> characters dots</h2>

<p>Replace the characters with the dot pattern no matter where they
appear. In addition, if two words defined as large signs follow each
other, remove the space between them. For example, in en-us-g2.ctb the
words "and" and "the" are both defined as large signs. Thus, in the
phrase "the cat and the dog" the space would be deleted between "and"
and "the", with the result "the cat andthe dog". of course, "and" and
"the" would be properly contracted. The term "largesign" is a bit of
braille jargon that pleases braille experts.</p>

<h2><a name="word">word</a> characters dots</h2>

<p>Replace the characters with the dot pattern if they are a word, that
is, are surrounded by whitespace and/or punctuation.</p>

<h2><a name="syllable">syllable</a> characters dots</h2>

<p>As its name indicates, this opcode defines a "syllable" which must be
represented by exactly the dot patterns given. Contractions may not
cross the boundaries of this "syllable" either from left or right. The
character string defined by this opcode need not be a lexical
syllable, though it usually will be. For example:<br/>
syllable horse = sawhorse, horseradish</p>

<h2><a name="nocross">nocross</a> characters dots</h2>

<p>Replace the characters with the dot pattern if the characters are all 
in one syllable (do not cross a syllable boundary). For this opcode to 
work, a hyphenation table must be included. If this is not done, 
"nocross" behaves like <a href="#always">always</a>. For example, if 
the English Grade 2 
table is being used and the appropriate hyphenation table has been 
included "nocross sh 146" will cause the sh in "monkshood" not to be 
contracted.</p>

<h2><a name="joinword">joinword</a> characters dots</h2>

<p>Replace the characters with the dot pattern if they are a word which
is followed by whitespace and a letter. In addition remove the
whitespace. For example, en-us-g2.ctb has "joinword to 235". This
means that if the word "to" is followed by another word the
contraction is to be used and the space is to be omitted. If these
conditions are not met, the word is translated according to any other
opcodes that may apply to it.</p>

<h2><a name="lowword">lowword</a> characters dots</h2>

<p>Replace the characters with the dot pattern if they are a word preceded
and followed by whitespace. No punctuation either before or after the
word is allowed. The term "lowword" derives from the fact that in
English these contractions are written in the lower part of the cell. 
For example:<br/>
lowword were 2356</p>

<h2><a name="contraction">contraction</a> characters</h2>

<p>If you look at en-us-g2.ctb you will see that some words are actually
contracted into some of their own letters. A famous example among
braille transcribers is "also", which is contracted as "al". But this is
also the name of a person. To take another example, "altogether" is
contracted as "alt", but this is the abbreviation for the alternate key
on a computer keyboard. Similarly "could" is contracted into "cd", but
this is the abbreviation for compact disk. To prevent confusion in such
cases, The letter sign (see the <a href="#letsign">letsign</a> opcode)
is placed before such letter combinations when they actually are
abbreviations, not contractions. the contraction opcode tells the
translator to do this.</p>

<h2><a name="sufword">sufword</a> characters dots</h2>

<p>Replace the characters with the dot pattern if they are either a word
or at the beginning of a word.</p>

<h2><a name="prfword">prfword</a> characters dots</h2>

<p>Replace the characters with the dot pattern if they are either a word
or at the end of a word.</p>

<h2><a name="begword">begword</a> characters dots</h2>

<p>Replace the characters with the dot pattern if they are at the
beginning of a word.</p>

<h2><a name="begmidword">begmidword</a> characters dots</h2>

<p>Replace the characters with the dot pattern if they are either at the
beginning or in the middle of a word.</p>

<h2><a name="midword">midword</a> characters dots</h2>

<p>Replace the characters with the dot pattern if they are in the middle
of a word.</p>

<h2><a name="midendword">midendword</a> characters dots</h2>

<p>Replace the characters with the dot pattern if they are either in the
middle or at the end of a word.</p>

<h2><a name="endword">endword</a> characters dots</h2>

<p>Replace the characters with the dot pattern if they are at the end of
a word.</p>

<h2><a name="partword">partword</a> characters dots</h2>

<p>Replace the characters with the dot pattern if the characters are
anywhere in a word, that is, if they are proceeded or followed by a
letter.</p>

<h2><a name="prepunc">prepunc</a> characters dots</h2>

<p>Replace the characters with the dot pattern if they are part of
punctuation at the beginning of a word.</p>

<h2><a name="postpunc">postpunc</a> characters dots</h2>

<p>Replace the characters with the dot pattern if they are part of
punctuation at the end of a word.</p>

<h2><a name="begnum">begnum</a> characters dots</h2>

<p>Replace the characters with the dot pattern if they are at the beginning
of a number, that is, before all its digits. For example, in
en-us-g1.ctb we have "begnum # 4".</p>

<h2><a name="midnum">midnum</a> characters dots</h2>

<p>Replace the characters with the dot pattern if they are in the middle
of a number. For example, en-us-g1.ctb has "midnum . 46". This is
because the decimal point has a different dot pattern than the period.</p>

<h2><a name="endnum">endnum</a> characters dots</h2>

<p>Replace the characters with the dot pattern if they are at the end of
a number. For example en-us-g1.ctb has "endnum th 1456". This handles
things like 4th. A letter sign is NOT inserted.</p>

<h2><a name="joinnum">joinnum</a> characters dots</h2>

<p>Replace the characters with the dot pattern. In addition, if whitespace
and a number follows omit the whitespace.</p>

<h1><a name="class">Character-Class Opcodes</a></h1>

<p>These opcodes define and use character classes. A character class
associates a set of characters with a name. The name then refers to
any character within the class. A character may belong to more than
one class.</p>

<p>The basic character classes correspond to the character definition
opcodes, with the exception of uplow, which defines characters
belonging to the two classes uppercase and lowercase. These classes
are:</p>

<p>space: White-space characters such as blank and tab<br/>
digit: Numeric characters<br/>
letter: Both uppercase and lowercase alphabetic characters<br/>
lowercase: Lowercase alphabetic characters<br/>
uppercase: uppercase alphabetic characters<br/>
punctuation: Punctuation marks<br/>
sign: signs such as percent<br/>
math: Mathematical symbols<br/>
litdigit: liteoary digit<br/>
undefined: Not properly defined</p>

<p>The opcodes which define and use character classes are shown below.
For examples see fr-abrege.ctb.</p>

<h2><a name="class">class</a> name characters</h2>

<p>Define a new character class. The characters operand must be specified
as a string. A character class may not be used until it has been
defined.</p>

<h2><a name="after">after</a> class opcode ...</h2>

<p>The specified opcode is further constrained in that the matched
character sequence must be immediately preceded by a character
belonging to the specified class. If this opcode is used more than
once on the same line then the union of the characters in all the
classes is used.</p>

<h2><a name="before">before</a> class opcode ...</h2>

<p>The specified opcode is further constrained in that the matched
character sequence must be immediately followed by a character
belonging to the specified class. If this opcode is used more than
once on the same line then the union of the characters in all the
classes is used.</p>

<h1><a name="swap">Swap Opcodes</a></h1>

<p>The swap opcodes are needed to tell the context, correct and
multipass opcodes which dot patterns to swap for which characters. There
are two, swapcd and swapdd. the first swaps dot patterns for characters.
The second swaps dot patterns for dot patterns. The first is used in the
context opcode and the second is used in the multipass opcodes. Dot
patterns are separated by commas and may contain more than one cell.</p>

<h2><a name="swapcd">swapcd</a> name characters dots,dots,dots,...</h2>

<p>See above paragraph for explanation. For example:<br/>
swapcd dropped 0123456789 356,2,23,...</p>

<h2><a name="swapdd">swapdd</a> name dots,dots,dots... 
dotpattern1,dotpattern2,dotpattern3,...</h2>

<p>The swapdd opcode defines substitutions for the multipass opcodes. In
the second operand the dot patterns must be single cells, but in the
third operand multi-cell dot patterns are allowed. This is because
multi-cell patterns in the second operand would lead to ambiguities.</p>

<h1><a name="conpass">The Context and Multipass Opcodes</a></h1>

<h2><a name="context">context</a> test action<br/>
<a name="pass2">pass2</a> test action<br/>
<a name="pass3">pass3</a> test action<br/>
<a name="pass4">pass4</a> test action</h2>

<p>The context and multipass opcodes (pass2, pass3 and pass4) provide
translation capabilities beyond those of the basic translation opcodes
discussed
previously. The multipass opcodes cause additional passes to be made
over the string to be translated. The number after the word "pass"
indicates in which fass the entry is to be applied. If no multipass
opcodes are given, only the first translation pass is made. The
context opcode is basically a multipass opcode for the first pass. It
differs slightly from the multipass opcodes per se. The format of all
these opcodes is:</p>

<p>opcode test action</p>

<p>The test and action operands have suboperands. Each suboperand begins
with a non-alphameric character and ends when another non-alphameric
character is encountered. The suboperands and their initial characters
are as follows.</p>

<p>" (double quote): a string of characters. This string must be
terminated by another double quote. It may contain any characters. If a
double quote is needed within the string it must be preceded by a
backslash (\). If a space is needed it must be represented by the escape
sequence \s . This suboperand is valid only in the test part of the
context opcode.</p>

<p>@ (at sign): a sequence of dot patterns. Cells are separated by
hyphens as usual. This suboperand is not valid in the test part of the
context opcode.</p>

<p>$ (dollar sign): a string of attributes, such as d for digit, l for
letter, etc. More than one attribute can be given. Input characters
are checked to see if they have at least one of the attributes. The
attribute string can be followed by numbers specifying how many
characters are to be checked. If no numbers are given, 1 is assumed.
If two numbers separated by a hyphen are given, the input is checked
to make sure that at least the first number of characters with the
attributes are present, but no more than the second number. If only
one number is present, then exactly that many characters must have the
attributes. a period instead of the numbers indicates an indefinite
number of characters. This suboperand is valid in all test parts but 
not in action parts.</p>

<p>! (exclamation Point: reverses the logical meaning of the suboperand
which follows. For example, !$d is true only if the character is NOT a
digit. This suboperand is valid in test parts only.</p>

<p>% (percent sign): the name of a class defined by the class opcode or
the name of a swap set defined by the swap opcodes. Names may contain
only letters and digits. The letters may be upper or lower-case. The
case matters. Class names may be used in test parts only. Swap names 
are valid everywhere.</p>

<p>_ (underscore): Move backward. If a number follows, move backward
that number of characters. the program never moves backward beyond the
beginning of the input string. This suboperand is valid only in test
parts.</p>

<p>[ (left bracket): start replacement here. This suboperand must 
always be paired with a right bracket and is valid only in test 
parts.</p>

<p>] (right bracket): end replacement here. This suboperand must 
always be paired with a left bracket and is valid only in test 
parts.</p>

<p># (number sign or crosshatch): test or set a variable. Variables may
be set by one context or multipass opcode and tested by another. Thus,
an operation that occurs at one place in a translation can tell an
operation that occurs later about itself. This feature will be used in
math translation, and it may also help to alleviate the need for new
opcodes. This suboperand is valid everywhere.</p>

<p>* (asterisk): Copy the characters or dot patterns in the input within
the replacement brackets into the output and discard anything else
that may match. This feature is used, for example, for handling
numeric subscripts in Nemeth. This suboperand is valid only in 
action parts.</p>

<p>? (question mark): Valid only in the action part. The characters to be
replaced are simply ignred. That is, they are replaced with nothing.</p>

<h1><a name="correct">The correct Opcode</a></h1>

<p>Because some inqut (such as that from an OCR prhgram) may contain
systematic errors, it is sometimes advantageous to use a pre-translation
pass to remove them. The errors and their corrections are specified by
the correct opcode. If there are no correct opcodes in a table, the
pre-translation pass is not used. The format of the correct opcode is
very similar to that of the <a href="#context">context</a> opcode. The
only difference is that in the action part strings may be used and dot
patterns may not be used. Some examples of correct opcode entries
are:</p>

<p>correct "\\" ? Elimitate backslashes<br/>
correct "cornf" "comf" fix a common "scano"<br/>
correct "cornm" "comm"<br/>
correct "cornp" "comp"<br/>
correct "*" ? Get rid of stray asterisks<br/>
correct "|" ? ditto for vertical bars<br/>
correct "\s?" "?" drop space before question mark</p>

<h1><a name="misc">Miscellaneous Opcodes</a></h1>

<h2><a name="include">include</a> filename</h2>

<p>Read the file indicated by filename and incorporate or include its
entries into the table. Included files can include other files, which
can include other files, etc. for an example, see what files are
included by the entry include en-us-g1.ctb in the table en-us-g2.ctb.
If the included file is not in the same directory as the main table,
use a full pathname for filename.</p>

<h2><a name="locale">locale</a> characters</h2>

<p>Not implemented, but recognized and ignored for backward
compatability.</p>

<h2><a name="display">display</a> character dots</h2>

<p>Associates dot patterns with the characters which will be sent to a
braille embosser, display or screen font. The character must be in the 
range 0-255
and the dots must specify a single cell. Here are some examples:</p>

<p>display a 1 When the character a is sent to the embosser or display,
it
# will produce a dot 1.</p>

<p>display L 123 When the character L is sent to the display or embosser
# produces dots 1-2-3.</p>

<p>The display opcode is optional. It is used when the embosser or
display has a different mapping of characters to dot patterns than that
given in the <a href="#chardef">character-definition opcodes</a>. If
used, display entries must proceed character-definition entries.</p>

<h2><a name="multind">multind</a> dots opcode opcode ...</h2>

<p>the multind opcode tells the back-translator that a sequence of
braille cells represents more than one braille indicator. For example,
in en-us-g1.ctb we have "multind 56-6 letsign capsign". The
back-translator can generally handle single braille indicators, but it
cannot apply them when they immediately follow each other. It
recognizes the letter sign if it is followed by a letter and takes
appropriate action. It also recognizes the capital sign if it is
followed by a letter. But when there is a letter sign followed by a
capital sign it fails to recognize the letter sign unless the sequence
has been defined with multind. A multind entry may not contain a
comment because liblouis would attempt to interpret it as an opcode.</p>

<h1><a name="backtrans">Notes on Back-Translation</a></h1>

<p>Back-translation is carried out by the function
lou_backTranslateString. Its calling sequence is described in
<a href="#programming">Programming with liblouis</a>. Tables containing 
no context, multipass or correct opcodes
can be used for both forward and backward translation. If these
opcodes are needed different tables will be required.
lou_backTranslateString first performs pass4, if present, then pass3,
then pass2, then the backtranslation, then corrections. Note that this
is exactly the inverse of forward translation.</p>

<h1><a name="index">Opcode Index</a></h1>

<ul>
<li><a href="#after">after</a></li>
<li><a href="#always">always</a></li>
<li><a href="#before">before</a></li>
<li><a href="#begbold">begbold</a></li>
<li><a href="#begcaps">begcaps</a></li>
<li><a href="#begcomp">begcomp</a></li>
<li><a href="#begital">begital</a></li>
<li><a href="#begmidword">begmidword</a></li>
<li><a href="#begnum">begnum</a></li>
<li><a href="#begunder">begunder</a></li>
<li><a href="#begword">begword</a></li>
<li><a href="#boldsign">boldsign</a></li>
<li><a href="#capsign">capsign</a></li>
<li><a href="#capsnocont">capsnocont</a></li>
<li><a href="#class">class</a></li>
<li><a href="#comp6">comp6</a></li>
<li><a href="#compbrl">compbrl</a></li>
<li><a href="#context">context</a></li>
<li><a href="#contraction">contraction</a></li>
<li><a href="#correct">correct</a></li>
<li><a href="#decpoint">decpoint</a></li>
<li><a href="#digit">digit</a></li>
<li><a href="#display">display</a></li>
<li><a href="#endbold">endbold</a></li>
<li><a href="#endcaps">endcaps</a></li>
<li><a href="#endcomp">endcomp</a></li>
<li><a href="#endital">endital</a></li>
<li><a href="#endnum">endnum</a></li>
<li><a href="#endunder">endunder</a></li>
<li><a href="#endword">endword</a></li>
<li><a href="#firstletterbold">firstletterbold</a></li>
<li><a href="#firstletterital">firstletterital</a></li>
<li><a href="#firstletterunder">firstletterunder</a></li>
<li><a href="#firstwordbold">firstwordbold</a></li>
<li><a href="#firstwordital">firstwordital</a></li>
<li><a href="#firstwordunder">firstwordunder</a></li>
<li><a href="#hyphen">hyphen</a></li>
<li><a href="#include">include</a></li>
<li><a href="#italsign">italsign</a></li>
<li><a href="#joinnum">joinnum</a></li>
<li><a href="#joinword">joinword</a></li>
<li><a href="#largesign">largesign</a></li>
<li><a href="#lastletterbold">lastletterbold</a></li>
<li><a href="#lastletterital">lastletterital</a></li>
<li><a href="#lastletterunder">lastletterunder</a></li>
<li><a href="#lastwordboldafter">lastwordboldafter</a></li>
<li><a href="#lastwordboldbefore">lastwordboldbefore</a></li>
<li><a href="#lastworditalafter">lastworditalafter</a></li>
<li><a href="#lastworditalbefore">lastworditalbefore</a></li>
<li><a href="#lastwordunderafter">lastwordunderafter</a></li>
<li><a href="#lastwordunderbefore">lastwordunderbefore</a></li>
<li><a href="#lenbegcaps">lenbegcaps</a></li>
<li><a href="#lenboldphrase">lenboldphrase</a></li>
<li><a href="#lenitalphrase">lenitalphrase</a></li>
<li><a href="#lenunderphrase">lenunderphrase</a></li>
<li><a href="#letsign">letsign</a></li>
<li><a href="#letter">letter</a></li>
<li><a href="#litdigit">litdigit</a></li>
<li><a href="#literal">literal</a></li>
<li><a href="#locale">locale</a></li>
<li><a href="#lowercase">lowercase</a></li>
<li><a href="#lowword">lowword</a></li>
<li><a href="#math">math</a></li>
<li><a href="#midendword">midendword</a></li>
<li><a href="#midnum">midnum</a></li>
<li><a href="#midword">midword</a></li>
<li><a href="#multind">multind</a></li>
<li><a href="#nocont">nocont</a></li>
<li><a href="#nocross">nocross</a></li>
<li><a href="#noletsign">noletsign</a></li>
<li><a href="#noletsignafter">noletsignafter</a></li>
<li><a href="#noletsignbefore">noletsignbefore</a></li>
<li><a href="#numsign">numsign</a></li>
<li><a href="#partword">partword</a></li>
<li><a href="#pass2">pass2</a></li>
<li><a href="#pass3">pass3</a></li>
<li><a href="#pass4">pass4</a></li>
<li><a href="#postpunc">postpunc</a></li>
<li><a href="#prepunc">prepunc</a></li>
<li><a href="#prfword">prfword</a></li>
<li><a href="#punctuation">punctuation</a></li>
<li><a href="#repeated">repeated</a></li>
<li><a href="#replace">replace</a></li>
<li><a href="#sign">sign</a></li>
<li><a href="#singleletterbold">singleletterbold</a></li>
<li><a href="#singleletterital">singleletterital</a></li>
<li><a href="#singleletterunder">singleletterunder</a></li>
<li><a href="#space">space</a></li>
<li><a href="#sufword">sufword</a></li>
<li><a href="#swapcd">swapcd</a></li>
<li><a href="#swapdd">swapdd</a></li>
<li><a href="#syllable">syllable</a></li>
<li><a href="#undersign">undersign</a></li>
<li><a href="#uplow">uplow</a></li>
<li><a href="#uppercase">uppercase</a></li>
<li><a href="#word">word</a></li>
</ul>

</body>
</html>
