// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This API is used for configuring network connections (Cellular, Ethernet,
// VPN, WiFi, WiMAX, or Tether). See the Open Network Configuration
// (ONC) documentation for detailed descriptions of properties:
// components/onc/docs/onc_spec.md.

module chromeos.network_config.mojom;

// Activation state for Cellular networks.
enum ActivationStateType {
  kUnknown,
  kActivated,
  kActivating,
  kNotActivated,
  kPartiallyActivated,
};

// The authentication type for Ethernet networks.
enum AuthenticationType {
  kNone,
  k8021x,
};

// Connection state of visible networks.
enum ConnectionStateType {
  kOnline,
  kConnected,
  kPortal,
  kConnecting,
  kNotConnected,
};

// Device / Technology state for available devices.
enum DeviceStateType {
  kUninitialized,
  kDisabled,
  kEnabling,
  kEnabled,
  kProhibited,
};

// The ONC source for policy or imported networks.
enum ONCSource {
  kUnknown,
  kNone,
  kUserImport,
  kDevicePolicy,
  kUserPolicy,
};

// The network technology type. NOTE: 'All' and 'Wireless' are only used by
// FilterType for requesting groups of networks.
enum NetworkType {
  kAll,
  kCellular,
  kEthernet,
  kTether,
  kVPN,
  // Wireles includes Cellular, Tether, WiFi, and WiMAX.
  kWireless,
  kWiFi,
  kWiMAX,
};

// The security type for WiFi Ethernet networks.
enum SecurityType {
  kNone,
  kWep8021x,
  kWepPsk,
  kWpaEap,
  kWpaPsk,
};

// The configuration type for virtual networks.
enum VPNType {
  kL2TPIPsec,
  kOpenVPN,
  kThirdPartyVPN,
  kArcVPN,
};

// Filter used for requesting lists of network states.
enum FilterType {
  // Return active (Connected or Connecting) networks.
  kActive,
  // Return visible (active, physically connected or in-range) networks.
  // Active networks will be listed first.
  kVisible,
  // Only include configured (saved) networks.
  kConfigured,
  // Include all networks.
  kAll,
};

// The SIM card lock status for Cellular networks.
struct SIMLockStatus {
  // The status of SIM lock. Possible values are 'sim-pin', 'sim-puk' or empty.
  string lock_type;
  // Whether SIM lock is enabled.
  bool lock_enabled;
  // Number of PIN lock tries allowed before PUK is required to unlock the SIM.
  int32 retries_left;
};

// Additional properties for third party VPNs.
struct ThirdPartyVPNProperties {
  // ID of the third-party VPN provider extension.
  string extension_id;
  // The VPN provider name.
  string provider_name;
};

struct CellularStateProperties {
  // Enumerated ONC activation state.
  ActivationStateType activation_state;
  // ONC NetworkTechnology value.
  string network_technology;
  // True when in a roaming state and the provider is not always roaming.
  bool roaming = false;
  // True while performing a scan for cellular netowkrs.
  bool scanning = false;
  // True when a SIM is required and not present.
  bool sim_absent = false;
  // The signal strength of the cellular connection.
  int32 signal_strength;
};

struct EthernetStateProperties {
  AuthenticationType authentication;
};

struct TetherStateProperties {
  // The battery percentage of the tethered device.
  int32 battery_percentage;
  // The cellular carrier for the tethered device.
  string carrier;
  // Whether the tethered device has already been connected to.
  bool has_connected_to_host;
  // The signal strength of the tethered device's cellular connection.
  int32 signal_strength;
};

struct VPNStateProperties {
  VPNType type;
  ThirdPartyVPNProperties? third_party_vpn;
};

struct WiFiStateProperties {
  // The id of the basic service set (access point) associated with the network.
  string bssid;
  // The WiFi service operating frequency in MHz. For connected networks, the
  // current frequency, otherwise, the frequency of the best available BSS.
  int32 frequency;
  // The hex encoded SSID (name) of the network.
  string hex_ssid;
  SecurityType security;
  // The signal strength for visible networks.
  int32 signal_strength;
  // The network SSID.
  string ssid;
};

struct WiMAXStateProperties {
  int32 signal_strength;
};

struct NetworkStateProperties {
  CellularStateProperties? cellular;
  // True if the network is configured and may be connectable.
  bool connectable = false;
  // True if an explicit connect was requested. The network state may not be
  // Connecting yet.
  bool connect_requested = false;
  ConnectionStateType connection_state;
  EthernetStateProperties? ethernet;
  // A string describing the network error state. TODO(stevenjb): Use an enum.
  string? error_state;
  // The unique identifier for the network.
  string guid;
  // The human readable name of the network, e.g. WiFi SSID or network type.
  string name;
  // The relative priority of the network. Larger values have higher priority.
  int32 priority;
  ONCSource source;
  TetherStateProperties? tether;
  NetworkType type;
  VPNStateProperties? vpn;
  WiFiStateProperties? wifi;
  WiMAXStateProperties? wimax;
};

struct DeviceStateProperties {
  // Set if the device is enabled. True if the device is currently scanning.
  bool scanning = false;
  // The SIM lock status if Type = Cellular and SIMPresent = True.
  SIMLockStatus? sim_lock_status;
  // Set to the SIM present state if the device type is Cellular.
  bool sim_present = false;
  DeviceStateType state;
  NetworkType type;
  // Whether or not any managed networks are available.
  bool managed_network_available = false;
};

const int32 kNoLimit = 0;

struct NetworkFilter {
  // Which networks to return (active, visible, etc).
  FilterType filter;
  // The type of networks to return.
  NetworkType network_type;
  // Maximum number of networks to return. 0 indicates no limit.
  int32 limit = kNoLimit;
};

interface CrosNetworkConfig {
  AddObserver(CrosNetworkConfigObserver observer);

  // Gets the state properties of the network matching |guid|.
  GetNetworkState(string guid) => (NetworkStateProperties result);

  // Returns a list of Network properties matching |filter|. Networks are
  // ordered by the system based on their priority, with active networks listed
  // first.
  GetNetworkStateList(NetworkFilter filter) =>
    (array<NetworkStateProperties> result);

  // Returns a list of Device properties.
  GetDeviceStateList() => (array<DeviceStateProperties> result);
};

interface CrosNetworkConfigObserver {
  // Fired when the properties of an active network or previously active
  // network change.
  OnActiveNetworksChanged(array<NetworkStateProperties> networks);

  // Fired when the list of networks changes.
  OnNetworkStateListChanged();

  // Fired when the list of devices changes or a device property changes.
  OnDeviceStateListChanged();
};
