// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Definitions for the diagnostics API exposed by the cros_healthd daemon. This
// API is normally consumed by the browser and the diag command-line tool.

// NOTE: This mojom should be kept in sync with the copy in Chromium's repo in
// src/platform2/diagnostics/mojo/cros_healthd_diagnostics.mojom.

module chromeos.cros_healthd.mojom;

// Special id that will be returned if a routine was unable to be created.
const int32 kFailedToStartId = 0;

// Enumeration of each of the diagnostics routines the platform may support.
[Extensible]
enum DiagnosticRoutineEnum {
  kBatteryCapacity = 0,
  kBatteryHealth = 1,
  kUrandom = 2,
  kSmartctlCheck = 3,
  kAcPower = 4,
  kCpuCache = 5,
  kCpuStress = 6,
  kFloatingPointAccuracy = 7,
  kNvmeWearLevel = 8,
  kNvmeSelfTest = 9,
  kDiskRead = 10,
  kPrimeSearch = 11,
  kBatteryDischarge = 12,
};

// Enumeration of the possible DiskRead routine's command type
enum DiskReadRoutineTypeEnum {
  kLinearRead,
  kRandomRead,
};

// Enumeration of each of the possible statuses for a diagnostics routine.
[Extensible]
enum DiagnosticRoutineStatusEnum {
  kReady = 0,  // Routine is ready to start.
  kRunning = 1,  // Routine is currently running.
  kWaiting = 2,  // Routine needs user input to continue.
  kPassed = 3,  // Routine completed and passed.
  kFailed = 4,  // Routine completed and failed.
  kError = 5,  // An error prevented the routine from completing.
  kCancelled = 6,  // Routine was cancelled before completion. A cancelled
                   // routine's information can still be accessed with a
                   // GetRoutineUpdateRequest.
  kFailedToStart = 7,  // Routine could not be created.
  kRemoved = 8,  // Routine has been removed and is no longer valid.
  kCancelling = 9,  // Routine is in the process of being cancelled.
};

// Enumeration of each of the messages a diagnostics routine can pass back.
// These messages prompt interaction from the user of the routine.
[Extensible]
enum DiagnosticRoutineUserMessageEnum {
  kUnplugACPower = 0,  // The user needs to unplug the AC power cord.
  kPlugInACPower = 1,  // The user needs to plug in the AC power cord.
};

// Enumeration of the possible commands to send a diagnostics routine.
[Extensible]
enum DiagnosticRoutineCommandEnum {
  kContinue = 0,  // Resume a routine that is waiting.
  kCancel = 1,  // Cancelled routines must still be removed before the routine
                // is destroyed.
  kGetStatus = 2,  // Used to get status but not otherwise control a routine.
  kRemove = 3,  // All routines which started successfully must be removed,
                // otherwise they will persist on the system. This makes sure
                // the routine is terminated before removing it.
};

// Generic return value for a RunSomeRoutine call.
struct RunRoutineResponse {
  // Unique identifier for the newly-created routine. An id of kFailedToStartId
  // means that the routine was unable to be created. Can be used in a
  // GetRoutineUpdate call to control or get the status of the created routine.
  int32 id;
  // Current status of the newly-created routine. A status of kFailedToStart
  // means the routine was unable to be created.
  DiagnosticRoutineStatusEnum status;
};

// Status fields specific to interactive routines.
struct InteractiveRoutineUpdate {
  // Request for user action. This message should be localized and displayed to
  // the user.
  DiagnosticRoutineUserMessageEnum user_message;
};

// Status fields specific to noninteractive routines.
struct NonInteractiveRoutineUpdate {
  // Current status of the routine.
  DiagnosticRoutineStatusEnum status;
  // More detailed status - for example, if |status| was kError,
  // |status_message| would describe the error encountered, like "failed to
  // read file."
  string status_message;
};

// Responses will be either interactive or noninteractive.
union RoutineUpdateUnion {
  InteractiveRoutineUpdate interactive_update;
  NonInteractiveRoutineUpdate noninteractive_update;
};

// Response type for GetRoutineUpdate.
struct RoutineUpdate {
  // Percent complete, must be between 0 and 100, inclusive.
  uint32 progress_percent;
  // Any accumulated output, like logs, from the routine. This field is only
  // valid when GetRoutineUpdate (see cros_healthd.mojom) is called with
  // include_output = true.
  handle? output;

  // Information specific to the type of response - interactive or
  // noninteractive.
  RoutineUpdateUnion routine_update_union;
};

// Enumeration of the possible statuses for a power supply in the AC power
// routine.
[Extensible]
enum AcPowerStatusEnum {
  kConnected = 0,     // Power supply is connected.
  kDisconnected = 1,  // Power supply is disconnected.
};

// Enumeration of the self-test type in nvme_self_test routine
[Extensible]
enum NvmeSelfTestTypeEnum {
  kShortSelfTest = 0, // Short time self-test.
  kLongSelfTest = 1,  // Long time self-test.
};
