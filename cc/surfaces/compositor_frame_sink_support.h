// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CC_SURFACES_COMPOSITOR_FRAME_SINK_SUPPORT_H_
#define CC_SURFACES_COMPOSITOR_FRAME_SINK_SUPPORT_H_

#include <memory>
#include <unordered_set>
#include <vector>

#include "base/compiler_specific.h"
#include "base/memory/weak_ptr.h"
#include "cc/output/compositor_frame.h"
#include "cc/scheduler/begin_frame_source.h"
#include "cc/surfaces/frame_sink_manager_client.h"
#include "cc/surfaces/referenced_surface_tracker.h"
#include "cc/surfaces/surface_id.h"
#include "cc/surfaces/surface_resource_holder.h"
#include "cc/surfaces/surface_resource_holder_client.h"
#include "cc/surfaces/surfaces_export.h"

namespace cc {

class CompositorFrameSinkSupportClient;
class Surface;
class SurfaceManager;

class CC_SURFACES_EXPORT CompositorFrameSinkSupport
    : public BeginFrameObserver,
      public SurfaceResourceHolderClient,
      public FrameSinkManagerClient {
 public:
  static std::unique_ptr<CompositorFrameSinkSupport> Create(
      CompositorFrameSinkSupportClient* client,
      SurfaceManager* surface_manager,
      const FrameSinkId& frame_sink_id,
      bool is_root,
      bool handles_frame_sink_id_invalidation,
      bool needs_sync_points);

  ~CompositorFrameSinkSupport() override;

  const FrameSinkId& frame_sink_id() const { return frame_sink_id_; }

  Surface* current_surface_for_testing() { return current_surface_.get(); }
  SurfaceManager* surface_manager() { return surface_manager_; }
  bool needs_sync_points() { return needs_sync_points_; }

  const ReferencedSurfaceTracker& ReferenceTrackerForTesting() const {
    return reference_tracker_;
  }

  // SurfaceResourceHolderClient implementation.
  void ReturnResources(const ReturnedResourceArray& resources) override;

  // FrameSinkManagerClient implementation.
  void SetBeginFrameSource(BeginFrameSource* begin_frame_source) override;

  void EvictFrame();
  void SetNeedsBeginFrame(bool needs_begin_frame);
  void BeginFrameDidNotSwap(const BeginFrameAck& ack);
  void SubmitCompositorFrame(const LocalSurfaceId& local_surface_id,
                             CompositorFrame frame);
  void RequestCopyOfSurface(std::unique_ptr<CopyOutputRequest> request);
  void ClaimTemporaryReference(const SurfaceId& surface_id);

  // TODO(staraz): Move the following 3 methods to private.
  void ReceiveFromChild(const TransferableResourceArray& resources);
  void RefResources(const TransferableResourceArray& resources);
  void UnrefResources(const ReturnedResourceArray& resources);

  void OnSurfaceActivated(Surface* surface);

 protected:
  CompositorFrameSinkSupport(CompositorFrameSinkSupportClient* client,
                             const FrameSinkId& frame_sink_id,
                             bool is_root,
                             bool handles_frame_sink_id_invalidation,
                             bool needs_sync_points);

  void Init(SurfaceManager* surface_manager);

 private:
  // Update surface references with SurfaceManager for current CompositorFrame
  // that has |local_surface_id|. UpdateReferences() must be called on
  // |reference_tracker_| before calling this. Will add and remove top-level
  // root references if |display_| is not null.
  void UpdateSurfaceReferences(const SurfaceId& last_surface_id,
                               const LocalSurfaceId& local_surface_id);

  void AddTopLevelRootReference(const SurfaceId& surface_id);
  void RemoveTopLevelRootReference(const SurfaceId& surface_id);
  void ReferencedSurfacesChanged(
      const LocalSurfaceId& local_surface_id,
      const std::vector<SurfaceId>* active_referenced_surfaces);

  void DidReceiveCompositorFrameAck();
  void WillDrawSurface(const LocalSurfaceId& local_surface_id,
                       const gfx::Rect& damage_rect);

  // BeginFrameObserver implementation.
  void OnBeginFrame(const BeginFrameArgs& args) override;
  const BeginFrameArgs& LastUsedBeginFrameArgs() const override;
  void OnBeginFrameSourcePausedChanged(bool paused) override;

  void UpdateNeedsBeginFramesInternal();
  std::unique_ptr<Surface> CreateSurface(
      const LocalSurfaceId& local_surface_id);
  void DestroyCurrentSurface();

  CompositorFrameSinkSupportClient* const client_;

  SurfaceManager* surface_manager_ = nullptr;

  const FrameSinkId frame_sink_id_;

  SurfaceResourceHolder surface_resource_holder_;

  std::unique_ptr<Surface> current_surface_;
  // Counts the number of CompositorFrames that have been submitted and have not
  // yet received an ACK.
  int ack_pending_count_ = 0;
  ReturnedResourceArray surface_returned_resources_;

  // The begin frame source being observered. Null if none.
  BeginFrameSource* begin_frame_source_ = nullptr;

  // The last begin frame args generated by the begin frame source.
  BeginFrameArgs last_begin_frame_args_;

  // Whether a request for begin frames has been issued.
  bool needs_begin_frame_ = false;

  // Whether or not a frame observer has been added.
  bool added_frame_observer_ = false;

  // Track the surface references for the surface corresponding to this
  // compositor frame sink.
  ReferencedSurfaceTracker reference_tracker_;

  const bool is_root_;
  const bool needs_sync_points_;
  bool seen_first_frame_activation_ = false;

  // TODO(staraz): Remove this flag once ui::Compositor no longer needs to call
  // RegisterFrameSinkId().
  // A surfaceSequence's validity is bound to the lifetime of the parent
  // FrameSink that created it. We track the lifetime of FrameSinks through
  // RegisterFrameSinkId and InvalidateFrameSinkId. During startup and GPU
  // restart, a SurfaceSequence created by the top most layer compositor may be
  // used prior to the creation of the associated CompositorFrameSinkSupport.
  // CompositorFrameSinkSupport is created asynchronously when a new GPU channel
  // is established. Once we switch to SurfaceReferences, this ordering concern
  // goes away and we can remove this bool.
  const bool handles_frame_sink_id_invalidation_;

  base::WeakPtrFactory<CompositorFrameSinkSupport> weak_factory_;

  DISALLOW_COPY_AND_ASSIGN(CompositorFrameSinkSupport);
};

}  // namespace cc

#endif  // CC_SURFACES_COMPOSITOR_FRAME_SINK_SUPPORT_H_
