// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// The messages in this file comprise the DBus/Proto interface for
// the new set of Cryptohome interface after the refactor, and the
// associated messages that's used by those interfaces.
// All input parameter to a call is named with a "Request" suffix,
// and all output parameter to a call is named with a "Reply" suffix.

syntax = "proto3";

option optimize_for = LITE_RUNTIME;

package user_data_auth;

import "key.proto";

///////////////////////////////////////////////////////////////////////////////
// Messages that's used by the actual request/reply goes below
///////////////////////////////////////////////////////////////////////////////

// We still need the AccountIdentifier, KeyDelegate and AuthorizationRequest
// messages from the old interface.
import "rpc.proto";

// Error codes do not need to be sequential per-call.
// Prefixes by Request/Reply type should be used to help
// callers know if specialized errors apply.
enum CryptohomeErrorCode {
  // 0 is the default value of BaseReply::error. It
  // should never be used.
  CRYPTOHOME_ERROR_NOT_SET = 0;

  CRYPTOHOME_ERROR_ACCOUNT_NOT_FOUND = 1;
  CRYPTOHOME_ERROR_AUTHORIZATION_KEY_NOT_FOUND = 2;
  CRYPTOHOME_ERROR_AUTHORIZATION_KEY_FAILED = 3;
  CRYPTOHOME_ERROR_NOT_IMPLEMENTED = 4;
  CRYPTOHOME_ERROR_MOUNT_FATAL = 5;
  CRYPTOHOME_ERROR_MOUNT_MOUNT_POINT_BUSY = 6;
  CRYPTOHOME_ERROR_TPM_COMM_ERROR = 7;
  CRYPTOHOME_ERROR_TPM_DEFEND_LOCK = 8;
  CRYPTOHOME_ERROR_TPM_NEEDS_REBOOT = 9;
  CRYPTOHOME_ERROR_AUTHORIZATION_KEY_DENIED = 10;
  CRYPTOHOME_ERROR_KEY_QUOTA_EXCEEDED = 11;
  CRYPTOHOME_ERROR_KEY_LABEL_EXISTS = 12;
  CRYPTOHOME_ERROR_BACKING_STORE_FAILURE = 13;
  CRYPTOHOME_ERROR_UPDATE_SIGNATURE_INVALID = 14;
  CRYPTOHOME_ERROR_KEY_NOT_FOUND = 15;
  CRYPTOHOME_ERROR_LOCKBOX_SIGNATURE_INVALID = 16;
  CRYPTOHOME_ERROR_LOCKBOX_CANNOT_SIGN = 17;
  CRYPTOHOME_ERROR_BOOT_ATTRIBUTE_NOT_FOUND = 18;
  CRYPTOHOME_ERROR_BOOT_ATTRIBUTES_CANNOT_SIGN = 19;
  CRYPTOHOME_ERROR_TPM_EK_NOT_AVAILABLE = 20;
  CRYPTOHOME_ERROR_ATTESTATION_NOT_READY = 21;
  CRYPTOHOME_ERROR_CANNOT_CONNECT_TO_CA = 22;
  CRYPTOHOME_ERROR_CA_REFUSED_ENROLLMENT = 23;
  CRYPTOHOME_ERROR_CA_REFUSED_CERTIFICATE = 24;
  CRYPTOHOME_ERROR_INTERNAL_ATTESTATION_ERROR = 25;
  CRYPTOHOME_ERROR_FIRMWARE_MANAGEMENT_PARAMETERS_INVALID = 26;
  CRYPTOHOME_ERROR_FIRMWARE_MANAGEMENT_PARAMETERS_CANNOT_STORE = 27;
  CRYPTOHOME_ERROR_FIRMWARE_MANAGEMENT_PARAMETERS_CANNOT_REMOVE = 28;
  CRYPTOHOME_ERROR_MOUNT_OLD_ENCRYPTION = 29;
  CRYPTOHOME_ERROR_MOUNT_PREVIOUS_MIGRATION_INCOMPLETE = 30;
  CRYPTOHOME_ERROR_MIGRATE_KEY_FAILED = 31;
  CRYPTOHOME_ERROR_REMOVE_FAILED = 32;
}

// This is used by MountRequest to store details about the mount to create
message CreateRequest {
  // In the future, this will contain account-wide data like
  // the deletion priority or the IdP's origin.

  // keys contain the key data to add to the key for the mount that we
  // are creating. Currently, only one key is supported.
  repeated cryptohome.Key keys = 1;
  // Explicitly use the |key| from the AuthorizationRequest.
  // Setting this value means that the KeyData is filled as it
  // would be with a Key above or in an AddKeyRequest.
  bool copy_authorization_key = 2;
  // If set to true, always use eCryptfs as the encryption method.
  bool force_ecryptfs = 3;
}

///////////////////////////////////////////////////////////////////////////////
// Actual request/reply goes below
///////////////////////////////////////////////////////////////////////////////

// Input parameters to IsMounted()
message IsMountedRequest {
  // If username is available, then it'll check if a specific user's home
  // directory is mounted. Otherwise, it'll check if any home directory is
  // mounted.
  string username = 1;
}

// Output parameters for IsMounted()
message IsMountedReply {
  // If the requested home directory is mounted.
  bool is_mounted = 1;
  // If the mount is ephemeral, that is, if the contents get cleared once
  // the user logs out.
  bool is_ephemeral_mount = 2;
}

// Input parameters to Unmount()
// Currently we only support unmounting all mounted cryptohomes but in the
// future we may implement per-user unmount, at which point we can extend this
// proto with the necessary information.
message UnmountRequest {
}

// Output parameters for Unmount()
message UnmountReply {
  // Indicates an error if |error| is not empty.
  CryptohomeErrorCode error = 1;
}

// Input parameters to Mount()
message MountRequest {
  // The account of the user whose home directory is requested for mounting.
  cryptohome.AccountIdentifier account = 1;
  // Authorization data from the user.
  cryptohome.AuthorizationRequest authorization = 2;

  // If set, then perform an ephemeral mount only.
  bool require_ephemeral = 3;
  // If defined, the account will be created if it does not exist.
  // Additionally, a failed AuthorizationRequest will be expected as
  // there will be no existing keys.
  CreateRequest create = 4;
  // If set to true, and cryptohomed supports the new "dircrypto" encryption,
  // forces to use the new encryption. That is, makes it an error to mount
  // an existing home directory encrypted in the old way (ecryptfs).
  bool force_dircrypto_if_available = 5;
  // If set to true, mounts the existing ecryptfs vault to a temporary location
  // while setting up a new dircrypto directory.
  bool to_migrate_from_ecryptfs = 6;
  // If set, then performs a public mount, which is used for a Kiosk session.
  // Credentials are not needed in the request; they are synthesized by
  // cryptohomed from id.
  bool public_mount = 7;
  // If set to true, mounts the vault to a temporary location. The mount is not
  // exposed to the usual locations (/home/user, /home/root).
  bool hidden_mount = 8;
  // If set to true, the mount will be for a guest session.
  bool guest_mount = 9;
}

// Output parameters for Mount()
message MountReply {
  // Indicate an error when |error| is not empty.
  CryptohomeErrorCode error = 1;
  // |recreated| is set when the cryptohome had to be wiped
  // because the key or data was an unrecoverable.  It does not imply
  // failure to Mount nor is it 'true' when a CreateRequest creates
  // a cryptohome for the first time.
  bool recreated = 2;
  // Returns the filesystem-sanitized username.
  string sanitized_username = 3;
}
