diff --git a/base/third_party/cityhash/city.cc b/base/third_party/cityhash/city.cc
index be08dc99cf18..f0af5bbd8507 100644
--- a/base/third_party/cityhash/city.cc
+++ b/base/third_party/cityhash/city.cc
@@ -29,21 +29,21 @@
 
 #include "city.h"
 
-#include <algorithm>
 #include <string.h>  // for memcpy and memset
+#include <algorithm>
 
 namespace base {
 namespace internal {
 namespace cityhash_v111 {
 using namespace std;
 
-static uint64 UNALIGNED_LOAD64(const char *p) {
+static uint64 UNALIGNED_LOAD64(const char* p) {
   uint64 result;
   memcpy(&result, p, sizeof(result));
   return result;
 }
 
-static uint32 UNALIGNED_LOAD32(const char *p) {
+static uint32 UNALIGNED_LOAD32(const char* p) {
   uint32 result;
   memcpy(&result, p, sizeof(result));
   return result;
@@ -82,8 +82,8 @@ static uint32 UNALIGNED_LOAD32(const char *p) {
 
 #elif defined(__NetBSD__)
 
-#include <sys/types.h>
 #include <machine/bswap.h>
+#include <sys/types.h>
 #if defined(__BSWAP_RENAME) && !defined(__bswap_32)
 #define bswap_32(x) bswap32(x)
 #define bswap_64(x) bswap64(x)
@@ -116,11 +116,11 @@ static uint32 UNALIGNED_LOAD32(const char *p) {
 #endif
 #endif
 
-static uint64 Fetch64(const char *p) {
+static uint64 Fetch64(const char* p) {
   return uint64_in_expected_order(UNALIGNED_LOAD64(p));
 }
 
-static uint32 Fetch32(const char *p) {
+static uint32 Fetch32(const char* p) {
   return uint32_in_expected_order(UNALIGNED_LOAD32(p));
 }
 
@@ -134,8 +134,7 @@ static const uint32 c1 = 0xcc9e2d51;
 static const uint32 c2 = 0x1b873593;
 
 // A 32-bit to 32-bit integer hash copied from Murmur3.
-static uint32 fmix(uint32 h)
-{
+static uint32 fmix(uint32 h) {
   h ^= h >> 16;
   h *= 0x85ebca6b;
   h ^= h >> 13;
@@ -150,7 +149,11 @@ static uint32 Rotate32(uint32 val, int shift) {
 }
 
 #undef PERMUTE3
-#define PERMUTE3(a, b, c) do { std::swap(a, b); std::swap(a, c); } while (0)
+#define PERMUTE3(a, b, c) \
+  do {                    \
+    std::swap(a, b);      \
+    std::swap(a, c);      \
+  } while (0)
 
 static uint32 Mur(uint32 a, uint32 h) {
   // Helper from Murmur3 for combining two 32-bit values.
@@ -162,7 +165,7 @@ static uint32 Mur(uint32 a, uint32 h) {
   return h * 5 + 0xe6546b64;
 }
 
-static uint32 Hash32Len13to24(const char *s, size_t len) {
+static uint32 Hash32Len13to24(const char* s, size_t len) {
   uint32 a = Fetch32(s - 4 + (len >> 1));
   uint32 b = Fetch32(s + 4);
   uint32 c = Fetch32(s + len - 8);
@@ -174,7 +177,7 @@ static uint32 Hash32Len13to24(const char *s, size_t len) {
   return fmix(Mur(f, Mur(e, Mur(d, Mur(c, Mur(b, Mur(a, h)))))));
 }
 
-static uint32 Hash32Len0to4(const char *s, size_t len) {
+static uint32 Hash32Len0to4(const char* s, size_t len) {
   uint32 b = 0;
   uint32 c = 9;
   for (size_t i = 0; i < len; i++) {
@@ -185,7 +188,7 @@ static uint32 Hash32Len0to4(const char *s, size_t len) {
   return fmix(Mur(b, Mur(len, c)));
 }
 
-static uint32 Hash32Len5to12(const char *s, size_t len) {
+static uint32 Hash32Len5to12(const char* s, size_t len) {
   uint32 a = len, b = len * 5, c = 9, d = b;
   a += Fetch32(s);
   b += Fetch32(s + len - 4);
@@ -193,11 +196,11 @@ static uint32 Hash32Len5to12(const char *s, size_t len) {
   return fmix(Mur(c, Mur(b, Mur(a, d))));
 }
 
-uint32 CityHash32(const char *s, size_t len) {
+uint32 CityHash32(const char* s, size_t len) {
   if (len <= 24) {
-    return len <= 12 ?
-        (len <= 4 ? Hash32Len0to4(s, len) : Hash32Len5to12(s, len)) :
-        Hash32Len13to24(s, len);
+    return len <= 12
+               ? (len <= 4 ? Hash32Len0to4(s, len) : Hash32Len5to12(s, len))
+               : Hash32Len13to24(s, len);
   }
 
   // len > 24
@@ -287,7 +290,7 @@ static uint64 HashLen16(uint64 u, uint64 v, uint64 mul) {
   return b;
 }
 
-static uint64 HashLen0to16(const char *s, size_t len) {
+static uint64 HashLen0to16(const char* s, size_t len) {
   if (len >= 8) {
     uint64 mul = k2 + len * 2;
     uint64 a = Fetch64(s) + k2;
@@ -314,7 +317,7 @@ static uint64 HashLen0to16(const char *s, size_t len) {
 
 // This probably works well for 16-byte strings as well, but it may be overkill
 // in that case.
-static uint64 HashLen17to32(const char *s, size_t len) {
+static uint64 HashLen17to32(const char* s, size_t len) {
   uint64 mul = k2 + len * 2;
   uint64 a = Fetch64(s) * k1;
   uint64 b = Fetch64(s + 8);
@@ -326,8 +329,12 @@ static uint64 HashLen17to32(const char *s, size_t len) {
 
 // Return a 16-byte hash for 48 bytes.  Quick and dirty.
 // Callers do best to use "random-looking" values for a and b.
-static pair<uint64, uint64> WeakHashLen32WithSeeds(
-    uint64 w, uint64 x, uint64 y, uint64 z, uint64 a, uint64 b) {
+static pair<uint64, uint64> WeakHashLen32WithSeeds(uint64 w,
+                                                   uint64 x,
+                                                   uint64 y,
+                                                   uint64 z,
+                                                   uint64 a,
+                                                   uint64 b) {
   a += w;
   b = Rotate(b + a + z, 21);
   uint64 c = a;
@@ -338,18 +345,15 @@ static pair<uint64, uint64> WeakHashLen32WithSeeds(
 }
 
 // Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.
-static pair<uint64, uint64> WeakHashLen32WithSeeds(
-    const char* s, uint64 a, uint64 b) {
-  return WeakHashLen32WithSeeds(Fetch64(s),
-                                Fetch64(s + 8),
-                                Fetch64(s + 16),
-                                Fetch64(s + 24),
-                                a,
-                                b);
+static pair<uint64, uint64> WeakHashLen32WithSeeds(const char* s,
+                                                   uint64 a,
+                                                   uint64 b) {
+  return WeakHashLen32WithSeeds(Fetch64(s), Fetch64(s + 8), Fetch64(s + 16),
+                                Fetch64(s + 24), a, b);
 }
 
 // Return an 8-byte hash for 33 to 64 bytes.
-static uint64 HashLen33to64(const char *s, size_t len) {
+static uint64 HashLen33to64(const char* s, size_t len) {
   uint64 mul = k2 + len * 2;
   uint64 a = Fetch64(s) * k2;
   uint64 b = Fetch64(s + 8);
@@ -370,7 +374,7 @@ static uint64 HashLen33to64(const char *s, size_t len) {
   return b + x;
 }
 
-uint64 CityHash64(const char *s, size_t len) {
+uint64 CityHash64(const char* s, size_t len) {
   if (len <= 32) {
     if (len <= 16) {
       return HashLen0to16(s, len);
@@ -408,18 +412,20 @@ uint64 CityHash64(const char *s, size_t len) {
                    HashLen16(v.second, w.second) + x);
 }
 
-uint64 CityHash64WithSeed(const char *s, size_t len, uint64 seed) {
+uint64 CityHash64WithSeed(const char* s, size_t len, uint64 seed) {
   return CityHash64WithSeeds(s, len, k2, seed);
 }
 
-uint64 CityHash64WithSeeds(const char *s, size_t len,
-                           uint64 seed0, uint64 seed1) {
+uint64 CityHash64WithSeeds(const char* s,
+                           size_t len,
+                           uint64 seed0,
+                           uint64 seed1) {
   return HashLen16(CityHash64(s, len) - seed0, seed1);
 }
 
 // A subroutine for CityHash128().  Returns a decent 128-bit hash for strings
 // of any length representable in signed long.  Based on City and Murmur.
-static uint128 CityMurmur(const char *s, size_t len, uint128 seed) {
+static uint128 CityMurmur(const char* s, size_t len, uint128 seed) {
   uint64 a = Uint128Low64(seed);
   uint64 b = Uint128High64(seed);
   uint64 c = 0;
@@ -449,7 +455,7 @@ static uint128 CityMurmur(const char *s, size_t len, uint128 seed) {
   return uint128(a ^ b, HashLen16(b, a));
 }
 
-uint128 CityHash128WithSeed(const char *s, size_t len, uint128 seed) {
+uint128 CityHash128WithSeed(const char* s, size_t len, uint128 seed) {
   if (len < 128) {
     return CityMurmur(s, len, seed);
   }
@@ -493,7 +499,7 @@ uint128 CityHash128WithSeed(const char *s, size_t len, uint128 seed) {
   w.first *= 9;
   v.first *= k0;
   // If 0 < len < 128, hash up to 4 chunks of 32 bytes each from the end of s.
-  for (size_t tail_done = 0; tail_done < len; ) {
+  for (size_t tail_done = 0; tail_done < len;) {
     tail_done += 32;
     y = Rotate(x + y, 42) * k0 + v.second;
     w.first += Fetch64(s + len - tail_done + 16);
@@ -512,14 +518,13 @@ uint128 CityHash128WithSeed(const char *s, size_t len, uint128 seed) {
                  HashLen16(x + w.second, y + v.second));
 }
 
-uint128 CityHash128(const char *s, size_t len) {
-  return len >= 16 ?
-      CityHash128WithSeed(s + 16, len - 16,
-                          uint128(Fetch64(s), Fetch64(s + 8) + k0)) :
-      CityHash128WithSeed(s, len, uint128(k0, k1));
+uint128 CityHash128(const char* s, size_t len) {
+  return len >= 16
+             ? CityHash128WithSeed(s + 16, len - 16,
+                                   uint128(Fetch64(s), Fetch64(s + 8) + k0))
+             : CityHash128WithSeed(s, len, uint128(k0, k1));
 }
 
 }  // namespace cityhash_v111
 }  // namespace internal
 }  // namespace base
-
diff --git a/base/third_party/cityhash/city.h b/base/third_party/cityhash/city.h
index e4672f6d44da..3e3dcaaaa9a5 100644
--- a/base/third_party/cityhash/city.h
+++ b/base/third_party/cityhash/city.h
@@ -62,8 +62,8 @@
 #ifndef BASE_THIRD_PARTY_CITYHASH_CITY_H_
 #define BASE_THIRD_PARTY_CITYHASH_CITY_H_
 
-#include <stdlib.h>  // for size_t.
 #include <stdint.h>
+#include <stdlib.h>  // for size_t.
 #include <utility>
 
 // XXX(cavalcantii): Declaring it inside of the 'base' namespace allows to
@@ -78,30 +78,36 @@ typedef uint32_t uint32;
 typedef uint64_t uint64;
 typedef std::pair<uint64, uint64> uint128;
 
-inline uint64 Uint128Low64(const uint128& x) { return x.first; }
-inline uint64 Uint128High64(const uint128& x) { return x.second; }
+inline uint64 Uint128Low64(const uint128& x) {
+  return x.first;
+}
+inline uint64 Uint128High64(const uint128& x) {
+  return x.second;
+}
 
 // Hash function for a byte array.
-uint64 CityHash64(const char *buf, size_t len);
+uint64 CityHash64(const char* buf, size_t len);
 
 // Hash function for a byte array.  For convenience, a 64-bit seed is also
 // hashed into the result.
-uint64 CityHash64WithSeed(const char *buf, size_t len, uint64 seed);
+uint64 CityHash64WithSeed(const char* buf, size_t len, uint64 seed);
 
 // Hash function for a byte array.  For convenience, two seeds are also
 // hashed into the result.
-uint64 CityHash64WithSeeds(const char *buf, size_t len,
-                           uint64 seed0, uint64 seed1);
+uint64 CityHash64WithSeeds(const char* buf,
+                           size_t len,
+                           uint64 seed0,
+                           uint64 seed1);
 
 // Hash function for a byte array.
-uint128 CityHash128(const char *s, size_t len);
+uint128 CityHash128(const char* s, size_t len);
 
 // Hash function for a byte array.  For convenience, a 128-bit seed is also
 // hashed into the result.
-uint128 CityHash128WithSeed(const char *s, size_t len, uint128 seed);
+uint128 CityHash128WithSeed(const char* s, size_t len, uint128 seed);
 
 // Hash function for a byte array.  Most useful in 32-bit binaries.
-uint32 CityHash32(const char *buf, size_t len);
+uint32 CityHash32(const char* buf, size_t len);
 
 // Hash 128 input bits down to 64 bits of output.
 // This is intended to be a reasonably good hash function.
