// Copyright 2017 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef COMPONENTS_VIZ_COMMON_SURFACES_LOCAL_SURFACE_ID_H_
#define COMPONENTS_VIZ_COMMON_SURFACES_LOCAL_SURFACE_ID_H_

#include <inttypes.h>

#include <iosfwd>
#include <string>
#include <tuple>

#include "base/hash.h"
#include "base/unguessable_token.h"
#include "components/viz/common/viz_common_export.h"
#include "mojo/public/cpp/bindings/struct_traits.h"

namespace viz {
namespace mojom {
class LocalSurfaceIdDataView;
}

class ParentLocalSurfaceIdAllocator;
class ChildLocalSurfaceIdAllocator;

constexpr uint32_t kInvalidParentSequenceNumber = 0;
constexpr uint32_t kInvalidChildSequenceNumber = 0;
constexpr uint32_t kInitialParentSequenceNumber = 1;
constexpr uint32_t kInitialChildSequenceNumber = 1;
constexpr uint32_t kMaxParentSequenceNumber =
    std::numeric_limits<uint32_t>::max();
constexpr uint32_t kMaxChildSequenceNumber =
    std::numeric_limits<uint32_t>::max();

// This struct is the part of SurfaceId that can be modified by the client.
// LocalSurfaceId uniquely identifies a surface among the surfaces created by a
// particular client. A SurfaceId, which is FrameSinkId+LocalSurfaceId, uniquely
// identifies a surface globally across all clients.
//
// LocalSurfaceId consists of:
//
// (1) parent_component: This is the part of LocalSurfaceId that is generated by
// the embedder. It consists of:
//
//   (a) sequence_number: This part is incremented by the embedder at every
//   allocation.
//
//   (b) embed_token: An UnguessableToken generated by the embedder. The purpose
//   of this value is to make SurfaceIds unguessable, because FrameSinkIds and
//   LocalSurfaceIds are otherwise predictable and clients might exploit this
//   fact to embed surfaces they're not allowed to. This value is generated once
//   by ParentLocalSurfaceIdAllocator and remains constant during the lifetime
//   of the embedding, even if a new LocalSurfaceId is generated for the
//   embedded client because of some change in its state (e.g. size,
//   device scale factor, etc.), or for other reasons. If a client is
//   re-parented, then the new parent allocates a new LocalSurfaceId, with a new
//   embed token, and communicates that to the embedded client.
//
// (2) child_sequence_number: This part is incremented by the client itself.
//
// The embedder uses ParentLocalSurfaceIdAllocator to generate LocalSurfaceIds
// for the embedee. If Surface Synchronization is on, the embedee uses
// ChildLocalSurfaceIdAllocator to generate LocalSurfaceIds for itself. If
// Surface Synchronization is off, the embedee also uses
// ParentLocalSurfaceIdAllocator, as the parent doesn't generate LocalSurfaceIds
// for the child.
class VIZ_COMMON_EXPORT LocalSurfaceId {
 public:
  // Contains elements generated by the parent.
  struct VIZ_COMMON_EXPORT ParentComponent {
    // Creates an invalid ParentComponent.
    constexpr ParentComponent()
        : sequence_number(kInvalidParentSequenceNumber) {}
    constexpr ParentComponent(uint32_t sequence_number,
                              base::UnguessableToken embed_token)
        : sequence_number(sequence_number), embed_token(embed_token) {}

    constexpr bool is_valid() const {
      return sequence_number != kInvalidParentSequenceNumber &&
             !embed_token.is_empty();
    }

    // Returns whether a ParentComponent was generated after another
    // ParentComponent, i.e. whether embed tokens are equal and
    // |sequence_number| is larger.
    bool IsNewerThan(const ParentComponent& other) const;

    bool IsSameOrNewerThan(const ParentComponent& other) const;

    bool operator==(const ParentComponent& other) const;

    bool operator!=(const ParentComponent& other) const;

    uint32_t sequence_number;
    base::UnguessableToken embed_token;
  };

  constexpr LocalSurfaceId()
      : child_sequence_number_(kInvalidChildSequenceNumber) {}

  constexpr LocalSurfaceId(const LocalSurfaceId& other)
      : parent_component_(other.parent_component_),
        child_sequence_number_(other.child_sequence_number_) {}

  constexpr LocalSurfaceId(uint32_t parent_sequence_number,
                           const base::UnguessableToken& embed_token)
      : parent_component_(parent_sequence_number, embed_token),
        child_sequence_number_(kInitialChildSequenceNumber) {}

  constexpr LocalSurfaceId(uint32_t parent_sequence_number,
                           uint32_t child_sequence_number,
                           const base::UnguessableToken& embed_token)
      : parent_component_(parent_sequence_number, embed_token),
        child_sequence_number_(child_sequence_number) {}

  static constexpr LocalSurfaceId MaxSequenceId() {
    return LocalSurfaceId(kMaxParentSequenceNumber, kMaxChildSequenceNumber,
                          base::UnguessableToken());
  }

  constexpr bool is_valid() const {
    return parent_component_.is_valid() &&
           child_sequence_number_ != kInvalidChildSequenceNumber;
  }

  constexpr ParentComponent parent_component() const {
    return parent_component_;
  }

  constexpr uint32_t parent_sequence_number() const {
    return parent_component_.sequence_number;
  }

  constexpr uint32_t child_sequence_number() const {
    return child_sequence_number_;
  }

  constexpr const base::UnguessableToken& embed_token() const {
    return parent_component_.embed_token;
  }

  // The |embed_trace_id| is used as the id for trace events associated with
  // embedding this LocalSurfaceId.
  uint64_t embed_trace_id() const { return hash() << 1; }

  // The |submission_trace_id| is used as the id for trace events associated
  // with submission of a CompositorFrame to a surface with this LocalSurfaceId.
  uint64_t submission_trace_id() const { return (hash() << 1) | 1; }

  bool operator==(const LocalSurfaceId& other) const {
    return parent_component_ == other.parent_component_ &&
           child_sequence_number_ == other.child_sequence_number_;
  }

  bool operator!=(const LocalSurfaceId& other) const {
    return !(*this == other);
  }

  size_t hash() const {
    DCHECK(is_valid()) << ToString();
    return base::HashInts(
        static_cast<uint64_t>(base::HashInts(parent_component_.sequence_number,
                                             child_sequence_number_)),
        static_cast<uint64_t>(
            base::UnguessableTokenHash()(parent_component_.embed_token)));
  }

  std::string ToString() const;

  // Returns whether this LocalSurfaceId was generated after |other|.
  bool IsNewerThan(const LocalSurfaceId& other) const;

  // Returns whether this LocalSurfaceId was generated after |other| or equal to
  // it.
  bool IsSameOrNewerThan(const LocalSurfaceId& other) const;

  // Returns the smallest valid LocalSurfaceId with the same embed token as this
  // LocalSurfaceID.
  LocalSurfaceId ToSmallestId() const;

 private:
  friend struct mojo::StructTraits<mojom::LocalSurfaceIdDataView,
                                   LocalSurfaceId>;
  friend class ParentLocalSurfaceIdAllocator;
  friend class ChildLocalSurfaceIdAllocator;

  friend bool operator<(const LocalSurfaceId& lhs, const LocalSurfaceId& rhs);

  ParentComponent parent_component_;
  uint32_t child_sequence_number_;
};

VIZ_COMMON_EXPORT std::ostream& operator<<(
    std::ostream& out,
    const LocalSurfaceId& local_surface_id);

// TODO(samans): These operators are very misleading and shouldn't exist because
// they can be easily confused with IsNewerThan and its variations. They only
// exist to let us use containers that require strict ordering between every two
// elements (e.g. std::set). In no other scenario it makes sense to compare the
// numerical values of the embed tokens.
inline bool operator<(const LocalSurfaceId& lhs, const LocalSurfaceId& rhs) {
  return std::tie(lhs.parent_component_.sequence_number,
                  lhs.child_sequence_number_,
                  lhs.parent_component_.embed_token) <
         std::tie(rhs.parent_component_.sequence_number,
                  rhs.child_sequence_number_,
                  rhs.parent_component_.embed_token);
}

inline bool operator>(const LocalSurfaceId& lhs, const LocalSurfaceId& rhs) {
  return operator<(rhs, lhs);
}

inline bool operator<=(const LocalSurfaceId& lhs, const LocalSurfaceId& rhs) {
  return !operator>(lhs, rhs);
}

inline bool operator>=(const LocalSurfaceId& lhs, const LocalSurfaceId& rhs) {
  return !operator<(lhs, rhs);
}

struct LocalSurfaceIdHash {
  size_t operator()(const LocalSurfaceId& key) const { return key.hash(); }
};

}  // namespace viz

#endif  // COMPONENTS_VIZ_COMMON_SURFACES_LOCAL_SURFACE_ID_H_
