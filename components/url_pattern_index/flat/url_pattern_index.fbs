// Copyright 2017 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

namespace url_pattern_index.flat;

// Corresponds to url_pattern_index::proto::UrlPatternType.
enum UrlPatternType : ubyte {
  SUBSTRING,
  WILDCARDED,
  REGEXP,
}

// Corresponds to url_pattern_index::proto::AnchorType.
enum AnchorType : ubyte {
  NONE,
  BOUNDARY,
  SUBDOMAIN,
}

// URL rule matching options. These correspond to multiple fields of
// url_pattern_index::proto::UrlRule, but here, they are represented as flags
// of the same bitmask to allow for compact storage.
enum OptionFlag : ubyte (bit_flags) {
  IS_WHITELIST,
  APPLIES_TO_FIRST_PARTY,
  APPLIES_TO_THIRD_PARTY,
  IS_MATCH_CASE,
}

// The flat representation of a single URL rule. For more details regarding the
// fields please see the comments to url_pattern_index::proto::UrlRule.
table UrlRule {
  // Rule matching options, a bitmask consisting of OptionFlags.
  options : ubyte;

  // A bitmask of element types, same as proto::UrlRule::element_types. Enables
  // all element types except POPUP by default.
  // Note: Keep it equal to ELEMENT_TYPE_ALL-ELEMENT_TYPE_POPUP for compactness.
  element_types : ushort = 6143;

  // A bitmask of activation types, same as proto::UrlRule::activation_types.
  // Disables all activation types by default.
  activation_types : ubyte = 0;

  // Use SUBSTRING as default, since it's the most used pattern type. Same as
  // the corresponding proto::UrlRule::url_pattern_type.
  url_pattern_type : UrlPatternType = SUBSTRING;

  // Use NONE as default, since most of the rules are not anchored.
  anchor_left : AnchorType = NONE;
  anchor_right : AnchorType = NONE;

  // The list of domains to be included/excluded from the filter's affected set.
  domains_included : [string];
  domains_excluded : [string];

  // A URL pattern in the format defined by |url_pattern_type|.
  url_pattern : string;
}

// Contains an N-gram (acting as a key in a hash table) and a list of URL rules
// associated with that N-gram.
table NGramToRules {
  // A string consisting of N (up to 8) non-special characters, which are stored
  // in the lowest N non-zero bytes, lower bytes corresponding to later symbols.
  ngram : ulong;

  // The list of rules containing |ngram| as a substring of their URL pattern.
  rule_list : [UrlRule];
}

// A data structure used to select only a handful of URL rule candidates that
// need to be matched against a certain resource URL.
table UrlPatternIndex {
  // The N of an N-gram index. Note: |n| should be between 1 and 8.
  n : uint;

  // A hash table with open addressing. The keys of the table are N-grams.
  ngram_index : [NGramToRules];

  // The slot that is pointed to by all empty slots of |ngram_index| hash table.
  // Note: This is a workaround needed because null offsets are not allowed as
  // elements of FlatBuffer arrays.
  ngram_index_empty_slot : NGramToRules;

  // A list storing the rules that doesn't contain any valid N-grams in their
  // URL patterns. Contains all the REGEXP rules as well.
  // TODO(pkalinnikov): Think about better implementation for the fallback
  // index. Possibly make it a hash map and maybe merge it with the N-gram
  // index, since we can treat any sequence of characters shorter than N as an
  // N-gram with zero bytes used for padding.
  fallback_rules : [UrlRule];
}

root_type UrlPatternIndex;
