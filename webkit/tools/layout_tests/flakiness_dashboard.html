<!DOCTYPE HTML>
<html>

<head>
  <title>Webkit Layout Test History</title>
  <script>
    var pageLoadStartTime = Date.now();
  </script>
  <style>
    body {
      font-family: arial;
      font-size: 13px;
    }
    h2 {
      font-size: 16px;
      margin-bottom: .25em;
    }
    form {
      margin: 3px 0;
    }
    .test-link {
      white-space: normal;
    }
    .test-link, .options-container {
      padding: 0 2px;
    }
    .test-table {
      white-space: nowrap;
    }
    .test-table {
      width: 100%;
    }
    .test-table tr {
      border: 1px solid red;
      background-color: #E8E8E8;
    }
    .test-table tbody tr:hover {
      opacity: .7;
    }
    .test-table th {
      -webkit-user-select: none;
      -moz-user-select: none;
    }
    .link, .sortable .header-text {
      color: blue;
      text-decoration: underline;
      cursor: pointer;
    }
    .table-header-content,
    .table-header-content * {
      display: -webkit-box;
    }
    .table-header-content * {
      -webkit-box-flex: 1;
      cursor: pointer;
      white-space: normal;
    }
    .legend * {
      white-space: nowrap;
      display: inline-block;
    }
    .results {
      cursor: pointer;
      padding: 0;
      font-size: 10px;
      text-align: center;
    }
    .legend * {
      padding: 0 3px;
      margin: 3px 0;
    }
    .builders * {
      margin: 0 5px;
    }
    .builders .link {
      display: inline-block;
      white-space: nowrap;
    }
    .test-table .wrong-expectations,
    .wrong-expectations {
      background-color: #afdaff;
    }
    .P {
      background-color: #8fdf5f;
    }
    .N {
      background-color: #e0b0ff;
    }
    .C {
      background-color: #ffc343;
    }
    .T {
      background-color: #fffc6c;
    }
    .I {
      background-color: #96f;
    }
    .S {
      background-color: #c6c;
    }
    .F {
      background-color: #e98080;
    }
    .O {
      background-color: #69f;
    }
    .separator {
      border: 1px solid lightgray;
      height: 0px;
    }
    .different-platform {
      color: gray;
      font-size: 10px;
    }
    .current-builder {
      font-weight: bold;
    }
    #passing-tests {
      -webkit-column-count: 2;
      -webkit-column-gap: 25px;
      -webkit-column-rule: 1px dashed black;
      -moz-column-count: 2;
      -moz-column-gap: 25px;
      -moz-column-rule: 1px dashed black;
    }
    .not-found {
      color: red;
      font-size: large;
    }
  </style>

  <script>
  /**
   * @fileoverview Creates a dashboard for multiple runs of a given set of tests
   * on the buildbots. Pulls in JSONP-ish files with the results for running
   * tests on a given builder (i.e. ADD_RESULTS(json_here)) and the expectations
   * for all tests on all builders (i.e. ADD_EXPECTATIONS(json_here)).
   *
   * This shows flakiness of the tests as well as runtimes for slow tests.
   *
   * Also, each column in the dashboard is sortable.
   *
   * Currently, only webkit tests are supported, but adding other test types
   * should just require the following steps:
   *   -generate results.json and expectations.json for these tests
   *   -copy them to the appropriate location
   *   -add the builder name to the list of builders below.
   */

  // Default to layout_tests.
  var testType = 'layout_test_results';
  var params = window.location.search.substring(1).split('&');
  for (var i = 0; i < params.length; i++) {
    var thisParam = params[i].split('=');
    if (thisParam[0] == 'testtype') {
      testType = thisParam[1];
      break;
    }
  }

  // Map of builderName (the name shown in the waterfall)
  // to builderPath (the path used in the builder's URL)
  // TODO(ojan): Make this switch based off of the testType.
  var builders = {
    'Webkit': 'webkit-rel',
    'Webkit (dbg)(1)': 'webkit-dbg-1',
    'Webkit (dbg)(2)': 'webkit-dbg-2',
    'Webkit (dbg)(3)': 'webkit-dbg-3',
    'Webkit Linux': 'webkit-rel-linux',
    'Webkit Linux (dbg)(1)': 'webkit-dbg-linux-1',
    'Webkit Linux (dbg)(2)': 'webkit-dbg-linux-2',
    'Webkit Linux (dbg)(3)': 'webkit-dbg-linux-3',
    'Webkit Mac10.5': 'webkit-rel-mac5',
    'Webkit Mac10.5 (dbg)(1)': 'webkit-dbg-mac5-1',
    'Webkit Mac10.5 (dbg)(2)': 'webkit-dbg-mac5-2',
    'Webkit Mac10.5 (dbg)(3)': 'webkit-dbg-mac5-3'
  };

  var resultsByBuilder = {};
  // Maps test path to an array of {builder, testResults} objects.
  var testToResultsMap = {};
  var expectationsByTest = {};
  function ADD_RESULTS(builds) {
    for (var builderName in builds) {
      resultsByBuilder[builderName] = builds[builderName];
    }

    generatePage();
  }
  var BUILDER_BASE = 'http://build.chromium.org/buildbot/';
  function getPathToBuilderResultsFile(builderName) {
    return BUILDER_BASE + testType + '/' + builders[builderName] + '/';
  }
  for (var builderName in builders) {
    var script = document.createElement('script');
    script.src = getPathToBuilderResultsFile(builderName) + 'results.json';
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  var script = document.createElement('script');
  // Grab expectations file from any builder.
  script.src = getPathToBuilderResultsFile(builderName) + 'expectations.json';
  document.getElementsByTagName('head')[0].appendChild(script);

  var expectationsLoaded = false;
  function ADD_EXPECTATIONS(expectations) {
    expectationsLoaded = true;
    expectationsByTest = expectations;
    generatePage();
  }

  // CONSTANTS
  var FORWARD = 'forward';
  var BACKWARD = 'backward';
  var TEST_URL_BASE_PATH =
      'http://trac.webkit.org/projects/webkit/browser/trunk/';
  var BUILDERS_BASE_PATH =
      'http://build.chromium.org/buildbot/waterfall/builders/';
  var EXPECTATIONS_MAP = {
    'T': 'TIMEOUT',
    'C': 'CRASH',
    'P': 'PASS',
    'F': 'TEXT FAIL',
    'S': 'SIMPLIFIED',
    'I': 'IMAGE',
    'O': 'OTHER',
    'N': 'NO DATA'
  };
  var PLATFORMS = {'MAC': 'MAC', 'LINUX': 'LINUX', 'WIN': 'WIN'};
  var BUILD_TYPES = {'DEBUG': 'DBG', 'RELEASE': 'RELEASE'};

  // GLOBALS
  // The DUMMYVALUE gets shifted off the array in the first call to
  // generatePage.
  var tableHeaders = ['DUMMYVALUE', 'bugs', 'modifiers', 'expectations',
      'missing', 'extra', 'slowest run',
      'flakiness (numbers are runtimes in seconds)'];
  var currentState = {builder: null, sortOrder: FORWARD, sortColumn: 'test'};
  var perBuilderPlatformAndBuildType = {};
  var oldLocation;
  var perBuilderFailures = {};
  // Map of builder to arrays of tests that are listed in the expectations file
  // but have for that builder.
  var perBuilderWithExpectationsButNoFailures = {};

  function createResultsObjectForTest(test) {
    return {
      test: test,
      // HTML for display of the results in the flakiness column
      html: '',
      flips: 0,
      slowestTime: 0,
      meetsExpectations: true,
      isWontFix: false,
      // Sorted string of missing expectations
      missing: '',
      // String of extra expectations (i.e. expectations that never occur).
      extra: '',
      // HTML for bug IDs for this test for all platforms
      bugsHTML: '',
      // HTML for expectations for this test for all platforms
      expectationsHTML: '',
      // HTML for modifiers for this test for all platforms
      modifiersHTML: ''
    };
  }

  function getMatchingElement(stringToMatch, elementsMap) {
    for (var element in elementsMap) {
      if (stringContains(stringToMatch, elementsMap[element]))
        return element;
    }
  }

  function stringContains(a, b) {
    return a.indexOf(b) != -1;
  }

  function trimString(str) {
    return str.replace(/^\s+|\s+$/g, '');
  }

  function anyKeyInString(object, string) {
    for (var key in object) {
      if (stringContains(string, key))
        return true;
    }
    return false;
  }

  /**
   * Returns whether the given string of modifiers applies to the platform and
   * build type of the given builder.
   */
  function hasPlatformAndBuildType(builderName, modifiers) {
    var platformAndBuildType = getPlatFormAndBuildType(builderName);
    var hasThisPlatform = stringContains(modifiers,
        platformAndBuildType.platform);
    var hasThisBuildType = stringContains(modifiers,
        platformAndBuildType.buildType);

    var hasAnyPlatform = anyKeyInString(PLATFORMS, modifiers);
    var hasAnyBuildType = anyKeyInString(BUILD_TYPES, modifiers);

    return (!hasAnyBuildType || hasThisBuildType) &&
        (!hasAnyPlatform || hasThisPlatform);
  }

  function getPlatFormAndBuildType(builderName) {
    if (!perBuilderPlatformAndBuildType[builderName]) {
      // If the build name does not contain a platform
      // or build type, assume Windows Release.
      var currentBuildUppercase = builderName.toUpperCase();
      var platform = getMatchingElement(currentBuildUppercase, PLATFORMS) ||
          'WIN';
      var buildType = getMatchingElement(currentBuildUppercase, BUILD_TYPES) ||
          'RELEASE';
      perBuilderPlatformAndBuildType[builderName] = {platform: platform,
          buildType: buildType};
    }
    return perBuilderPlatformAndBuildType[builderName];
  }

  /**
   * Returns whether any of the modifiers in the array have the correct
   * platform and build type for the given builder.
   */
  function getModifierThatHasPlatformAndBuildType(builderName, modifiersArray) {
    for (var i = 0; i < modifiersArray.length; i++) {
      if (hasPlatformAndBuildType(builderName, modifiersArray[i].modifiers))
        return modifiersArray[i];
    }
    return null;
  }

  /**
   * Returns the expectation string for the given single character result.
   * This string should match the expectations that are put into
   * test_expectations.py.
   *
   * For example, if we start explicitly listing IMAGE result failures,
   * this function should start returning 'IMAGE'.
   */
  function getExpectationsFileStringForResult(result) {
    // For the purposes of comparing against the expecations of a test,
    // consider image/simplified diff failures as just failures since
    // the test_expectations file doesn't treat them specially.
    if (result == 'F' || result == 'S' || result == 'I')
      return 'FAIL';

    if (result == 'N' || result == 'O')
      return '';

    return EXPECTATIONS_MAP[result];
  }

  // Map of all tests to true values. This is just so we can have the list of
  // all tests across all the builders.
  var allTests;

  /**
   * Returns a map of all tests to true values. This is just so we can have the
   * list of all tests across all the builders.
   */
  function getAllTests() {
    if (!allTests) {
      allTests = {};
      for (var builder in builders) {
        addTestsForBuilder(builder, allTests);
      }
    }
    return allTests;
  }

  /**
   * Adds all the tests for the given builder to the testMapToPopulate.
   */
  function addTestsForBuilder(builder, testMapToPopulate) {
    var tests = resultsByBuilder[builder].tests;
    for (var test in tests) {
      testMapToPopulate[test] = true;
    }
  }

  // Map of all tests to true values by platform and build type.
  // e.g. allTestsByPlatformAndBuildType['WIN']['DEBUG'] will have the union
  // of all tests run on the win-debug builders.
  var allTestsByPlatformAndBuildType = {};
  for (var platform in PLATFORMS) {
    allTestsByPlatformAndBuildType[platform] = {};
  }

  /**
   * Map of all tests to true values by platform and build type.
   * e.g. allTestsByPlatformAndBuildType['WIN']['DEBUG'] will have the union
   * of all tests run on the win-debug builders.
   */
  function getAllTestsWithSamePlatformAndBuildType(builder) {
    var buildInfo = getPlatFormAndBuildType(builder);
    var platform = buildInfo.platform;
    var buildType = buildInfo.buildType;

    if (!allTestsByPlatformAndBuildType[platform][buildType]) {
      var tests = {};
      for (var thisBuilder in builders) {
        var thisBuilderBuildInfo = getPlatFormAndBuildType(thisBuilder);
        if (thisBuilderBuildInfo.buildType == buildType &&
            thisBuilderBuildInfo.platform == platform) {
          addTestsForBuilder(thisBuilder, tests);
        }
      }
      allTestsByPlatformAndBuildType[platform][buildType] = tests;
    }

    return allTestsByPlatformAndBuildType[platform][buildType];
  }

  /**
   * Adds the given test and path to the appropriate objects depending on
   * whether the modifiers match the builders platform and buildType.
   */
  function addTestAndExpectations(test, prefixPath, builder, expectationsMap,
      expectations, testPrefixes) {
    var modifiersForBuilder =
        getModifierThatHasPlatformAndBuildType(builder, expectations);
    if (modifiersForBuilder) {
      if (getAllTestsWithSamePlatformAndBuildType(builder)[test]) {
        expectationsMap[test] = expectations;
        testPrefixes[test] = prefixPath;
      } else if (!stringContains(modifiersForBuilder.modifiers, 'SKIP') &&
          !modifiersForBuilder.expectations.match(/^\s*PASS\s*$/)) {
        // Don't include skip tests here as they'll look the same as a test
        // that passes on all builders.
        // Also don't include tests that are only expected to pass, e.g.
        // SLOW : foo/bar/baz.html = PASS
        // TODO(ojan): Should we also exclude WONTFIX tests here?
        perBuilderWithExpectationsButNoFailures[builder].push(test);
      }
      return true;
    }
    return false;
  }

  /**
   * Naive check that path points to a directory.
   */
  function isDirectory(path) {
    return !stringContains(path, '.')
  }

  function addHTMLToIndividualOptionsArray(array, html, isCurrentPlatform) {
    if (html) {
      array.push('<div class="option' +
          (isCurrentPlatform ? '' : ' different-platform') + '">' + html +
          '</div>');
    }
  }

  function addHtmlToOptionsArrays(htmlArrays, expectations, modifiers, bugs,
      isCurrentPlatform) {
    addHTMLToIndividualOptionsArray(htmlArrays.expectations, expectations,
        isCurrentPlatform);
    addHTMLToIndividualOptionsArray(htmlArrays.modifiers, modifiers,
        isCurrentPlatform);
    addHTMLToIndividualOptionsArray(htmlArrays.bugs, getHtmlForBugs(bugs),
        isCurrentPlatform);
  }

  function processTestRunsForBuilder(builderName) {
    if (perBuilderFailures[builderName])
      return;

    var failures = [];
    var allTests = getAllTests();

    var expectationsMap = {};
    for (var test in allTests) {
      if (expectationsByTest[test])
        expectationsMap[test] = expectationsByTest[test];
    }

    var testPrefixes = {};
    perBuilderWithExpectationsButNoFailures[builderName] = [];
    for (var path in expectationsByTest) {
      var expectations = expectationsByTest[path];
      if (!isDirectory(path) &&
          addTestAndExpectations(path, path, builderName, expectationsMap,
              expectations, testPrefixes)) {
        continue;
      }
      // Test path doesn't match a specific test, see if it prefix matches
      // any test.
      for (var test in allTests) {
        if (stringContains(test, path) &&
            (!testPrefixes[test] ||
             !stringContains(testPrefixes[test], path))) {
          addTestAndExpectations(test, path, builderName, expectationsMap,
              expectations, testPrefixes);
        }
      }
    }
    perBuilderWithExpectationsButNoFailures[builderName].sort();

    var allTestsForThisBuilder = resultsByBuilder[builderName].tests;
    for (var test in allTestsForThisBuilder) {
      var resultsForTest = createResultsObjectForTest(test);

      if (expectationsMap[test] && expectationsMap[test].length) {
        var expectationsArray = expectationsMap[test];
        var htmlArrays = {};
        htmlArrays.expectations = [];
        htmlArrays.modifiers = [];
        htmlArrays.bugs = [];

        var thisBuilderExpectations;
        var thisBuilderModifiers;
        for (var i = 0; i < expectationsArray.length; i++) {
          var modifiers = expectationsArray[i].modifiers;
          var bugs = modifiers.match(/BUG\d+/g);
          if (bugs) {
            for (var j = 0; j < bugs.length; j++) {
              modifiers = modifiers.replace(bugs[j], '');
            }
            modifiers = trimString(modifiers);
            bugs = bugs.join(' ');
          } else {
            bugs = '';
          }

          var expectations = expectationsArray[i].expectations;
          if (hasPlatformAndBuildType(builderName, modifiers)) {
            resultsForTest.bugs = bugs;
            resultsForTest.expectations = expectations;
            resultsForTest.modifiers = modifiers;
            // TODO(ojan): Also specially mark slow tests that should be marked
            // as slow or should have the slow modifier removed.
            resultsForTest.isWontFix = stringContains(modifiers, 'WONTFIX');
          } else {
            addHtmlToOptionsArrays(htmlArrays, expectations, modifiers, bugs,
                false);
          }
        }

        if (resultsForTest.expectations) {
          addHtmlToOptionsArrays(htmlArrays, resultsForTest.expectations,
              resultsForTest.modifiers, resultsForTest.bugs, true);
        }

        resultsForTest.bugsHTML +=
            htmlArrays.bugs.join('<div class=separator></div>');
        resultsForTest.expectationsHTML +=
            htmlArrays.expectations.join('<div class=separator></div>');
        resultsForTest.modifiersHTML +=
            htmlArrays.modifiers.join('<div class=separator></div>');
      }

      var results = resultsByBuilder[builderName].tests[test].results.split('');

      var unexpectedExpectations = [];
      var resultsMap = {}
      for (var i = 0; i < results.length - 1; i++) {
        if (results[i] != results[i + 1])
          resultsForTest.flips++;

        var expectation = getExpectationsFileStringForResult(results[i]);
        resultsMap[expectation] = true;
      }

      var expectationsArray = resultsForTest.expectations ?
          resultsForTest.expectations.split(' ') : [];
      var extraExpectations = expectationsArray.filter(
          function(element) {
              return element && !resultsMap[element] &&
                  !stringContains(element, 'BUG');
          });

      var missingExpectations = [];
      for (var result in resultsMap) {
        var hasExpectation = false;
        for (var i = 0; i < expectationsArray.length; i++) {
          if (result == expectationsArray[i])
            hasExpectation = true;
        }
        if (!hasExpectation)
          missingExpectations.push(result);
      }

      // TODO(ojan): Make this detect the case of a test that has NODATA,
      // then fails for a few runs, then passes for the rest. We should
      // consider that as meetsExpectations since every new test will have
      // that pattern.
      resultsForTest.meetsExpectations =
          !missingExpectations.length && !extraExpectations.length;
      resultsForTest.missing = missingExpectations.sort().join(' ');
      resultsForTest.extra = extraExpectations.sort().join(' ');

      var times = resultsByBuilder[builderName].tests[test].times;
      resultsForTest.slowestTime = Math.max.apply(null, times)

      resultsForTest.html = getHtmlForTestResults(builderName, test);

      failures.push(resultsForTest);

      if (!testToResultsMap[test])
        testToResultsMap[test] = [];
      testToResultsMap[test].push(
          {builder: builderName, results: resultsForTest});
    }

    perBuilderFailures[builderName] = failures;
  }

  function hasExpectations(expectations, resultName) {
    if (resultName == 'NO DATA')
      return true;

    if (!expectations)
      return false;

    return stringContains(expectations, resultName);
  }

  var bugUrlPrefix = '<a href="http://';
  var bugUrlPostfix = '/$1">$1</a> ';
  var internalBugReplaceValue = bugUrlPrefix + 'b' + bugUrlPostfix;
  var externalBugReplaceValue = bugUrlPrefix + 'crbug.com' + bugUrlPostfix;

  /**
   * Returns the BUG modifiers linking to the bug.
   * Bugs with 4 or 5 digits are crbug.com bugs. Bugs with 6 or 7 digits
   * are internal google bugs.
   */
  function getHtmlForBugs(bugs) {
    bugs = bugs.replace(/BUG(\d{4})(\ |$)/g, externalBugReplaceValue);
    bugs = bugs.replace(/BUG(\d{5})(\ |$)/g, externalBugReplaceValue);
    bugs = bugs.replace(/BUG(\d{6})(\ |$)/g, internalBugReplaceValue);
    bugs = bugs.replace(/BUG(\d{7})(\ |$)/g, internalBugReplaceValue);
    return bugs;
  }

  function didTestPassAllRuns(builderName, testPath) {
    var numBuilds = resultsByBuilder[builderName].buildNumbers.length;
    var passingResults = Array(numBuilds + 1).join('P');
    var results = resultsByBuilder[builderName].tests[testPath].results;
    return results == passingResults;
  }

  function loadBuilderPageForBuildNumber(builderName, buildNumber) {
    window.open(BUILDERS_BASE_PATH + builderName + '/builds/' + buildNumber);
  }

  function getHtmlForTestResults(builderName, testPath) {
    var html = '';
    var test = resultsByBuilder[builderName].tests[testPath];
    var results = test.results.split('');
    var times = test.times;
    var buildNumbers = resultsByBuilder[builderName].buildNumbers;
    for (var i = 0; i < results.length; i++) {
      var buildNumber = buildNumbers[i];
      var innerHTML = times[i] > 0 ? times[i] : '&nbsp;';
      html += '<td title="Build:' + buildNumber + '" class="results ' +
          results[i] + '" onclick=\'loadBuilderPageForBuildNumber("' +
          builderName + '","' + buildNumber + '")\'>' + innerHTML + '</td>';
    }
    return html;
  }

  function getHTMLForTestsWithExpectationsButNoFailures(builder) {
    var tests = perBuilderWithExpectationsButNoFailures[builder];
    if (!tests.length)
      return '';

    var buildInfo = getPlatFormAndBuildType(builder);
    return '<h2>Have expectations for ' + buildInfo.platform + '-' +
          buildInfo.buildType + ' but have not failed in last ' +
          resultsByBuilder[builderName].buildNumbers.length +
          ' runs.</h2><div id="passing-tests"><div>' +
          tests.join('</div><div>') + '</div></div>';
  }

  /**
   * Returns whether we should exclude test results from the test table.
   * Note that we never want to exclude tests when we're in the individual
   * tests view of the dashboard since the user is explicitly listing tests
   * to view.
   */
  function shouldHideTest(testResult) {
    return !currentState.tests &&
        (test.isWontFix && !currentState.showWontFix ||
         test.meetsExpectations && !currentState.showCorrectExpectations);
  }

  function getHTMLForSingleTestRow(test, opt_builder) {
    if (shouldHideTest(test)) {
      // The innerHTML call is considerably faster if we exclude the rows for
      // items we're not showing than if we hide them using display:none.
      return '';
    }

    // If opt_builder is provided, we're just viewing a single test
    // with results for many builders, so the first column is builder names
    // instead of test paths.
    var testCellHTML = opt_builder ? opt_builder :
      '<span class="link" onclick="setState(\'tests\', \'' + test.test +
      '\');return false;">' + test.test + '</span>';

    return '<tr class="' +
      (test.meetsExpectations ? '' : 'wrong-expectations') +
      // TODO(ojan): If a test is a chrome/ or a pending/ test, point to
      // src.chromium.org instead of trac.webkit.org.
      '"><td class=test-link>' + testCellHTML +
      '</td><td class=options-container>' + test.bugsHTML +
      '</td><td class=options-container>' + test.modifiersHTML +
      '</td><td class=options-container>' + test.expectationsHTML +
      '</td><td>' + test.missing +
      '</td><td>' + test.extra +
      '</td><td>' + (test.slowestTime ? test.slowestTime + 's' : '') +
      '</td>' +
      test.html +
      '</tr>';
  }

  function getHTMLForTestTable(rowsHTML) {
    var html = '<div class=legend>';
    for (var expectation in EXPECTATIONS_MAP) {
      html += '<span class=' + expectation + '>' +
          EXPECTATIONS_MAP[expectation] + '</span>';
    }
    html += '<span class=wrong-expectations>WRONG EXPECTATIONS</span>' +
        '</div><table class=test-table><thead><tr>';
    for (var i = 0; i < tableHeaders.length; i++) {
      // Use the first word of the header title as the sortkey
      var thisSortValue = tableHeaders[i].split(' ')[0];
      var arrowHTML = thisSortValue == currentState.sortColumn ?
          '<span class=' + currentState.sortOrder + '>' +
          (currentState.sortOrder == FORWARD ? '&uarr;' : '&darr;' ) +
          '</span>' :
          '';
      html += '<th sortValue=' + thisSortValue +
          // Extend last th through all the rest of the columns.
          (i == tableHeaders.length - 1 ? ' colspan=10000' : '') +
          // Extra span here is so flex boxing actually centers.
          // There's probably a better way to do this with CSS only though.
          '><div class=table-header-content><span></span>' + arrowHTML +
          '<span class=header-text>' + tableHeaders[i] + '</span>' +
          arrowHTML + '</div></th>';
    }
    return html + '</tr></thead><tbody>' + rowsHTML + '</tbody></table>';
  }

  function setFullPageHTML(html) {
    var startTime = Date.now();
    // InnerHTML to a div that's not in the document. This is
    // ~300ms faster in Safari 4 and Chrome 4 on mac.
    var div = document.createElement('div');
    div.innerHTML = html;
    document.body.innerHTML = '';
    document.body.appendChild(div);
    logTime('Time to innerHTML', startTime);
  }

  function getAlphanumericCompare(column, reverse) {
    return getReversibleCompareFunction(function(a, b) {
      // Put null entries at the bottom
      var a = a[column] ? String(a[column]) : 'z';
      var b = b[column] ? String(b[column]) : 'z';

      if (a < b)
        return -1;
      else if (a == b)
        return 0;
      else
        return 1;
    }, reverse);
  }

  function getNumericSort(column, reverse) {
    return getReversibleCompareFunction(function(a, b) {
      a = parseFloat(a[column]);
      b = parseFloat(b[column]);
      return a - b;
    }, reverse);
  }

  function getReversibleCompareFunction(compare, reverse) {
    return function(a, b) {
      return compare(reverse ? b : a, reverse ? a : b);
    }
  }

  function changeSort(e) {
    var target = e.currentTarget;
    e.preventDefault();

    var sortValue = target.getAttribute('sortValue');
    while (target && target.tagName != 'TABLE') {
      target = target.parentNode;
    }

    var sort = 'sortColumn';
    var orderKey = 'sortOrder';
    if (sortValue == currentState[sort] && currentState[orderKey] == FORWARD)
      order = BACKWARD;
    else
      order = FORWARD;

    setState(sort, sortValue);
    setState(orderKey, order);
  }

  function sortTests(tests, column, order) {
    var resultsProperty, sortFunctionGetter;
    if (column == 'flakiness') {
      sortFunctionGetter = getNumericSort;
      resultsProperty = 'flips';
    } else if (column == 'slowest') {
      sortFunctionGetter = getNumericSort;
      resultsProperty = 'slowestTime';
    } else {
      sortFunctionGetter = getAlphanumericCompare;
      resultsProperty = column;
    }

    tests.sort(sortFunctionGetter(resultsProperty, order == BACKWARD));
  }

  function generatePage() {
    var startTime = Date.now();
    currentPlatformAndBuildType = null;
    oldLocation = window.location.toString();
    var hash = window.location.hash;
    if (hash) {
      var hashParts = hash.slice(1).split('&');
      var urlHasTests = false;
      for (var i = 0; i < hashParts.length; i++) {
        var itemParts = hashParts[i].split('=');
        // TODO(ojan): Validate keys and values to avoid XSS holes.
        var key = itemParts[0];
        currentState[key] = decodeURIComponent(itemParts[1]);
        if (key == 'tests') {
          urlHasTests = true;
        } else if (key == 'showWontFix' || key == 'showCorrectExpectations') {
          // Convert these values to booleans so we don't have to do this check
          // in a bunch of places.
          currentState[key] = currentState[key] == 'true';
        }
      }
    }

    // Only continue if all the JSON files have loaded.
    if (!expectationsLoaded)
      return;

    for (var build in builders) {
      if (!resultsByBuilder[build])
        return;
    }

    tableHeaders.shift();
    if (urlHasTests) {
      tableHeaders.unshift('builder');

      generatePageForIndividualTests(currentState.tests.split(','));
    } else {
      tableHeaders.unshift('test');

      if (!currentState.builder) {
        for (var builder in builders) {
          currentState.builder = builder;
          break;
        }
      }
      generatePageForBuilder(currentState.builder);
    }
    logTime('Time to generate page (includes innerHTML)', startTime);
  }

  function generatePageForIndividualTests(tests) {
    // TODO: Add link to trac from individual test page
    // TODO: Make links on builder pages to tests be to the individual test page
    for (var builder in builders)
      processTestRunsForBuilder(builder);

    var html = getHTMLForNavBar() +
      '<b>IF A BUILDER IS NOT LISTED THAT MEANS THE ' +
      'BUILDER DOES NOT RUN THAT TEST OR ALL RUNS OF THE TEST PASSED.</b>';

    for (var i = 0; i < tests.length; i++) {
      html += '<h2>' + tests[i] + '</h2>';

      var testResults = testToResultsMap[tests[i]];
      if (testResults && testResults.length) {
        var tableRowsHTML = '';
        for (var j = 0; j < testResults.length; j++) {
          tableRowsHTML += getHTMLForSingleTestRow(testResults[j].results,
              testResults[j].builder);
        }
        html += getHTMLForTestTable(tableRowsHTML);
      } else {
        html +='<div class="not-found">Test not found. Either it does not ' +
            'exist or it passes on all platforms.</div>';
      }
    }
    setFullPageHTML(html);

    document.getElementById('tests-input').value = currentState.tests;
  }

  function getHTMLForNavBar(opt_builderName) {
    var html = '<div class=builders>';
    for (var builder in builders) {
      var className = builder == opt_builderName ? 'current-builder' : 'link';
      html += '<span class=' + className +
          ' onclick=\'setState("builder", "' + builder + '")\'>' +
          builder + '</span>';
    }
    return html + '</div>' +
        '<form onsubmit="setState(\'tests\', tests.value);return false;">' +
        'Show tests on all platforms (slow): <input name=tests ' +
        'placeholder="LayoutTests/foo/bar.html,LayoutTests/foo/baz.html" ' +
        'id=tests-input style="width:60%"></form>';
  }

  function getLinkHTMLToToggleState(key, linkText) {
    var isTrue = currentState[key];
    return '<span class=link onclick="setState(\'' + key + '\', \'' + !isTrue +
        '\')">' + (isTrue ? 'Hide' : 'Show') + ' ' + linkText + '</span>';
  }

  function generatePageForBuilder(builderName) {
    processTestRunsForBuilder(builderName);

    var tableRowsHTML = '';
    var results = perBuilderFailures[builderName];
    sortTests(results, currentState.sortColumn, currentState.sortOrder);
    for (var i = 0; i < results.length; i++) {
      tableRowsHTML += getHTMLForSingleTestRow(results[i]);
    }

    var html = getHTMLForNavBar(builderName) +
        getHTMLForTestsWithExpectationsButNoFailures(builderName) +
        '<h2>Failing tests</h2>' +
        getLinkHTMLToToggleState('showWontFix', 'WONTFIX tests') + ' | ' +
        getLinkHTMLToToggleState('showCorrectExpectations',
            'tests with correct expectations') +
        '<b> | All columns are sortable. | Skipped tests are not listed. | ' +
        'Flakiness reader order is newer --> older runs.</b>' +
        getHTMLForTestTable(tableRowsHTML);

    setFullPageHTML(html);

    var ths = document.getElementsByTagName('th');
    for (var i = 0; i < ths.length; i++) {
      ths[i].addEventListener('click', changeSort, false);
      ths[i].className = "sortable";
    }
  }

  function setState(key, value) {
    currentState[key] = value;

    if (key == 'tests') {
      currentState.builder = null;
      currentState.sortColumn = null;
      currentState.sortOrder = null;
      currentState.showWontFix = null;
      currentState.showCorrectExpectations = null;
    } else {
      currentState.tests = null;
    }

    var newLocation = window.location.pathname + '#';
    if (currentState.tests) {
      newLocation += 'tests=' + currentState.tests;
    } else {
      newLocation += 'builder=' + currentState.builder + '&' +
        'sortColumn=' + currentState.sortColumn + '&' +
        'sortOrder=' + currentState.sortOrder + '&' +
        'showWontFix=' + currentState.showWontFix + '&' +
        'showCorrectExpectations=' + currentState.showCorrectExpectations;
    }

    window.location.replace(newLocation);
    generatePage();
  }

  function logTime(msg, startTime) {
    console.log(msg + ': ' + (Date.now() - startTime));
  }

  window.onload = function() {
    // This doesn't seem totally accurate as there is a race between
    // onload firing and the last script tag being executed.
    logTime('Time to load JS', pageLoadStartTime);
    setInterval(function() {
      if (oldLocation != window.location)
        generatePage();
    }, 100);
  }
  </script>
</head>

<body></body>
</html>
